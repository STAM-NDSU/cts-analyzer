/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.MathException;/** * An interface for Mann-Whitney U test (also called Wilcoxon rank-sum test). * * @version $Id$ */public interface MannWhitneyUTest {    /**     * Computes the <a     * href="http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U"> Mann-Whitney     * U statistic</a> comparing mean for two independent samples possibly of     * different length.     * <p>     * This statistic can be used to perform a Mann-Whitney U test evaluating     * the null hypothesis that the two independent samples has equal mean.     * </p>     * <p>     * Let X<sub>i</sub> denote the i'th individual of the first sample and     * Y<sub>j</sub> the j'th individual in the second sample. Note that the     * samples would often have different length.     * </p>     * <p>     * <strong>Preconditions</strong>:     * <ul>     * <li>All observations in the two samples are independent.</li>     * <li>The observations are at least ordinal (continuous are also ordinal).</li>     * </ul>     * </p>     *     * @param x     *            the first sample     * @param y     *            the second sample     * @return mannWhitneyU statistic     * @throws IllegalArgumentException     *             if preconditions are not met     */    double mannWhitneyU(final double[] x, final double[] y)            throws IllegalArgumentException;    /**     * Returns the asymptotic <i>observed significance level</i>, or <a href=     * "http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a <a     * href="http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U"> Mann-Whitney     * U statistic</a> comparing mean for two independent samples.     * <p>     * Let X<sub>i</sub> denote the i'th individual of the first sample and     * Y<sub>j</sub> the j'th individual in the second sample. Note that the     * samples would often have different length.     * </p>     * <p>     * <strong>Preconditions</strong>:     * <ul>     * <li>All observations in the two samples are independent.</li>     * <li>The observations are at least ordinal (continuous are also ordinal).</li>     * </ul>     * </p>     *     * @param x     *            the first sample     * @param y     *            the second sample     * @return asymptotic p-value     * @throws IllegalArgumentException     *             if preconditions are not met     * @throws MathException     *             if an error occurs computing the p-value     */    double mannWhitneyUTest(final double[] x, final double[] y)            throws IllegalArgumentException, MathException;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.MathException;/** * An interface for Chi-Square tests. * <p>This interface handles only known distributions. If the distribution is * unknown and should be provided by a sample, then the {@link UnknownDistributionChiSquareTest * UnknownDistributionChiSquareTest} extended interface should be used instead.</p> * @version $Id$ */public interface ChiSquareTest {     /**     * Computes the <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm">     * Chi-Square statistic</a> comparing <code>observed</code> and <code>expected</code>     * frequency counts.     * <p>     * This statistic can be used to perform a Chi-Square test evaluating the null hypothesis that     *  the observed counts follow the expected distribution.</p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Expected counts must all be positive.     * </li>     * <li>Observed counts must all be >= 0.     * </li>     * <li>The observed and expected arrays must have the same length and     * their common length must be at least 2.     * </li></ul></p><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed array of observed frequency counts     * @param expected array of expected frequency counts     * @return chiSquare statistic     * @throws IllegalArgumentException if preconditions are not met     */    double chiSquare(double[] expected, long[] observed)        throws IllegalArgumentException;    /**     * Returns the <i>observed significance level</i>, or <a href=     * "http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a     * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm">     * Chi-square goodness of fit test</a> comparing the <code>observed</code>     * frequency counts to those in the <code>expected</code> array.     * <p>     * The number returned is the smallest significance level at which one can reject     * the null hypothesis that the observed counts conform to the frequency distribution     * described by the expected counts.</p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Expected counts must all be positive.     * </li>     * <li>Observed counts must all be >= 0.     * </li>     * <li>The observed and expected arrays must have the same length and     * their common length must be at least 2.     * </li></ul></p><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed array of observed frequency counts     * @param expected array of expected frequency counts     * @return p-value     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs computing the p-value     */    double chiSquareTest(double[] expected, long[] observed)        throws IllegalArgumentException, MathException;    /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm">     * Chi-square goodness of fit test</a> evaluating the null hypothesis that the observed counts     * conform to the frequency distribution described by the expected counts, with     * significance level <code>alpha</code>.  Returns true iff the null hypothesis can be rejected     * with 100 * (1 - alpha) percent confidence.     * <p>     * <strong>Example:</strong><br>     * To test the hypothesis that <code>observed</code> follows     * <code>expected</code> at the 99% level, use </p><p>     * <code>chiSquareTest(expected, observed, 0.01) </code></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Expected counts must all be positive.     * </li>     * <li>Observed counts must all be >= 0.     * </li>     * <li>The observed and expected arrays must have the same length and     * their common length must be at least 2.     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul></p><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed array of observed frequency counts     * @param expected array of expected frequency counts     * @param alpha significance level of the test     * @return true iff null hypothesis can be rejected with confidence     * 1 - alpha     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean chiSquareTest(double[] expected, long[] observed, double alpha)        throws IllegalArgumentException, MathException;    /**     *  Computes the Chi-Square statistic associated with a     * <a href="http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm">     *  chi-square test of independence</a> based on the input <code>counts</code>     *  array, viewed as a two-way table.     * <p>     * The rows of the 2-way table are     * <code>count[0], ... , count[count.length - 1] </code></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>All counts must be >= 0.     * </li>     * <li>The count array must be rectangular (i.e. all count[i] subarrays     *  must have the same length).     * </li>     * <li>The 2-way table represented by <code>counts</code> must have at     *  least 2 columns and at least 2 rows.     * </li>     * </li></ul></p><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param counts array representation of 2-way table     * @return chiSquare statistic     * @throws IllegalArgumentException if preconditions are not met     */    double chiSquare(long[][] counts)    throws IllegalArgumentException;    /**     * Returns the <i>observed significance level</i>, or <a href=     * "http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a     * <a href="http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm">     * chi-square test of independence</a> based on the input <code>counts</code>     * array, viewed as a two-way table.     * <p>     * The rows of the 2-way table are     * <code>count[0], ... , count[count.length - 1] </code></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>All counts must be >= 0.     * </li>     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length).     * </li>     * <li>The 2-way table represented by <code>counts</code> must have at least 2 columns and     *        at least 2 rows.     * </li>     * </li></ul></p><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param counts array representation of 2-way table     * @return p-value     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs computing the p-value     */    double chiSquareTest(long[][] counts)    throws IllegalArgumentException, MathException;    /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm">     * chi-square test of independence</a> evaluating the null hypothesis that the classifications     * represented by the counts in the columns of the input 2-way table are independent of the rows,     * with significance level <code>alpha</code>.  Returns true iff the null hypothesis can be rejected     * with 100 * (1 - alpha) percent confidence.     * <p>     * The rows of the 2-way table are     * <code>count[0], ... , count[count.length - 1] </code></p>     * <p>     * <strong>Example:</strong><br>     * To test the null hypothesis that the counts in     * <code>count[0], ... , count[count.length - 1] </code>     *  all correspond to the same underlying probability distribution at the 99% level, use </p><p>     * <code>chiSquareTest(counts, 0.01) </code></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>All counts must be >= 0.     * </li>     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length).     * </li>     * <li>The 2-way table represented by <code>counts</code> must have at least 2 columns and     *        at least 2 rows.     * </li>     * </li></ul></p><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param counts array representation of 2-way table     * @param alpha significance level of the test     * @return true iff null hypothesis can be rejected with confidence     * 1 - alpha     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean chiSquareTest(long[][] counts, double alpha)    throws IllegalArgumentException, MathException;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.MathException;/** * An interface for Chi-Square tests for unknown distributions. * <p>Two samples tests are used when the distribution is unknown <i>a priori</i> * but provided by one sample. We compare the second sample against the first.</p> * * @version $Id$ * @since 1.2 */public interface UnknownDistributionChiSquareTest extends ChiSquareTest {    /**     * <p>Computes a     * <a href="http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/chi2samp.htm">     * Chi-Square two sample test statistic</a> comparing bin frequency counts     * in <code>observed1</code> and <code>observed2</code>.  The     * sums of frequency counts in the two samples are not required to be the     * same.  The formula used to compute the test statistic is</p>     * <code>     * &sum;[(K * observed1[i] - observed2[i]/K)<sup>2</sup> / (observed1[i] + observed2[i])]     * </code> where     * <br/><code>K = &sqrt;[&sum(observed2 / &sum;(observed1)]</code>     * </p>     * <p>This statistic can be used to perform a Chi-Square test evaluating the null hypothesis that     * both observed counts follow the same distribution.</p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Observed counts must be non-negative.     * </li>     * <li>Observed counts for a specific bin must not both be zero.     * </li>     * <li>Observed counts for a specific sample must not all be 0.     * </li>     * <li>The arrays <code>observed1</code> and <code>observed2</code> must have the same length and     * their common length must be at least 2.     * </li></ul></p><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed1 array of observed frequency counts of the first data set     * @param observed2 array of observed frequency counts of the second data set     * @return chiSquare statistic     * @throws IllegalArgumentException if preconditions are not met     */    double chiSquareDataSetsComparison(long[] observed1, long[] observed2)        throws IllegalArgumentException;    /**     * <p>Returns the <i>observed significance level</i>, or <a href=     * "http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a Chi-Square two sample test comparing     * bin frequency counts in <code>observed1</code> and     * <code>observed2</code>.     * </p>     * <p>The number returned is the smallest significance level at which one     * can reject the null hypothesis that the observed counts conform to the     * same distribution.     * </p>     * <p>See {@link #chiSquareDataSetsComparison(long[], long[])} for details     * on the formula used to compute the test statistic. The degrees of     * of freedom used to perform the test is one less than the common length     * of the input observed count arrays.     * </p>     * <strong>Preconditions</strong>: <ul>     * <li>Observed counts must be non-negative.     * </li>     * <li>Observed counts for a specific bin must not both be zero.     * </li>     * <li>Observed counts for a specific sample must not all be 0.     * </li>     * <li>The arrays <code>observed1</code> and <code>observed2</code> must     * have the same length and     * their common length must be at least 2.     * </li></ul><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed1 array of observed frequency counts of the first data set     * @param observed2 array of observed frequency counts of the second data set     * @return p-value     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs computing the p-value     */    double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)      throws IllegalArgumentException, MathException;    /**     * <p>Performs a Chi-Square two sample test comparing two binned data     * sets. The test evaluates the null hypothesis that the two lists of     * observed counts conform to the same frequency distribution, with     * significance level <code>alpha</code>.  Returns true iff the null     * hypothesis can be rejected with 100 * (1 - alpha) percent confidence.     * </p>     * <p>See {@link #chiSquareDataSetsComparison(long[], long[])} for     * details on the formula used to compute the Chisquare statistic used     * in the test. The degrees of of freedom used to perform the test is     * one less than the common length of the input observed count arrays.     * </p>     * <strong>Preconditions</strong>: <ul>     * <li>Observed counts must be non-negative.     * </li>     * <li>Observed counts for a specific bin must not both be zero.     * </li>     * <li>Observed counts for a specific sample must not all be 0.     * </li>     * <li>The arrays <code>observed1</code> and <code>observed2</code> must     * have the same length and their common length must be at least 2.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed1 array of observed frequency counts of the first data set     * @param observed2 array of observed frequency counts of the second data set     * @param alpha significance level of the test     * @return true iff null hypothesis can be rejected with confidence     * 1 - alpha     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean chiSquareTestDataSetsComparison(long[] observed1, long[] observed2, double alpha)      throws IllegalArgumentException, MathException;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.MathException;import org.apache.commons.math.stat.descriptive.StatisticalSummary;/** * An interface for Student's t-tests. * <p> * Tests can be:<ul> * <li>One-sample or two-sample</li> * <li>One-sided or two-sided</li> * <li>Paired or unpaired (for two-sample tests)</li> * <li>Homoscedastic (equal variance assumption) or heteroscedastic * (for two sample tests)</li> * <li>Fixed significance level (boolean-valued) or returning p-values. * </li></ul></p> * <p> * Test statistics are available for all tests.  Methods including "Test" in * in their names perform tests, all other methods return t-statistics.  Among * the "Test" methods, <code>double-</code>valued methods return p-values; * <code>boolean-</code>valued methods perform fixed significance level tests. * Significance levels are always specified as numbers between 0 and 0.5 * (e.g. tests at the 95% level  use <code>alpha=0.05</code>).</p> * <p> * Input to tests can be either <code>double[]</code> arrays or * {@link StatisticalSummary} instances.</p> * * * @version $Id$ */public interface TTest {    /**     * Computes a paired, 2-sample t-statistic based on the data in the input     * arrays.  The t-statistic returned is equivalent to what would be returned by     * computing the one-sample t-statistic {@link #t(double, double[])}, with     * <code>mu = 0</code> and the sample array consisting of the (signed)     * differences between corresponding entries in <code>sample1</code> and     * <code>sample2.</code>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The input arrays must have the same length and their common length     * must be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if the statistic can not be computed do to a     *         convergence or other numerical error.     */    double pairedT(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or     * <i> p-value</i>, associated with a paired, two-sample, two-tailed t-test     * based on the data in the input arrays.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the mean of the paired     * differences is 0 in favor of the two-sided alternative that the mean paired     * difference is not equal to 0. For a one-sided test, divide the returned     * value by 2.</p>     * <p>     * This test is equivalent to a one-sample t-test computed using     * {@link #tTest(double, double[])} with <code>mu = 0</code> and the sample     * array consisting of the signed differences between corresponding elements of     * <code>sample1</code> and <code>sample2.</code></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The input array lengths must be the same and their common length must     * be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double pairedTTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException;    /**     * Performs a paired t-test evaluating the null hypothesis that the     * mean of the paired differences between <code>sample1</code> and     * <code>sample2</code> is 0 in favor of the two-sided alternative that the     * mean paired difference is not equal to 0, with significance level     * <code>alpha</code>.     * <p>     * Returns <code>true</code> iff the null hypothesis can be rejected with     * confidence <code>1 - alpha</code>.  To perform a 1-sided test, use     * <code>alpha * 2</code></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The input array lengths must be the same and their common length     * must be at least 2.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with     * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean pairedTTest(        double[] sample1,        double[] sample2,        double alpha)        throws IllegalArgumentException, MathException;    /**     * Computes a <a href="http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula">     * t statistic </a> given observed values and a comparison constant.     * <p>     * This statistic can be used to perform a one sample t-test for the mean.     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array length must be at least 2.     * </li></ul></p>     *     * @param mu comparison constant     * @param observed array of values     * @return t statistic     * @throws IllegalArgumentException if input array length is less than 2     */    double t(double mu, double[] observed)        throws IllegalArgumentException;    /**     * Computes a <a href="http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula">     * t statistic </a> to use in comparing the mean of the dataset described by     * <code>sampleStats</code> to <code>mu</code>.     * <p>     * This statistic can be used to perform a one sample t-test for the mean.     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li><code>observed.getN() > = 2</code>.     * </li></ul></p>     *     * @param mu comparison constant     * @param sampleStats DescriptiveStatistics holding sample summary statitstics     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    double t(double mu, StatisticalSummary sampleStats)        throws IllegalArgumentException;    /**     * Computes a 2-sample t statistic,  under the hypothesis of equal     * subpopulation variances.  To compute a t-statistic without the     * equal variances hypothesis, use {@link #t(double[], double[])}.     * <p>     * This statistic can be used to perform a (homoscedastic) two-sample     * t-test to compare sample means.</p>     * <p>     * The t-statisitc is</p>     * <p>     * &nbsp;&nbsp;<code>  t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))</code>     * </p><p>     * where <strong><code>n1</code></strong> is the size of first sample;     * <strong><code> n2</code></strong> is the size of second sample;     * <strong><code> m1</code></strong> is the mean of first sample;     * <strong><code> m2</code></strong> is the mean of second sample</li>     * </ul>     * and <strong><code>var</code></strong> is the pooled variance estimate:     * </p><p>     * <code>var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))</code>     * </p><p>     * with <strong><code>var1<code></strong> the variance of the first sample and     * <strong><code>var2</code></strong> the variance of the second sample.     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    double homoscedasticT(double[] sample1, double[] sample2)        throws IllegalArgumentException;    /**     * Computes a 2-sample t statistic, without the hypothesis of equal     * subpopulation variances.  To compute a t-statistic assuming equal     * variances, use {@link #homoscedasticT(double[], double[])}.     * <p>     * This statistic can be used to perform a two-sample t-test to compare     * sample means.</p>     * <p>     * The t-statisitc is</p>     * <p>     * &nbsp;&nbsp; <code>  t = (m1 - m2) / sqrt(var1/n1 + var2/n2)</code>     * </p><p>     *  where <strong><code>n1</code></strong> is the size of the first sample     * <strong><code> n2</code></strong> is the size of the second sample;     * <strong><code> m1</code></strong> is the mean of the first sample;     * <strong><code> m2</code></strong> is the mean of the second sample;     * <strong><code> var1</code></strong> is the variance of the first sample;     * <strong><code> var2</code></strong> is the variance of the second sample;     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    double t(double[] sample1, double[] sample2)        throws IllegalArgumentException;    /**     * Computes a 2-sample t statistic </a>, comparing the means of the datasets     * described by two {@link StatisticalSummary} instances, without the     * assumption of equal subpopulation variances.  Use     * {@link #homoscedasticT(StatisticalSummary, StatisticalSummary)} to     * compute a t-statistic under the equal variances assumption.     * <p>     * This statistic can be used to perform a two-sample t-test to compare     * sample means.</p>     * <p>      * The returned  t-statisitc is</p>     * <p>     * &nbsp;&nbsp; <code>  t = (m1 - m2) / sqrt(var1/n1 + var2/n2)</code>     * </p><p>     * where <strong><code>n1</code></strong> is the size of the first sample;     * <strong><code> n2</code></strong> is the size of the second sample;     * <strong><code> m1</code></strong> is the mean of the first sample;     * <strong><code> m2</code></strong> is the mean of the second sample     * <strong><code> var1</code></strong> is the variance of the first sample;     * <strong><code> var2</code></strong> is the variance of the second sample     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li></ul></p>     *     * @param sampleStats1 StatisticalSummary describing data from the first sample     * @param sampleStats2 StatisticalSummary describing data from the second sample     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    double t(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException;    /**     * Computes a 2-sample t statistic, comparing the means of the datasets     * described by two {@link StatisticalSummary} instances, under the     * assumption of equal subpopulation variances.  To compute a t-statistic     * without the equal variances assumption, use     * {@link #t(StatisticalSummary, StatisticalSummary)}.     * <p>     * This statistic can be used to perform a (homoscedastic) two-sample     * t-test to compare sample means.</p>     * <p>     * The t-statisitc returned is</p>     * <p>     * &nbsp;&nbsp;<code>  t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))</code>     * </p><p>     * where <strong><code>n1</code></strong> is the size of first sample;     * <strong><code> n2</code></strong> is the size of second sample;     * <strong><code> m1</code></strong> is the mean of first sample;     * <strong><code> m2</code></strong> is the mean of second sample     * and <strong><code>var</code></strong> is the pooled variance estimate:     * </p><p>     * <code>var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))</code>     * </p><p>     * with <strong><code>var1<code></strong> the variance of the first sample and     * <strong><code>var2</code></strong> the variance of the second sample.     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li></ul></p>     *     * @param sampleStats1 StatisticalSummary describing data from the first sample     * @param sampleStats2 StatisticalSummary describing data from the second sample     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    double homoscedasticT(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException;    /**     * Returns the <i>observed significance level</i>, or     * <i>p-value</i>, associated with a one-sample, two-tailed t-test     * comparing the mean of the input array with the constant <code>mu</code>.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the mean equals     * <code>mu</code> in favor of the two-sided alternative that the mean     * is different from <code>mu</code>. For a one-sided test, divide the     * returned value by 2.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">here</a>     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array length must be at least 2.     * </li></ul></p>     *     * @param mu constant value to compare sample mean against     * @param sample array of sample data values     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double tTest(double mu, double[] sample)        throws IllegalArgumentException, MathException;    /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that the mean of the population from     * which <code>sample</code> is drawn equals <code>mu</code>.     * <p>     * Returns <code>true</code> iff the null hypothesis can be     * rejected with confidence <code>1 - alpha</code>.  To     * perform a 1-sided test, use <code>alpha * 2</code></p>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>sample mean = mu </code> at     * the 95% level, use <br><code>tTest(mu, sample, 0.05) </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>     * at the 99% level, first verify that the measured sample mean is less     * than <code>mu</code> and then use     * <br><code>tTest(mu, sample, 0.02) </code>     * </li></ol></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the one-sample     * parametric t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample">here</a>     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array length must be at least 2.     * </li></ul></p>     *     * @param mu constant value to compare sample mean against     * @param sample array of sample data values     * @param alpha significance level of the test     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error computing the p-value     */    boolean tTest(double mu, double[] sample, double alpha)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or     * <i>p-value</i>, associated with a one-sample, two-tailed t-test     * comparing the mean of the dataset described by <code>sampleStats</code>     * with the constant <code>mu</code>.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the mean equals     * <code>mu</code> in favor of the two-sided alternative that the mean     * is different from <code>mu</code>. For a one-sided test, divide the     * returned value by 2.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The sample must contain at least 2 observations.     * </li></ul></p>     *     * @param mu constant value to compare sample mean against     * @param sampleStats StatisticalSummary describing sample data     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double tTest(double mu, StatisticalSummary sampleStats)        throws IllegalArgumentException, MathException;    /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that the mean of the     * population from which the dataset described by <code>stats</code> is     * drawn equals <code>mu</code>.     * <p>     * Returns <code>true</code> iff the null hypothesis can be rejected with     * confidence <code>1 - alpha</code>.  To  perform a 1-sided test, use     * <code>alpha * 2.</code></p>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>sample mean = mu </code> at     * the 95% level, use <br><code>tTest(mu, sampleStats, 0.05) </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>     * at the 99% level, first verify that the measured sample mean is less     * than <code>mu</code> and then use     * <br><code>tTest(mu, sampleStats, 0.02) </code>     * </li></ol></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the one-sample     * parametric t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample">here</a>     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The sample must include at least 2 observations.     * </li></ul></p>     *     * @param mu constant value to compare sample mean against     * @param sampleStats StatisticalSummary describing sample data values     * @param alpha significance level of the test     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    boolean tTest(        double mu,        StatisticalSummary sampleStats,        double alpha)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or     * <i>p-value</i>, associated with a two-sample, two-tailed t-test     * comparing the means of the input arrays.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.     * For a one-sided test, divide the returned value by 2.</p>     * <p>     * The test does not assume that the underlying popuation variances are     * equal  and it uses approximated degrees of freedom computed from the     * sample data to compute the p-value.  The t-statistic used is as defined in     * {@link #t(double[], double[])} and the Welch-Satterthwaite approximation     * to the degrees of freedom is used,     * as described     * <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">     * here.</a>  To perform the test under the assumption of equal subpopulation     * variances, use {@link #homoscedasticTTest(double[], double[])}.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double tTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or     * <i>p-value</i>, associated with a two-sample, two-tailed t-test     * comparing the means of the input arrays, under the assumption that     * the two samples are drawn from subpopulations with equal variances.     * To perform the test without the equal variances assumption, use     * {@link #tTest(double[], double[])}.</p>     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.     * For a one-sided test, divide the returned value by 2.</p>     * <p>     * A pooled variance estimate is used to compute the t-statistic.  See     * {@link #homoscedasticT(double[], double[])}. The sum of the sample sizes     * minus 2 is used as the degrees of freedom.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double homoscedasticTTest(        double[] sample1,        double[] sample2)        throws IllegalArgumentException, MathException;    /**     * Performs a     * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code>     * and <code>sample2</code> are drawn from populations with the same mean,     * with significance level <code>alpha</code>.  This test does not assume     * that the subpopulation variances are equal.  To perform the test assuming     * equal variances, use     * {@link #homoscedasticTTest(double[], double[], double)}.     * <p>     * Returns <code>true</code> iff the null hypothesis that the means are     * equal can be rejected with confidence <code>1 - alpha</code>.  To     * perform a 1-sided test, use <code>alpha * 2</code></p>     * <p>     * See {@link #t(double[], double[])} for the formula used to compute the     * t-statistic.  Degrees of freedom are approximated using the     * <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">     * Welch-Satterthwaite approximation.</a></p>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at     * the 95% level,  use     * <br><code>tTest(sample1, sample2, 0.05). </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code>,     * at the 99% level, first verify that the measured  mean of <code>sample 1</code>     * is less than the mean of <code>sample 2</code> and then use     * <br><code>tTest(sample1, sample2, 0.02) </code>     * </li></ol></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with     * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean tTest(        double[] sample1,        double[] sample2,        double alpha)        throws IllegalArgumentException, MathException;    /**     * Performs a     * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code>     * and <code>sample2</code> are drawn from populations with the same mean,     * with significance level <code>alpha</code>,  assuming that the     * subpopulation variances are equal.  Use     * {@link #tTest(double[], double[], double)} to perform the test without     * the assumption of equal variances.     * <p>     * Returns <code>true</code> iff the null hypothesis that the means are     * equal can be rejected with confidence <code>1 - alpha</code>.  To     * perform a 1-sided test, use <code>alpha * 2.</code>  To perform the test     * without the assumption of equal subpopulation variances, use     * {@link #tTest(double[], double[], double)}.</p>     * <p>     * A pooled variance estimate is used to compute the t-statistic. See     * {@link #t(double[], double[])} for the formula. The sum of the sample     * sizes minus 2 is used as the degrees of freedom.</p>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at     * the 95% level, use <br><code>tTest(sample1, sample2, 0.05). </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2, </code>     * at the 99% level, first verify that the measured mean of     * <code>sample 1</code> is less than the mean of <code>sample 2</code>     * and then use     * <br><code>tTest(sample1, sample2, 0.02) </code>     * </li></ol></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with     * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean homoscedasticTTest(        double[] sample1,        double[] sample2,        double alpha)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or     * <i>p-value</i>, associated with a two-sample, two-tailed t-test     * comparing the means of the datasets described by two StatisticalSummary     * instances.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.     * For a one-sided test, divide the returned value by 2.</p>     * <p>     * The test does not assume that the underlying popuation variances are     * equal  and it uses approximated degrees of freedom computed from the     * sample data to compute the p-value.   To perform the test assuming     * equal variances, use     * {@link #homoscedasticTTest(StatisticalSummary, StatisticalSummary)}.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li></ul></p>     *     * @param sampleStats1  StatisticalSummary describing data from the first sample     * @param sampleStats2  StatisticalSummary describing data from the second sample     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double tTest(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or     * <i>p-value</i>, associated with a two-sample, two-tailed t-test     * comparing the means of the datasets described by two StatisticalSummary     * instances, under the hypothesis of equal subpopulation variances. To     * perform a test without the equal variances assumption, use     * {@link #tTest(StatisticalSummary, StatisticalSummary)}.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.     * For a one-sided test, divide the returned value by 2.</p>     * <p>     * See {@link #homoscedasticT(double[], double[])} for the formula used to     * compute the t-statistic. The sum of the  sample sizes minus 2 is used as     * the degrees of freedom.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">here</a>     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li></ul></p>     *     * @param sampleStats1  StatisticalSummary describing data from the first sample     * @param sampleStats2  StatisticalSummary describing data from the second sample     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double homoscedasticTTest(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException, MathException;    /**     * Performs a     * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that     * <code>sampleStats1</code> and <code>sampleStats2</code> describe     * datasets drawn from populations with the same mean, with significance     * level <code>alpha</code>.   This test does not assume that the     * subpopulation variances are equal.  To perform the test under the equal     * variances assumption, use     * {@link #homoscedasticTTest(StatisticalSummary, StatisticalSummary)}.     * <p>     * Returns <code>true</code> iff the null hypothesis that the means are     * equal can be rejected with confidence <code>1 - alpha</code>.  To     * perform a 1-sided test, use <code>alpha * 2</code></p>     * <p>     * See {@link #t(double[], double[])} for the formula used to compute the     * t-statistic.  Degrees of freedom are approximated using the     * <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">     * Welch-Satterthwaite approximation.</a></p>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at     * the 95%, use     * <br><code>tTest(sampleStats1, sampleStats2, 0.05) </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code>     * at the 99% level,  first verify that the measured mean of     * <code>sample 1</code> is less than  the mean of <code>sample 2</code>     * and then use     * <br><code>tTest(sampleStats1, sampleStats2, 0.02) </code>     * </li></ol></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul></p>     *     * @param sampleStats1 StatisticalSummary describing sample data values     * @param sampleStats2 StatisticalSummary describing sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with     * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean tTest(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2,        double alpha)        throws IllegalArgumentException, MathException;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import java.util.Collection;import org.apache.commons.math.MathException;import org.apache.commons.math.stat.descriptive.StatisticalSummary;/** * A collection of static methods to create inference test instances or to * perform inference tests. * * @since 1.1 * @version $Id$ */public class TestUtils  {    /** Singleton TTest instance using default implementation. */    private static final TTest T_TEST = new TTestImpl();    /** Singleton ChiSquareTest instance using default implementation. */    private static final ChiSquareTest CHI_SQUARE_TEST = new ChiSquareTestImpl();    /** Singleton ChiSquareTest instance using default implementation. */    private static final UnknownDistributionChiSquareTest UNKNOWN_DISTRIBUTION_CHI_SQUARE_TEST =        new ChiSquareTestImpl();    /** Singleton OneWayAnova instance using default implementation. */    private static final OneWayAnova ONE_WAY_ANANOVA = new OneWayAnovaImpl();    /**     * Prevent instantiation.     */    private TestUtils() {        super();    }    // CHECKSTYLE: stop JavadocMethodCheck    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticT(double[], double[])     */    public static double homoscedasticT(double[] sample1, double[] sample2)        throws IllegalArgumentException {        return T_TEST.homoscedasticT(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticT(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double homoscedasticT(StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException {        return T_TEST.homoscedasticT(sampleStats1, sampleStats2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticTTest(double[], double[], double)     */    public static boolean homoscedasticTTest(double[] sample1, double[] sample2,            double alpha)        throws IllegalArgumentException, MathException {        return T_TEST. homoscedasticTTest(sample1, sample2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticTTest(double[], double[])     */    public static double homoscedasticTTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException {        return T_TEST.homoscedasticTTest(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticTTest(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double homoscedasticTTest(StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException, MathException {        return T_TEST.homoscedasticTTest(sampleStats1, sampleStats2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#pairedT(double[], double[])     */    public static double pairedT(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException {        return T_TEST.pairedT(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#pairedTTest(double[], double[], double)     */    public static boolean pairedTTest(double[] sample1, double[] sample2,        double alpha)        throws IllegalArgumentException, MathException {        return T_TEST.pairedTTest(sample1, sample2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#pairedTTest(double[], double[])     */    public static double pairedTTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException {        return T_TEST.pairedTTest(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#t(double, double[])     */    public static double t(double mu, double[] observed)        throws IllegalArgumentException {        return T_TEST.t(mu, observed);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#t(double, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double t(double mu, StatisticalSummary sampleStats)        throws IllegalArgumentException {        return T_TEST.t(mu, sampleStats);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#t(double[], double[])     */    public static double t(double[] sample1, double[] sample2)        throws IllegalArgumentException {        return T_TEST.t(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#t(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double t(StatisticalSummary sampleStats1,            StatisticalSummary sampleStats2)        throws IllegalArgumentException {        return T_TEST.t(sampleStats1, sampleStats2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, double[], double)     */    public static boolean tTest(double mu, double[] sample, double alpha)        throws IllegalArgumentException, MathException {        return T_TEST.tTest(mu, sample, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, double[])     */    public static double tTest(double mu, double[] sample)        throws IllegalArgumentException, MathException {        return T_TEST.tTest(mu, sample);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, org.apache.commons.math.stat.descriptive.StatisticalSummary, double)     */    public static boolean tTest(double mu, StatisticalSummary sampleStats,        double alpha)        throws IllegalArgumentException, MathException {        return T_TEST. tTest(mu, sampleStats, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double tTest(double mu, StatisticalSummary sampleStats)        throws IllegalArgumentException, MathException {        return T_TEST.tTest(mu, sampleStats);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double[], double[], double)     */    public static boolean tTest(double[] sample1, double[] sample2, double alpha)        throws IllegalArgumentException, MathException {        return T_TEST.tTest(sample1, sample2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double[], double[])     */    public static double tTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException {        return T_TEST.tTest(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary, double)     */    public static boolean tTest(StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2, double alpha)        throws IllegalArgumentException, MathException {        return T_TEST. tTest(sampleStats1, sampleStats2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double tTest(StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException, MathException {        return T_TEST.tTest(sampleStats1, sampleStats2);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquare(double[], long[])     */    public static double chiSquare(double[] expected, long[] observed)        throws IllegalArgumentException {        return CHI_SQUARE_TEST.chiSquare(expected, observed);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquare(long[][])     */    public static double chiSquare(long[][] counts)        throws IllegalArgumentException {        return CHI_SQUARE_TEST.chiSquare(counts);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(double[], long[], double)     */    public static boolean chiSquareTest(double[] expected, long[] observed,        double alpha)        throws IllegalArgumentException, MathException {        return CHI_SQUARE_TEST.chiSquareTest(expected, observed, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(double[], long[])     */    public static double chiSquareTest(double[] expected, long[] observed)        throws IllegalArgumentException, MathException {        return CHI_SQUARE_TEST.chiSquareTest(expected, observed);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(long[][], double)     */    public static boolean chiSquareTest(long[][] counts, double alpha)        throws IllegalArgumentException, MathException {        return CHI_SQUARE_TEST. chiSquareTest(counts, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(long[][])     */    public static double chiSquareTest(long[][] counts)        throws IllegalArgumentException, MathException {        return CHI_SQUARE_TEST.chiSquareTest(counts);    }    /**     * @see org.apache.commons.math.stat.inference.UnknownDistributionChiSquareTest#chiSquareDataSetsComparison(long[], long[])     *     * @since 1.2     */    public static double chiSquareDataSetsComparison(long[] observed1, long[] observed2)        throws IllegalArgumentException {        return UNKNOWN_DISTRIBUTION_CHI_SQUARE_TEST.chiSquareDataSetsComparison(observed1, observed2);    }    /**     * @see org.apache.commons.math.stat.inference.UnknownDistributionChiSquareTest#chiSquareTestDataSetsComparison(long[], long[])     *     * @since 1.2     */    public static double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)        throws IllegalArgumentException, MathException {        return UNKNOWN_DISTRIBUTION_CHI_SQUARE_TEST.chiSquareTestDataSetsComparison(observed1, observed2);    }    /**     * @see org.apache.commons.math.stat.inference.UnknownDistributionChiSquareTest#chiSquareTestDataSetsComparison(long[], long[], double)     *     * @since 1.2     */    public static boolean chiSquareTestDataSetsComparison(long[] observed1, long[] observed2,        double alpha)        throws IllegalArgumentException, MathException {        return UNKNOWN_DISTRIBUTION_CHI_SQUARE_TEST.chiSquareTestDataSetsComparison(observed1, observed2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.OneWayAnova#anovaFValue(Collection)     *     * @since 1.2     */    public static double oneWayAnovaFValue(Collection<double[]> categoryData)    throws IllegalArgumentException, MathException {        return ONE_WAY_ANANOVA.anovaFValue(categoryData);    }    /**     * @see org.apache.commons.math.stat.inference.OneWayAnova#anovaPValue(Collection)     *     * @since 1.2     */    public static double oneWayAnovaPValue(Collection<double[]> categoryData)    throws IllegalArgumentException, MathException {        return ONE_WAY_ANANOVA.anovaPValue(categoryData);    }    /**     * @see org.apache.commons.math.stat.inference.OneWayAnova#anovaTest(Collection,double)     *     * @since 1.2     */    public static boolean oneWayAnovaTest(Collection<double[]> categoryData, double alpha)    throws IllegalArgumentException, MathException {        return ONE_WAY_ANANOVA.anovaTest(categoryData, alpha);    }    // CHECKSTYLE: resume JavadocMethodCheck}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.MathException;/** * An interface for Wilcoxon signed-rank test. * * @version $Id$ */public interface WilcoxonSignedRankTest {    /**     * Computes the <a     * href="http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test">     * Wilcoxon signed ranked statistic</a> comparing mean for two related     * samples or repeated measurements on a single sample.     * <p>     * This statistic can be used to perform a Wilcoxon signed ranked test     * evaluating the null hypothesis that the two related samples or repeated     * measurements on a single sample has equal mean.     * </p>     * <p>     * Let X<sub>i</sub> denote the i'th individual of the first sample and     * Y<sub>i</sub> the related i'th individual in the second sample. Let     * Z<sub>i</sub> = Y<sub>i</sub> - X<sub>i</sub>.     * </p>     * <p>     * <strong>Preconditions</strong>:     * <ul>     * <li>The differences Z<sub>i</sub> must be independent.</li>     * <li>Each Z<sub>i</sub> comes from a continuous population (they must be     * identical) and is symmetric about a common median.</li>     * <li>The values that X<sub>i</sub> and Y<sub>i</sub> represent are     * ordered, so the comparisons greater than, less than, and equal to are     * meaningful.</li>     * </ul>     * </p>     *     * @param x     *            the first sample     * @param y     *            the second sample     * @return wilcoxonSignedRank statistic     * @throws IllegalArgumentException     *             if preconditions are not met     */    double wilcoxonSignedRank(final double[] x, final double[] y)            throws IllegalArgumentException;    /**     * Returns the <i>observed significance level</i>, or <a href=     * "http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a <a     * href="http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test">     * Wilcoxon signed ranked statistic</a> comparing mean for two related     * samples or repeated measurements on a single sample.     * <p>     * Let X<sub>i</sub> denote the i'th individual of the first sample and     * Y<sub>i</sub> the related i'th individual in the second sample. Let     * Z<sub>i</sub> = Y<sub>i</sub> - X<sub>i</sub>.     * </p>     * <p>     * <strong>Preconditions</strong>:     * <ul>     * <li>The differences Z<sub>i</sub> must be independent.</li>     * <li>Each Z<sub>i</sub> comes from a continuous population (they must be     * identical) and is symmetric about a common median.</li>     * <li>The values that X<sub>i</sub> and Y<sub>i</sub> represent are     * ordered, so the comparisons greater than, less than, and equal to are     * meaningful.</li>     * </ul>     * </p>     *     * @param x     *            the first sample     * @param y     *            the second sample     * @param exactPValue     *            if the exact p-value is wanted (only works for x.length <= 30,     *            if true and x.length > 30, this is ignored because     *            calculations may take too long)     * @return p-value     * @throws IllegalArgumentException     *             if preconditions are not met     * @throws MathException     *             if an error occurs computing the p-value     */    double wilcoxonSignedRankTest(final double[] x, final double[] y,            boolean exactPValue) throws IllegalArgumentException,            MathException;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.stat.StatUtils;import org.junit.Assert;import org.junit.Test;/** * This class contains test cases for the ExpandableDoubleArray. * * @version $Id$ */public abstract class DoubleArrayAbstractTest {    protected DoubleArray da = null;    // Array used to test rolling    protected DoubleArray ra = null;    @Test    public void testAdd1000() {        for (int i = 0; i < 1000; i++) {            da.addElement(i);        }        Assert.assertEquals(            "Number of elements should be equal to 1000 after adding 1000 values",            1000,            da.getNumElements());        Assert.assertEquals(            "The element at the 56th index should be 56",            56.0,            da.getElement(56),            Double.MIN_VALUE);    }    @Test    public void testGetValues() {        double[] controlArray = { 2.0, 4.0, 6.0 };        da.addElement(2.0);        da.addElement(4.0);        da.addElement(6.0);        double[] testArray = da.getElements();        for (int i = 0; i < da.getNumElements(); i++) {            Assert.assertEquals(                "The testArray values should equal the controlArray values, index i: "                    + i                    + " does not match",                testArray[i],                controlArray[i],                Double.MIN_VALUE);        }    }    @Test    public void testAddElementRolling() {        ra.addElement(0.5);        ra.addElement(1.0);        ra.addElement(1.0);        ra.addElement(1.0);        ra.addElement(1.0);        ra.addElement(1.0);        ra.addElementRolling(2.0);        Assert.assertEquals(            "There should be 6 elements in the eda",            6,            ra.getNumElements());        Assert.assertEquals(            "The max element should be 2.0",            2.0,            StatUtils.max(ra.getElements()),            Double.MIN_VALUE);        Assert.assertEquals(            "The min element should be 1.0",            1.0,            StatUtils.min(ra.getElements()),            Double.MIN_VALUE);        for (int i = 0; i < 1024; i++) {            ra.addElementRolling(i);        }        Assert.assertEquals(            "We just inserted 1024 rolling elements, num elements should still be 6",            6,            ra.getNumElements());    }    @Test    public void testMinMax() {        da.addElement(2.0);        da.addElement(22.0);        da.addElement(-2.0);        da.addElement(21.0);        da.addElement(22.0);        da.addElement(42.0);        da.addElement(62.0);        da.addElement(22.0);        da.addElement(122.0);        da.addElement(1212.0);        Assert.assertEquals("Min should be -2.0", -2.0, StatUtils.min(da.getElements()), Double.MIN_VALUE);        Assert.assertEquals(            "Max should be 1212.0",            1212.0,            StatUtils.max(da.getElements()),            Double.MIN_VALUE);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.junit.Assert;import org.junit.Test;/** * @version $Id$ */public class ContinuedFractionTest {    @Test    public void testGoldenRatio() throws Exception {        ContinuedFraction cf = new ContinuedFraction() {            @Override            public double getA(int n, double x) {                return 1.0;            }            @Override            public double getB(int n, double x) {                return 1.0;            }        };        double gr = cf.evaluate(0.0, 10e-9);        Assert.assertEquals(1.61803399, gr, 10e-9);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.util;import org.junit.Assert;import org.junit.Test;/** * Test for {@link Pair}. */public class PairTest {    @Test    public void testAccessor() {        final Pair<Integer, Double> p            = new Pair<Integer, Double>(new Integer(1), new Double(2));        Assert.assertEquals(new Integer(1), p.getKey());        Assert.assertEquals(new Double(2), p.getValue(), Math.ulp(1d));    }    @Test    public void testEquals() {        Pair<Integer, Double> p1 = new Pair<Integer, Double>(null, null);        Assert.assertFalse(p1.equals(null));        Pair<Integer, Double> p2 = new Pair<Integer, Double>(null, null);        Assert.assertTrue(p1.equals(p2));        p1 = new Pair<Integer, Double>(new Integer(1), new Double(2));        Assert.assertFalse(p1.equals(p2));        p2 = new Pair<Integer, Double>(new Integer(1), new Double(2));        Assert.assertTrue(p1.equals(p2));        Pair<Integer, Float> p3 = new Pair<Integer, Float>(new Integer(1), new Float(2));        Assert.assertFalse(p1.equals(p3));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import java.math.BigDecimal;import java.math.BigInteger;import java.math.MathContext;import org.apache.commons.math.TestUtils;import org.junit.Assert;import org.junit.Test;public class BigRealTest {    @Test    public void testConstructor() {        Assert.assertEquals(1.625, new BigReal(new BigDecimal("1.625")).doubleValue(), 1.0e-15);        Assert.assertEquals(-5.0, new BigReal(new BigInteger("-5")).doubleValue(), 1.0e-15);        Assert.assertEquals(-5.0, new BigReal(new BigInteger("-5"), MathContext.DECIMAL64).doubleValue(), 1.0e-15);        Assert.assertEquals(0.125, new BigReal(new BigInteger("125"), 3).doubleValue(), 1.0e-15);        Assert.assertEquals(0.125, new BigReal(new BigInteger("125"), 3, MathContext.DECIMAL64).doubleValue(), 1.0e-15);        Assert.assertEquals(1.625, new BigReal(new char[] { '1', '.', '6', '2', '5' }).doubleValue(), 1.0e-15);        Assert.assertEquals(1.625, new BigReal(new char[] { 'A', 'A', '1', '.', '6', '2', '5', '9' }, 2, 5).doubleValue(), 1.0e-15);        Assert.assertEquals(1.625, new BigReal(new char[] { 'A', 'A', '1', '.', '6', '2', '5', '9' }, 2, 5, MathContext.DECIMAL64).doubleValue(), 1.0e-15);        Assert.assertEquals(1.625, new BigReal(new char[] { '1', '.', '6', '2', '5' }, MathContext.DECIMAL64).doubleValue(), 1.0e-15);        Assert.assertEquals(1.625, new BigReal(1.625).doubleValue(), 1.0e-15);        Assert.assertEquals(1.625, new BigReal(1.625, MathContext.DECIMAL64).doubleValue(), 1.0e-15);        Assert.assertEquals(-5.0, new BigReal(-5).doubleValue(), 1.0e-15);        Assert.assertEquals(-5.0, new BigReal(-5, MathContext.DECIMAL64).doubleValue(), 1.0e-15);        Assert.assertEquals(-5.0, new BigReal(-5l).doubleValue(), 1.0e-15);        Assert.assertEquals(-5.0, new BigReal(-5l, MathContext.DECIMAL64).doubleValue(), 1.0e-15);        Assert.assertEquals(1.625, new BigReal("1.625").doubleValue(), 1.0e-15);        Assert.assertEquals(1.625, new BigReal("1.625", MathContext.DECIMAL64).doubleValue(), 1.0e-15);    }    @Test    public void testCompareTo() {        BigReal first = new BigReal(1.0 / 2.0);        BigReal second = new BigReal(1.0 / 3.0);        BigReal third = new BigReal(1.0 / 2.0);        Assert.assertEquals(0, first.compareTo(first));        Assert.assertEquals(0, first.compareTo(third));        Assert.assertEquals(1, first.compareTo(second));        Assert.assertEquals(-1, second.compareTo(first));    }    @Test    public void testAdd() {        BigReal a = new BigReal("1.2345678");        BigReal b = new BigReal("8.7654321");        Assert.assertEquals(9.9999999, a.add(b).doubleValue(), 1.0e-15);    }    @Test    public void testSubtract() {        BigReal a = new BigReal("1.2345678");        BigReal b = new BigReal("8.7654321");        Assert.assertEquals( -7.5308643, a.subtract(b).doubleValue(), 1.0e-15);    }    @Test    public void testDivide() {        BigReal a = new BigReal("1.0000000000");        BigReal b = new BigReal("0.0009765625");        Assert.assertEquals(1024.0, a.divide(b).doubleValue(), 1.0e-15);    }    @Test    public void testMultiply() {        BigReal a = new BigReal("1024.0");        BigReal b = new BigReal("0.0009765625");        Assert.assertEquals(1.0, a.multiply(b).doubleValue(), 1.0e-15);    }    @Test    public void testDoubleValue() {        Assert.assertEquals(0.5, new BigReal(0.5).doubleValue(), 1.0e-15);    }    @Test    public void testBigDecimalValue() {        BigDecimal pi = new BigDecimal("3.1415926535897932384626433832795028841971693993751");        Assert.assertEquals(pi, new BigReal(pi).bigDecimalValue());        Assert.assertEquals(new BigDecimal(0.5), new BigReal(1.0 / 2.0).bigDecimalValue());    }    @Test    public void testEqualsAndHashCode() {        BigReal zero = new BigReal(0.0);        BigReal nullReal = null;        Assert.assertTrue(zero.equals(zero));        Assert.assertFalse(zero.equals(nullReal));        Assert.assertFalse(zero.equals(Double.valueOf(0)));        BigReal zero2 = new BigReal(0.0);        Assert.assertTrue(zero.equals(zero2));        Assert.assertEquals(zero.hashCode(), zero2.hashCode());        BigReal one = new BigReal(1.0);        Assert.assertFalse((one.equals(zero) || zero.equals(one)));        Assert.assertTrue(one.equals(BigReal.ONE));    }    @Test    public void testSerial() {        BigReal[] Reals = {            new BigReal(3.0), BigReal.ONE, BigReal.ZERO,            new BigReal(17), new BigReal(FastMath.PI),            new BigReal(-2.5)        };        for (BigReal Real : Reals) {            Assert.assertEquals(Real, TestUtils.serializeAndRecover(Real));        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import java.util.ConcurrentModificationException;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.NoSuchElementException;import java.util.Random;import java.util.Set;import java.util.Map.Entry;import org.apache.commons.math.Field;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionConversionException;import org.apache.commons.math.fraction.FractionField;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public class OpenIntToFieldTest {    private Map<Integer, Fraction> javaMap = new HashMap<Integer, Fraction>();    private FractionField field = FractionField.getInstance();    @Before    public void setUp() throws FractionConversionException {        javaMap.put(50, new Fraction(100.0));        javaMap.put(75, new Fraction(75.0));        javaMap.put(25, new Fraction(500.0));        javaMap.put(Integer.MAX_VALUE, new Fraction(Integer.MAX_VALUE));        javaMap.put(0, new Fraction(-1.0));        javaMap.put(1, new Fraction(0.0));        javaMap.put(33, new Fraction(-0.1));        javaMap.put(23234234, new Fraction(-242343.0));        javaMap.put(23321, new Fraction (Integer.MIN_VALUE));        javaMap.put(-4444, new Fraction(332.0));        javaMap.put(-1, new Fraction(-2323.0));        javaMap.put(Integer.MIN_VALUE, new Fraction(44.0));        /* Add a few more to cause the table to rehash */        javaMap.putAll(generate());    }    private Map<Integer, Fraction> generate() {        Map<Integer, Fraction> map = new HashMap<Integer, Fraction>();        Random r = new Random();        double dd=0;        for (int i = 0; i < 2000; ++i)            dd = r.nextDouble();            try {                map.put(r.nextInt(), new Fraction(dd));            } catch (FractionConversionException e) {                throw new IllegalStateException("Invalid :"+dd, e);            }        return map;    }    private OpenIntToFieldHashMap<Fraction> createFromJavaMap(Field<Fraction> field) {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());        }        return map;    }    @Test    public void testPutAndGetWith0ExpectedSize() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field,0);        assertPutAndGet(map);    }    @Test    public void testPutAndGetWithExpectedSize() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field,500);        assertPutAndGet(map);    }    @Test    public void testPutAndGet() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);        assertPutAndGet(map);    }    private void assertPutAndGet(OpenIntToFieldHashMap<Fraction> map) {        assertPutAndGet(map, 0, new HashSet<Integer>());    }    private void assertPutAndGet(OpenIntToFieldHashMap<Fraction> map, int mapSize,            Set<Integer> keysInMap) {        Assert.assertEquals(mapSize, map.size());        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            if (!keysInMap.contains(mapEntry.getKey()))                ++mapSize;            Assert.assertEquals(mapSize, map.size());            Assert.assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));        }    }    @Test    public void testPutAbsentOnExisting() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        int size = javaMap.size();        for (Map.Entry<Integer, Fraction> mapEntry : generateAbsent().entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            Assert.assertEquals(++size, map.size());            Assert.assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));        }    }    @Test    public void testPutOnExisting() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            Assert.assertEquals(javaMap.size(), map.size());            Assert.assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));        }    }    @Test    public void testGetAbsent() {        Map<Integer, Fraction> generated = generateAbsent();        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        for (Map.Entry<Integer, Fraction> mapEntry : generated.entrySet())            Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));    }    @Test    public void testGetFromEmpty() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);        Assert.assertTrue(field.getZero().equals(map.get(5)));        Assert.assertTrue(field.getZero().equals(map.get(0)));        Assert.assertTrue(field.getZero().equals(map.get(50)));    }    @Test    public void testRemove() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        int mapSize = javaMap.size();        Assert.assertEquals(mapSize, map.size());        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            map.remove(mapEntry.getKey());            Assert.assertEquals(--mapSize, map.size());            Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));        }        /* Ensure that put and get still work correctly after removals */        assertPutAndGet(map);    }    /* This time only remove some entries */    @Test    public void testRemove2() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        int mapSize = javaMap.size();        int count = 0;        Set<Integer> keysInMap = new HashSet<Integer>(javaMap.keySet());        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            keysInMap.remove(mapEntry.getKey());            map.remove(mapEntry.getKey());            Assert.assertEquals(--mapSize, map.size());            Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));            if (count++ > 5)                break;        }        /* Ensure that put and get still work correctly after removals */        assertPutAndGet(map, mapSize, keysInMap);    }    @Test    public void testRemoveFromEmpty() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);        Assert.assertTrue(field.getZero().equals(map.remove(50)));    }    @Test    public void testRemoveAbsent() {        Map<Integer, Fraction> generated = generateAbsent();        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        int mapSize = map.size();        for (Map.Entry<Integer, Fraction> mapEntry : generated.entrySet()) {            map.remove(mapEntry.getKey());            Assert.assertEquals(mapSize, map.size());            Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));        }    }    /**     * Returns a map with at least 100 elements where each element is absent from javaMap.     */    private Map<Integer, Fraction> generateAbsent() {        Map<Integer, Fraction> generated = new HashMap<Integer, Fraction>();        do {            generated.putAll(generate());            for (Integer key : javaMap.keySet())                generated.remove(key);        } while (generated.size() < 100);        return generated;    }    @Test    public void testCopy() {        OpenIntToFieldHashMap<Fraction> copy =            new OpenIntToFieldHashMap<Fraction>(createFromJavaMap(field));        Assert.assertEquals(javaMap.size(), copy.size());        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet())            Assert.assertEquals(mapEntry.getValue(), copy.get(mapEntry.getKey()));    }    @Test    public void testContainsKey() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        for (Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            Assert.assertTrue(map.containsKey(mapEntry.getKey()));        }        for (Map.Entry<Integer, Fraction> mapEntry : generateAbsent().entrySet()) {            Assert.assertFalse(map.containsKey(mapEntry.getKey()));        }        for (Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            int key = mapEntry.getKey();            Assert.assertTrue(map.containsKey(key));            map.remove(key);            Assert.assertFalse(map.containsKey(key));        }    }    @Test    public void testIterator() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        OpenIntToFieldHashMap<Fraction>.Iterator iterator = map.iterator();        for (int i = 0; i < map.size(); ++i) {            Assert.assertTrue(iterator.hasNext());            iterator.advance();            int key = iterator.key();            Assert.assertTrue(map.containsKey(key));            Assert.assertEquals(javaMap.get(key), map.get(key));            Assert.assertEquals(javaMap.get(key), iterator.value());            Assert.assertTrue(javaMap.containsKey(key));        }        Assert.assertFalse(iterator.hasNext());        try {            iterator.advance();            Assert.fail("an exception should have been thrown");        } catch (NoSuchElementException nsee) {            // expected        }    }    @Test    public void testConcurrentModification() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        OpenIntToFieldHashMap<Fraction>.Iterator iterator = map.iterator();        map.put(3, new Fraction(3));        try {            iterator.advance();            Assert.fail("an exception should have been thrown");        } catch (ConcurrentModificationException cme) {            // expected        }    }    /**     * Regression test for a bug in findInsertionIndex where the hashing in the second probing     * loop was inconsistent with the first causing duplicate keys after the right sequence     * of puts and removes.     */    @Test    public void testPutKeysWithCollisions() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);        int key1 = -1996012590;        Fraction value1 = new Fraction(1);        map.put(key1, value1);        int key2 = 835099822;        map.put(key2, value1);        int key3 = 1008859686;        map.put(key3, value1);        Assert.assertEquals(value1, map.get(key3));        Assert.assertEquals(3, map.size());        map.remove(key2);        Fraction value2 = new Fraction(2);        map.put(key3, value2);        Assert.assertEquals(value2, map.get(key3));        Assert.assertEquals(2, map.size());    }    /**     * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly     * different manner.     */    @Test    public void testPutKeysWithCollision2() {        OpenIntToFieldHashMap<Fraction>map = new OpenIntToFieldHashMap<Fraction>(field);        int key1 = 837989881;        Fraction value1 = new Fraction(1);        map.put(key1, value1);        int key2 = 476463321;        map.put(key2, value1);        Assert.assertEquals(2, map.size());        Assert.assertEquals(value1, map.get(key2));        map.remove(key1);        Fraction value2 = new Fraction(2);        map.put(key2, value2);        Assert.assertEquals(1, map.size());        Assert.assertEquals(value2, map.get(key2));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.random.RandomDataImpl;import org.apache.commons.math.random.RandomData;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;/** * This class contains test cases for the ResizableDoubleArray. * * @version $Id$ */public class ResizableDoubleArrayTest extends DoubleArrayAbstractTest {    @After    public void tearDown() throws Exception {        da = null;        ra = null;    }    @Before    public void setUp() throws Exception {        da = new ResizableDoubleArray();        ra = new ResizableDoubleArray();    }    @Test    public void testConstructors() {        float defaultExpansionFactor = 2.0f;        float defaultContractionCriteria = 2.5f;        int defaultMode = ResizableDoubleArray.MULTIPLICATIVE_MODE;        ResizableDoubleArray testDa = new ResizableDoubleArray(2);        Assert.assertEquals(0, testDa.getNumElements());        Assert.assertEquals(2, testDa.getInternalLength());        Assert.assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);        Assert.assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);        Assert.assertEquals(defaultMode, testDa.getExpansionMode());        try {            da = new ResizableDoubleArray(-1);            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                testDa = new ResizableDoubleArray((double[]) null);        Assert.assertEquals(0, testDa.getNumElements());                double[] initialArray = new double[] { 0, 1, 2 };                testDa = new ResizableDoubleArray(initialArray);        Assert.assertEquals(3, testDa.getNumElements());        testDa = new ResizableDoubleArray(2, 2.0f);        Assert.assertEquals(0, testDa.getNumElements());        Assert.assertEquals(2, testDa.getInternalLength());        Assert.assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);        Assert.assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);        Assert.assertEquals(defaultMode, testDa.getExpansionMode());        try {            da = new ResizableDoubleArray(2, 0.5f);            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        testDa = new ResizableDoubleArray(2, 3.0f);        Assert.assertEquals(3.0f, testDa.getExpansionFactor(), 0);        Assert.assertEquals(3.5f, testDa.getContractionCriteria(), 0);        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f);        Assert.assertEquals(0, testDa.getNumElements());        Assert.assertEquals(2, testDa.getInternalLength());        Assert.assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);        Assert.assertEquals(3.0f, testDa.getContractionCriteria(), 0);        Assert.assertEquals(defaultMode, testDa.getExpansionMode());        try {            da = new ResizableDoubleArray(2, 2.0f, 1.5f);            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f,                ResizableDoubleArray.ADDITIVE_MODE);        Assert.assertEquals(0, testDa.getNumElements());        Assert.assertEquals(2, testDa.getInternalLength());        Assert.assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);        Assert.assertEquals(3.0f, testDa.getContractionCriteria(), 0);        Assert.assertEquals(ResizableDoubleArray.ADDITIVE_MODE,                testDa.getExpansionMode());        try {            da = new ResizableDoubleArray(2, 2.0f, 2.5f, -1);            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        // Copy constructor        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f,                ResizableDoubleArray.ADDITIVE_MODE);        testDa.addElement(2.0);        testDa.addElement(3.2);        ResizableDoubleArray copyDa = new ResizableDoubleArray(testDa);        Assert.assertEquals(copyDa, testDa);        Assert.assertEquals(testDa, copyDa);    }    @Test    public void testSetElementArbitraryExpansion() {        // MULTIPLICATIVE_MODE        da.addElement(2.0);        da.addElement(4.0);        da.addElement(6.0);        da.setElement(1, 3.0);        // Expand the array arbitrarily to 1000 items        da.setElement(1000, 3.4);        Assert.assertEquals( "The number of elements should now be 1001, it isn't",                da.getNumElements(), 1001);        Assert.assertEquals( "Uninitialized Elements are default value of 0.0, index 766 wasn't", 0.0,                da.getElement( 760 ), Double.MIN_VALUE );        Assert.assertEquals( "The 1000th index should be 3.4, it isn't", 3.4, da.getElement(1000),                Double.MIN_VALUE );        Assert.assertEquals( "The 0th index should be 2.0, it isn't", 2.0, da.getElement(0),                Double.MIN_VALUE);        // Make sure numElements and expansion work correctly for expansion boundary cases        da.clear();        da.addElement(2.0);        da.addElement(4.0);        da.addElement(6.0);        Assert.assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());        Assert.assertEquals(3, da.getNumElements());        da.setElement(3, 7.0);        Assert.assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());        Assert.assertEquals(4, da.getNumElements());        da.setElement(10, 10.0);        Assert.assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());        Assert.assertEquals(11, da.getNumElements());        da.setElement(9, 10.0);        Assert.assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());        Assert.assertEquals(11, da.getNumElements());        try {            da.setElement(-2, 3);            Assert.fail("Expecting ArrayIndexOutOfBoundsException for negative index");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected        }        // ADDITIVE_MODE        ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 3.0f,                ResizableDoubleArray.ADDITIVE_MODE);        Assert.assertEquals(2, testDa.getInternalLength());        testDa.addElement(1d);        testDa.addElement(1d);        Assert.assertEquals(2, testDa.getInternalLength());        testDa.addElement(1d);        Assert.assertEquals(4, testDa.getInternalLength());    }    @Override    @Test    public void testAdd1000() {        super.testAdd1000();        Assert.assertEquals("Internal Storage length should be 1024 if we started out with initial capacity of " +                "16 and an expansion factor of 2.0",                1024, ((ResizableDoubleArray) da).getInternalLength());    }        @Test    public void testAddElements() {        ResizableDoubleArray testDa = new ResizableDoubleArray();                // MULTIPLICATIVE_MODE        testDa.addElements(new double[] {4, 5, 6});        Assert.assertEquals(3, testDa.getNumElements(), 0);        Assert.assertEquals(4, testDa.getElement(0), 0);        Assert.assertEquals(5, testDa.getElement(1), 0);        Assert.assertEquals(6, testDa.getElement(2), 0);                testDa.addElements(new double[] {4, 5, 6});        Assert.assertEquals(6, testDa.getNumElements());        // ADDITIVE_MODE  (x's are occupied storage locations, 0's are open)        testDa = new ResizableDoubleArray(2, 2.0f, 2.5f,                ResizableDoubleArray.ADDITIVE_MODE);                Assert.assertEquals(2, testDa.getInternalLength());        testDa.addElements(new double[] { 1d }); // x,0        testDa.addElements(new double[] { 2d }); // x,x        testDa.addElements(new double[] { 3d }); // x,x,x,0 -- expanded        Assert.assertEquals(1d, testDa.getElement(0), 0);        Assert.assertEquals(2d, testDa.getElement(1), 0);        Assert.assertEquals(3d, testDa.getElement(2), 0);        Assert.assertEquals(4, testDa.getInternalLength());  // x,x,x,0        Assert.assertEquals(3, testDa.getNumElements());    }    @Override    @Test    public void testAddElementRolling() {        super.testAddElementRolling();        // MULTIPLICATIVE_MODE        da.clear();        da.addElement(1);        da.addElement(2);        da.addElementRolling(3);        Assert.assertEquals(3, da.getElement(1), 0);        da.addElementRolling(4);        Assert.assertEquals(3, da.getElement(0), 0);        Assert.assertEquals(4, da.getElement(1), 0);        da.addElement(5);        Assert.assertEquals(5, da.getElement(2), 0);        da.addElementRolling(6);        Assert.assertEquals(4, da.getElement(0), 0);        Assert.assertEquals(5, da.getElement(1), 0);        Assert.assertEquals(6, da.getElement(2), 0);        // ADDITIVE_MODE  (x's are occupied storage locations, 0's are open)        ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 2.5f,                ResizableDoubleArray.ADDITIVE_MODE);        Assert.assertEquals(2, testDa.getInternalLength());        testDa.addElement(1d); // x,0        testDa.addElement(2d); // x,x        testDa.addElement(3d); // x,x,x,0 -- expanded        Assert.assertEquals(1d, testDa.getElement(0), 0);        Assert.assertEquals(2d, testDa.getElement(1), 0);        Assert.assertEquals(3d, testDa.getElement(2), 0);        Assert.assertEquals(4, testDa.getInternalLength());  // x,x,x,0        Assert.assertEquals(3, testDa.getNumElements());        testDa.addElementRolling(4d);        Assert.assertEquals(2d, testDa.getElement(0), 0);        Assert.assertEquals(3d, testDa.getElement(1), 0);        Assert.assertEquals(4d, testDa.getElement(2), 0);        Assert.assertEquals(4, testDa.getInternalLength());  // 0,x,x,x        Assert.assertEquals(3, testDa.getNumElements());        testDa.addElementRolling(5d);   // 0,0,x,x,x,0 -- time to contract        Assert.assertEquals(3d, testDa.getElement(0), 0);        Assert.assertEquals(4d, testDa.getElement(1), 0);        Assert.assertEquals(5d, testDa.getElement(2), 0);        Assert.assertEquals(4, testDa.getInternalLength());  // contracted -- x,x,x,0        Assert.assertEquals(3, testDa.getNumElements());        try {            testDa.getElement(4);            Assert.fail("Expecting ArrayIndexOutOfBoundsException");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected        }        try {            testDa.getElement(-1);            Assert.fail("Expecting ArrayIndexOutOfBoundsException");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected        }    }    @Test    public void testSetNumberOfElements() {        da.addElement( 1.0 );        da.addElement( 1.0 );        da.addElement( 1.0 );        da.addElement( 1.0 );        da.addElement( 1.0 );        da.addElement( 1.0 );        Assert.assertEquals( "Number of elements should equal 6", da.getNumElements(), 6);        ((ResizableDoubleArray) da).setNumElements( 3 );        Assert.assertEquals( "Number of elements should equal 3", da.getNumElements(), 3);        try {            ((ResizableDoubleArray) da).setNumElements( -3 );            Assert.fail( "Setting number of elements to negative should've thrown an exception");        } catch( IllegalArgumentException iae ) {        }        ((ResizableDoubleArray) da).setNumElements(1024);        Assert.assertEquals( "Number of elements should now be 1024", da.getNumElements(), 1024);        Assert.assertEquals( "Element 453 should be a default double", da.getElement( 453 ), 0.0, Double.MIN_VALUE);    }    @Test    public void testWithInitialCapacity() {        ResizableDoubleArray eDA2 = new ResizableDoubleArray(2);        Assert.assertEquals("Initial number of elements should be 0", 0, eDA2.getNumElements());        RandomData randomData = new RandomDataImpl();        int iterations = randomData.nextInt(100, 1000);        for( int i = 0; i < iterations; i++) {            eDA2.addElement( i );        }        Assert.assertEquals("Number of elements should be equal to " + iterations, iterations, eDA2.getNumElements());        eDA2.addElement( 2.0 );        Assert.assertEquals("Number of elements should be equals to " + (iterations +1),                iterations + 1 , eDA2.getNumElements() );    }    @Test    public void testWithInitialCapacityAndExpansionFactor() {        ResizableDoubleArray eDA3 = new ResizableDoubleArray(3, 3.0f, 3.5f);        Assert.assertEquals("Initial number of elements should be 0", 0, eDA3.getNumElements() );        RandomData randomData = new RandomDataImpl();        int iterations = randomData.nextInt(100, 3000);        for( int i = 0; i < iterations; i++) {            eDA3.addElement( i );        }        Assert.assertEquals("Number of elements should be equal to " + iterations, iterations,eDA3.getNumElements());        eDA3.addElement( 2.0 );        Assert.assertEquals("Number of elements should be equals to " + (iterations +1),                iterations +1, eDA3.getNumElements() );        Assert.assertEquals("Expansion factor should equal 3.0", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);    }    @Test    public void testDiscard() {        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        Assert.assertEquals( "Number of elements should be 11", 11, da.getNumElements());        ((ResizableDoubleArray)da).discardFrontElements(5);        Assert.assertEquals( "Number of elements should be 6", 6, da.getNumElements());        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        Assert.assertEquals( "Number of elements should be 10", 10, da.getNumElements());        ((ResizableDoubleArray)da).discardMostRecentElements(2);        Assert.assertEquals( "Number of elements should be 8", 8, da.getNumElements());        try {            ((ResizableDoubleArray)da).discardFrontElements(-1);            Assert.fail( "Trying to discard a negative number of element is not allowed");        } catch( Exception e ){        }        try {            ((ResizableDoubleArray)da).discardMostRecentElements(-1);            Assert.fail( "Trying to discard a negative number of element is not allowed");        } catch( Exception e ){        }        try {            ((ResizableDoubleArray)da).discardFrontElements( 10000 );            Assert.fail( "You can't discard more elements than the array contains");        } catch( Exception e ){        }        try {            ((ResizableDoubleArray)da).discardMostRecentElements( 10000 );            Assert.fail( "You can't discard more elements than the array contains");        } catch( Exception e ){        }    }    @Test    public void testSubstitute() {        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        Assert.assertEquals( "Number of elements should be 11", 11, da.getNumElements());        ((ResizableDoubleArray)da).substituteMostRecentElement(24);        Assert.assertEquals( "Number of elements should be 11", 11, da.getNumElements());        try {            ((ResizableDoubleArray)da).discardMostRecentElements(10);        } catch( Exception e ){            Assert.fail( "Trying to discard a negative number of element is not allowed");        }        ((ResizableDoubleArray)da).substituteMostRecentElement(24);        Assert.assertEquals( "Number of elements should be 1", 1, da.getNumElements());    }    @Test    public void testMutators() {        ((ResizableDoubleArray)da).setContractionCriteria(10f);        Assert.assertEquals(10f, ((ResizableDoubleArray)da).getContractionCriteria(), 0);        ((ResizableDoubleArray)da).setExpansionFactor(8f);        Assert.assertEquals(8f, ((ResizableDoubleArray)da).getExpansionFactor(), 0);        try {            ((ResizableDoubleArray)da).setExpansionFactor(11f);  // greater than contractionCriteria            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        ((ResizableDoubleArray)da).setExpansionMode(                ResizableDoubleArray.ADDITIVE_MODE);        Assert.assertEquals(ResizableDoubleArray.ADDITIVE_MODE,                ((ResizableDoubleArray)da).getExpansionMode());        try {            ((ResizableDoubleArray)da).setExpansionMode(-1);            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }    @Test    public void testEqualsAndHashCode() throws Exception {        // Wrong type        ResizableDoubleArray first = new ResizableDoubleArray();        Double other = new Double(2);        Assert.assertFalse(first.equals(other));        // Null        other = null;        Assert.assertFalse(first.equals(other));        // Reflexive        Assert.assertTrue(first.equals(first));        // Argumentless constructor        ResizableDoubleArray second = new ResizableDoubleArray();        verifyEquality(first, second);        // Equals iff same data, same properties        ResizableDoubleArray third = new ResizableDoubleArray(3, 2.0f, 2.0f);        verifyInequality(third, first);        ResizableDoubleArray fourth = new ResizableDoubleArray(3, 2.0f, 2.0f);        ResizableDoubleArray fifth = new ResizableDoubleArray(2, 2.0f, 2.0f);        verifyEquality(third, fourth);        verifyInequality(third, fifth);        third.addElement(4.1);        third.addElement(4.2);        third.addElement(4.3);        fourth.addElement(4.1);        fourth.addElement(4.2);        fourth.addElement(4.3);        verifyEquality(third, fourth);        // expand        fourth.addElement(4.4);        verifyInequality(third, fourth);        third.addElement(4.4);        verifyEquality(third, fourth);        fourth.addElement(4.4);        verifyInequality(third, fourth);        third.addElement(4.4);        verifyEquality(third, fourth);        fourth.addElementRolling(4.5);        third.addElementRolling(4.5);        verifyEquality(third, fourth);        // discard        third.discardFrontElements(1);        verifyInequality(third, fourth);        fourth.discardFrontElements(1);        verifyEquality(third, fourth);        // discard recent        third.discardMostRecentElements(2);        fourth.discardMostRecentElements(2);        verifyEquality(third, fourth);        // wrong order        third.addElement(18);        fourth.addElement(17);        third.addElement(17);        fourth.addElement(18);        verifyInequality(third, fourth);        // copy        ResizableDoubleArray.copy(fourth, fifth);        verifyEquality(fourth, fifth);        // Copy constructor        verifyEquality(fourth, new ResizableDoubleArray(fourth));        // Instance copy        verifyEquality(fourth, fourth.copy());    }    private void verifyEquality(ResizableDoubleArray a, ResizableDoubleArray b) {        Assert.assertTrue(b.equals(a));        Assert.assertTrue(a.equals(b));        Assert.assertEquals(a.hashCode(), b.hashCode());    }    private void verifyInequality(ResizableDoubleArray a, ResizableDoubleArray b) {        Assert.assertFalse(b.equals(a));        Assert.assertFalse(a.equals(b));        Assert.assertFalse(a.hashCode() == b.hashCode());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.util;import java.math.BigDecimal;import java.math.BigInteger;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.commons.math.TestUtils;import org.apache.commons.math.exception.NonMonotonousSequenceException;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.exception.MathArithmeticException;import org.apache.commons.math.exception.NotFiniteNumberException;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.exception.util.LocalizedFormats;import org.apache.commons.math.random.RandomDataImpl;import org.apache.commons.math.random.Well1024a;import org.junit.Assert;import org.junit.Test;/** * Test cases for the MathUtils class. * @version $Id$ *          2007) $ */public final class MathUtilsTest {    /** cached binomial coefficients */    private static final List<Map<Integer, Long>> binomialCache = new ArrayList<Map<Integer, Long>>();    /**     * Exact (caching) recursive implementation to test against     */    private long binomialCoefficient(int n, int k) throws MathArithmeticException {        if (binomialCache.size() > n) {            Long cachedResult = binomialCache.get(n).get(Integer.valueOf(k));            if (cachedResult != null) {                return cachedResult.longValue();            }        }        long result = -1;        if ((n == k) || (k == 0)) {            result = 1;        } else if ((k == 1) || (k == n - 1)) {            result = n;        } else {            // Reduce stack depth for larger values of n            if (k < n - 100) {                binomialCoefficient(n - 100, k);            }            if (k > 100) {                binomialCoefficient(n - 100, k - 100);            }            result = MathUtils.addAndCheck(binomialCoefficient(n - 1, k - 1),                binomialCoefficient(n - 1, k));        }        if (result == -1) {            throw new MathArithmeticException();        }        for (int i = binomialCache.size(); i < n + 1; i++) {            binomialCache.add(new HashMap<Integer, Long>());        }        binomialCache.get(n).put(Integer.valueOf(k), Long.valueOf(result));        return result;    }    /**     * Exact direct multiplication implementation to test against     */    private long factorial(int n) {        long result = 1;        for (int i = 2; i <= n; i++) {            result *= i;        }        return result;    }    /** Verify that b(0,0) = 1 */    @Test    public void test0Choose0() {        Assert.assertEquals(MathUtils.binomialCoefficientDouble(0, 0), 1d, 0);        Assert.assertEquals(MathUtils.binomialCoefficientLog(0, 0), 0d, 0);        Assert.assertEquals(MathUtils.binomialCoefficient(0, 0), 1);    }    @Test    public void testAddAndCheck() {        int big = Integer.MAX_VALUE;        int bigNeg = Integer.MIN_VALUE;        Assert.assertEquals(big, MathUtils.addAndCheck(big, 0));        try {            MathUtils.addAndCheck(big, 1);            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException ex) {        }        try {            MathUtils.addAndCheck(bigNeg, -1);            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException ex) {        }    }    @Test    public void testAddAndCheckLong() {        long max = Long.MAX_VALUE;        long min = Long.MIN_VALUE;        Assert.assertEquals(max, MathUtils.addAndCheck(max, 0L));        Assert.assertEquals(min, MathUtils.addAndCheck(min, 0L));        Assert.assertEquals(max, MathUtils.addAndCheck(0L, max));        Assert.assertEquals(min, MathUtils.addAndCheck(0L, min));        Assert.assertEquals(1, MathUtils.addAndCheck(-1L, 2L));        Assert.assertEquals(1, MathUtils.addAndCheck(2L, -1L));        Assert.assertEquals(-3, MathUtils.addAndCheck(-2L, -1L));        Assert.assertEquals(min, MathUtils.addAndCheck(min + 1, -1L));        testAddAndCheckLongFailure(max, 1L);        testAddAndCheckLongFailure(min, -1L);        testAddAndCheckLongFailure(1L, max);        testAddAndCheckLongFailure(-1L, min);    }    private void testAddAndCheckLongFailure(long a, long b) {        try {            MathUtils.addAndCheck(a, b);            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException ex) {            // success        }    }    @Test    public void testBinomialCoefficient() {        long[] bcoef5 = {            1,            5,            10,            10,            5,            1 };        long[] bcoef6 = {            1,            6,            15,            20,            15,            6,            1 };        for (int i = 0; i < 6; i++) {            Assert.assertEquals("5 choose " + i, bcoef5[i], MathUtils.binomialCoefficient(5, i));        }        for (int i = 0; i < 7; i++) {            Assert.assertEquals("6 choose " + i, bcoef6[i], MathUtils.binomialCoefficient(6, i));        }        for (int n = 1; n < 10; n++) {            for (int k = 0; k <= n; k++) {                Assert.assertEquals(n + " choose " + k, binomialCoefficient(n, k), MathUtils.binomialCoefficient(n, k));                Assert.assertEquals(n + " choose " + k, binomialCoefficient(n, k), MathUtils.binomialCoefficientDouble(n, k), Double.MIN_VALUE);                Assert.assertEquals(n + " choose " + k, FastMath.log(binomialCoefficient(n, k)), MathUtils.binomialCoefficientLog(n, k), 10E-12);            }        }        int[] n = { 34, 66, 100, 1500, 1500 };        int[] k = { 17, 33, 10, 1500 - 4, 4 };        for (int i = 0; i < n.length; i++) {            long expected = binomialCoefficient(n[i], k[i]);            Assert.assertEquals(n[i] + " choose " + k[i], expected,                MathUtils.binomialCoefficient(n[i], k[i]));            Assert.assertEquals(n[i] + " choose " + k[i], expected,                MathUtils.binomialCoefficientDouble(n[i], k[i]), 0.0);            Assert.assertEquals("log(" + n[i] + " choose " + k[i] + ")", FastMath.log(expected),                MathUtils.binomialCoefficientLog(n[i], k[i]), 0.0);        }    }    /**     * Tests correctness for large n and sharpness of upper bound in API doc     * JIRA: MATH-241     */    @Test    public void testBinomialCoefficientLarge() throws Exception {        // This tests all legal and illegal values for n <= 200.        for (int n = 0; n <= 200; n++) {            for (int k = 0; k <= n; k++) {                long ourResult = -1;                long exactResult = -1;                boolean shouldThrow = false;                boolean didThrow = false;                try {                    ourResult = MathUtils.binomialCoefficient(n, k);                } catch (MathArithmeticException ex) {                    didThrow = true;                }                try {                    exactResult = binomialCoefficient(n, k);                } catch (MathArithmeticException ex) {                    shouldThrow = true;                }                Assert.assertEquals(n + " choose " + k, exactResult, ourResult);                Assert.assertEquals(n + " choose " + k, shouldThrow, didThrow);                Assert.assertTrue(n + " choose " + k, (n > 66 || !didThrow));                if (!shouldThrow && exactResult > 1) {                    Assert.assertEquals(n + " choose " + k, 1.,                        MathUtils.binomialCoefficientDouble(n, k) / exactResult, 1e-10);                    Assert.assertEquals(n + " choose " + k, 1,                        MathUtils.binomialCoefficientLog(n, k) / FastMath.log(exactResult), 1e-10);                }            }        }        long ourResult = MathUtils.binomialCoefficient(300, 3);        long exactResult = binomialCoefficient(300, 3);        Assert.assertEquals(exactResult, ourResult);        ourResult = MathUtils.binomialCoefficient(700, 697);        exactResult = binomialCoefficient(700, 697);        Assert.assertEquals(exactResult, ourResult);        // This one should throw        try {            MathUtils.binomialCoefficient(700, 300);            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException ex) {            // Expected        }        int n = 10000;        ourResult = MathUtils.binomialCoefficient(n, 3);        exactResult = binomialCoefficient(n, 3);        Assert.assertEquals(exactResult, ourResult);        Assert.assertEquals(1, MathUtils.binomialCoefficientDouble(n, 3) / exactResult, 1e-10);        Assert.assertEquals(1, MathUtils.binomialCoefficientLog(n, 3) / FastMath.log(exactResult), 1e-10);    }    @Test    public void testBinomialCoefficientFail() {        try {            MathUtils.binomialCoefficient(4, 5);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficientDouble(4, 5);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficientLog(4, 5);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficient(-1, -2);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficientDouble(-1, -2);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficientLog(-1, -2);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficient(67, 30);            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException ex) {            // ignored        }        try {            MathUtils.binomialCoefficient(67, 34);            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException ex) {            // ignored        }        double x = MathUtils.binomialCoefficientDouble(1030, 515);        Assert.assertTrue("expecting infinite binomial coefficient", Double            .isInfinite(x));    }    @Test    public void testCompareToEpsilon() {        Assert.assertEquals(0, MathUtils.compareTo(152.33, 152.32, .011));        Assert.assertTrue(MathUtils.compareTo(152.308, 152.32, .011) < 0);        Assert.assertTrue(MathUtils.compareTo(152.33, 152.318, .011) > 0);        Assert.assertEquals(0, MathUtils.compareTo(Double.MIN_VALUE, +0.0, Double.MIN_VALUE));        Assert.assertEquals(0, MathUtils.compareTo(Double.MIN_VALUE, -0.0, Double.MIN_VALUE));    }    @Test    public void testCompareToMaxUlps() {        double a     = 152.32;        double delta = FastMath.ulp(a);        for (int i = 0; i <= 10; ++i) {            if (i <= 5) {                Assert.assertEquals( 0, MathUtils.compareTo(a, a + i * delta, 5));                Assert.assertEquals( 0, MathUtils.compareTo(a, a - i * delta, 5));            } else {                Assert.assertEquals(-1, MathUtils.compareTo(a, a + i * delta, 5));                Assert.assertEquals(+1, MathUtils.compareTo(a, a - i * delta, 5));            }        }        Assert.assertEquals( 0, MathUtils.compareTo(-0.0, 0.0, 0));        Assert.assertEquals(-1, MathUtils.compareTo(-Double.MIN_VALUE, -0.0, 0));        Assert.assertEquals( 0, MathUtils.compareTo(-Double.MIN_VALUE, -0.0, 1));        Assert.assertEquals(-1, MathUtils.compareTo(-Double.MIN_VALUE, +0.0, 0));        Assert.assertEquals( 0, MathUtils.compareTo(-Double.MIN_VALUE, +0.0, 1));        Assert.assertEquals(+1, MathUtils.compareTo( Double.MIN_VALUE, -0.0, 0));        Assert.assertEquals( 0, MathUtils.compareTo( Double.MIN_VALUE, -0.0, 1));        Assert.assertEquals(+1, MathUtils.compareTo( Double.MIN_VALUE, +0.0, 0));        Assert.assertEquals( 0, MathUtils.compareTo( Double.MIN_VALUE, +0.0, 1));        Assert.assertEquals(-1, MathUtils.compareTo(-Double.MIN_VALUE, Double.MIN_VALUE, 0));        Assert.assertEquals(-1, MathUtils.compareTo(-Double.MIN_VALUE, Double.MIN_VALUE, 1));        Assert.assertEquals( 0, MathUtils.compareTo(-Double.MIN_VALUE, Double.MIN_VALUE, 2));        Assert.assertEquals( 0, MathUtils.compareTo(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));        Assert.assertEquals(-1, MathUtils.compareTo(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 0));        Assert.assertEquals(+1, MathUtils.compareTo(Double.MAX_VALUE, Double.NaN, Integer.MAX_VALUE));        Assert.assertEquals(+1, MathUtils.compareTo(Double.NaN, Double.MAX_VALUE, Integer.MAX_VALUE));    }    @Test    public void testCosh() {        double x = 3.0;        double expected = 10.06766;        Assert.assertEquals(expected, MathUtils.cosh(x), 1.0e-5);    }    @Test    public void testCoshNaN() {        Assert.assertTrue(Double.isNaN(MathUtils.cosh(Double.NaN)));    }    @Test    public void testEqualsIncludingNaN() {        double[] testArray = {            Double.NaN,            Double.POSITIVE_INFINITY,            Double.NEGATIVE_INFINITY,            1d,            0d };        for (int i = 0; i < testArray.length; i++) {            for (int j = 0; j < testArray.length; j++) {                if (i == j) {                    Assert.assertTrue(MathUtils.equalsIncludingNaN(testArray[i], testArray[j]));                    Assert.assertTrue(MathUtils.equalsIncludingNaN(testArray[j], testArray[i]));                } else {                    Assert.assertTrue(!MathUtils.equalsIncludingNaN(testArray[i], testArray[j]));                    Assert.assertTrue(!MathUtils.equalsIncludingNaN(testArray[j], testArray[i]));                }            }        }    }    @Test    public void testEqualsWithAllowedDelta() {        Assert.assertTrue(MathUtils.equals(153.0000, 153.0000, .0625));        Assert.assertTrue(MathUtils.equals(153.0000, 153.0625, .0625));        Assert.assertTrue(MathUtils.equals(152.9375, 153.0000, .0625));        Assert.assertFalse(MathUtils.equals(153.0000, 153.0625, .0624));        Assert.assertFalse(MathUtils.equals(152.9374, 153.0000, .0625));        Assert.assertFalse(MathUtils.equals(Double.NaN, Double.NaN, 1.0));        Assert.assertTrue(MathUtils.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));        Assert.assertTrue(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0));        Assert.assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));    }    @Test    public void testMath475() {        final double a = 1.7976931348623182E16;        final double b = FastMath.nextUp(a);        double diff = FastMath.abs(a - b);        // Because they are adjacent floating point numbers, "a" and "b" are        // considered equal even though the allowed error is smaller than        // their difference.        Assert.assertTrue(MathUtils.equals(a, b, 0.5 * diff));        final double c = FastMath.nextUp(b);        diff = FastMath.abs(a - c);        // Because "a" and "c" are not adjacent, the tolerance is taken into        // account for assessing equality.        Assert.assertTrue(MathUtils.equals(a, c, diff));        Assert.assertFalse(MathUtils.equals(a, c, (1 - 1e-16) * diff));    }    @Test    public void testEqualsIncludingNaNWithAllowedDelta() {        Assert.assertTrue(MathUtils.equalsIncludingNaN(153.0000, 153.0000, .0625));        Assert.assertTrue(MathUtils.equalsIncludingNaN(153.0000, 153.0625, .0625));        Assert.assertTrue(MathUtils.equalsIncludingNaN(152.9375, 153.0000, .0625));        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.NaN, Double.NaN, 1.0));        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0));        Assert.assertFalse(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));        Assert.assertFalse(MathUtils.equalsIncludingNaN(153.0000, 153.0625, .0624));        Assert.assertFalse(MathUtils.equalsIncludingNaN(152.9374, 153.0000, .0625));    }    // Tests for floating point equality    @Test    public void testFloatEqualsWithAllowedUlps() {        Assert.assertTrue("+0.0f == -0.0f",MathUtils.equals(0.0f, -0.0f));        Assert.assertTrue("+0.0f == -0.0f (1 ulp)",MathUtils.equals(0.0f, -0.0f, 1));        float oneFloat = 1.0f;        Assert.assertTrue("1.0f == 1.0f + 1 ulp",MathUtils.equals(oneFloat, Float.intBitsToFloat(1 + Float.floatToIntBits(oneFloat))));        Assert.assertTrue("1.0f == 1.0f + 1 ulp (1 ulp)",MathUtils.equals(oneFloat, Float.intBitsToFloat(1 + Float.floatToIntBits(oneFloat)), 1));        Assert.assertFalse("1.0f != 1.0f + 2 ulp (1 ulp)",MathUtils.equals(oneFloat, Float.intBitsToFloat(2 + Float.floatToIntBits(oneFloat)), 1));        Assert.assertTrue(MathUtils.equals(153.0f, 153.0f, 1));        // These tests need adjusting for floating point precision//        Assert.assertTrue(MathUtils.equals(153.0f, 153.00000000000003f, 1));//        Assert.assertFalse(MathUtils.equals(153.0f, 153.00000000000006f, 1));//        Assert.assertTrue(MathUtils.equals(153.0f, 152.99999999999997f, 1));//        Assert.assertFalse(MathUtils.equals(153f, 152.99999999999994f, 1));////        Assert.assertTrue(MathUtils.equals(-128.0f, -127.99999999999999f, 1));//        Assert.assertFalse(MathUtils.equals(-128.0f, -127.99999999999997f, 1));//        Assert.assertTrue(MathUtils.equals(-128.0f, -128.00000000000003f, 1));//        Assert.assertFalse(MathUtils.equals(-128.0f, -128.00000000000006f, 1));        Assert.assertTrue(MathUtils.equals(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY, 1));        Assert.assertTrue(MathUtils.equals(Double.MAX_VALUE, Float.POSITIVE_INFINITY, 1));        Assert.assertTrue(MathUtils.equals(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY, 1));        Assert.assertTrue(MathUtils.equals(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY, 1));        Assert.assertFalse(MathUtils.equals(Float.NaN, Float.NaN, 1));        Assert.assertFalse(MathUtils.equals(Float.NaN, Float.NaN, 0));        Assert.assertFalse(MathUtils.equals(Float.NaN, 0, 0));        Assert.assertFalse(MathUtils.equals(Float.NaN, Float.POSITIVE_INFINITY, 0));        Assert.assertFalse(MathUtils.equals(Float.NaN, Float.NEGATIVE_INFINITY, 0));        Assert.assertFalse(MathUtils.equals(Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, 100000));    }    @Test    public void testEqualsWithAllowedUlps() {        Assert.assertTrue(MathUtils.equals(0.0, -0.0, 1));        Assert.assertTrue(MathUtils.equals(1.0, 1 + FastMath.ulp(1d), 1));        Assert.assertFalse(MathUtils.equals(1.0, 1 + 2 * FastMath.ulp(1d), 1));        final double nUp1 = FastMath.nextAfter(1d, Double.POSITIVE_INFINITY);        final double nnUp1 = FastMath.nextAfter(nUp1, Double.POSITIVE_INFINITY);        Assert.assertTrue(MathUtils.equals(1.0, nUp1, 1));        Assert.assertTrue(MathUtils.equals(nUp1, nnUp1, 1));        Assert.assertFalse(MathUtils.equals(1.0, nnUp1, 1));        Assert.assertTrue(MathUtils.equals(0.0, FastMath.ulp(0d), 1));        Assert.assertTrue(MathUtils.equals(0.0, -FastMath.ulp(0d), 1));        Assert.assertTrue(MathUtils.equals(153.0, 153.0, 1));        Assert.assertTrue(MathUtils.equals(153.0, 153.00000000000003, 1));        Assert.assertFalse(MathUtils.equals(153.0, 153.00000000000006, 1));        Assert.assertTrue(MathUtils.equals(153.0, 152.99999999999997, 1));        Assert.assertFalse(MathUtils.equals(153, 152.99999999999994, 1));        Assert.assertTrue(MathUtils.equals(-128.0, -127.99999999999999, 1));        Assert.assertFalse(MathUtils.equals(-128.0, -127.99999999999997, 1));        Assert.assertTrue(MathUtils.equals(-128.0, -128.00000000000003, 1));        Assert.assertFalse(MathUtils.equals(-128.0, -128.00000000000006, 1));        Assert.assertTrue(MathUtils.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1));        Assert.assertTrue(MathUtils.equals(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));        Assert.assertTrue(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1));        Assert.assertTrue(MathUtils.equals(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1));        Assert.assertFalse(MathUtils.equals(Double.NaN, Double.NaN, 1));        Assert.assertFalse(MathUtils.equals(Double.NaN, Double.NaN, 0));        Assert.assertFalse(MathUtils.equals(Double.NaN, 0, 0));        Assert.assertFalse(MathUtils.equals(Double.NaN, Double.POSITIVE_INFINITY, 0));        Assert.assertFalse(MathUtils.equals(Double.NaN, Double.NEGATIVE_INFINITY, 0));        Assert.assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));    }    @Test    public void testEqualsIncludingNaNWithAllowedUlps() {        Assert.assertTrue(MathUtils.equalsIncludingNaN(0.0, -0.0, 1));        Assert.assertTrue(MathUtils.equalsIncludingNaN(1.0, 1 + FastMath.ulp(1d), 1));        Assert.assertFalse(MathUtils.equalsIncludingNaN(1.0, 1 + 2 * FastMath.ulp(1d), 1));        final double nUp1 = FastMath.nextAfter(1d, Double.POSITIVE_INFINITY);        final double nnUp1 = FastMath.nextAfter(nUp1, Double.POSITIVE_INFINITY);        Assert.assertTrue(MathUtils.equalsIncludingNaN(1.0, nUp1, 1));        Assert.assertTrue(MathUtils.equalsIncludingNaN(nUp1, nnUp1, 1));        Assert.assertFalse(MathUtils.equalsIncludingNaN(1.0, nnUp1, 1));        Assert.assertTrue(MathUtils.equalsIncludingNaN(0.0, FastMath.ulp(0d), 1));        Assert.assertTrue(MathUtils.equalsIncludingNaN(0.0, -FastMath.ulp(0d), 1));        Assert.assertTrue(MathUtils.equalsIncludingNaN(153.0, 153.0, 1));        Assert.assertTrue(MathUtils.equalsIncludingNaN(153.0, 153.00000000000003, 1));        Assert.assertFalse(MathUtils.equalsIncludingNaN(153.0, 153.00000000000006, 1));        Assert.assertTrue(MathUtils.equalsIncludingNaN(153.0, 152.99999999999997, 1));        Assert.assertFalse(MathUtils.equalsIncludingNaN(153, 152.99999999999994, 1));        Assert.assertTrue(MathUtils.equalsIncludingNaN(-128.0, -127.99999999999999, 1));        Assert.assertFalse(MathUtils.equalsIncludingNaN(-128.0, -127.99999999999997, 1));        Assert.assertTrue(MathUtils.equalsIncludingNaN(-128.0, -128.00000000000003, 1));        Assert.assertFalse(MathUtils.equalsIncludingNaN(-128.0, -128.00000000000006, 1));        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1));        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1));        Assert.assertTrue(MathUtils.equalsIncludingNaN(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1));        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.NaN, Double.NaN, 1));        Assert.assertFalse(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));    }    @Test    public void testArrayEquals() {        Assert.assertFalse(MathUtils.equals(new double[] { 1d }, null));        Assert.assertFalse(MathUtils.equals(null, new double[] { 1d }));        Assert.assertTrue(MathUtils.equals((double[]) null, (double[]) null));        Assert.assertFalse(MathUtils.equals(new double[] { 1d }, new double[0]));        Assert.assertTrue(MathUtils.equals(new double[] { 1d }, new double[] { 1d }));        Assert.assertTrue(MathUtils.equals(new double[] {                                      Double.POSITIVE_INFINITY,                                      Double.NEGATIVE_INFINITY, 1d, 0d                                    }, new double[] {                                      Double.POSITIVE_INFINITY,                                      Double.NEGATIVE_INFINITY, 1d, 0d                                    }));        Assert.assertFalse(MathUtils.equals(new double[] { Double.NaN },                                     new double[] { Double.NaN }));        Assert.assertFalse(MathUtils.equals(new double[] { Double.POSITIVE_INFINITY },                                     new double[] { Double.NEGATIVE_INFINITY }));        Assert.assertFalse(MathUtils.equals(new double[] { 1d },                                     new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) }));    }    @Test    public void testArrayEqualsIncludingNaN() {        Assert.assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d }, null));        Assert.assertFalse(MathUtils.equalsIncludingNaN(null, new double[] { 1d }));        Assert.assertTrue(MathUtils.equalsIncludingNaN((double[]) null, (double[]) null));        Assert.assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d }, new double[0]));        Assert.assertTrue(MathUtils.equalsIncludingNaN(new double[] { 1d }, new double[] { 1d }));        Assert.assertTrue(MathUtils.equalsIncludingNaN(new double[] {                    Double.NaN, Double.POSITIVE_INFINITY,                    Double.NEGATIVE_INFINITY, 1d, 0d                }, new double[] {                    Double.NaN, Double.POSITIVE_INFINITY,                    Double.NEGATIVE_INFINITY, 1d, 0d                }));        Assert.assertFalse(MathUtils.equalsIncludingNaN(new double[] { Double.POSITIVE_INFINITY },                                                 new double[] { Double.NEGATIVE_INFINITY }));        Assert.assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d },                                                 new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) }));    }    @Test    public void testFactorial() {        for (int i = 1; i < 21; i++) {            Assert.assertEquals(i + "! ", factorial(i), MathUtils.factorial(i));            Assert.assertEquals(i + "! ", factorial(i), MathUtils.factorialDouble(i), Double.MIN_VALUE);            Assert.assertEquals(i + "! ", FastMath.log(factorial(i)), MathUtils.factorialLog(i), 10E-12);        }        Assert.assertEquals("0", 1, MathUtils.factorial(0));        Assert.assertEquals("0", 1.0d, MathUtils.factorialDouble(0), 1E-14);        Assert.assertEquals("0", 0.0d, MathUtils.factorialLog(0), 1E-14);    }    @Test    public void testFactorialFail() {        try {            MathUtils.factorial(-1);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }        try {            MathUtils.factorialDouble(-1);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }        try {            MathUtils.factorialLog(-1);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }        try {            MathUtils.factorial(21);            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException ex) {            // ignored        }        Assert.assertTrue("expecting infinite factorial value", Double.isInfinite(MathUtils.factorialDouble(171)));    }    @Test    public void testGcd() {        int a = 30;        int b = 50;        int c = 77;        Assert.assertEquals(0, MathUtils.gcd(0, 0));        Assert.assertEquals(b, MathUtils.gcd(0, b));        Assert.assertEquals(a, MathUtils.gcd(a, 0));        Assert.assertEquals(b, MathUtils.gcd(0, -b));        Assert.assertEquals(a, MathUtils.gcd(-a, 0));        Assert.assertEquals(10, MathUtils.gcd(a, b));        Assert.assertEquals(10, MathUtils.gcd(-a, b));        Assert.assertEquals(10, MathUtils.gcd(a, -b));        Assert.assertEquals(10, MathUtils.gcd(-a, -b));        Assert.assertEquals(1, MathUtils.gcd(a, c));        Assert.assertEquals(1, MathUtils.gcd(-a, c));        Assert.assertEquals(1, MathUtils.gcd(a, -c));        Assert.assertEquals(1, MathUtils.gcd(-a, -c));        Assert.assertEquals(3 * (1<<15), MathUtils.gcd(3 * (1<<20), 9 * (1<<15)));        Assert.assertEquals(Integer.MAX_VALUE, MathUtils.gcd(Integer.MAX_VALUE, 0));        Assert.assertEquals(Integer.MAX_VALUE, MathUtils.gcd(-Integer.MAX_VALUE, 0));        Assert.assertEquals(1<<30, MathUtils.gcd(1<<30, -Integer.MIN_VALUE));        try {            // gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE            MathUtils.gcd(Integer.MIN_VALUE, 0);            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException expected) {            // expected        }        try {            // gcd(0, Integer.MIN_VALUE) > Integer.MAX_VALUE            MathUtils.gcd(0, Integer.MIN_VALUE);            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException expected) {            // expected        }        try {            // gcd(Integer.MIN_VALUE, Integer.MIN_VALUE) > Integer.MAX_VALUE            MathUtils.gcd(Integer.MIN_VALUE, Integer.MIN_VALUE);            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException expected) {            // expected        }    }    @Test    public void  testGcdLong(){        long a = 30;        long b = 50;        long c = 77;        Assert.assertEquals(0, MathUtils.gcd(0L, 0));        Assert.assertEquals(b, MathUtils.gcd(0, b));        Assert.assertEquals(a, MathUtils.gcd(a, 0));        Assert.assertEquals(b, MathUtils.gcd(0, -b));        Assert.assertEquals(a, MathUtils.gcd(-a, 0));        Assert.assertEquals(10, MathUtils.gcd(a, b));        Assert.assertEquals(10, MathUtils.gcd(-a, b));        Assert.assertEquals(10, MathUtils.gcd(a, -b));        Assert.assertEquals(10, MathUtils.gcd(-a, -b));        Assert.assertEquals(1, MathUtils.gcd(a, c));        Assert.assertEquals(1, MathUtils.gcd(-a, c));        Assert.assertEquals(1, MathUtils.gcd(a, -c));        Assert.assertEquals(1, MathUtils.gcd(-a, -c));        Assert.assertEquals(3L * (1L<<45), MathUtils.gcd(3L * (1L<<50), 9L * (1L<<45)));        Assert.assertEquals(1L<<45, MathUtils.gcd(1L<<45, Long.MIN_VALUE));        Assert.assertEquals(Long.MAX_VALUE, MathUtils.gcd(Long.MAX_VALUE, 0L));        Assert.assertEquals(Long.MAX_VALUE, MathUtils.gcd(-Long.MAX_VALUE, 0L));        Assert.assertEquals(1, MathUtils.gcd(60247241209L, 153092023L));        try {            // gcd(Long.MIN_VALUE, 0) > Long.MAX_VALUE            MathUtils.gcd(Long.MIN_VALUE, 0);            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException expected) {            // expected        }        try {            // gcd(0, Long.MIN_VALUE) > Long.MAX_VALUE            MathUtils.gcd(0, Long.MIN_VALUE);            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException expected) {            // expected        }        try {            // gcd(Long.MIN_VALUE, Long.MIN_VALUE) > Long.MAX_VALUE            MathUtils.gcd(Long.MIN_VALUE, Long.MIN_VALUE);            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException expected) {            // expected        }    }    @Test    public void testGcdConsistency() {        int[] primeList = {19, 23, 53, 67, 73, 79, 101, 103, 111, 131};        ArrayList<Integer> primes = new ArrayList<Integer>();        for (int i = 0; i < primeList.length; i++) {            primes.add(Integer.valueOf(primeList[i]));        }        RandomDataImpl randomData = new RandomDataImpl();        for (int i = 0; i < 20; i++) {            Object[] sample = randomData.nextSample(primes, 4);            int p1 = ((Integer) sample[0]).intValue();            int p2 = ((Integer) sample[1]).intValue();            int p3 = ((Integer) sample[2]).intValue();            int p4 = ((Integer) sample[3]).intValue();            int i1 = p1 * p2 * p3;            int i2 = p1 * p2 * p4;            int gcd = p1 * p2;            Assert.assertEquals(gcd, MathUtils.gcd(i1, i2));            long l1 = i1;            long l2 = i2;            Assert.assertEquals(gcd, MathUtils.gcd(l1, l2));        }    }    @Test    public void testHash() {        double[] testArray = {            Double.NaN,            Double.POSITIVE_INFINITY,            Double.NEGATIVE_INFINITY,            1d,            0d,            1E-14,            (1 + 1E-14),            Double.MIN_VALUE,            Double.MAX_VALUE };        for (int i = 0; i < testArray.length; i++) {            for (int j = 0; j < testArray.length; j++) {                if (i == j) {                    Assert.assertEquals(MathUtils.hash(testArray[i]), MathUtils.hash(testArray[j]));                    Assert.assertEquals(MathUtils.hash(testArray[j]), MathUtils.hash(testArray[i]));                } else {                    Assert.assertTrue(MathUtils.hash(testArray[i]) != MathUtils.hash(testArray[j]));                    Assert.assertTrue(MathUtils.hash(testArray[j]) != MathUtils.hash(testArray[i]));                }            }        }    }    @Test    public void testArrayHash() {        Assert.assertEquals(0, MathUtils.hash((double[]) null));        Assert.assertEquals(MathUtils.hash(new double[] {                                      Double.NaN, Double.POSITIVE_INFINITY,                                      Double.NEGATIVE_INFINITY, 1d, 0d                                    }),                     MathUtils.hash(new double[] {                                      Double.NaN, Double.POSITIVE_INFINITY,                                      Double.NEGATIVE_INFINITY, 1d, 0d                                    }));        Assert.assertFalse(MathUtils.hash(new double[] { 1d }) ==                    MathUtils.hash(new double[] { FastMath.nextAfter(1d, 2d) }));        Assert.assertFalse(MathUtils.hash(new double[] { 1d }) ==                    MathUtils.hash(new double[] { 1d, 1d }));    }    /**     * Make sure that permuted arrays do not hash to the same value.     */    @Test    public void testPermutedArrayHash() {        double[] original = new double[10];        double[] permuted = new double[10];        RandomDataImpl random = new RandomDataImpl();        // Generate 10 distinct random values        for (int i = 0; i < 10; i++) {            original[i] = random.nextUniform(i + 0.5, i + 0.75);        }        // Generate a random permutation, making sure it is not the identity        boolean isIdentity = true;        do {            int[] permutation = random.nextPermutation(10, 10);            for (int i = 0; i < 10; i++) {                if (i != permutation[i]) {                    isIdentity = false;                }                permuted[i] = original[permutation[i]];            }        } while (isIdentity);        // Verify that permuted array has different hash        Assert.assertFalse(MathUtils.hash(original) == MathUtils.hash(permuted));    }    @Test    public void testIndicatorByte() {        Assert.assertEquals((byte)1, MathUtils.indicator((byte)2));        Assert.assertEquals((byte)1, MathUtils.indicator((byte)0));        Assert.assertEquals((byte)(-1), MathUtils.indicator((byte)(-2)));    }    @Test    public void testIndicatorDouble() {        double delta = 0.0;        Assert.assertEquals(1.0, MathUtils.indicator(2.0), delta);        Assert.assertEquals(1.0, MathUtils.indicator(0.0), delta);        Assert.assertEquals(-1.0, MathUtils.indicator(-2.0), delta);        Assert.assertTrue(Double.isNaN(MathUtils.indicator(Double.NaN)));    }    @Test    public void testIndicatorFloat() {        float delta = 0.0F;        Assert.assertEquals(1.0F, MathUtils.indicator(2.0F), delta);        Assert.assertEquals(1.0F, MathUtils.indicator(0.0F), delta);        Assert.assertEquals(-1.0F, MathUtils.indicator(-2.0F), delta);    }    @Test    public void testIndicatorInt() {        Assert.assertEquals(1, MathUtils.indicator((2)));        Assert.assertEquals(1, MathUtils.indicator((0)));        Assert.assertEquals((-1), MathUtils.indicator((-2)));    }    @Test    public void testIndicatorLong() {        Assert.assertEquals(1L, MathUtils.indicator(2L));        Assert.assertEquals(1L, MathUtils.indicator(0L));        Assert.assertEquals(-1L, MathUtils.indicator(-2L));    }    @Test    public void testIndicatorShort() {        Assert.assertEquals((short)1, MathUtils.indicator((short)2));        Assert.assertEquals((short)1, MathUtils.indicator((short)0));        Assert.assertEquals((short)(-1), MathUtils.indicator((short)(-2)));    }    @Test    public void testLcm() {        int a = 30;        int b = 50;        int c = 77;        Assert.assertEquals(0, MathUtils.lcm(0, b));        Assert.assertEquals(0, MathUtils.lcm(a, 0));        Assert.assertEquals(b, MathUtils.lcm(1, b));        Assert.assertEquals(a, MathUtils.lcm(a, 1));        Assert.assertEquals(150, MathUtils.lcm(a, b));        Assert.assertEquals(150, MathUtils.lcm(-a, b));        Assert.assertEquals(150, MathUtils.lcm(a, -b));        Assert.assertEquals(150, MathUtils.lcm(-a, -b));        Assert.assertEquals(2310, MathUtils.lcm(a, c));        // Assert that no intermediate value overflows:        // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)        Assert.assertEquals((1<<20)*15, MathUtils.lcm((1<<20)*3, (1<<20)*5));        // Special case        Assert.assertEquals(0, MathUtils.lcm(0, 0));        try {            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int            MathUtils.lcm(Integer.MIN_VALUE, 1);            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException expected) {            // expected        }        try {            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int            MathUtils.lcm(Integer.MIN_VALUE, 1<<20);            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException expected) {            // expected        }        try {            MathUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException expected) {            // expected        }    }    @Test    public void testLcmLong() {        long a = 30;        long b = 50;        long c = 77;        Assert.assertEquals(0, MathUtils.lcm(0, b));        Assert.assertEquals(0, MathUtils.lcm(a, 0));        Assert.assertEquals(b, MathUtils.lcm(1, b));        Assert.assertEquals(a, MathUtils.lcm(a, 1));        Assert.assertEquals(150, MathUtils.lcm(a, b));        Assert.assertEquals(150, MathUtils.lcm(-a, b));        Assert.assertEquals(150, MathUtils.lcm(a, -b));        Assert.assertEquals(150, MathUtils.lcm(-a, -b));        Assert.assertEquals(2310, MathUtils.lcm(a, c));        Assert.assertEquals(Long.MAX_VALUE, MathUtils.lcm(60247241209L, 153092023L));        // Assert that no intermediate value overflows:        // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)        Assert.assertEquals((1L<<50)*15, MathUtils.lcm((1L<<45)*3, (1L<<50)*5));        // Special case        Assert.assertEquals(0L, MathUtils.lcm(0L, 0L));        try {            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int            MathUtils.lcm(Long.MIN_VALUE, 1);            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException expected) {            // expected        }        try {            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int            MathUtils.lcm(Long.MIN_VALUE, 1<<20);            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException expected) {            // expected        }        Assert.assertEquals((long) Integer.MAX_VALUE * (Integer.MAX_VALUE - 1),            MathUtils.lcm((long)Integer.MAX_VALUE, Integer.MAX_VALUE - 1));        try {            MathUtils.lcm(Long.MAX_VALUE, Long.MAX_VALUE - 1);            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException expected) {            // expected        }    }    @Test    public void testLog() {        Assert.assertEquals(2.0, MathUtils.log(2, 4), 0);        Assert.assertEquals(3.0, MathUtils.log(2, 8), 0);        Assert.assertTrue(Double.isNaN(MathUtils.log(-1, 1)));        Assert.assertTrue(Double.isNaN(MathUtils.log(1, -1)));        Assert.assertTrue(Double.isNaN(MathUtils.log(0, 0)));        Assert.assertEquals(0, MathUtils.log(0, 10), 0);        Assert.assertEquals(Double.NEGATIVE_INFINITY, MathUtils.log(10, 0), 0);    }    @Test    public void testMulAndCheck() {        int big = Integer.MAX_VALUE;        int bigNeg = Integer.MIN_VALUE;        Assert.assertEquals(big, MathUtils.mulAndCheck(big, 1));        try {            MathUtils.mulAndCheck(big, 2);            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException ex) {        }        try {            MathUtils.mulAndCheck(bigNeg, 2);            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException ex) {        }    }    @Test    public void testMulAndCheckLong() {        long max = Long.MAX_VALUE;        long min = Long.MIN_VALUE;        Assert.assertEquals(max, MathUtils.mulAndCheck(max, 1L));        Assert.assertEquals(min, MathUtils.mulAndCheck(min, 1L));        Assert.assertEquals(0L, MathUtils.mulAndCheck(max, 0L));        Assert.assertEquals(0L, MathUtils.mulAndCheck(min, 0L));        Assert.assertEquals(max, MathUtils.mulAndCheck(1L, max));        Assert.assertEquals(min, MathUtils.mulAndCheck(1L, min));        Assert.assertEquals(0L, MathUtils.mulAndCheck(0L, max));        Assert.assertEquals(0L, MathUtils.mulAndCheck(0L, min));        Assert.assertEquals(1L, MathUtils.mulAndCheck(-1L, -1L));        Assert.assertEquals(min, MathUtils.mulAndCheck(min / 2, 2));        testMulAndCheckLongFailure(max, 2L);        testMulAndCheckLongFailure(2L, max);        testMulAndCheckLongFailure(min, 2L);        testMulAndCheckLongFailure(2L, min);        testMulAndCheckLongFailure(min, -1L);        testMulAndCheckLongFailure(-1L, min);    }    private void testMulAndCheckLongFailure(long a, long b) {        try {            MathUtils.mulAndCheck(a, b);            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException ex) {            // success        }    }    @Test    public void testNormalizeAngle() {        for (double a = -15.0; a <= 15.0; a += 0.1) {            for (double b = -15.0; b <= 15.0; b += 0.2) {                double c = MathUtils.normalizeAngle(a, b);                Assert.assertTrue((b - FastMath.PI) <= c);                Assert.assertTrue(c <= (b + FastMath.PI));                double twoK = FastMath.rint((a - c) / FastMath.PI);                Assert.assertEquals(c, a - twoK * FastMath.PI, 1.0e-14);            }        }    }    @Test    public void testReduce() {        final double period = -12.222;        final double offset = 13;        final double delta = 1.5;        double orig = offset + 122456789 * period + delta;        double expected = delta;        Assert.assertEquals(expected,                            MathUtils.reduce(orig, period, offset),                            1e-7);        Assert.assertEquals(expected,                            MathUtils.reduce(orig, -period, offset),                            1e-7);        orig = offset - 123356789 * period - delta;        expected = Math.abs(period) - delta;        Assert.assertEquals(expected,                            MathUtils.reduce(orig, period, offset),                            1e-6);        Assert.assertEquals(expected,                            MathUtils.reduce(orig, -period, offset),                            1e-6);        orig = offset - 123446789 * period + delta;        expected = delta;        Assert.assertEquals(expected,                            MathUtils.reduce(orig, period, offset),                            1e-6);        Assert.assertEquals(expected,                            MathUtils.reduce(orig, -period, offset),                            1e-6);                Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, Double.NaN, offset)));        Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.NaN, period, offset)));        Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, period, Double.NaN)));        Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, period,                Double.POSITIVE_INFINITY)));        Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY,                period, offset)));        Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig,                Double.POSITIVE_INFINITY, offset)));           Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig,                Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY)));        Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY,                period, Double.POSITIVE_INFINITY)));        Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY,                Double.POSITIVE_INFINITY, offset)));         Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY,                Double.POSITIVE_INFINITY,  Double.POSITIVE_INFINITY)));    }    @Test    public void testReduceComparedWithNormalizeAngle() {        final double tol = Math.ulp(1d);        final double period = 2 * Math.PI;        for (double a = -15; a <= 15; a += 0.5) {            for (double center = -15; center <= 15; center += 1) {                final double nA = MathUtils.normalizeAngle(a, center);                final double offset = center - Math.PI;                final double r = MathUtils.reduce(a, period, offset);                Assert.assertEquals(nA, r + offset, tol);            }        }    }    @Test    public void testNormalizeArray() {        double[] testValues1 = new double[] {1, 1, 2};        TestUtils.assertEquals(                new double[] {.25, .25, .5},                MathUtils.normalizeArray(testValues1, 1),                Double.MIN_VALUE);        double[] testValues2 = new double[] {-1, -1, 1};        TestUtils.assertEquals(                new double[] {1, 1, -1},                MathUtils.normalizeArray(testValues2, 1),                Double.MIN_VALUE);        // Ignore NaNs        double[] testValues3 = new double[] {-1, -1, Double.NaN, 1, Double.NaN};        TestUtils.assertEquals(                new double[] {1, 1,Double.NaN, -1, Double.NaN},                MathUtils.normalizeArray(testValues3, 1),                Double.MIN_VALUE);        // Zero sum -> MathArithmeticException        double[] zeroSum = new double[] {-1, 1};        try {            MathUtils.normalizeArray(zeroSum, 1);            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException ex) {}        // Infinite elements -> MathArithmeticException        double[] hasInf = new double[] {1, 2, 1, Double.NEGATIVE_INFINITY};        try {            MathUtils.normalizeArray(hasInf, 1);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {}        // Infinite target -> MathIllegalArgumentException        try {            MathUtils.normalizeArray(testValues1, Double.POSITIVE_INFINITY);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {}        // NaN target -> MathIllegalArgumentException        try {            MathUtils.normalizeArray(testValues1, Double.NaN);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {}    }    @Test    public void testRoundDouble() {        double x = 1.234567890;        Assert.assertEquals(1.23, MathUtils.round(x, 2), 0.0);        Assert.assertEquals(1.235, MathUtils.round(x, 3), 0.0);        Assert.assertEquals(1.2346, MathUtils.round(x, 4), 0.0);        // JIRA MATH-151        Assert.assertEquals(39.25, MathUtils.round(39.245, 2), 0.0);        Assert.assertEquals(39.24, MathUtils.round(39.245, 2, BigDecimal.ROUND_DOWN), 0.0);        double xx = 39.0;        xx = xx + 245d / 1000d;        Assert.assertEquals(39.25, MathUtils.round(xx, 2), 0.0);        // BZ 35904        Assert.assertEquals(30.1d, MathUtils.round(30.095d, 2), 0.0d);        Assert.assertEquals(30.1d, MathUtils.round(30.095d, 1), 0.0d);        Assert.assertEquals(33.1d, MathUtils.round(33.095d, 1), 0.0d);        Assert.assertEquals(33.1d, MathUtils.round(33.095d, 2), 0.0d);        Assert.assertEquals(50.09d, MathUtils.round(50.085d, 2), 0.0d);        Assert.assertEquals(50.19d, MathUtils.round(50.185d, 2), 0.0d);        Assert.assertEquals(50.01d, MathUtils.round(50.005d, 2), 0.0d);        Assert.assertEquals(30.01d, MathUtils.round(30.005d, 2), 0.0d);        Assert.assertEquals(30.65d, MathUtils.round(30.645d, 2), 0.0d);        Assert.assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);        Assert.assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);        Assert.assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);        Assert.assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);        Assert.assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);        Assert.assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);        Assert.assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);        Assert.assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);        Assert.assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);        Assert.assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);        Assert.assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);        Assert.assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);        Assert.assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);        Assert.assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);        Assert.assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);        Assert.assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);        Assert.assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);        Assert.assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);        Assert.assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);        Assert.assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        Assert.assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);        Assert.assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);        Assert.assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        Assert.assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);        Assert.assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        Assert.assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        Assert.assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(1.236, MathUtils.round(1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(-1.236, MathUtils.round(-1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);        Assert.assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);        Assert.assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);        Assert.assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);        Assert.assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);        Assert.assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);        Assert.assertEquals(1.235, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);        Assert.assertEquals(-1.235, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);        Assert.assertEquals(-1.23, MathUtils.round(-1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);        Assert.assertEquals(1.23, MathUtils.round(1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);        try {            MathUtils.round(1.234, 2, BigDecimal.ROUND_UNNECESSARY);            Assert.fail();        } catch (ArithmeticException ex) {             // expected        }        Assert.assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);        Assert.assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);        Assert.assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);        Assert.assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);        Assert.assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);        Assert.assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);        try {            MathUtils.round(1.234, 2, 1923);            Assert.fail();        } catch (IllegalArgumentException ex) {            // expected        }        // MATH-151        Assert.assertEquals(39.25, MathUtils.round(39.245, 2, BigDecimal.ROUND_HALF_UP), 0.0);        // special values        TestUtils.assertEquals(Double.NaN, MathUtils.round(Double.NaN, 2), 0.0);        Assert.assertEquals(0.0, MathUtils.round(0.0, 2), 0.0);        Assert.assertEquals(Double.POSITIVE_INFINITY, MathUtils.round(Double.POSITIVE_INFINITY, 2), 0.0);        Assert.assertEquals(Double.NEGATIVE_INFINITY, MathUtils.round(Double.NEGATIVE_INFINITY, 2), 0.0);    }    @Test    public void testRoundFloat() {        float x = 1.234567890f;        Assert.assertEquals(1.23f, MathUtils.round(x, 2), 0.0);        Assert.assertEquals(1.235f, MathUtils.round(x, 3), 0.0);        Assert.assertEquals(1.2346f, MathUtils.round(x, 4), 0.0);        // BZ 35904        Assert.assertEquals(30.1f, MathUtils.round(30.095f, 2), 0.0f);        Assert.assertEquals(30.1f, MathUtils.round(30.095f, 1), 0.0f);        Assert.assertEquals(50.09f, MathUtils.round(50.085f, 2), 0.0f);        Assert.assertEquals(50.19f, MathUtils.round(50.185f, 2), 0.0f);        Assert.assertEquals(50.01f, MathUtils.round(50.005f, 2), 0.0f);        Assert.assertEquals(30.01f, MathUtils.round(30.005f, 2), 0.0f);        Assert.assertEquals(30.65f, MathUtils.round(30.645f, 2), 0.0f);        Assert.assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);        Assert.assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);        Assert.assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);        Assert.assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);        Assert.assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);        Assert.assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);        Assert.assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);        Assert.assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);        Assert.assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);        Assert.assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);        Assert.assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);        Assert.assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);        Assert.assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);        Assert.assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);        Assert.assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);        Assert.assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);        Assert.assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);        Assert.assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);        Assert.assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);        Assert.assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        Assert.assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);        Assert.assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);        Assert.assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        Assert.assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);        Assert.assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        Assert.assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        Assert.assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(1.236f, MathUtils.round(1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(-1.236f, MathUtils.round(-1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        Assert.assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);        Assert.assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);        Assert.assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);        Assert.assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);        Assert.assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);        Assert.assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);        Assert.assertEquals(1.235f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);        Assert.assertEquals(-1.235f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);        Assert.assertEquals(-1.23f, MathUtils.round(-1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);        Assert.assertEquals(1.23f, MathUtils.round(1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);        try {            MathUtils.round(1.234f, 2, BigDecimal.ROUND_UNNECESSARY);            Assert.fail();        } catch (MathArithmeticException ex) {            // success        }        Assert.assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);        Assert.assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);        Assert.assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);        Assert.assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);        Assert.assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);        Assert.assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);        try {            MathUtils.round(1.234f, 2, 1923);            Assert.fail();        } catch (MathIllegalArgumentException ex) {            // success        }        // special values        TestUtils.assertEquals(Float.NaN, MathUtils.round(Float.NaN, 2), 0.0f);        Assert.assertEquals(0.0f, MathUtils.round(0.0f, 2), 0.0f);        Assert.assertEquals(Float.POSITIVE_INFINITY, MathUtils.round(Float.POSITIVE_INFINITY, 2), 0.0f);        Assert.assertEquals(Float.NEGATIVE_INFINITY, MathUtils.round(Float.NEGATIVE_INFINITY, 2), 0.0f);    }    @Test    public void testSignByte() {        Assert.assertEquals((byte) 1, MathUtils.sign((byte) 2));        Assert.assertEquals((byte) 0, MathUtils.sign((byte) 0));        Assert.assertEquals((byte) (-1), MathUtils.sign((byte) (-2)));    }    @Test    public void testSignDouble() {        double delta = 0.0;        Assert.assertEquals(1.0, MathUtils.sign(2.0), delta);        Assert.assertEquals(0.0, MathUtils.sign(0.0), delta);        Assert.assertEquals(-1.0, MathUtils.sign(-2.0), delta);        TestUtils.assertSame(-0. / 0., MathUtils.sign(Double.NaN));    }    @Test    public void testSignFloat() {        float delta = 0.0F;        Assert.assertEquals(1.0F, MathUtils.sign(2.0F), delta);        Assert.assertEquals(0.0F, MathUtils.sign(0.0F), delta);        Assert.assertEquals(-1.0F, MathUtils.sign(-2.0F), delta);        TestUtils.assertSame(Float.NaN, MathUtils.sign(Float.NaN));    }    @Test    public void testSignInt() {        Assert.assertEquals(1, MathUtils.sign(2));        Assert.assertEquals(0, MathUtils.sign(0));        Assert.assertEquals((-1), MathUtils.sign((-2)));    }    @Test    public void testSignLong() {        Assert.assertEquals(1L, MathUtils.sign(2L));        Assert.assertEquals(0L, MathUtils.sign(0L));        Assert.assertEquals(-1L, MathUtils.sign(-2L));    }    @Test    public void testSignShort() {        Assert.assertEquals((short) 1, MathUtils.sign((short) 2));        Assert.assertEquals((short) 0, MathUtils.sign((short) 0));        Assert.assertEquals((short) (-1), MathUtils.sign((short) (-2)));    }    @Test    public void testSinh() {        double x = 3.0;        double expected = 10.01787;        Assert.assertEquals(expected, MathUtils.sinh(x), 1.0e-5);    }    @Test    public void testSinhNaN() {        Assert.assertTrue(Double.isNaN(MathUtils.sinh(Double.NaN)));    }    @Test    public void testSubAndCheck() {        int big = Integer.MAX_VALUE;        int bigNeg = Integer.MIN_VALUE;        Assert.assertEquals(big, MathUtils.subAndCheck(big, 0));        Assert.assertEquals(bigNeg + 1, MathUtils.subAndCheck(bigNeg, -1));        Assert.assertEquals(-1, MathUtils.subAndCheck(bigNeg, -big));        try {            MathUtils.subAndCheck(big, -1);            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException ex) {        }        try {            MathUtils.subAndCheck(bigNeg, 1);            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException ex) {        }    }    @Test    public void testSubAndCheckErrorMessage() {        int big = Integer.MAX_VALUE;        try {            MathUtils.subAndCheck(big, -1);            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException ex) {            Assert.assertTrue(ex.getMessage().length() > 1);        }    }    @Test    public void testSubAndCheckLong() {        long max = Long.MAX_VALUE;        long min = Long.MIN_VALUE;        Assert.assertEquals(max, MathUtils.subAndCheck(max, 0));        Assert.assertEquals(min, MathUtils.subAndCheck(min, 0));        Assert.assertEquals(-max, MathUtils.subAndCheck(0, max));        Assert.assertEquals(min + 1, MathUtils.subAndCheck(min, -1));        // min == -1-max        Assert.assertEquals(-1, MathUtils.subAndCheck(-max - 1, -max));        Assert.assertEquals(max, MathUtils.subAndCheck(-1, -1 - max));        testSubAndCheckLongFailure(0L, min);        testSubAndCheckLongFailure(max, -1L);        testSubAndCheckLongFailure(min, 1L);    }    private void testSubAndCheckLongFailure(long a, long b) {        try {            MathUtils.subAndCheck(a, b);            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException ex) {            // success        }    }    @Test    public void testPow() {        Assert.assertEquals(1801088541, MathUtils.pow(21, 7));        Assert.assertEquals(1, MathUtils.pow(21, 0));        try {            MathUtils.pow(21, -7);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected behavior        }        Assert.assertEquals(1801088541, MathUtils.pow(21, 7l));        Assert.assertEquals(1, MathUtils.pow(21, 0l));        try {            MathUtils.pow(21, -7l);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected behavior        }        Assert.assertEquals(1801088541l, MathUtils.pow(21l, 7));        Assert.assertEquals(1l, MathUtils.pow(21l, 0));        try {            MathUtils.pow(21l, -7);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected behavior        }        Assert.assertEquals(1801088541l, MathUtils.pow(21l, 7l));        Assert.assertEquals(1l, MathUtils.pow(21l, 0l));        try {            MathUtils.pow(21l, -7l);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected behavior        }        BigInteger twentyOne = BigInteger.valueOf(21l);        Assert.assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, 7));        Assert.assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, 0));        try {            MathUtils.pow(twentyOne, -7);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected behavior        }        Assert.assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, 7l));        Assert.assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, 0l));        try {            MathUtils.pow(twentyOne, -7l);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected behavior        }        Assert.assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, BigInteger.valueOf(7l)));        Assert.assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, BigInteger.ZERO));        try {            MathUtils.pow(twentyOne, BigInteger.valueOf(-7l));            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected behavior        }        BigInteger bigOne =            new BigInteger("1543786922199448028351389769265814882661837148" +                           "4763915343722775611762713982220306372888519211" +                           "560905579993523402015636025177602059044911261");        Assert.assertEquals(bigOne, MathUtils.pow(twentyOne, 103));        Assert.assertEquals(bigOne, MathUtils.pow(twentyOne, 103l));        Assert.assertEquals(bigOne, MathUtils.pow(twentyOne, BigInteger.valueOf(103l)));    }    @Test    public void testL1DistanceDouble() {        double[] p1 = { 2.5,  0.0 };        double[] p2 = { -0.5, 4.0 };        Assert.assertTrue(MathUtils.equals(7.0, MathUtils.distance1(p1, p2), 1));    }    @Test    public void testL1DistanceInt() {        int[] p1 = { 3, 0 };        int[] p2 = { 0, 4 };        Assert.assertEquals(7, MathUtils.distance1(p1, p2));    }    @Test    public void testL2DistanceDouble() {        double[] p1 = { 2.5,  0.0 };        double[] p2 = { -0.5, 4.0 };        Assert.assertTrue(MathUtils.equals(5.0, MathUtils.distance(p1, p2), 1));    }    @Test    public void testL2DistanceInt() {        int[] p1 = { 3, 0 };        int[] p2 = { 0, 4 };        Assert.assertTrue(MathUtils.equals(5, MathUtils.distance(p1, p2), 1));    }    @Test    public void testLInfDistanceDouble() {        double[] p1 = { 2.5,  0.0 };        double[] p2 = { -0.5, 4.0 };        Assert.assertTrue(MathUtils.equals(4.0, MathUtils.distanceInf(p1, p2), 1));    }    @Test    public void testLInfDistanceInt() {        int[] p1 = { 3, 0 };        int[] p2 = { 0, 4 };        Assert.assertEquals(4, MathUtils.distanceInf(p1, p2));    }    @Test    public void testCheckOrder() {        MathUtils.checkOrder(new double[] {-15, -5.5, -1, 2, 15},                             MathUtils.OrderDirection.INCREASING, true);        MathUtils.checkOrder(new double[] {-15, -5.5, -1, 2, 2},                             MathUtils.OrderDirection.INCREASING, false);        MathUtils.checkOrder(new double[] {3, -5.5, -11, -27.5},                             MathUtils.OrderDirection.DECREASING, true);        MathUtils.checkOrder(new double[] {3, 0, 0, -5.5, -11, -27.5},                             MathUtils.OrderDirection.DECREASING, false);        try {            MathUtils.checkOrder(new double[] {-15, -5.5, -1, -1, 2, 15},                                 MathUtils.OrderDirection.INCREASING, true);            Assert.fail("an exception should have been thrown");        } catch (NonMonotonousSequenceException e) {            // Expected        }        try {            MathUtils.checkOrder(new double[] {-15, -5.5, -1, -2, 2},                                 MathUtils.OrderDirection.INCREASING, false);            Assert.fail("an exception should have been thrown");        } catch (NonMonotonousSequenceException e) {            // Expected        }        try {            MathUtils.checkOrder(new double[] {3, 3, -5.5, -11, -27.5},                                 MathUtils.OrderDirection.DECREASING, true);            Assert.fail("an exception should have been thrown");        } catch (NonMonotonousSequenceException e) {            // Expected        }        try {            MathUtils.checkOrder(new double[] {3, -1, 0, -5.5, -11, -27.5},                                 MathUtils.OrderDirection.DECREASING, false);            Assert.fail("an exception should have been thrown");        } catch (NonMonotonousSequenceException e) {            // Expected        }    }    @Test    public void testCheckFinite() {        try {            MathUtils.checkFinite(Double.POSITIVE_INFINITY);            Assert.fail("an exception should have been thrown");        } catch (NotFiniteNumberException e) {            // Expected        }        try {            MathUtils.checkFinite(Double.NEGATIVE_INFINITY);            Assert.fail("an exception should have been thrown");        } catch (NotFiniteNumberException e) {            // Expected        }        try {            MathUtils.checkFinite(Double.NaN);            Assert.fail("an exception should have been thrown");        } catch (NotFiniteNumberException e) {            // Expected        }        try {            MathUtils.checkFinite(new double[] {0, -1, Double.POSITIVE_INFINITY, -2, 3});            Assert.fail("an exception should have been thrown");        } catch (NotFiniteNumberException e) {            // Expected        }        try {            MathUtils.checkFinite(new double[] {1, Double.NEGATIVE_INFINITY, -2, 3});            Assert.fail("an exception should have been thrown");        } catch (NotFiniteNumberException e) {            // Expected        }        try {            MathUtils.checkFinite(new double[] {4, 3, -1, Double.NaN, -2, 1});            Assert.fail("an exception should have been thrown");        } catch (NotFiniteNumberException e) {            // Expected        }    }    @Test    public void testSortInPlace() {        final double[] x1 = {2,   5,  -3, 1,  4};        final double[] x2 = {4,  25,   9, 1, 16};        final double[] x3 = {8, 125, -27, 1, 64};                MathUtils.sortInPlace(x1, x2, x3);        Assert.assertEquals(-3,  x1[0], Math.ulp(1d));        Assert.assertEquals(9,   x2[0], Math.ulp(1d));        Assert.assertEquals(-27, x3[0], Math.ulp(1d));        Assert.assertEquals(1, x1[1], Math.ulp(1d));        Assert.assertEquals(1, x2[1], Math.ulp(1d));        Assert.assertEquals(1, x3[1], Math.ulp(1d));        Assert.assertEquals(2, x1[2], Math.ulp(1d));        Assert.assertEquals(4, x2[2], Math.ulp(1d));        Assert.assertEquals(8, x3[2], Math.ulp(1d));        Assert.assertEquals(4,  x1[3], Math.ulp(1d));        Assert.assertEquals(16, x2[3], Math.ulp(1d));        Assert.assertEquals(64, x3[3], Math.ulp(1d));        Assert.assertEquals(5,   x1[4], Math.ulp(1d));        Assert.assertEquals(25,  x2[4], Math.ulp(1d));        Assert.assertEquals(125, x3[4], Math.ulp(1d));    }    @Test    public void testCopyOfInt() {        final int[] source = { Integer.MIN_VALUE,                               -1, 0, 1, 3, 113, 4769,                               Integer.MAX_VALUE };        final int[] dest = MathUtils.copyOf(source);        Assert.assertEquals(dest.length, source.length);        for (int i = 0; i < source.length; i++) {            Assert.assertEquals(source[i], dest[i]);        }    }    @Test    public void testCopyOfInt2() {        final int[] source = { Integer.MIN_VALUE,                               -1, 0, 1, 3, 113, 4769,                               Integer.MAX_VALUE };        final int offset = 3;        final int[] dest = MathUtils.copyOf(source, source.length - offset);        Assert.assertEquals(dest.length, source.length - offset);        for (int i = 0; i < source.length - offset; i++) {            Assert.assertEquals(source[i], dest[i]);        }    }    @Test    public void testCopyOfInt3() {        final int[] source = { Integer.MIN_VALUE,                               -1, 0, 1, 3, 113, 4769,                               Integer.MAX_VALUE };        final int offset = 3;        final int[] dest = MathUtils.copyOf(source, source.length + offset);        Assert.assertEquals(dest.length, source.length + offset);        for (int i = 0; i < source.length; i++) {            Assert.assertEquals(source[i], dest[i]);        }        for (int i = source.length; i < source.length + offset; i++) {            Assert.assertEquals(0, dest[i], 0);        }    }    @Test    public void testCopyOfDouble() {        final double[] source = { Double.NEGATIVE_INFINITY,                                  -Double.MAX_VALUE,                                  -1, 0,                                  Double.MIN_VALUE,                                  Math.ulp(1d),                                  1, 3, 113, 4769,                                  Double.MAX_VALUE,                                  Double.POSITIVE_INFINITY };        final double[] dest = MathUtils.copyOf(source);        Assert.assertEquals(dest.length, source.length);        for (int i = 0; i < source.length; i++) {            Assert.assertEquals(source[i], dest[i], 0);        }    }    @Test    public void testCopyOfDouble2() {        final double[] source = { Double.NEGATIVE_INFINITY,                                  -Double.MAX_VALUE,                                  -1, 0,                                  Double.MIN_VALUE,                                  Math.ulp(1d),                                  1, 3, 113, 4769,                                  Double.MAX_VALUE,                                  Double.POSITIVE_INFINITY };        final int offset = 3;        final double[] dest = MathUtils.copyOf(source, source.length - offset);        Assert.assertEquals(dest.length, source.length - offset);        for (int i = 0; i < source.length - offset; i++) {            Assert.assertEquals(source[i], dest[i], 0);        }    }    @Test    public void testCopyOfDouble3() {        final double[] source = { Double.NEGATIVE_INFINITY,                                  -Double.MAX_VALUE,                                  -1, 0,                                  Double.MIN_VALUE,                                  Math.ulp(1d),                                  1, 3, 113, 4769,                                  Double.MAX_VALUE,                                  Double.POSITIVE_INFINITY };        final int offset = 3;        final double[] dest = MathUtils.copyOf(source, source.length + offset);        Assert.assertEquals(dest.length, source.length + offset);        for (int i = 0; i < source.length; i++) {            Assert.assertEquals(source[i], dest[i], 0);        }        for (int i = source.length; i < source.length + offset; i++) {            Assert.assertEquals(0, dest[i], 0);        }    }    @Test    public void testCheckNotNull1() {        try {            Object obj = null;            MathUtils.checkNotNull(obj);        } catch (NullArgumentException e) {            // Expected.        }    }    @Test    public void testCheckNotNull2() {        try {            double[] array = null;            MathUtils.checkNotNull(array, LocalizedFormats.INPUT_ARRAY);        } catch (NullArgumentException e) {            // Expected.        }    }    @Test    public void testLinearCombination1() {        final double[] a = new double[] {            -1321008684645961.0 / 268435456.0,            -5774608829631843.0 / 268435456.0,            -7645843051051357.0 / 8589934592.0        };        final double[] b = new double[] {            -5712344449280879.0 / 2097152.0,            -4550117129121957.0 / 2097152.0,            8846951984510141.0 / 131072.0        };        final double abSumInline = MathUtils.linearCombination(a[0], b[0],                                                               a[1], b[1],                                                               a[2], b[2]);        final double abSumArray = MathUtils.linearCombination(a, b);        Assert.assertEquals(abSumInline, abSumArray, 0);    }    @Test    public void testLinearCombination2() {        // we compare accurate versus naive dot product implementations        // on regular vectors (i.e. not extreme cases like in the previous test)        Well1024a random = new Well1024a(553267312521321234l);        for (int i = 0; i < 10000; ++i) {            final double ux = 1e17 * random.nextDouble();            final double uy = 1e17 * random.nextDouble();            final double uz = 1e17 * random.nextDouble();            final double vx = 1e17 * random.nextDouble();            final double vy = 1e17 * random.nextDouble();            final double vz = 1e17 * random.nextDouble();            final double sInline = MathUtils.linearCombination(ux, vx,                                                               uy, vy,                                                               uz, vz);            final double sArray = MathUtils.linearCombination(new double[] {ux, uy, uz},                                                              new double[] {vx, vy, vz});            Assert.assertEquals(sInline, sArray, 0);        }    }    @Test    public void testLinearCombinationInfinite() {        final double[][] a = new double[][] {            { 1, 2, 3, 4},            { 1, Double.POSITIVE_INFINITY, 3, 4},            { 1, 2, Double.POSITIVE_INFINITY, 4},            { 1, Double.POSITIVE_INFINITY, 3, Double.NEGATIVE_INFINITY},            { 1, 2, 3, 4},            { 1, 2, 3, 4},            { 1, 2, 3, 4},            { 1, 2, 3, 4}        };        final double[][] b = new double[][] {            { 1, -2, 3, 4},            { 1, -2, 3, 4},            { 1, -2, 3, 4},            { 1, -2, 3, 4},            { 1, Double.POSITIVE_INFINITY, 3, 4},            { 1, -2, Double.POSITIVE_INFINITY, 4},            { 1, Double.POSITIVE_INFINITY, 3, Double.NEGATIVE_INFINITY},            { Double.NaN, -2, 3, 4}        };        Assert.assertEquals(-3,                            MathUtils.linearCombination(a[0][0], b[0][0],                                                        a[0][1], b[0][1]),                            1.0e-10);        Assert.assertEquals(6,                            MathUtils.linearCombination(a[0][0], b[0][0],                                                        a[0][1], b[0][1],                                                        a[0][2], b[0][2]),                            1.0e-10);        Assert.assertEquals(22,                            MathUtils.linearCombination(a[0][0], b[0][0],                                                        a[0][1], b[0][1],                                                        a[0][2], b[0][2],                                                        a[0][3], b[0][3]),                            1.0e-10);        Assert.assertEquals(22, MathUtils.linearCombination(a[0], b[0]), 1.0e-10);        Assert.assertEquals(Double.NEGATIVE_INFINITY,                            MathUtils.linearCombination(a[1][0], b[1][0],                                                        a[1][1], b[1][1]),                            1.0e-10);        Assert.assertEquals(Double.NEGATIVE_INFINITY,                            MathUtils.linearCombination(a[1][0], b[1][0],                                                        a[1][1], b[1][1],                                                        a[1][2], b[1][2]),                            1.0e-10);        Assert.assertEquals(Double.NEGATIVE_INFINITY,                            MathUtils.linearCombination(a[1][0], b[1][0],                                                        a[1][1], b[1][1],                                                        a[1][2], b[1][2],                                                        a[1][3], b[1][3]),                            1.0e-10);        Assert.assertEquals(Double.NEGATIVE_INFINITY, MathUtils.linearCombination(a[1], b[1]), 1.0e-10);        Assert.assertEquals(-3,                            MathUtils.linearCombination(a[2][0], b[2][0],                                                        a[2][1], b[2][1]),                            1.0e-10);        Assert.assertEquals(Double.POSITIVE_INFINITY,                            MathUtils.linearCombination(a[2][0], b[2][0],                                                        a[2][1], b[2][1],                                                        a[2][2], b[2][2]),                            1.0e-10);        Assert.assertEquals(Double.POSITIVE_INFINITY,                            MathUtils.linearCombination(a[2][0], b[2][0],                                                        a[2][1], b[2][1],                                                        a[2][2], b[2][2],                                                        a[2][3], b[2][3]),                            1.0e-10);        Assert.assertEquals(Double.POSITIVE_INFINITY, MathUtils.linearCombination(a[2], b[2]), 1.0e-10);        Assert.assertEquals(Double.NEGATIVE_INFINITY,                            MathUtils.linearCombination(a[3][0], b[3][0],                                                        a[3][1], b[3][1]),                            1.0e-10);        Assert.assertEquals(Double.NEGATIVE_INFINITY,                            MathUtils.linearCombination(a[3][0], b[3][0],                                                        a[3][1], b[3][1],                                                        a[3][2], b[3][2]),                            1.0e-10);        Assert.assertEquals(Double.NEGATIVE_INFINITY,                            MathUtils.linearCombination(a[3][0], b[3][0],                                                        a[3][1], b[3][1],                                                        a[3][2], b[3][2],                                                        a[3][3], b[3][3]),                            1.0e-10);        Assert.assertEquals(Double.NEGATIVE_INFINITY, MathUtils.linearCombination(a[3], b[3]), 1.0e-10);        Assert.assertEquals(Double.POSITIVE_INFINITY,                            MathUtils.linearCombination(a[4][0], b[4][0],                                                        a[4][1], b[4][1]),                            1.0e-10);        Assert.assertEquals(Double.POSITIVE_INFINITY,                            MathUtils.linearCombination(a[4][0], b[4][0],                                                        a[4][1], b[4][1],                                                        a[4][2], b[4][2]),                            1.0e-10);        Assert.assertEquals(Double.POSITIVE_INFINITY,                            MathUtils.linearCombination(a[4][0], b[4][0],                                                        a[4][1], b[4][1],                                                        a[4][2], b[4][2],                                                        a[4][3], b[4][3]),                            1.0e-10);        Assert.assertEquals(Double.POSITIVE_INFINITY, MathUtils.linearCombination(a[4], b[4]), 1.0e-10);        Assert.assertEquals(-3,                            MathUtils.linearCombination(a[5][0], b[5][0],                                                        a[5][1], b[5][1]),                            1.0e-10);        Assert.assertEquals(Double.POSITIVE_INFINITY,                            MathUtils.linearCombination(a[5][0], b[5][0],                                                        a[5][1], b[5][1],                                                        a[5][2], b[5][2]),                            1.0e-10);        Assert.assertEquals(Double.POSITIVE_INFINITY,                            MathUtils.linearCombination(a[5][0], b[5][0],                                                        a[5][1], b[5][1],                                                        a[5][2], b[5][2],                                                        a[5][3], b[5][3]),                            1.0e-10);        Assert.assertEquals(Double.POSITIVE_INFINITY, MathUtils.linearCombination(a[5], b[5]), 1.0e-10);        Assert.assertEquals(Double.POSITIVE_INFINITY,                            MathUtils.linearCombination(a[6][0], b[6][0],                                                        a[6][1], b[6][1]),                            1.0e-10);        Assert.assertEquals(Double.POSITIVE_INFINITY,                            MathUtils.linearCombination(a[6][0], b[6][0],                                                        a[6][1], b[6][1],                                                        a[6][2], b[6][2]),                            1.0e-10);        Assert.assertTrue(Double.isNaN(MathUtils.linearCombination(a[6][0], b[6][0],                                                                   a[6][1], b[6][1],                                                                   a[6][2], b[6][2],                                                                   a[6][3], b[6][3])));        Assert.assertTrue(Double.isNaN(MathUtils.linearCombination(a[6], b[6])));        Assert.assertTrue(Double.isNaN(MathUtils.linearCombination(a[7][0], b[7][0],                                                        a[7][1], b[7][1])));        Assert.assertTrue(Double.isNaN(MathUtils.linearCombination(a[7][0], b[7][0],                                                        a[7][1], b[7][1],                                                        a[7][2], b[7][2])));        Assert.assertTrue(Double.isNaN(MathUtils.linearCombination(a[7][0], b[7][0],                                                                   a[7][1], b[7][1],                                                                   a[7][2], b[7][2],                                                                   a[7][3], b[7][3])));        Assert.assertTrue(Double.isNaN(MathUtils.linearCombination(a[7], b[7])));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import java.math.BigDecimal;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.exception.NullArgumentException;import org.junit.Assert;import org.junit.Test;/** * @version $Id$ */public class DefaultTransformerTest {    /**     *     */    @Test    public void testTransformDouble() throws Exception {        double expected = 1.0;        Double input = Double.valueOf(expected);        DefaultTransformer t = new DefaultTransformer();        Assert.assertEquals(expected, t.transform(input), 1.0e-4);    }    /**     *     */    @Test    public void testTransformNull() throws Exception {        DefaultTransformer t = new DefaultTransformer();        try {            t.transform(null);            Assert.fail("Expecting NullArgumentException");        } catch (NullArgumentException e) {            // expected        }    }    /**     *     */    @Test    public void testTransformInteger() throws Exception {        double expected = 1.0;        Integer input = Integer.valueOf(1);        DefaultTransformer t = new DefaultTransformer();        Assert.assertEquals(expected, t.transform(input), 1.0e-4);    }    /**     *     */    @Test    public void testTransformBigDecimal() throws Exception {        double expected = 1.0;        BigDecimal input = new BigDecimal("1.0");        DefaultTransformer t = new DefaultTransformer();        Assert.assertEquals(expected, t.transform(input), 1.0e-4);    }    /**     *     */    @Test    public void testTransformString() throws Exception {        double expected = 1.0;        String input = "1.0";        DefaultTransformer t = new DefaultTransformer();        Assert.assertEquals(expected, t.transform(input), 1.0e-4);    }    /**     *     */    @Test    public void testTransformObject(){        Boolean input = Boolean.TRUE;        DefaultTransformer t = new DefaultTransformer();        try {            t.transform(input);            Assert.fail("Expecting MathException");        } catch (MathException e) {            // expected        }    }    @Test    public void testSerial() {        Assert.assertEquals(new DefaultTransformer(), TestUtils.serializeAndRecover(new DefaultTransformer()));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.lang.reflect.Type;import org.apache.commons.math.dfp.Dfp;import org.apache.commons.math.dfp.DfpField;import org.apache.commons.math.dfp.DfpMath;import org.apache.commons.math.random.MersenneTwister;import org.apache.commons.math.random.RandomGenerator;import org.junit.Assert;import org.junit.Before;import org.junit.Ignore;import org.junit.Test;public class FastMathTest {    private static final double MAX_ERROR_ULP = 0.51;    private static final int NUMBER_OF_TRIALS = 1000;    private DfpField field;    private RandomGenerator generator;    @Before    public void setUp() {        field = new DfpField(40);        generator = new MersenneTwister(6176597458463500194l);    }    @Test    public void testMinMaxDouble() {        double[][] pairs = {            { -50.0, 50.0 },            {  Double.POSITIVE_INFINITY, 1.0 },            {  Double.NEGATIVE_INFINITY, 1.0 },            {  Double.NaN, 1.0 },            {  Double.POSITIVE_INFINITY, 0.0 },            {  Double.NEGATIVE_INFINITY, 0.0 },            {  Double.NaN, 0.0 },            {  Double.NaN, Double.NEGATIVE_INFINITY },            {  Double.NaN, Double.POSITIVE_INFINITY },            { MathUtils.SAFE_MIN, MathUtils.EPSILON }        };        for (double[] pair : pairs) {            Assert.assertEquals("min(" + pair[0] + ", " + pair[1] + ")",                                Math.min(pair[0], pair[1]),                                FastMath.min(pair[0], pair[1]),                                MathUtils.EPSILON);            Assert.assertEquals("min(" + pair[1] + ", " + pair[0] + ")",                                Math.min(pair[1], pair[0]),                                FastMath.min(pair[1], pair[0]),                                MathUtils.EPSILON);            Assert.assertEquals("max(" + pair[0] + ", " + pair[1] + ")",                                Math.max(pair[0], pair[1]),                                FastMath.max(pair[0], pair[1]),                                MathUtils.EPSILON);            Assert.assertEquals("max(" + pair[1] + ", " + pair[0] + ")",                                Math.max(pair[1], pair[0]),                                FastMath.max(pair[1], pair[0]),                                MathUtils.EPSILON);        }    }    @Test    public void testMinMaxFloat() {        float[][] pairs = {            { -50.0f, 50.0f },            {  Float.POSITIVE_INFINITY, 1.0f },            {  Float.NEGATIVE_INFINITY, 1.0f },            {  Float.NaN, 1.0f },            {  Float.POSITIVE_INFINITY, 0.0f },            {  Float.NEGATIVE_INFINITY, 0.0f },            {  Float.NaN, 0.0f },            {  Float.NaN, Float.NEGATIVE_INFINITY },            {  Float.NaN, Float.POSITIVE_INFINITY }        };        for (float[] pair : pairs) {            Assert.assertEquals("min(" + pair[0] + ", " + pair[1] + ")",                                Math.min(pair[0], pair[1]),                                FastMath.min(pair[0], pair[1]),                                MathUtils.EPSILON);            Assert.assertEquals("min(" + pair[1] + ", " + pair[0] + ")",                                Math.min(pair[1], pair[0]),                                FastMath.min(pair[1], pair[0]),                                MathUtils.EPSILON);            Assert.assertEquals("max(" + pair[0] + ", " + pair[1] + ")",                                Math.max(pair[0], pair[1]),                                FastMath.max(pair[0], pair[1]),                                MathUtils.EPSILON);            Assert.assertEquals("max(" + pair[1] + ", " + pair[0] + ")",                                Math.max(pair[1], pair[0]),                                FastMath.max(pair[1], pair[0]),                                MathUtils.EPSILON);        }    }    @Test    public void testConstants() {        Assert.assertEquals(Math.PI, FastMath.PI, 1.0e-20);        Assert.assertEquals(Math.E, FastMath.E, 1.0e-20);    }    @Test    public void testAtan2() {        double y1 = 1.2713504628280707e10;        double x1 = -5.674940885228782e-10;        Assert.assertEquals(Math.atan2(y1, x1), FastMath.atan2(y1, x1), 2 * MathUtils.EPSILON);        double y2 = 0.0;        double x2 = Double.POSITIVE_INFINITY;        Assert.assertEquals(Math.atan2(y2, x2), FastMath.atan2(y2, x2), MathUtils.SAFE_MIN);    }    @Test    public void testHyperbolic() {        double maxErr = 0;        for (double x = -30; x < 30; x += 0.001) {            double tst = FastMath.sinh(x);            double ref = Math.sinh(x);            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));        }        Assert.assertEquals(0, maxErr, 2);        maxErr = 0;        for (double x = -30; x < 30; x += 0.001) {            double tst = FastMath.cosh(x);            double ref = Math.cosh(x);            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));        }        Assert.assertEquals(0, maxErr, 2);        maxErr = 0;        for (double x = -0.5; x < 0.5; x += 0.001) {            double tst = FastMath.tanh(x);            double ref = Math.tanh(x);            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));        }        Assert.assertEquals(0, maxErr, 4);    }    @Test    public void testHyperbolicInverses() {        double maxErr = 0;        for (double x = -30; x < 30; x += 0.01) {            maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.sinh(FastMath.asinh(x))) / (2 * FastMath.ulp(x)));        }        Assert.assertEquals(0, maxErr, 3);        maxErr = 0;        for (double x = 1; x < 30; x += 0.01) {            maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.cosh(FastMath.acosh(x))) / (2 * FastMath.ulp(x)));        }        Assert.assertEquals(0, maxErr, 2);        maxErr = 0;        for (double x = -1 + MathUtils.EPSILON; x < 1 - MathUtils.EPSILON; x += 0.0001) {            maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.tanh(FastMath.atanh(x))) / (2 * FastMath.ulp(x)));        }        Assert.assertEquals(0, maxErr, 2);    }    @Test    public void testLogAccuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            double x = Math.exp(generator.nextDouble() * 1416.0 - 708.0) * generator.nextDouble();            // double x = generator.nextDouble()*2.0;            double tst = FastMath.log(x);            double ref = DfpMath.log(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0.0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double                                          .doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("log() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testLog10Accuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            double x = Math.exp(generator.nextDouble() * 1416.0 - 708.0) * generator.nextDouble();            // double x = generator.nextDouble()*2.0;            double tst = FastMath.log10(x);            double ref = DfpMath.log(field.newDfp(x)).divide(DfpMath.log(field.newDfp("10"))).toDouble();            double err = (tst - ref) / ref;            if (err != 0.0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x)).divide(DfpMath.log(field.newDfp("10")))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("log10() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testLog1pAccuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            double x = Math.exp(generator.nextDouble() * 10.0 - 5.0) * generator.nextDouble();            // double x = generator.nextDouble()*2.0;            double tst = FastMath.log1p(x);            double ref = DfpMath.log(field.newDfp(x).add(field.getOne())).toDouble();            double err = (tst - ref) / ref;            if (err != 0.0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x).add(field.getOne()))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("log1p() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testLogSpecialCases() {        double x;        x = FastMath.log(0.0);        if (x != Double.NEGATIVE_INFINITY)            throw new RuntimeException("Log of zero should be -Inf");        x = FastMath.log(-0.0);        if (x != Double.NEGATIVE_INFINITY)            throw new RuntimeException("Log of zero should be -Inf");        x = FastMath.log(Double.NaN);        if (x == x)            throw new RuntimeException("Log of NaN should be NaN");        x = FastMath.log(-1.0);        if (x == x)            throw new RuntimeException("Log of negative number should be NaN");        x = FastMath.log(Double.MIN_VALUE);        if (x != -744.4400719213812)            throw new RuntimeException(                                       "Log of Double.MIN_VALUE should be -744.4400719213812");        x = FastMath.log(-1.0);        if (x == x)            throw new RuntimeException("Log of negative number should be NaN");        x = FastMath.log(Double.POSITIVE_INFINITY);        if (x != Double.POSITIVE_INFINITY)            throw new RuntimeException("Log of infinity should be infinity");    }    @Test    public void testExpSpecialCases() {        double x;        /* Smallest value that will round up to Double.MIN_VALUE */        x = FastMath.exp(-745.1332191019411);        if (x != Double.MIN_VALUE)            throw new RuntimeException(                                       "exp(-745.1332191019411) should be Double.MIN_VALUE");        x = FastMath.exp(-745.1332191019412);        if (x != 0.0)            throw new RuntimeException("exp(-745.1332191019412) should be 0.0");        x = FastMath.exp(Double.NaN);        if (x == x)            throw new RuntimeException("exp of NaN should be NaN");        x = FastMath.exp(Double.POSITIVE_INFINITY);        if (x != Double.POSITIVE_INFINITY)            throw new RuntimeException("exp of infinity should be infinity");        x = FastMath.exp(Double.NEGATIVE_INFINITY);        if (x != 0.0)            throw new RuntimeException("exp of -infinity should be 0.0");        x = FastMath.exp(1.0);        if (x != Math.E)            throw new RuntimeException("exp(1) should be Math.E");    }    @Test    public void testPowSpecialCases() {        double x;        x = FastMath.pow(-1.0, 0.0);        if (x != 1.0)            throw new RuntimeException("pow(x, 0) should be 1.0");        x = FastMath.pow(-1.0, -0.0);        if (x != 1.0)            throw new RuntimeException("pow(x, -0) should be 1.0");        x = FastMath.pow(Math.PI, 1.0);        if (x != Math.PI)            throw new RuntimeException("pow(PI, 1.0) should be PI");        x = FastMath.pow(-Math.PI, 1.0);        if (x != -Math.PI)            throw new RuntimeException("pow(-PI, 1.0) should be PI");        x = FastMath.pow(Math.PI, Double.NaN);        if (x == x)            throw new RuntimeException("pow(PI, NaN) should be NaN");        x = FastMath.pow(Double.NaN, Math.PI);        if (x == x)            throw new RuntimeException("pow(NaN, PI) should be NaN");        x = FastMath.pow(2.0, Double.POSITIVE_INFINITY);        if (x != Double.POSITIVE_INFINITY)            throw new RuntimeException("pow(2.0, Infinity) should be Infinity");        x = FastMath.pow(0.5, Double.NEGATIVE_INFINITY);        if (x != Double.POSITIVE_INFINITY)            throw new RuntimeException("pow(0.5, -Infinity) should be Infinity");        x = FastMath.pow(0.5, Double.POSITIVE_INFINITY);        if (x != 0.0)            throw new RuntimeException("pow(0.5, Infinity) should be 0.0");        x = FastMath.pow(2.0, Double.NEGATIVE_INFINITY);        if (x != 0.0)            throw new RuntimeException("pow(2.0, -Infinity) should be 0.0");        x = FastMath.pow(0.0, 0.5);        if (x != 0.0)            throw new RuntimeException("pow(0.0, 0.5) should be 0.0");        x = FastMath.pow(Double.POSITIVE_INFINITY, -0.5);        if (x != 0.0)            throw new RuntimeException("pow(Inf, -0.5) should be 0.0");        x = FastMath.pow(0.0, -0.5);        if (x != Double.POSITIVE_INFINITY)            throw new RuntimeException("pow(0.0, -0.5) should be Inf");        x = FastMath.pow(Double.POSITIVE_INFINITY, 0.5);        if (x != Double.POSITIVE_INFINITY)            throw new RuntimeException("pow(Inf, 0.5) should be Inf");        x = FastMath.pow(-0.0, -3.0);        if (x != Double.NEGATIVE_INFINITY)            throw new RuntimeException("pow(-0.0, -3.0) should be -Inf");        x = FastMath.pow(Double.NEGATIVE_INFINITY, 3.0);        if (x != Double.NEGATIVE_INFINITY)            throw new RuntimeException("pow(-Inf, -3.0) should be -Inf");        x = FastMath.pow(-0.0, -3.5);        if (x != Double.POSITIVE_INFINITY)            throw new RuntimeException("pow(-0.0, -3.5) should be Inf");        x = FastMath.pow(Double.POSITIVE_INFINITY, 3.5);        if (x != Double.POSITIVE_INFINITY)            throw new RuntimeException("pow(Inf, 3.5) should be Inf");        x = FastMath.pow(-2.0, 3.0);        if (x != -8.0)            throw new RuntimeException("pow(-2.0, 3.0) should be -8.0");        x = FastMath.pow(-2.0, 3.5);        if (x == x)            throw new RuntimeException("pow(-2.0, 3.5) should be NaN");    }    @Test    public void testAtan2SpecialCases() {        double x;        x = FastMath.atan2(Double.NaN, 0.0);        if (x == x)            throw new RuntimeException("atan2(NaN, 0.0) should be NaN");        x = FastMath.atan2(0.0, Double.NaN);        if (x == x)            throw new RuntimeException("atan2(0.0, NaN) should be NaN");        x = FastMath.atan2(0.0, 0.0);        if (x != 0.0 || 1 / x != Double.POSITIVE_INFINITY)            throw new RuntimeException("atan2(0.0, 0.0) should be 0.0");        x = FastMath.atan2(0.0, 0.001);        if (x != 0.0 || 1 / x != Double.POSITIVE_INFINITY)            throw new RuntimeException("atan2(0.0, 0.001) should be 0.0");        x = FastMath.atan2(0.1, Double.POSITIVE_INFINITY);        if (x != 0.0 || 1 / x != Double.POSITIVE_INFINITY)            throw new RuntimeException("atan2(0.1, +Inf) should be 0.0");        x = FastMath.atan2(-0.0, 0.0);        if (x != 0.0 || 1 / x != Double.NEGATIVE_INFINITY)            throw new RuntimeException("atan2(-0.0, 0.0) should be -0.0");        x = FastMath.atan2(-0.0, 0.001);        if (x != 0.0 || 1 / x != Double.NEGATIVE_INFINITY)            throw new RuntimeException("atan2(-0.0, 0.001) should be -0.0");        x = FastMath.atan2(-0.1, Double.POSITIVE_INFINITY);        if (x != 0.0 || 1 / x != Double.NEGATIVE_INFINITY)            throw new RuntimeException("atan2(-0.0, +Inf) should be -0.0");        x = FastMath.atan2(0.0, -0.0);        if (x != Math.PI)            throw new RuntimeException("atan2(0.0, -0.0) should be PI");        x = FastMath.atan2(0.1, Double.NEGATIVE_INFINITY);        if (x != Math.PI)            throw new RuntimeException("atan2(0.1, -Inf) should be PI");        x = FastMath.atan2(-0.0, -0.0);        if (x != -Math.PI)            throw new RuntimeException("atan2(-0.0, -0.0) should be -PI");        x = FastMath.atan2(-0.1, Double.NEGATIVE_INFINITY);        if (x != -Math.PI)            throw new RuntimeException("atan2(0.1, -Inf) should be -PI");        x = FastMath.atan2(0.1, 0.0);        if (x != Math.PI / 2)            throw new RuntimeException("atan2(0.1, 0.0) should be PI/2");        x = FastMath.atan2(0.1, -0.0);        if (x != Math.PI / 2)            throw new RuntimeException("atan2(0.1, -0.0) should be PI/2");        x = FastMath.atan2(Double.POSITIVE_INFINITY, 0.1);        if (x != Math.PI / 2)            throw new RuntimeException("atan2(Inf, 0.1) should be PI/2");        x = FastMath.atan2(Double.POSITIVE_INFINITY, -0.1);        if (x != Math.PI / 2)            throw new RuntimeException("atan2(Inf, -0.1) should be PI/2");        x = FastMath.atan2(-0.1, 0.0);        if (x != -Math.PI / 2)            throw new RuntimeException("atan2(-0.1, 0.0) should be -PI/2");        x = FastMath.atan2(-0.1, -0.0);        if (x != -Math.PI / 2)            throw new RuntimeException("atan2(-0.1, -0.0) should be -PI/2");        x = FastMath.atan2(Double.NEGATIVE_INFINITY, 0.1);        if (x != -Math.PI / 2)            throw new RuntimeException("atan2(-Inf, 0.1) should be -PI/2");        x = FastMath.atan2(Double.NEGATIVE_INFINITY, -0.1);        if (x != -Math.PI / 2)            throw new RuntimeException("atan2(-Inf, -0.1) should be -PI/2");        x = FastMath.atan2(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);        if (x != Math.PI / 4)            throw new RuntimeException("atan2(Inf, Inf) should be PI/4");        x = FastMath.atan2(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY);        if (x != Math.PI * 3.0 / 4.0)            throw new RuntimeException("atan2(Inf, -Inf) should be PI * 3/4");        x = FastMath.atan2(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);        if (x != -Math.PI / 4)            throw new RuntimeException("atan2(-Inf, Inf) should be -PI/4");        x = FastMath.atan2(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);        if (x != -Math.PI * 3.0 / 4.0)            throw new RuntimeException("atan2(-Inf, -Inf) should be -PI * 3/4");    }    @Test    public void testPowAccuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            double x = (generator.nextDouble() * 2.0 + 0.25);            double y = (generator.nextDouble() * 1200.0 - 600.0) * generator.nextDouble();            /*             * double x = FastMath.floor(generator.nextDouble()*1024.0 - 512.0); double             * y; if (x != 0) y = FastMath.floor(512.0 / FastMath.abs(x)); else             * y = generator.nextDouble()*1200.0; y = y - y/2; x = FastMath.pow(2.0, x) *             * generator.nextDouble(); y = y * generator.nextDouble();             */            // double x = generator.nextDouble()*2.0;            double tst = FastMath.pow(x, y);            double ref = DfpMath.pow(field.newDfp(x), field.newDfp(y)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double                                          .doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.pow(field.newDfp(x), field.newDfp(y))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + y + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("pow() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testExpAccuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            /* double x = 1.0 + i/1024.0/2.0; */            double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();            // double x = (generator.nextDouble() * 20.0) - 10.0;            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();            /* double x = 3.0 / 512.0 * i - 3.0; */            double tst = FastMath.exp(x);            double ref = DfpMath.exp(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("exp() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testSinAccuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            /* double x = 1.0 + i/1024.0/2.0; */            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();            double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) *                       Math.pow(2, 21) * generator.nextDouble();            // double x = (generator.nextDouble() * 20.0) - 10.0;            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();            /* double x = 3.0 / 512.0 * i - 3.0; */            double tst = FastMath.sin(x);            double ref = DfpMath.sin(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.sin(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("sin() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testCosAccuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            /* double x = 1.0 + i/1024.0/2.0; */            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();            double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) *                       Math.pow(2, 21) * generator.nextDouble();            // double x = (generator.nextDouble() * 20.0) - 10.0;            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();            /* double x = 3.0 / 512.0 * i - 3.0; */            double tst = FastMath.cos(x);            double ref = DfpMath.cos(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.cos(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("cos() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testTanAccuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            /* double x = 1.0 + i/1024.0/2.0; */            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();            double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) *                       Math.pow(2, 12) * generator.nextDouble();            // double x = (generator.nextDouble() * 20.0) - 10.0;            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();            /* double x = 3.0 / 512.0 * i - 3.0; */            double tst = FastMath.tan(x);            double ref = DfpMath.tan(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.tan(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("tan() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testAtanAccuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            /* double x = 1.0 + i/1024.0/2.0; */            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();            // double x = ((generator.nextDouble() * Math.PI) - Math.PI/2.0) *            // generator.nextDouble();            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble();            // double x = (generator.nextDouble() * 20.0) - 10.0;            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();            /* double x = 3.0 / 512.0 * i - 3.0; */            double tst = FastMath.atan(x);            double ref = DfpMath.atan(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.atan(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("atan() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testAtan2Accuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            /* double x = 1.0 + i/1024.0/2.0; */            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();            double x = generator.nextDouble() - 0.5;            double y = generator.nextDouble() - 0.5;            // double x = (generator.nextDouble() * 20.0) - 10.0;            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();            /* double x = 3.0 / 512.0 * i - 3.0; */            double tst = FastMath.atan2(y, x);            Dfp refdfp = DfpMath.atan(field.newDfp(y)                .divide(field.newDfp(x)));            /* Make adjustments for sign */            if (x < 0.0) {                if (y > 0.0)                    refdfp = field.getPi().add(refdfp);                else                    refdfp = refdfp.subtract(field.getPi());            }            double ref = refdfp.toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double                                          .doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(refdfp).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + y + "\t" + tst + "\t" + ref + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("atan2() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testExpm1Accuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            /* double x = 1.0 + i/1024.0/2.0; */            // double x = (generator.nextDouble() * 20.0) - 10.0;            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble();            /* double x = 3.0 / 512.0 * i - 3.0; */            double tst = FastMath.expm1(x);            double ref = DfpMath.exp(field.newDfp(x)).subtract(field.getOne()).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double                                          .doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("expm1() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testAsinAccuracy() {        double maxerrulp = 0.0;        for (int i=0; i<10000; i++) {            double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();             double tst = FastMath.asin(x);            double ref = DfpMath.asin(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.asin(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();                //System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("asin() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testAcosAccuracy() {        double maxerrulp = 0.0;        for (int i=0; i<10000; i++) {            double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();             double tst = FastMath.acos(x);            double ref = DfpMath.acos(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.acos(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();                //System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("acos() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    private Dfp cosh(Dfp x) {      return DfpMath.exp(x).add(DfpMath.exp(x.negate())).divide(2);    }    private Dfp sinh(Dfp x) {      return DfpMath.exp(x).subtract(DfpMath.exp(x.negate())).divide(2);    }    private Dfp tanh(Dfp x) {      return sinh(x).divide(cosh(x));    }    @Test    public void testSinhAccuracy() {        double maxerrulp = 0.0;        for (int i=0; i<10000; i++) {            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble();             double tst = FastMath.sinh(x);            double ref = sinh(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(sinh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();                 //System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp);                 maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("sinh() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testCoshAccuracy() {        double maxerrulp = 0.0;        for (int i=0; i<10000; i++) {            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble();             double tst = FastMath.cosh(x);            double ref = cosh(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(cosh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();                 //System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp);                 maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("cosh() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testTanhAccuracy() {        double maxerrulp = 0.0;        for (int i=0; i<10000; i++) {            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble();             double tst = FastMath.tanh(x);            double ref = tanh(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(tanh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();                 //System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp);                 maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("tanh() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testCbrtAccuracy() {        double maxerrulp = 0.0;        for (int i=0; i<10000; i++) {            double x = ((generator.nextDouble() * 200.0) - 100.0) * generator.nextDouble();             double tst = FastMath.cbrt(x);            double ref = cbrt(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(cbrt(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();                 //System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp);                 maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("cbrt() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    private Dfp cbrt(Dfp x) {      boolean negative=false;      if (x.lessThan(field.getZero())) {          negative = true;          x = x.negate();      }      Dfp y = DfpMath.pow(x, field.getOne().divide(3));      if (negative) {          y = y.negate();      }      return y;    }    @Test    public void testToDegrees() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            double x = generator.nextDouble();            double tst = field.newDfp(x).multiply(180).divide(field.getPi()).toDouble();            double ref = FastMath.toDegrees(x);            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("toDegrees() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testToRadians() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            double x = generator.nextDouble();            double tst = field.newDfp(x).multiply(field.getPi()).divide(180).toDouble();            double ref = FastMath.toRadians(x);            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double                                          .doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("toRadians() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testNextAfter() {        // 0x402fffffffffffff 0x404123456789abcd -> 4030000000000000        Assert.assertEquals(16.0, FastMath.nextAfter(15.999999999999998, 34.27555555555555), 0.0);        // 0xc02fffffffffffff 0x404123456789abcd -> c02ffffffffffffe        Assert.assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 34.27555555555555), 0.0);        // 0x402fffffffffffff 0x400123456789abcd -> 402ffffffffffffe        Assert.assertEquals(15.999999999999996, FastMath.nextAfter(15.999999999999998, 2.142222222222222), 0.0);        // 0xc02fffffffffffff 0x400123456789abcd -> c02ffffffffffffe        Assert.assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 2.142222222222222), 0.0);        // 0x4020000000000000 0x404123456789abcd -> 4020000000000001        Assert.assertEquals(8.000000000000002, FastMath.nextAfter(8.0, 34.27555555555555), 0.0);        // 0xc020000000000000 0x404123456789abcd -> c01fffffffffffff        Assert.assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 34.27555555555555), 0.0);        // 0x4020000000000000 0x400123456789abcd -> 401fffffffffffff        Assert.assertEquals(7.999999999999999, FastMath.nextAfter(8.0, 2.142222222222222), 0.0);        // 0xc020000000000000 0x400123456789abcd -> c01fffffffffffff        Assert.assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 2.142222222222222), 0.0);        // 0x3f2e43753d36a223 0x3f2e43753d36a224 -> 3f2e43753d36a224        Assert.assertEquals(2.308922399667661E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0);        // 0x3f2e43753d36a223 0x3f2e43753d36a223 -> 3f2e43753d36a223        Assert.assertEquals(2.3089223996676606E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);        // 0x3f2e43753d36a223 0x3f2e43753d36a222 -> 3f2e43753d36a222        Assert.assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);        // 0x3f2e43753d36a223 0xbf2e43753d36a224 -> 3f2e43753d36a222        Assert.assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0);        // 0x3f2e43753d36a223 0xbf2e43753d36a223 -> 3f2e43753d36a222        Assert.assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);        // 0x3f2e43753d36a223 0xbf2e43753d36a222 -> 3f2e43753d36a222        Assert.assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);        // 0xbf2e43753d36a223 0x3f2e43753d36a224 -> bf2e43753d36a222        Assert.assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0);        // 0xbf2e43753d36a223 0x3f2e43753d36a223 -> bf2e43753d36a222        Assert.assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);        // 0xbf2e43753d36a223 0x3f2e43753d36a222 -> bf2e43753d36a222        Assert.assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);        // 0xbf2e43753d36a223 0xbf2e43753d36a224 -> bf2e43753d36a224        Assert.assertEquals(-2.308922399667661E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0);        // 0xbf2e43753d36a223 0xbf2e43753d36a223 -> bf2e43753d36a223        Assert.assertEquals(-2.3089223996676606E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);        // 0xbf2e43753d36a223 0xbf2e43753d36a222 -> bf2e43753d36a222        Assert.assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);    }    @Test    public void testDoubleNextAfterSpecialCases() {        Assert.assertEquals(-Double.MAX_VALUE,FastMath.nextAfter(Double.NEGATIVE_INFINITY, 0D), 0D);        Assert.assertEquals(Double.MAX_VALUE,FastMath.nextAfter(Double.POSITIVE_INFINITY, 0D), 0D);        Assert.assertEquals(Double.NaN,FastMath.nextAfter(Double.NaN, 0D), 0D);        Assert.assertEquals(Double.POSITIVE_INFINITY,FastMath.nextAfter(Double.MAX_VALUE, Double.POSITIVE_INFINITY), 0D);        Assert.assertEquals(Double.NEGATIVE_INFINITY,FastMath.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY), 0D);        Assert.assertEquals(Double.MIN_VALUE, FastMath.nextAfter(0D, 1D), 0D);        Assert.assertEquals(-Double.MIN_VALUE, FastMath.nextAfter(0D, -1D), 0D);        Assert.assertEquals(0D, FastMath.nextAfter(Double.MIN_VALUE, -1), 0D);        Assert.assertEquals(0D, FastMath.nextAfter(-Double.MIN_VALUE, 1), 0D);    }    @Test    public void testFloatNextAfterSpecialCases() {        Assert.assertEquals(-Float.MAX_VALUE,FastMath.nextAfter(Float.NEGATIVE_INFINITY, 0F), 0F);        Assert.assertEquals(Float.MAX_VALUE,FastMath.nextAfter(Float.POSITIVE_INFINITY, 0F), 0F);        Assert.assertEquals(Float.NaN,FastMath.nextAfter(Float.NaN, 0F), 0F);        Assert.assertEquals(Float.POSITIVE_INFINITY,FastMath.nextAfter(Float.MAX_VALUE, Float.POSITIVE_INFINITY), 0F);        Assert.assertEquals(Float.NEGATIVE_INFINITY,FastMath.nextAfter(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY), 0F);        Assert.assertEquals(Float.MIN_VALUE, FastMath.nextAfter(0F, 1F), 0F);        Assert.assertEquals(-Float.MIN_VALUE, FastMath.nextAfter(0F, -1F), 0F);        Assert.assertEquals(0F, FastMath.nextAfter(Float.MIN_VALUE, -1F), 0F);        Assert.assertEquals(0F, FastMath.nextAfter(-Float.MIN_VALUE, 1F), 0F);    }    @Test    public void testDoubleScalbSpecialCases() {        Assert.assertEquals(2.5269841324701218E-175,  FastMath.scalb(2.2250738585072014E-308, 442), 0D);        Assert.assertEquals(1.307993905256674E297,    FastMath.scalb(1.1102230246251565E-16, 1040), 0D);        Assert.assertEquals(7.2520887996488946E-217,  FastMath.scalb(Double.MIN_VALUE,        356), 0D);        Assert.assertEquals(8.98846567431158E307,     FastMath.scalb(Double.MIN_VALUE,       2097), 0D);        Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb(Double.MIN_VALUE,       2098), 0D);        Assert.assertEquals(1.1125369292536007E-308,  FastMath.scalb(2.225073858507201E-308,   -1), 0D);        Assert.assertEquals(1.0E-323,                 FastMath.scalb(Double.MAX_VALUE,      -2097), 0D);        Assert.assertEquals(Double.MIN_VALUE,         FastMath.scalb(Double.MAX_VALUE,      -2098), 0D);        Assert.assertEquals(0,                        FastMath.scalb(Double.MAX_VALUE,      -2099), 0D);        Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb(Double.POSITIVE_INFINITY, -1000000), 0D);        Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.1102230246251565E-16, 1078), 0D);        Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.1102230246251565E-16,  1079), 0D);        Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-2.2250738585072014E-308, 2047), 0D);        Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-2.2250738585072014E-308, 2048), 0D);        Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.7976931348623157E308,  2147483647), 0D);        Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb( 1.7976931348623157E308,  2147483647), 0D);        Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.1102230246251565E-16,  2147483647), 0D);        Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb( 1.1102230246251565E-16,  2147483647), 0D);        Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-2.2250738585072014E-308, 2147483647), 0D);        Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb( 2.2250738585072014E-308, 2147483647), 0D);    }    @Test    public void testFloatScalbSpecialCases() {        Assert.assertEquals(0f,                       FastMath.scalb(Float.MIN_VALUE,  -30), 0F);        Assert.assertEquals(2 * Float.MIN_VALUE,      FastMath.scalb(Float.MIN_VALUE,    1), 0F);        Assert.assertEquals(7.555786e22f,             FastMath.scalb(Float.MAX_VALUE,  -52), 0F);        Assert.assertEquals(1.7014118e38f,            FastMath.scalb(Float.MIN_VALUE,  276), 0F);        Assert.assertEquals(Float.POSITIVE_INFINITY,  FastMath.scalb(Float.MIN_VALUE,  277), 0F);        Assert.assertEquals(5.8774718e-39f,           FastMath.scalb(1.1754944e-38f,    -1), 0F);        Assert.assertEquals(2 * Float.MIN_VALUE,      FastMath.scalb(Float.MAX_VALUE, -276), 0F);        Assert.assertEquals(Float.MIN_VALUE,          FastMath.scalb(Float.MAX_VALUE, -277), 0F);        Assert.assertEquals(0,                        FastMath.scalb(Float.MAX_VALUE, -278), 0F);        Assert.assertEquals(Float.POSITIVE_INFINITY,  FastMath.scalb(Float.POSITIVE_INFINITY, -1000000), 0F);        Assert.assertEquals(-3.13994498e38f,          FastMath.scalb(-1.1e-7f,         151), 0F);        Assert.assertEquals(Float.NEGATIVE_INFINITY,  FastMath.scalb(-1.1e-7f,         152), 0F);        Assert.assertEquals(Float.POSITIVE_INFINITY,  FastMath.scalb(3.4028235E38f,  2147483647), 0F);        Assert.assertEquals(Float.NEGATIVE_INFINITY,  FastMath.scalb(-3.4028235E38f, 2147483647), 0F);    }    private boolean compareClassMethods(Class<?> class1, Class<?> class2){        boolean allfound = true;        for(Method method1 : class1.getDeclaredMethods()){            if (Modifier.isPublic(method1.getModifiers())){                Type []params = method1.getGenericParameterTypes();                try {                    class2.getDeclaredMethod(method1.getName(), (Class[]) params);                } catch (NoSuchMethodException e) {                    allfound = false;                    System.out.println(class2.getSimpleName()+" does not implement: "+method1);                }            }        }        return allfound;    }    @Test    public void checkMissingFastMathClasses() {        boolean ok = compareClassMethods(StrictMath.class, FastMath.class);        Assert.assertTrue("FastMath should implement all StrictMath methods", ok);    }    @Ignore    @Test    public void checkExtraFastMathClasses() {        compareClassMethods( FastMath.class, StrictMath.class);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.OutOfRangeException;import org.apache.commons.math.exception.NotStrictlyPositiveException;import org.junit.Assert;import org.junit.Test;/** * */public class MultidimensionalCounterTest {    @Test    public void testPreconditions() {        MultidimensionalCounter c;        try {            c = new MultidimensionalCounter(0, 1);            Assert.fail("NotStrictlyPositiveException expected");        } catch (NotStrictlyPositiveException e) {            // Expected.        }        try {            c = new MultidimensionalCounter(2, 0);            Assert.fail("NotStrictlyPositiveException expected");        } catch (NotStrictlyPositiveException e) {            // Expected.        }        try {            c = new MultidimensionalCounter(-1, 1);            Assert.fail("NotStrictlyPositiveException expected");        } catch (NotStrictlyPositiveException e) {            // Expected.        }        c = new MultidimensionalCounter(2, 3);        try {            c.getCount(1, 1, 1);            Assert.fail("DimensionMismatchException expected");        } catch (DimensionMismatchException e) {            // Expected.        }        try {            c.getCount(3, 1);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException e) {            // Expected.        }        try {            c.getCount(0, -1);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException e) {            // Expected.        }        try {            c.getCounts(-1);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException e) {            // Expected.        }        try {            c.getCounts(6);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException e) {            // Expected.        }    }    @Test    public void testIteratorPreconditions() {        MultidimensionalCounter.Iterator iter = (new MultidimensionalCounter(2, 3)).iterator();        try {            iter.getCount(-1);            Assert.fail("IndexOutOfBoundsException expected");        } catch (IndexOutOfBoundsException e) {            // Expected.        }        try {            iter.getCount(2);            Assert.fail("IndexOutOfBoundsException expected");        } catch (IndexOutOfBoundsException e) {            // Expected.        }    }    @Test    public void testMulti2UniConversion() {        final MultidimensionalCounter c = new MultidimensionalCounter(2, 4, 5);        Assert.assertEquals(c.getCount(1, 2, 3), 33);    }    @Test    public void testAccessors() {        final int[] originalSize = new int[] {2, 6, 5};        final MultidimensionalCounter c = new MultidimensionalCounter(originalSize);        final int nDim = c.getDimension();        Assert.assertEquals(nDim, originalSize.length);        final int[] size = c.getSizes();        for (int i = 0; i < nDim; i++) {            Assert.assertEquals(originalSize[i], size[i]);        }    }    @Test    public void testIterationConsistency() {        final MultidimensionalCounter c = new MultidimensionalCounter(2, 3, 4);        final int[][] expected = new int[][] {            { 0, 0, 0 },            { 0, 0, 1 },            { 0, 0, 2 },            { 0, 0, 3 },            { 0, 1, 0 },            { 0, 1, 1 },            { 0, 1, 2 },            { 0, 1, 3 },            { 0, 2, 0 },            { 0, 2, 1 },            { 0, 2, 2 },            { 0, 2, 3 },            { 1, 0, 0 },            { 1, 0, 1 },            { 1, 0, 2 },            { 1, 0, 3 },            { 1, 1, 0 },            { 1, 1, 1 },            { 1, 1, 2 },            { 1, 1, 3 },            { 1, 2, 0 },            { 1, 2, 1 },            { 1, 2, 2 },            { 1, 2, 3 }        };        final int totalSize = c.getSize();        final int nDim = c.getDimension();        final MultidimensionalCounter.Iterator iter = c.iterator();        for (int i = 0; i < totalSize; i++) {            if (!iter.hasNext()) {                Assert.fail("Too short");            }            final int uniDimIndex = iter.next();            Assert.assertEquals("Wrong iteration at " + i, i, uniDimIndex);            for (int dimIndex = 0; dimIndex < nDim; dimIndex++) {                Assert.assertEquals("Wrong multidimensional index for [" + i + "][" + dimIndex + "]",                                    expected[i][dimIndex], iter.getCount(dimIndex));            }            Assert.assertEquals("Wrong unidimensional index for [" + i + "]",                                c.getCount(expected[i]), uniDimIndex);            final int[] indices = c.getCounts(uniDimIndex);            for (int dimIndex = 0; dimIndex < nDim; dimIndex++) {                Assert.assertEquals("Wrong multidimensional index for [" + i + "][" + dimIndex + "]",                                    expected[i][dimIndex], indices[dimIndex]);            }        }        if (iter.hasNext()) {            Assert.fail("Too long");        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.TestUtils;import org.junit.Assert;import org.junit.Test;public class BigRealFieldTest {    @Test    public void testZero() {        Assert.assertEquals(BigReal.ZERO, BigRealField.getInstance().getZero());    }    @Test    public void testOne() {        Assert.assertEquals(BigReal.ONE, BigRealField.getInstance().getOne());    }    @Test    public void testSerial() {        // deserializing the singleton should give the singleton itself back        BigRealField field = BigRealField.getInstance();        Assert.assertTrue(field == TestUtils.serializeAndRecover(field));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import java.util.ConcurrentModificationException;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.NoSuchElementException;import java.util.Random;import java.util.Set;import org.junit.Assert;import org.junit.Before;import org.junit.Test;/** * Test cases for the {@link OpenIntToDoubleHashMap}. */public class OpenIntToDoubleHashMapTest {    private Map<Integer, Double> javaMap = new HashMap<Integer, Double>();    @Before    public void setUp() throws Exception {        javaMap.put(50, 100.0);        javaMap.put(75, 75.0);        javaMap.put(25, 500.0);        javaMap.put(Integer.MAX_VALUE, Double.MAX_VALUE);        javaMap.put(0, -1.0);        javaMap.put(1, 0.0);        javaMap.put(33, -0.1);        javaMap.put(23234234, -242343.0);        javaMap.put(23321, Double.MIN_VALUE);        javaMap.put(-4444, 332.0);        javaMap.put(-1, -2323.0);        javaMap.put(Integer.MIN_VALUE, 44.0);        /* Add a few more to cause the table to rehash */        javaMap.putAll(generate());    }    private Map<Integer, Double> generate() {        Map<Integer, Double> map = new HashMap<Integer, Double>();        Random r = new Random();        for (int i = 0; i < 2000; ++i)            map.put(r.nextInt(), r.nextDouble());        return map;    }    private OpenIntToDoubleHashMap createFromJavaMap() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());        }        return map;    }    @Test    public void testPutAndGetWith0ExpectedSize() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(0);        assertPutAndGet(map);    }    @Test    public void testPutAndGetWithExpectedSize() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(500);        assertPutAndGet(map);    }    @Test    public void testPutAndGet() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        assertPutAndGet(map);    }    private void assertPutAndGet(OpenIntToDoubleHashMap map) {        assertPutAndGet(map, 0, new HashSet<Integer>());    }    private void assertPutAndGet(OpenIntToDoubleHashMap map, int mapSize,            Set<Integer> keysInMap) {        Assert.assertEquals(mapSize, map.size());        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            if (!keysInMap.contains(mapEntry.getKey()))                ++mapSize;            Assert.assertEquals(mapSize, map.size());            Assert.assertTrue(MathUtils.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1));        }    }    @Test    public void testPutAbsentOnExisting() {        OpenIntToDoubleHashMap map = createFromJavaMap();        int size = javaMap.size();        for (Map.Entry<Integer, Double> mapEntry : generateAbsent().entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            Assert.assertEquals(++size, map.size());            Assert.assertTrue(MathUtils.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1));        }    }    @Test    public void testPutOnExisting() {        OpenIntToDoubleHashMap map = createFromJavaMap();        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            Assert.assertEquals(javaMap.size(), map.size());            Assert.assertTrue(MathUtils.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1));        }    }    @Test    public void testGetAbsent() {        Map<Integer, Double> generated = generateAbsent();        OpenIntToDoubleHashMap map = createFromJavaMap();        for (Map.Entry<Integer, Double> mapEntry : generated.entrySet())            Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey())));    }    @Test    public void testGetFromEmpty() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        Assert.assertTrue(Double.isNaN(map.get(5)));        Assert.assertTrue(Double.isNaN(map.get(0)));        Assert.assertTrue(Double.isNaN(map.get(50)));    }    @Test    public void testRemove() {        OpenIntToDoubleHashMap map = createFromJavaMap();        int mapSize = javaMap.size();        Assert.assertEquals(mapSize, map.size());        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            map.remove(mapEntry.getKey());            Assert.assertEquals(--mapSize, map.size());            Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey())));        }        /* Ensure that put and get still work correctly after removals */        assertPutAndGet(map);    }    /* This time only remove some entries */    @Test    public void testRemove2() {        OpenIntToDoubleHashMap map = createFromJavaMap();        int mapSize = javaMap.size();        int count = 0;        Set<Integer> keysInMap = new HashSet<Integer>(javaMap.keySet());        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            keysInMap.remove(mapEntry.getKey());            map.remove(mapEntry.getKey());            Assert.assertEquals(--mapSize, map.size());            Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey())));            if (count++ > 5)                break;        }        /* Ensure that put and get still work correctly after removals */        assertPutAndGet(map, mapSize, keysInMap);    }    @Test    public void testRemoveFromEmpty() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        Assert.assertTrue(Double.isNaN(map.remove(50)));    }    @Test    public void testRemoveAbsent() {        Map<Integer, Double> generated = generateAbsent();        OpenIntToDoubleHashMap map = createFromJavaMap();        int mapSize = map.size();        for (Map.Entry<Integer, Double> mapEntry : generated.entrySet()) {            map.remove(mapEntry.getKey());            Assert.assertEquals(mapSize, map.size());            Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey())));        }    }    /**     * Returns a map with at least 100 elements where each element is absent from javaMap.     */    private Map<Integer, Double> generateAbsent() {        Map<Integer, Double> generated = new HashMap<Integer, Double>();        do {            generated.putAll(generate());            for (Integer key : javaMap.keySet())                generated.remove(key);        } while (generated.size() < 100);        return generated;    }    @Test    public void testCopy() {        OpenIntToDoubleHashMap copy =            new OpenIntToDoubleHashMap(createFromJavaMap());        Assert.assertEquals(javaMap.size(), copy.size());        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet())            Assert.assertTrue(MathUtils.equals(mapEntry.getValue(), copy.get(mapEntry.getKey()), 1));    }    @Test    public void testContainsKey() {        OpenIntToDoubleHashMap map = createFromJavaMap();        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            Assert.assertTrue(map.containsKey(mapEntry.getKey()));        }        for (Map.Entry<Integer, Double> mapEntry : generateAbsent().entrySet()) {            Assert.assertFalse(map.containsKey(mapEntry.getKey()));        }        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            int key = mapEntry.getKey();            Assert.assertTrue(map.containsKey(key));            map.remove(key);            Assert.assertFalse(map.containsKey(key));        }    }    @Test    public void testIterator() {        OpenIntToDoubleHashMap map = createFromJavaMap();        OpenIntToDoubleHashMap.Iterator iterator = map.iterator();        for (int i = 0; i < map.size(); ++i) {            Assert.assertTrue(iterator.hasNext());            iterator.advance();            int key = iterator.key();            Assert.assertTrue(map.containsKey(key));            Assert.assertEquals(javaMap.get(key), map.get(key), 0);            Assert.assertEquals(javaMap.get(key), iterator.value(), 0);            Assert.assertTrue(javaMap.containsKey(key));        }        Assert.assertFalse(iterator.hasNext());        try {            iterator.advance();            Assert.fail("an exception should have been thrown");        } catch (NoSuchElementException nsee) {            // expected        }    }    @Test    public void testConcurrentModification() {        OpenIntToDoubleHashMap map = createFromJavaMap();        OpenIntToDoubleHashMap.Iterator iterator = map.iterator();        map.put(3, 3);        try {            iterator.advance();            Assert.fail("an exception should have been thrown");        } catch (ConcurrentModificationException cme) {            // expected        }    }    /**     * Regression test for a bug in findInsertionIndex where the hashing in the second probing     * loop was inconsistent with the first causing duplicate keys after the right sequence     * of puts and removes.     */    @Test    public void testPutKeysWithCollisions() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        int key1 = -1996012590;        double value1 = 1.0;        map.put(key1, value1);        int key2 = 835099822;        map.put(key2, value1);        int key3 = 1008859686;        map.put(key3, value1);        Assert.assertTrue(MathUtils.equals(value1, map.get(key3), 1));        Assert.assertEquals(3, map.size());        map.remove(key2);        double value2 = 2.0;        map.put(key3, value2);        Assert.assertTrue(MathUtils.equals(value2, map.get(key3), 1));        Assert.assertEquals(2, map.size());    }    /**     * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly     * different manner.     */    @Test    public void testPutKeysWithCollision2() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        int key1 = 837989881;        double value1 = 1.0;        map.put(key1, value1);        int key2 = 476463321;        map.put(key2, value1);        Assert.assertEquals(2, map.size());        Assert.assertTrue(MathUtils.equals(value1, map.get(key2), 1));        map.remove(key1);        double value2 = 2.0;        map.put(key2, value2);        Assert.assertEquals(1, map.size());        Assert.assertTrue(MathUtils.equals(value2, map.get(key2), 1));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.TestUtils;import org.junit.Assert;import org.junit.Test;/** * @version $Id$ */public class TransformerMapTest {    /**     *     */    @Test    public void testPutTransformer(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        Assert.assertEquals(expected, map.getTransformer(TransformerMapTest.class));    }    /**     *     */    @Test    public void testContainsClass(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        Assert.assertTrue(map.containsClass(TransformerMapTest.class));    }    /**     *     */    @Test    public void testContainsTransformer(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        Assert.assertTrue(map.containsTransformer(expected));    }    /**     *     */    @Test    public void testRemoveTransformer(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        Assert.assertTrue(map.containsClass(TransformerMapTest.class));        Assert.assertTrue(map.containsTransformer(expected));        map.removeTransformer(TransformerMapTest.class);        Assert.assertFalse(map.containsClass(TransformerMapTest.class));        Assert.assertFalse(map.containsTransformer(expected));    }    /**     *     */    @Test    public void testClear(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        Assert.assertTrue(map.containsClass(TransformerMapTest.class));        map.clear();        Assert.assertFalse(map.containsClass(TransformerMapTest.class));    }    /**     *     */    @Test    public void testClasses(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        Assert.assertTrue(map.classes().contains(TransformerMapTest.class));    }    /**     *     */    @Test    public void testTransformers(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        Assert.assertTrue(map.transformers().contains(expected));    }    @Test    public void testSerial(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        Assert.assertEquals(map, TestUtils.serializeAndRecover(map));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.MathRuntimeException;import org.apache.commons.math.exception.util.LocalizedFormats;/** * @version $Id$ */public class TestBean {    private Double x = Double.valueOf(1.0);    private String y = "1.0";    /**     *     */    public Double getX() {        return x;    }    /**     *     */    public String getY() {        return y;    }    /**     *     */    public void setX(Double double1) {        x = double1;    }    /**     *     */    public void setY(String string) {        y = string;    }    /**     *     */    public Double getZ() {        throw new MathRuntimeException(LocalizedFormats.SIMPLE_MESSAGE, "?");    }    /**     *     */    public void setZ(Double double1) {    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.exception.MaxCountExceededException;import org.junit.Assert;import org.junit.Test;/** * Test for {@link Incrementor}. */public class IncrementorTest {    @Test    public void testAccessor() {        final Incrementor i = new Incrementor();        i.setMaximalCount(10);        Assert.assertEquals(10, i.getMaximalCount());        Assert.assertEquals(0, i.getCount());    }    @Test    public void testBelowMaxCount() {        final Incrementor i = new Incrementor();        i.setMaximalCount(3);        i.incrementCount();        i.incrementCount();        i.incrementCount();        Assert.assertEquals(3, i.getCount());    }    @Test(expected = MaxCountExceededException.class)    public void testAboveMaxCount() {        final Incrementor i = new Incrementor();        i.setMaximalCount(3);        i.incrementCount();        i.incrementCount();        i.incrementCount();        i.incrementCount();    }    @Test    public void testReset() {        final Incrementor i = new Incrementor();        i.setMaximalCount(3);        i.incrementCount();        i.incrementCount();        i.incrementCount();        Assert.assertEquals(3, i.getCount());        i.resetCount();        Assert.assertEquals(0, i.getCount());    }    @Test    public void testBulkIncrement() {        final Incrementor i = new Incrementor();        i.setMaximalCount(3);        i.incrementCount(2);        Assert.assertEquals(2, i.getCount());        i.incrementCount(1);        Assert.assertEquals(3, i.getCount());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.lang.reflect.Type;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters;/** * Test to compare FastMath results against StrictMath results for boundary values. * <p> * Running all tests independently: <br/> * {@code mvn test -Dtest=FastMathStrictComparisonTest}<br/> * or just run tests against a single method (e.g. scalb):<br/> * {@code mvn test -Dtest=FastMathStrictComparisonTest -DargLine="-DtestMethod=scalb"} */@RunWith(Parameterized.class)public class FastMathStrictComparisonTest {    // Values which often need special handling    private static final Double[] DOUBLE_SPECIAL_VALUES = {        -0.0, +0.0,                                         // 1,2        Double.NaN,                                         // 3        Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, // 4,5        -Double.MAX_VALUE, Double.MAX_VALUE,                // 6,7        // decreasing order of absolute value to help catch first failure        -MathUtils.EPSILON, MathUtils.EPSILON,              // 8,9        -MathUtils.SAFE_MIN, MathUtils.SAFE_MIN,            // 10,11        -Double.MIN_VALUE, Double.MIN_VALUE,                // 12,13    };    private static final Float [] FLOAT_SPECIAL_VALUES = {        -0.0f, +0.0f,                                       // 1,2        Float.NaN,                                          // 3        Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY,   // 4,5        Float.MIN_VALUE, Float.MAX_VALUE,                   // 6,7        -Float.MIN_VALUE, -Float.MAX_VALUE,                 // 8,9    };    private static final Object [] LONG_SPECIAL_VALUES = {        -1,0,1,                                             // 1,2,3        Long.MIN_VALUE, Long.MAX_VALUE,                     // 4,5    };    private static final Object[] INT_SPECIAL_VALUES = {        -1,0,1,                                             // 1,2,3        Integer.MIN_VALUE, Integer.MAX_VALUE,               // 4,5    };    private final Method mathMethod;    private final Method fastMethod;    private final Type[] types;    private final Object[][] valueArrays;    public FastMathStrictComparisonTest(Method m, Method f, Type[] types, Object[][] data) throws Exception{        this.mathMethod=m;        this.fastMethod=f;        this.types=types;        this.valueArrays=data;    }    @Test    public void test1() throws Exception{        setupMethodCall(mathMethod, fastMethod, types, valueArrays);    }    private static boolean isNumber(Double d) {        return !(d.isInfinite() || d.isNaN());    }    private static boolean isNumber(Float f) {        return !(f.isInfinite() || f.isNaN());    }    private static void reportFailedResults(Method mathMethod, Object[] params, Object expected, Object actual, int[] entries){        final String methodName = mathMethod.getName();        String format = null;        long actL=0;        long expL=0;        if (expected instanceof Double) {            Double exp = (Double) expected;            Double act = (Double) actual;            if (isNumber(exp) && isNumber(act) && exp != 0) { // show difference as hex                actL = Double.doubleToLongBits(act);                expL = Double.doubleToLongBits(exp);                if (Math.abs(actL-expL)==1) {                    // Not 100% sure off-by-one errors are allowed everywhere, so only allow for these methods                    if (methodName.equals("toRadians") || methodName.equals("atan2")) {                        return;                    }                }                format = "%016x";            }        } else if (expected instanceof Float ){            Float exp = (Float) expected;            Float act = (Float) actual;            if (isNumber(exp) && isNumber(act) && exp != 0) { // show difference as hex                actL = Float.floatToIntBits(act);                expL = Float.floatToIntBits(exp);                format = "%08x";            }        }        StringBuilder sb = new StringBuilder();        sb.append(mathMethod.getReturnType().getSimpleName());        sb.append(" ");        sb.append(methodName);        sb.append("(");        String sep = "";        for(Object o : params){            sb.append(sep);            sb.append(o);            sep=", ";        }        sb.append(") expected ");        if (format != null){            sb.append(String.format(format, expL));        } else {            sb.append(expected);        }        sb.append(" actual ");        if (format != null){            sb.append(String.format(format, actL));        } else {            sb.append(actual);        }        sb.append(" entries ");        sb.append(Arrays.toString(entries));        String message = sb.toString();        final boolean fatal = true;        if (fatal) {            Assert.fail(message);        } else {            System.out.println(message);        }    }    private static void callMethods(Method mathMethod, Method fastMethod,            Object[] params, int[] entries) throws IllegalAccessException,            InvocationTargetException {        try {            Object expected = mathMethod.invoke(mathMethod, params);            Object actual = fastMethod.invoke(mathMethod, params);            if (!expected.equals(actual)) {                reportFailedResults(mathMethod, params, expected, actual, entries);            }        } catch (IllegalArgumentException e) {            Assert.fail(mathMethod+" "+e);        }    }    private static void setupMethodCall(Method mathMethod, Method fastMethod,            Type[] types, Object[][] valueArrays) throws Exception {        Object[] params = new Object[types.length];        int entry1 = 0;        int[] entries = new int[types.length];        for(Object d : valueArrays[0]) {            entry1++;            params[0] = d;            entries[0] = entry1;            if (params.length > 1){                int entry2 = 0;                for(Object d1 : valueArrays[1]) {                    entry2++;                    params[1] = d1;                    entries[1] = entry2;                    callMethods(mathMethod, fastMethod, params, entries);                }            } else {                callMethods(mathMethod, fastMethod, params, entries);            }        }    }    @Parameters    public static List<Object[]> data() throws Exception {        String singleMethod = System.getProperty("testMethod");        List<Object[]> list = new ArrayList<Object[]>();        for(Method mathMethod : StrictMath.class.getDeclaredMethods()) {            method:            if (Modifier.isPublic(mathMethod.getModifiers())){// Only test public methods                Type []types = mathMethod.getGenericParameterTypes();                if (types.length >=1) { // Only check methods with at least one parameter                    try {                        // Get the corresponding FastMath method                        Method fastMethod = FastMath.class.getDeclaredMethod(mathMethod.getName(), (Class[]) types);                        if (Modifier.isPublic(fastMethod.getModifiers())) { // It must be public too                            if (singleMethod != null && !fastMethod.getName().equals(singleMethod)) {                                break method;                            }                            Object [][] values = new Object[types.length][];                            int index = 0;                            for(Type t : types) {                                if (t.equals(double.class)){                                    values[index]=DOUBLE_SPECIAL_VALUES;                                } else if (t.equals(float.class)) {                                    values[index]=FLOAT_SPECIAL_VALUES;                                } else if (t.equals(long.class)) {                                    values[index]=LONG_SPECIAL_VALUES;                                } else if (t.equals(int.class)) {                                    values[index]=INT_SPECIAL_VALUES;                                } else {                                    System.out.println("Cannot handle class "+t+" for "+mathMethod);                                    break method;                                }                                index++;                            }//                            System.out.println(fastMethod);                            /*                             * The current implementation runs each method as a separate test.                             * Could be amended to run each value as a separate test                             */                            list.add(new Object[]{mathMethod, fastMethod, types, values});//                            setupMethodCall(mathMethod, fastMethod, params, data);                        } else {                            System.out.println("Cannot find public FastMath method corresponding to: "+mathMethod);                        }                    } catch (NoSuchMethodException e) {                        System.out.println("Cannot find FastMath method corresponding to: "+mathMethod);                    }                }            }        }        return list;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.transform;import org.apache.commons.math.util.MathUtils;import org.junit.Assert;import org.junit.Test;/** * JUnit Test for HadamardTransformerTest * @see org.apache.commons.math.transform.FastHadamardTransformer */public final class FastHadamardTransformerTest {    /**     * Test of transformer for the a 8-point FHT (means n=8)     */    @Test    public void test8Points() {        checkAllTransforms(new int[] { 1, 4, -2, 3, 0, 1, 4, -1 },                       new int[] { 10, -4, 2, -4, 2, -12, 6, 8 });    }    /**     * Test of transformer for the a 4-points FHT (means n=4)     */    @Test    public void test4Points() {        checkAllTransforms(new int[] { 1, 2, 3, 4 },                           new int[] { 10, -2, -4, 0 });    }    /**     * Test the inverse transform of an integer vector is not always an integer vector     */    @Test    public void testNoIntInverse() {        FastHadamardTransformer transformer = new FastHadamardTransformer();        double[] x = transformer.inversetransform(new double[] { 0, 1, 0, 1});        Assert.assertEquals( 0.5, x[0], 0);        Assert.assertEquals(-0.5, x[1], 0);        Assert.assertEquals( 0.0, x[2], 0);        Assert.assertEquals( 0.0, x[3], 0);    }    /**     * Test of transformer for wrong number of points     */    @Test    public void test3Points() {        try {            new FastHadamardTransformer().transform(new double[3]);            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected        }    }    private void checkAllTransforms(int[]x, int[] y) {        checkDoubleTransform(x, y);        checkInverseDoubleTransform(x, y);        checkIntTransform(x, y);    }    private void checkDoubleTransform(int[]x, int[] y) {        // Initiate the transformer        FastHadamardTransformer transformer = new FastHadamardTransformer();        // check double transform        double[] dX = new double[x.length];        for (int i = 0; i < dX.length; ++i) {            dX[i] = x[i];        }        double dResult[] = transformer.transform(dX);        for (int i = 0; i < dResult.length; i++) {            // compare computed results to precomputed results            Assert.assertTrue(MathUtils.equals((double) y[i], dResult[i], 1));        }    }    private void checkIntTransform(int[]x, int[] y) {        // Initiate the transformer        FastHadamardTransformer transformer = new FastHadamardTransformer();        // check integer transform        int iResult[] = transformer.transform(x);        for (int i = 0; i < iResult.length; i++) {            // compare computed results to precomputed results            Assert.assertEquals(y[i], iResult[i]);        }    }    private void checkInverseDoubleTransform(int[]x, int[] y) {        // Initiate the transformer        FastHadamardTransformer transformer = new FastHadamardTransformer();        // check double transform        double[] dY = new double[y.length];        for (int i = 0; i < dY.length; ++i) {            dY[i] = y[i];        }        double dResult[] = transformer.inversetransform(dY);        for (int i = 0; i < dResult.length; i++) {            // compare computed results to precomputed results            Assert.assertTrue(MathUtils.equals((double) x[i], dResult[i], 1));        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.transform;import org.apache.commons.math.analysis.*;import org.apache.commons.math.complex.*;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test case for fast Fourier transformer. * <p> * FFT algorithm is exact, the small tolerance number is used only * to account for round-off errors. * * @version $Id$ */public final class FastFourierTransformerTest {    /**     * Test of transformer for the ad hoc data taken from Mathematica.     */    @Test    public void testAdHocData() {        FastFourierTransformer transformer = new FastFourierTransformer();        Complex result[]; double tolerance = 1E-12;        double x[] = {1.3, 2.4, 1.7, 4.1, 2.9, 1.7, 5.1, 2.7};        Complex y[] = {            new Complex(21.9, 0.0),            new Complex(-2.09497474683058, 1.91507575950825),            new Complex(-2.6, 2.7),            new Complex(-1.10502525316942, -4.88492424049175),            new Complex(0.1, 0.0),            new Complex(-1.10502525316942, 4.88492424049175),            new Complex(-2.6, -2.7),            new Complex(-2.09497474683058, -1.91507575950825)};        result = transformer.transform(x);        for (int i = 0; i < result.length; i++) {            Assert.assertEquals(y[i].getReal(), result[i].getReal(), tolerance);            Assert.assertEquals(y[i].getImaginary(), result[i].getImaginary(), tolerance);        }        result = transformer.inversetransform(y);        for (int i = 0; i < result.length; i++) {            Assert.assertEquals(x[i], result[i].getReal(), tolerance);            Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);        }        double x2[] = {10.4, 21.6, 40.8, 13.6, 23.2, 32.8, 13.6, 19.2};        FastFourierTransformer.scaleArray(x2, 1.0 / FastMath.sqrt(x2.length));        Complex y2[] = y;        result = transformer.transform2(y2);        for (int i = 0; i < result.length; i++) {            Assert.assertEquals(x2[i], result[i].getReal(), tolerance);            Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);        }        result = transformer.inversetransform2(x2);        for (int i = 0; i < result.length; i++) {            Assert.assertEquals(y2[i].getReal(), result[i].getReal(), tolerance);            Assert.assertEquals(y2[i].getImaginary(), result[i].getImaginary(), tolerance);        }    }    @Test    public void test2DData() {        FastFourierTransformer transformer = new FastFourierTransformer();        double tolerance = 1E-12;        Complex[][] input = new Complex[][] {new Complex[] {new Complex(1, 0),                                                            new Complex(2, 0)},                                             new Complex[] {new Complex(3, 1),                                                            new Complex(4, 2)}};        Complex[][] goodOutput = new Complex[][] {new Complex[] {new Complex(5,                1.5), new Complex(-1, -.5)}, new Complex[] {new Complex(-2,                -1.5), new Complex(0, .5)}};        Complex[][] output = (Complex[][])transformer.mdfft(input, true);        Complex[][] output2 = (Complex[][])transformer.mdfft(output, false);        Assert.assertEquals(input.length, output.length);        Assert.assertEquals(input.length, output2.length);        Assert.assertEquals(input[0].length, output[0].length);        Assert.assertEquals(input[0].length, output2[0].length);        Assert.assertEquals(input[1].length, output[1].length);        Assert.assertEquals(input[1].length, output2[1].length);        for (int i = 0; i < input.length; i++) {            for (int j = 0; j < input[0].length; j++) {                Assert.assertEquals(input[i][j].getImaginary(), output2[i][j].getImaginary(),                             tolerance);                Assert.assertEquals(input[i][j].getReal(), output2[i][j].getReal(), tolerance);                Assert.assertEquals(goodOutput[i][j].getImaginary(), output[i][j].getImaginary(),                             tolerance);                Assert.assertEquals(goodOutput[i][j].getReal(), output[i][j].getReal(), tolerance);            }        }    }    /**     * Test of transformer for the sine function.     */    @Test    public void testSinFunction() {        UnivariateRealFunction f = new SinFunction();        FastFourierTransformer transformer = new FastFourierTransformer();        Complex result[]; int N = 1 << 8;        double min, max, tolerance = 1E-12;        min = 0.0; max = 2.0 * FastMath.PI;        result = transformer.transform(f, min, max, N);        Assert.assertEquals(0.0, result[1].getReal(), tolerance);        Assert.assertEquals(-(N >> 1), result[1].getImaginary(), tolerance);        Assert.assertEquals(0.0, result[N-1].getReal(), tolerance);        Assert.assertEquals(N >> 1, result[N-1].getImaginary(), tolerance);        for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {            Assert.assertEquals(0.0, result[i].getReal(), tolerance);            Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);        }        min = -FastMath.PI; max = FastMath.PI;        result = transformer.inversetransform(f, min, max, N);        Assert.assertEquals(0.0, result[1].getReal(), tolerance);        Assert.assertEquals(-0.5, result[1].getImaginary(), tolerance);        Assert.assertEquals(0.0, result[N-1].getReal(), tolerance);        Assert.assertEquals(0.5, result[N-1].getImaginary(), tolerance);        for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {            Assert.assertEquals(0.0, result[i].getReal(), tolerance);            Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);        }    }    /**     * Test of parameters for the transformer.     */    @Test    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        FastFourierTransformer transformer = new FastFourierTransformer();        try {            // bad interval            transformer.transform(f, 1, -1, 64);            Assert.fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 0);            Assert.fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 100);            Assert.fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.transform;import org.apache.commons.math.analysis.*;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test case for fast cosine transformer. * <p> * FCT algorithm is exact, the small tolerance number is used only * to account for round-off errors. * * @version $Id$ */public final class FastCosineTransformerTest {    /**     * Test of transformer for the ad hoc data.     */    @Test    public void testAdHocData() {        FastCosineTransformer transformer = new FastCosineTransformer();        double result[], tolerance = 1E-12;        double x[] = { 0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0 };        double y[] = { 172.0, -105.096569476353, 27.3137084989848,                      -12.9593152353742, 8.0, -5.78585076868676,                       4.68629150101524, -4.15826451958632, 4.0 };        result = transformer.transform(x);        for (int i = 0; i < result.length; i++) {            Assert.assertEquals(y[i], result[i], tolerance);        }        result = transformer.inversetransform(y);        for (int i = 0; i < result.length; i++) {            Assert.assertEquals(x[i], result[i], tolerance);        }        FastFourierTransformer.scaleArray(x, FastMath.sqrt(0.5 * (x.length-1)));        result = transformer.transform2(y);        for (int i = 0; i < result.length; i++) {            Assert.assertEquals(x[i], result[i], tolerance);        }        result = transformer.inversetransform2(x);        for (int i = 0; i < result.length; i++) {            Assert.assertEquals(y[i], result[i], tolerance);        }    }    /**     * Test of transformer for the sine function.     */    @Test    public void testSinFunction() {        UnivariateRealFunction f = new SinFunction();        FastCosineTransformer transformer = new FastCosineTransformer();        double min, max, result[], tolerance = 1E-12; int N = 9;        double expected[] = { 0.0, 3.26197262739567, 0.0,                             -2.17958042710327, 0.0, -0.648846697642915,                              0.0, -0.433545502649478, 0.0 };        min = 0.0; max = 2.0 * FastMath.PI * N / (N-1);        result = transformer.transform(f, min, max, N);        for (int i = 0; i < N; i++) {            Assert.assertEquals(expected[i], result[i], tolerance);        }        min = -FastMath.PI; max = FastMath.PI * (N+1) / (N-1);        result = transformer.transform(f, min, max, N);        for (int i = 0; i < N; i++) {            Assert.assertEquals(-expected[i], result[i], tolerance);        }    }    /**     * Test of parameters for the transformer.     */    @Test    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        FastCosineTransformer transformer = new FastCosineTransformer();        try {            // bad interval            transformer.transform(f, 1, -1, 65);            Assert.fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 1);            Assert.fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 64);            Assert.fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.transform;import org.apache.commons.math.analysis.*;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test case for fast sine transformer. * <p> * FST algorithm is exact, the small tolerance number is used only * to account for round-off errors. * * @version $Id$ */public final class FastSineTransformerTest {    /**     * Test of transformer for the ad hoc data.     */    @Test    public void testAdHocData() {        FastSineTransformer transformer = new FastSineTransformer();        double result[], tolerance = 1E-12;        double x[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 };        double y[] = { 0.0, 20.1093579685034, -9.65685424949238,                       5.98642305066196, -4.0, 2.67271455167720,                      -1.65685424949238, 0.795649469518633 };        result = transformer.transform(x);        for (int i = 0; i < result.length; i++) {            Assert.assertEquals(y[i], result[i], tolerance);        }        result = transformer.inversetransform(y);        for (int i = 0; i < result.length; i++) {            Assert.assertEquals(x[i], result[i], tolerance);        }        FastFourierTransformer.scaleArray(x, FastMath.sqrt(x.length / 2.0));        result = transformer.transform2(y);        for (int i = 0; i < result.length; i++) {            Assert.assertEquals(x[i], result[i], tolerance);        }        result = transformer.inversetransform2(x);        for (int i = 0; i < result.length; i++) {            Assert.assertEquals(y[i], result[i], tolerance);        }    }    /**     * Test of transformer for the sine function.     */    @Test    public void testSinFunction() {        UnivariateRealFunction f = new SinFunction();        FastSineTransformer transformer = new FastSineTransformer();        double min, max, result[], tolerance = 1E-12; int N = 1 << 8;        min = 0.0; max = 2.0 * FastMath.PI;        result = transformer.transform(f, min, max, N);        Assert.assertEquals(N >> 1, result[2], tolerance);        for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {            Assert.assertEquals(0.0, result[i], tolerance);        }        min = -FastMath.PI; max = FastMath.PI;        result = transformer.transform(f, min, max, N);        Assert.assertEquals(-(N >> 1), result[2], tolerance);        for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {            Assert.assertEquals(0.0, result[i], tolerance);        }    }    /**     * Test of parameters for the transformer.     */    @Test    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        FastSineTransformer transformer = new FastSineTransformer();        try {            // bad interval            transformer.transform(f, 1, -1, 64);            Assert.fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 0);            Assert.fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 100);            Assert.fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception.util;import java.util.Locale;import java.util.Arrays;import java.io.IOException;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.ByteArrayOutputStream;import java.io.ByteArrayInputStream;import org.junit.Assert;import org.junit.Test;/** * Test for {@link ExceptionContext}. *  * @version $Id$ */public class ExceptionContextTest {    @Test    public void testMessageChain() {        final ExceptionContext c = new ExceptionContext();        final String sep = " | "; // Non-default separator.        final String m1 = "column index (0)";        c.addMessage(LocalizedFormats.COLUMN_INDEX, 0);        final String m2 = "got 1x2 but expected 3x4";        c.addMessage(LocalizedFormats.DIMENSIONS_MISMATCH_2x2, 1, 2, 3, 4);        final String m3 = "It didn't work out";        c.addMessage(LocalizedFormats.SIMPLE_MESSAGE, m3);        Assert.assertEquals(c.getMessage(Locale.US, sep),                            m1 + sep + m2 + sep + m3);    }    @Test    public void testNoArgAddMessage() {        final ExceptionContext c = new ExceptionContext();        c.addMessage(LocalizedFormats.SIMPLE_MESSAGE);        Assert.assertEquals(c.getMessage(), "{0}");    }    @Test    public void testContext() {        final ExceptionContext c = new ExceptionContext();        final String[] keys = {"Key 1", "Key 2"};        final Object[] values = {"Value 1", Integer.valueOf(2)};        for (int i = 0; i < keys.length; i++) {            c.setValue(keys[i], values[i]);        }        // Check that all keys are present.        Assert.assertTrue(c.getKeys().containsAll(Arrays.asList(keys)));        // Check that all values are correctly stored.        for (int i = 0; i < keys.length; i++) {            Assert.assertEquals(values[i], c.getValue(keys[i]));        }        // Check behaviour on missing key.        Assert.assertNull(c.getValue("xyz"));    }    @Test    public void testSerialize()        throws IOException,               ClassNotFoundException {        final ExceptionContext cOut = new ExceptionContext();        cOut.addMessage(LocalizedFormats.COLUMN_INDEX, 0);        cOut.setValue("Key 1", Integer.valueOf(0));        ByteArrayOutputStream bos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(bos);        oos.writeObject(cOut);        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());        ObjectInputStream ois = new ObjectInputStream(bis);        ExceptionContext cIn = (ExceptionContext) ois.readObject();        Assert.assertTrue(cOut.getMessage().equals(cIn.getMessage()));        for (String key : cIn.getKeys()) {            Assert.assertTrue(cOut.getValue(key).equals(cIn.getValue(key)));        }    }    @Test    public void testSerializeUnserializable() {        final ExceptionContext cOut = new ExceptionContext();        cOut.addMessage(LocalizedFormats.SIMPLE_MESSAGE, "OK");        cOut.addMessage(LocalizedFormats.SIMPLE_MESSAGE, new Unserializable());        String key = "Key 1";        cOut.setValue(key, new Unserializable());        try {            ByteArrayOutputStream bos = new ByteArrayOutputStream();            ObjectOutputStream oos = new ObjectOutputStream(bos);            oos.writeObject(cOut);            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());            ObjectInputStream ois = new ObjectInputStream(bis);            ExceptionContext cIn = (ExceptionContext) ois.readObject();            String nsObjStr = (String) cIn.getValue(key);            Assert.assertTrue(nsObjStr.matches(".*could not be serialized.*"));        } catch (Exception e) {            Assert.fail(e.toString());        }    }    /**     * Class used by {@link #testSerializeUnserializable()}.     */    private static class Unserializable {        Unserializable() {}    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception.util;import java.util.List;import java.util.ArrayList;import org.junit.Assert;import org.junit.Test;/** * Test for {@link ArgUtils}. *  * @version $Id$ */public class ArgUtilsTest {    @Test    public void testFlatten() {        final List<Object> orig = new ArrayList<Object>();        final Object[] struct = new Object[] {            new Object[] {                new Object[] {                    create(orig),                    create(orig),                },                create(orig),                new Object[] {                    create(orig),                }            },            create(orig),            new Object[] {                create(orig),                new Object[] {                    create(orig),                    create(orig),                }            },            create(orig),        };        Object[] flat = ArgUtils.flatten(struct);        Assert.assertEquals(flat.length, orig.size());        for (int i = 0, max = orig.size(); i < max; i++) {            Assert.assertEquals(orig.get(i), flat[i]);        }    }    /**     * Create and store an {@code Object}.     *     * @param list List to store to.     * @return the stored object.     */    private Object create(List<Object> list) {        final Object o = new Object();        list.add(o);        return o;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception;import org.junit.Assert;import org.junit.Test;/** * Test for {@link DimensionMismatchException}. *  * @version $Id$ */public class DimensionMismatchExceptionTest {    @Test    public void testAccessors() {        final DimensionMismatchException e = new DimensionMismatchException(1, 2);        Assert.assertEquals(1, e.getArgument());        Assert.assertEquals(2, e.getDimension());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception;import org.junit.Assert;import org.junit.Test;/** * Test for {@link NotStrictlyPositiveException}. *  * @version $Id$ */public class NotStrictlyPositiveExceptionTest {    @Test    public void testAccessors() {        final NotStrictlyPositiveException e = new NotStrictlyPositiveException(0);        Assert.assertEquals(0, e.getArgument());        Assert.assertEquals(0, e.getMin());        Assert.assertFalse(e.getBoundIsAllowed());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception;import java.text.MessageFormat;import org.junit.Assert;import org.junit.Test;/** * Test for {@link TooManyEvaluationsException}. *  * @version $Id$ */public class TooManyEvaluationsExceptionTest {    @Test    public void testMessage() {        final int max = 12345;        final TooManyEvaluationsException e = new TooManyEvaluationsException(max);        final String msg = e.getLocalizedMessage();        Assert.assertTrue(msg,                          msg.matches(".*?" +                                      MessageFormat.format("{0}", max) +                                      ".*"));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception;import org.junit.Assert;import org.junit.Test;/** * Test for {@link NotPositiveException}. *  * @version $Id$ */public class NotPositiveExceptionTest {    @Test    public void testAccessors() {        final NotPositiveException e = new NotPositiveException(-1);        Assert.assertEquals(-1, e.getArgument());        Assert.assertEquals(0, e.getMin());        Assert.assertTrue(e.getBoundIsAllowed());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception;import org.junit.Assert;import org.junit.Test;/** * Test for {@link NumberIsTooSmallException}. *  * @version $Id$ */public class NumberIsTooSmallExceptionTest {    @Test    public void testAccessors() {        final NumberIsTooSmallException e = new NumberIsTooSmallException(0, 0, false);        Assert.assertEquals(0, e.getArgument());        Assert.assertEquals(0, e.getMin());        Assert.assertFalse(e.getBoundIsAllowed());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception;import org.junit.Assert;import org.junit.Test;/** * Test for {@link NumberIsTooLargeException}. *  * @version $Id$ */public class NumberIsTooLargeExceptionTest {    @Test    public void testAccessors() {        final NumberIsTooLargeException e = new NumberIsTooLargeException(1, 0, true);        Assert.assertEquals(1, e.getArgument());        Assert.assertEquals(0, e.getMax());        Assert.assertTrue(e.getBoundIsAllowed());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception;import org.apache.commons.math.util.MathUtils;import org.junit.Assert;import org.junit.Test;/** * Test for {@link NonMonotonousSequenceException}. *  * @version $Id$ */public class NonMonotonousSequenceExceptionTest {    @Test    public void testAccessors() {        NonMonotonousSequenceException e            = new NonMonotonousSequenceException(0, -1, 1, MathUtils.OrderDirection.DECREASING, false);        Assert.assertEquals(0, e.getArgument());        Assert.assertEquals(-1, e.getPrevious());        Assert.assertEquals(1, e.getIndex());        Assert.assertTrue(e.getDirection() == MathUtils.OrderDirection.DECREASING);        Assert.assertFalse(e.getStrict());        e = new NonMonotonousSequenceException(-1, 0, 1);        Assert.assertEquals(-1, e.getArgument());        Assert.assertEquals(0, e.getPrevious());        Assert.assertEquals(1, e.getIndex());        Assert.assertTrue(e.getDirection() == MathUtils.OrderDirection.INCREASING);        Assert.assertTrue(e.getStrict());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception;import org.junit.Assert;import org.junit.Test;/** * Test for {@link OutOfRangeException}. *  * @version $Id$ */public class OutOfRangeExceptionTest {    @Test    public void testAccessors() {        final OutOfRangeException e = new OutOfRangeException(-1, 0, 2);        Assert.assertEquals(-1, e.getArgument());        Assert.assertEquals(0, e.getLo());        Assert.assertEquals(2, e.getHi());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception;import org.junit.Assert;import org.junit.Test;/** * Test for {@link MaxCountExceededException}. *  * @version $Id$ */public class MaxCountExceededExceptionTest {    @Test    public void testAccessors() {        final MaxCountExceededException e = new MaxCountExceededException(10);        Assert.assertEquals(10, e.getMax());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.special;import org.apache.commons.math.TestUtils;import org.junit.Test;/** * @version $Id$ */public class BetaTest {    private void testRegularizedBeta(double expected, double x,                                     double a, double b) {        double actual = Beta.regularizedBeta(x, a, b);        TestUtils.assertEquals(expected, actual, 10e-15);    }    private void testLogBeta(double expected, double a, double b) {        double actual = Beta.logBeta(a, b);        TestUtils.assertEquals(expected, actual, 10e-15);    }    @Test    public void testRegularizedBetaNanPositivePositive() {        testRegularizedBeta(Double.NaN, Double.NaN, 1.0, 1.0);    }    @Test    public void testRegularizedBetaPositiveNanPositive() {        testRegularizedBeta(Double.NaN, 0.5, Double.NaN, 1.0);    }    @Test    public void testRegularizedBetaPositivePositiveNan() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, Double.NaN);    }    @Test    public void testRegularizedBetaNegativePositivePositive() {        testRegularizedBeta(Double.NaN, -0.5, 1.0, 2.0);    }    @Test    public void testRegularizedBetaPositiveNegativePositive() {        testRegularizedBeta(Double.NaN, 0.5, -1.0, 2.0);    }    @Test    public void testRegularizedBetaPositivePositiveNegative() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, -2.0);    }    @Test    public void testRegularizedBetaZeroPositivePositive() {        testRegularizedBeta(0.0, 0.0, 1.0, 2.0);    }    @Test    public void testRegularizedBetaPositiveZeroPositive() {        testRegularizedBeta(Double.NaN, 0.5, 0.0, 2.0);    }    @Test    public void testRegularizedBetaPositivePositiveZero() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, 0.0);    }    @Test    public void testRegularizedBetaPositivePositivePositive() {        testRegularizedBeta(0.75, 0.5, 1.0, 2.0);    }    @Test    public void testLogBetaNanPositive() {        testLogBeta(Double.NaN, Double.NaN, 2.0);    }    @Test    public void testLogBetaPositiveNan() {        testLogBeta(Double.NaN, 1.0, Double.NaN);    }    @Test    public void testLogBetaNegativePositive() {        testLogBeta(Double.NaN, -1.0, 2.0);    }    @Test    public void testLogBetaPositiveNegative() {        testLogBeta(Double.NaN, 1.0, -2.0);    }    @Test    public void testLogBetaZeroPositive() {        testLogBeta(Double.NaN, 0.0, 2.0);    }    @Test    public void testLogBetaPositiveZero() {        testLogBeta(Double.NaN, 1.0, 0.0);    }    @Test    public void testLogBetaPositivePositive() {        testLogBeta(-0.693147180559945, 1.0, 2.0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.special;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Test;import org.junit.Assert;/** * @version $Id$ */public class GammaTest {    private void testRegularizedGamma(double expected, double a, double x) {        double actualP = Gamma.regularizedGammaP(a, x);        double actualQ = Gamma.regularizedGammaQ(a, x);        TestUtils.assertEquals(expected, actualP, 10e-15);        TestUtils.assertEquals(actualP, 1.0 - actualQ, 10e-15);    }    private void testLogGamma(double expected, double x) {        double actual = Gamma.logGamma(x);        TestUtils.assertEquals(expected, actual, 10e-15);    }    @Test    public void testRegularizedGammaNanPositive() {        testRegularizedGamma(Double.NaN, Double.NaN, 1.0);    }    @Test    public void testRegularizedGammaPositiveNan() {        testRegularizedGamma(Double.NaN, 1.0, Double.NaN);    }    @Test    public void testRegularizedGammaNegativePositive() {        testRegularizedGamma(Double.NaN, -1.5, 1.0);    }    @Test    public void testRegularizedGammaPositiveNegative() {        testRegularizedGamma(Double.NaN, 1.0, -1.0);    }    @Test    public void testRegularizedGammaZeroPositive() {        testRegularizedGamma(Double.NaN, 0.0, 1.0);    }    @Test    public void testRegularizedGammaPositiveZero() {        testRegularizedGamma(0.0, 1.0, 0.0);    }    @Test    public void testRegularizedGammaPositivePositive() {        testRegularizedGamma(0.632120558828558, 1.0, 1.0);    }    @Test    public void testLogGammaNan() {        testLogGamma(Double.NaN, Double.NaN);    }    @Test    public void testLogGammaNegative() {        testLogGamma(Double.NaN, -1.0);    }    @Test    public void testLogGammaZero() {        testLogGamma(Double.NaN, 0.0);    }    @Test    public void testLogGammaPositive() {        testLogGamma(0.6931471805599457, 3.0);    }    @Test    public void testDigammaLargeArgs() {        double eps = 1e-8;        Assert.assertEquals(4.6001618527380874002, Gamma.digamma(100), eps);        Assert.assertEquals(3.9019896734278921970, Gamma.digamma(50), eps);        Assert.assertEquals(2.9705239922421490509, Gamma.digamma(20), eps);        Assert.assertEquals(2.9958363947076465821, Gamma.digamma(20.5), eps);        Assert.assertEquals(2.2622143570941481605, Gamma.digamma(10.1), eps);        Assert.assertEquals(2.1168588189004379233, Gamma.digamma(8.8), eps);        Assert.assertEquals(1.8727843350984671394, Gamma.digamma(7), eps);        Assert.assertEquals(0.42278433509846713939, Gamma.digamma(2), eps);        Assert.assertEquals(-100.56088545786867450, Gamma.digamma(0.01), eps);        Assert.assertEquals(-4.0390398965921882955, Gamma.digamma(-0.8), eps);        Assert.assertEquals(4.2003210041401844726, Gamma.digamma(-6.3), eps);    }    @Test    public void testDigammaSmallArgs() {        // values for negative powers of 10 from 1 to 30 as computed by webMathematica with 20 digits        // see functions.wolfram.com        double[] expected = {-10.423754940411076795, -100.56088545786867450, -1000.5755719318103005,                -10000.577051183514335, -100000.57719921568107, -1.0000005772140199687e6, -1.0000000577215500408e7,                -1.0000000057721564845e8, -1.0000000005772156633e9, -1.0000000000577215665e10, -1.0000000000057721566e11,                -1.0000000000005772157e12, -1.0000000000000577216e13, -1.0000000000000057722e14, -1.0000000000000005772e15, -1e+16,                -1e+17, -1e+18, -1e+19, -1e+20, -1e+21, -1e+22, -1e+23, -1e+24, -1e+25, -1e+26,                -1e+27, -1e+28, -1e+29, -1e+30};        for (double n = 1; n < 30; n++) {            checkRelativeError(String.format("Test %.0f: ", n), expected[(int) (n - 1)], Gamma.digamma(FastMath.pow(10.0, -n)), 1e-8);        }    }    @Test    public void testTrigamma() {        double eps = 1e-8;        // computed using webMathematica.  For example, to compute trigamma($i) = Polygamma(1, $i), use        //        // http://functions.wolfram.com/webMathematica/Evaluated.jsp?name=PolyGamma2&plottype=0&vars={%221%22,%22$i%22}&digits=20        double[] data = {                1e-4, 1.0000000164469368793e8,                1e-3, 1.0000016425331958690e6,                1e-2, 10001.621213528313220,                1e-1, 101.43329915079275882,                1, 1.6449340668482264365,                2, 0.64493406684822643647,                3, 0.39493406684822643647,                4, 0.28382295573711532536,                5, 0.22132295573711532536,                10, 0.10516633568168574612,                20, 0.051270822935203119832,                50, 0.020201333226697125806,                100, 0.010050166663333571395        };        for (int i = data.length - 2; i >= 0; i -= 2) {            Assert.assertEquals(String.format("trigamma %.0f", data[i]), data[i + 1], Gamma.trigamma(data[i]), eps);        }    }    private void checkRelativeError(String msg, double expected, double actual, double tolerance) {        Assert.assertEquals(msg, expected, actual, FastMath.abs(tolerance * actual));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.apache.commons.math.special;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Test;import org.junit.Assert;/** * @version $Id$ */public class ErfTest {    @Test    public void testErf0() {        double actual = Erf.erf(0.0);        double expected = 0.0;        Assert.assertEquals(expected, actual, 1.0e-15);        Assert.assertEquals(1 - expected, Erf.erfc(0.0), 1.0e-15);    }    @Test    public void testErf1960() {        double x = 1.960 / FastMath.sqrt(2.0);        double actual = Erf.erf(x);        double expected = 0.95;        Assert.assertEquals(expected, actual, 1.0e-5);        Assert.assertEquals(1 - actual, Erf.erfc(x), 1.0e-15);        actual = Erf.erf(-x);        expected = -expected;        Assert.assertEquals(expected, actual, 1.0e-5);        Assert.assertEquals(1 - actual, Erf.erfc(-x), 1.0e-15);    }    @Test    public void testErf2576() {        double x = 2.576 / FastMath.sqrt(2.0);        double actual = Erf.erf(x);        double expected = 0.99;        Assert.assertEquals(expected, actual, 1.0e-5);        Assert.assertEquals(1 - actual, Erf.erfc(x), 1e-15);        actual = Erf.erf(-x);        expected = -expected;        Assert.assertEquals(expected, actual, 1.0e-5);        Assert.assertEquals(1 - actual, Erf.erfc(-x), 1.0e-15);    }    @Test    public void testErf2807() {        double x = 2.807 / FastMath.sqrt(2.0);        double actual = Erf.erf(x);        double expected = 0.995;        Assert.assertEquals(expected, actual, 1.0e-5);        Assert.assertEquals(1 - actual, Erf.erfc(x), 1.0e-15);        actual = Erf.erf(-x);        expected = -expected;        Assert.assertEquals(expected, actual, 1.0e-5);        Assert.assertEquals(1 - actual, Erf.erfc(-x), 1.0e-15);    }    @Test    public void testErf3291() {        double x = 3.291 / FastMath.sqrt(2.0);        double actual = Erf.erf(x);        double expected = 0.999;        Assert.assertEquals(expected, actual, 1.0e-5);        Assert.assertEquals(1 - expected, Erf.erfc(x), 1.0e-5);        actual = Erf.erf(-x);        expected = -expected;        Assert.assertEquals(expected, actual, 1.0e-5);        Assert.assertEquals(1 - expected, Erf.erfc(-x), 1.0e-5);    }        /**     * MATH-301, MATH-456     */    @Test    public void testLargeValues() throws Exception {        for (int i = 1; i < 200; i*=10) {            double result = Erf.erf(i);            Assert.assertFalse(Double.isNaN(result));            Assert.assertTrue(result > 0 && result <= 1);            result = Erf.erf(-i);            Assert.assertFalse(Double.isNaN(result));            Assert.assertTrue(result >= -1 && result < 0);            result = Erf.erfc(i);            Assert.assertFalse(Double.isNaN(result));            Assert.assertTrue(result >= 0 && result < 1);            result = Erf.erfc(-i);            Assert.assertFalse(Double.isNaN(result));            Assert.assertTrue(result >= 1 && result <= 2);            }        Assert.assertEquals(-1, Erf.erf(Double.NEGATIVE_INFINITY), 0);        Assert.assertEquals(1, Erf.erf(Double.POSITIVE_INFINITY), 0);        Assert.assertEquals(2, Erf.erfc(Double.NEGATIVE_INFINITY), 0);        Assert.assertEquals(0, Erf.erfc(Double.POSITIVE_INFINITY), 0);    }        /**     * Compare Erf.erf against reference values computed using GCC 4.2.1 (Apple OSX packaged version)     * erfl (extended precision erf).     */    @Test    public void testErfGnu() throws Exception {        final double tol = 1E-15;        final double[] gnuValues = new double[] {-1, -1, -1, -1, -1,         -1, -1, -1, -0.99999999999999997848,         -0.99999999999999264217, -0.99999999999846254017, -0.99999999980338395581, -0.99999998458274209971,         -0.9999992569016276586, -0.99997790950300141459, -0.99959304798255504108, -0.99532226501895273415,         -0.96610514647531072711, -0.84270079294971486948, -0.52049987781304653809,  0,          0.52049987781304653809, 0.84270079294971486948, 0.96610514647531072711, 0.99532226501895273415,          0.99959304798255504108, 0.99997790950300141459, 0.9999992569016276586, 0.99999998458274209971,          0.99999999980338395581, 0.99999999999846254017, 0.99999999999999264217, 0.99999999999999997848,          1,  1,  1,  1,          1,  1,  1,  1};        double x = -10d;        for (int i = 0; i < 41; i++) {            Assert.assertEquals(gnuValues[i], Erf.erf(x), tol);            x += 0.5d;        }    }        /**     * Compare Erf.erfc against reference values computed using GCC 4.2.1 (Apple OSX packaged version)     * erfcl (extended precision erfc).     */    @Test    public void testErfcGnu() throws Exception {        final double tol = 1E-15;        final double[] gnuValues = new double[] { 2,  2,  2,  2,  2,         2,  2,  2, 1.9999999999999999785,         1.9999999999999926422, 1.9999999999984625402, 1.9999999998033839558, 1.9999999845827420998,         1.9999992569016276586, 1.9999779095030014146, 1.9995930479825550411, 1.9953222650189527342,         1.9661051464753107271, 1.8427007929497148695, 1.5204998778130465381,  1,         0.47950012218695346194, 0.15729920705028513051, 0.033894853524689272893, 0.0046777349810472658333,         0.00040695201744495893941, 2.2090496998585441366E-05, 7.4309837234141274516E-07, 1.5417257900280018858E-08,         1.966160441542887477E-10, 1.5374597944280348501E-12, 7.3578479179743980661E-15, 2.1519736712498913103E-17,         3.8421483271206474691E-20, 4.1838256077794144006E-23, 2.7766493860305691016E-26, 1.1224297172982927079E-29,         2.7623240713337714448E-33, 4.1370317465138102353E-37, 3.7692144856548799402E-41, 2.0884875837625447567E-45};        double x = -10d;        for (int i = 0; i < 41; i++) {            Assert.assertEquals(gnuValues[i], Erf.erfc(x), tol);            x += 0.5d;        }    }        /**     * Tests erfc against reference data computed using Maple reported in Marsaglia, G,,      * "Evaluating the Normal Distribution," Journal of Statistical Software, July, 2004.     * http//www.jstatsoft.org/v11/a05/paper     */    @Test    public void testErfcMaple() throws Exception {        double[][] ref = new double[][]                        {{0.1, 4.60172162722971e-01},                         {1.2, 1.15069670221708e-01},                         {2.3, 1.07241100216758e-02},                         {3.4, 3.36929265676881e-04},                         {4.5, 3.39767312473006e-06},                         {5.6, 1.07175902583109e-08},                          {6.7, 1.04209769879652e-11},                         {7.8, 3.09535877195870e-15},                         {8.9, 2.79233437493966e-19},                         {10.0, 7.61985302416053e-24},                         {11.1, 6.27219439321703e-29},                         {12.2, 1.55411978638959e-34},                          {13.3, 1.15734162836904e-40},                         {14.4, 2.58717592540226e-47},                         {15.5, 1.73446079179387e-54},                         {16.6, 3.48454651995041e-62}        };        for (int i = 0; i < 15; i++) {            final double result = 0.5*Erf.erfc(ref[i][0]/Math.sqrt(2));            Assert.assertEquals(ref[i][1], result, 1E-15);            TestUtils.assertRelativelyEquals(ref[i][1], result, 1E-13);        }    }        /**     * Test the implementation of Erf.erf(double, double) for consistency with results     * obtained from Erf.erf(double) and Erf.erfc(double).     */    @Test    public void testTwoArgumentErf() throws Exception {        double[] xi = new double[]{-2.0, -1.0, -0.9, -0.1, 0.0, 0.1, 0.9, 1.0, 2.0};        for(double x1 : xi) {            for(double x2 : xi) {                double a = Erf.erf(x1, x2);                double b = Erf.erf(x2) - Erf.erf(x1);                double c = Erf.erfc(x1) - Erf.erfc(x2);                Assert.assertEquals(a, b, 1E-15);                Assert.assertEquals(a, c, 1E-15);            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import org.junit.Assert;import org.junit.Test;public class RandomKeyMutationTest {    @Test    public void testMutate() {        MutationPolicy mutation = new RandomKeyMutation();        int l=10;        for (int i=0; i<20; i++) {            DummyRandomKey origRk = new DummyRandomKey(RandomKey.randomPermutation(l));            Chromosome mutated = mutation.mutate(origRk);            DummyRandomKey mutatedRk = (DummyRandomKey) mutated;            int changes = 0;            for (int j=0; j<origRk.getLength(); j++) {                if (origRk.getRepresentation().get(j) != mutatedRk.getRepresentation().get(j)) {                    changes++;                }            }            Assert.assertEquals(1,changes);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import java.util.Arrays;import java.util.Comparator;import java.util.List;import org.junit.Assert;import org.junit.Test;public class RandomKeyTest {    @Test(expected=IllegalArgumentException.class)    public void testConstructor1() {        new DummyRandomKey(new Double[] {0.2, 0.3, 1.2});    }    @Test(expected=IllegalArgumentException.class)    public void testConstructor2() {        new DummyRandomKey(new Double[] {0.2, 0.3, -0.2});    }    @Test    public void testIsSame() {        DummyRandomKey drk1 = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});        DummyRandomKey drk2 = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});        DummyRandomKey drk3 = new DummyRandomKey(new Double[] {0.4, 0.15, 0.5, 0.8, 0.2});        DummyRandomKey drk4 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2});        DummyRandomKey drk5 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2, 0.5});        Assert.assertTrue(drk1.isSame(drk2));        Assert.assertTrue(drk2.isSame(drk3));        Assert.assertFalse(drk3.isSame(drk4));        Assert.assertFalse(drk4.isSame(drk5));    }    @Test    public void testDecode() {        DummyRandomKey drk = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});        List<String> decoded = drk.decode(Arrays.asList(new String[] {"a", "b", "c", "d", "e"}));        Assert.assertEquals("b", decoded.get(0));        Assert.assertEquals("e", decoded.get(1));        Assert.assertEquals("a", decoded.get(2));        Assert.assertEquals("c", decoded.get(3));        Assert.assertEquals("d", decoded.get(4));    }        @Test(expected=IllegalArgumentException.class)    public void testInvalidRepresentation() {        new DummyRandomKey(new Double[] {0.1, 0.1, 2d, 0.8, 0.2});    }    @Test    public void testRandomPermutation() {        // never generate an invalid one        for (int i=0; i<10; i++) {            DummyRandomKey drk = new DummyRandomKey(RandomKey.randomPermutation(20));            Assert.assertNotNull(drk);        }    }    @Test    public void testIdentityPermutation() {        DummyRandomKey drk = new DummyRandomKey(RandomKey.identityPermutation(5));        List<String> decoded = drk.decode(Arrays.asList(new String[] {"a", "b", "c", "d", "e"}));        Assert.assertEquals("a", decoded.get(0));        Assert.assertEquals("b", decoded.get(1));        Assert.assertEquals("c", decoded.get(2));        Assert.assertEquals("d", decoded.get(3));        Assert.assertEquals("e", decoded.get(4));    }    @Test    public void testComparatorPermutation() {        List<String> data = Arrays.asList(new String[] {"x", "b", "c", "z", "b"});        List<Double> permutation = RandomKey.comparatorPermutation(data, new Comparator<String>() {            public int compare(String o1, String o2) {                return o1.compareTo(o2);            }        });        Double[] permArr = new Double[data.size()];        permArr = permutation.toArray(permArr);        Assert.assertArrayEquals(new Double[] {0.6,0.0,0.4,0.8,0.2}, permArr);        List<String> decodedData = new DummyRandomKey(permutation).decode(data);        Assert.assertEquals("b", decodedData.get(0));        Assert.assertEquals("b", decodedData.get(1));        Assert.assertEquals("c", decodedData.get(2));        Assert.assertEquals("x", decodedData.get(3));        Assert.assertEquals("z", decodedData.get(4));        permutation = RandomKey.comparatorPermutation(data, new Comparator<String>() {            public int compare(String o1, String o2) {                return o2.compareTo(o1);            }        });        permArr = new Double[data.size()];        permArr = permutation.toArray(permArr);        Assert.assertArrayEquals(new Double[] {0.2,0.6,0.4,0.0,0.8}, permArr);        decodedData = new DummyRandomKey(permutation).decode(data);        Assert.assertEquals("z", decodedData.get(0));        Assert.assertEquals("x", decodedData.get(1));        Assert.assertEquals("c", decodedData.get(2));        Assert.assertEquals("b", decodedData.get(3));        Assert.assertEquals("b", decodedData.get(4));    }    @Test    public void testInducedPermutation() {        List<String> origData = Arrays.asList(new String[] {"a", "b", "c", "d", "d"});        List<String> permutedData = Arrays.asList(new String[] {"d", "b", "c", "a", "d"});        DummyRandomKey drk = new DummyRandomKey(RandomKey.inducedPermutation(origData, permutedData));        List<String> decoded = drk.decode(origData);        Assert.assertEquals("d", decoded.get(0));        Assert.assertEquals("b", decoded.get(1));        Assert.assertEquals("c", decoded.get(2));        Assert.assertEquals("a", decoded.get(3));        Assert.assertEquals("d", decoded.get(4));        try {            RandomKey.inducedPermutation(                    Arrays.asList(new String[] {"a", "b", "c", "d", "d"}),                    Arrays.asList(new String[] {"a", "b", "c", "d"})            );            Assert.fail("Uncaught exception");        } catch (IllegalArgumentException e) {            // no-op        }        try {            RandomKey.inducedPermutation(                    Arrays.asList(new String[] {"a", "b", "c", "d", "d"}),                    Arrays.asList(new String[] {"a", "b", "c", "d", "f"})            );            Assert.fail("Uncaught exception");        } catch (IllegalArgumentException e) {            // no-op        }    }    @Test    public void testEqualRepr() {        DummyRandomKey drk = new DummyRandomKey(new Double[] {0.2, 0.2, 0.5});        List<String> decodedData = drk.decode(Arrays.asList(new String[] {"a", "b", "c"}));        Assert.assertEquals("a", decodedData.get(0));        Assert.assertEquals("b", decodedData.get(1));        Assert.assertEquals("c", decodedData.get(2));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import org.junit.Assert;import org.junit.Test;public class TournamentSelectionTest {    private static int counter = 0;    @Test    public void testSelect() {        TournamentSelection ts = new TournamentSelection(2);        ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203);        for (int i=0; i<pop.getPopulationLimit(); i++) {            pop.addChromosome(new DummyChromosome());        }        // how to write a test for stochastic method?        for (int i=0; i<20; i++) {            ChromosomePair pair = ts.select(pop);            // the worst chromosome should NEVER be selected            Assert.assertTrue(pair.getFirst().getFitness() > 0);            Assert.assertTrue(pair.getSecond().getFitness() > 0);        }    }    private static class DummyChromosome extends Chromosome {        private final int fitness;        public DummyChromosome() {            this.fitness = counter;            counter++;        }        public double fitness() {            return this.fitness;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import java.util.Iterator;import org.junit.Assert;import org.junit.Test;public class FixedGenerationCountTest {    @Test    public void testIsSatisfied() {        FixedGenerationCount fgc = new FixedGenerationCount(20);        int cnt = 0;        Population pop = new Population() {            public void addChromosome(Chromosome chromosome) {                // unimportant            }            public Chromosome getFittestChromosome() {                // unimportant                return null;            }            public int getPopulationLimit() {                // unimportant                return 0;            }            public int getPopulationSize() {                // unimportant                return 0;            }            public Population nextGeneration() {                // unimportant                return null;            }            public Iterator<Chromosome> iterator() {                // unimportant                return null;            }        };        while (!fgc.isSatisfied(pop)) {            cnt++;        }        Assert.assertEquals(20, cnt);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import java.util.ArrayList;import java.util.List;import org.junit.Assert;import org.junit.Test;public class ChromosomeTest {    @Test    public void testCompareTo() {        Chromosome c1 = new Chromosome() {            public double fitness() {                return 0;            }        };        Chromosome c2 = new Chromosome() {            public double fitness() {                return 10;            }        };        Chromosome c3 = new Chromosome() {            public double fitness() {                return 10;            }        };        Assert.assertTrue(c1.compareTo(c2) < 0);        Assert.assertTrue(c2.compareTo(c1) > 0);        Assert.assertEquals(0,c3.compareTo(c2));        Assert.assertEquals(0,c2.compareTo(c3));    }    private abstract static class DummyChromosome extends Chromosome {        private final int repr;        public DummyChromosome(final int repr) {            this.repr = repr;        }        @Override        protected boolean isSame(Chromosome another) {            return ((DummyChromosome) another).repr == repr;        }    }    @Test    public void testFindSameChromosome() {        Chromosome c1 = new DummyChromosome(1) {            public double fitness() {                return 1;            }        };        Chromosome c2 = new DummyChromosome(2) {            public double fitness() {                return 2;            }        };        Chromosome c3 = new DummyChromosome(3) {            public double fitness() {                return 3;            }        };        Chromosome c4 = new DummyChromosome(1) {            public double fitness() {                return 5;            }        };        Chromosome c5 = new DummyChromosome(15) {            public double fitness() {                return 15;            }        };        List<Chromosome> popChr = new ArrayList<Chromosome>();        popChr.add(c1);        popChr.add(c2);        popChr.add(c3);        Population pop = new ListPopulation(popChr,3) {            public Population nextGeneration() {                // not important                return null;            }        };        Assert.assertNull(c5.findSameChromosome(pop));        Assert.assertEquals(c1, c4.findSameChromosome(pop));        c4.searchForFitnessUpdate(pop);        Assert.assertEquals(1, c4.getFitness(),0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import org.junit.Assert;import org.junit.Test;public class OnePointCrossoverTest {    @Test    public void testCrossover() {        Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};        Integer[] p2 = new Integer[] {0,1,1,0,1,0,1,1,1};        BinaryChromosome p1c = new DummyBinaryChromosome(p1);        BinaryChromosome p2c = new DummyBinaryChromosome(p2);        OnePointCrossover<Integer> opc = new OnePointCrossover<Integer>();        // how to test a stochastic method?        for (int i=0; i<20; i++) {            ChromosomePair pair = opc.crossover(p1c,p2c);            Integer[] c1 = new Integer[p1.length];            Integer[] c2 = new Integer[p2.length];            c1 = ((BinaryChromosome) pair.getFirst()).getRepresentation().toArray(c1);            c2 = ((BinaryChromosome) pair.getSecond()).getRepresentation().toArray(c2);            // first and last values will be the same            Assert.assertEquals((int) p1[0], (int) c1[0]);            Assert.assertEquals((int) p2[0], (int) c2[0]);            Assert.assertEquals((int) p1[p1.length-1], (int) c1[c1.length-1]);            Assert.assertEquals((int) p2[p2.length-1], (int) c2[c2.length-1]);            // moreover, in the above setting, the 2nd, 3rd and 7th values will be the same            Assert.assertEquals((int) p1[2], (int) c1[2]);            Assert.assertEquals((int) p2[2], (int) c2[2]);            Assert.assertEquals((int) p1[3], (int) c1[3]);            Assert.assertEquals((int) p2[3], (int) c2[3]);            Assert.assertEquals((int) p1[7], (int) c1[7]);            Assert.assertEquals((int) p2[7], (int) c2[7]);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import java.util.LinkedList;import java.util.List;import org.junit.Assert;import org.junit.Test;public class FitnessCachingTest {    // parameters for the GA    private static final int DIMENSION = 50;    private static final double CROSSOVER_RATE = 1;    private static final double MUTATION_RATE = 0.1;    private static final int TOURNAMENT_ARITY = 5;    private static final int POPULATION_SIZE = 10;    private static final int NUM_GENERATIONS = 50;    private static final double ELITISM_RATE = 0.2;    // how many times was the fitness computed    private static int fitnessCalls = 0;    @Test    public void testFitnessCaching() {        // initialize a new genetic algorithm        GeneticAlgorithm ga = new GeneticAlgorithm(                new OnePointCrossover<Integer>(),                CROSSOVER_RATE, // all selected chromosomes will be recombined (=crosssover)                new BinaryMutation(),                MUTATION_RATE, // no mutation                new TournamentSelection(TOURNAMENT_ARITY)        );        // initial population        Population initial = randomPopulation();        // stopping conditions        StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);        // run the algorithm        ga.evolve(initial, stopCond);        int neededCalls =            POPULATION_SIZE /*initial population*/ +            (NUM_GENERATIONS - 1) /*for each population*/ * (int)(POPULATION_SIZE * (1.0 - ELITISM_RATE)) /*some chromosomes are copied*/            ;        Assert.assertTrue(fitnessCalls <= neededCalls); // some chromosomes after crossover may be the same os old ones    }    /**     * Initializes a random population.     */    private static ElitisticListPopulation randomPopulation() {        List<Chromosome> popList = new LinkedList<Chromosome>();        for (int i=0; i<POPULATION_SIZE; i++) {            BinaryChromosome randChrom = new DummyCountingBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(DIMENSION));            popList.add(randChrom);        }        return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE);    }    private static class DummyCountingBinaryChromosome extends DummyBinaryChromosome {        public DummyCountingBinaryChromosome(List<Integer> representation) {            super(representation);        }        @Override        public double fitness() {            fitnessCalls++;            return 0;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import java.util.ArrayList;import org.junit.Assert;import org.junit.Test;public class ListPopulationTest {    @Test    public void testGetFittestChromosome() {        Chromosome c1 = new Chromosome() {            public double fitness() {                return 0;            }        };        Chromosome c2 = new Chromosome() {            public double fitness() {                return 10;            }        };        Chromosome c3 = new Chromosome() {            public double fitness() {                return 15;            }        };        ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome> ();        chromosomes.add(c1);        chromosomes.add(c2);        chromosomes.add(c3);        ListPopulation population = new ListPopulation(chromosomes,10) {            public Population nextGeneration() {                // not important                return null;            }        };        Assert.assertEquals(c3, population.getFittestChromosome());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import org.junit.Assert;import org.junit.Test;public class BinaryChromosomeTest {    @Test    public void testInvalidConstructor() {        Integer[][] reprs = new Integer[][] {                new Integer[] {0,1,0,1,2},                new Integer[] {0,1,0,1,-1}        };        for (Integer[] repr : reprs) {            try {                new DummyBinaryChromosome(repr);                Assert.fail("Exception not caught");            } catch (IllegalArgumentException e) {                // Expected            }        }    }    @Test    public void testRandomConstructor() {        for (int i=0; i<20; i++) {            new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10));        }    }    @Test    public void testIsSame() {        Chromosome c1 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1});        Chromosome c2 = new DummyBinaryChromosome(new Integer[] {0,1,1,0,1});        Chromosome c3 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1,1});        Chromosome c4 = new DummyBinaryChromosome(new Integer[] {1,1,0,1,0,1});        Chromosome c5 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,0});        Chromosome c6 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1});        Assert.assertFalse(c1.isSame(c2));        Assert.assertFalse(c1.isSame(c3));        Assert.assertFalse(c1.isSame(c4));        Assert.assertFalse(c1.isSame(c5));        Assert.assertTrue(c1.isSame(c6));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import org.junit.Assert;import org.junit.Test;public class ElitisticListPopulationTest {    private static int counter = 0;    @Test    public void testNextGeneration() {        ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203);        for (int i=0; i<pop.getPopulationLimit(); i++) {            pop.addChromosome(new DummyChromosome());        }        Population nextGeneration = pop.nextGeneration();        Assert.assertEquals(20, nextGeneration.getPopulationSize());    }    private static class DummyChromosome extends Chromosome {        private final int fitness;        public DummyChromosome() {            this.fitness = counter;            counter++;        }        public double fitness() {            return this.fitness;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import org.junit.Assert;import org.junit.Test;public class BinaryMutationTest {    @Test    public void testMutate() {        BinaryMutation mutation = new BinaryMutation();        // stochastic testing :)        for (int i=0; i<20; i++) {            DummyBinaryChromosome original = new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10));            DummyBinaryChromosome mutated = (DummyBinaryChromosome) mutation.mutate(original);            // one gene should be different            int numDifferent = 0;            for (int j=0; j<original.getRepresentation().size(); j++) {                if (original.getRepresentation().get(j) != mutated.getRepresentation().get(j))                    numDifferent++;            }            Assert.assertEquals(1, numDifferent);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.filter;import org.apache.commons.math.linear.Array2DRowRealMatrix;import org.apache.commons.math.linear.ArrayRealVector;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.RealVector;import org.apache.commons.math.random.JDKRandomGenerator;import org.apache.commons.math.random.RandomGenerator;import org.apache.commons.math.util.MathUtils;import org.junit.Assert;import org.junit.Test;/** * Test for {@link KalmanFilter}. * * @version $Id$ */public class KalmanFilterTest {    @Test    public void testConstant() {        double constantValue = 10d;        double measurementNoise = 0.1d;        double processNoise = 1e-5d;        // A = [ 1 ]        RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });        // no control input        RealMatrix B = null;        // H = [ 1 ]        RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });        // x = [ 10 ]        RealVector x = new ArrayRealVector(new double[] { constantValue });        // Q = [ 1e-5 ]        RealMatrix Q = new Array2DRowRealMatrix(new double[] { processNoise });        // R = [ 0.1 ]        RealMatrix R = new Array2DRowRealMatrix(new double[] { measurementNoise });        ProcessModel pm            = new DefaultProcessModel(A, B, Q,                                      new ArrayRealVector(new double[] { constantValue }), null);        MeasurementModel mm = new DefaultMeasurementModel(H, R);        KalmanFilter filter = new KalmanFilter(pm, mm);        Assert.assertEquals(1, filter.getMeasurementDimension());        Assert.assertEquals(1, filter.getStateDimension());        assertMatrixEquals(Q.getData(), filter.getErrorCovariance());        // check the initial state        double[] expectedInitialState = new double[] { constantValue };        assertVectorEquals(expectedInitialState, filter.getStateEstimation());        RealVector pNoise = new ArrayRealVector(1);        RealVector mNoise = new ArrayRealVector(1);        RandomGenerator rand = new JDKRandomGenerator();        // iterate 60 steps        for (int i = 0; i < 60; i++) {            filter.predict();            // Simulate the process            pNoise.setEntry(0, processNoise * rand.nextGaussian());            // x = A * x + p_noise            x = A.operate(x).add(pNoise);            // Simulate the measurement            mNoise.setEntry(0, measurementNoise * rand.nextGaussian());            // z = H * x + m_noise            RealVector z = H.operate(x).add(mNoise);            filter.correct(z);            // state estimate should be larger than measurement noise            double diff = Math.abs(constantValue - filter.getStateEstimation()[0]);            // System.out.println(diff);            Assert.assertTrue(MathUtils.compareTo(diff, measurementNoise, 1e-6) < 0);        }        // error covariance should be already very low (< 0.02)        Assert.assertTrue(MathUtils.compareTo(filter.getErrorCovariance()[0][0],                                              0.02d, 1e-6) < 0);    }    private void assertVectorEquals(double[] expected, double[] result) {        Assert.assertEquals("Wrong number of rows.", expected.length,                            result.length);        for (int i = 0; i < expected.length; i++) {            Assert.assertEquals("Wrong value at position [" + i + "]",                                expected[i], result[i], 1.0e-15);        }    }    private void assertMatrixEquals(double[][] expected, double[][] result) {        Assert.assertEquals("Wrong number of rows.", expected.length,                            result.length);        for (int i = 0; i < expected.length; i++) {            Assert.assertEquals("Wrong number of columns.", expected[i].length,                                result[i].length);            for (int j = 0; j < expected[i].length; j++) {                Assert.assertEquals("Wrong value at position [" + i + "," + j                                    + "]", expected[i][j], result[i][j], 1.0e-15);            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.analysis.Expm1Function;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.exception.NumberIsTooLargeException;import org.apache.commons.math.exception.NoBracketingException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test case for {@link MullerSolver Muller} solver. * <p> * Muller's method converges almost quadratically near roots, but it can * be very slow in regions far away from zeros. Test runs show that for * reasonably good initial values, for a default absolute accuracy of 1E-6, * it generally takes 5 to 10 iterations for the solver to converge. * <p> * Tests for the exponential function illustrate the situations where * Muller solver performs poorly. * * @version $Id$ */public final class MullerSolverTest {    /**     * Test of solver for the sine function.     */    @Test    public void testSinFunction() {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new MullerSolver();        double min, max, expected, result, tolerance;        min = 3.0; max = 4.0; expected = FastMath.PI;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = -1.0; max = 1.5; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function.     */    @Test    public void testQuinticFunction() {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new MullerSolver();        double min, max, expected, result, tolerance;        min = -0.4; max = 0.2; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = 0.75; max = 1.5; expected = 1.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = -0.9; max = -0.2; expected = -0.5;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the exponential function.     * <p>     * It takes 10 to 15 iterations for the last two tests to converge.     * In fact, if not for the bisection alternative, the solver would     * exceed the default maximal iteration of 100.     */    @Test    public void testExpm1Function() {        UnivariateRealFunction f = new Expm1Function();        UnivariateRealSolver solver = new MullerSolver();        double min, max, expected, result, tolerance;        min = -1.0; max = 2.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = -20.0; max = 10.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = -50.0; max = 100.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the solver.     */    @Test    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new MullerSolver();        try {            // bad interval            double root = solver.solve(100, f, 1, -1);            System.out.println("root=" + root);            Assert.fail("Expecting NumberIsTooLargeException - bad interval");        } catch (NumberIsTooLargeException ex) {            // expected        }        try {            // no bracketing            solver.solve(100, f, 2, 3);            Assert.fail("Expecting NoBracketingException - no bracketing");        } catch (NoBracketingException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;/** * Test case for {@link PegasusSolver Pegasus} solver. * * @version $Id$ */public final class PegasusSolverTest extends BaseSecantSolverAbstractTest {    /** {@inheritDoc} */    protected UnivariateRealSolver getSolver() {        return new PegasusSolver();    }    /** {@inheritDoc} */    protected int[] getQuinticEvalCounts() {        return new int[] {3, 7, 9, 8, 9, 8, 10, 10, 12, 16, 18};    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.analysis.XMinus5Function;import org.apache.commons.math.exception.NumberIsTooLargeException;import org.apache.commons.math.exception.NoBracketingException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Base class for root-finding algorithms tests derived from * {@link BaseSecantSolver}. * * @version $Id$ */public abstract class BaseSecantSolverAbstractTest {    /** Returns the solver to use to perform the tests.     * @return the solver to use to perform the tests     */    protected abstract UnivariateRealSolver getSolver();    /** Returns the expected number of evaluations for the     * {@link #testQuinticZero} unit test. A value of {@code -1} indicates that     * the test should be skipped for that solver.     * @return the expected number of evaluations for the     * {@link #testQuinticZero} unit test     */    protected abstract int[] getQuinticEvalCounts();    @Test    public void testSinZero() {        // The sinus function is behaved well around the root at pi. The second        // order derivative is zero, which means linear approximating methods        // still converge quadratically.        UnivariateRealFunction f = new SinFunction();        double result;        UnivariateRealSolver solver = getSolver();        result = solver.solve(100, f, 3, 4);        //System.out.println(        //    "Root: " + result + " Evaluations: " + solver.getEvaluations());        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        Assert.assertTrue(solver.getEvaluations() <= 6);        result = solver.solve(100, f, 1, 4);        //System.out.println(        //    "Root: " + result + " Evaluations: " + solver.getEvaluations());        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        Assert.assertTrue(solver.getEvaluations() <= 7);    }    @Test    public void testQuinticZero() {        // The quintic function has zeros at 0, +-0.5 and +-1.        // Around the root of 0 the function is well behaved, with a second        // derivative of zero a 0.        // The other roots are less well to find, in particular the root at 1,        // because the function grows fast for x>1.        // The function has extrema (first derivative is zero) at 0.27195613        // and 0.82221643, intervals containing these values are harder for        // the solvers.        UnivariateRealFunction f = new QuinticFunction();        double result;        UnivariateRealSolver solver = getSolver();        double atol = solver.getAbsoluteAccuracy();        int[] counts = getQuinticEvalCounts();        // Tests data: initial bounds, and expected solution, per test case.        double[][] testsData = {{-0.2,  0.2,  0.0},                                {-0.1,  0.3,  0.0},                                {-0.3,  0.45, 0.0},                                { 0.3,  0.7,  0.5},                                { 0.2,  0.6,  0.5},                                { 0.05, 0.95, 0.5},                                { 0.85, 1.25, 1.0},                                { 0.8,  1.2,  1.0},                                { 0.85, 1.75, 1.0},                                { 0.55, 1.45, 1.0},                                { 0.85, 5.0,  1.0},                               };        int maxIter = 500;        for(int i = 0; i < testsData.length; i++) {            // Skip test, if needed.            if (counts[i] == -1) continue;            // Compute solution.            double[] testData = testsData[i];            result = solver.solve(maxIter, f, testData[0], testData[1]);            //System.out.println(            //    "Root: " + result + " Evaluations: " + solver.getEvaluations());            // Check solution.            Assert.assertEquals(result, testData[2], atol);            Assert.assertTrue(solver.getEvaluations() <= counts[i] + 1);        }    }    @Test    public void testRootEndpoints() {        UnivariateRealFunction f = new XMinus5Function();        UnivariateRealSolver solver = getSolver();        // End-point is root. This should be a special case in the solver, and        // the initial end-point should be returned exactly.        double result = solver.solve(100, f, 5.0, 6.0);        Assert.assertEquals(5.0, result, 0.0);        result = solver.solve(100, f, 4.0, 5.0);        Assert.assertEquals(5.0, result, 0.0);        result = solver.solve(100, f, 5.0, 6.0, 5.5);        Assert.assertEquals(5.0, result, 0.0);        result = solver.solve(100, f, 4.0, 5.0, 4.5);        Assert.assertEquals(5.0, result, 0.0);    }    @Test    public void testBadEndpoints() {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = getSolver();        try {  // bad interval            solver.solve(100, f, 1, -1);            Assert.fail("Expecting NumberIsTooLargeException - bad interval");        } catch (NumberIsTooLargeException ex) {            // expected        }        try {  // no bracket            solver.solve(100, f, 1, 1.5);            Assert.fail("Expecting NoBracketingException - non-bracketing");        } catch (NoBracketingException ex) {            // expected        }        try {  // no bracket            solver.solve(100, f, 1, 1.5, 1.2);            Assert.fail("Expecting NoBracketingException - non-bracketing");        } catch (NoBracketingException ex) {            // expected        }    }    @Test    public void testSolutionLeftSide() {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = getSolver();        double left = -1.5;        double right = 0.05;        for(int i = 0; i < 10; i++) {            // Test whether the allowed solutions are taken into account.            double solution = getSolution(solver, 100, f, left, right, AllowedSolution.LEFT_SIDE);            if (!Double.isNaN(solution)) {                Assert.assertTrue(solution <= 0.0);            }            // Prepare for next test.            left -= 0.1;            right += 0.3;        }    }    @Test    public void testSolutionRightSide() {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = getSolver();        double left = -1.5;        double right = 0.05;        for(int i = 0; i < 10; i++) {            // Test whether the allowed solutions are taken into account.            double solution = getSolution(solver, 100, f, left, right, AllowedSolution.RIGHT_SIDE);            if (!Double.isNaN(solution)) {                Assert.assertTrue(solution >= 0.0);            }            // Prepare for next test.            left -= 0.1;            right += 0.3;        }    }    @Test    public void testSolutionBelowSide() {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = getSolver();        double left = -1.5;        double right = 0.05;        for(int i = 0; i < 10; i++) {            // Test whether the allowed solutions are taken into account.            double solution = getSolution(solver, 100, f, left, right, AllowedSolution.BELOW_SIDE);            if (!Double.isNaN(solution)) {                Assert.assertTrue(f.value(solution) <= 0.0);            }            // Prepare for next test.            left -= 0.1;            right += 0.3;        }    }    @Test    public void testSolutionAboveSide() {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = getSolver();        double left = -1.5;        double right = 0.05;        for(int i = 0; i < 10; i++) {            // Test whether the allowed solutions are taken into account.            double solution = getSolution(solver, 100, f, left, right, AllowedSolution.ABOVE_SIDE);            if (!Double.isNaN(solution)) {                Assert.assertTrue(f.value(solution) >= 0.0);            }            // Prepare for next test.            left -= 0.1;            right += 0.3;        }    }    private double getSolution(UnivariateRealSolver solver, int maxEval, UnivariateRealFunction f,                               double left, double right, AllowedSolution allowedSolution) {        try {            @SuppressWarnings("unchecked")            BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =            (BracketedUnivariateRealSolver<UnivariateRealFunction>) solver;            return bracketing.solve(100, f, left, right, allowedSolution);        } catch (ClassCastException cce) {            double baseRoot = solver.solve(maxEval, f, left, right);            if ((baseRoot <= left) || (baseRoot >= right)) {                // the solution slipped out of interval                return Double.NaN;            }            PegasusSolver bracketing =                    new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy(),                                      solver.getFunctionValueAccuracy());            return UnivariateRealSolverUtils.forceSide(maxEval - solver.getEvaluations(),                                                       f, bracketing, baseRoot, left, right,                                                       allowedSolution);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.exception.TooManyEvaluationsException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test case for {@link BracketingNthOrderBrentSolver bracketing n<sup>th</sup> order Brent} solver. * * @version $Id$ */public final class BracketingNthOrderBrentSolverTest extends BaseSecantSolverAbstractTest {    /** {@inheritDoc} */    protected UnivariateRealSolver getSolver() {        return new BracketingNthOrderBrentSolver();    }    /** {@inheritDoc} */    protected int[] getQuinticEvalCounts() {        return new int[] {1, 3, 8, 1, 9, 4, 8, 1, 12, 1, 14};    }    @Test(expected=NumberIsTooSmallException.class)    public void testInsufficientOrder1() {        new BracketingNthOrderBrentSolver(1.0e-10, 1);    }    @Test(expected=NumberIsTooSmallException.class)    public void testInsufficientOrder2() {        new BracketingNthOrderBrentSolver(1.0e-10, 1.0e-10, 1);    }    @Test(expected=NumberIsTooSmallException.class)    public void testInsufficientOrder3() {        new BracketingNthOrderBrentSolver(1.0e-10, 1.0e-10, 1.0e-10, 1);    }    @Test    public void testConstructorsOK() {        Assert.assertEquals(2, new BracketingNthOrderBrentSolver(1.0e-10, 2).getMaximalOrder());        Assert.assertEquals(2, new BracketingNthOrderBrentSolver(1.0e-10, 1.0e-10, 2).getMaximalOrder());        Assert.assertEquals(2, new BracketingNthOrderBrentSolver(1.0e-10, 1.0e-10, 1.0e-10, 2).getMaximalOrder());    }    @Test    public void testConvergenceOnFunctionAccuracy() {        BracketingNthOrderBrentSolver solver =                new BracketingNthOrderBrentSolver(1.0e-12, 1.0e-10, 0.001, 3);        QuinticFunction f = new QuinticFunction();        double result = solver.solve(20, f, 0.2, 0.9, 0.4, AllowedSolution.BELOW_SIDE);        Assert.assertEquals(0, f.value(result), solver.getFunctionValueAccuracy());        Assert.assertTrue(f.value(result) <= 0);        Assert.assertTrue(result - 0.5 > solver.getAbsoluteAccuracy());        result = solver.solve(20, f, -0.9, -0.2,  -0.4, AllowedSolution.ABOVE_SIDE);        Assert.assertEquals(0, f.value(result), solver.getFunctionValueAccuracy());        Assert.assertTrue(f.value(result) >= 0);        Assert.assertTrue(result + 0.5 < -solver.getAbsoluteAccuracy());    }    @Test    public void testFasterThanNewton() {        // the following test functions come from Beny Neta's paper:        // "Several New Methods for solving Equations"        // intern J. Computer Math Vol 23 pp 265-282        // available here: http://www.math.nps.navy.mil/~bneta/SeveralNewMethods.PDF        // the reference roots have been computed by the Dfp solver to more than        // 80 digits and checked with emacs (only the first 20 digits are reproduced here)        compare(new TestFunction(0.0, -2, 2) {            public double value(double x)      { return FastMath.sin(x) - 0.5 * x; }            public double derivative(double x) { return FastMath.cos(x) - 0.5; }        });        compare(new TestFunction(6.3087771299726890947, -5, 10) {            public double value(double x)      { return FastMath.pow(x, 5) + x - 10000; }            public double derivative(double x) { return 5 * FastMath.pow(x, 4) + 1; }        });        compare(new TestFunction(9.6335955628326951924, 0.001, 10) {            public double value(double x)      { return FastMath.sqrt(x) - 1 / x - 3; }            public double derivative(double x) { return 0.5 / FastMath.sqrt(x) + 1 / (x * x); }        });        compare(new TestFunction(2.8424389537844470678, -5, 5) {            public double value(double x)      { return FastMath.exp(x) + x - 20; }            public double derivative(double x) { return FastMath.exp(x) + 1; }        });        compare(new TestFunction(8.3094326942315717953, 0.001, 10) {            public double value(double x)      { return FastMath.log(x) + FastMath.sqrt(x) - 5; }            public double derivative(double x) { return 1 / x + 0.5 / FastMath.sqrt(x); }        });        compare(new TestFunction(1.4655712318767680266, -0.5, 1.5) {            public double value(double x)      { return (x - 1) * x * x - 1; }            public double derivative(double x) { return (3 * x - 2) * x; }        });    }    private void compare(TestFunction f) {        compare(f, f.getRoot(), f.getMin(), f.getMax());    }    private void compare(DifferentiableUnivariateRealFunction f,                         double root, double min, double max) {        NewtonSolver newton = new NewtonSolver(1.0e-12);        BracketingNthOrderBrentSolver bracketing =                new BracketingNthOrderBrentSolver(1.0e-12, 1.0e-12, 1.0e-18, 5);        double resultN;        try {            resultN = newton.solve(100, f, min, max);        } catch (TooManyEvaluationsException tmee) {            resultN = Double.NaN;        }        double resultB;        try {            resultB = bracketing.solve(100, f, min, max);        } catch (TooManyEvaluationsException tmee) {            resultB = Double.NaN;        }        Assert.assertEquals(root, resultN, newton.getAbsoluteAccuracy());        Assert.assertEquals(root, resultB, bracketing.getAbsoluteAccuracy());        Assert.assertTrue(bracketing.getEvaluations() < newton.getEvaluations());    }    private static abstract class TestFunction implements DifferentiableUnivariateRealFunction {        private final double root;        private final double min;        private final double max;        protected TestFunction(final double root, final double min, final double max) {            this.root = root;            this.min  = min;            this.max  = max;        }        public double getRoot() {            return root;        }        public double getMin() {            return min;        }        public double getMax() {            return max;        }        public abstract double value(double x);        public abstract double derivative(double x);        public UnivariateRealFunction derivative() {            return new UnivariateRealFunction() {                public double value(double x) {                     return derivative(x);                }            };        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.exception.ConvergenceException;import org.junit.Test;import org.junit.Assert;/** * Test case for {@link RegulaFalsiSolver Regula Falsi} solver. * * @version $Id$ */public final class RegulaFalsiSolverTest extends BaseSecantSolverAbstractTest {    /** {@inheritDoc} */    protected UnivariateRealSolver getSolver() {        return new RegulaFalsiSolver();    }    /** {@inheritDoc} */    protected int[] getQuinticEvalCounts() {        // While the Regula Falsi method guarantees convergence, convergence        // may be extremely slow. The last test case does not converge within        // even a million iterations. As such, it was disabled.        return new int[] {3, 7, 8, 19, 18, 11, 67, 55, 288, 151, -1};    }    @Test(expected=ConvergenceException.class)    public void testIssue631() {        final UnivariateRealFunction f = new UnivariateRealFunction() {                /** {@inheritDoc} */                public double value(double x) {                    return Math.exp(x) - Math.pow(Math.PI, 3.0);                }            };        final UnivariateRealSolver solver = new RegulaFalsiSolver();        final double root = solver.solve(3624, f, 1, 10);        Assert.assertEquals(3.4341896575482003, root, 1e-15);}}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * @version $Id$ */public class UnivariateRealSolverUtilsTest {    protected UnivariateRealFunction sin = new SinFunction();    @Test    public void testSolveNull() {        try {            UnivariateRealSolverUtils.solve(null, 0.0, 4.0);            Assert.fail();        } catch(MathIllegalArgumentException ex){            // success        }    }    @Test    public void testSolveBadEndpoints() {        try { // bad endpoints            double root = UnivariateRealSolverUtils.solve(sin, 4.0, -0.1, 1e-6);            System.out.println("root=" + root);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testSolveBadAccuracy() {        try { // bad accuracy            UnivariateRealSolverUtils.solve(sin, 0.0, 4.0, 0.0);//             Assert.fail("Expecting MathIllegalArgumentException"); // TODO needs rework since convergence behaviour was changed        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testSolveSin() {        double x = UnivariateRealSolverUtils.solve(sin, 1.0, 4.0);        Assert.assertEquals(FastMath.PI, x, 1.0e-4);    }    @Test    public void testSolveAccuracyNull()  {        try {            double accuracy = 1.0e-6;            UnivariateRealSolverUtils.solve(null, 0.0, 4.0, accuracy);            Assert.fail();        } catch(MathIllegalArgumentException ex){            // success        }    }    @Test    public void testSolveAccuracySin() {        double accuracy = 1.0e-6;        double x = UnivariateRealSolverUtils.solve(sin, 1.0,                4.0, accuracy);        Assert.assertEquals(FastMath.PI, x, accuracy);    }    @Test    public void testSolveNoRoot() {        try {            UnivariateRealSolverUtils.solve(sin, 1.0, 1.5);            Assert.fail("Expecting MathIllegalArgumentException ");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testBracketSin() {        double[] result = UnivariateRealSolverUtils.bracket(sin,                0.0, -2.0, 2.0);        Assert.assertTrue(sin.value(result[0]) < 0);        Assert.assertTrue(sin.value(result[1]) > 0);    }    @Test    public void testBracketEndpointRoot() {        double[] result = UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0);        Assert.assertEquals(0.0, sin.value(result[0]), 1.0e-15);        Assert.assertTrue(sin.value(result[1]) > 0);    }    @Test    public void testNullFunction() {        try { // null function            UnivariateRealSolverUtils.bracket(null, 1.5, 0, 2.0);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }    }        @Test    public void testBadInitial() {        try { // initial not between endpoints            UnivariateRealSolverUtils.bracket(sin, 2.5, 0, 2.0);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }    }        @Test    public void testBadEndpoints() {        try { // endpoints not valid            UnivariateRealSolverUtils.bracket(sin, 1.5, 2.0, 1.0);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }    }        @Test    public void testBadMaximumIterations() {        try { // bad maximum iterations            UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0, 0);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testMisc() {        UnivariateRealFunction f = new QuinticFunction();        double result;        // Static solve method        result = UnivariateRealSolverUtils.solve(f, -0.2, 0.2);        Assert.assertEquals(result, 0, 1E-8);        result = UnivariateRealSolverUtils.solve(f, -0.1, 0.3);        Assert.assertEquals(result, 0, 1E-8);        result = UnivariateRealSolverUtils.solve(f, -0.3, 0.45);        Assert.assertEquals(result, 0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.3, 0.7);        Assert.assertEquals(result, 0.5, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.2, 0.6);        Assert.assertEquals(result, 0.5, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.05, 0.95);        Assert.assertEquals(result, 0.5, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.25);        Assert.assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.8, 1.2);        Assert.assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.75);        Assert.assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.55, 1.45);        Assert.assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.85, 5);        Assert.assertEquals(result, 1.0, 1E-6);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;/** * Test case for {@link SecantSolver Secant} solver. * * @version $Id$ */public final class SecantSolverTest extends BaseSecantSolverAbstractTest {    /** {@inheritDoc} */    protected UnivariateRealSolver getSolver() {        return new SecantSolver();    }    /** {@inheritDoc} */    protected int[] getQuinticEvalCounts() {        // As the Secant method does not maintain a bracketed solution,        // convergence is not guaranteed. Two test cases are disabled (-1) due        // to bad solutions.        return new int[] {3, 7, -1, 8, 9, 8, 11, 12, 14, -1, 16};    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;/** * Test case for {@link IllinoisSolver Illinois} solver. * * @version $Id$ */public final class IllinoisSolverTest extends BaseSecantSolverAbstractTest {    /** {@inheritDoc} */    protected UnivariateRealSolver getSolver() {        return new IllinoisSolver();    }    /** {@inheritDoc} */    protected int[] getQuinticEvalCounts() {        return new int[] {3, 7, 9, 10, 10, 10, 12, 12, 14, 15, 20};    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.analysis.polynomials.PolynomialFunction;import org.apache.commons.math.exception.NumberIsTooLargeException;import org.apache.commons.math.exception.NoBracketingException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test case for Laguerre solver. * <p> * Laguerre's method is very efficient in solving polynomials. Test runs * show that for a default absolute accuracy of 1E-6, it generally takes * less than 5 iterations to find one root, provided solveAll() is not * invoked, and 15 to 20 iterations to find all roots for quintic function. * * @version $Id$ */public final class LaguerreSolverTest {    /**     * Test of solver for the linear function.     */    @Test    public void testLinearFunction() {        double min, max, expected, result, tolerance;        // p(x) = 4x - 1        double coefficients[] = { -1.0, 4.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        LaguerreSolver solver = new LaguerreSolver();        min = 0.0; max = 1.0; expected = 0.25;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quadratic function.     */    @Test    public void testQuadraticFunction() {        double min, max, expected, result, tolerance;        // p(x) = 2x^2 + 5x - 3 = (x+3)(2x-1)        double coefficients[] = { -3.0, 5.0, 2.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        LaguerreSolver solver = new LaguerreSolver();        min = 0.0; max = 2.0; expected = 0.5;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = -4.0; max = -1.0; expected = -3.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function.     */    @Test    public void testQuinticFunction() {        double min, max, expected, result, tolerance;        // p(x) = x^5 - x^4 - 12x^3 + x^2 - x - 12 = (x+1)(x+3)(x-4)(x^2-x+1)        double coefficients[] = { -12.0, -1.0, 1.0, -12.0, -1.0, 1.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        LaguerreSolver solver = new LaguerreSolver();        min = -2.0; max = 2.0; expected = -1.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = -5.0; max = -2.5; expected = -3.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = 3.0; max = 6.0; expected = 4.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function using solveAll().     * XXX commented out because "solveAll" is not part of the API.     */    // public void testQuinticFunction2() {    //     double initial = 0.0, tolerance;    //     Complex expected, result[];    //     // p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4)    //     double coefficients[] = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 };    //     LaguerreSolver solver = new LaguerreSolver();    //     result = solver.solveAll(coefficients, initial);    //     expected = new Complex(0.0, -2.0);    //     tolerance = FastMath.max(solver.getAbsoluteAccuracy(),    //                 FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));    //     TestUtils.assertContains(result, expected, tolerance);    //     expected = new Complex(0.0, 2.0);    //     tolerance = FastMath.max(solver.getAbsoluteAccuracy(),    //                 FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));    //     TestUtils.assertContains(result, expected, tolerance);    //     expected = new Complex(0.5, 0.5 * FastMath.sqrt(3.0));    //     tolerance = FastMath.max(solver.getAbsoluteAccuracy(),    //                 FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));    //     TestUtils.assertContains(result, expected, tolerance);    //     expected = new Complex(-1.0, 0.0);    //     tolerance = FastMath.max(solver.getAbsoluteAccuracy(),    //                 FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));    //     TestUtils.assertContains(result, expected, tolerance);    //     expected = new Complex(0.5, -0.5 * FastMath.sqrt(3.0));    //     tolerance = FastMath.max(solver.getAbsoluteAccuracy(),    //                 FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));    //     TestUtils.assertContains(result, expected, tolerance);    // }    /**     * Test of parameters for the solver.     */    @Test    public void testParameters() {        double coefficients[] = { -3.0, 5.0, 2.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        LaguerreSolver solver = new LaguerreSolver();        try {            // bad interval            solver.solve(100, f, 1, -1);            Assert.fail("Expecting NumberIsTooLargeException - bad interval");        } catch (NumberIsTooLargeException ex) {            // expected        }        try {            // no bracketing            solver.solve(100, f, 2, 3);            Assert.fail("Expecting NoBracketingException - no bracketing");        } catch (NoBracketingException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.analysis.MonitoredFunction;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.NumberIsTooLargeException;import org.apache.commons.math.exception.NoBracketingException;import org.apache.commons.math.exception.TooManyEvaluationsException;import org.junit.Assert;import org.junit.Test;/** * Test case for {@link BrentSolver Brent} solver. * Because Brent-Dekker is guaranteed to converge in less than the default * maximum iteration count due to bisection fallback, it is quite hard to * debug. I include measured iteration counts plus one in order to detect * regressions. On average Brent-Dekker should use 4..5 iterations for the * default absolute accuracy of 10E-8 for sinus and the quintic function around * zero, and 5..10 iterations for the other zeros. * * @version $Id$ */public final class BrentSolverTest {    @Test    public void testSinZero() {        // The sinus function is behaved well around the root at pi. The second        // order derivative is zero, which means linar approximating methods will        // still converge quadratically.        UnivariateRealFunction f = new SinFunction();        double result;        UnivariateRealSolver solver = new BrentSolver();        // Somewhat benign interval. The function is monotone.        result = solver.solve(100, f, 3, 4);        // System.out.println(        //    "Root: " + result + " Evaluations: " + solver.getEvaluations());        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        Assert.assertTrue(solver.getEvaluations() <= 7);        // Larger and somewhat less benign interval. The function is grows first.        result = solver.solve(100, f, 1, 4);        // System.out.println(        //    "Root: " + result + " Evaluations: " + solver.getEvaluations());        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        Assert.assertTrue(solver.getEvaluations() <= 8);    }    @Test    public void testQuinticZero() {        // The quintic function has zeros at 0, +-0.5 and +-1.        // Around the root of 0 the function is well behaved, with a second derivative        // of zero a 0.        // The other roots are less well to find, in particular the root at 1, because        // the function grows fast for x>1.        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,        // intervals containing these values are harder for the solvers.        UnivariateRealFunction f = new QuinticFunction();        double result;        // Brent-Dekker solver.        UnivariateRealSolver solver = new BrentSolver();        // Symmetric bracket around 0. Test whether solvers can handle hitting        // the root in the first iteration.        result = solver.solve(100, f, -0.2, 0.2);        //System.out.println(        //    "Root: " + result + " Evaluations: " + solver.getEvaluations());        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());        Assert.assertTrue(solver.getEvaluations() <= 3);        // 1 iterations on i586 JDK 1.4.1.        // Asymmetric bracket around 0, just for fun. Contains extremum.        result = solver.solve(100, f, -0.1, 0.3);        //System.out.println(        //    "Root: " + result + " Evaluations: " + solver.getEvaluations());        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        Assert.assertTrue(solver.getEvaluations() <= 7);        // Large bracket around 0. Contains two extrema.        result = solver.solve(100, f, -0.3, 0.45);        //System.out.println(        //    "Root: " + result + " Evaluations: " + solver.getEvaluations());        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        Assert.assertTrue(solver.getEvaluations() <= 8);        // Benign bracket around 0.5, function is monotonous.        result = solver.solve(100, f, 0.3, 0.7);        //System.out.println(        //    "Root: " + result + " Evaluations: " + solver.getEvaluations());        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        Assert.assertTrue(solver.getEvaluations() <= 9);        // Less benign bracket around 0.5, contains one extremum.        result = solver.solve(100, f, 0.2, 0.6);        // System.out.println(        //    "Root: " + result + " Evaluations: " + solver.getEvaluations());        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        Assert.assertTrue(solver.getEvaluations() <= 10);        // Large, less benign bracket around 0.5, contains both extrema.        result = solver.solve(100, f, 0.05, 0.95);        //System.out.println(        //    "Root: " + result + " Evaluations: " + solver.getEvaluations());        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        Assert.assertTrue(solver.getEvaluations() <= 11);        // Relatively benign bracket around 1, function is monotonous. Fast growth for x>1        // is still a problem.        result = solver.solve(100, f, 0.85, 1.25);        //System.out.println(        //    "Root: " + result + " Evaluations: " + solver.getEvaluations());        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        Assert.assertTrue(solver.getEvaluations() <= 11);        // Less benign bracket around 1 with extremum.        result = solver.solve(100, f, 0.8, 1.2);        //System.out.println(        //    "Root: " + result + " Evaluations: " + solver.getEvaluations());        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        Assert.assertTrue(solver.getEvaluations() <= 11);        // Large bracket around 1. Monotonous.        result = solver.solve(100, f, 0.85, 1.75);        //System.out.println(        //    "Root: " + result + " Evaluations: " + solver.getEvaluations());        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        Assert.assertTrue(solver.getEvaluations() <= 13);        // Large bracket around 1. Interval contains extremum.        result = solver.solve(100, f, 0.55, 1.45);        //System.out.println(        //    "Root: " + result + " Evaluations: " + solver.getEvaluations());        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        Assert.assertTrue(solver.getEvaluations() <= 10);        // Very large bracket around 1 for testing fast growth behaviour.        result = solver.solve(100, f, 0.85, 5);        //System.out.println(       //     "Root: " + result + " Evaluations: " + solver.getEvaluations());        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        Assert.assertTrue(solver.getEvaluations() <= 15);        try {            result = solver.solve(5, f, 0.85, 5);            Assert.fail("Expected TooManyEvaluationsException");        } catch (TooManyEvaluationsException e) {            // Expected.        }    }    @Test    public void testRootEndpoints() {        UnivariateRealFunction f = new SinFunction();        BrentSolver solver = new BrentSolver();        // endpoint is root        double result = solver.solve(100, f, FastMath.PI, 4);        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 3, FastMath.PI);        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, FastMath.PI, 4, 3.5);        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 3, FastMath.PI, 3.07);        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());    }    @Test    public void testBadEndpoints() {        UnivariateRealFunction f = new SinFunction();        BrentSolver solver = new BrentSolver();        try {  // bad interval            solver.solve(100, f, 1, -1);            Assert.fail("Expecting NumberIsTooLargeException - bad interval");        } catch (NumberIsTooLargeException ex) {            // expected        }        try {  // no bracket            solver.solve(100, f, 1, 1.5);            Assert.fail("Expecting NoBracketingException - non-bracketing");        } catch (NoBracketingException ex) {            // expected        }        try {  // no bracket            solver.solve(100, f, 1, 1.5, 1.2);            Assert.fail("Expecting NoBracketingException - non-bracketing");        } catch (NoBracketingException ex) {            // expected        }    }    @Test    public void testInitialGuess() {        MonitoredFunction f = new MonitoredFunction(new QuinticFunction());        BrentSolver solver = new BrentSolver();        double result;        // no guess        result = solver.solve(100, f, 0.6, 7.0);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        int referenceCallsCount = f.getCallsCount();        Assert.assertTrue(referenceCallsCount >= 13);        // invalid guess (it *is* a root, but outside of the range)        try {          result = solver.solve(100, f, 0.6, 7.0, 0.0);          Assert.fail("a NumberIsTooLargeException was expected");        } catch (NumberIsTooLargeException iae) {            // expected behaviour        }        // bad guess        f.setCallsCount(0);        result = solver.solve(100, f, 0.6, 7.0, 0.61);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        Assert.assertTrue(f.getCallsCount() > referenceCallsCount);        // good guess        f.setCallsCount(0);        result = solver.solve(100, f, 0.6, 7.0, 0.999999);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        Assert.assertTrue(f.getCallsCount() < referenceCallsCount);        // perfect guess        f.setCallsCount(0);        result = solver.solve(100, f, 0.6, 7.0, 1.0);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        Assert.assertEquals(1, solver.getEvaluations());        Assert.assertEquals(1, f.getCallsCount());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.analysis.Expm1Function;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.NoBracketingException;import org.apache.commons.math.exception.NumberIsTooLargeException;import org.junit.Assert;import org.junit.Test;/** * Test case for {@link RiddersSolver Ridders} solver. * <p> * Ridders' method converges superlinearly, more specific, its rate of * convergence is sqrt(2). Test runs show that for a default absolute * accuracy of 1E-6, it generally takes less than 5 iterations for close * initial bracket and 5 to 10 iterations for distant initial bracket * to converge. * * @version $Id$ */public final class RiddersSolverTest {    /**     * Test of solver for the sine function.     */    @Test    public void testSinFunction() {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new RiddersSolver();        double min, max, expected, result, tolerance;        min = 3.0; max = 4.0; expected = FastMath.PI;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = -1.0; max = 1.5; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function.     */    @Test    public void testQuinticFunction() {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new RiddersSolver();        double min, max, expected, result, tolerance;        min = -0.4; max = 0.2; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = 0.75; max = 1.5; expected = 1.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = -0.9; max = -0.2; expected = -0.5;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the exponential function.     */    @Test    public void testExpm1Function() {        UnivariateRealFunction f = new Expm1Function();        UnivariateRealSolver solver = new RiddersSolver();        double min, max, expected, result, tolerance;        min = -1.0; max = 2.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = -20.0; max = 10.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = -50.0; max = 100.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the solver.     */    @Test    public void testParameters() {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new RiddersSolver();        try {            // bad interval            solver.solve(100, f, 1, -1);            Assert.fail("Expecting NumberIsTooLargeException - bad interval");        } catch (NumberIsTooLargeException ex) {            // expected        }        try {            // no bracketing            solver.solve(100, f, 2, 3);            Assert.fail("Expecting NoBracketingException - no bracketing");        } catch (NoBracketingException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * @version $Id$ */public final class BisectionSolverTest {    @Test    public void testSinZero() {        UnivariateRealFunction f = new SinFunction();        double result;        BisectionSolver solver = new BisectionSolver();        result = solver.solve(100, f, 3, 4);        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 1, 4);        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());    }    @Test    public void testQuinticZero() {        UnivariateRealFunction f = new QuinticFunction();        double result;        BisectionSolver solver = new BisectionSolver();        result = solver.solve(100, f, -0.2, 0.2);        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, -0.1, 0.3);        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, -0.3, 0.45);        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 0.3, 0.7);        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 0.2, 0.6);        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 0.05, 0.95);        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 0.85, 1.25);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 0.8, 1.2);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 0.85, 1.75);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 0.55, 1.45);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 0.85, 5);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        Assert.assertTrue(solver.getEvaluations() > 0);    }    @Test    public void testMath369() {        UnivariateRealFunction f = new SinFunction();        BisectionSolver solver = new BisectionSolver();        Assert.assertEquals(FastMath.PI, solver.solve(100, f, 3.0, 3.2, 3.1), solver.getAbsoluteAccuracy());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.analysis.Expm1Function;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.exception.NumberIsTooLargeException;import org.apache.commons.math.exception.NoBracketingException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test case for {@link MullerSolver2 Muller} solver. * <p> * Muller's method converges almost quadratically near roots, but it can * be very slow in regions far away from zeros. Test runs show that for * reasonably good initial values, for a default absolute accuracy of 1E-6, * it generally takes 5 to 10 iterations for the solver to converge. * <p> * Tests for the exponential function illustrate the situations where * Muller solver performs poorly. * * @version $Id$ */public final class MullerSolver2Test {    /**     * Test of solver for the sine function.     */    @Test    public void testSinFunction() {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new MullerSolver2();        double min, max, expected, result, tolerance;        min = 3.0; max = 4.0; expected = FastMath.PI;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = -1.0; max = 1.5; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function.     */    @Test    public void testQuinticFunction() {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new MullerSolver2();        double min, max, expected, result, tolerance;        min = -0.4; max = 0.2; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = 0.75; max = 1.5; expected = 1.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = -0.9; max = -0.2; expected = -0.5;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the exponential function.     * <p>     * It takes 25 to 50 iterations for the last two tests to converge.     */    @Test    public void testExpm1Function() {        UnivariateRealFunction f = new Expm1Function();        UnivariateRealSolver solver = new MullerSolver2();        double min, max, expected, result, tolerance;        min = -1.0; max = 2.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = -20.0; max = 10.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = -50.0; max = 100.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(100, f, min, max);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the solver.     */    @Test    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new MullerSolver2();        try {            // bad interval            solver.solve(100, f, 1, -1);            Assert.fail("Expecting NumberIsTooLargeException - bad interval");        } catch (NumberIsTooLargeException ex) {            // expected        }        try {            // no bracketing            solver.solve(100, f, 2, 3);            Assert.fail("Expecting NoBracketingException - no bracketing");        } catch (NoBracketingException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * @version $Id$ */public final class NewtonSolverTest {    /**     *     */    @Test    public void testSinZero() {        DifferentiableUnivariateRealFunction f = new SinFunction();        double result;        NewtonSolver solver = new NewtonSolver();        result = solver.solve(100, f, 3, 4);        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 1, 4);        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        Assert.assertTrue(solver.getEvaluations() > 0);    }    /**     *     */    @Test    public void testQuinticZero() {        DifferentiableUnivariateRealFunction f = new QuinticFunction();        double result;        NewtonSolver solver = new NewtonSolver();        result = solver.solve(100, f, -0.2, 0.2);        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, -0.1, 0.3);        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, -0.3, 0.45);        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 0.3, 0.7);        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 0.2, 0.6);        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 0.05, 0.95);        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 0.85, 1.25);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 0.8, 1.2);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 0.85, 1.75);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 0.55, 1.45);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(100, f, 0.85, 5);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.function;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.exception.NotStrictlyPositiveException;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test for class {@link Logistic}. */public class LogisticTest {    private final double EPS = Math.ulp(1d);    @Test(expected=NotStrictlyPositiveException.class)    public void testPreconditions1() {        new Logistic(1, 0, 1, 1, 0, -1);    }    @Test(expected=NotStrictlyPositiveException.class)    public void testPreconditions2() {        new Logistic(1, 0, 1, 1, 0, 0);    }    @Test    public void testCompareSigmoid() {        final UnivariateRealFunction sig = new Sigmoid();        final UnivariateRealFunction sigL = new Logistic(1, 0, 1, 1, 0, 1);        final double min = -2;        final double max = 2;        final int n = 100;        final double delta = (max - min) / n;        for (int i = 0; i < n; i++) {            final double x = min + i * delta;            Assert.assertEquals("x=" + x, sig.value(x), sigL.value(x), EPS);        }    }    @Test    public void testSomeValues() {        final double k = 4;        final double m = 5;        final double b = 2;        final double q = 3;        final double a = -1;        final double n = 2;        final UnivariateRealFunction f = new Logistic(k, m, b, q, a, n);        double x;        x = m;        Assert.assertEquals("x=" + x, a + (k - a) / FastMath.sqrt(1 + q), f.value(x), EPS);        x = Double.NEGATIVE_INFINITY;        Assert.assertEquals("x=" + x, a, f.value(x), EPS);        x = Double.POSITIVE_INFINITY;        Assert.assertEquals("x=" + x, k, f.value(x), EPS);    }    @Test    public void testCompareDerivativeSigmoid() {        final double k = 3;        final double a = 2;        final Logistic f = new Logistic(k, 0, 1, 1, a, 1);        final Sigmoid g = new Sigmoid(a, k);                final UnivariateRealFunction dfdx = f.derivative();        final UnivariateRealFunction dgdx = g.derivative();        final double min = -10;        final double max = 10;        final double n = 20;        final double delta = (max - min) / n;        for (int i = 0; i < n; i++) {            final double x = min + i * delta;            Assert.assertEquals("x=" + x, dgdx.value(x), dfdx.value(x), EPS);        }    }    @Test(expected=NullArgumentException.class)    public void testParametricUsage1() {        final Logistic.Parametric g = new Logistic.Parametric();        g.value(0, null);    }    @Test(expected=DimensionMismatchException.class)    public void testParametricUsage2() {        final Logistic.Parametric g = new Logistic.Parametric();        g.value(0, new double[] {0});    }    @Test(expected=NullArgumentException.class)    public void testParametricUsage3() {        final Logistic.Parametric g = new Logistic.Parametric();        g.gradient(0, null);    }    @Test(expected=DimensionMismatchException.class)    public void testParametricUsage4() {        final Logistic.Parametric g = new Logistic.Parametric();        g.gradient(0, new double[] {0});    }    @Test(expected=NotStrictlyPositiveException.class)    public void testParametricUsage5() {        final Logistic.Parametric g = new Logistic.Parametric();        g.value(0, new double[] {1, 0, 1, 1, 0 ,0});    }    @Test(expected=NotStrictlyPositiveException.class)    public void testParametricUsage6() {        final Logistic.Parametric g = new Logistic.Parametric();        g.gradient(0, new double[] {1, 0, 1, 1, 0 ,0});    }    @Test    public void testGradientComponent0Component4() {        final double k = 3;        final double a = 2;        final Logistic.Parametric f = new Logistic.Parametric();        // Compare using the "Sigmoid" function.        final Sigmoid.Parametric g = new Sigmoid.Parametric();                final double x = 0.12345;        final double[] gf = f.gradient(x, new double[] {k, 0, 1, 1, a, 1});        final double[] gg = g.gradient(x, new double[] {a, k});        Assert.assertEquals(gg[0], gf[4], EPS);        Assert.assertEquals(gg[1], gf[0], EPS);    }    @Test    public void testGradientComponent5() {        final double m = 1.2;        final double k = 3.4;        final double a = 2.3;        final double q = 0.567;        final double b = -FastMath.log(q);        final double n = 3.4;        final Logistic.Parametric f = new Logistic.Parametric();                final double x = m - 1;        final double qExp1 = 2;        final double[] gf = f.gradient(x, new double[] {k, m, b, q, a, n});        Assert.assertEquals((k - a) * FastMath.log(qExp1) / (n * n * FastMath.pow(qExp1, 1 / n)),                            gf[5], EPS);    }    @Test    public void testGradientComponent1Component2Component3() {        final double m = 1.2;        final double k = 3.4;        final double a = 2.3;        final double b = 0.567;        final double q = 1 / FastMath.exp(b * m);        final double n = 3.4;        final Logistic.Parametric f = new Logistic.Parametric();                final double x = 0;        final double qExp1 = 2;        final double[] gf = f.gradient(x, new double[] {k, m, b, q, a, n});        final double factor = (a - k) / (n * FastMath.pow(qExp1, 1 / n + 1));        Assert.assertEquals(factor * b, gf[1], EPS);        Assert.assertEquals(factor * m, gf[2], EPS);        Assert.assertEquals(factor / q, gf[3], EPS);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.function;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.NonMonotonousSequenceException;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.exception.NoDataException;import org.junit.Assert;import org.junit.Test;/** * Test for class {@link StepFunction}. */public class StepFunctionTest {    private final double EPS = Math.ulp(1d);    @Test(expected=NullArgumentException.class)    public void testPreconditions1() {        new StepFunction(null, new double[] {0, -1, -2});    }    @Test(expected=NullArgumentException.class)    public void testPreconditions2() {        new StepFunction(new double[] {0, 1}, null);    }    @Test(expected=NoDataException.class)    public void testPreconditions3() {        new StepFunction(new double[] {0}, new double[] {});    }    @Test(expected=NoDataException.class)    public void testPreconditions4() {        new StepFunction(new double[] {}, new double[] {0});    }    @Test(expected=DimensionMismatchException.class)    public void testPreconditions5() {        new StepFunction(new double[] {0, 1}, new double[] {0, -1, -2});    }    @Test(expected=NonMonotonousSequenceException.class)    public void testPreconditions6() {        new StepFunction(new double[] {1, 0, 1}, new double[] {0, -1, -2});    }    @Test    public void testSomeValues() {        final double[] x = { -2, -0.5, 0, 1.9, 7.4, 21.3 };        final double[] y = { 4, -1, -5.5, 0.4, 5.8, 51.2 };        final UnivariateRealFunction f = new StepFunction(x, y);        Assert.assertEquals(4, f.value(Double.NEGATIVE_INFINITY), EPS);        Assert.assertEquals(4, f.value(-10), EPS);        Assert.assertEquals(-1, f.value(-0.4), EPS);        Assert.assertEquals(-5.5, f.value(0), EPS);        Assert.assertEquals(0.4, f.value(2), EPS);        Assert.assertEquals(5.8, f.value(10), EPS);        Assert.assertEquals(51.2, f.value(30), EPS);        Assert.assertEquals(51.2, f.value(Double.POSITIVE_INFINITY), EPS);    }    @Test    public void testHeaviside() {           final UnivariateRealFunction h = new StepFunction(new double[] {-1, 0},                                                          new double[] {0, 1});        Assert.assertEquals(0, h.value(Double.NEGATIVE_INFINITY), 0);        Assert.assertEquals(0, h.value(-Double.MAX_VALUE), 0);        Assert.assertEquals(0, h.value(-2), 0);        Assert.assertEquals(0, h.value(-Double.MIN_VALUE), 0);        Assert.assertEquals(1, h.value(0), 0);        Assert.assertEquals(1, h.value(2), 0);        Assert.assertEquals(1, h.value(Double.POSITIVE_INFINITY), 0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.function;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.exception.NotStrictlyPositiveException;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test for class {@link Gaussian}. */public class GaussianTest {    private final double EPS = Math.ulp(1d);    @Test(expected=NotStrictlyPositiveException.class)    public void testPreconditions() {        new Gaussian(1, 2, -1);    }    @Test    public void testSomeValues() {        final UnivariateRealFunction f = new Gaussian();        Assert.assertEquals(1 / FastMath.sqrt(2 * Math.PI), f.value(0), EPS);    }    @Test    public void testLargeArguments() {        final UnivariateRealFunction f = new Gaussian();        Assert.assertEquals(0, f.value(Double.NEGATIVE_INFINITY), 0);        Assert.assertEquals(0, f.value(-Double.MAX_VALUE), 0);        Assert.assertEquals(0, f.value(-1e2), 0);        Assert.assertEquals(0, f.value(1e2), 0);        Assert.assertEquals(0, f.value(Double.MAX_VALUE), 0);        Assert.assertEquals(0, f.value(Double.POSITIVE_INFINITY), 0);    }    @Test    public void testDerivative() {        final Gaussian f = new Gaussian();        final UnivariateRealFunction dfdx = f.derivative();        Assert.assertEquals(0, dfdx.value(0), 0);    }    @Test    public void testDerivativeLargeArguments() {        final Gaussian f = new Gaussian(0, 1e-50);        final UnivariateRealFunction dfdx = f.derivative();        Assert.assertEquals(0, dfdx.value(Double.NEGATIVE_INFINITY), 0);        Assert.assertEquals(0, dfdx.value(-Double.MAX_VALUE), 0);        Assert.assertEquals(0, dfdx.value(-1e50), 0);        Assert.assertEquals(0, dfdx.value(-1e2), 0);        Assert.assertEquals(0, dfdx.value(1e2), 0);        Assert.assertEquals(0, dfdx.value(1e50), 0);        Assert.assertEquals(0, dfdx.value(Double.MAX_VALUE), 0);        Assert.assertEquals(0, dfdx.value(Double.POSITIVE_INFINITY), 0);            }    @Test    public void testDerivativeNaN() {        final Gaussian f = new Gaussian(0, 1e-50);        final UnivariateRealFunction dfdx = f.derivative();        Assert.assertTrue(Double.isNaN(dfdx.value(Double.NaN)));    }    @Test(expected=NullArgumentException.class)    public void testParametricUsage1() {        final Gaussian.Parametric g = new Gaussian.Parametric();        g.value(0, null);    }    @Test(expected=DimensionMismatchException.class)    public void testParametricUsage2() {        final Gaussian.Parametric g = new Gaussian.Parametric();        g.value(0, new double[] {0});    }    @Test(expected=NotStrictlyPositiveException.class)    public void testParametricUsage3() {        final Gaussian.Parametric g = new Gaussian.Parametric();        g.value(0, new double[] {0, 1, 0});    }    @Test(expected=NullArgumentException.class)    public void testParametricUsage4() {        final Gaussian.Parametric g = new Gaussian.Parametric();        g.gradient(0, null);    }    @Test(expected=DimensionMismatchException.class)    public void testParametricUsage5() {        final Gaussian.Parametric g = new Gaussian.Parametric();        g.gradient(0, new double[] {0});    }    @Test(expected=NotStrictlyPositiveException.class)    public void testParametricUsage6() {        final Gaussian.Parametric g = new Gaussian.Parametric();        g.gradient(0, new double[] {0, 1, 0});    }    @Test    public void testParametricValue() {        final double norm = 2;        final double mean = 3;        final double sigma = 4;        final Gaussian f = new Gaussian(norm, mean, sigma);        final Gaussian.Parametric g = new Gaussian.Parametric();        Assert.assertEquals(f.value(-1), g.value(-1, new double[] {norm, mean, sigma}), 0);        Assert.assertEquals(f.value(0), g.value(0, new double[] {norm, mean, sigma}), 0);        Assert.assertEquals(f.value(2), g.value(2, new double[] {norm, mean, sigma}), 0);    }    @Test    public void testParametricGradient() {        final double norm = 2;        final double mean = 3;        final double sigma = 4;        final Gaussian.Parametric f = new Gaussian.Parametric();        final double x = 1;        final double[] grad = f.gradient(1, new double[] {norm, mean, sigma});        final double diff = x - mean;        final double n = FastMath.exp(-diff * diff / (2 * sigma * sigma));        Assert.assertEquals(n, grad[0], EPS);        final double m = norm * n * diff / (sigma * sigma);        Assert.assertEquals(m, grad[1], EPS);        final double s = m * diff / sigma;        Assert.assertEquals(s, grad[2], EPS);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.function;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.exception.DimensionMismatchException;import org.junit.Assert;import org.junit.Test;/** * Test for class {@link Sigmoid}. */public class SigmoidTest {    private final double EPS = Math.ulp(1d);    @Test    public void testSomeValues() {        final UnivariateRealFunction f = new Sigmoid();        Assert.assertEquals(0.5, f.value(0), EPS);        Assert.assertEquals(0, f.value(Double.NEGATIVE_INFINITY), EPS);        Assert.assertEquals(1, f.value(Double.POSITIVE_INFINITY), EPS);    }    @Test    public void testDerivative() {        final Sigmoid f = new Sigmoid();        final UnivariateRealFunction dfdx = f.derivative();        Assert.assertEquals(0.25, dfdx.value(0), 0);    }    @Test    public void testDerivativeLargeArguments() {        final Sigmoid f = new Sigmoid(1, 2);        final UnivariateRealFunction dfdx = f.derivative();        Assert.assertEquals(0, dfdx.value(Double.NEGATIVE_INFINITY), 0);        Assert.assertEquals(0, dfdx.value(-Double.MAX_VALUE), 0);        Assert.assertEquals(0, dfdx.value(-1e50), 0);        Assert.assertEquals(0, dfdx.value(-1e3), 0);        Assert.assertEquals(0, dfdx.value(1e3), 0);        Assert.assertEquals(0, dfdx.value(1e50), 0);        Assert.assertEquals(0, dfdx.value(Double.MAX_VALUE), 0);        Assert.assertEquals(0, dfdx.value(Double.POSITIVE_INFINITY), 0);            }    @Test(expected=NullArgumentException.class)    public void testParametricUsage1() {        final Sigmoid.Parametric g = new Sigmoid.Parametric();        g.value(0, null);    }    @Test(expected=DimensionMismatchException.class)    public void testParametricUsage2() {        final Sigmoid.Parametric g = new Sigmoid.Parametric();        g.value(0, new double[] {0});    }    @Test(expected=NullArgumentException.class)    public void testParametricUsage3() {        final Sigmoid.Parametric g = new Sigmoid.Parametric();        g.gradient(0, null);    }    @Test(expected=DimensionMismatchException.class)    public void testParametricUsage4() {        final Sigmoid.Parametric g = new Sigmoid.Parametric();        g.gradient(0, new double[] {0});    }    @Test    public void testParametricValue() {        final double lo = 2;        final double hi = 3;        final Sigmoid f = new Sigmoid(lo, hi);        final Sigmoid.Parametric g = new Sigmoid.Parametric();        Assert.assertEquals(f.value(-1), g.value(-1, new double[] {lo, hi}), 0);        Assert.assertEquals(f.value(0), g.value(0, new double[] {lo, hi}), 0);        Assert.assertEquals(f.value(2), g.value(2, new double[] {lo, hi}), 0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.function;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.analysis.FunctionUtils;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.OutOfRangeException;import org.junit.Assert;import org.junit.Test;/** * Test for class {@link Logit}. */public class LogitTest {    private final double EPS = Math.ulp(1d);    @Test(expected=OutOfRangeException.class)    public void testPreconditions1() {        final double lo = -1;        final double hi = 2;        final UnivariateRealFunction f = new Logit(lo, hi);        f.value(lo - 1);    }    @Test(expected=OutOfRangeException.class)    public void testPreconditions2() {        final double lo = -1;        final double hi = 2;        final UnivariateRealFunction f = new Logit(lo, hi);        f.value(hi + 1);    }    @Test    public void testSomeValues() {        final double lo = 1;        final double hi = 2;        final UnivariateRealFunction f = new Logit(lo, hi);        Assert.assertEquals(Double.NEGATIVE_INFINITY, f.value(1), EPS);        Assert.assertEquals(Double.POSITIVE_INFINITY, f.value(2), EPS);        Assert.assertEquals(0, f.value(1.5), EPS);    }    @Test    public void testDerivative() {        final double lo = 1;        final double hi = 2;        final Logit f = new Logit(lo, hi);        final UnivariateRealFunction dfdx = f.derivative();        Assert.assertEquals(4, dfdx.value(1.5), EPS);    }    @Test    public void testDerivativeLargeArguments() {        final Logit f = new Logit(1, 2);        final UnivariateRealFunction dfdx = f.derivative();        Assert.assertEquals(0, dfdx.value(Double.NEGATIVE_INFINITY), 0);        Assert.assertEquals(0, dfdx.value(-Double.MAX_VALUE), 0);        Assert.assertEquals(0, dfdx.value(-1e155), 0);        Assert.assertEquals(0, dfdx.value(1e155), 0);        Assert.assertEquals(0, dfdx.value(Double.MAX_VALUE), 0);        Assert.assertEquals(0, dfdx.value(Double.POSITIVE_INFINITY), 0);            }    @Test(expected=NullArgumentException.class)    public void testParametricUsage1() {        final Logit.Parametric g = new Logit.Parametric();        g.value(0, null);    }    @Test(expected=DimensionMismatchException.class)    public void testParametricUsage2() {        final Logit.Parametric g = new Logit.Parametric();        g.value(0, new double[] {0});    }    @Test(expected=NullArgumentException.class)    public void testParametricUsage3() {        final Logit.Parametric g = new Logit.Parametric();        g.gradient(0, null);    }    @Test(expected=DimensionMismatchException.class)    public void testParametricUsage4() {        final Logit.Parametric g = new Logit.Parametric();        g.gradient(0, new double[] {0});    }    @Test(expected=OutOfRangeException.class)    public void testParametricUsage5() {        final Logit.Parametric g = new Logit.Parametric();        g.value(-1, new double[] {0, 1});    }    @Test(expected=OutOfRangeException.class)    public void testParametricUsage6() {        final Logit.Parametric g = new Logit.Parametric();        g.value(2, new double[] {0, 1});    }    @Test    public void testParametricValue() {        final double lo = 2;        final double hi = 3;        final Logit f = new Logit(lo, hi);        final Logit.Parametric g = new Logit.Parametric();        Assert.assertEquals(f.value(2), g.value(2, new double[] {lo, hi}), 0);        Assert.assertEquals(f.value(2.34567), g.value(2.34567, new double[] {lo, hi}), 0);        Assert.assertEquals(f.value(3), g.value(3, new double[] {lo, hi}), 0);    }    @Test    public void testValueWithInverseFunction() {        final double lo = 2;        final double hi = 3;        final Logit f = new Logit(lo, hi);        final Sigmoid g = new Sigmoid(lo, hi);        final UnivariateRealFunction id = FunctionUtils.compose(g, f);                for (int i = 0; i < 10; i++) {            final double x = lo + Math.random() * (hi - lo);            Assert.assertEquals(x, id.value(x), EPS);        }        Assert.assertEquals(lo, id.value(lo), EPS);        Assert.assertEquals(hi, id.value(hi), EPS);    }    @Test    public void testDerivativeWithInverseFunction() {        final double lo = 2;        final double hi = 3;        final Logit f = new Logit(lo, hi);        final UnivariateRealFunction dfdx = f.derivative();        final Sigmoid g = new Sigmoid(lo, hi);        final UnivariateRealFunction dgdx = g.derivative();        final UnivariateRealFunction chain            = FunctionUtils.compose(new Inverse(), FunctionUtils.compose(dgdx, f));                for (int i = 0; i < 10; i++) {            final double x = lo + Math.random() * (hi - lo);            final double r = dfdx.value(x);            Assert.assertEquals(r, chain.value(x), r * 1e-15);        }        Assert.assertEquals(dfdx.value(lo), chain.value(lo), 0); // -inf        Assert.assertEquals(dfdx.value(hi), chain.value(hi), 0); // +inf    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.function;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test for class {@link HarmonicOscillator}. */public class HarmonicOscillatorTest {    private final double EPS = Math.ulp(1d);    @Test    public void testSomeValues() {        final double a = -1.2;        final double w = 0.34;        final double p = 5.6;        final UnivariateRealFunction f = new HarmonicOscillator(a, w, p);        final double d = 0.12345;        for (int i = 0; i < 10; i++) {            final double v = i * d;            Assert.assertEquals(a * FastMath.cos(w * v + p), f.value(v), 0);        }    }    @Test    public void testDerivative() {        final double a = -1.2;        final double w = 0.34;        final double p = 5.6;        final HarmonicOscillator f = new HarmonicOscillator(a, w, p);        final UnivariateRealFunction dfdx = f.derivative();        final double d = 0.12345;        for (int i = 0; i < 10; i++) {            final double v = i * d;            Assert.assertEquals(-a * w * FastMath.sin(w * v + p), dfdx.value(v), 0);        }    }    @Test(expected=NullArgumentException.class)    public void testParametricUsage1() {        final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric();        g.value(0, null);    }    @Test(expected=DimensionMismatchException.class)    public void testParametricUsage2() {        final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric();        g.value(0, new double[] {0});    }    @Test(expected=NullArgumentException.class)    public void testParametricUsage3() {        final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric();        g.gradient(0, null);    }    @Test(expected=DimensionMismatchException.class)    public void testParametricUsage4() {        final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric();        g.gradient(0, new double[] {0});    }    @Test    public void testParametricValue() {        final double amplitude = 2;        final double omega = 3;        final double phase = 4;        final HarmonicOscillator f = new HarmonicOscillator(amplitude, omega, phase);        final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric();        Assert.assertEquals(f.value(-1), g.value(-1, new double[] {amplitude, omega, phase}), 0);        Assert.assertEquals(f.value(0), g.value(0, new double[] {amplitude, omega, phase}), 0);        Assert.assertEquals(f.value(2), g.value(2, new double[] {amplitude, omega, phase}), 0);    }    @Test    public void testParametricGradient() {        final double amplitude = 2;        final double omega = 3;        final double phase = 4;        final HarmonicOscillator.Parametric f = new HarmonicOscillator.Parametric();        final double x = 1;        final double[] grad = f.gradient(1, new double[] {amplitude, omega, phase});        final double xTimesOmegaPlusPhase = omega * x + phase;        final double a = FastMath.cos(xTimesOmegaPlusPhase);        Assert.assertEquals(a, grad[0], EPS);        final double w = -amplitude * x * FastMath.sin(xTimesOmegaPlusPhase);        Assert.assertEquals(w, grad[1], EPS);        final double p = -amplitude * FastMath.sin(xTimesOmegaPlusPhase);        Assert.assertEquals(p, grad[2], EPS);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.integration;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.exception.NumberIsTooLargeException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test case for Romberg integrator. * <p> * Romberg algorithm is very fast for good behavior integrand. Test runs * show that for a default relative accuracy of 1E-6, it generally takes * takes less than 5 iterations for the integral to converge. * * @version $Id$ */public final class RombergIntegratorTest {    /**     * Test of integrator for the sine function.     */    @Test    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new RombergIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = FastMath.PI; expected = 2;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(100, f, min, max);        Assert.assertTrue(integrator.getEvaluations() < 50);        Assert.assertTrue(integrator.getIterations()  < 10);        Assert.assertEquals(expected, result, tolerance);        min = -FastMath.PI/3; max = 0; expected = -0.5;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(100, f, min, max);        Assert.assertTrue(integrator.getEvaluations() < 50);        Assert.assertTrue(integrator.getIterations()  < 10);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of integrator for the quintic function.     */    @Test    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealIntegrator integrator = new RombergIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = 1; expected = -1.0/48;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(100, f, min, max);        Assert.assertTrue(integrator.getEvaluations() < 10);        Assert.assertTrue(integrator.getIterations()  < 5);        Assert.assertEquals(expected, result, tolerance);        min = 0; max = 0.5; expected = 11.0/768;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(100, f, min, max);        Assert.assertTrue(integrator.getEvaluations() < 10);        Assert.assertTrue(integrator.getIterations()  < 5);        Assert.assertEquals(expected, result, tolerance);        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(100, f, min, max);        Assert.assertTrue(integrator.getEvaluations() < 10);        Assert.assertTrue(integrator.getIterations()  < 5);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the integrator.     */    @Test    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        try {            // bad interval            new RombergIntegrator().integrate(1000, f, 1, -1);            Assert.fail("Expecting NumberIsTooLargeException - bad interval");        } catch (NumberIsTooLargeException ex) {            // expected        }        try {            // bad iteration limits            new RombergIntegrator(5, 4);            Assert.fail("Expecting NumberIsTooSmallException - bad iteration limits");        } catch (NumberIsTooSmallException ex) {            // expected        }        try {            // bad iteration limits            new RombergIntegrator(10, 50);            Assert.fail("Expecting NumberIsTooLargeException - bad iteration limits");        } catch (NumberIsTooLargeException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.integration;import java.util.Random;import org.apache.commons.math.ConvergenceException;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.analysis.polynomials.PolynomialFunction;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.exception.TooManyEvaluationsException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class LegendreGaussIntegratorTest {    @Test    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegratorImpl integrator = new LegendreGaussIntegrator(5, 1.0e-14, 1.0e-10, 2, 15);        double min, max, expected, result, tolerance;        min = 0; max = FastMath.PI; expected = 2;        tolerance = FastMath.max(integrator.getAbsoluteAccuracy(),                             FastMath.abs(expected * integrator.getRelativeAccuracy()));        result = integrator.integrate(10000, f, min, max);        Assert.assertEquals(expected, result, tolerance);        min = -FastMath.PI/3; max = 0; expected = -0.5;        tolerance = FastMath.max(integrator.getAbsoluteAccuracy(),                FastMath.abs(expected * integrator.getRelativeAccuracy()));        result = integrator.integrate(10000, f, min, max);        Assert.assertEquals(expected, result, tolerance);    }    @Test    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealIntegrator integrator =                new LegendreGaussIntegrator(3,                                            UnivariateRealIntegratorImpl.DEFAULT_RELATIVE_ACCURACY,                                            UnivariateRealIntegratorImpl.DEFAULT_ABSOLUTE_ACCURACY,                                            UnivariateRealIntegratorImpl.DEFAULT_MIN_ITERATIONS_COUNT,                                            64);        double min, max, expected, result;        min = 0; max = 1; expected = -1.0/48;        result = integrator.integrate(10000, f, min, max);        Assert.assertEquals(expected, result, 1.0e-16);        min = 0; max = 0.5; expected = 11.0/768;        result = integrator.integrate(10000, f, min, max);        Assert.assertEquals(expected, result, 1.0e-16);        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;        result = integrator.integrate(10000, f, min, max);        Assert.assertEquals(expected, result, 1.0e-16);    }    @Test    public void testExactIntegration()        throws ConvergenceException, MathUserException {        Random random = new Random(86343623467878363l);        for (int n = 2; n < 6; ++n) {            LegendreGaussIntegrator integrator =                new LegendreGaussIntegrator(n,                                            UnivariateRealIntegratorImpl.DEFAULT_RELATIVE_ACCURACY,                                            UnivariateRealIntegratorImpl.DEFAULT_ABSOLUTE_ACCURACY,                                            UnivariateRealIntegratorImpl.DEFAULT_MIN_ITERATIONS_COUNT,                                            64);            // an n points Gauss-Legendre integrator integrates 2n-1 degree polynoms exactly            for (int degree = 0; degree <= 2 * n - 1; ++degree) {                for (int i = 0; i < 10; ++i) {                    double[] coeff = new double[degree + 1];                    for (int k = 0; k < coeff.length; ++k) {                        coeff[k] = 2 * random.nextDouble() - 1;                    }                    PolynomialFunction p = new PolynomialFunction(coeff);                    double result    = integrator.integrate(10000, p, -5.0, 15.0);                    double reference = exactIntegration(p, -5.0, 15.0);                    Assert.assertEquals(n + " " + degree + " " + i, reference, result, 1.0e-12 * (1.0 + FastMath.abs(reference)));                }            }        }    }    @Test    public void testIssue464() throws ConvergenceException {        final double value = 0.2;        UnivariateRealFunction f = new UnivariateRealFunction() {            public double value(double x) {                return (x >= 0 && x <= 5) ? value : 0.0;            }        };        LegendreGaussIntegrator gauss = new LegendreGaussIntegrator(5, 3, 100);        // due to the discontinuity, integration implies *many* calls        double maxX = 0.32462367623786328;        Assert.assertEquals(maxX * value, gauss.integrate(Integer.MAX_VALUE, f, -10, maxX), 1.0e-7);        Assert.assertTrue(gauss.getEvaluations() > 37000000);        Assert.assertTrue(gauss.getIterations() < 30);        // setting up limits prevents such large number of calls        try {            gauss.integrate(1000, f, -10, maxX);            Assert.fail("expected TooManyEvaluationsException");        } catch (TooManyEvaluationsException tmee) {            // expected            Assert.assertEquals(1000, tmee.getMax());        }        // integrating on the two sides should be simpler        double sum1 = gauss.integrate(1000, f, -10, 0);        int eval1   = gauss.getEvaluations();        double sum2 = gauss.integrate(1000, f, 0, maxX);        int eval2   = gauss.getEvaluations();        Assert.assertEquals(maxX * value, sum1 + sum2, 1.0e-7);        Assert.assertTrue(eval1 + eval2 < 200);    }    private double exactIntegration(PolynomialFunction p, double a, double b) {        final double[] coeffs = p.getCoefficients();        double yb = coeffs[coeffs.length - 1] / coeffs.length;        double ya = yb;        for (int i = coeffs.length - 2; i >= 0; --i) {            yb = yb * b + coeffs[i] / (i + 1);            ya = ya * a + coeffs[i] / (i + 1);        }        return yb * b - ya * a;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.integration;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.exception.NumberIsTooLargeException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test case for trapezoid integrator. * <p> * Test runs show that for a default relative accuracy of 1E-6, it * generally takes 10 to 15 iterations for the integral to converge. * * @version $Id$ */public final class TrapezoidIntegratorTest {    /**     * Test of integrator for the sine function.     */    @Test    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new TrapezoidIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = FastMath.PI; expected = 2;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(10000, f, min, max);        Assert.assertTrue(integrator.getEvaluations() < 2500);        Assert.assertTrue(integrator.getIterations()  < 15);        Assert.assertEquals(expected, result, tolerance);        min = -FastMath.PI/3; max = 0; expected = -0.5;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(10000, f, min, max);        Assert.assertTrue(integrator.getEvaluations() < 2500);        Assert.assertTrue(integrator.getIterations()  < 15);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of integrator for the quintic function.     */    @Test    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealIntegrator integrator = new TrapezoidIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = 1; expected = -1.0/48;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(10000, f, min, max);        Assert.assertTrue(integrator.getEvaluations() < 5000);        Assert.assertTrue(integrator.getIterations()  < 15);        Assert.assertEquals(expected, result, tolerance);        min = 0; max = 0.5; expected = 11.0/768;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(10000, f, min, max);        Assert.assertTrue(integrator.getEvaluations() < 2500);        Assert.assertTrue(integrator.getIterations()  < 15);        Assert.assertEquals(expected, result, tolerance);        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(10000, f, min, max);        Assert.assertTrue(integrator.getEvaluations() < 5000);        Assert.assertTrue(integrator.getIterations()  < 15);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the integrator.     */    @Test    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        try {            // bad interval            new TrapezoidIntegrator().integrate(1000, f, 1, -1);            Assert.fail("Expecting NumberIsTooLargeException - bad interval");        } catch (NumberIsTooLargeException ex) {            // expected        }        try {            // bad iteration limits            new TrapezoidIntegrator(5, 4);            Assert.fail("Expecting NumberIsTooSmallException - bad iteration limits");        } catch (NumberIsTooSmallException ex) {            // expected        }        try {            // bad iteration limits            new TrapezoidIntegrator(10,99);            Assert.fail("Expecting NumberIsTooLargeException - bad iteration limits");        } catch (NumberIsTooLargeException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.integration;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.exception.NumberIsTooLargeException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test case for Simpson integrator. * <p> * Test runs show that for a default relative accuracy of 1E-6, it * generally takes 5 to 10 iterations for the integral to converge. * * @version $Id$ */public final class SimpsonIntegratorTest {    /**     * Test of integrator for the sine function.     */    @Test    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new SimpsonIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = FastMath.PI; expected = 2;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(1000, f, min, max);        Assert.assertTrue(integrator.getEvaluations() < 100);        Assert.assertTrue(integrator.getIterations()  < 10);        Assert.assertEquals(expected, result, tolerance);        min = -FastMath.PI/3; max = 0; expected = -0.5;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(1000, f, min, max);        Assert.assertTrue(integrator.getEvaluations() < 50);        Assert.assertTrue(integrator.getIterations()  < 10);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of integrator for the quintic function.     */    @Test    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealIntegrator integrator = new SimpsonIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = 1; expected = -1.0/48;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(1000, f, min, max);        Assert.assertTrue(integrator.getEvaluations() < 150);        Assert.assertTrue(integrator.getIterations()  < 10);        Assert.assertEquals(expected, result, tolerance);        min = 0; max = 0.5; expected = 11.0/768;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(1000, f, min, max);        Assert.assertTrue(integrator.getEvaluations() < 100);        Assert.assertTrue(integrator.getIterations()  < 10);        Assert.assertEquals(expected, result, tolerance);        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(1000, f, min, max);        Assert.assertTrue(integrator.getEvaluations() < 150);        Assert.assertTrue(integrator.getIterations()  < 10);        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the integrator.     */    @Test    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        try {            // bad interval            new SimpsonIntegrator().integrate(1000, f, 1, -1);            Assert.fail("Expecting NumberIsTooLargeException - bad interval");        } catch (NumberIsTooLargeException ex) {            // expected        }        try {            // bad iteration limits            new SimpsonIntegrator(5, 4);            Assert.fail("Expecting NumberIsTooSmallException - bad iteration limits");        } catch (NumberIsTooSmallException ex) {            // expected        }        try {            // bad iteration limits            new SimpsonIntegrator(10, 99);            Assert.fail("Expecting NumberIsTooLargeException - bad iteration limits");        } catch (NumberIsTooLargeException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.analysis.BivariateRealFunction;import org.junit.Assert;import org.junit.Test;/** * Test case for the smoothing bicubic interpolator. *  * @version $Id$ */public final class SmoothingPolynomialBicubicSplineInterpolatorTest {    /**     * Test preconditions.     */    @Test    public void testPreconditions() {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2.5};        double[][] zval = new double[xval.length][yval.length];        BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(0);                @SuppressWarnings("unused")        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);                double[] wxval = new double[] {3, 2, 5, 6.5};        try {            p = interpolator.interpolate(wxval, yval, zval);            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException e) {            // Expected        }        double[] wyval = new double[] {-4, -3, -1, -1};        try {            p = interpolator.interpolate(xval, wyval, zval);            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException e) {            // Expected        }        double[][] wzval = new double[xval.length][yval.length + 1];        try {            p = interpolator.interpolate(xval, yval, wzval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wzval = new double[xval.length - 1][yval.length];        try {            p = interpolator.interpolate(xval, yval, wzval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wzval = new double[xval.length][yval.length - 1];        try {            p = interpolator.interpolate(xval, yval, wzval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }    }    /**     * Test of interpolator for a plane.     * <p>     * z = 2 x - 3 y + 5     */    @Test    public void testPlane() {        BivariateRealFunction f = new BivariateRealFunction() {                public double value(double x, double y) {                    return 2 * x - 3 * y + 5                        + ((int) (FastMath.abs(5 * x + 3 * y)) % 2 == 0 ? 1 : -1);                }            };        BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(1);        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2, 2.5};        double[][] zval = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                zval[i][j] = f.value(xval[i], yval[j]);            }        }        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);        double x, y;        double expected, result;                x = 4;        y = -3;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("On sample point", expected, result, 2);        x = 4.5;        y = -1.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 2);        x = 3.5;        y = -3.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 2);    }    /**     * Test of interpolator for a paraboloid.     * <p>     * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5     */    @Test    public void testParaboloid() {        BivariateRealFunction f = new BivariateRealFunction() {                public double value(double x, double y) {                    return 2 * x * x - 3 * y * y + 4 * x * y - 5                        + ((int) (FastMath.abs(5 * x + 3 * y)) % 2 == 0 ? 1 : -1);                }            };        BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(4);        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -2, -1, 0.5, 2.5};        double[][] zval = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                zval[i][j] = f.value(xval[i], yval[j]);            }        }        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);        double x, y;        double expected, result;        x = 5;        y = 0.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("On sample point", expected, result, 2);        x = 4.5;        y = -1.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 2);        x = 3.5;        y = -3.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 2);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.OutOfRangeException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.NoDataException;import org.apache.commons.math.exception.NonMonotonousSequenceException;import org.apache.commons.math.exception.NotFiniteNumberException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.junit.Assert;import org.junit.Test;/** * Test of the LoessInterpolator class. */public class LoessInterpolatorTest {    @Test    public void testOnOnePoint() {        double[] xval = {0.5};        double[] yval = {0.7};        double[] res = new LoessInterpolator().smooth(xval, yval);        Assert.assertEquals(1, res.length);        Assert.assertEquals(0.7, res[0], 0.0);    }    @Test    public void testOnTwoPoints() {        double[] xval = {0.5, 0.6};        double[] yval = {0.7, 0.8};        double[] res = new LoessInterpolator().smooth(xval, yval);        Assert.assertEquals(2, res.length);        Assert.assertEquals(0.7, res[0], 0.0);        Assert.assertEquals(0.8, res[1], 0.0);    }    @Test    public void testOnStraightLine() {        double[] xval = {1,2,3,4,5};        double[] yval = {2,4,6,8,10};        LoessInterpolator li = new LoessInterpolator(0.6, 2, 1e-12);        double[] res = li.smooth(xval, yval);        Assert.assertEquals(5, res.length);        for(int i = 0; i < 5; ++i) {            Assert.assertEquals(yval[i], res[i], 1e-8);        }    }    @Test    public void testOnDistortedSine() {        int numPoints = 100;        double[] xval = new double[numPoints];        double[] yval = new double[numPoints];        double xnoise = 0.1;        double ynoise = 0.2;        generateSineData(xval, yval, xnoise, ynoise);        LoessInterpolator li = new LoessInterpolator(0.3, 4, 1e-12);        double[] res = li.smooth(xval, yval);        // Check that the resulting curve differs from        // the "real" sine less than the jittered one        double noisyResidualSum = 0;        double fitResidualSum = 0;        for(int i = 0; i < numPoints; ++i) {            double expected = FastMath.sin(xval[i]);            double noisy = yval[i];            double fit = res[i];            noisyResidualSum += FastMath.pow(noisy - expected, 2);            fitResidualSum += FastMath.pow(fit - expected, 2);        }        Assert.assertTrue(fitResidualSum < noisyResidualSum);    }    @Test    public void testIncreasingBandwidthIncreasesSmoothness() {        int numPoints = 100;        double[] xval = new double[numPoints];        double[] yval = new double[numPoints];        double xnoise = 0.1;        double ynoise = 0.1;        generateSineData(xval, yval, xnoise, ynoise);        // Check that variance decreases as bandwidth increases        double[] bandwidths = {0.1, 0.5, 1.0};        double[] variances = new double[bandwidths.length];        for (int i = 0; i < bandwidths.length; i++) {            double bw = bandwidths[i];            LoessInterpolator li = new LoessInterpolator(bw, 4, 1e-12);            double[] res = li.smooth(xval, yval);            for (int j = 1; j < res.length; ++j) {                variances[i] += FastMath.pow(res[j] - res[j-1], 2);            }        }        for(int i = 1; i < variances.length; ++i) {            Assert.assertTrue(variances[i] < variances[i-1]);        }    }    @Test    public void testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers() {        int numPoints = 100;        double[] xval = new double[numPoints];        double[] yval = new double[numPoints];        double xnoise = 0.1;        double ynoise = 0.1;        generateSineData(xval, yval, xnoise, ynoise);        // Introduce a couple of outliers        yval[numPoints/3] *= 100;        yval[2 * numPoints/3] *= -100;        // Check that variance decreases as the number of robustness        // iterations increases        double[] variances = new double[4];        for (int i = 0; i < 4; i++) {            LoessInterpolator li = new LoessInterpolator(0.3, i, 1e-12);            double[] res = li.smooth(xval, yval);            for (int j = 1; j < res.length; ++j) {                variances[i] += FastMath.abs(res[j] - res[j-1]);            }        }        for(int i = 1; i < variances.length; ++i) {            Assert.assertTrue(variances[i] < variances[i-1]);        }    }    @Test(expected=DimensionMismatchException.class)    public void testUnequalSizeArguments() {        new LoessInterpolator().smooth(new double[] {1,2,3}, new double[] {1,2,3,4});    }    @Test(expected=NoDataException.class)    public void testEmptyData() {        new LoessInterpolator().smooth(new double[] {}, new double[] {});    }    @Test(expected=NonMonotonousSequenceException.class)    public void testNonStrictlyIncreasing1() {        new LoessInterpolator().smooth(new double[] {4,3,1,2}, new double[] {3,4,5,6});    }    @Test(expected=NonMonotonousSequenceException.class)    public void testNonStrictlyIncreasing2() {        new LoessInterpolator().smooth(new double[] {1,2,2,3}, new double[] {3,4,5,6});    }    @Test(expected=NotFiniteNumberException.class)    public void testNotAllFiniteReal1() {        new LoessInterpolator().smooth(new double[] {1,2,Double.NaN}, new double[] {3,4,5});    }    @Test(expected=NotFiniteNumberException.class)    public void testNotAllFiniteReal2() {        new LoessInterpolator().smooth(new double[] {1,2,Double.POSITIVE_INFINITY}, new double[] {3,4,5});    }    @Test(expected=NotFiniteNumberException.class)    public void testNotAllFiniteReal3() {        new LoessInterpolator().smooth(new double[] {1,2,Double.NEGATIVE_INFINITY}, new double[] {3,4,5});    }    @Test(expected=NotFiniteNumberException.class)    public void testNotAllFiniteReal4() {        new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.NaN});    }    @Test(expected=NotFiniteNumberException.class)    public void testNotAllFiniteReal5() {        new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.POSITIVE_INFINITY});    }    @Test(expected=NotFiniteNumberException.class)    public void testNotAllFiniteReal6() {        new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.NEGATIVE_INFINITY});    }    @Test(expected=NumberIsTooSmallException.class)    public void testInsufficientBandwidth() {        LoessInterpolator li = new LoessInterpolator(0.1, 3, 1e-12);        li.smooth(new double[] {1,2,3,4,5,6,7,8,9,10,11,12}, new double[] {1,2,3,4,5,6,7,8,9,10,11,12});    }    @Test(expected=OutOfRangeException.class)    public void testCompletelyIncorrectBandwidth1() {        new LoessInterpolator(-0.2, 3, 1e-12);    }    @Test(expected=OutOfRangeException.class)    public void testCompletelyIncorrectBandwidth2() {        new LoessInterpolator(1.1, 3, 1e-12);    }    @Test    public void testMath296withoutWeights() {        double[] xval = {                0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0,                 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0};        double[] yval = {                0.47, 0.48, 0.55, 0.56, -0.08, -0.04, -0.07, -0.07,                -0.56, -0.46, -0.56, -0.52, -3.03, -3.08, -3.09,                -3.04, 3.54, 3.46, 3.36, 3.35};        // Output from R, rounded to .001        double[] yref = {                0.461, 0.499, 0.541, 0.308, 0.175, -0.042, -0.072,                -0.196, -0.311, -0.446, -0.557, -1.497, -2.133,                -3.08, -3.09, -0.621, 0.982, 3.449, 3.389, 3.336        };        LoessInterpolator li = new LoessInterpolator(0.3, 4, 1e-12);        double[] res = li.smooth(xval, yval);        Assert.assertEquals(xval.length, res.length);        for(int i = 0; i < res.length; ++i) {            Assert.assertEquals(yref[i], res[i], 0.02);        }    }    private void generateSineData(double[] xval, double[] yval, double xnoise, double ynoise) {        double dx = 2 * FastMath.PI / xval.length;        double x = 0;        for(int i = 0; i < xval.length; ++i) {            xval[i] = x;            yval[i] = FastMath.sin(x) + (2 * FastMath.random() - 1) * ynoise;            x += dx * (1 + (2 * FastMath.random() - 1) * xnoise);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.analysis.TrivariateRealFunction;import org.junit.Assert;import org.junit.Test;/** * Test case for the tricubic interpolator. *  * @version $Id$ */public final class TricubicSplineInterpolatorTest {    /**     * Test preconditions.     */    @Test    public void testPreconditions() {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2.5};        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};        double[][][] fval = new double[xval.length][yval.length][zval.length];        TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator();                @SuppressWarnings("unused")        TrivariateRealFunction p = interpolator.interpolate(xval, yval, zval, fval);                double[] wxval = new double[] {3, 2, 5, 6.5};        try {            p = interpolator.interpolate(wxval, yval, zval, fval);            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException e) {            // Expected        }        double[] wyval = new double[] {-4, -3, -1, -1};        try {            p = interpolator.interpolate(xval, wyval, zval, fval);            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException e) {            // Expected        }        double[] wzval = new double[] {-12, -8, -5.5, -3, -4, 2.5};        try {            p = interpolator.interpolate(xval, yval, wzval, fval);            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException e) {            // Expected        }        double[][][] wfval = new double[xval.length][yval.length + 1][zval.length];        try {            p = interpolator.interpolate(xval, yval, zval, wfval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wfval = new double[xval.length - 1][yval.length][zval.length];        try {            p = interpolator.interpolate(xval, yval, zval, wfval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wfval = new double[xval.length][yval.length][zval.length - 1];        try {            p = interpolator.interpolate(xval, yval, zval, wfval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }    }    /**     * Test of interpolator for a plane.     * <p>     * f(x, y, z) = 2 x - 3 y - z + 5     */    @Test    public void testPlane() {        TrivariateRealFunction f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return 2 * x - 3 * y - z + 5;                }            };        TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator();        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2, 2.5};        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};        double[][][] fval = new double[xval.length][yval.length][zval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    fval[i][j][k] = f.value(xval[i], yval[j], zval[k]);                }            }        }        TrivariateRealFunction p = interpolator.interpolate(xval, yval, zval, fval);        double x, y, z;        double expected, result;                x = 4;        y = -3;        z = 0;        expected = f.value(x, y, z);        result = p.value(x, y, z);        Assert.assertEquals("On sample point", expected, result, 1e-15);        x = 4.5;        y = -1.5;        z = -4.25;        expected = f.value(x, y, z);        result = p.value(x, y, z);        Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 0.3);        x = 3.5;        y = -3.5;        z = -10;        expected = f.value(x, y, z);        result = p.value(x, y, z);        Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 0.3);    }    /**     * Test of interpolator for a sine wave.     * <p>     * <p>     *  f(x, y, z) = a cos [&omega; z - k<sub>y</sub> x - k<sub>y</sub> y]     * </p>     * with A = 0.2, &omega; = 0.5, k<sub>x</sub> = 2, k<sub>y</sub> = 1.     */    @Test    public void testWave() {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2, 2.5};        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 4};        final double a = 0.2;        final double omega = 0.5;        final double kx = 2;        final double ky = 1;        // Function values        TrivariateRealFunction f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return a * FastMath.cos(omega * z - kx * x - ky * y);                }            };                double[][][] fval = new double[xval.length][yval.length][zval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    fval[i][j][k] = f.value(xval[i], yval[j], zval[k]);                }            }        }        TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator();        TrivariateRealFunction p = interpolator.interpolate(xval, yval, zval, fval);        double x, y, z;        double expected, result;                x = 4;        y = -3;        z = 0;        expected = f.value(x, y, z);        result = p.value(x, y, z);        Assert.assertEquals("On sample point",                            expected, result, 1e-12);        x = 4.5;        y = -1.5;        z = -4.25;        expected = f.value(x, y, z);        result = p.value(x, y, z);        Assert.assertEquals("Half-way between sample points (middle of the patch)",                            expected, result, 0.1);        x = 3.5;        y = -3.5;        z = -10;        expected = f.value(x, y, z);        result = p.value(x, y, z);        Assert.assertEquals("Half-way between sample points (border of the patch)",                            expected, result, 0.1);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.exception.NonMonotonousSequenceException;import org.apache.commons.math.analysis.Expm1Function;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test case for Divided Difference interpolator. * <p> * The error of polynomial interpolation is *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n! * where f^(n) is the n-th derivative of the approximated function and * zeta is some point in the interval determined by x[] and z. * <p> * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound * it and use the absolute value upper bound for estimates. For reference, * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2. * * @version $Id$ */public final class DividedDifferenceInterpolatorTest {    /**     * Test of interpolator for the sine function.     * <p>     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]     */    @Test    public void testSinFunction() {        UnivariateRealFunction f = new SinFunction();        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();        double x[], y[], z, expected, result, tolerance;        // 6 interpolating points on interval [0, 2*PI]        int n = 6;        double min = 0.0, max = 2 * FastMath.PI;        x = new double[n];        y = new double[n];        for (int i = 0; i < n; i++) {            x[i] = min + i * (max - min) / n;            y[i] = f.value(x[i]);        }        double derivativebound = 1.0;        UnivariateRealFunction p = interpolator.interpolate(x, y);        z = FastMath.PI / 4; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        Assert.assertEquals(expected, result, tolerance);        z = FastMath.PI * 1.5; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of interpolator for the exponential function.     * <p>     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]     */    @Test    public void testExpm1Function() {        UnivariateRealFunction f = new Expm1Function();        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();        double x[], y[], z, expected, result, tolerance;        // 5 interpolating points on interval [-1, 1]        int n = 5;        double min = -1.0, max = 1.0;        x = new double[n];        y = new double[n];        for (int i = 0; i < n; i++) {            x[i] = min + i * (max - min) / n;            y[i] = f.value(x[i]);        }        double derivativebound = FastMath.E;        UnivariateRealFunction p = interpolator.interpolate(x, y);        z = 0.0; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        Assert.assertEquals(expected, result, tolerance);        z = 0.5; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        Assert.assertEquals(expected, result, tolerance);        z = -0.5; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the interpolator.     */    @Test    public void testParameters() throws Exception {        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();        try {            // bad abscissas array            double x[] = { 1.0, 2.0, 2.0, 4.0 };            double y[] = { 0.0, 4.0, 4.0, 2.5 };            UnivariateRealFunction p = interpolator.interpolate(x, y);            p.value(0.0);            Assert.fail("Expecting NonMonotonousSequenceException - bad abscissas array");        } catch (NonMonotonousSequenceException ex) {            // expected        }    }    /**     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!     */    protected double partialerror(double x[], double z) throws        IllegalArgumentException {        if (x.length < 1) {            throw new IllegalArgumentException                ("Interpolation array cannot be empty.");        }        double out = 1;        for (int i = 0; i < x.length; i++) {            out *= (z - x[i]) / (i + 1);        }        return out;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test case for the "microsphere projection" interpolator. * * @version $Id$ */public final class MicrosphereInterpolatorTest {    /**     * Test of interpolator for a plane.     * <p>     * y = 2 x<sub>1</sub> - 3 x<sub>2</sub> + 5     */    @Test    public void testLinearFunction2D() {        MultivariateRealFunction f = new MultivariateRealFunction() {                public double value(double[] x) {                    if (x.length != 2) {                        throw new IllegalArgumentException();                    }                    return 2 * x[0] - 3 * x[1] + 5;                }            };        MultivariateRealInterpolator interpolator = new MicrosphereInterpolator();        // Interpolating points in [-1, 1][-1, 1] by steps of 1.        final int n = 9;        final int dim = 2;        double[][] x = new double[n][dim];        double[] y = new double[n];        int index = 0;        for (int i = -1; i <= 1; i++) {            for (int j = -1; j <= 1; j++) {                x[index][0] = i;                x[index][1] = j;                y[index] = f.value(x[index]);                ++index;            }        }        MultivariateRealFunction p = interpolator.interpolate(x, y);        double[] c = new double[dim];        double expected, result;        c[0] = 0;        c[1] = 0;        expected = f.value(c);        result = p.value(c);        Assert.assertEquals("On sample point", expected, result, FastMath.ulp(1d));        c[0] = 0 + 1e-5;        c[1] = 1 - 1e-5;        expected = f.value(c);        result = p.value(c);        Assert.assertEquals("1e-5 away from sample point", expected, result, 1e-4);    }    /**     * Test of interpolator for a quadratic function.     * <p>     * y = 2 x<sub>1</sub><sup>2</sup> - 3 x<sub>2</sub><sup>2</sup>     *     + 4 x<sub>1</sub> x<sub>2</sub> - 5     */    @Test    public void testParaboloid2D() {        MultivariateRealFunction f = new MultivariateRealFunction() {                public double value(double[] x) {                    if (x.length != 2) {                        throw new IllegalArgumentException();                    }                    return 2 * x[0] * x[0] - 3 * x[1] * x[1] + 4 * x[0] * x[1] - 5;                }            };        MultivariateRealInterpolator interpolator = new MicrosphereInterpolator();        // Interpolating points in [-10, 10][-10, 10] by steps of 2.        final int n = 121;        final int dim = 2;        double[][] x = new double[n][dim];        double[] y = new double[n];        int index = 0;        for (int i = -10; i <= 10; i += 2) {            for (int j = -10; j <= 10; j += 2) {                x[index][0] = i;                x[index][1] = j;                y[index] = f.value(x[index]);                ++index;            }        }        MultivariateRealFunction p = interpolator.interpolate(x, y);        double[] c = new double[dim];        double expected, result;        c[0] = 0;        c[1] = 0;        expected = f.value(c);        result = p.value(c);        Assert.assertEquals("On sample point", expected, result, FastMath.ulp(1d));        c[0] = 2 + 1e-5;        c[1] = 2 - 1e-5;        expected = f.value(c);        result = p.value(c);        Assert.assertEquals("1e-5 away from sample point", expected, result, 1e-3);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.analysis.BivariateRealFunction;import org.junit.Assert;import org.junit.Test;/** * Test case for the bicubic function. *  * @version $Id$ */public final class BicubicSplineInterpolatingFunctionTest {    /**     * Test preconditions.     */    @Test    public void testPreconditions() {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2.5};        double[][] zval = new double[xval.length][yval.length];        @SuppressWarnings("unused")        BivariateRealFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval,                                                                           zval, zval, zval);                double[] wxval = new double[] {3, 2, 5, 6.5};        try {            bcf = new BicubicSplineInterpolatingFunction(wxval, yval, zval, zval, zval, zval);            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException e) {            // Expected        }        double[] wyval = new double[] {-4, -1, -1, 2.5};        try {            bcf = new BicubicSplineInterpolatingFunction(xval, wyval, zval, zval, zval, zval);            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException e) {            // Expected        }        double[][] wzval = new double[xval.length][yval.length - 1];        try {            bcf = new BicubicSplineInterpolatingFunction(xval, yval, wzval, zval, zval, zval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, wzval, zval, zval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, wzval, zval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, zval, wzval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wzval = new double[xval.length - 1][yval.length];        try {            bcf = new BicubicSplineInterpolatingFunction(xval, yval, wzval, zval, zval, zval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, wzval, zval, zval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, wzval, zval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, zval, wzval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }    }    /**     * Test for a plane.     * <p>     * z = 2 x - 3 y + 5     */    @Test    public void testPlane() {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2, 2.5};        // Function values        BivariateRealFunction f = new BivariateRealFunction() {                public double value(double x, double y) {                    return 2 * x - 3 * y + 5;                }            };        double[][] zval = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                zval[i][j] = f.value(xval[i], yval[j]);            }        }        // Partial derivatives with respect to x        double[][] dZdX = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                dZdX[i][j] = 2;            }        }        // Partial derivatives with respect to y        double[][] dZdY = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                dZdY[i][j] = -3;            }        }        // Partial cross-derivatives        double[][] dZdXdY = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                dZdXdY[i][j] = 0;            }        }        BivariateRealFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval,                                                                           dZdX, dZdY, dZdXdY);        double x, y;        double expected, result;        x = 4;        y = -3;        expected = f.value(x, y);        result = bcf.value(x, y);        Assert.assertEquals("On sample point",                            expected, result, 1e-15);        x = 4.5;        y = -1.5;        expected = f.value(x, y);        result = bcf.value(x, y);        Assert.assertEquals("Half-way between sample points (middle of the patch)",                            expected, result, 0.3);        x = 3.5;        y = -3.5;        expected = f.value(x, y);        result = bcf.value(x, y);        Assert.assertEquals("Half-way between sample points (border of the patch)",                            expected, result, 0.3);    }    /**     * Test for a paraboloid.     * <p>     * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5     */    @Test    public void testParaboloid() {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2, 2.5};        // Function values        BivariateRealFunction f = new BivariateRealFunction() {                public double value(double x, double y) {                    return 2 * x * x - 3 * y * y + 4 * x * y - 5;                }            };        double[][] zval = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                zval[i][j] = f.value(xval[i], yval[j]);            }        }        // Partial derivatives with respect to x        double[][] dZdX = new double[xval.length][yval.length];        BivariateRealFunction dfdX = new BivariateRealFunction() {                public double value(double x, double y) {                    return 4 * (x + y);                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                dZdX[i][j] = dfdX.value(xval[i], yval[j]);            }        }        // Partial derivatives with respect to y        double[][] dZdY = new double[xval.length][yval.length];        BivariateRealFunction dfdY = new BivariateRealFunction() {                public double value(double x, double y) {                    return 4 * x - 6 * y;                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                dZdY[i][j] = dfdY.value(xval[i], yval[j]);            }        }        // Partial cross-derivatives        double[][] dZdXdY = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                dZdXdY[i][j] = 4;            }        }        BivariateRealFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval,                                                                           dZdX, dZdY, dZdXdY);        double x, y;        double expected, result;                x = 4;        y = -3;        expected = f.value(x, y);        result = bcf.value(x, y);        Assert.assertEquals("On sample point",                            expected, result, 1e-15);        x = 4.5;        y = -1.5;        expected = f.value(x, y);        result = bcf.value(x, y);        Assert.assertEquals("Half-way between sample points (middle of the patch)",                            expected, result, 2);        x = 3.5;        y = -3.5;        expected = f.value(x, y);        result = bcf.value(x, y);        Assert.assertEquals("Half-way between sample points (border of the patch)",                            expected, result, 2);    }    /**     * Test for partial derivatives of {@link BicubicSplineFunction}.     * <p>     * f(x, y) = &Sigma;<sub>i</sub>&Sigma;<sub>j</sub> (i+1) (j+2) x<sup>i</sup> y<sup>j</sup>     */    @Test    public void testSplinePartialDerivatives() {        final int N = 4;        final double[] coeff = new double[16];        for (int i = 0; i < N; i++) {            for (int j = 0; j < N; j++) {                coeff[i + N * j] = (i + 1) * (j + 2);            }        }        final BicubicSplineFunction f = new BicubicSplineFunction(coeff);        BivariateRealFunction derivative;        final double x = 0.435;        final double y = 0.776;        final double tol = 1e-13;        derivative = new BivariateRealFunction() {                public double value(double x, double y) {                    final double x2 = x * x;                    final double y2 = y * y;                    final double y3 = y2 * y;                    final double yFactor = 2 + 3 * y + 4 * y2 + 5 * y3;                    return yFactor * (2 + 6 * x + 12 * x2);                }            };        Assert.assertEquals("dFdX", derivative.value(x, y),                            f.partialDerivativeX().value(x, y), tol);                derivative = new BivariateRealFunction() {                public double value(double x, double y) {                    final double x2 = x * x;                    final double x3 = x2 * x;                    final double y2 = y * y;                    final double xFactor = 1 + 2 * x + 3 * x2 + 4 * x3;                    return xFactor * (3 + 8 * y + 15 * y2);                }            };        Assert.assertEquals("dFdY", derivative.value(x, y),                            f.partialDerivativeY().value(x, y), tol);        derivative = new BivariateRealFunction() {                public double value(double x, double y) {                    final double y2 = y * y;                    final double y3 = y2 * y;                    final double yFactor = 2 + 3 * y + 4 * y2 + 5 * y3;                    return yFactor * (6 + 24 * x);                }            };        Assert.assertEquals("d2FdX2", derivative.value(x, y),                            f.partialDerivativeXX().value(x, y), tol);        derivative = new BivariateRealFunction() {                public double value(double x, double y) {                    final double x2 = x * x;                    final double x3 = x2 * x;                    final double xFactor = 1 + 2 * x + 3 * x2 + 4 * x3;                    return xFactor * (8 + 30 * y);                }            };        Assert.assertEquals("d2FdY2", derivative.value(x, y),                            f.partialDerivativeYY().value(x, y), tol);        derivative = new BivariateRealFunction() {                public double value(double x, double y) {                    final double x2 = x * x;                    final double y2 = y * y;                    final double yFactor = 3 + 8 * y + 15 * y2;                    return yFactor * (2 + 6 * x + 12 * x2);                }            };        Assert.assertEquals("d2FdXdY", derivative.value(x, y),                            f.partialDerivativeXY().value(x, y), tol);    }    /**     * Test that the partial derivatives computed from a     * {@link BicubicSplineInterpolatingFunction} match the input data.     * <p>     * f(x, y) = 5     *           - 3 x + 2 y     *           - x y + 2 x<sup>2</sup> - 3 y<sup>2</sup>     *           + 4 x<sup>2</sup> y - x y<sup>2</sup> - 3 x<sup>3</sup> + y<sup>3</sup>     */    @Test    public void testMatchingPartialDerivatives() {        final int sz = 21;        double[] val = new double[sz];        // Coordinate values        final double delta = 1d / (sz - 1);        for (int i = 0; i < sz; i++) {            val[i] = i * delta;        }        // Function values        BivariateRealFunction f = new BivariateRealFunction() {                public double value(double x, double y) {                    final double x2 = x * x;                    final double x3 = x2 * x;                    final double y2 = y * y;                    final double y3 = y2 * y;                    return 5                        - 3 * x + 2 * y                        - x * y + 2 * x2 - 3 * y2                        + 4 * x2 * y - x * y2 - 3 * x3 + y3;                }            };        double[][] fval = new double[sz][sz];        for (int i = 0; i < sz; i++) {            for (int j = 0; j < sz; j++) {                fval[i][j] = f.value(val[i], val[j]);            }        }        // Partial derivatives with respect to x        double[][] dFdX = new double[sz][sz];        BivariateRealFunction dfdX = new BivariateRealFunction() {                public double value(double x, double y) {                    final double x2 = x * x;                    final double y2 = y * y;                                        return - 3 - y + 4 * x + 8 * x * y - y2 - 9 * x2;                }            };        for (int i = 0; i < sz; i++) {            for (int j = 0; j < sz; j++) {                dFdX[i][j] = dfdX.value(val[i], val[j]);            }        }        // Partial derivatives with respect to y        double[][] dFdY = new double[sz][sz];        BivariateRealFunction dfdY = new BivariateRealFunction() {                public double value(double x, double y) {                    final double x2 = x * x;                    final double y2 = y * y;                                        return 2 - x - 6 * y + 4 * x2 - 2 * x * y + 3 * y2;                }            };        for (int i = 0; i < sz; i++) {            for (int j = 0; j < sz; j++) {                dFdY[i][j] = dfdY.value(val[i], val[j]);            }        }        // Partial cross-derivatives        double[][] d2FdXdY = new double[sz][sz];        BivariateRealFunction d2fdXdY = new BivariateRealFunction() {                public double value(double x, double y) {                    return -1 + 8 * x - 2 * y;                }            };        for (int i = 0; i < sz; i++) {            for (int j = 0; j < sz; j++) {                d2FdXdY[i][j] = d2fdXdY.value(val[i], val[j]);            }        }        BicubicSplineInterpolatingFunction bcf            = new BicubicSplineInterpolatingFunction(val, val, fval, dFdX, dFdY, d2FdXdY);        double x, y;        double expected, result;        final double tol = 1e-12;        for (int i = 0; i < sz; i++) {            x = val[i];            for (int j = 0; j < sz; j++) {                y = val[j];                                expected = dfdX.value(x, y);                result = bcf.partialDerivativeX(x, y);                Assert.assertEquals(x + " " + y + " dFdX", expected, result, tol);                expected = dfdY.value(x, y);                result = bcf.partialDerivativeY(x, y);                Assert.assertEquals(x + " " + y + " dFdY", expected, result, tol);                                expected = d2fdXdY.value(x, y);                result = bcf.partialDerivativeXY(x, y);                Assert.assertEquals(x + " " + y + " d2FdXdY", expected, result, tol);            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.exception.NonMonotonousSequenceException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.analysis.polynomials.PolynomialFunction;import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;import org.junit.Assert;import org.junit.Test;/** * Test the LinearInterpolator. */public class LinearInterpolatorTest {    /** error tolerance for spline interpolator value at knot points */    protected double knotTolerance = 1E-12;    /** error tolerance for interpolating polynomial coefficients */    protected double coefficientTolerance = 1E-6;    /** error tolerance for interpolated values */    protected double interpolationTolerance = 1E-12;    @Test    public void testInterpolateLinearDegenerateTwoSegment()        throws Exception {        double x[] = { 0.0, 0.5, 1.0 };        double y[] = { 0.0, 0.5, 1.0 };        UnivariateRealInterpolator i = new LinearInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 1d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        // Check interpolation        Assert.assertEquals(0.0,f.value(0.0), interpolationTolerance);        Assert.assertEquals(0.4,f.value(0.4), interpolationTolerance);        Assert.assertEquals(1.0,f.value(1.0), interpolationTolerance);    }    @Test    public void testInterpolateLinearDegenerateThreeSegment()        throws Exception {        double x[] = { 0.0, 0.5, 1.0, 1.5 };        double y[] = { 0.0, 0.5, 1.0, 1.5 };        UnivariateRealInterpolator i = new LinearInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 1d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[2], 1d};        TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);        // Check interpolation        Assert.assertEquals(0,f.value(0), interpolationTolerance);        Assert.assertEquals(1.4,f.value(1.4), interpolationTolerance);        Assert.assertEquals(1.5,f.value(1.5), interpolationTolerance);    }    @Test    public void testInterpolateLinear() throws Exception {        double x[] = { 0.0, 0.5, 1.0 };        double y[] = { 0.0, 0.5, 0.0 };        UnivariateRealInterpolator i = new LinearInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], -1d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);    }    @Test    public void testIllegalArguments() {        // Data set arrays of different size.        UnivariateRealInterpolator i = new LinearInterpolator();        try {            double xval[] = { 0.0, 1.0 };            double yval[] = { 0.0, 1.0, 2.0 };            i.interpolate(xval, yval);            Assert.fail("Failed to detect data set array with different sizes.");        } catch (DimensionMismatchException iae) {            // Expected.        }        // X values not sorted.        try {            double xval[] = { 0.0, 1.0, 0.5 };            double yval[] = { 0.0, 1.0, 2.0 };            i.interpolate(xval, yval);            Assert.fail("Failed to detect unsorted arguments.");        } catch (NonMonotonousSequenceException iae) {            // Expected.        }        // Not enough data to interpolate.        try {            double xval[] = { 0.0 };            double yval[] = { 0.0 };            i.interpolate(xval, yval);            Assert.fail("Failed to detect unsorted arguments.");        } catch (NumberIsTooSmallException iae) {            // Expected.        }    }    /**     * verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length.     */    protected void verifyInterpolation(UnivariateRealFunction f, double x[], double y[])        throws Exception{        for (int i = 0; i < x.length; i++) {            Assert.assertEquals(f.value(x[i]), y[i], knotTolerance);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import java.util.Random;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.exception.NonMonotonousSequenceException;import org.junit.Assert;import org.junit.Test;/** * Test for {@link UnivariateRealPeriodicInterpolator}. */public class UnivariateRealPeriodicInterpolatorTest {    private final Random rng = new Random(1224465L);    @Test    public void testSine() {        final int n = 30;        final double[] xval = new double[n];        final double[] yval = new double[n];        final double period = 12.3;        final double offset = 45.67;        double delta = 0;        for (int i = 0; i < n; i++) {            delta += rng.nextDouble() * period / n;            xval[i] = offset + delta;            yval[i] = FastMath.sin(xval[i]);        }        final UnivariateRealInterpolator inter = new LinearInterpolator();        final UnivariateRealFunction f = inter.interpolate(xval, yval);        final UnivariateRealInterpolator interP            = new UnivariateRealPeriodicInterpolator(new LinearInterpolator(),                                                     period, 1);        final UnivariateRealFunction fP = interP.interpolate(xval, yval);        // Comparing with original interpolation algorithm.        final double xMin = xval[0];        final double xMax = xval[n - 1];        for (int i = 0; i < n; i++) {            final double x = xMin + (xMax - xMin) * rng.nextDouble();            final double y = f.value(x);            final double yP = fP.value(x);            Assert.assertEquals("x=" + x, y, yP, Math.ulp(1d));        }        // Test interpolation outside the primary interval.        for (int i = 0; i < n; i++) {            final double xIn = offset + rng.nextDouble() * period;            final double xOut = xIn + rng.nextInt(123456789) * period;            final double yIn = fP.value(xIn);            final double yOut = fP.value(xOut);            Assert.assertEquals(yIn, yOut, 1e-7);        }    }    @Test    public void testLessThanOnePeriodCoverage() {        final int n = 30;        final double[] xval = new double[n];        final double[] yval = new double[n];        final double period = 12.3;        final double offset = 45.67;        double delta = period / 2;        for (int i = 0; i < n; i++) {            delta += period / (2 * n) * rng.nextDouble();            xval[i] = offset + delta;            yval[i] = FastMath.sin(xval[i]);        }        final UnivariateRealInterpolator interP            = new UnivariateRealPeriodicInterpolator(new LinearInterpolator(),                                                     period, 1);        final UnivariateRealFunction fP = interP.interpolate(xval, yval);        // Test interpolation outside the sample data interval.        for (int i = 0; i < n; i++) {            final double xIn = offset + rng.nextDouble() * period;            final double xOut = xIn + rng.nextInt(123456789) * period;            final double yIn = fP.value(xIn);            final double yOut = fP.value(xOut);            Assert.assertEquals(yIn, yOut, 1e-7);        }    }    @Test    public void testMoreThanOnePeriodCoverage() {        final int n = 30;        final double[] xval = new double[n];        final double[] yval = new double[n];        final double period = 12.3;        final double offset = 45.67;        double delta = period / 2;        for (int i = 0; i < n; i++) {            delta += 10 * period / n * rng.nextDouble();            xval[i] = offset + delta;            yval[i] = FastMath.sin(xval[i]);        }        final UnivariateRealInterpolator interP            = new UnivariateRealPeriodicInterpolator(new LinearInterpolator(),                                                     period, 1);        final UnivariateRealFunction fP = interP.interpolate(xval, yval);        // Test interpolation outside the sample data interval.        for (int i = 0; i < n; i++) {            final double xIn = offset + rng.nextDouble() * period;            final double xOut = xIn + rng.nextInt(123456789) * period;            final double yIn = fP.value(xIn);            final double yOut = fP.value(xOut);            Assert.assertEquals(yIn, yOut, 1e-6);        }    }    @Test(expected=NumberIsTooSmallException.class)    public void testTooFewSamples() {        final double[] xval = { 2, 3, 7 };        final double[] yval = { 1, 6, 5 };        final double period = 10;        final UnivariateRealInterpolator interpolator            = new UnivariateRealPeriodicInterpolator(new LinearInterpolator(), period);        interpolator.interpolate(xval, yval);    }    @Test(expected=NonMonotonousSequenceException.class)    public void testUnsortedSamples() {        final double[] xval = { 2, 3, 7, 4, 6 };        final double[] yval = { 1, 6, 5, -1, -2 };        final double period = 10;        final UnivariateRealInterpolator interpolator            = new UnivariateRealPeriodicInterpolator(new LinearInterpolator(), period);        interpolator.interpolate(xval, yval);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.exception.NonMonotonousSequenceException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.TestUtils;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.analysis.polynomials.PolynomialFunction;import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;import org.junit.Assert;import org.junit.Test;/** * Test the SplineInterpolator. * * @version $Id$ */public class SplineInterpolatorTest {    /** error tolerance for spline interpolator value at knot points */    protected double knotTolerance = 1E-12;    /** error tolerance for interpolating polynomial coefficients */    protected double coefficientTolerance = 1E-6;    /** error tolerance for interpolated values -- high value is from sin test */    protected double interpolationTolerance = 1E-2;    @Test    public void testInterpolateLinearDegenerateTwoSegment()        throws Exception {        double x[] = { 0.0, 0.5, 1.0 };        double y[] = { 0.0, 0.5, 1.0 };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        verifyConsistency((PolynomialSplineFunction) f, x);        // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 1d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        // Check interpolation        Assert.assertEquals(0.0,f.value(0.0), interpolationTolerance);        Assert.assertEquals(0.4,f.value(0.4), interpolationTolerance);        Assert.assertEquals(1.0,f.value(1.0), interpolationTolerance);    }    @Test    public void testInterpolateLinearDegenerateThreeSegment()        throws Exception {        double x[] = { 0.0, 0.5, 1.0, 1.5 };        double y[] = { 0.0, 0.5, 1.0, 1.5 };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 1d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[2], 1d};        TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);        // Check interpolation        Assert.assertEquals(0,f.value(0), interpolationTolerance);        Assert.assertEquals(1.4,f.value(1.4), interpolationTolerance);        Assert.assertEquals(1.5,f.value(1.5), interpolationTolerance);    }    @Test    public void testInterpolateLinear() throws Exception {        double x[] = { 0.0, 0.5, 1.0 };        double y[] = { 0.0, 0.5, 0.0 };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        verifyConsistency((PolynomialSplineFunction) f, x);        // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1.5d, 0d, -2d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 0d, -3d, 2d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);    }    @Test    public void testInterpolateSin() throws Exception {        double x[] =            {                0.0,                FastMath.PI / 6d,                FastMath.PI / 2d,                5d * FastMath.PI / 6d,                FastMath.PI,                7d * FastMath.PI / 6d,                3d * FastMath.PI / 2d,                11d * FastMath.PI / 6d,                2.d * FastMath.PI };        double y[] = { 0d, 0.5d, 1d, 0.5d, 0d, -0.5d, -1d, -0.5d, 0d };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        verifyConsistency((PolynomialSplineFunction) f, x);        /* Check coefficients against values computed using R (version 1.8.1, Red Hat Linux 9)         *         * To replicate in R:         *     x[1] <- 0         *     x[2] <- pi / 6, etc, same for y[] (could use y <- scan() for y values)         *     g <- splinefun(x, y, "natural")         *     splinecoef <- eval(expression(z), envir = environment(g))         *     print(splinecoef)         */        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1.002676d, 0d, -0.17415829d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 8.594367e-01, -2.735672e-01, -0.08707914};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[2], 1.471804e-17,-5.471344e-01, 0.08707914};        TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[3], -8.594367e-01, -2.735672e-01, 0.17415829};        TestUtils.assertEquals(polynomials[3].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[4], -1.002676, 6.548562e-17, 0.17415829};        TestUtils.assertEquals(polynomials[4].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[5], -8.594367e-01, 2.735672e-01, 0.08707914};        TestUtils.assertEquals(polynomials[5].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[6], 3.466465e-16, 5.471344e-01, -0.08707914};        TestUtils.assertEquals(polynomials[6].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[7], 8.594367e-01, 2.735672e-01, -0.17415829};        TestUtils.assertEquals(polynomials[7].getCoefficients(), target, coefficientTolerance);        //Check interpolation        Assert.assertEquals(FastMath.sqrt(2d) / 2d,f.value(FastMath.PI/4d),interpolationTolerance);        Assert.assertEquals(FastMath.sqrt(2d) / 2d,f.value(3d*FastMath.PI/4d),interpolationTolerance);    }    @Test    public void testIllegalArguments() {        // Data set arrays of different size.        UnivariateRealInterpolator i = new SplineInterpolator();        try {            double xval[] = { 0.0, 1.0 };            double yval[] = { 0.0, 1.0, 2.0 };            i.interpolate(xval, yval);            Assert.fail("Failed to detect data set array with different sizes.");        } catch (DimensionMismatchException iae) {            // Expected.        }        // X values not sorted.        try {            double xval[] = { 0.0, 1.0, 0.5 };            double yval[] = { 0.0, 1.0, 2.0 };            i.interpolate(xval, yval);            Assert.fail("Failed to detect unsorted arguments.");        } catch (NonMonotonousSequenceException iae) {            // Expected.        }        // Not enough data to interpolate.        try {            double xval[] = { 0.0, 1.0 };            double yval[] = { 0.0, 1.0 };            i.interpolate(xval, yval);            Assert.fail("Failed to detect unsorted arguments.");        } catch (NumberIsTooSmallException iae) {            // Expected.        }    }    /**     * verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length.     */    protected void verifyInterpolation(UnivariateRealFunction f, double x[], double y[])        throws Exception{        for (int i = 0; i < x.length; i++) {            Assert.assertEquals(f.value(x[i]), y[i], knotTolerance);        }    }    /**     * Verifies that interpolating polynomials satisfy consistency requirement:     *    adjacent polynomials must agree through two derivatives at knot points     */    protected void verifyConsistency(PolynomialSplineFunction f, double x[])        throws Exception {        PolynomialFunction polynomials[] = f.getPolynomials();        for (int i = 1; i < x.length - 2; i++) {            // evaluate polynomials and derivatives at x[i + 1]            Assert.assertEquals(polynomials[i].value(x[i +1] - x[i]), polynomials[i + 1].value(0), 0.1);            Assert.assertEquals(polynomials[i].derivative().value(x[i +1] - x[i]),                                polynomials[i + 1].derivative().value(0), 0.5);            Assert.assertEquals(polynomials[i].polynomialDerivative().derivative().value(x[i +1] - x[i]),                                polynomials[i + 1].polynomialDerivative().derivative().value(0), 0.5);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.analysis.BivariateRealFunction;import org.junit.Assert;import org.junit.Test;/** * Test case for the bicubic interpolator. *  * @version $Id$ */public final class BicubicSplineInterpolatorTest {    /**     * Test preconditions.     */    @Test    public void testPreconditions() {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2.5};        double[][] zval = new double[xval.length][yval.length];        BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator();                @SuppressWarnings("unused")        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);                double[] wxval = new double[] {3, 2, 5, 6.5};        try {            p = interpolator.interpolate(wxval, yval, zval);            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException e) {            // Expected        }        double[] wyval = new double[] {-4, -3, -1, -1};        try {            p = interpolator.interpolate(xval, wyval, zval);            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException e) {            // Expected        }        double[][] wzval = new double[xval.length][yval.length + 1];        try {            p = interpolator.interpolate(xval, yval, wzval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wzval = new double[xval.length - 1][yval.length];        try {            p = interpolator.interpolate(xval, yval, wzval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }    }    /**     * Test of interpolator for a plane.     * <p>     * z = 2 x - 3 y + 5     */    @Test    public void testPlane() {        BivariateRealFunction f = new BivariateRealFunction() {                public double value(double x, double y) {                    return 2 * x - 3 * y + 5;                }            };        BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator();        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2, 2.5};        double[][] zval = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                zval[i][j] = f.value(xval[i], yval[j]);            }        }        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);        double x, y;        double expected, result;                x = 4;        y = -3;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("On sample point", expected, result, 1e-15);        x = 4.5;        y = -1.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 0.3);        x = 3.5;        y = -3.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 0.3);    }    /**     * Test of interpolator for a paraboloid.     * <p>     * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5     */    @Test    public void testParaboloid() {        BivariateRealFunction f = new BivariateRealFunction() {                public double value(double x, double y) {                    return 2 * x * x - 3 * y * y + 4 * x * y - 5;                }            };        BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator();        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -2, -1, 0.5, 2.5};        double[][] zval = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                zval[i][j] = f.value(xval[i], yval[j]);            }        }        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);        double x, y;        double expected, result;                x = 5;        y = 0.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("On sample point", expected, result, 1e-13);        x = 4.5;        y = -1.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 0.2);        x = 3.5;        y = -3.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 0.2);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.analysis.TrivariateRealFunction;import org.junit.Assert;import org.junit.Test;/** * Test case for the bicubic function. *  * @version $Id$ */public final class TricubicSplineInterpolatingFunctionTest {    /**     * Test preconditions.     */    @Test    public void testPreconditions() throws Exception {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2.5};        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};        double[][][] fval = new double[xval.length][yval.length][zval.length];        @SuppressWarnings("unused")        TrivariateRealFunction tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                                             fval, fval, fval, fval,                                                                             fval, fval, fval, fval);                double[] wxval = new double[] {3, 2, 5, 6.5};        try {            tcf = new TricubicSplineInterpolatingFunction(wxval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException e) {            // Expected        }        double[] wyval = new double[] {-4, -1, -1, 2.5};        try {            tcf = new TricubicSplineInterpolatingFunction(xval, wyval, zval,                                                          fval, fval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException e) {            // Expected        }        double[] wzval = new double[] {-12, -8, -9, -3, 0, 2.5};        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, wzval,                                                          fval, fval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException e) {            // Expected        }        double[][][] wfval = new double[xval.length - 1][yval.length - 1][zval.length];        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          wfval, fval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, wfval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, wfval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, wfval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          wfval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, wfval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, fval, wfval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, fval, fval, wfval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wfval = new double[xval.length][yval.length - 1][zval.length];        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          wfval, fval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, wfval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, wfval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, wfval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          wfval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, wfval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, fval, wfval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, fval, fval, wfval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wfval = new double[xval.length][yval.length][zval.length - 1];        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          wfval, fval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, wfval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, wfval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, wfval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          wfval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, wfval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, fval, wfval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, fval, fval, wfval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }    }    /**     * Test for a plane.     * <p>     *  f(x, y, z) = 2 x - 3 y - 4 z + 5     * </p>     */    @Test    public void testPlane() {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2, 2.5};        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};        // Function values        TrivariateRealFunction f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return 2 * x - 3 * y - 4 * z + 5;                }            };        double[][][] fval = new double[xval.length][yval.length][zval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    fval[i][j][k] = f.value(xval[i], yval[j], zval[k]);                }            }        }        // Partial derivatives with respect to x        double[][][] dFdX = new double[xval.length][yval.length][zval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    dFdX[i][j][k] = 2;                }            }        }        // Partial derivatives with respect to y        double[][][] dFdY = new double[xval.length][yval.length][zval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    dFdY[i][j][k] = -3;                }            }        }        // Partial derivatives with respect to z        double[][][] dFdZ = new double[xval.length][yval.length][zval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    dFdZ[i][j][k] = -4;                }            }        }        // Partial cross-derivatives        double[][][] d2FdXdY = new double[xval.length][yval.length][zval.length];        double[][][] d2FdXdZ = new double[xval.length][yval.length][zval.length];        double[][][] d2FdYdZ = new double[xval.length][yval.length][zval.length];        double[][][] d3FdXdYdZ = new double[xval.length][yval.length][zval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    d2FdXdY[i][j][k] = 0;                    d2FdXdZ[i][j][k] = 0;                    d2FdYdZ[i][j][k] = 0;                    d3FdXdYdZ[i][j][k] = 0;                }            }        }        TrivariateRealFunction tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                                             fval, dFdX, dFdY, dFdZ,                                                                             d2FdXdY, d2FdXdZ, d2FdYdZ,                                                                             d3FdXdYdZ);        double x, y, z;        double expected, result;        x = 4;        y = -3;        z = 0;        expected = f.value(x, y, z);        result = tcf.value(x, y, z);        Assert.assertEquals("On sample point",                            expected, result, 1e-15);        x = 4.5;        y = -1.5;        z = -4.25;        expected = f.value(x, y, z);        result = tcf.value(x, y, z);        Assert.assertEquals("Half-way between sample points (middle of the patch)",                            expected, result, 0.3);        x = 3.5;        y = -3.5;        z = -10;        expected = f.value(x, y, z);        result = tcf.value(x, y, z);        Assert.assertEquals("Half-way between sample points (border of the patch)",                            expected, result, 0.3);    }    /**     * Sine wave.     * <p>     *  f(x, y, z) = a cos [&omega; z - k<sub>y</sub> x - k<sub>y</sub> y]     * </p>     * with A = 0.2, &omega; = 0.5, k<sub>x</sub> = 2, k<sub>y</sub> = 1.     */    @Test    public void testWave() {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2, 2.5};        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 4};                final double a = 0.2;        final double omega = 0.5;        final double kx = 2;        final double ky = 1;                // Function values        TrivariateRealFunction f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return a * FastMath.cos(omega * z - kx * x - ky * y);                }            };                double[][][] fval = new double[xval.length][yval.length][zval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    fval[i][j][k] = f.value(xval[i], yval[j], zval[k]);                }            }        }                // Partial derivatives with respect to x        double[][][] dFdX = new double[xval.length][yval.length][zval.length];        TrivariateRealFunction dFdX_f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return a * FastMath.sin(omega * z - kx * x - ky * y) * kx;                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    dFdX[i][j][k] = dFdX_f.value(xval[i], yval[j], zval[k]);                }            }        }                    // Partial derivatives with respect to y        double[][][] dFdY = new double[xval.length][yval.length][zval.length];        TrivariateRealFunction dFdY_f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return a * FastMath.sin(omega * z - kx * x - ky * y) * ky;                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    dFdY[i][j][k] = dFdY_f.value(xval[i], yval[j], zval[k]);                }            }        }        // Partial derivatives with respect to z        double[][][] dFdZ = new double[xval.length][yval.length][zval.length];        TrivariateRealFunction dFdZ_f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return -a * FastMath.sin(omega * z - kx * x - ky * y) * omega;                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    dFdZ[i][j][k] = dFdZ_f.value(xval[i], yval[j], zval[k]);                }            }        }        // Partial second derivatives w.r.t. (x, y)        double[][][] d2FdXdY = new double[xval.length][yval.length][zval.length];        TrivariateRealFunction d2FdXdY_f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return -a * FastMath.cos(omega * z - kx * x - ky * y) * kx * ky;                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    d2FdXdY[i][j][k] = d2FdXdY_f.value(xval[i], yval[j], zval[k]);                }            }        }        // Partial second derivatives w.r.t. (x, z)        double[][][] d2FdXdZ = new double[xval.length][yval.length][zval.length];        TrivariateRealFunction d2FdXdZ_f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return a * FastMath.cos(omega * z - kx * x - ky * y) * kx * omega;                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    d2FdXdZ[i][j][k] = d2FdXdZ_f.value(xval[i], yval[j], zval[k]);                }            }        }        // Partial second derivatives w.r.t. (y, z)        double[][][] d2FdYdZ = new double[xval.length][yval.length][zval.length];        TrivariateRealFunction d2FdYdZ_f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return a * FastMath.cos(omega * z - kx * x - ky * y) * ky * omega;                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    d2FdYdZ[i][j][k] = d2FdYdZ_f.value(xval[i], yval[j], zval[k]);                }            }        }        // Partial third derivatives        double[][][] d3FdXdYdZ = new double[xval.length][yval.length][zval.length];        TrivariateRealFunction d3FdXdYdZ_f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return a * FastMath.sin(omega * z - kx * x - ky * y) * kx * ky * omega;                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    d3FdXdYdZ[i][j][k] = d3FdXdYdZ_f.value(xval[i], yval[j], zval[k]);                }            }        }        TrivariateRealFunction tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                                             fval, dFdX, dFdY, dFdZ,                                                                             d2FdXdY, d2FdXdZ, d2FdYdZ,                                                                             d3FdXdYdZ);        double x, y, z;        double expected, result;                x = 4;        y = -3;        z = 0;        expected = f.value(x, y, z);        result = tcf.value(x, y, z);        Assert.assertEquals("On sample point",                            expected, result, 1e-14);        x = 4.5;        y = -1.5;        z = -4.25;        expected = f.value(x, y, z);        result = tcf.value(x, y, z);        Assert.assertEquals("Half-way between sample points (middle of the patch)",                            expected, result, 0.1);        x = 3.5;        y = -3.5;        z = -10;        expected = f.value(x, y, z);        result = tcf.value(x, y, z);        Assert.assertEquals("Half-way between sample points (border of the patch)",                            expected, result, 0.1);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.exception.NonMonotonousSequenceException;import org.apache.commons.math.analysis.Expm1Function;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test case for Neville interpolator. * <p> * The error of polynomial interpolation is *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n! * where f^(n) is the n-th derivative of the approximated function and * zeta is some point in the interval determined by x[] and z. * <p> * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound * it and use the absolute value upper bound for estimates. For reference, * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2. * * @version $Id$ */public final class NevilleInterpolatorTest {    /**     * Test of interpolator for the sine function.     * <p>     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]     */    @Test    public void testSinFunction() {        UnivariateRealFunction f = new SinFunction();        UnivariateRealInterpolator interpolator = new NevilleInterpolator();        double x[], y[], z, expected, result, tolerance;        // 6 interpolating points on interval [0, 2*PI]        int n = 6;        double min = 0.0, max = 2 * FastMath.PI;        x = new double[n];        y = new double[n];        for (int i = 0; i < n; i++) {            x[i] = min + i * (max - min) / n;            y[i] = f.value(x[i]);        }        double derivativebound = 1.0;        UnivariateRealFunction p = interpolator.interpolate(x, y);        z = FastMath.PI / 4; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        Assert.assertEquals(expected, result, tolerance);        z = FastMath.PI * 1.5; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of interpolator for the exponential function.     * <p>     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]     */    @Test    public void testExpm1Function() {        UnivariateRealFunction f = new Expm1Function();        UnivariateRealInterpolator interpolator = new NevilleInterpolator();        double x[], y[], z, expected, result, tolerance;        // 5 interpolating points on interval [-1, 1]        int n = 5;        double min = -1.0, max = 1.0;        x = new double[n];        y = new double[n];        for (int i = 0; i < n; i++) {            x[i] = min + i * (max - min) / n;            y[i] = f.value(x[i]);        }        double derivativebound = FastMath.E;        UnivariateRealFunction p = interpolator.interpolate(x, y);        z = 0.0; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        Assert.assertEquals(expected, result, tolerance);        z = 0.5; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        Assert.assertEquals(expected, result, tolerance);        z = -0.5; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        Assert.assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the interpolator.     */    @Test    public void testParameters() throws Exception {        UnivariateRealInterpolator interpolator = new NevilleInterpolator();        try {            // bad abscissas array            double x[] = { 1.0, 2.0, 2.0, 4.0 };            double y[] = { 0.0, 4.0, 4.0, 2.5 };            UnivariateRealFunction p = interpolator.interpolate(x, y);            p.value(0.0);            Assert.fail("Expecting NonMonotonousSequenceException - bad abscissas array");        } catch (NonMonotonousSequenceException ex) {            // expected        }    }    /**     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!     */    protected double partialerror(double x[], double z) throws        IllegalArgumentException {        if (x.length < 1) {            throw new IllegalArgumentException                ("Interpolation array cannot be empty.");        }        double out = 1;        for (int i = 0; i < x.length; i++) {            out *= (z - x[i]) / (i + 1);        }        return out;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.polynomials;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.junit.Assert;import org.junit.Test;/** * Test case for Lagrange form of polynomial function. * <p> * We use n+1 points to interpolate a polynomial of degree n. This should * give us the exact same polynomial as result. Thus we can use a very * small tolerance to account only for round-off errors. * * @version $Id$ */public final class PolynomialFunctionLagrangeFormTest {    /**     * Test of polynomial for the linear function.     */    @Test    public void testLinearFunction() {        PolynomialFunctionLagrangeForm p;        double c[], z, expected, result, tolerance = 1E-12;        // p(x) = 1.5x - 4        double x[] = { 0.0, 3.0 };        double y[] = { -4.0, 0.5 };        p = new PolynomialFunctionLagrangeForm(x, y);        z = 2.0; expected = -1.0; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        z = 4.5; expected = 2.75; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        z = 6.0; expected = 5.0; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        Assert.assertEquals(1, p.degree());        c = p.getCoefficients();        Assert.assertEquals(2, c.length);        Assert.assertEquals(-4.0, c[0], tolerance);        Assert.assertEquals(1.5, c[1], tolerance);    }    /**     * Test of polynomial for the quadratic function.     */    @Test    public void testQuadraticFunction() {        PolynomialFunctionLagrangeForm p;        double c[], z, expected, result, tolerance = 1E-12;        // p(x) = 2x^2 + 5x - 3 = (2x - 1)(x + 3)        double x[] = { 0.0, -1.0, 0.5 };        double y[] = { -3.0, -6.0, 0.0 };        p = new PolynomialFunctionLagrangeForm(x, y);        z = 1.0; expected = 4.0; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        z = 2.5; expected = 22.0; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        z = -2.0; expected = -5.0; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        Assert.assertEquals(2, p.degree());        c = p.getCoefficients();        Assert.assertEquals(3, c.length);        Assert.assertEquals(-3.0, c[0], tolerance);        Assert.assertEquals(5.0, c[1], tolerance);        Assert.assertEquals(2.0, c[2], tolerance);    }    /**     * Test of polynomial for the quintic function.     */    @Test    public void testQuinticFunction() {        PolynomialFunctionLagrangeForm p;        double c[], z, expected, result, tolerance = 1E-12;        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x = x(x^2 - 1)(x + 2)(x - 3)        double x[] = { 1.0, -1.0, 2.0, 3.0, -3.0, 0.5 };        double y[] = { 0.0, 0.0, -24.0, 0.0, -144.0, 2.34375 };        p = new PolynomialFunctionLagrangeForm(x, y);        z = 0.0; expected = 0.0; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        z = -2.0; expected = 0.0; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        z = 4.0; expected = 360.0; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        Assert.assertEquals(5, p.degree());        c = p.getCoefficients();        Assert.assertEquals(6, c.length);        Assert.assertEquals(0.0, c[0], tolerance);        Assert.assertEquals(6.0, c[1], tolerance);        Assert.assertEquals(1.0, c[2], tolerance);        Assert.assertEquals(-7.0, c[3], tolerance);        Assert.assertEquals(-1.0, c[4], tolerance);        Assert.assertEquals(1.0, c[5], tolerance);    }    /**     * Test of parameters for the polynomial.     */    @Test    public void testParameters() throws Exception {        try {            // bad input array length            double x[] = { 1.0 };            double y[] = { 2.0 };            new PolynomialFunctionLagrangeForm(x, y);            Assert.fail("Expecting MathIllegalArgumentException - bad input array length");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            // mismatch input arrays            double x[] = { 1.0, 2.0, 3.0, 4.0 };            double y[] = { 0.0, -4.0, -24.0 };            new PolynomialFunctionLagrangeForm(x, y);            Assert.fail("Expecting MathIllegalArgumentException - mismatch input arrays");        } catch (MathIllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.polynomials;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.junit.Assert;import org.junit.Test;/** * Test case for Newton form of polynomial function. * <p> * The small tolerance number is used only to account for round-off errors. * * @version $Id$ */public final class PolynomialFunctionNewtonFormTest {    /**     * Test of polynomial for the linear function.     */    @Test    public void testLinearFunction() {        PolynomialFunctionNewtonForm p;        double coefficients[], z, expected, result, tolerance = 1E-12;        // p(x) = 1.5x - 4 = 2 + 1.5(x-4)        double a[] = { 2.0, 1.5 };        double c[] = { 4.0 };        p = new PolynomialFunctionNewtonForm(a, c);        z = 2.0; expected = -1.0; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        z = 4.5; expected = 2.75; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        z = 6.0; expected = 5.0; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        Assert.assertEquals(1, p.degree());        coefficients = p.getCoefficients();        Assert.assertEquals(2, coefficients.length);        Assert.assertEquals(-4.0, coefficients[0], tolerance);        Assert.assertEquals(1.5, coefficients[1], tolerance);    }    /**     * Test of polynomial for the quadratic function.     */    @Test    public void testQuadraticFunction() {        PolynomialFunctionNewtonForm p;        double coefficients[], z, expected, result, tolerance = 1E-12;        // p(x) = 2x^2 + 5x - 3 = 4 + 3(x-1) + 2(x-1)(x+2)        double a[] = { 4.0, 3.0, 2.0 };        double c[] = { 1.0, -2.0 };        p = new PolynomialFunctionNewtonForm(a, c);        z = 1.0; expected = 4.0; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        z = 2.5; expected = 22.0; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        z = -2.0; expected = -5.0; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        Assert.assertEquals(2, p.degree());        coefficients = p.getCoefficients();        Assert.assertEquals(3, coefficients.length);        Assert.assertEquals(-3.0, coefficients[0], tolerance);        Assert.assertEquals(5.0, coefficients[1], tolerance);        Assert.assertEquals(2.0, coefficients[2], tolerance);    }    /**     * Test of polynomial for the quintic function.     */    @Test    public void testQuinticFunction() {        PolynomialFunctionNewtonForm p;        double coefficients[], z, expected, result, tolerance = 1E-12;        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x        //      = 6x - 6x^2 -6x^2(x-1) + x^2(x-1)(x+1) + x^2(x-1)(x+1)(x-2)        double a[] = { 0.0, 6.0, -6.0, -6.0, 1.0, 1.0 };        double c[] = { 0.0, 0.0, 1.0, -1.0, 2.0 };        p = new PolynomialFunctionNewtonForm(a, c);        z = 0.0; expected = 0.0; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        z = -2.0; expected = 0.0; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        z = 4.0; expected = 360.0; result = p.value(z);        Assert.assertEquals(expected, result, tolerance);        Assert.assertEquals(5, p.degree());        coefficients = p.getCoefficients();        Assert.assertEquals(6, coefficients.length);        Assert.assertEquals(0.0, coefficients[0], tolerance);        Assert.assertEquals(6.0, coefficients[1], tolerance);        Assert.assertEquals(1.0, coefficients[2], tolerance);        Assert.assertEquals(-7.0, coefficients[3], tolerance);        Assert.assertEquals(-1.0, coefficients[4], tolerance);        Assert.assertEquals(1.0, coefficients[5], tolerance);    }    /**     * Test of parameters for the polynomial.     */    @Test    public void testParameters() throws Exception {        try {            // bad input array length            double a[] = { 1.0 };            double c[] = { 2.0 };            new PolynomialFunctionNewtonForm(a, c);            Assert.fail("Expecting MathIllegalArgumentException - bad input array length");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            // mismatch input arrays            double a[] = { 1.0, 2.0, 3.0, 4.0 };            double c[] = { 4.0, 3.0, 2.0, 1.0 };            new PolynomialFunctionNewtonForm(a, c);            Assert.fail("Expecting MathIllegalArgumentException - mismatch input arrays");        } catch (MathIllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.polynomials;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Test;import org.junit.Assert;/** * Tests the PolynomialFunction implementation of a UnivariateRealFunction. * * @version $Id$ */public final class PolynomialFunctionTest {    /** Error tolerance for tests */    protected double tolerance = 1e-12;    /**     * tests the value of a constant polynomial.     *     * <p>value of this is 2.5 everywhere.</p>     */    @Test    public void testConstants() {        double[] c = { 2.5 };        PolynomialFunction f = new PolynomialFunction(c);        // verify that we are equal to c[0] at several (nonsymmetric) places        Assert.assertEquals(f.value(0), c[0], tolerance);        Assert.assertEquals(f.value(-1), c[0], tolerance);        Assert.assertEquals(f.value(-123.5), c[0], tolerance);        Assert.assertEquals(f.value(3), c[0], tolerance);        Assert.assertEquals(f.value(456.89), c[0], tolerance);        Assert.assertEquals(f.degree(), 0);        Assert.assertEquals(f.derivative().value(0), 0, tolerance);        Assert.assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);    }    /**     * tests the value of a linear polynomial.     *     * <p>This will test the function f(x) = 3*x - 1.5</p>     * <p>This will have the values     *  <tt>f(0) = -1.5, f(-1) = -4.5, f(-2.5) = -9,     *      f(0.5) = 0, f(1.5) = 3</tt> and <tt>f(3) = 7.5</tt>     * </p>     */    @Test    public void testLinear() {        double[] c = { -1.5, 3 };        PolynomialFunction f = new PolynomialFunction(c);        // verify that we are equal to c[0] when x=0        Assert.assertEquals(f.value(0), c[0], tolerance);        // now check a few other places        Assert.assertEquals(-4.5, f.value(-1), tolerance);        Assert.assertEquals(-9, f.value(-2.5), tolerance);        Assert.assertEquals(0, f.value(0.5), tolerance);        Assert.assertEquals(3, f.value(1.5), tolerance);        Assert.assertEquals(7.5, f.value(3), tolerance);        Assert.assertEquals(f.degree(), 1);        Assert.assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);    }    /**     * Tests a second order polynomial.     * <p> This will test the function f(x) = 2x^2 - 3x -2 = (2x+1)(x-2)</p>     */    @Test    public void testQuadratic() {        double[] c = { -2, -3, 2 };        PolynomialFunction f = new PolynomialFunction(c);        // verify that we are equal to c[0] when x=0        Assert.assertEquals(f.value(0), c[0], tolerance);        // now check a few other places        Assert.assertEquals(0, f.value(-0.5), tolerance);        Assert.assertEquals(0, f.value(2), tolerance);        Assert.assertEquals(-2, f.value(1.5), tolerance);        Assert.assertEquals(7, f.value(-1.5), tolerance);        Assert.assertEquals(265.5312, f.value(12.34), tolerance);    }    /**     * This will test the quintic function     *   f(x) = x^2(x-5)(x+3)(x-1) = x^5 - 3x^4 -13x^3 + 15x^2</p>     */    @Test    public void testQuintic() {        double[] c = { 0, 0, 15, -13, -3, 1 };        PolynomialFunction f = new PolynomialFunction(c);        // verify that we are equal to c[0] when x=0        Assert.assertEquals(f.value(0), c[0], tolerance);        // now check a few other places        Assert.assertEquals(0, f.value(5), tolerance);        Assert.assertEquals(0, f.value(1), tolerance);        Assert.assertEquals(0, f.value(-3), tolerance);        Assert.assertEquals(54.84375, f.value(-1.5), tolerance);        Assert.assertEquals(-8.06637, f.value(1.3), tolerance);        Assert.assertEquals(f.degree(), 5);    }    /**     * tests the firstDerivative function by comparison     *     * <p>This will test the functions     * <tt>f(x) = x^3 - 2x^2 + 6x + 3, g(x) = 3x^2 - 4x + 6</tt>     * and <tt>h(x) = 6x - 4</tt>     */    @Test    public void testfirstDerivativeComparison() {        double[] f_coeff = { 3, 6, -2, 1 };        double[] g_coeff = { 6, -4, 3 };        double[] h_coeff = { -4, 6 };        PolynomialFunction f = new PolynomialFunction(f_coeff);        PolynomialFunction g = new PolynomialFunction(g_coeff);        PolynomialFunction h = new PolynomialFunction(h_coeff);        // compare f' = g        Assert.assertEquals(f.derivative().value(0), g.value(0), tolerance);        Assert.assertEquals(f.derivative().value(1), g.value(1), tolerance);        Assert.assertEquals(f.derivative().value(100), g.value(100), tolerance);        Assert.assertEquals(f.derivative().value(4.1), g.value(4.1), tolerance);        Assert.assertEquals(f.derivative().value(-3.25), g.value(-3.25), tolerance);        // compare g' = h        Assert.assertEquals(g.derivative().value(FastMath.PI), h.value(FastMath.PI), tolerance);        Assert.assertEquals(g.derivative().value(FastMath.E),  h.value(FastMath.E),  tolerance);    }    @Test    public void testString() {        PolynomialFunction p = new PolynomialFunction(new double[] { -5, 3, 1 });        checkPolynomial(p, "-5 + 3 x + x^2");        checkPolynomial(new PolynomialFunction(new double[] { 0, -2, 3 }),                        "-2 x + 3 x^2");        checkPolynomial(new PolynomialFunction(new double[] { 1, -2, 3 }),                      "1 - 2 x + 3 x^2");        checkPolynomial(new PolynomialFunction(new double[] { 0,  2, 3 }),                       "2 x + 3 x^2");        checkPolynomial(new PolynomialFunction(new double[] { 1,  2, 3 }),                     "1 + 2 x + 3 x^2");        checkPolynomial(new PolynomialFunction(new double[] { 1,  0, 3 }),                     "1 + 3 x^2");        checkPolynomial(new PolynomialFunction(new double[] { 0 }),                     "0");    }    @Test    public void testAddition() {        PolynomialFunction p1 = new PolynomialFunction(new double[] { -2, 1 });        PolynomialFunction p2 = new PolynomialFunction(new double[] { 2, -1, 0 });        checkNullPolynomial(p1.add(p2));        p2 = p1.add(p1);        checkPolynomial(p2, "-4 + 2 x");        p1 = new PolynomialFunction(new double[] { 1, -4, 2 });        p2 = new PolynomialFunction(new double[] { -1, 3, -2 });        p1 = p1.add(p2);        Assert.assertEquals(1, p1.degree());        checkPolynomial(p1, "-x");    }    @Test    public void testSubtraction() {        PolynomialFunction p1 = new PolynomialFunction(new double[] { -2, 1 });        checkNullPolynomial(p1.subtract(p1));        PolynomialFunction p2 = new PolynomialFunction(new double[] { -2, 6 });        p2 = p2.subtract(p1);        checkPolynomial(p2, "5 x");        p1 = new PolynomialFunction(new double[] { 1, -4, 2 });        p2 = new PolynomialFunction(new double[] { -1, 3, 2 });        p1 = p1.subtract(p2);        Assert.assertEquals(1, p1.degree());        checkPolynomial(p1, "2 - 7 x");    }    @Test    public void testMultiplication() {        PolynomialFunction p1 = new PolynomialFunction(new double[] { -3, 2 });        PolynomialFunction p2 = new PolynomialFunction(new double[] { 3, 2, 1 });        checkPolynomial(p1.multiply(p2), "-9 + x^2 + 2 x^3");        p1 = new PolynomialFunction(new double[] { 0, 1 });        p2 = p1;        for (int i = 2; i < 10; ++i) {            p2 = p2.multiply(p1);            checkPolynomial(p2, "x^" + i);        }    }    @Test    public void testSerial() {        PolynomialFunction p2 = new PolynomialFunction(new double[] { 3, 2, 1 });        Assert.assertEquals(p2, TestUtils.serializeAndRecover(p2));    }    /**     * tests the firstDerivative function by comparison     *     * <p>This will test the functions     * <tt>f(x) = x^3 - 2x^2 + 6x + 3, g(x) = 3x^2 - 4x + 6</tt>     * and <tt>h(x) = 6x - 4</tt>     */    @Test    public void testMath341() {        double[] f_coeff = { 3, 6, -2, 1 };        double[] g_coeff = { 6, -4, 3 };        double[] h_coeff = { -4, 6 };        PolynomialFunction f = new PolynomialFunction(f_coeff);        PolynomialFunction g = new PolynomialFunction(g_coeff);        PolynomialFunction h = new PolynomialFunction(h_coeff);        // compare f' = g        Assert.assertEquals(f.derivative().value(0), g.value(0), tolerance);        Assert.assertEquals(f.derivative().value(1), g.value(1), tolerance);        Assert.assertEquals(f.derivative().value(100), g.value(100), tolerance);        Assert.assertEquals(f.derivative().value(4.1), g.value(4.1), tolerance);        Assert.assertEquals(f.derivative().value(-3.25), g.value(-3.25), tolerance);        // compare g' = h        Assert.assertEquals(g.derivative().value(FastMath.PI), h.value(FastMath.PI), tolerance);        Assert.assertEquals(g.derivative().value(FastMath.E),  h.value(FastMath.E),  tolerance);    }    public void checkPolynomial(PolynomialFunction p, String reference) {        Assert.assertEquals(reference, p.toString());    }    private void checkNullPolynomial(PolynomialFunction p) {        for (double coefficient : p.getCoefficients()) {            Assert.assertEquals(0, coefficient, 1e-15);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.polynomials;import org.apache.commons.math.util.FastMath;import org.junit.Test;import org.junit.Assert;/** * Tests the PolynomialsUtils class. * * @version $Id$ */public class PolynomialsUtilsTest {    @Test    public void testFirstChebyshevPolynomials() {        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(3), "-3 x + 4 x^3");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(2), "-1 + 2 x^2");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(1), "x");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(0), "1");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(7), "-7 x + 56 x^3 - 112 x^5 + 64 x^7");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(6), "-1 + 18 x^2 - 48 x^4 + 32 x^6");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(5), "5 x - 20 x^3 + 16 x^5");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(4), "1 - 8 x^2 + 8 x^4");    }    @Test    public void testChebyshevBounds() {        for (int k = 0; k < 12; ++k) {            PolynomialFunction Tk = PolynomialsUtils.createChebyshevPolynomial(k);            for (double x = -1; x <= 1; x += 0.02) {                Assert.assertTrue(k + " " + Tk.value(x), FastMath.abs(Tk.value(x)) < (1 + 1e-12));            }        }    }    @Test    public void testChebyshevDifferentials() {        for (int k = 0; k < 12; ++k) {            PolynomialFunction Tk0 = PolynomialsUtils.createChebyshevPolynomial(k);            PolynomialFunction Tk1 = Tk0.polynomialDerivative();            PolynomialFunction Tk2 = Tk1.polynomialDerivative();            PolynomialFunction g0 = new PolynomialFunction(new double[] { k * k });            PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -1});            PolynomialFunction g2 = new PolynomialFunction(new double[] { 1, 0, -1 });            PolynomialFunction Tk0g0 = Tk0.multiply(g0);            PolynomialFunction Tk1g1 = Tk1.multiply(g1);            PolynomialFunction Tk2g2 = Tk2.multiply(g2);            checkNullPolynomial(Tk0g0.add(Tk1g1.add(Tk2g2)));        }    }    @Test    public void testFirstHermitePolynomials() {        checkPolynomial(PolynomialsUtils.createHermitePolynomial(3), "-12 x + 8 x^3");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(2), "-2 + 4 x^2");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(1), "2 x");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(0), "1");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(7), "-1680 x + 3360 x^3 - 1344 x^5 + 128 x^7");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(6), "-120 + 720 x^2 - 480 x^4 + 64 x^6");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(5), "120 x - 160 x^3 + 32 x^5");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(4), "12 - 48 x^2 + 16 x^4");    }    @Test    public void testHermiteDifferentials() {        for (int k = 0; k < 12; ++k) {            PolynomialFunction Hk0 = PolynomialsUtils.createHermitePolynomial(k);            PolynomialFunction Hk1 = Hk0.polynomialDerivative();            PolynomialFunction Hk2 = Hk1.polynomialDerivative();            PolynomialFunction g0 = new PolynomialFunction(new double[] { 2 * k });            PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -2 });            PolynomialFunction g2 = new PolynomialFunction(new double[] { 1 });            PolynomialFunction Hk0g0 = Hk0.multiply(g0);            PolynomialFunction Hk1g1 = Hk1.multiply(g1);            PolynomialFunction Hk2g2 = Hk2.multiply(g2);            checkNullPolynomial(Hk0g0.add(Hk1g1.add(Hk2g2)));        }    }    @Test    public void testFirstLaguerrePolynomials() {        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(3), 6l, "6 - 18 x + 9 x^2 - x^3");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(2), 2l, "2 - 4 x + x^2");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(1), 1l, "1 - x");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(0), 1l, "1");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(7), 5040l,                "5040 - 35280 x + 52920 x^2 - 29400 x^3"                + " + 7350 x^4 - 882 x^5 + 49 x^6 - x^7");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(6),  720l,                "720 - 4320 x + 5400 x^2 - 2400 x^3 + 450 x^4"                + " - 36 x^5 + x^6");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(5),  120l,        "120 - 600 x + 600 x^2 - 200 x^3 + 25 x^4 - x^5");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(4),   24l,        "24 - 96 x + 72 x^2 - 16 x^3 + x^4");    }    @Test    public void testLaguerreDifferentials() {        for (int k = 0; k < 12; ++k) {            PolynomialFunction Lk0 = PolynomialsUtils.createLaguerrePolynomial(k);            PolynomialFunction Lk1 = Lk0.polynomialDerivative();            PolynomialFunction Lk2 = Lk1.polynomialDerivative();            PolynomialFunction g0 = new PolynomialFunction(new double[] { k });            PolynomialFunction g1 = new PolynomialFunction(new double[] { 1, -1 });            PolynomialFunction g2 = new PolynomialFunction(new double[] { 0, 1 });            PolynomialFunction Lk0g0 = Lk0.multiply(g0);            PolynomialFunction Lk1g1 = Lk1.multiply(g1);            PolynomialFunction Lk2g2 = Lk2.multiply(g2);            checkNullPolynomial(Lk0g0.add(Lk1g1.add(Lk2g2)));        }    }    @Test    public void testFirstLegendrePolynomials() {        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(3),  2l, "-3 x + 5 x^3");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(2),  2l, "-1 + 3 x^2");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(1),  1l, "x");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(0),  1l, "1");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(7), 16l, "-35 x + 315 x^3 - 693 x^5 + 429 x^7");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(6), 16l, "-5 + 105 x^2 - 315 x^4 + 231 x^6");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(5),  8l, "15 x - 70 x^3 + 63 x^5");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(4),  8l, "3 - 30 x^2 + 35 x^4");    }    @Test    public void testLegendreDifferentials() {        for (int k = 0; k < 12; ++k) {            PolynomialFunction Pk0 = PolynomialsUtils.createLegendrePolynomial(k);            PolynomialFunction Pk1 = Pk0.polynomialDerivative();            PolynomialFunction Pk2 = Pk1.polynomialDerivative();            PolynomialFunction g0 = new PolynomialFunction(new double[] { k * (k + 1) });            PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -2 });            PolynomialFunction g2 = new PolynomialFunction(new double[] { 1, 0, -1 });            PolynomialFunction Pk0g0 = Pk0.multiply(g0);            PolynomialFunction Pk1g1 = Pk1.multiply(g1);            PolynomialFunction Pk2g2 = Pk2.multiply(g2);            checkNullPolynomial(Pk0g0.add(Pk1g1.add(Pk2g2)));        }    }    @Test    public void testHighDegreeLegendre() {        PolynomialsUtils.createLegendrePolynomial(40);        double[] l40 = PolynomialsUtils.createLegendrePolynomial(40).getCoefficients();        double denominator = 274877906944d;        double[] numerators = new double[] {                          +34461632205d,            -28258538408100d,          +3847870979902950d,        -207785032914759300d,                  +5929294332103310025d,     -103301483474866556880d,    +1197358103913226000200d,    -9763073770369381232400d,              +58171647881784229843050d,  -260061484647976556945400d,  +888315281771246239250340d, -2345767627188139419665400d,            +4819022625419112503443050d, -7710436200670580005508880d, +9566652323054238154983240d, -9104813935044723209570256d,            +6516550296251767619752905d, -3391858621221953912598660d, +1211378079007840683070950d,  -265365894974690562152100d,              +26876802183334044115405d        };        for (int i = 0; i < l40.length; ++i) {            if (i % 2 == 0) {                double ci = numerators[i / 2] / denominator;                Assert.assertEquals(ci, l40[i], FastMath.abs(ci) * 1e-15);            } else {                Assert.assertEquals(0, l40[i], 0);            }        }    }    private void checkPolynomial(PolynomialFunction p, long denominator, String reference) {        PolynomialFunction q = new PolynomialFunction(new double[] { denominator});        Assert.assertEquals(reference, p.multiply(q).toString());    }    private void checkPolynomial(PolynomialFunction p, String reference) {        Assert.assertEquals(reference, p.toString());    }    private void checkNullPolynomial(PolynomialFunction p) {        for (double coefficient : p.getCoefficients()) {            Assert.assertEquals(0, coefficient, 1e-13);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.polynomials;import java.util.Arrays;import org.apache.commons.math.exception.OutOfRangeException;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.exception.MathIllegalStateException;import org.junit.Assert;import org.junit.Test;/** * Tests the PolynomialSplineFunction implementation. * * @version $Id$ */public class PolynomialSplineFunctionTest {    /** Error tolerance for tests */    protected double tolerance = 1.0e-12;    /**     * Quadratic polynomials used in tests:     *     * x^2 + x            [-1, 0)     * x^2 + x + 2        [0, 1)     * x^2 + x + 4        [1, 2)     *     * Defined so that evaluation using PolynomialSplineFunction evaluation     * algorithm agrees at knot point boundaries.     */    protected PolynomialFunction[] polynomials = {        new PolynomialFunction(new double[] {0d, 1d, 1d}),        new PolynomialFunction(new double[] {2d, 1d, 1d}),        new PolynomialFunction(new double[] {4d, 1d, 1d})    };    /** Knot points  */    protected double[] knots = {-1, 0, 1, 2};    /** Derivative of test polynomials -- 2x + 1  */    protected PolynomialFunction dp =        new PolynomialFunction(new double[] {1d, 2d});    @Test    public void testConstructor() {        PolynomialSplineFunction spline =            new PolynomialSplineFunction(knots, polynomials);        Assert.assertTrue(Arrays.equals(knots, spline.getKnots()));        Assert.assertEquals(1d, spline.getPolynomials()[0].getCoefficients()[2], 0);        Assert.assertEquals(3, spline.getN());        try { // too few knots            new PolynomialSplineFunction(new double[] {0}, polynomials);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try { // too many knots            new PolynomialSplineFunction(new double[] {0,1,2,3,4}, polynomials);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try { // knots not increasing            new PolynomialSplineFunction(new double[] {0,1, 3, 2}, polynomials);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testValues() throws Exception {        PolynomialSplineFunction spline =            new PolynomialSplineFunction(knots, polynomials);        UnivariateRealFunction dSpline = spline.derivative();        /**         * interior points -- spline value at x should equal p(x - knot)         * where knot is the largest knot point less than or equal to x and p         * is the polynomial defined over the knot segment to which x belongs.         */        double x = -1;        int index = 0;        for (int i = 0; i < 10; i++) {           x+=0.25;           index = findKnot(knots, x);           Assert.assertEquals("spline function evaluation failed for x=" + x,                   polynomials[index].value(x - knots[index]), spline.value(x), tolerance);           Assert.assertEquals("spline derivative evaluation failed for x=" + x,                   dp.value(x - knots[index]), dSpline.value(x), tolerance);        }        // knot points -- centering should zero arguments        for (int i = 0; i < 3; i++) {            Assert.assertEquals("spline function evaluation failed for knot=" + knots[i],                    polynomials[i].value(0), spline.value(knots[i]), tolerance);            Assert.assertEquals("spline function evaluation failed for knot=" + knots[i],                    dp.value(0), dSpline.value(knots[i]), tolerance);        }        try { //outside of domain -- under min            x = spline.value(-1.5);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try { //outside of domain -- over max            x = spline.value(2.5);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    /**     *  Do linear search to find largest knot point less than or equal to x.     *  Implementation does binary search.     */     protected int findKnot(double[] knots, double x) {         if (x < knots[0] || x >= knots[knots.length -1]) {             throw new OutOfRangeException(x, knots[0], knots[knots.length -1]);         }         for (int i = 0; i < knots.length; i++) {             if (knots[i] > x) {                 return i - 1;             }         }         throw new MathIllegalStateException();     }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.analysis.function.Identity;import org.apache.commons.math.analysis.function.Constant;import org.apache.commons.math.analysis.function.Minus;import org.apache.commons.math.analysis.function.Inverse;import org.apache.commons.math.analysis.function.Power;import org.apache.commons.math.analysis.function.Sin;import org.apache.commons.math.analysis.function.Sinc;import org.apache.commons.math.analysis.BivariateRealFunction;import org.apache.commons.math.analysis.function.Add;import org.apache.commons.math.analysis.function.Multiply;import org.apache.commons.math.analysis.function.Divide;import org.apache.commons.math.analysis.function.Min;import org.apache.commons.math.analysis.function.Max;import org.apache.commons.math.analysis.function.Pow;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.junit.Assert;import org.junit.Test;/** * Test for {@link FunctionUtils}. */public class FunctionUtilsTest {    private final double EPS = Math.ulp(1d);    @Test    public void testCompose() {        UnivariateRealFunction id = new Identity();        Assert.assertEquals(3, FunctionUtils.compose(id, id, id).value(3), EPS);        UnivariateRealFunction c = new Constant(4);        Assert.assertEquals(4, FunctionUtils.compose(id, c).value(3), EPS);        Assert.assertEquals(4, FunctionUtils.compose(c, id).value(3), EPS);        UnivariateRealFunction m = new Minus();        Assert.assertEquals(-3, FunctionUtils.compose(m).value(3), EPS);        Assert.assertEquals(3, FunctionUtils.compose(m, m).value(3), EPS);        UnivariateRealFunction inv = new Inverse();        Assert.assertEquals(-0.25, FunctionUtils.compose(inv, m, c, id).value(3), EPS);        UnivariateRealFunction pow = new Power(2);        Assert.assertEquals(81, FunctionUtils.compose(pow, pow).value(3), EPS);    }    @Test    public void testAdd() {        UnivariateRealFunction id = new Identity();        UnivariateRealFunction c = new Constant(4);        UnivariateRealFunction m = new Minus();        UnivariateRealFunction inv = new Inverse();        Assert.assertEquals(4.5, FunctionUtils.add(inv, m, c, id).value(2), EPS);        Assert.assertEquals(4 + 2, FunctionUtils.add(c, id).value(2), EPS);        Assert.assertEquals(4 - 2, FunctionUtils.add(c, FunctionUtils.compose(m, id)).value(2), EPS);    }    @Test    public void testMultiply() {        UnivariateRealFunction c = new Constant(4);        Assert.assertEquals(16, FunctionUtils.multiply(c, c).value(12345), EPS);        UnivariateRealFunction inv = new Inverse();        UnivariateRealFunction pow = new Power(2);        Assert.assertEquals(1, FunctionUtils.multiply(FunctionUtils.compose(inv, pow), pow).value(3.5), EPS);    }    @Test    public void testCombine() {        BivariateRealFunction bi = new Add();        UnivariateRealFunction id = new Identity();        UnivariateRealFunction m = new Minus();        UnivariateRealFunction c = FunctionUtils.combine(bi, id, m);        Assert.assertEquals(0, c.value(2.3456), EPS);        bi = new Multiply();        UnivariateRealFunction inv = new Inverse();        c = FunctionUtils.combine(bi, id, inv);        Assert.assertEquals(1, c.value(2.3456), EPS);    }    @Test    public void testCollector() {        BivariateRealFunction bi = new Add();        MultivariateRealFunction coll = FunctionUtils.collector(bi, 0);        Assert.assertEquals(10, coll.value(new double[] {1, 2, 3, 4}), EPS);        bi = new Multiply();        coll = FunctionUtils.collector(bi, 1);        Assert.assertEquals(24, coll.value(new double[] {1, 2, 3, 4}), EPS);        bi = new Max();        coll = FunctionUtils.collector(bi, Double.NEGATIVE_INFINITY);        Assert.assertEquals(10, coll.value(new double[] {1, -2, 7.5, 10, -24, 9.99}), 0);        bi = new Min();        coll = FunctionUtils.collector(bi, Double.POSITIVE_INFINITY);        Assert.assertEquals(-24, coll.value(new double[] {1, -2, 7.5, 10, -24, 9.99}), 0);    }    @Test    public void testSinc() {        BivariateRealFunction div = new Divide();        UnivariateRealFunction sin = new Sin();        UnivariateRealFunction id = new Identity();        UnivariateRealFunction sinc1 = FunctionUtils.combine(div, sin, id);        UnivariateRealFunction sinc2 = new Sinc();        for (int i = 0; i < 10; i++) {            double x = Math.random();            Assert.assertEquals(sinc1.value(x), sinc2.value(x), EPS);        }    }    @Test    public void testFixingArguments() {        UnivariateRealFunction scaler = FunctionUtils.fix1stArgument(new Multiply(), 10);        Assert.assertEquals(1.23456, scaler.value(0.123456), EPS);        UnivariateRealFunction pow1 = new Power(2);        UnivariateRealFunction pow2 = FunctionUtils.fix2ndArgument(new Pow(), 2);        for (int i = 0; i < 10; i++) {            double x = Math.random() * 10;            Assert.assertEquals(pow1.value(x), pow2.value(x), 0);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.rank;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */public class MaxTest extends StorelessUnivariateStatisticAbstractTest {    protected Max stat;    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Max();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.max;    }    @Test    public void testSpecialValues() {        double[] testArray = {0d, Double.NaN, Double.NEGATIVE_INFINITY,                Double.POSITIVE_INFINITY};        Max max = new Max();        Assert.assertTrue(Double.isNaN(max.getResult()));        max.increment(testArray[0]);        Assert.assertEquals(0d, max.getResult(), 0);        max.increment(testArray[1]);        Assert.assertEquals(0d, max.getResult(), 0);        max.increment(testArray[2]);        Assert.assertEquals(0d, max.getResult(), 0);        max.increment(testArray[3]);        Assert.assertEquals(Double.POSITIVE_INFINITY, max.getResult(), 0);        Assert.assertEquals(Double.POSITIVE_INFINITY, max.evaluate(testArray), 0);    }    @Test    public void testNaNs() {        Max max = new Max();        double nan = Double.NaN;        Assert.assertEquals(3d, max.evaluate(new double[]{nan, 2d, 3d}), 0);        Assert.assertEquals(3d, max.evaluate(new double[]{1d, nan, 3d}), 0);        Assert.assertEquals(2d, max.evaluate(new double[]{1d, 2d, nan}), 0);        Assert.assertTrue(Double.isNaN(max.evaluate(new double[]{nan, nan, nan})));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.rank;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */public class PercentileTest extends UnivariateStatisticAbstractTest{    protected Percentile stat;    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Percentile(95.0);    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.percentile95;    }    @Test    public void testHighPercentile(){        double[] d = new double[]{1, 2, 3};        Percentile p = new Percentile(75);        Assert.assertEquals(3.0, p.evaluate(d), 1.0e-5);    }        @Test    public void testLowPercentile() {        double[] d = new double[] {0, 1};        Percentile p = new Percentile(25);        Assert.assertEquals(0d, p.evaluate(d), Double.MIN_VALUE);    }    @Test    public void testPercentile() {        double[] d = new double[] {1, 3, 2, 4};        Percentile p = new Percentile(30);        Assert.assertEquals(1.5, p.evaluate(d), 1.0e-5);        p.setQuantile(25);        Assert.assertEquals(1.25, p.evaluate(d), 1.0e-5);        p.setQuantile(75);        Assert.assertEquals(3.75, p.evaluate(d), 1.0e-5);        p.setQuantile(50);        Assert.assertEquals(2.5, p.evaluate(d), 1.0e-5);        // invalid percentiles        try {            p.evaluate(d, 0, d.length, -1.0);            Assert.fail();        } catch (MathIllegalArgumentException ex) {            // success        }        try {            p.evaluate(d, 0, d.length, 101.0);            Assert.fail();        } catch (MathIllegalArgumentException ex) {            // success        }    }    @Test    public void testNISTExample() {        double[] d = new double[] {95.1772, 95.1567, 95.1937, 95.1959,                95.1442, 95.0610,  95.1591, 95.1195, 95.1772, 95.0925, 95.1990, 95.1682        };        Percentile p = new Percentile(90);        Assert.assertEquals(95.1981, p.evaluate(d), 1.0e-4);        Assert.assertEquals(95.1990, p.evaluate(d,0,d.length, 100d), 0);    }    @Test    public void test5() {        Percentile percentile = new Percentile(5);        Assert.assertEquals(this.percentile5, percentile.evaluate(testArray), getTolerance());    }    @Test    public void testNullEmpty() {        Percentile percentile = new Percentile(50);        double[] nullArray = null;        double[] emptyArray = new double[] {};        try {            percentile.evaluate(nullArray);            Assert.fail("Expecting MathIllegalArgumentException for null array");        } catch (MathIllegalArgumentException ex) {            // expected        }        Assert.assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));    }    @Test    public void testSingleton() {        Percentile percentile = new Percentile(50);        double[] singletonArray = new double[] {1d};        Assert.assertEquals(1d, percentile.evaluate(singletonArray), 0);        Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);        Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 5), 0);        Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 100), 0);        Assert.assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0)));    }    @Test    public void testSpecialValues() {        Percentile percentile = new Percentile(50);        double[] specialValues = new double[] {0d, 1d, 2d, 3d, 4d,  Double.NaN};        Assert.assertEquals(2.5d, percentile.evaluate(specialValues), 0);        specialValues =  new double[] {Double.NEGATIVE_INFINITY, 1d, 2d, 3d,                Double.NaN, Double.POSITIVE_INFINITY};        Assert.assertEquals(2.5d, percentile.evaluate(specialValues), 0);        specialValues = new double[] {1d, 1d, Double.POSITIVE_INFINITY,                Double.POSITIVE_INFINITY};        Assert.assertTrue(Double.isInfinite(percentile.evaluate(specialValues)));        specialValues = new double[] {1d, 1d, Double.NaN,                Double.NaN};        Assert.assertTrue(Double.isNaN(percentile.evaluate(specialValues)));        specialValues = new double[] {1d, 1d, Double.NEGATIVE_INFINITY,                Double.NEGATIVE_INFINITY};        // Interpolation results in NEGATIVE_INFINITY + POSITIVE_INFINITY        Assert.assertTrue(Double.isNaN(percentile.evaluate(specialValues)));    }    @Test    public void testSetQuantile() {        Percentile percentile = new Percentile(10);        percentile.setQuantile(100); // OK        Assert.assertEquals(100, percentile.getQuantile(), 0);        try {            percentile.setQuantile(0);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            new Percentile(0);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.rank;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */public class MedianTest extends UnivariateStatisticAbstractTest{    protected Median stat;    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Median();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.median;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.rank;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */public class MinTest extends StorelessUnivariateStatisticAbstractTest{    protected Min stat;    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Min();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.min;    }    @Test    public void testSpecialValues() {        double[] testArray = {0d, Double.NaN, Double.POSITIVE_INFINITY,                Double.NEGATIVE_INFINITY};        Min min = new Min();        Assert.assertTrue(Double.isNaN(min.getResult()));        min.increment(testArray[0]);        Assert.assertEquals(0d, min.getResult(), 0);        min.increment(testArray[1]);        Assert.assertEquals(0d, min.getResult(), 0);        min.increment(testArray[2]);        Assert.assertEquals(0d, min.getResult(), 0);        min.increment(testArray[3]);        Assert.assertEquals(Double.NEGATIVE_INFINITY, min.getResult(), 0);        Assert.assertEquals(Double.NEGATIVE_INFINITY, min.evaluate(testArray), 0);    }    @Test    public void testNaNs() {        Min min = new Min();        double nan = Double.NaN;        Assert.assertEquals(2d, min.evaluate(new double[]{nan, 2d, 3d}), 0);        Assert.assertEquals(1d, min.evaluate(new double[]{1d, nan, 3d}), 0);        Assert.assertEquals(1d, min.evaluate(new double[]{1d, 2d, nan}), 0);        Assert.assertTrue(Double.isNaN(min.evaluate(new double[]{nan, nan, nan})));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link UnivariateStatistic} class. * * @version $Id$ */public class StandardDeviationTest extends StorelessUnivariateStatisticAbstractTest{    protected StandardDeviation stat;    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new StandardDeviation();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.std;    }    /**     * Make sure Double.NaN is returned iff n = 0     *     */    @Test    public void testNaN() {        StandardDeviation std = new StandardDeviation();        Assert.assertTrue(Double.isNaN(std.getResult()));        std.increment(1d);        Assert.assertEquals(0d, std.getResult(), 0);    }    /**     * Test population version of variance     */    @Test    public void testPopulation() {        double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};        double sigma = populationStandardDeviation(values);        SecondMoment m = new SecondMoment();        m.evaluate(values);  // side effect is to add values        StandardDeviation s1 = new StandardDeviation();        s1.setBiasCorrected(false);        Assert.assertEquals(sigma, s1.evaluate(values), 1E-14);        s1.incrementAll(values);        Assert.assertEquals(sigma, s1.getResult(), 1E-14);        s1 = new StandardDeviation(false, m);        Assert.assertEquals(sigma, s1.getResult(), 1E-14);        s1 = new StandardDeviation(false);        Assert.assertEquals(sigma, s1.evaluate(values), 1E-14);        s1.incrementAll(values);        Assert.assertEquals(sigma, s1.getResult(), 1E-14);    }    /**     * Definitional formula for population standard deviation     */    protected double populationStandardDeviation(double[] v) {        double mean = new Mean().evaluate(v);        double sum = 0;        for (int i = 0; i < v.length; i++) {            sum += (v[i] - mean) * (v[i] - mean);        }        return FastMath.sqrt(sum / v.length);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.StatUtils;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.junit.Assert;import org.junit.Test;public class SemiVarianceTest {    @Test    public void testInsufficientData() {        double[] nothing = null;        SemiVariance sv = new SemiVariance();        try {            sv.evaluate(nothing);            Assert.fail("null is not a valid data array.");        } catch (MathIllegalArgumentException iae) {        }        try {            sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);            sv.evaluate(nothing);            Assert.fail("null is not a valid data array.");        } catch (MathIllegalArgumentException iae) {        }        nothing = new double[] {};        Assert.assertTrue(Double.isNaN(sv.evaluate(nothing)));    }    @Test    public void testSingleDown() {        SemiVariance sv = new SemiVariance();        double[] values = { 50.0d };        double singletest = sv.evaluate(values);        Assert.assertEquals(0.0d, singletest, 0);    }    @Test    public void testSingleUp() {        SemiVariance sv = new SemiVariance(SemiVariance.UPSIDE_VARIANCE);        double[] values = { 50.0d };        double singletest = sv.evaluate(values);        Assert.assertEquals(0.0d, singletest, 0);    }    @Test    public void testSample() {        final double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };        final int length = values.length;        final double mean = StatUtils.mean(values); // 6.333...        final SemiVariance sv = new SemiVariance();  // Default bias correction is true        final double downsideSemiVariance = sv.evaluate(values); // Downside is the default        Assert.assertEquals(TestUtils.sumSquareDev(new double[] {-2d, 2d, 4d, -2d, 3d, 5d}, mean) / (length - 1),                downsideSemiVariance, 1E-14);        sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);        final double upsideSemiVariance = sv.evaluate(values);        Assert.assertEquals(TestUtils.sumSquareDev(new double[] {22d, 11d, 14d}, mean) / (length - 1),                upsideSemiVariance, 1E-14);        // Verify that upper + lower semivariance against the mean sum to variance        Assert.assertEquals(StatUtils.variance(values), downsideSemiVariance + upsideSemiVariance, 10e-12);    }    @Test    public void testPopulation() {        double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };        SemiVariance sv = new SemiVariance(false);        double singletest = sv.evaluate(values);        Assert.assertEquals(19.556d, singletest, 0.01d);        sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);        singletest = sv.evaluate(values);        Assert.assertEquals(36.222d, singletest, 0.01d);    }    @Test    public void testNonMeanCutoffs() {        double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };        SemiVariance sv = new SemiVariance(false); // Turn off bias correction - use df = length        double singletest = sv.evaluate(values, 1.0d, SemiVariance.DOWNSIDE_VARIANCE, false, 0, values.length);        Assert.assertEquals(TestUtils.sumSquareDev(new double[] { -2d, -2d }, 1.0d) / values.length,                singletest, 0.01d);        singletest = sv.evaluate(values, 3.0d, SemiVariance.UPSIDE_VARIANCE, false, 0, values.length);        Assert.assertEquals(TestUtils.sumSquareDev(new double[] { 4d, 22d, 11d, 14d, 5d }, 3.0d) / values.length, singletest,                0.01d);    }    /**     * Check that the lower + upper semivariance against the mean sum to the     * variance.     */    @Test    public void testVarianceDecompMeanCutoff() {        double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };        double variance = StatUtils.variance(values);        SemiVariance sv = new SemiVariance(true); // Bias corrected        sv.setVarianceDirection(SemiVariance.DOWNSIDE_VARIANCE);        final double lower = sv.evaluate(values);        sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);        final double upper = sv.evaluate(values);        Assert.assertEquals(variance, lower + upper, 10e-12);    }    /**     * Check that upper and lower semivariances against a cutoff sum to the sum     * of squared deviations of the full set of values against the cutoff     * divided by df = length - 1 (assuming bias-corrected).     */    @Test    public void testVarianceDecompNonMeanCutoff() {        double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };        double target = 0;        double totalSumOfSquares = TestUtils.sumSquareDev(values, target);        SemiVariance sv = new SemiVariance(true); // Bias corrected        sv.setVarianceDirection(SemiVariance.DOWNSIDE_VARIANCE);        double lower = sv.evaluate(values, target);        sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);        double upper = sv.evaluate(values, target);        Assert.assertEquals(totalSumOfSquares / (values.length - 1), lower + upper, 10e-12);    }    @Test    public void testNoVariance() {        final double[] values = {100d, 100d, 100d, 100d};        SemiVariance sv = new SemiVariance();        Assert.assertEquals(0, sv.evaluate(values), 10E-12);        Assert.assertEquals(0, sv.evaluate(values, 100d), 10E-12);        Assert.assertEquals(0, sv.evaluate(values, 100d, SemiVariance.UPSIDE_VARIANCE, false, 0, values.length), 10E-12);    }}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.TestUtils;import org.junit.Test;import org.junit.Assert;public class VectorialMeanTest {    private double[][] points;    public VectorialMeanTest() {        points = new double[][] {            { 1.2, 2.3,  4.5},            {-0.7, 2.3,  5.0},            { 3.1, 0.0, -3.1},            { 6.0, 1.2,  4.2},            {-0.7, 2.3,  5.0}        };    }    @Test    public void testMismatch() {        try {            new VectorialMean(8).increment(new double[5]);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException dme) {            Assert.assertEquals(5, dme.getArgument());            Assert.assertEquals(8, dme.getDimension());        }    }    @Test    public void testSimplistic() {        VectorialMean stat = new VectorialMean(2);        stat.increment(new double[] {-1.0,  1.0});        stat.increment(new double[] { 1.0, -1.0});        double[] mean = stat.getResult();        Assert.assertEquals(0.0, mean[0], 1.0e-12);        Assert.assertEquals(0.0, mean[1], 1.0e-12);    }    @Test    public void testBasicStats() {        VectorialMean stat = new VectorialMean(points[0].length);        for (int i = 0; i < points.length; ++i) {            stat.increment(points[i]);        }        Assert.assertEquals(points.length, stat.getN());        double[] mean = stat.getResult();        double[]   refMean = new double[] { 1.78, 1.62,  3.12};        for (int i = 0; i < mean.length; ++i) {            Assert.assertEquals(refMean[i], mean[i], 1.0e-12);        }    }    @Test    public void testSerial() {        VectorialMean stat = new VectorialMean(points[0].length);        for (int i = 0; i < points.length; ++i) {            stat.increment(points[i]);        }        Assert.assertEquals(stat, TestUtils.serializeAndRecover(stat));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link FourthMoment} class. * @version $Id$ */public class FourthMomentTest extends StorelessUnivariateStatisticAbstractTest{    /** descriptive statistic. */    protected FourthMoment stat;    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new FourthMoment();    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    @Override    public double expectedValue() {       return this.fourthMoment;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link ThirdMoment} class. * @version $Id$ */public class ThirdMomentTest extends StorelessUnivariateStatisticAbstractTest{    /** descriptive statistic. */    protected ThirdMoment stat;    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new ThirdMoment();    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    @Override    public double expectedValue() {      return this.thirdMoment;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */public class KurtosisTest extends StorelessUnivariateStatisticAbstractTest{    protected Kurtosis stat;    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Kurtosis();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.kurt;    }    /**     * Make sure Double.NaN is returned iff n < 4     *     */    @Test    public void testNaN() {        Kurtosis kurt = new Kurtosis();        Assert.assertTrue(Double.isNaN(kurt.getResult()));        kurt.increment(1d);        Assert.assertTrue(Double.isNaN(kurt.getResult()));        kurt.increment(1d);        Assert.assertTrue(Double.isNaN(kurt.getResult()));        kurt.increment(1d);        Assert.assertTrue(Double.isNaN(kurt.getResult()));        kurt.increment(1d);        Assert.assertFalse(Double.isNaN(kurt.getResult()));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link UnivariateStatistic} class. * * @version $Id$ */public class SkewnessTest extends StorelessUnivariateStatisticAbstractTest{    protected Skewness stat;    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Skewness();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.skew;    }    /**     * Make sure Double.NaN is returned iff n < 3     *     */    @Test    public void testNaN() {        Skewness skew = new Skewness();        Assert.assertTrue(Double.isNaN(skew.getResult()));        skew.increment(1d);        Assert.assertTrue(Double.isNaN(skew.getResult()));        skew.increment(1d);        Assert.assertTrue(Double.isNaN(skew.getResult()));        skew.increment(1d);        Assert.assertFalse(Double.isNaN(skew.getResult()));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.apache.commons.math.util.MathUtils;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link UnivariateStatistic} class. * * @version $Id$ */public class VarianceTest extends StorelessUnivariateStatisticAbstractTest{    protected Variance stat;    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Variance();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.var;    }    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */    public double expectedWeightedValue() {        return this.weightedVar;    }    /**     * Make sure Double.NaN is returned iff n = 0     *     */    @Test    public void testNaN() {        StandardDeviation std = new StandardDeviation();        Assert.assertTrue(Double.isNaN(std.getResult()));        std.increment(1d);        Assert.assertEquals(0d, std.getResult(), 0);    }    /**     * Test population version of variance     */    @Test    public void testPopulation() {        double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};        SecondMoment m = new SecondMoment();        m.evaluate(values);  // side effect is to add values        Variance v1 = new Variance();        v1.setBiasCorrected(false);        Assert.assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);        v1.incrementAll(values);        Assert.assertEquals(populationVariance(values), v1.getResult(), 1E-14);        v1 = new Variance(false, m);        Assert.assertEquals(populationVariance(values), v1.getResult(), 1E-14);        v1 = new Variance(false);        Assert.assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);        v1.incrementAll(values);        Assert.assertEquals(populationVariance(values), v1.getResult(), 1E-14);    }    /**     * Definitional formula for population variance     */    protected double populationVariance(double[] v) {        double mean = new Mean().evaluate(v);        double sum = 0;        for (int i = 0; i < v.length; i++) {           sum += (v[i] - mean) * (v[i] - mean);        }        return sum / v.length;    }    @Test    public void testWeightedVariance() {        Variance variance = new Variance();        Assert.assertEquals(expectedWeightedValue(),                variance.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());        // All weights = 1 -> weighted variance = unweighted variance        Assert.assertEquals(expectedValue(),                variance.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());        // All weights the same -> when weights are normalized to sum to the length of the values array,        // weighted variance = unweighted value        Assert.assertEquals(expectedValue(),                variance.evaluate(testArray, MathUtils.normalizeArray(identicalWeightsArray, testArray.length),                        0, testArray.length), getTolerance());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link FirstMoment} class. * @version $Id$ */public class FirstMomentTest extends StorelessUnivariateStatisticAbstractTest{    /** descriptive statistic. */    protected FirstMoment stat;    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new FirstMoment();    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    @Override    public double expectedValue() {        return this.mean;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */public class GeometricMeanTest extends StorelessUnivariateStatisticAbstractTest{    protected GeometricMean stat;    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new GeometricMean();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.geoMean;    }    @Test    public void testSpecialValues() {        GeometricMean mean = new GeometricMean();        // empty        Assert.assertTrue(Double.isNaN(mean.getResult()));        // finite data        mean.increment(1d);        Assert.assertFalse(Double.isNaN(mean.getResult()));        // add 0 -- makes log sum blow to minus infinity, should make 0        mean.increment(0d);        Assert.assertEquals(0d, mean.getResult(), 0);        // add positive infinity - note the minus infinity above        mean.increment(Double.POSITIVE_INFINITY);        Assert.assertTrue(Double.isNaN(mean.getResult()));        // clear        mean.clear();        Assert.assertTrue(Double.isNaN(mean.getResult()));        // positive infinity by itself        mean.increment(Double.POSITIVE_INFINITY);        Assert.assertEquals(Double.POSITIVE_INFINITY, mean.getResult(), 0);        // negative value -- should make NaN        mean.increment(-2d);        Assert.assertTrue(Double.isNaN(mean.getResult()));    }}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.linear.RealMatrix;import org.junit.Test;import org.junit.Assert;public class VectorialCovarianceTest {    private double[][] points;    public VectorialCovarianceTest() {        points = new double[][] {            { 1.2, 2.3,  4.5},            {-0.7, 2.3,  5.0},            { 3.1, 0.0, -3.1},            { 6.0, 1.2,  4.2},            {-0.7, 2.3,  5.0}        };    }    @Test    public void testMismatch() {        try {            new VectorialCovariance(8, true).increment(new double[5]);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException dme) {            Assert.assertEquals(5, dme.getArgument());            Assert.assertEquals(8, dme.getDimension());        }    }    @Test    public void testSimplistic() {        VectorialCovariance stat = new VectorialCovariance(2, true);        stat.increment(new double[] {-1.0,  1.0});        stat.increment(new double[] { 1.0, -1.0});        RealMatrix c = stat.getResult();        Assert.assertEquals( 2.0, c.getEntry(0, 0), 1.0e-12);        Assert.assertEquals(-2.0, c.getEntry(1, 0), 1.0e-12);        Assert.assertEquals( 2.0, c.getEntry(1, 1), 1.0e-12);    }    @Test    public void testBasicStats() {        VectorialCovariance stat = new VectorialCovariance(points[0].length, true);        for (int i = 0; i < points.length; ++i) {            stat.increment(points[i]);        }        Assert.assertEquals(points.length, stat.getN());        RealMatrix c = stat.getResult();        double[][] refC    = new double[][] {                { 8.0470, -1.9195, -3.4445},                {-1.9195,  1.0470,  3.2795},                {-3.4445,  3.2795, 12.2070}        };        for (int i = 0; i < c.getRowDimension(); ++i) {            for (int j = 0; j <= i; ++j) {                Assert.assertEquals(refC[i][j], c.getEntry(i, j), 1.0e-12);            }        }    }    @Test    public void testSerial(){        VectorialCovariance stat = new VectorialCovariance(points[0].length, true);        Assert.assertEquals(stat, TestUtils.serializeAndRecover(stat));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link SecondMoment} class. * @version $Id$ */public class SecondMomentTest extends StorelessUnivariateStatisticAbstractTest {    /** descriptive statistic. */    protected SecondMoment stat;    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new SecondMoment();    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    @Override    public double expectedValue() {        return this.secondMoment;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */public class MeanTest extends StorelessUnivariateStatisticAbstractTest{    protected Mean stat;    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Mean();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.mean;    }    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */    public double expectedWeightedValue() {        return this.weightedMean;    }    @Test    public void testSmallSamples() {        Mean mean = new Mean();        Assert.assertTrue(Double.isNaN(mean.getResult()));        mean.increment(1d);        Assert.assertEquals(1d, mean.getResult(), 0);    }    @Test    public void testWeightedMean() {        Mean mean = new Mean();        Assert.assertEquals(expectedWeightedValue(), mean.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());        Assert.assertEquals(expectedValue(), mean.evaluate(testArray, identicalWeightsArray, 0, testArray.length), getTolerance());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.summary;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link Sum} class. * @version $Id$ */public class SumTest extends StorelessUnivariateStatisticAbstractTest{    protected Sum stat;    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Sum();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.sum;    }    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */    public double expectedWeightedValue() {        return this.weightedSum;    }    @Test    public void testSpecialValues() {        Sum sum = new Sum();        Assert.assertEquals(0, sum.getResult(), 0);        sum.increment(1);        Assert.assertEquals(1, sum.getResult(), 0);        sum.increment(Double.POSITIVE_INFINITY);        Assert.assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);        sum.increment(Double.NEGATIVE_INFINITY);        Assert.assertTrue(Double.isNaN(sum.getResult()));        sum.increment(1);        Assert.assertTrue(Double.isNaN(sum.getResult()));    }    @Test    public void testWeightedSum() {        Sum sum = new Sum();        Assert.assertEquals(expectedWeightedValue(), sum.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());        Assert.assertEquals(expectedValue(), sum.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());    }        @Override    protected void checkClearValue(StorelessUnivariateStatistic statistic){        Assert.assertEquals(0, statistic.getResult(), 0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.summary;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */public class SumLogTest extends StorelessUnivariateStatisticAbstractTest{    protected SumOfLogs stat;    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new SumOfLogs();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.sumLog;    }    @Test    public void testSpecialValues() {        SumOfLogs sum = new SumOfLogs();        // empty        Assert.assertEquals(0, sum.getResult(), 0);        // finite data        sum.increment(1d);        Assert.assertFalse(Double.isNaN(sum.getResult()));        // add negative infinity        sum.increment(0d);        Assert.assertEquals(Double.NEGATIVE_INFINITY, sum.getResult(), 0);        // add positive infinity -- should make NaN        sum.increment(Double.POSITIVE_INFINITY);        Assert.assertTrue(Double.isNaN(sum.getResult()));        // clear        sum.clear();        Assert.assertEquals(0, sum.getResult(), 0);        // positive infinity by itself        sum.increment(Double.POSITIVE_INFINITY);        Assert.assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);        // negative value -- should make NaN        sum.increment(-2d);        Assert.assertTrue(Double.isNaN(sum.getResult()));    }        @Override    protected void checkClearValue(StorelessUnivariateStatistic statistic){        Assert.assertEquals(0, statistic.getResult(), 0);    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.summary;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */public class ProductTest extends StorelessUnivariateStatisticAbstractTest{    protected Product stat;    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Product();    }    /**     * {@inheritDoc}     */    @Override    public double getTolerance() {        return 10E8;    //sic -- big absolute error due to only 15 digits of accuracy in double    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.product;    }    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */    public double expectedWeightedValue() {        return this.weightedProduct;    }    @Test    public void testSpecialValues() {        Product product = new Product();        Assert.assertEquals(1, product.getResult(), 0);        product.increment(1);        Assert.assertEquals(1, product.getResult(), 0);        product.increment(Double.POSITIVE_INFINITY);        Assert.assertEquals(Double.POSITIVE_INFINITY, product.getResult(), 0);        product.increment(Double.NEGATIVE_INFINITY);        Assert.assertEquals(Double.NEGATIVE_INFINITY, product.getResult(), 0);        product.increment(Double.NaN);        Assert.assertTrue(Double.isNaN(product.getResult()));        product.increment(1);        Assert.assertTrue(Double.isNaN(product.getResult()));    }    @Test    public void testWeightedProduct() {        Product product = new Product();        Assert.assertEquals(expectedWeightedValue(), product.evaluate(testArray, testWeightsArray, 0, testArray.length),getTolerance());        Assert.assertEquals(expectedValue(), product.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());    }        @Override    protected void checkClearValue(StorelessUnivariateStatistic statistic){        Assert.assertEquals(1, statistic.getResult(), 0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.summary;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link SumOfSquares} class. * * @version $Id$ */public class SumSqTest extends StorelessUnivariateStatisticAbstractTest{    protected SumOfSquares stat;    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new SumOfSquares();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.sumSq;    }    @Test    public void testSpecialValues() {        SumOfSquares sumSq = new SumOfSquares();        Assert.assertEquals(0, sumSq.getResult(), 0);        sumSq.increment(2d);        Assert.assertEquals(4d, sumSq.getResult(), 0);        sumSq.increment(Double.POSITIVE_INFINITY);        Assert.assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);        sumSq.increment(Double.NEGATIVE_INFINITY);        Assert.assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);        sumSq.increment(Double.NaN);        Assert.assertTrue(Double.isNaN(sumSq.getResult()));        sumSq.increment(1);        Assert.assertTrue(Double.isNaN(sumSq.getResult()));    }        @Override    protected void checkClearValue(StorelessUnivariateStatistic statistic){        Assert.assertEquals(0, statistic.getResult(), 0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import java.io.Serializable;import java.util.ArrayList;import java.util.List;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.util.NumberTransformer;import org.apache.commons.math.util.TransformerMap;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link ListUnivariateImpl} class. * * @version $Id$ */public final class MixedListUnivariateImplTest {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = FastMath.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double tolerance = 10E-15;    private TransformerMap transformers = new TransformerMap();    public MixedListUnivariateImplTest() {        transformers = new TransformerMap();        transformers.putTransformer(Foo.class, new FooTransformer());        transformers.putTransformer(Bar.class, new BarTransformer());    }    /** test stats */    @Test    public void testStats() {        List<Object> externalList = new ArrayList<Object>();        DescriptiveStatistics u = new ListUnivariateImpl(externalList,transformers);        Assert.assertEquals("total count", 0, u.getN(), tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        Assert.assertEquals("N", n, u.getN(), tolerance);        Assert.assertEquals("sum", sum, u.getSum(), tolerance);        Assert.assertEquals("sumsq", sumSq, u.getSumsq(), tolerance);        Assert.assertEquals("var", var, u.getVariance(), tolerance);        Assert.assertEquals("std", std, u.getStandardDeviation(), tolerance);        Assert.assertEquals("mean", mean, u.getMean(), tolerance);        Assert.assertEquals("min", min, u.getMin(), tolerance);        Assert.assertEquals("max", max, u.getMax(), tolerance);        u.clear();        Assert.assertEquals("total count", 0, u.getN(), tolerance);    }    @Test    public void testN0andN1Conditions() throws Exception {        DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);        Assert.assertTrue(            "Mean of n = 0 set should be NaN",            Double.isNaN(u.getMean()));        Assert.assertTrue(            "Standard Deviation of n = 0 set should be NaN",            Double.isNaN(u.getStandardDeviation()));        Assert.assertTrue(            "Variance of n = 0 set should be NaN",            Double.isNaN(u.getVariance()));        u.addValue(one);        Assert.assertTrue(            "Mean of n = 1 set should be value of single item n1, instead it is " + u.getMean() ,            u.getMean() == one);        Assert.assertTrue(            "StdDev of n = 1 set should be zero, instead it is: "                + u.getStandardDeviation(),            u.getStandardDeviation() == 0);        Assert.assertTrue(            "Variance of n = 1 set should be zero",            u.getVariance() == 0);    }    @Test    public void testSkewAndKurtosis() {        ListUnivariateImpl u =            new ListUnivariateImpl(new ArrayList<Object>(), transformers);        u.addObject("12.5");        u.addObject(Integer.valueOf(12));        u.addObject("11.8");        u.addObject("14.2");        u.addObject(new Foo());        u.addObject("14.5");        u.addObject(Long.valueOf(21));        u.addObject("8.2");        u.addObject("10.3");        u.addObject("11.3");        u.addObject(Float.valueOf(14.1f));        u.addObject("9.9");        u.addObject("12.2");        u.addObject(new Bar());        u.addObject("12.1");        u.addObject("11");        u.addObject(Double.valueOf(19.8));        u.addObject("11");        u.addObject("10");        u.addObject("8.8");        u.addObject("9");        u.addObject("12.3");        Assert.assertEquals("mean", 12.40455, u.getMean(), 0.0001);        Assert.assertEquals("variance", 10.00236, u.getVariance(), 0.0001);        Assert.assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);        Assert.assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    @Test    public void testProductAndGeometricMean() throws Exception {        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);        u.setWindowSize(10);        u.addValue(1.0);        u.addValue(2.0);        u.addValue(3.0);        u.addValue(4.0);        Assert.assertEquals(            "Geometric mean not expected",            2.213364,            u.getGeometricMean(),            0.00001);        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution        // of a discarded element        for (int i = 0; i < 10; i++) {            u.addValue(i + 2);        }        // Values should be (2,3,4,5,6,7,8,9,10,11)        Assert.assertEquals(            "Geometric mean not expected",            5.755931,            u.getGeometricMean(),            0.00001);    }    public static final class Foo {        public String heresFoo() {            return "14.9";        }    }    public static final class FooTransformer implements NumberTransformer, Serializable {        private static final long serialVersionUID = -4252248129291326127L;        public double transform(Object o) {            return Double.parseDouble(((Foo) o).heresFoo());        }    }    public static final class Bar {        public String heresBar() {            return "12.0";        }    }    public static final class BarTransformer implements NumberTransformer, Serializable {        private static final long serialVersionUID = -1768345377764262043L;        public double transform(Object o) {            return Double.parseDouble(((Bar) o).heresBar());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.stat.descriptive;/** * Test cases for the {@link SynchronizedDescriptiveStatisticsTest} class. * @version $Id$ *          2007) $ */public final class SynchronizedDescriptiveStatisticsTest extends DescriptiveStatisticsTest {    @Override    protected DescriptiveStatistics createDescriptiveStatistics() {        return new SynchronizedDescriptiveStatistics();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import java.util.Locale;import org.apache.commons.math.TestUtils;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link StatisticalSummaryValues} class. * * @version $Id$ */public final class StatisticalSummaryValuesTest {    @Test    public void testSerialization() {        StatisticalSummaryValues u = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);        TestUtils.checkSerializedEquality(u);        StatisticalSummaryValues t = (StatisticalSummaryValues) TestUtils.serializeAndRecover(u);        verifyEquality(u, t);    }    @Test    public void testEqualsAndHashCode() {        StatisticalSummaryValues u  = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);        StatisticalSummaryValues t = null;        Assert.assertTrue("reflexive", u.equals(u));        Assert.assertFalse("non-null compared to null", u.equals(t));        Assert.assertFalse("wrong type", u.equals(Double.valueOf(0)));        t = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);        Assert.assertTrue("instances with same data should be equal", t.equals(u));        Assert.assertEquals("hash code", u.hashCode(), t.hashCode());        u = new StatisticalSummaryValues(Double.NaN, 2, 3, 4, 5, 6);        t = new StatisticalSummaryValues(1, Double.NaN, 3, 4, 5, 6);        Assert.assertFalse("instances based on different data should be different",                (u.equals(t) ||t.equals(u)));    }    private void verifyEquality(StatisticalSummaryValues s, StatisticalSummaryValues u) {        Assert.assertEquals("N",s.getN(),u.getN());        TestUtils.assertEquals("sum",s.getSum(),u.getSum(), 0);        TestUtils.assertEquals("var",s.getVariance(),u.getVariance(), 0);        TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(), 0);        TestUtils.assertEquals("mean",s.getMean(),u.getMean(), 0);        TestUtils.assertEquals("min",s.getMin(),u.getMin(), 0);        TestUtils.assertEquals("max",s.getMax(),u.getMax(), 0);    }        @Test    public void testToString() {        StatisticalSummaryValues u  = new StatisticalSummaryValues(4.5, 16, 10, 5, 4, 45);        Locale d = Locale.getDefault();        Locale.setDefault(Locale.US);        Assert.assertEquals("StatisticalSummaryValues:\n" +                     "n: 10\n" +                     "min: 4.0\n" +                     "max: 5.0\n" +                     "mean: 4.5\n" +                     "std dev: 4.0\n" +                     "variance: 16.0\n" +                     "sum: 45.0\n",  u.toString());        Locale.setDefault(d);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 *s * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import java.util.ArrayList;import java.util.List;import org.apache.commons.math.TestUtils;import org.apache.commons.math.random.RandomData;import org.apache.commons.math.random.RandomDataImpl;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */public abstract class UnivariateStatisticAbstractTest {    protected double mean = 12.404545454545455d;    protected double geoMean = 12.070589161633011d;    protected double var = 10.00235930735931d;    protected double std = FastMath.sqrt(var);    protected double skew = 1.437423729196190d;    protected double kurt = 2.377191264804700d;    protected double min = 8.2d;    protected double max = 21d;    protected double median = 12d;    protected double percentile5 = 8.29d;    protected double percentile95 = 20.82d;    protected double product = 628096400563833396009676.9200400128d;    protected double sumLog = 54.7969806116451507d;    protected double sumSq = 3595.250d;    protected double sum = 272.90d;    protected double secondMoment = 210.04954545454547d;    protected double thirdMoment = 868.0906859504136;    protected double fourthMoment = 9244.080993773481;    protected double weightedMean = 12.366995073891626d;    protected double weightedVar =   9.974760968886391d;    protected double weightedStd = FastMath.sqrt(weightedVar);    protected double weightedProduct = 8517647448765288000000d;    protected double weightedSum = 251.05d;    protected double tolerance = 10E-12;    protected double[] testArray =        { 12.5, 12.0, 11.8, 14.2, 14.9, 14.5, 21.0,  8.2, 10.3, 11.3,          14.1,  9.9, 12.2, 12.0, 12.1, 11.0, 19.8, 11.0, 10.0,  8.8,           9.0, 12.3 };    protected double[] testWeightsArray =        {  1.5,  0.8,  1.2,  0.4,  0.8,  1.8,  1.2,  1.1,  1.0,  0.7,           1.3,  0.6,  0.7,  1.3,  0.7,  1.0,  0.4,  0.1,  1.4,  0.9,           1.1,  0.3 };    protected double[] identicalWeightsArray =        {  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,           0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,           0.5,  0.5 };    protected double[] unitWeightsArray =        {  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,           1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,           1.0,  1.0 };    public abstract UnivariateStatistic getUnivariateStatistic();    public abstract double expectedValue();    public double getTolerance() {        return tolerance;    }    @Test    public void testEvaluation() throws Exception {        Assert.assertEquals(            expectedValue(),            getUnivariateStatistic().evaluate(testArray),            getTolerance());    }    @Test    public void testCopy() throws Exception {        UnivariateStatistic original = getUnivariateStatistic();        UnivariateStatistic copy = original.copy();        Assert.assertEquals(                expectedValue(),                copy.evaluate(testArray),                getTolerance());    }    /**     * Tests consistency of weighted statistic computation.     * For statistics that support weighted evaluation, this test case compares     * the result of direct computation on an array with repeated values with     * a weighted computation on the corresponding (shorter) array with each     * value appearing only once but with a weight value equal to its multiplicity     * in the repeating array.     */    @Test    public void testWeightedConsistency() throws Exception {        // See if this statistic computes weighted statistics        // If not, skip this test        UnivariateStatistic statistic = getUnivariateStatistic();        if (!(statistic instanceof WeightedEvaluation)) {            return;        }        // Create arrays of values and corresponding integral weights        // and longer array with values repeated according to the weights        final int len = 10;        // length of values array        final double mu = 0;       // mean of test data        final double sigma = 5;    // std dev of test data        double[] values = new double[len];        double[] weights = new double[len];        RandomData randomData = new RandomDataImpl();        // Fill weights array with random int values between 1 and 5        int[] intWeights = new int[len];        for (int i = 0; i < len; i++) {            intWeights[i] = randomData.nextInt(1, 5);            weights[i] = intWeights[i];        }        // Fill values array with random data from N(mu, sigma)        // and fill valuesList with values from values array with        // values[i] repeated weights[i] times, each i        List<Double> valuesList = new ArrayList<Double>();        for (int i = 0; i < len; i++) {            double value = randomData.nextGaussian(mu, sigma);            values[i] = value;            for (int j = 0; j < intWeights[i]; j++) {                valuesList.add(new Double(value));            }        }        // Dump valuesList into repeatedValues array        int sumWeights = valuesList.size();        double[] repeatedValues = new double[sumWeights];        for (int i = 0; i < sumWeights; i++) {            repeatedValues[i] = valuesList.get(i);        }        // Compare result of weighted statistic computation with direct computation        // on array of repeated values        WeightedEvaluation weightedStatistic = (WeightedEvaluation) statistic;        TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),                weightedStatistic.evaluate(values, weights, 0, values.length),                10E-14);        // Check consistency of weighted evaluation methods        Assert.assertEquals(weightedStatistic.evaluate(values, weights, 0, values.length),                weightedStatistic.evaluate(values, weights), Double.MIN_VALUE);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.stat.descriptive;import java.util.Locale;import org.apache.commons.math.stat.descriptive.rank.Percentile;import org.apache.commons.math.util.MathUtils;import org.junit.Assert;import org.junit.Test;/** * Test cases for the DescriptiveStatistics class. * * @version $Id$ *          2007) $ */public class DescriptiveStatisticsTest {    protected DescriptiveStatistics createDescriptiveStatistics() {        return new DescriptiveStatistics();    }    @Test    public void testSetterInjection() {        DescriptiveStatistics stats = createDescriptiveStatistics();        stats.addValue(1);        stats.addValue(3);        Assert.assertEquals(2, stats.getMean(), 1E-10);        // Now lets try some new math        stats.setMeanImpl(new deepMean());        Assert.assertEquals(42, stats.getMean(), 1E-10);    }    @Test    public void testCopy() {        DescriptiveStatistics stats = createDescriptiveStatistics();        stats.addValue(1);        stats.addValue(3);        DescriptiveStatistics copy = new DescriptiveStatistics(stats);        Assert.assertEquals(2, copy.getMean(), 1E-10);        // Now lets try some new math        stats.setMeanImpl(new deepMean());        copy = stats.copy();        Assert.assertEquals(42, copy.getMean(), 1E-10);    }    @Test    public void testWindowSize() {        DescriptiveStatistics stats = createDescriptiveStatistics();        stats.setWindowSize(300);        for (int i = 0; i < 100; ++i) {            stats.addValue(i + 1);        }        int refSum = (100 * 101) / 2;        Assert.assertEquals(refSum / 100.0, stats.getMean(), 1E-10);        Assert.assertEquals(300, stats.getWindowSize());        try {            stats.setWindowSize(-3);            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected        }        Assert.assertEquals(300, stats.getWindowSize());        stats.setWindowSize(50);        Assert.assertEquals(50, stats.getWindowSize());        int refSum2 = refSum - (50 * 51) / 2;        Assert.assertEquals(refSum2 / 50.0, stats.getMean(), 1E-10);    }    @Test    public void testGetValues() {        DescriptiveStatistics stats = createDescriptiveStatistics();        for (int i = 100; i > 0; --i) {            stats.addValue(i);        }        int refSum = (100 * 101) / 2;        Assert.assertEquals(refSum / 100.0, stats.getMean(), 1E-10);        double[] v = stats.getValues();        for (int i = 0; i < v.length; ++i) {            Assert.assertEquals(100.0 - i, v[i], 1.0e-10);        }        double[] s = stats.getSortedValues();        for (int i = 0; i < s.length; ++i) {            Assert.assertEquals(i + 1.0, s[i], 1.0e-10);        }        Assert.assertEquals(12.0, stats.getElement(88), 1.0e-10);    }    @Test    public void testToString() {        DescriptiveStatistics stats = createDescriptiveStatistics();        stats.addValue(1);        stats.addValue(2);        stats.addValue(3);        Locale d = Locale.getDefault();        Locale.setDefault(Locale.US);        Assert.assertEquals("DescriptiveStatistics:\n" +                     "n: 3\n" +                     "min: 1.0\n" +                     "max: 3.0\n" +                     "mean: 2.0\n" +                     "std dev: 1.0\n" +                     "median: 2.0\n" +                     "skewness: 0.0\n" +                     "kurtosis: NaN\n",  stats.toString());        Locale.setDefault(d);    }    @Test    public void testShuffledStatistics() {        // the purpose of this test is only to check the get/set methods        // we are aware shuffling statistics like this is really not        // something sensible to do in production ...        DescriptiveStatistics reference = createDescriptiveStatistics();        DescriptiveStatistics shuffled  = createDescriptiveStatistics();        UnivariateStatistic tmp = shuffled.getGeometricMeanImpl();        shuffled.setGeometricMeanImpl(shuffled.getMeanImpl());        shuffled.setMeanImpl(shuffled.getKurtosisImpl());        shuffled.setKurtosisImpl(shuffled.getSkewnessImpl());        shuffled.setSkewnessImpl(shuffled.getVarianceImpl());        shuffled.setVarianceImpl(shuffled.getMaxImpl());        shuffled.setMaxImpl(shuffled.getMinImpl());        shuffled.setMinImpl(shuffled.getSumImpl());        shuffled.setSumImpl(shuffled.getSumsqImpl());        shuffled.setSumsqImpl(tmp);        for (int i = 100; i > 0; --i) {            reference.addValue(i);            shuffled.addValue(i);        }        Assert.assertEquals(reference.getMean(),          shuffled.getGeometricMean(), 1.0e-10);        Assert.assertEquals(reference.getKurtosis(),      shuffled.getMean(),          1.0e-10);        Assert.assertEquals(reference.getSkewness(),      shuffled.getKurtosis(), 1.0e-10);        Assert.assertEquals(reference.getVariance(),      shuffled.getSkewness(), 1.0e-10);        Assert.assertEquals(reference.getMax(),           shuffled.getVariance(), 1.0e-10);        Assert.assertEquals(reference.getMin(),           shuffled.getMax(), 1.0e-10);        Assert.assertEquals(reference.getSum(),           shuffled.getMin(), 1.0e-10);        Assert.assertEquals(reference.getSumsq(),         shuffled.getSum(), 1.0e-10);        Assert.assertEquals(reference.getGeometricMean(), shuffled.getSumsq(), 1.0e-10);    }    @Test    public void testPercentileSetter() throws Exception {        DescriptiveStatistics stats = createDescriptiveStatistics();        stats.addValue(1);        stats.addValue(2);        stats.addValue(3);        Assert.assertEquals(2, stats.getPercentile(50.0), 1E-10);        // Inject wrapped Percentile impl        stats.setPercentileImpl(new goodPercentile());        Assert.assertEquals(2, stats.getPercentile(50.0), 1E-10);        // Try "new math" impl        stats.setPercentileImpl(new subPercentile());        Assert.assertEquals(10.0, stats.getPercentile(10.0), 1E-10);        // Try to set bad impl        try {            stats.setPercentileImpl(new badPercentile());            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }    @Test    public void test20090720() {        DescriptiveStatistics descriptiveStatistics = new DescriptiveStatistics(100);        for (int i = 0; i < 161; i++) {            descriptiveStatistics.addValue(1.2);        }        descriptiveStatistics.clear();        descriptiveStatistics.addValue(1.2);        Assert.assertEquals(1, descriptiveStatistics.getN());    }    @Test    public void testRemoval() {        final DescriptiveStatistics dstat = createDescriptiveStatistics();        checkremoval(dstat, 1, 6.0, 0.0, Double.NaN);        checkremoval(dstat, 3, 5.0, 3.0, 4.5);        checkremoval(dstat, 6, 3.5, 2.5, 3.0);        checkremoval(dstat, 9, 3.5, 2.5, 3.0);        checkremoval(dstat, DescriptiveStatistics.INFINITE_WINDOW, 3.5, 2.5, 3.0);    }    public void checkremoval(DescriptiveStatistics dstat, int wsize,                             double mean1, double mean2, double mean3) {        dstat.setWindowSize(wsize);        dstat.clear();        for (int i = 1 ; i <= 6 ; ++i) {            dstat.addValue(i);        }        Assert.assertTrue(MathUtils.equalsIncludingNaN(mean1, dstat.getMean()));        dstat.replaceMostRecentValue(0);        Assert.assertTrue(MathUtils.equalsIncludingNaN(mean2, dstat.getMean()));        dstat.removeMostRecentValue();        Assert.assertTrue(MathUtils.equalsIncludingNaN(mean3, dstat.getMean()));    }    // Test UnivariateStatistics impls for setter injection tests    /**     * A new way to compute the mean     */    static class deepMean implements UnivariateStatistic {        public double evaluate(double[] values, int begin, int length) {            return 42;        }        public double evaluate(double[] values) {            return 42;        }        public UnivariateStatistic copy() {            return new deepMean();        }    }    /**     * Test percentile implementation - wraps a Percentile     */    static class goodPercentile implements UnivariateStatistic {        private Percentile percentile = new Percentile();        public void setQuantile(double quantile) {            percentile.setQuantile(quantile);        }        public double evaluate(double[] values, int begin, int length) {            return percentile.evaluate(values, begin, length);        }        public double evaluate(double[] values) {            return percentile.evaluate(values);        }        public UnivariateStatistic copy() {            goodPercentile result = new goodPercentile();            result.setQuantile(percentile.getQuantile());            return result;        }    }    /**     * Test percentile subclass - another "new math" impl     * Always returns currently set quantile     */    static class subPercentile extends Percentile {        @Override        public double evaluate(double[] values, int begin, int length) {            return getQuantile();        }        @Override        public double evaluate(double[] values) {            return getQuantile();        }        private static final long serialVersionUID = 8040701391045914979L;        @Override        public Percentile copy() {            subPercentile result = new subPercentile();            return result;        }    }    /**     * "Bad" test percentile implementation - no setQuantile     */    static class badPercentile implements UnivariateStatistic {        private Percentile percentile = new Percentile();        public double evaluate(double[] values, int begin, int length) {            return percentile.evaluate(values, begin, length);        }        public double evaluate(double[] values) {            return percentile.evaluate(values);        }        public UnivariateStatistic copy() {            return new badPercentile();        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.stat.descriptive.moment.Mean;import org.junit.Assert;import org.junit.Test;/** * Tests for AbstractUnivariateStatistic * * @version $Id$ */public class AbstractUnivariateStatisticTest {    protected double[] testArray = {0, 1, 2, 3, 4, 5};    protected double[] testWeightsArray = {0.3, 0.2, 1.3, 1.1, 1.0, 1.8};    protected double[] testNegativeWeightsArray = {-0.3, 0.2, -1.3, 1.1, 1.0, 1.8};    protected double[] nullArray = null;    protected double[] singletonArray = {0};    protected Mean testStatistic = new Mean();    @Test    public void testTestPositive() {        for (int j = 0; j < 6; j++) {            for (int i = 1; i < (7 - j); i++) {                Assert.assertTrue(testStatistic.test(testArray, 0, i));            }        }        Assert.assertTrue(testStatistic.test(singletonArray, 0, 1));        Assert.assertTrue(testStatistic.test(singletonArray, 0, 0, true));    }    @Test    public void testTestNegative() {        Assert.assertFalse(testStatistic.test(singletonArray, 0, 0));        Assert.assertFalse(testStatistic.test(testArray, 0, 0));        try {            testStatistic.test(singletonArray, 2, 1);  // start past end            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, 0, 7);  // end past end            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, -1, 1);  // start negative            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, 0, -1);  // length negative            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(nullArray, 0, 1);  // null array            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, nullArray, 0, 1);  // null weights array            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(singletonArray, testWeightsArray, 0, 1);  // weights.length != value.length            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, testNegativeWeightsArray, 0, 6);  // can't have negative weights            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import java.util.ArrayList;import java.util.List;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link ListUnivariateImpl} class. * * @version $Id$ */public final class ListUnivariateImplTest {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = FastMath.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double tolerance = 10E-15;    /** test stats */    @Test    public void testStats() {        List<Object> externalList = new ArrayList<Object>();        DescriptiveStatistics u = new ListUnivariateImpl( externalList );        Assert.assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        Assert.assertEquals("N",n,u.getN(),tolerance);        Assert.assertEquals("sum",sum,u.getSum(),tolerance);        Assert.assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        Assert.assertEquals("var",var,u.getVariance(),tolerance);        Assert.assertEquals("std",std,u.getStandardDeviation(),tolerance);        Assert.assertEquals("mean",mean,u.getMean(),tolerance);        Assert.assertEquals("min",min,u.getMin(),tolerance);        Assert.assertEquals("max",max,u.getMax(),tolerance);        u.clear();        Assert.assertEquals("total count",0,u.getN(),tolerance);    }    @Test    public void testN0andN1Conditions() throws Exception {        List<Object> list = new ArrayList<Object>();        DescriptiveStatistics u = new ListUnivariateImpl( list );        Assert.assertTrue("Mean of n = 0 set should be NaN", Double.isNaN( u.getMean() ) );        Assert.assertTrue("Standard Deviation of n = 0 set should be NaN", Double.isNaN( u.getStandardDeviation() ) );        Assert.assertTrue("Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance() ) );        list.add( Double.valueOf(one));        Assert.assertTrue( "Mean of n = 1 set should be value of single item n1", u.getMean() == one);        Assert.assertTrue( "StdDev of n = 1 set should be zero, instead it is: " + u.getStandardDeviation(), u.getStandardDeviation() == 0);        Assert.assertTrue( "Variance of n = 1 set should be zero", u.getVariance() == 0);    }    @Test    public void testSkewAndKurtosis() {        DescriptiveStatistics u = new DescriptiveStatistics();        double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,                                             9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };        for( int i = 0; i < testArray.length; i++) {            u.addValue( testArray[i]);        }        Assert.assertEquals("mean", 12.40455, u.getMean(), 0.0001);        Assert.assertEquals("variance", 10.00236, u.getVariance(), 0.0001);        Assert.assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);        Assert.assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    @Test    public void testProductAndGeometricMean() throws Exception {        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>());        u.setWindowSize(10);        u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        Assert.assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001 );        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution        // of a discarded element        for( int i = 0; i < 10; i++ ) {            u.addValue( i + 2 );        }        // Values should be (2,3,4,5,6,7,8,9,10,11)        Assert.assertEquals( "Geometric mean not expected", 5.755931, u.getGeometricMean(), 0.00001 );    }    /** test stats */    @Test    public void testSerialization() {        DescriptiveStatistics u = new ListUnivariateImpl();        Assert.assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);        DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u);        u2.addValue(two);        u2.addValue(three);        Assert.assertEquals("N",n,u2.getN(),tolerance);        Assert.assertEquals("sum",sum,u2.getSum(),tolerance);        Assert.assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance);        Assert.assertEquals("var",var,u2.getVariance(),tolerance);        Assert.assertEquals("std",std,u2.getStandardDeviation(),tolerance);        Assert.assertEquals("mean",mean,u2.getMean(),tolerance);        Assert.assertEquals("min",min,u2.getMin(),tolerance);        Assert.assertEquals("max",max,u2.getMax(),tolerance);        u2.clear();        Assert.assertEquals("total count",0,u2.getN(),tolerance);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.stat.descriptive;/** * Test cases for the {@link SynchronizedSummaryStatisticsTest} class. * @version $Id$ *          2007) $ */public final class SynchronizedSummaryStatisticsTest extends SummaryStatisticsTest {    @Override    protected SummaryStatistics createSummaryStatistics() {        return new SynchronizedSummaryStatistics();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.moment.Mean;import org.apache.commons.math.stat.descriptive.summary.Sum;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link SummaryStatistics} class. * * @version $Id$ */public class SummaryStatisticsTest {    private double one = 1;    private float twoF = 2;    private long twoL = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = FastMath.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double tolerance = 10E-15;    protected SummaryStatistics createSummaryStatistics() {        return new SummaryStatistics();    }    /** test stats */    @Test    public void testStats() {        SummaryStatistics u = createSummaryStatistics();        Assert.assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(twoF);        u.addValue(twoL);        u.addValue(three);        Assert.assertEquals("N",n,u.getN(),tolerance);        Assert.assertEquals("sum",sum,u.getSum(),tolerance);        Assert.assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        Assert.assertEquals("var",var,u.getVariance(),tolerance);        Assert.assertEquals("std",std,u.getStandardDeviation(),tolerance);        Assert.assertEquals("mean",mean,u.getMean(),tolerance);        Assert.assertEquals("min",min,u.getMin(),tolerance);        Assert.assertEquals("max",max,u.getMax(),tolerance);        u.clear();        Assert.assertEquals("total count",0,u.getN(),tolerance);    }    @Test    public void testN0andN1Conditions() throws Exception {        SummaryStatistics u = createSummaryStatistics();        Assert.assertTrue("Mean of n = 0 set should be NaN",                Double.isNaN( u.getMean() ) );        Assert.assertTrue("Standard Deviation of n = 0 set should be NaN",                Double.isNaN( u.getStandardDeviation() ) );        Assert.assertTrue("Variance of n = 0 set should be NaN",                Double.isNaN(u.getVariance() ) );        /* n=1 */        u.addValue(one);        Assert.assertTrue("mean should be one (n = 1)",                u.getMean() == one);        Assert.assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(),                u.getGeometricMean() == one);        Assert.assertTrue("Std should be zero (n = 1)",                u.getStandardDeviation() == 0.0);        Assert.assertTrue("variance should be zero (n = 1)",                u.getVariance() == 0.0);        /* n=2 */        u.addValue(twoF);        Assert.assertTrue("Std should not be zero (n = 2)",                u.getStandardDeviation() != 0.0);        Assert.assertTrue("variance should not be zero (n = 2)",                u.getVariance() != 0.0);    }    @Test    public void testProductAndGeometricMean() throws Exception {        SummaryStatistics u = createSummaryStatistics();        u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        Assert.assertEquals( "Geometric mean not expected", 2.213364,                u.getGeometricMean(), 0.00001 );    }    @Test    public void testNaNContracts() {        SummaryStatistics u = createSummaryStatistics();        Assert.assertTrue("mean not NaN",Double.isNaN(u.getMean()));        Assert.assertTrue("min not NaN",Double.isNaN(u.getMin()));        Assert.assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation()));        Assert.assertTrue("var not NaN",Double.isNaN(u.getVariance()));        Assert.assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));        u.addValue(1.0);        Assert.assertEquals( "mean not expected", 1.0,                u.getMean(), Double.MIN_VALUE);        Assert.assertEquals( "variance not expected", 0.0,                u.getVariance(), Double.MIN_VALUE);        Assert.assertEquals( "geometric mean not expected", 1.0,                u.getGeometricMean(), Double.MIN_VALUE);        u.addValue(-1.0);        Assert.assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));        u.addValue(0.0);        Assert.assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));        //FiXME: test all other NaN contract specs    }    @Test    public void testGetSummary() {        SummaryStatistics u = createSummaryStatistics();        StatisticalSummary summary = u.getSummary();        verifySummary(u, summary);        u.addValue(1d);        summary = u.getSummary();        verifySummary(u, summary);        u.addValue(2d);        summary = u.getSummary();        verifySummary(u, summary);        u.addValue(2d);        summary = u.getSummary();        verifySummary(u, summary);    }    @Test    public void testSerialization() {        SummaryStatistics u = createSummaryStatistics();        // Empty test        TestUtils.checkSerializedEquality(u);        SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);        StatisticalSummary summary = s.getSummary();        verifySummary(u, summary);        // Add some data        u.addValue(2d);        u.addValue(1d);        u.addValue(3d);        u.addValue(4d);        u.addValue(5d);        // Test again        TestUtils.checkSerializedEquality(u);        s = (SummaryStatistics) TestUtils.serializeAndRecover(u);        summary = s.getSummary();        verifySummary(u, summary);    }    @Test    public void testEqualsAndHashCode() {        SummaryStatistics u = createSummaryStatistics();        SummaryStatistics t = null;        int emptyHash = u.hashCode();        Assert.assertTrue("reflexive", u.equals(u));        Assert.assertFalse("non-null compared to null", u.equals(t));        Assert.assertFalse("wrong type", u.equals(Double.valueOf(0)));        t = createSummaryStatistics();        Assert.assertTrue("empty instances should be equal", t.equals(u));        Assert.assertTrue("empty instances should be equal", u.equals(t));        Assert.assertEquals("empty hash code", emptyHash, t.hashCode());        // Add some data to u        u.addValue(2d);        u.addValue(1d);        u.addValue(3d);        u.addValue(4d);        Assert.assertFalse("different n's should make instances not equal", t.equals(u));        Assert.assertFalse("different n's should make instances not equal", u.equals(t));        Assert.assertTrue("different n's should make hashcodes different",                u.hashCode() != t.hashCode());        //Add data in same order to t        t.addValue(2d);        t.addValue(1d);        t.addValue(3d);        t.addValue(4d);        Assert.assertTrue("summaries based on same data should be equal", t.equals(u));        Assert.assertTrue("summaries based on same data should be equal", u.equals(t));        Assert.assertEquals("summaries based on same data should have same hashcodes",                u.hashCode(), t.hashCode());        // Clear and make sure summaries are indistinguishable from empty summary        u.clear();        t.clear();        Assert.assertTrue("empty instances should be equal", t.equals(u));        Assert.assertTrue("empty instances should be equal", u.equals(t));        Assert.assertEquals("empty hash code", emptyHash, t.hashCode());        Assert.assertEquals("empty hash code", emptyHash, u.hashCode());    }    @Test    public void testCopy() throws Exception {        SummaryStatistics u = createSummaryStatistics();        u.addValue(2d);        u.addValue(1d);        u.addValue(3d);        u.addValue(4d);        SummaryStatistics v = new SummaryStatistics(u);        Assert.assertEquals(u, v);        Assert.assertEquals(v, u);        Assert.assertTrue(v.geoMean == v.getGeoMeanImpl());        Assert.assertTrue(v.mean == v.getMeanImpl());        Assert.assertTrue(v.min == v.getMinImpl());        Assert.assertTrue(v.max == v.getMaxImpl());        Assert.assertTrue(v.sum == v.getSumImpl());        Assert.assertTrue(v.sumsq == v.getSumsqImpl());        Assert.assertTrue(v.sumLog == v.getSumLogImpl());        Assert.assertTrue(v.variance == v.getVarianceImpl());        // Make sure both behave the same with additional values added        u.addValue(7d);        u.addValue(9d);        u.addValue(11d);        u.addValue(23d);        v.addValue(7d);        v.addValue(9d);        v.addValue(11d);        v.addValue(23d);        Assert.assertEquals(u, v);        Assert.assertEquals(v, u);        // Check implementation pointers are preserved        u.clear();        u.setSumImpl(new Sum());        SummaryStatistics.copy(u,v);        Assert.assertEquals(u.sum, v.sum);        Assert.assertEquals(u.getSumImpl(), v.getSumImpl());    }    private void verifySummary(SummaryStatistics u, StatisticalSummary s) {        Assert.assertEquals("N",s.getN(),u.getN());        TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);        TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);        TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);        TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);        TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);        TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);    }    @Test    public void testSetterInjection() throws Exception {        SummaryStatistics u = createSummaryStatistics();        u.setMeanImpl(new Sum());        u.setSumLogImpl(new Sum());        u.addValue(1);        u.addValue(3);        Assert.assertEquals(4, u.getMean(), 1E-14);        Assert.assertEquals(4, u.getSumOfLogs(), 1E-14);        Assert.assertEquals(FastMath.exp(2), u.getGeometricMean(), 1E-14);        u.clear();        u.addValue(1);        u.addValue(2);        Assert.assertEquals(3, u.getMean(), 1E-14);        u.clear();        u.setMeanImpl(new Mean()); // OK after clear    }    @Test    public void testSetterIllegalState() throws Exception {        SummaryStatistics u = createSummaryStatistics();        u.addValue(1);        u.addValue(3);        try {            u.setMeanImpl(new Sum());            Assert.fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import java.util.ArrayList;import java.util.Collection;import org.apache.commons.math.TestUtils;import org.apache.commons.math.random.RandomData;import org.apache.commons.math.random.RandomDataImpl;import org.apache.commons.math.util.MathUtils;import org.junit.Assert;import org.junit.Test;/** * Test cases for {@link AggregateSummaryStatistics} * */public class AggregateSummaryStatisticsTest {    /**     * Tests the standard aggregation behavior     */    @Test    public void testAggregation() {        AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();        SummaryStatistics setOneStats = aggregate.createContributingStatistics();        SummaryStatistics setTwoStats = aggregate.createContributingStatistics();        Assert.assertNotNull("The set one contributing stats are null", setOneStats);        Assert.assertNotNull("The set two contributing stats are null", setTwoStats);        Assert.assertNotSame("Contributing stats objects are the same", setOneStats, setTwoStats);        setOneStats.addValue(2);        setOneStats.addValue(3);        setOneStats.addValue(5);        setOneStats.addValue(7);        setOneStats.addValue(11);        Assert.assertEquals("Wrong number of set one values", 5, setOneStats.getN());        Assert.assertTrue("Wrong sum of set one values", MathUtils.equals(28.0, setOneStats.getSum(), 1));        setTwoStats.addValue(2);        setTwoStats.addValue(4);        setTwoStats.addValue(8);        Assert.assertEquals("Wrong number of set two values", 3, setTwoStats.getN());        Assert.assertTrue("Wrong sum of set two values", MathUtils.equals(14.0, setTwoStats.getSum(), 1));        Assert.assertEquals("Wrong number of aggregate values", 8, aggregate.getN());        Assert.assertTrue("Wrong aggregate sum", MathUtils.equals(42.0, aggregate.getSum(), 1));    }    /**     * Verify that aggregating over a partition gives the same results     * as direct computation.     *     *  1) Randomly generate a dataset of 10-100 values     *     from [-100, 100]     *  2) Divide the dataset it into 2-5 partitions     *  3) Create an AggregateSummaryStatistic and ContributingStatistics     *     for each partition     *  4) Compare results from the AggregateSummaryStatistic with values     *     returned by a single SummaryStatistics instance that is provided     *     the full dataset     */    @Test    public void testAggregationConsistency() throws Exception {        // Generate a random sample and random partition        double[] totalSample = generateSample();        double[][] subSamples = generatePartition(totalSample);        int nSamples = subSamples.length;        // Create aggregator and total stats for comparison        AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();        SummaryStatistics totalStats = new SummaryStatistics();        // Create array of component stats        SummaryStatistics componentStats[] = new SummaryStatistics[nSamples];        for (int i = 0; i < nSamples; i++) {            // Make componentStats[i] a contributing statistic to aggregate            componentStats[i] = aggregate.createContributingStatistics();            // Add values from subsample            for (int j = 0; j < subSamples[i].length; j++) {                componentStats[i].addValue(subSamples[i][j]);            }        }        // Compute totalStats directly        for (int i = 0; i < totalSample.length; i++) {            totalStats.addValue(totalSample[i]);        }        /*         * Compare statistics in totalStats with aggregate.         * Note that guaranteed success of this comparison depends on the         * fact that <aggregate> gets values in exactly the same order         * as <totalStats>.         *         */        Assert.assertEquals(totalStats.getSummary(), aggregate.getSummary());    }    /**     * Test aggregate function by randomly generating a dataset of 10-100 values     * from [-100, 100], dividing it into 2-5 partitions, computing stats for each     * partition and comparing the result of aggregate(...) applied to the collection     * of per-partition SummaryStatistics with a single SummaryStatistics computed     * over the full sample.     *     * @throws Exception     */    @Test    public void testAggregate() throws Exception {        // Generate a random sample and random partition        double[] totalSample = generateSample();        double[][] subSamples = generatePartition(totalSample);        int nSamples = subSamples.length;        // Compute combined stats directly        SummaryStatistics totalStats = new SummaryStatistics();        for (int i = 0; i < totalSample.length; i++) {            totalStats.addValue(totalSample[i]);        }        // Now compute subsample stats individually and aggregate        SummaryStatistics[] subSampleStats = new SummaryStatistics[nSamples];        for (int i = 0; i < nSamples; i++) {            subSampleStats[i] = new SummaryStatistics();        }        Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();        for (int i = 0; i < nSamples; i++) {            for (int j = 0; j < subSamples[i].length; j++) {                subSampleStats[i].addValue(subSamples[i][j]);            }            aggregate.add(subSampleStats[i]);        }        // Compare values        StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);        assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);    }    @Test    public void testAggregateDegenerate() throws Exception {        double[] totalSample = {1, 2, 3, 4, 5};        double[][] subSamples = {{1}, {2}, {3}, {4}, {5}};        // Compute combined stats directly        SummaryStatistics totalStats = new SummaryStatistics();        for (int i = 0; i < totalSample.length; i++) {            totalStats.addValue(totalSample[i]);        }        // Now compute subsample stats individually and aggregate        SummaryStatistics[] subSampleStats = new SummaryStatistics[5];        for (int i = 0; i < 5; i++) {            subSampleStats[i] = new SummaryStatistics();        }        Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();        for (int i = 0; i < 5; i++) {            for (int j = 0; j < subSamples[i].length; j++) {                subSampleStats[i].addValue(subSamples[i][j]);            }            aggregate.add(subSampleStats[i]);        }        // Compare values        StatisticalSummaryValues aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);        assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);    }    @Test    public void testAggregateSpecialValues() throws Exception {        double[] totalSample = {Double.POSITIVE_INFINITY, 2, 3, Double.NaN, 5};        double[][] subSamples = {{Double.POSITIVE_INFINITY, 2}, {3}, {Double.NaN}, {5}};        // Compute combined stats directly        SummaryStatistics totalStats = new SummaryStatistics();        for (int i = 0; i < totalSample.length; i++) {            totalStats.addValue(totalSample[i]);        }        // Now compute subsample stats individually and aggregate        SummaryStatistics[] subSampleStats = new SummaryStatistics[5];        for (int i = 0; i < 4; i++) {            subSampleStats[i] = new SummaryStatistics();        }        Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();        for (int i = 0; i < 4; i++) {            for (int j = 0; j < subSamples[i].length; j++) {                subSampleStats[i].addValue(subSamples[i][j]);            }            aggregate.add(subSampleStats[i]);        }        // Compare values        StatisticalSummaryValues aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);        assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);    }    /**     * Verifies that a StatisticalSummary and a StatisticalSummaryValues are equal up     * to delta, with NaNs, infinities returned in the same spots. For max, min, n, values     * have to agree exactly, delta is used only for sum, mean, variance, std dev.     */    protected static void assertEquals(StatisticalSummary expected, StatisticalSummary observed, double delta) {        TestUtils.assertEquals(expected.getMax(), observed.getMax(), 0);        TestUtils.assertEquals(expected.getMin(), observed.getMin(), 0);        Assert.assertEquals(expected.getN(), observed.getN());        TestUtils.assertEquals(expected.getSum(), observed.getSum(), delta);        TestUtils.assertEquals(expected.getMean(), observed.getMean(), delta);        TestUtils.assertEquals(expected.getStandardDeviation(), observed.getStandardDeviation(), delta);        TestUtils.assertEquals(expected.getVariance(), observed.getVariance(), delta);    }    /**     * Generates a random sample of double values.     * Sample size is random, between 10 and 100 and values are     * uniformly distributed over [-100, 100].     *     * @return array of random double values     */    private double[] generateSample() {        final RandomData randomData = new RandomDataImpl();        final int sampleSize = randomData.nextInt(10,100);        double[] out = new double[sampleSize];        for (int i = 0; i < out.length; i++) {            out[i] = randomData.nextUniform(-100, 100);        }        return out;    }    /**     * Generates a partition of <sample> into up to 5 sequentially selected     * subsamples with randomly selected partition points.     *     * @param sample array to partition     * @return rectangular array with rows = subsamples     */    private double[][] generatePartition(double[] sample) {        final int length = sample.length;        final double[][] out = new double[5][];        final RandomData randomData = new RandomDataImpl();        int cur = 0;        int offset = 0;        int sampleCount = 0;        for (int i = 0; i < 5; i++) {            if (cur == length || offset == length) {                break;            }            final int next = (i == 4 || cur == length - 1) ? length - 1 : randomData.nextInt(cur, length - 1);            final int subLength = next - cur + 1;            out[i] = new double[subLength];            System.arraycopy(sample, offset, out[i], 0, subLength);            cur = next + 1;            sampleCount++;            offset += subLength;        }        if (sampleCount < 5) {            double[][] out2 = new double[sampleCount][];            for (int j = 0; j < sampleCount; j++) {                final int curSize = out[j].length;                out2[j] = new double[curSize];                System.arraycopy(out[j], 0, out2[j], 0, curSize);            }            return out2;        } else {            return out;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import java.util.Locale;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.moment.Mean;import org.apache.commons.math.util.FastMath;import org.junit.Test;import org.junit.Assert;/** * Test cases for the {@link MultivariateSummaryStatistics} class. * * @version $Id$ */public class MultivariateSummaryStatisticsTest {    protected MultivariateSummaryStatistics createMultivariateSummaryStatistics(int k, boolean isCovarianceBiasCorrected) {        return new MultivariateSummaryStatistics(k, isCovarianceBiasCorrected);    }    @Test    public void testSetterInjection() throws Exception {        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);        u.setMeanImpl(new StorelessUnivariateStatistic[] {                        new sumMean(), new sumMean()                      });        u.addValue(new double[] { 1, 2 });        u.addValue(new double[] { 3, 4 });        Assert.assertEquals(4, u.getMean()[0], 1E-14);        Assert.assertEquals(6, u.getMean()[1], 1E-14);        u.clear();        u.addValue(new double[] { 1, 2 });        u.addValue(new double[] { 3, 4 });        Assert.assertEquals(4, u.getMean()[0], 1E-14);        Assert.assertEquals(6, u.getMean()[1], 1E-14);        u.clear();        u.setMeanImpl(new StorelessUnivariateStatistic[] {                        new Mean(), new Mean()                      }); // OK after clear        u.addValue(new double[] { 1, 2 });        u.addValue(new double[] { 3, 4 });        Assert.assertEquals(2, u.getMean()[0], 1E-14);        Assert.assertEquals(3, u.getMean()[1], 1E-14);        Assert.assertEquals(2, u.getDimension());    }    @Test    public void testSetterIllegalState() throws Exception {        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);        u.addValue(new double[] { 1, 2 });        u.addValue(new double[] { 3, 4 });        try {            u.setMeanImpl(new StorelessUnivariateStatistic[] {                            new sumMean(), new sumMean()                          });            Assert.fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {            // expected        }    }    @Test    public void testToString() {        MultivariateSummaryStatistics stats = createMultivariateSummaryStatistics(2, true);        stats.addValue(new double[] {1, 3});        stats.addValue(new double[] {2, 2});        stats.addValue(new double[] {3, 1});        Locale d = Locale.getDefault();        Locale.setDefault(Locale.US);        final String suffix = System.getProperty("line.separator");        Assert.assertEquals("MultivariateSummaryStatistics:" + suffix+                     "n: 3" +suffix+                     "min: 1.0, 1.0" +suffix+                     "max: 3.0, 3.0" +suffix+                     "mean: 2.0, 2.0" +suffix+                     "geometric mean: 1.817..., 1.817..." +suffix+                     "sum of squares: 14.0, 14.0" +suffix+                     "sum of logarithms: 1.791..., 1.791..." +suffix+                     "standard deviation: 1.0, 1.0" +suffix+                     "covariance: Array2DRowRealMatrix{{1.0,-1.0},{-1.0,1.0}}" +suffix,                     stats.toString().replaceAll("([0-9]+\\.[0-9][0-9][0-9])[0-9]+", "$1..."));        Locale.setDefault(d);    }    @Test    public void testShuffledStatistics() {        // the purpose of this test is only to check the get/set methods        // we are aware shuffling statistics like this is really not        // something sensible to do in production ...        MultivariateSummaryStatistics reference = createMultivariateSummaryStatistics(2, true);        MultivariateSummaryStatistics shuffled  = createMultivariateSummaryStatistics(2, true);        StorelessUnivariateStatistic[] tmp = shuffled.getGeoMeanImpl();        shuffled.setGeoMeanImpl(shuffled.getMeanImpl());        shuffled.setMeanImpl(shuffled.getMaxImpl());        shuffled.setMaxImpl(shuffled.getMinImpl());        shuffled.setMinImpl(shuffled.getSumImpl());        shuffled.setSumImpl(shuffled.getSumsqImpl());        shuffled.setSumsqImpl(shuffled.getSumLogImpl());        shuffled.setSumLogImpl(tmp);        for (int i = 100; i > 0; --i) {            reference.addValue(new double[] {i, i});            shuffled.addValue(new double[] {i, i});        }        TestUtils.assertEquals(reference.getMean(),          shuffled.getGeometricMean(), 1.0e-10);        TestUtils.assertEquals(reference.getMax(),           shuffled.getMean(),          1.0e-10);        TestUtils.assertEquals(reference.getMin(),           shuffled.getMax(),           1.0e-10);        TestUtils.assertEquals(reference.getSum(),           shuffled.getMin(),           1.0e-10);        TestUtils.assertEquals(reference.getSumSq(),         shuffled.getSum(),           1.0e-10);        TestUtils.assertEquals(reference.getSumLog(),        shuffled.getSumSq(),         1.0e-10);        TestUtils.assertEquals(reference.getGeometricMean(), shuffled.getSumLog(),        1.0e-10);    }    /**     * Bogus mean implementation to test setter injection.     * Returns the sum instead of the mean.     */    static class sumMean implements StorelessUnivariateStatistic {        private double sum = 0;        private long n = 0;        public double evaluate(double[] values, int begin, int length) {            return 0;        }        public double evaluate(double[] values) {            return 0;        }        public void clear() {          sum = 0;          n = 0;        }        public long getN() {            return n;        }        public double getResult() {            return sum;        }        public void increment(double d) {            sum += d;            n++;        }        public void incrementAll(double[] values, int start, int length) {        }        public void incrementAll(double[] values) {        }        public StorelessUnivariateStatistic copy() {            return new sumMean();        }    }    @Test    public void testDimension() {        try {            createMultivariateSummaryStatistics(2, true).addValue(new double[3]);            Assert.fail("Expecting DimensionMismatchException");        } catch (DimensionMismatchException dme) {            // expected behavior        }    }    /** test stats */    @Test    public void testStats() {        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);        Assert.assertEquals(0, u.getN());        u.addValue(new double[] { 1, 2 });        u.addValue(new double[] { 2, 3 });        u.addValue(new double[] { 2, 3 });        u.addValue(new double[] { 3, 4 });        Assert.assertEquals( 4, u.getN());        Assert.assertEquals( 8, u.getSum()[0], 1.0e-10);        Assert.assertEquals(12, u.getSum()[1], 1.0e-10);        Assert.assertEquals(18, u.getSumSq()[0], 1.0e-10);        Assert.assertEquals(38, u.getSumSq()[1], 1.0e-10);        Assert.assertEquals( 1, u.getMin()[0], 1.0e-10);        Assert.assertEquals( 2, u.getMin()[1], 1.0e-10);        Assert.assertEquals( 3, u.getMax()[0], 1.0e-10);        Assert.assertEquals( 4, u.getMax()[1], 1.0e-10);        Assert.assertEquals(2.4849066497880003102, u.getSumLog()[0], 1.0e-10);        Assert.assertEquals( 4.276666119016055311, u.getSumLog()[1], 1.0e-10);        Assert.assertEquals( 1.8612097182041991979, u.getGeometricMean()[0], 1.0e-10);        Assert.assertEquals( 2.9129506302439405217, u.getGeometricMean()[1], 1.0e-10);        Assert.assertEquals( 2, u.getMean()[0], 1.0e-10);        Assert.assertEquals( 3, u.getMean()[1], 1.0e-10);        Assert.assertEquals(FastMath.sqrt(2.0 / 3.0), u.getStandardDeviation()[0], 1.0e-10);        Assert.assertEquals(FastMath.sqrt(2.0 / 3.0), u.getStandardDeviation()[1], 1.0e-10);        Assert.assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 0), 1.0e-10);        Assert.assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 1), 1.0e-10);        Assert.assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 0), 1.0e-10);        Assert.assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 1), 1.0e-10);        u.clear();        Assert.assertEquals(0, u.getN());    }    @Test    public void testN0andN1Conditions() throws Exception {        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(1, true);        Assert.assertTrue(Double.isNaN(u.getMean()[0]));        Assert.assertTrue(Double.isNaN(u.getStandardDeviation()[0]));        /* n=1 */        u.addValue(new double[] { 1 });        Assert.assertEquals(1.0, u.getMean()[0], 1.0e-10);        Assert.assertEquals(1.0, u.getGeometricMean()[0], 1.0e-10);        Assert.assertEquals(0.0, u.getStandardDeviation()[0], 1.0e-10);        /* n=2 */        u.addValue(new double[] { 2 });        Assert.assertTrue(u.getStandardDeviation()[0] > 0);    }    @Test    public void testNaNContracts() {        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(1, true);        Assert.assertTrue(Double.isNaN(u.getMean()[0]));        Assert.assertTrue(Double.isNaN(u.getMin()[0]));        Assert.assertTrue(Double.isNaN(u.getStandardDeviation()[0]));        Assert.assertTrue(Double.isNaN(u.getGeometricMean()[0]));        u.addValue(new double[] { 1.0 });        Assert.assertFalse(Double.isNaN(u.getMean()[0]));        Assert.assertFalse(Double.isNaN(u.getMin()[0]));        Assert.assertFalse(Double.isNaN(u.getStandardDeviation()[0]));        Assert.assertFalse(Double.isNaN(u.getGeometricMean()[0]));    }    @Test    public void testSerialization() {        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);        // Empty test        TestUtils.checkSerializedEquality(u);        MultivariateSummaryStatistics s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u);        Assert.assertEquals(u, s);        // Add some data        u.addValue(new double[] { 2d, 1d });        u.addValue(new double[] { 1d, 1d });        u.addValue(new double[] { 3d, 1d });        u.addValue(new double[] { 4d, 1d });        u.addValue(new double[] { 5d, 1d });        // Test again        TestUtils.checkSerializedEquality(u);        s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u);        Assert.assertEquals(u, s);    }    @Test    public void testEqualsAndHashCode() {        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);        MultivariateSummaryStatistics t = null;        int emptyHash = u.hashCode();        Assert.assertTrue(u.equals(u));        Assert.assertFalse(u.equals(t));        Assert.assertFalse(u.equals(Double.valueOf(0)));        t = createMultivariateSummaryStatistics(2, true);        Assert.assertTrue(t.equals(u));        Assert.assertTrue(u.equals(t));        Assert.assertEquals(emptyHash, t.hashCode());        // Add some data to u        u.addValue(new double[] { 2d, 1d });        u.addValue(new double[] { 1d, 1d });        u.addValue(new double[] { 3d, 1d });        u.addValue(new double[] { 4d, 1d });        u.addValue(new double[] { 5d, 1d });        Assert.assertFalse(t.equals(u));        Assert.assertFalse(u.equals(t));        Assert.assertTrue(u.hashCode() != t.hashCode());        //Add data in same order to t        t.addValue(new double[] { 2d, 1d });        t.addValue(new double[] { 1d, 1d });        t.addValue(new double[] { 3d, 1d });        t.addValue(new double[] { 4d, 1d });        t.addValue(new double[] { 5d, 1d });        Assert.assertTrue(t.equals(u));        Assert.assertTrue(u.equals(t));        Assert.assertEquals(u.hashCode(), t.hashCode());        // Clear and make sure summaries are indistinguishable from empty summary        u.clear();        t.clear();        Assert.assertTrue(t.equals(u));        Assert.assertTrue(u.equals(t));        Assert.assertEquals(emptyHash, t.hashCode());        Assert.assertEquals(emptyHash, u.hashCode());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.stat.descriptive;/** * Test cases for the {@link SynchronizedMultivariateSummaryStatisticsTest} class. * @version $Id$ *          2007) $ */public final class SynchronizedMultivariateSummaryStatisticsTest    extends MultivariateSummaryStatisticsTest {    @Override    protected MultivariateSummaryStatistics createMultivariateSummaryStatistics(int k, boolean isCovarianceBiasCorrected) {        return new SynchronizedMultivariateSummaryStatistics(k, isCovarianceBiasCorrected);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import org.apache.commons.math.stat.descriptive.moment.FourthMoment;import org.apache.commons.math.stat.descriptive.moment.Kurtosis;import org.apache.commons.math.stat.descriptive.moment.Mean;import org.apache.commons.math.stat.descriptive.moment.Skewness;import org.apache.commons.math.stat.descriptive.moment.Variance;import org.junit.Assert;import org.junit.Test;/** * @version $Id$ */public class InteractionTest {    protected double mean = 12.40454545454550;    protected double var = 10.00235930735930;    protected double skew = 1.437423729196190;    protected double kurt = 2.377191264804700;    protected double tolerance = 10E-12;    protected double[] testArray =        {            12.5,            12,            11.8,            14.2,            14.9,            14.5,            21,            8.2,            10.3,            11.3,            14.1,            9.9,            12.2,            12,            12.1,            11,            19.8,            11,            10,            8.8,            9,            12.3 };    @Test    public void testInteraction() {        FourthMoment m4 = new FourthMoment();        Mean m = new Mean(m4);        Variance v = new Variance(m4);        Skewness s= new Skewness(m4);        Kurtosis k = new Kurtosis(m4);        for (int i = 0; i < testArray.length; i++){            m4.increment(testArray[i]);        }        Assert.assertEquals(mean,m.getResult(),tolerance);        Assert.assertEquals(var,v.getResult(),tolerance);        Assert.assertEquals(skew ,s.getResult(),tolerance);        Assert.assertEquals(kurt,k.getResult(),tolerance);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.moment.SecondMoment;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test cases for {@link StorelessUnivariateStatistic} classes. * @version $Id$ */public abstract class StorelessUnivariateStatisticAbstractTest    extends UnivariateStatisticAbstractTest {    /** Small sample arrays */    protected double[][] smallSamples = {{}, {1}, {1,2}, {1,2,3}, {1,2,3,4}};    /** Return a new instance of the statistic */    @Override    public abstract UnivariateStatistic getUnivariateStatistic();    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */    @Override    public abstract double expectedValue();    /**     *  Verifies that increment() and incrementAll work properly.     */    @Test    public void testIncrementation() throws Exception {        StorelessUnivariateStatistic statistic =            (StorelessUnivariateStatistic) getUnivariateStatistic();        // Add testArray one value at a time and check result        for (int i = 0; i < testArray.length; i++) {            statistic.increment(testArray[i]);        }        Assert.assertEquals(expectedValue(), statistic.getResult(), getTolerance());        Assert.assertEquals(testArray.length, statistic.getN());        statistic.clear();        // Add testArray all at once and check again        statistic.incrementAll(testArray);        Assert.assertEquals(expectedValue(), statistic.getResult(), getTolerance());        Assert.assertEquals(testArray.length, statistic.getN());        statistic.clear();        // Cleared        checkClearValue(statistic);        Assert.assertEquals(0, statistic.getN());    }    protected void checkClearValue(StorelessUnivariateStatistic statistic){        Assert.assertTrue(Double.isNaN(statistic.getResult()));    }        @Test    public void testSerialization() throws Exception {        StorelessUnivariateStatistic statistic =            (StorelessUnivariateStatistic) getUnivariateStatistic();        TestUtils.checkSerializedEquality(statistic);        statistic.clear();        for (int i = 0; i < testArray.length; i++) {            statistic.increment(testArray[i]);            if(i % 5 == 0)                statistic = (StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);        }        TestUtils.checkSerializedEquality(statistic);        Assert.assertEquals(expectedValue(), statistic.getResult(), getTolerance());        statistic.clear();        checkClearValue(statistic);    }    @Test    public void testEqualsAndHashCode() {        StorelessUnivariateStatistic statistic =            (StorelessUnivariateStatistic) getUnivariateStatistic();        StorelessUnivariateStatistic statistic2 = null;        Assert.assertTrue("non-null, compared to null", !statistic.equals(statistic2));        Assert.assertTrue("reflexive, non-null", statistic.equals(statistic));        int emptyHash = statistic.hashCode();        statistic2 = (StorelessUnivariateStatistic) getUnivariateStatistic();        Assert.assertTrue("empty stats should be equal", statistic.equals(statistic2));        Assert.assertEquals("empty stats should have the same hashcode",                emptyHash, statistic2.hashCode());        statistic.increment(1d);        Assert.assertTrue("reflexive, non-empty", statistic.equals(statistic));        Assert.assertTrue("non-empty, compared to empty", !statistic.equals(statistic2));        Assert.assertTrue("non-empty, compared to empty", !statistic2.equals(statistic));        Assert.assertTrue("non-empty stat should have different hashcode from empty stat",                statistic.hashCode() != emptyHash);        statistic2.increment(1d);        Assert.assertTrue("stats with same data should be equal", statistic.equals(statistic2));        Assert.assertEquals("stats with same data should have the same hashcode",                statistic.hashCode(), statistic2.hashCode());        statistic.increment(Double.POSITIVE_INFINITY);        Assert.assertTrue("stats with different n's should not be equal", !statistic2.equals(statistic));        Assert.assertTrue("stats with different n's should have different hashcodes",                statistic.hashCode() != statistic2.hashCode());        statistic2.increment(Double.POSITIVE_INFINITY);        Assert.assertTrue("stats with same data should be equal", statistic.equals(statistic2));        Assert.assertEquals("stats with same data should have the same hashcode",                statistic.hashCode(), statistic2.hashCode());        statistic.clear();        statistic2.clear();        Assert.assertTrue("cleared stats should be equal", statistic.equals(statistic2));        Assert.assertEquals("cleared stats should have thashcode of empty stat",                emptyHash, statistic2.hashCode());        Assert.assertEquals("cleared stats should have thashcode of empty stat",                emptyHash, statistic.hashCode());    }    @Test    public void testMomentSmallSamples() {        UnivariateStatistic stat = getUnivariateStatistic();        if (stat instanceof SecondMoment) {            SecondMoment moment = (SecondMoment) getUnivariateStatistic();            Assert.assertTrue(Double.isNaN(moment.getResult()));            moment.increment(1d);            Assert.assertEquals(0d, moment.getResult(), 0);        }    }    /**     * Make sure that evaluate(double[]) and inrementAll(double[]),     * getResult() give same results.     */    @Test    public void testConsistency() {        StorelessUnivariateStatistic stat = (StorelessUnivariateStatistic) getUnivariateStatistic();        stat.incrementAll(testArray);        Assert.assertEquals(stat.getResult(), stat.evaluate(testArray), getTolerance());        for (int i = 0; i < smallSamples.length; i++) {            stat.clear();            for (int j =0; j < smallSamples[i].length; j++) {                stat.increment(smallSamples[i][j]);            }            TestUtils.assertEquals(stat.getResult(), stat.evaluate(smallSamples[i]), getTolerance());        }    }    /**     * Verifies that copied statistics remain equal to originals when     * incremented the same way.     *     */    @Test    public void testCopyConsistency() {        StorelessUnivariateStatistic master =            (StorelessUnivariateStatistic) getUnivariateStatistic();        StorelessUnivariateStatistic replica = null;        // Randomly select a portion of testArray to load first        long index = FastMath.round((FastMath.random()) * testArray.length);        // Put first half in master and copy master to replica        master.incrementAll(testArray, 0, (int) index);        replica = master.copy();        // Check same        Assert.assertTrue(replica.equals(master));        Assert.assertTrue(master.equals(replica));        // Now add second part to both and check again        master.incrementAll(testArray,                (int) index, (int) (testArray.length - index));        replica.incrementAll(testArray,                (int) index, (int) (testArray.length - index));        Assert.assertTrue(replica.equals(master));        Assert.assertTrue(master.equals(replica));    }    @Test    public void testSerial() {        StorelessUnivariateStatistic s =            (StorelessUnivariateStatistic) getUnivariateStatistic();        Assert.assertEquals(s, TestUtils.serializeAndRecover(s));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.stat.descriptive.SummaryStatistics;import org.junit.Assert;import org.junit.Before;import org.junit.Test;/** * Test cases for the TTestImpl class. * * @version $Id$ */public class TTestTest {    protected TTest testStatistic = new TTestImpl();    private double[] tooShortObs = { 1.0 };    private double[] emptyObs = {};    private SummaryStatistics emptyStats = new SummaryStatistics();   SummaryStatistics tooShortStats = null;    @Before    public void setUp() {        tooShortStats = new SummaryStatistics();        tooShortStats.addValue(0d);    }    @Test    public void testOneSampleT() throws Exception {        double[] observed =            {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0,  88.0, 98.0, 94.0, 101.0, 92.0, 95.0 };        double mu = 100.0;        SummaryStatistics sampleStats = null;        sampleStats = new SummaryStatistics();        for (int i = 0; i < observed.length; i++) {            sampleStats.addValue(observed[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        Assert.assertEquals("t statistic",  -2.81976445346,                testStatistic.t(mu, observed), 10E-10);        Assert.assertEquals("t statistic",  -2.81976445346,                testStatistic.t(mu, sampleStats), 10E-10);        Assert.assertEquals("p value", 0.0136390585873,                testStatistic.tTest(mu, observed), 10E-10);        Assert.assertEquals("p value", 0.0136390585873,                testStatistic.tTest(mu, sampleStats), 10E-10);        try {            testStatistic.t(mu, (double[]) null);            Assert.fail("arguments too short, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(mu, (SummaryStatistics) null);            Assert.fail("arguments too short, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(mu, emptyObs);            Assert.fail("arguments too short, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(mu, emptyStats);            Assert.fail("arguments too short, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(mu, tooShortObs);            Assert.fail("insufficient data to compute t statistic, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.tTest(mu, tooShortObs);            Assert.fail("insufficient data to perform t test, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {           // expected        }        try {            testStatistic.t(mu, tooShortStats);            Assert.fail("insufficient data to compute t statistic, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.tTest(mu, tooShortStats);            Assert.fail("insufficient data to perform t test, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testOneSampleTTest() throws Exception {        double[] oneSidedP =            {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d };        SummaryStatistics oneSidedPStats = new SummaryStatistics();        for (int i = 0; i < oneSidedP.length; i++) {            oneSidedPStats.addValue(oneSidedP[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        Assert.assertEquals("one sample t stat", 3.86485535541,                testStatistic.t(0d, oneSidedP), 10E-10);        Assert.assertEquals("one sample t stat", 3.86485535541,                testStatistic.t(0d, oneSidedPStats),1E-10);        Assert.assertEquals("one sample p value", 0.000521637019637,                testStatistic.tTest(0d, oneSidedP) / 2d, 10E-10);        Assert.assertEquals("one sample p value", 0.000521637019637,                testStatistic.tTest(0d, oneSidedPStats) / 2d, 10E-5);        Assert.assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedP, 0.01));        Assert.assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedPStats, 0.01));        Assert.assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedP, 0.0001));        Assert.assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedPStats, 0.0001));        try {            testStatistic.tTest(0d, oneSidedP, 95);            Assert.fail("alpha out of range, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.tTest(0d, oneSidedPStats, 95);            Assert.fail("alpha out of range, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testTwoSampleTHeterscedastic() throws Exception {        double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };        double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };        SummaryStatistics sampleStats1 = new SummaryStatistics();        for (int i = 0; i < sample1.length; i++) {            sampleStats1.addValue(sample1[i]);        }        SummaryStatistics sampleStats2 = new SummaryStatistics();        for (int i = 0; i < sample2.length; i++) {            sampleStats2.addValue(sample2[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        Assert.assertEquals("two sample heteroscedastic t stat", 1.60371728768,                testStatistic.t(sample1, sample2), 1E-10);        Assert.assertEquals("two sample heteroscedastic t stat", 1.60371728768,                testStatistic.t(sampleStats1, sampleStats2), 1E-10);        Assert.assertEquals("two sample heteroscedastic p value", 0.128839369622,                testStatistic.tTest(sample1, sample2), 1E-10);        Assert.assertEquals("two sample heteroscedastic p value", 0.128839369622,                testStatistic.tTest(sampleStats1, sampleStats2), 1E-10);        Assert.assertTrue("two sample heteroscedastic t-test reject",                testStatistic.tTest(sample1, sample2, 0.2));        Assert.assertTrue("two sample heteroscedastic t-test reject",                testStatistic.tTest(sampleStats1, sampleStats2, 0.2));        Assert.assertTrue("two sample heteroscedastic t-test accept",                !testStatistic.tTest(sample1, sample2, 0.1));        Assert.assertTrue("two sample heteroscedastic t-test accept",                !testStatistic.tTest(sampleStats1, sampleStats2, 0.1));        try {            testStatistic.tTest(sample1, sample2, .95);            Assert.fail("alpha out of range, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.tTest(sampleStats1, sampleStats2, .95);            Assert.fail("alpha out of range, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.tTest(sample1, tooShortObs, .01);            Assert.fail("insufficient data, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.tTest(sampleStats1, tooShortStats, .01);            Assert.fail("insufficient data, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.tTest(sample1, tooShortObs);            Assert.fail("insufficient data, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {           // expected        }        try {            testStatistic.tTest(sampleStats1, tooShortStats);            Assert.fail("insufficient data, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(sample1, tooShortObs);            Assert.fail("insufficient data, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(sampleStats1, tooShortStats);            Assert.fail("insufficient data, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {           // expected        }    }    @Test    public void testTwoSampleTHomoscedastic() throws Exception {        double[] sample1 ={2, 4, 6, 8, 10, 97};        double[] sample2 = {4, 6, 8, 10, 16};        SummaryStatistics sampleStats1 = new SummaryStatistics();        for (int i = 0; i < sample1.length; i++) {            sampleStats1.addValue(sample1[i]);        }        SummaryStatistics sampleStats2 = new SummaryStatistics();        for (int i = 0; i < sample2.length; i++) {            sampleStats2.addValue(sample2[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        Assert.assertEquals("two sample homoscedastic t stat", 0.73096310086,              testStatistic.homoscedasticT(sample1, sample2), 10E-11);        Assert.assertEquals("two sample homoscedastic p value", 0.4833963785,                testStatistic.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);        Assert.assertTrue("two sample homoscedastic t-test reject",                testStatistic.homoscedasticTTest(sample1, sample2, 0.49));        Assert.assertTrue("two sample homoscedastic t-test accept",                !testStatistic.homoscedasticTTest(sample1, sample2, 0.48));    }    @Test    public void testSmallSamples() throws Exception {        double[] sample1 = {1d, 3d};        double[] sample2 = {4d, 5d};        // Target values computed using R, version 1.8.1 (linux version)        Assert.assertEquals(-2.2360679775, testStatistic.t(sample1, sample2),                1E-10);        Assert.assertEquals(0.198727388935, testStatistic.tTest(sample1, sample2),                1E-10);    }    @Test    public void testPaired() throws Exception {        double[] sample1 = {1d, 3d, 5d, 7d};        double[] sample2 = {0d, 6d, 11d, 2d};        double[] sample3 = {5d, 7d, 8d, 10d};        // Target values computed using R, version 1.8.1 (linux version)        Assert.assertEquals(-0.3133, testStatistic.pairedT(sample1, sample2), 1E-4);        Assert.assertEquals(0.774544295819, testStatistic.pairedTTest(sample1, sample2), 1E-10);        Assert.assertEquals(0.001208, testStatistic.pairedTTest(sample1, sample3), 1E-6);        Assert.assertFalse(testStatistic.pairedTTest(sample1, sample3, .001));        Assert.assertTrue(testStatistic.pairedTTest(sample1, sample3, .002));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import java.util.ArrayList;import java.util.List;import org.junit.Assert;import org.junit.Test;/** * Test cases for the OneWayAnovaImpl class. * * @version $Id$ */public class OneWayAnovaTest {    protected OneWayAnova testStatistic = new OneWayAnovaImpl();    private double[] emptyArray = {};    private double[] classA =            {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };    private double[] classB =            {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };    private double[] classC =            {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };    @Test    public void testAnovaFValue() throws Exception {        // Target comparison values computed using R version 2.6.0 (Linux version)        List<double[]> threeClasses = new ArrayList<double[]>();        threeClasses.add(classA);        threeClasses.add(classB);        threeClasses.add(classC);        Assert.assertEquals("ANOVA F-value",  24.67361709460624,                 testStatistic.anovaFValue(threeClasses), 1E-12);        List<double[]> twoClasses = new ArrayList<double[]>();        twoClasses.add(classA);        twoClasses.add(classB);        Assert.assertEquals("ANOVA F-value",  0.0150579150579,                 testStatistic.anovaFValue(twoClasses), 1E-12);        List<double[]> emptyContents = new ArrayList<double[]>();        emptyContents.add(emptyArray);        emptyContents.add(classC);        try {            testStatistic.anovaFValue(emptyContents);            Assert.fail("empty array for key classX, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        List<double[]> tooFew = new ArrayList<double[]>();        tooFew.add(classA);        try {            testStatistic.anovaFValue(tooFew);            Assert.fail("less than two classes, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }    }    @Test    public void testAnovaPValue() throws Exception {        // Target comparison values computed using R version 2.6.0 (Linux version)        List<double[]> threeClasses = new ArrayList<double[]>();        threeClasses.add(classA);        threeClasses.add(classB);        threeClasses.add(classC);        Assert.assertEquals("ANOVA P-value", 6.959446E-06,                 testStatistic.anovaPValue(threeClasses), 1E-12);        List<double[]> twoClasses = new ArrayList<double[]>();        twoClasses.add(classA);        twoClasses.add(classB);        Assert.assertEquals("ANOVA P-value",  0.904212960464,                 testStatistic.anovaPValue(twoClasses), 1E-12);    }    @Test    public void testAnovaTest() throws Exception {        // Target comparison values computed using R version 2.3.1 (Linux version)        List<double[]> threeClasses = new ArrayList<double[]>();        threeClasses.add(classA);        threeClasses.add(classB);        threeClasses.add(classC);        Assert.assertTrue("ANOVA Test P<0.01", testStatistic.anovaTest(threeClasses, 0.01));        List<double[]> twoClasses = new ArrayList<double[]>();        twoClasses.add(classA);        twoClasses.add(classB);        Assert.assertFalse("ANOVA Test P>0.01", testStatistic.anovaTest(twoClasses, 0.01));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.junit.Assert;import org.junit.Test;/** * Test cases for the ChiSquareTestImpl class. * * @version $Id$ */public class MannWhitneyUTestTest {    protected MannWhitneyUTest testStatistic = new MannWhitneyUTestImpl();    @Test    public void testMannWhitneyUSimple() throws Exception {        /* Target values computed using R version 2.11.1         * x <- c(19, 22, 16, 29, 24)         * y <- c(20, 11, 17, 12)         * wilcox.test(x, y, alternative = "two.sided", mu = 0, paired = FALSE, exact = FALSE, correct = FALSE)         * W = 17, p-value = 0.08641          */        final double x[] = {19, 22, 16, 29, 24};        final double y[] = {20, 11, 17, 12};                Assert.assertEquals(17, testStatistic.mannWhitneyU(x, y), 1e-10);        Assert.assertEquals(0.08641, testStatistic.mannWhitneyUTest(x, y), 1e-5);    }    @Test    public void testMannWhitneyUInputValidation() throws Exception {        /* Samples must be present, i.e. length > 0         */        try {            testStatistic.mannWhitneyUTest(new double[] { }, new double[] { 1.0 });            Assert.fail("x does not contain samples (exact), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.mannWhitneyUTest(new double[] { 1.0 }, new double[] { });            Assert.fail("y does not contain samples (exact), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        /*         * x and y is null         */        try {            testStatistic.mannWhitneyUTest(null, null);            Assert.fail("x and y is null (exact), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                try {            testStatistic.mannWhitneyUTest(null, null);            Assert.fail("x and y is null (asymptotic), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                /*         * x or y is null         */        try {            testStatistic.mannWhitneyUTest(null, new double[] { 1.0 });            Assert.fail("x is null (exact), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                try {            testStatistic.mannWhitneyUTest(new double[] { 1.0 }, null);            Assert.fail("y is null (exact), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.junit.Assert;import org.junit.Test;/** * Test cases for the ChiSquareTestImpl class. * * @version $Id$ */public class ChiSquareTestTest {    protected UnknownDistributionChiSquareTest testStatistic = new ChiSquareTestImpl();    @Test    public void testChiSquare() throws Exception {        // Target values computed using R version 1.8.1        // Some assembly required ;-)        //      Use sum((obs - exp)^2/exp) for the chi-square statistic and        //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value        long[] observed = {10, 9, 11};        double[] expected = {10, 10, 10};        Assert.assertEquals("chi-square statistic", 0.2,  testStatistic.chiSquare(expected, observed), 10E-12);        Assert.assertEquals("chi-square p-value", 0.904837418036, testStatistic.chiSquareTest(expected, observed), 1E-10);        long[] observed1 = { 500, 623, 72, 70, 31 };        double[] expected1 = { 485, 541, 82, 61, 37 };        Assert.assertEquals( "chi-square test statistic", 9.023307936427388, testStatistic.chiSquare(expected1, observed1), 1E-10);        Assert.assertEquals("chi-square p-value", 0.06051952647453607, testStatistic.chiSquareTest(expected1, observed1), 1E-9);        Assert.assertTrue("chi-square test reject", testStatistic.chiSquareTest(expected1, observed1, 0.08));        Assert.assertTrue("chi-square test accept", !testStatistic.chiSquareTest(expected1, observed1, 0.05));        try {            testStatistic.chiSquareTest(expected1, observed1, 95);            Assert.fail("alpha out of range, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        long[] tooShortObs = { 0 };        double[] tooShortEx = { 1 };        try {            testStatistic.chiSquare(tooShortEx, tooShortObs);            Assert.fail("arguments too short, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        // unmatched arrays        long[] unMatchedObs = { 0, 1, 2, 3 };        double[] unMatchedEx = { 1, 1, 2 };        try {            testStatistic.chiSquare(unMatchedEx, unMatchedObs);            Assert.fail("arrays have different lengths, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        // 0 expected count        expected[0] = 0;        try {            testStatistic.chiSquareTest(expected, observed, .01);            Assert.fail("bad expected count, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        // negative observed count        expected[0] = 1;        observed[0] = -1;        try {            testStatistic.chiSquareTest(expected, observed, .01);            Assert.fail("bad expected count, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testChiSquareIndependence() throws Exception {        // Target values computed using R version 1.8.1        long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};        Assert.assertEquals( "chi-square test statistic", 22.709027688, testStatistic.chiSquare(counts), 1E-9);        Assert.assertEquals("chi-square p-value", 0.000144751460134, testStatistic.chiSquareTest(counts), 1E-9);        Assert.assertTrue("chi-square test reject", testStatistic.chiSquareTest(counts, 0.0002));        Assert.assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts, 0.0001));        long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };        Assert.assertEquals( "chi-square test statistic", 0.168965517241, testStatistic.chiSquare(counts2), 1E-9);        Assert.assertEquals("chi-square p-value",0.918987499852, testStatistic.chiSquareTest(counts2), 1E-9);        Assert.assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts2, 0.1));        // ragged input array        long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};        try {            testStatistic.chiSquare(counts3);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        // insufficient data        long[][] counts4 = {{40, 22, 43}};        try {            testStatistic.chiSquare(counts4);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        long[][] counts5 = {{40}, {40}, {30}, {10}};        try {            testStatistic.chiSquare(counts5);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        // negative counts        long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };        try {            testStatistic.chiSquare(counts6);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        // bad alpha        try {            testStatistic.chiSquareTest(counts, 0);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testChiSquareLargeTestStatistic() throws Exception {        double[] exp = new double[] {            3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0,            232921.0, 437665.75        };        long[] obs = new long[] {            2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899        };        org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =            new org.apache.commons.math.stat.inference.ChiSquareTestImpl();        double cst = csti.chiSquareTest(exp, obs);        Assert.assertEquals("chi-square p-value", 0.0, cst, 1E-3);        Assert.assertEquals( "chi-square test statistic",                114875.90421929007, testStatistic.chiSquare(exp, obs), 1E-9);    }    /** Contingency table containing zeros - PR # 32531 */    @Test    public void testChiSquareZeroCount() throws Exception {        // Target values computed using R version 1.8.1        long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};        Assert.assertEquals( "chi-square test statistic", 9.67444662263,                testStatistic.chiSquare(counts), 1E-9);        Assert.assertEquals("chi-square p-value", 0.0462835770603,                testStatistic.chiSquareTest(counts), 1E-9);    }    /** Target values verified using DATAPLOT version 2006.3 */    @Test    public void testChiSquareDataSetsComparisonEqualCounts()    throws Exception {        long[] observed1 = {10, 12, 12, 10};        long[] observed2 = {5, 15, 14, 10};        Assert.assertEquals("chi-square p value", 0.541096,                testStatistic.chiSquareTestDataSetsComparison(                observed1, observed2), 1E-6);        Assert.assertEquals("chi-square test statistic", 2.153846,                testStatistic.chiSquareDataSetsComparison(                observed1, observed2), 1E-6);        Assert.assertFalse("chi-square test result",                testStatistic.chiSquareTestDataSetsComparison(                observed1, observed2, 0.4));    }    /** Target values verified using DATAPLOT version 2006.3 */    @Test    public void testChiSquareDataSetsComparisonUnEqualCounts()    throws Exception {        long[] observed1 = {10, 12, 12, 10, 15};        long[] observed2 = {15, 10, 10, 15, 5};        Assert.assertEquals("chi-square p value", 0.124115,                testStatistic.chiSquareTestDataSetsComparison(                observed1, observed2), 1E-6);        Assert.assertEquals("chi-square test statistic", 7.232189,                testStatistic.chiSquareDataSetsComparison(                observed1, observed2), 1E-6);        Assert.assertTrue("chi-square test result",                testStatistic.chiSquareTestDataSetsComparison(                observed1, observed2, 0.13));        Assert.assertFalse("chi-square test result",                testStatistic.chiSquareTestDataSetsComparison(                observed1, observed2, 0.12));    }    @Test    public void testChiSquareDataSetsComparisonBadCounts()    throws Exception {        long[] observed1 = {10, -1, 12, 10, 15};        long[] observed2 = {15, 10, 10, 15, 5};        try {            testStatistic.chiSquareTestDataSetsComparison(                    observed1, observed2);            Assert.fail("Expecting MathIllegalArgumentException - negative count");        } catch (MathIllegalArgumentException ex) {            // expected        }        long[] observed3 = {10, 0, 12, 10, 15};        long[] observed4 = {15, 0, 10, 15, 5};        try {            testStatistic.chiSquareTestDataSetsComparison(                    observed3, observed4);            Assert.fail("Expecting MathIllegalArgumentException - double 0's");        } catch (MathIllegalArgumentException ex) {            // expected        }        long[] observed5 = {10, 10, 12, 10, 15};        long[] observed6 = {0, 0, 0, 0, 0};        try {            testStatistic.chiSquareTestDataSetsComparison(                    observed5, observed6);            Assert.fail("Expecting MathIllegalArgumentException - vanishing counts");        } catch (MathIllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import java.util.ArrayList;import java.util.List;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.stat.descriptive.SummaryStatistics;import org.junit.Assert;import org.junit.Test;/** * Test cases for the TestUtils class. * * @version $Id$ */public class TestUtilsTest {    @Test    public void testChiSquare() throws Exception {        // Target values computed using R version 1.8.1        // Some assembly required ;-)        //      Use sum((obs - exp)^2/exp) for the chi-square statistic and        //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value        long[] observed = {10, 9, 11};        double[] expected = {10, 10, 10};        Assert.assertEquals("chi-square statistic", 0.2,  TestUtils.chiSquare(expected, observed), 10E-12);        Assert.assertEquals("chi-square p-value", 0.904837418036, TestUtils.chiSquareTest(expected, observed), 1E-10);        long[] observed1 = { 500, 623, 72, 70, 31 };        double[] expected1 = { 485, 541, 82, 61, 37 };        Assert.assertEquals( "chi-square test statistic", 9.023307936427388, TestUtils.chiSquare(expected1, observed1), 1E-10);        Assert.assertEquals("chi-square p-value", 0.06051952647453607, TestUtils.chiSquareTest(expected1, observed1), 1E-9);        Assert.assertTrue("chi-square test reject", TestUtils.chiSquareTest(expected1, observed1, 0.07));        Assert.assertTrue("chi-square test accept", !TestUtils.chiSquareTest(expected1, observed1, 0.05));        try {            TestUtils.chiSquareTest(expected1, observed1, 95);            Assert.fail("alpha out of range, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        long[] tooShortObs = { 0 };        double[] tooShortEx = { 1 };        try {            TestUtils.chiSquare(tooShortEx, tooShortObs);            Assert.fail("arguments too short, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        // unmatched arrays        long[] unMatchedObs = { 0, 1, 2, 3 };        double[] unMatchedEx = { 1, 1, 2 };        try {            TestUtils.chiSquare(unMatchedEx, unMatchedObs);            Assert.fail("arrays have different lengths, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        // 0 expected count        expected[0] = 0;        try {            TestUtils.chiSquareTest(expected, observed, .01);            Assert.fail("bad expected count, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        // negative observed count        expected[0] = 1;        observed[0] = -1;        try {            TestUtils.chiSquareTest(expected, observed, .01);            Assert.fail("bad expected count, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testChiSquareIndependence() throws Exception {        // Target values computed using R version 1.8.1        long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};        Assert.assertEquals( "chi-square test statistic", 22.709027688, TestUtils.chiSquare(counts), 1E-9);        Assert.assertEquals("chi-square p-value", 0.000144751460134, TestUtils.chiSquareTest(counts), 1E-9);        Assert.assertTrue("chi-square test reject", TestUtils.chiSquareTest(counts, 0.0002));        Assert.assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts, 0.0001));        long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };        Assert.assertEquals( "chi-square test statistic", 0.168965517241, TestUtils.chiSquare(counts2), 1E-9);        Assert.assertEquals("chi-square p-value",0.918987499852, TestUtils.chiSquareTest(counts2), 1E-9);        Assert.assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts2, 0.1));        // ragged input array        long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};        try {            TestUtils.chiSquare(counts3);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        // insufficient data        long[][] counts4 = {{40, 22, 43}};        try {            TestUtils.chiSquare(counts4);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        long[][] counts5 = {{40}, {40}, {30}, {10}};        try {            TestUtils.chiSquare(counts5);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        // negative counts        long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };        try {            TestUtils.chiSquare(counts6);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        // bad alpha        try {            TestUtils.chiSquareTest(counts, 0);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testChiSquareLargeTestStatistic() throws Exception {        double[] exp = new double[] {                3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0,                232921.0, 437665.75        };        long[] obs = new long[] {                2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899        };        org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =            new org.apache.commons.math.stat.inference.ChiSquareTestImpl();        double cst = csti.chiSquareTest(exp, obs);        Assert.assertEquals("chi-square p-value", 0.0, cst, 1E-3);        Assert.assertEquals( "chi-square test statistic",                114875.90421929007, TestUtils.chiSquare(exp, obs), 1E-9);    }    /** Contingency table containing zeros - PR # 32531 */    @Test    public void testChiSquareZeroCount() throws Exception {        // Target values computed using R version 1.8.1        long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};        Assert.assertEquals( "chi-square test statistic", 9.67444662263,                TestUtils.chiSquare(counts), 1E-9);        Assert.assertEquals("chi-square p-value", 0.0462835770603,                TestUtils.chiSquareTest(counts), 1E-9);    }    private double[] tooShortObs = { 1.0 };    private double[] emptyObs = {};    private SummaryStatistics emptyStats = new SummaryStatistics();    @Test    public void testOneSampleT() throws Exception {        double[] observed =            {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0,  88.0, 98.0, 94.0, 101.0, 92.0, 95.0 };        double mu = 100.0;        SummaryStatistics sampleStats = null;        sampleStats = new SummaryStatistics();        for (int i = 0; i < observed.length; i++) {            sampleStats.addValue(observed[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        Assert.assertEquals("t statistic",  -2.81976445346,                TestUtils.t(mu, observed), 10E-10);        Assert.assertEquals("t statistic",  -2.81976445346,                TestUtils.t(mu, sampleStats), 10E-10);        Assert.assertEquals("p value", 0.0136390585873,                TestUtils.tTest(mu, observed), 10E-10);        Assert.assertEquals("p value", 0.0136390585873,                TestUtils.tTest(mu, sampleStats), 10E-10);        try {            TestUtils.t(mu, (double[]) null);            Assert.fail("arguments too short, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(mu, (SummaryStatistics) null);            Assert.fail("arguments too short, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(mu, emptyObs);            Assert.fail("arguments too short, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(mu, emptyStats);            Assert.fail("arguments too short, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(mu, tooShortObs);            Assert.fail("insufficient data to compute t statistic, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(mu, tooShortObs);            Assert.fail("insufficient data to perform t test, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(mu, (SummaryStatistics) null);            Assert.fail("insufficient data to compute t statistic, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(mu, (SummaryStatistics) null);            Assert.fail("insufficient data to perform t test, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testOneSampleTTest() throws Exception {        double[] oneSidedP =            {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d };        SummaryStatistics oneSidedPStats = new SummaryStatistics();        for (int i = 0; i < oneSidedP.length; i++) {            oneSidedPStats.addValue(oneSidedP[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        Assert.assertEquals("one sample t stat", 3.86485535541,                TestUtils.t(0d, oneSidedP), 10E-10);        Assert.assertEquals("one sample t stat", 3.86485535541,                TestUtils.t(0d, oneSidedPStats),1E-10);        Assert.assertEquals("one sample p value", 0.000521637019637,                TestUtils.tTest(0d, oneSidedP) / 2d, 10E-10);        Assert.assertEquals("one sample p value", 0.000521637019637,                TestUtils.tTest(0d, oneSidedPStats) / 2d, 10E-5);        Assert.assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedP, 0.01));        Assert.assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedPStats, 0.01));        Assert.assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedP, 0.0001));        Assert.assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedPStats, 0.0001));        try {            TestUtils.tTest(0d, oneSidedP, 95);            Assert.fail("alpha out of range, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(0d, oneSidedPStats, 95);            Assert.fail("alpha out of range, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testTwoSampleTHeterscedastic() throws Exception {        double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };        double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };        SummaryStatistics sampleStats1 = new SummaryStatistics();        for (int i = 0; i < sample1.length; i++) {            sampleStats1.addValue(sample1[i]);        }        SummaryStatistics sampleStats2 = new SummaryStatistics();        for (int i = 0; i < sample2.length; i++) {            sampleStats2.addValue(sample2[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        Assert.assertEquals("two sample heteroscedastic t stat", 1.60371728768,                TestUtils.t(sample1, sample2), 1E-10);        Assert.assertEquals("two sample heteroscedastic t stat", 1.60371728768,                TestUtils.t(sampleStats1, sampleStats2), 1E-10);        Assert.assertEquals("two sample heteroscedastic p value", 0.128839369622,                TestUtils.tTest(sample1, sample2), 1E-10);        Assert.assertEquals("two sample heteroscedastic p value", 0.128839369622,                TestUtils.tTest(sampleStats1, sampleStats2), 1E-10);        Assert.assertTrue("two sample heteroscedastic t-test reject",                TestUtils.tTest(sample1, sample2, 0.2));        Assert.assertTrue("two sample heteroscedastic t-test reject",                TestUtils.tTest(sampleStats1, sampleStats2, 0.2));        Assert.assertTrue("two sample heteroscedastic t-test accept",                !TestUtils.tTest(sample1, sample2, 0.1));        Assert.assertTrue("two sample heteroscedastic t-test accept",                !TestUtils.tTest(sampleStats1, sampleStats2, 0.1));        try {            TestUtils.tTest(sample1, sample2, .95);            Assert.fail("alpha out of range, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(sampleStats1, sampleStats2, .95);            Assert.fail("alpha out of range, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(sample1, tooShortObs, .01);            Assert.fail("insufficient data, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(sampleStats1, (SummaryStatistics) null, .01);            Assert.fail("insufficient data, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(sample1, tooShortObs);            Assert.fail("insufficient data, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(sampleStats1, (SummaryStatistics) null);            Assert.fail("insufficient data, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(sample1, tooShortObs);            Assert.fail("insufficient data, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(sampleStats1, (SummaryStatistics) null);            Assert.fail("insufficient data, MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testTwoSampleTHomoscedastic() throws Exception {        double[] sample1 ={2, 4, 6, 8, 10, 97};        double[] sample2 = {4, 6, 8, 10, 16};        SummaryStatistics sampleStats1 = new SummaryStatistics();        for (int i = 0; i < sample1.length; i++) {            sampleStats1.addValue(sample1[i]);        }        SummaryStatistics sampleStats2 = new SummaryStatistics();        for (int i = 0; i < sample2.length; i++) {            sampleStats2.addValue(sample2[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        Assert.assertEquals("two sample homoscedastic t stat", 0.73096310086,                TestUtils.homoscedasticT(sample1, sample2), 10E-11);        Assert.assertEquals("two sample homoscedastic p value", 0.4833963785,                TestUtils.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);        Assert.assertTrue("two sample homoscedastic t-test reject",                TestUtils.homoscedasticTTest(sample1, sample2, 0.49));        Assert.assertTrue("two sample homoscedastic t-test accept",                !TestUtils.homoscedasticTTest(sample1, sample2, 0.48));    }    @Test    public void testSmallSamples() throws Exception {        double[] sample1 = {1d, 3d};        double[] sample2 = {4d, 5d};        // Target values computed using R, version 1.8.1 (linux version)        Assert.assertEquals(-2.2360679775, TestUtils.t(sample1, sample2),                1E-10);        Assert.assertEquals(0.198727388935, TestUtils.tTest(sample1, sample2),                1E-10);    }    @Test    public void testPaired() throws Exception {        double[] sample1 = {1d, 3d, 5d, 7d};        double[] sample2 = {0d, 6d, 11d, 2d};        double[] sample3 = {5d, 7d, 8d, 10d};        // Target values computed using R, version 1.8.1 (linux version)        Assert.assertEquals(-0.3133, TestUtils.pairedT(sample1, sample2), 1E-4);        Assert.assertEquals(0.774544295819, TestUtils.pairedTTest(sample1, sample2), 1E-10);        Assert.assertEquals(0.001208, TestUtils.pairedTTest(sample1, sample3), 1E-6);        Assert.assertFalse(TestUtils.pairedTTest(sample1, sample3, .001));        Assert.assertTrue(TestUtils.pairedTTest(sample1, sample3, .002));    }    private double[] classA =      {93.0, 103.0, 95.0, 101.0};    private double[] classB =      {99.0, 92.0, 102.0, 100.0, 102.0};    private double[] classC =      {110.0, 115.0, 111.0, 117.0, 128.0};    private List<double[]> classes = new ArrayList<double[]>();    private OneWayAnova oneWayAnova = new OneWayAnovaImpl();    @Test    public void testOneWayAnovaUtils() throws Exception {        classes.add(classA);        classes.add(classB);        classes.add(classC);        Assert.assertEquals(oneWayAnova.anovaFValue(classes),                TestUtils.oneWayAnovaFValue(classes), 10E-12);        Assert.assertEquals(oneWayAnova.anovaPValue(classes),                TestUtils.oneWayAnovaPValue(classes), 10E-12);        Assert.assertEquals(oneWayAnova.anovaTest(classes, 0.01),                TestUtils.oneWayAnovaTest(classes, 0.01));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.junit.Assert;import org.junit.Test;/** * Test cases for the ChiSquareTestImpl class. * * @version $Id$ */public class WilcoxonSignedRankTestTest {    protected WilcoxonSignedRankTest testStatistic = new WilcoxonSignedRankTestImpl();    @Test    public void testWilcoxonSignedRankSimple() throws Exception {        /* Target values computed using R version 2.11.1         * x <- c(1.83, 0.50, 1.62, 2.48, 1.68, 1.88, 1.55, 3.06, 1.30)         * y <- c(0.878, 0.647, 0.598, 2.05, 1.06, 1.29, 1.06, 3.14, 1.29)         */        final double x[] = {1.83, 0.50, 1.62, 2.48, 1.68, 1.88, 1.55, 3.06, 1.30};        final double y[] = {0.878, 0.647, 0.598, 2.05, 1.06, 1.29, 1.06, 3.14, 1.29};                /* EXACT:         * wilcox.test(x, y, alternative = "two.sided", mu = 0, paired = TRUE, exact = TRUE, correct = FALSE)         * V = 40, p-value = 0.03906         *          * Corresponds to the value obtained in R.         */        Assert.assertEquals(40, testStatistic.wilcoxonSignedRank(x, y), 1e-10);        Assert.assertEquals(0.03906, testStatistic.wilcoxonSignedRankTest(x, y, true), 1e-5);                        /* ASYMPTOTIC:         * wilcox.test(x, y, alternative = "two.sided", mu = 0, paired = TRUE, exact = FALSE, correct = FALSE)         * V = 40, p-value = 0.03815         *          * This is not entirely the same due to different corrects,          * e.g. http://mlsc.lboro.ac.uk/resources/statistics/wsrt.pdf         * and src/library/stats/R/wilcox.test.R in the R source         */        Assert.assertEquals(40, testStatistic.wilcoxonSignedRank(x, y), 1e-10);        Assert.assertEquals(0.0329693812, testStatistic.wilcoxonSignedRankTest(x, y, false), 1e-10);    }        @Test    public void testWilcoxonSignedRankInputValidation() throws Exception {        /*         * Exact only for sample size <= 30         */        final double[] x1 = new double[30];        final double[] x2 = new double[31];        final double[] y1 = new double[30];        final double[] y2 = new double[31];        for (int i = 0; i < 30; ++i) {            x1[i] = x2[i] = y1[i] = y2[i] = i;                    }                // Exactly 30 is okay        //testStatistic.wilcoxonSignedRankTest(x1, y1, true);                            try {            testStatistic.wilcoxonSignedRankTest(x2, y2, true);            Assert.fail("More than 30 samples and exact chosen, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                /* Samples must be present, i.e. length > 0         */        try {            testStatistic.wilcoxonSignedRankTest(new double[] { }, new double[] { 1.0 }, true);            Assert.fail("x does not contain samples (exact), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.wilcoxonSignedRankTest(new double[] { }, new double[] { 1.0 }, false);            Assert.fail("x does not contain samples (asymptotic), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.wilcoxonSignedRankTest(new double[] { 1.0 }, new double[] { }, true);            Assert.fail("y does not contain samples (exact), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.wilcoxonSignedRankTest(new double[] { 1.0 }, new double[] { }, false);            Assert.fail("y does not contain samples (asymptotic), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        /* Samples not same size, i.e. cannot be pairred         */        try {            testStatistic.wilcoxonSignedRankTest(new double[] { 1.0, 2.0 }, new double[] { 3.0 }, true);            Assert.fail("x and y not same size (exact), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.wilcoxonSignedRankTest(new double[] { 1.0, 2.0 }, new double[] { 3.0 }, false);            Assert.fail("x and y not same size (asymptotic), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                /*         * x and y is null         */        try {            testStatistic.wilcoxonSignedRankTest(null, null, true);            Assert.fail("x and y is null (exact), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                try {            testStatistic.wilcoxonSignedRankTest(null, null, false);            Assert.fail("x and y is null (asymptotic), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                /*         * x or y is null         */        try {            testStatistic.wilcoxonSignedRankTest(null, new double[] { 1.0 }, true);            Assert.fail("x is null (exact), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                try {            testStatistic.wilcoxonSignedRankTest(null, new double[] { 1.0 }, false);            Assert.fail("x is null (asymptotic), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                try {            testStatistic.wilcoxonSignedRankTest(new double[] { 1.0 }, null, true);            Assert.fail("y is null (exact), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                try {            testStatistic.wilcoxonSignedRankTest(new double[] { 1.0 }, null, false);            Assert.fail("y is null (asymptotic), IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.clustering;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.List;import java.util.Random;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.junit.Assert;import org.junit.Test;public class KMeansPlusPlusClustererTest {    @Test    public void dimension2() {        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer =            new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(new Random(1746432956321l));        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {                // first expected cluster                new EuclideanIntegerPoint(new int[] { -15,  3 }),                new EuclideanIntegerPoint(new int[] { -15,  4 }),                new EuclideanIntegerPoint(new int[] { -15,  5 }),                new EuclideanIntegerPoint(new int[] { -14,  3 }),                new EuclideanIntegerPoint(new int[] { -14,  5 }),                new EuclideanIntegerPoint(new int[] { -13,  3 }),                new EuclideanIntegerPoint(new int[] { -13,  4 }),                new EuclideanIntegerPoint(new int[] { -13,  5 }),                // second expected cluster                new EuclideanIntegerPoint(new int[] { -1,  0 }),                new EuclideanIntegerPoint(new int[] { -1, -1 }),                new EuclideanIntegerPoint(new int[] {  0, -1 }),                new EuclideanIntegerPoint(new int[] {  1, -1 }),                new EuclideanIntegerPoint(new int[] {  1, -2 }),                // third expected cluster                new EuclideanIntegerPoint(new int[] { 13,  3 }),                new EuclideanIntegerPoint(new int[] { 13,  4 }),                new EuclideanIntegerPoint(new int[] { 14,  4 }),                new EuclideanIntegerPoint(new int[] { 14,  7 }),                new EuclideanIntegerPoint(new int[] { 16,  5 }),                new EuclideanIntegerPoint(new int[] { 16,  6 }),                new EuclideanIntegerPoint(new int[] { 17,  4 }),                new EuclideanIntegerPoint(new int[] { 17,  7 })        };        List<Cluster<EuclideanIntegerPoint>> clusters =            transformer.cluster(Arrays.asList(points), 3, 5, 10);        Assert.assertEquals(3, clusters.size());        boolean cluster1Found = false;        boolean cluster2Found = false;        boolean cluster3Found = false;        for (Cluster<EuclideanIntegerPoint> cluster : clusters) {            int[] center = cluster.getCenter().getPoint();            if (center[0] < 0) {                cluster1Found = true;                Assert.assertEquals(8, cluster.getPoints().size());                Assert.assertEquals(-14, center[0]);                Assert.assertEquals( 4, center[1]);            } else if (center[1] < 0) {                cluster2Found = true;                Assert.assertEquals(5, cluster.getPoints().size());                Assert.assertEquals( 0, center[0]);                Assert.assertEquals(-1, center[1]);            } else {                cluster3Found = true;                Assert.assertEquals(8, cluster.getPoints().size());                Assert.assertEquals(15, center[0]);                Assert.assertEquals(5, center[1]);            }        }        Assert.assertTrue(cluster1Found);        Assert.assertTrue(cluster2Found);        Assert.assertTrue(cluster3Found);    }    /**     * JIRA: MATH-305     *     * Two points, one cluster, one iteration     */    @Test    public void testPerformClusterAnalysisDegenerate() {        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(                new Random(1746432956321l));        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);        Assert.assertEquals(1, clusters.size());        Assert.assertEquals(2, (clusters.get(0).getPoints().size()));        EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });        EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });        Assert.assertTrue(clusters.get(0).getPoints().contains(pt1));        Assert.assertTrue(clusters.get(0).getPoints().contains(pt2));    }    @Test    public void testCertainSpace() {        KMeansPlusPlusClusterer.EmptyClusterStrategy[] strategies = {            KMeansPlusPlusClusterer.EmptyClusterStrategy.LARGEST_VARIANCE,            KMeansPlusPlusClusterer.EmptyClusterStrategy.LARGEST_POINTS_NUMBER,            KMeansPlusPlusClusterer.EmptyClusterStrategy.FARTHEST_POINT        };        for (KMeansPlusPlusClusterer.EmptyClusterStrategy strategy : strategies) {            KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer =                new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(new Random(1746432956321l), strategy);            int numberOfVariables = 27;            // initialise testvalues            int position1 = 1;            int position2 = position1 + numberOfVariables;            int position3 = position2 + numberOfVariables;            int position4 = position3 + numberOfVariables;            // testvalues will be multiplied            int multiplier = 1000000;            EuclideanIntegerPoint[] breakingPoints = new EuclideanIntegerPoint[numberOfVariables];            // define the space which will break the cluster algorithm            for (int i = 0; i < numberOfVariables; i++) {                int points[] = { position1, position2, position3, position4 };                // multiply the values                for (int j = 0; j < points.length; j++) {                    points[j] = points[j] * multiplier;                }                EuclideanIntegerPoint euclideanIntegerPoint = new EuclideanIntegerPoint(points);                breakingPoints[i] = euclideanIntegerPoint;                position1 = position1 + numberOfVariables;                position2 = position2 + numberOfVariables;                position3 = position3 + numberOfVariables;                position4 = position4 + numberOfVariables;            }            for (int n = 2; n < 27; ++n) {                List<Cluster<EuclideanIntegerPoint>> clusters =                    transformer.cluster(Arrays.asList(breakingPoints), n, 100);                Assert.assertEquals(n, clusters.size());                int sum = 0;                for (Cluster<EuclideanIntegerPoint> cluster : clusters) {                    sum += cluster.getPoints().size();                }                Assert.assertEquals(numberOfVariables, sum);            }        }    }    /**     * A helper class for testSmallDistances(). This class is similar to EuclideanIntegerPoint, but     * it defines a different distanceFrom() method that tends to return distances less than 1.     */    private class CloseIntegerPoint implements Clusterable<CloseIntegerPoint> {        public CloseIntegerPoint(EuclideanIntegerPoint point) {            euclideanPoint = point;        }        public double distanceFrom(CloseIntegerPoint p) {            return euclideanPoint.distanceFrom(p.euclideanPoint) * 0.001;        }        public CloseIntegerPoint centroidOf(Collection<CloseIntegerPoint> p) {            Collection<EuclideanIntegerPoint> euclideanPoints =                new ArrayList<EuclideanIntegerPoint>();            for (CloseIntegerPoint point : p) {                euclideanPoints.add(point.euclideanPoint);            }            return new CloseIntegerPoint(euclideanPoint.centroidOf(euclideanPoints));        }        @Override        public boolean equals(Object o) {            if (!(o instanceof CloseIntegerPoint)) {                return false;            }            CloseIntegerPoint p = (CloseIntegerPoint) o;            return euclideanPoint.equals(p.euclideanPoint);        }        @Override        public int hashCode() {            return euclideanPoint.hashCode();        }        private EuclideanIntegerPoint euclideanPoint;    }    /**     * Test points that are very close together. See issue MATH-546.     */    @Test    public void testSmallDistances() {        // Create a bunch of CloseIntegerPoints. Most are identical, but one is different by a        // small distance.        int[] repeatedArray = { 0 };        int[] uniqueArray = { 1 };        CloseIntegerPoint repeatedPoint =            new CloseIntegerPoint(new EuclideanIntegerPoint(repeatedArray));        CloseIntegerPoint uniquePoint =            new CloseIntegerPoint(new EuclideanIntegerPoint(uniqueArray));        Collection<CloseIntegerPoint> points = new ArrayList<CloseIntegerPoint>();        final int NUM_REPEATED_POINTS = 10 * 1000;        for (int i = 0; i < NUM_REPEATED_POINTS; ++i) {            points.add(repeatedPoint);        }        points.add(uniquePoint);        // Ask a KMeansPlusPlusClusterer to run zero iterations (i.e., to simply choose initial        // cluster centers).        final long RANDOM_SEED = 0;        final int NUM_CLUSTERS = 2;        final int NUM_ITERATIONS = 0;        KMeansPlusPlusClusterer<CloseIntegerPoint> clusterer =            new KMeansPlusPlusClusterer<CloseIntegerPoint>(new Random(RANDOM_SEED));        List<Cluster<CloseIntegerPoint>> clusters =            clusterer.cluster(points, NUM_CLUSTERS, NUM_ITERATIONS);        // Check that one of the chosen centers is the unique point.        boolean uniquePointIsCenter = false;        for (Cluster<CloseIntegerPoint> cluster : clusters) {            if (cluster.getCenter().equals(uniquePoint)) {                uniquePointIsCenter = true;            }        }        Assert.assertTrue(uniquePointIsCenter);    }        /**     * 2 variables cannot be clustered into 3 clusters. See issue MATH-436.     */    @Test(expected=NumberIsTooSmallException.class)    public void testPerformClusterAnalysisToManyClusters() {        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer =             new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(                    new Random(1746432956321l));                EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {            new EuclideanIntegerPoint(new int[] {                1959, 325100            }), new EuclideanIntegerPoint(new int[] {                1960, 373200            })        };                transformer.cluster(Arrays.asList(points), 3, 1);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.clustering;import java.util.ArrayList;import java.util.List;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class EuclideanIntegerPointTest {    @Test    public void testArrayIsReference() {        int[] array = { -3, -2, -1, 0, 1 };        Assert.assertTrue(array == new EuclideanIntegerPoint(array).getPoint());    }    @Test    public void testDistance() {        EuclideanIntegerPoint e1 = new EuclideanIntegerPoint(new int[] { -3, -2, -1, 0, 1 });        EuclideanIntegerPoint e2 = new EuclideanIntegerPoint(new int[] {  1,  0, -1, 1, 1 });        Assert.assertEquals(FastMath.sqrt(21.0), e1.distanceFrom(e2), 1.0e-15);        Assert.assertEquals(0.0, e1.distanceFrom(e1), 1.0e-15);        Assert.assertEquals(0.0, e2.distanceFrom(e2), 1.0e-15);    }    @Test    public void testCentroid() {        List<EuclideanIntegerPoint> list = new ArrayList<EuclideanIntegerPoint>();        list.add(new EuclideanIntegerPoint(new int[] {  1,  3 }));        list.add(new EuclideanIntegerPoint(new int[] {  2,  2 }));        list.add(new EuclideanIntegerPoint(new int[] {  3,  3 }));        list.add(new EuclideanIntegerPoint(new int[] {  2,  4 }));        EuclideanIntegerPoint c = list.get(0).centroidOf(list);        Assert.assertEquals(2, c.getPoint()[0]);        Assert.assertEquals(3, c.getPoint()[1]);    }    @Test    public void testSerial() {        EuclideanIntegerPoint p = new EuclideanIntegerPoint(new int[] { -3, -2, -1, 0, 1 });        Assert.assertEquals(p, TestUtils.serializeAndRecover(p));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.regression;import org.apache.commons.math.TestUtils;import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.Array2DRowRealMatrix;import org.apache.commons.math.linear.RealVector;import org.apache.commons.math.stat.StatUtils;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public class OLSMultipleLinearRegressionTest extends MultipleLinearRegressionAbstractTest {    private double[] y;    private double[][] x;    @Before    @Override    public void setUp(){        y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};        x = new double[6][];        x[0] = new double[]{0, 0, 0, 0, 0};        x[1] = new double[]{2.0, 0, 0, 0, 0};        x[2] = new double[]{0, 3.0, 0, 0, 0};        x[3] = new double[]{0, 0, 4.0, 0, 0};        x[4] = new double[]{0, 0, 0, 5.0, 0};        x[5] = new double[]{0, 0, 0, 0, 6.0};        super.setUp();    }    @Override    protected OLSMultipleLinearRegression createRegression() {        OLSMultipleLinearRegression regression = new OLSMultipleLinearRegression();        regression.newSampleData(y, x);        return regression;    }    @Override    protected int getNumberOfRegressors() {        return x[0].length + 1;    }    @Override    protected int getSampleSize() {        return y.length;    }        @Test(expected=IllegalArgumentException.class)    public void cannotAddSampleDataWithSizeMismatch() {        double[] y = new double[]{1.0, 2.0};        double[][] x = new double[1][];        x[0] = new double[]{1.0, 0};        createRegression().newSampleData(y, x);    }    @Test    public void testPerfectFit() throws Exception {        double[] betaHat = regression.estimateRegressionParameters();        TestUtils.assertEquals(betaHat,                               new double[]{ 11.0, 1.0 / 2.0, 2.0 / 3.0, 3.0 / 4.0, 4.0 / 5.0, 5.0 / 6.0 },                               1e-14);        double[] residuals = regression.estimateResiduals();        TestUtils.assertEquals(residuals, new double[]{0d,0d,0d,0d,0d,0d},                               1e-14);        RealMatrix errors =            new Array2DRowRealMatrix(regression.estimateRegressionParametersVariance(), false);        final double[] s = { 1.0, -1.0 /  2.0, -1.0 /  3.0, -1.0 /  4.0, -1.0 /  5.0, -1.0 /  6.0 };        RealMatrix referenceVariance = new Array2DRowRealMatrix(s.length, s.length);        referenceVariance.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {            @Override            public double visit(int row, int column, double value) {                if (row == 0) {                    return s[column];                }                double x = s[row] * s[column];                return (row == column) ? 2 * x : x;            }        });       Assert.assertEquals(0.0,                     errors.subtract(referenceVariance).getNorm(),                     5.0e-16 * referenceVariance.getNorm());       Assert.assertEquals(1, ((OLSMultipleLinearRegression) regression).calculateRSquared(), 1E-12);    }    /**     * Test Longley dataset against certified values provided by NIST.     * Data Source: J. Longley (1967) "An Appraisal of Least Squares     * Programs for the Electronic Computer from the Point of View of the User"     * Journal of the American Statistical Association, vol. 62. September,     * pp. 819-841.     *     * Certified values (and data) are from NIST:     * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat     */    @Test    public void testLongly() throws Exception {        // Y values are first, then independent vars        // Each row is one observation        double[] design = new double[] {            60323,83.0,234289,2356,1590,107608,1947,            61122,88.5,259426,2325,1456,108632,1948,            60171,88.2,258054,3682,1616,109773,1949,            61187,89.5,284599,3351,1650,110929,1950,            63221,96.2,328975,2099,3099,112075,1951,            63639,98.1,346999,1932,3594,113270,1952,            64989,99.0,365385,1870,3547,115094,1953,            63761,100.0,363112,3578,3350,116219,1954,            66019,101.2,397469,2904,3048,117388,1955,            67857,104.6,419180,2822,2857,118734,1956,            68169,108.4,442769,2936,2798,120445,1957,            66513,110.8,444546,4681,2637,121950,1958,            68655,112.6,482704,3813,2552,123366,1959,            69564,114.2,502601,3931,2514,125368,1960,            69331,115.7,518173,4806,2572,127852,1961,            70551,116.9,554894,4007,2827,130081,1962        };        final int nobs = 16;        final int nvars = 6;        // Estimate the model        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();        model.newSampleData(design, nobs, nvars);        // Check expected beta values from NIST        double[] betaHat = model.estimateRegressionParameters();        TestUtils.assertEquals(betaHat,          new double[]{-3482258.63459582, 15.0618722713733,                -0.358191792925910E-01,-2.02022980381683,                -1.03322686717359,-0.511041056535807E-01,                 1829.15146461355}, 2E-8); //        // Check expected residuals from R        double[] residuals = model.estimateResiduals();        TestUtils.assertEquals(residuals, new double[]{                267.340029759711,-94.0139423988359,46.28716775752924,                -410.114621930906,309.7145907602313,-249.3112153297231,                -164.0489563956039,-13.18035686637081,14.30477260005235,                 455.394094551857,-17.26892711483297,-39.0550425226967,                -155.5499735953195,-85.6713080421283,341.9315139607727,                -206.7578251937366},                      1E-8);        // Check standard errors from NIST        double[] errors = model.estimateRegressionParametersStandardErrors();        TestUtils.assertEquals(new double[] {890420.383607373,                       84.9149257747669,                       0.334910077722432E-01,                       0.488399681651699,                       0.214274163161675,                       0.226073200069370,                       455.478499142212}, errors, 1E-6);                // Check regression standard error against R        Assert.assertEquals(304.8540735619638, model.estimateRegressionStandardError(), 1E-10);                // Check R-Square statistics against R        Assert.assertEquals(0.995479004577296, model.calculateRSquared(), 1E-12);        Assert.assertEquals(0.992465007628826, model.calculateAdjustedRSquared(), 1E-12);                checkVarianceConsistency(model);                // Estimate model without intercept        model.setNoIntercept(true);        model.newSampleData(design, nobs, nvars);                // Check expected beta values from R        betaHat = model.estimateRegressionParameters();        TestUtils.assertEquals(betaHat,          new double[]{-52.99357013868291, 0.07107319907358,                -0.42346585566399,-0.57256866841929,                -0.41420358884978, 48.41786562001326}, 1E-11);                 // Check standard errors from R        errors = model.estimateRegressionParametersStandardErrors();        TestUtils.assertEquals(new double[] {129.54486693117232, 0.03016640003786,                0.41773654056612, 0.27899087467676, 0.32128496193363,                17.68948737819961}, errors, 1E-11);                // Check expected residuals from R        residuals = model.estimateResiduals();        TestUtils.assertEquals(residuals, new double[]{                279.90274927293092, -130.32465380836874, 90.73228661967445, -401.31252201634948,                -440.46768772620027, -543.54512853774793, 201.32111639536299, 215.90889365977932,                73.09368242049943, 913.21694494481869, 424.82484953610174, -8.56475876776709,                -361.32974610842876, 27.34560497213464, 151.28955976355002, -492.49937355336846},                      1E-10);                // Check regression standard error against R        Assert.assertEquals(475.1655079819517, model.estimateRegressionStandardError(), 1E-10);                // Check R-Square statistics against R        Assert.assertEquals(0.9999670130706, model.calculateRSquared(), 1E-12);        Assert.assertEquals(0.999947220913, model.calculateAdjustedRSquared(), 1E-12);             }    /**     * Test R Swiss fertility dataset against R.     * Data Source: R datasets package     */    @Test    public void testSwissFertility() throws Exception {        double[] design = new double[] {            80.2,17.0,15,12,9.96,            83.1,45.1,6,9,84.84,            92.5,39.7,5,5,93.40,            85.8,36.5,12,7,33.77,            76.9,43.5,17,15,5.16,            76.1,35.3,9,7,90.57,            83.8,70.2,16,7,92.85,            92.4,67.8,14,8,97.16,            82.4,53.3,12,7,97.67,            82.9,45.2,16,13,91.38,            87.1,64.5,14,6,98.61,            64.1,62.0,21,12,8.52,            66.9,67.5,14,7,2.27,            68.9,60.7,19,12,4.43,            61.7,69.3,22,5,2.82,            68.3,72.6,18,2,24.20,            71.7,34.0,17,8,3.30,            55.7,19.4,26,28,12.11,            54.3,15.2,31,20,2.15,            65.1,73.0,19,9,2.84,            65.5,59.8,22,10,5.23,            65.0,55.1,14,3,4.52,            56.6,50.9,22,12,15.14,            57.4,54.1,20,6,4.20,            72.5,71.2,12,1,2.40,            74.2,58.1,14,8,5.23,            72.0,63.5,6,3,2.56,            60.5,60.8,16,10,7.72,            58.3,26.8,25,19,18.46,            65.4,49.5,15,8,6.10,            75.5,85.9,3,2,99.71,            69.3,84.9,7,6,99.68,            77.3,89.7,5,2,100.00,            70.5,78.2,12,6,98.96,            79.4,64.9,7,3,98.22,            65.0,75.9,9,9,99.06,            92.2,84.6,3,3,99.46,            79.3,63.1,13,13,96.83,            70.4,38.4,26,12,5.62,            65.7,7.7,29,11,13.79,            72.7,16.7,22,13,11.22,            64.4,17.6,35,32,16.92,            77.6,37.6,15,7,4.97,            67.6,18.7,25,7,8.65,            35.0,1.2,37,53,42.34,            44.7,46.6,16,29,50.43,            42.8,27.7,22,29,58.33        };                final int nobs = 47;        final int nvars = 4;        // Estimate the model        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();        model.newSampleData(design, nobs, nvars);        // Check expected beta values from R        double[] betaHat = model.estimateRegressionParameters();        TestUtils.assertEquals(betaHat,                new double[]{91.05542390271397,                -0.22064551045715,                -0.26058239824328,                -0.96161238456030,                 0.12441843147162}, 1E-12);        // Check expected residuals from R        double[] residuals = model.estimateResiduals();        TestUtils.assertEquals(residuals, new double[]{                7.1044267859730512,1.6580347433531366,                4.6944952770029644,8.4548022690166160,13.6547432343186212,               -9.3586864458500774,7.5822446330520386,15.5568995563859289,                0.8113090736598980,7.1186762732484308,7.4251378771228724,                2.6761316873234109,0.8351584810309354,7.1769991119615177,               -3.8746753206299553,-3.1337779476387251,-0.1412575244091504,                1.1186809170469780,-6.3588097346816594,3.4039270429434074,                2.3374058329820175,-7.9272368576900503,-7.8361010968497959,               -11.2597369269357070,0.9445333697827101,6.6544245101380328,               -0.9146136301118665,-4.3152449403848570,-4.3536932047009183,               -3.8907885169304661,-6.3027643926302188,-7.8308982189289091,               -3.1792280015332750,-6.7167298771158226,-4.8469946718041754,               -10.6335664353633685,11.1031134362036958,6.0084032641811733,                5.4326230830188482,-7.2375578629692230,2.1671550814448222,                15.0147574652763112,4.8625103516321015,-7.1597256413907706,                -0.4515205619767598,-10.2916870903837587,-15.7812984571900063},                1E-12);        // Check standard errors from R        double[] errors = model.estimateRegressionParametersStandardErrors();        TestUtils.assertEquals(new double[] {6.94881329475087,                0.07360008972340,                0.27410957467466,                0.19454551679325,                0.03726654773803}, errors, 1E-10);                // Check regression standard error against R        Assert.assertEquals(7.73642194433223, model.estimateRegressionStandardError(), 1E-12);                // Check R-Square statistics against R        Assert.assertEquals(0.649789742860228, model.calculateRSquared(), 1E-12);        Assert.assertEquals(0.6164363850373927, model.calculateAdjustedRSquared(), 1E-12);                checkVarianceConsistency(model);                // Estimate the model with no intercept        model = new OLSMultipleLinearRegression();        model.setNoIntercept(true);        model.newSampleData(design, nobs, nvars);        // Check expected beta values from R        betaHat = model.estimateRegressionParameters();        TestUtils.assertEquals(betaHat,                new double[]{0.52191832900513,                  2.36588087917963,                  -0.94770353802795,                   0.30851985863609}, 1E-12);        // Check expected residuals from R        residuals = model.estimateResiduals();        TestUtils.assertEquals(residuals, new double[]{                44.138759883538249, 27.720705122356215, 35.873200836126799,                 34.574619581211977, 26.600168342080213, 15.074636243026923, -12.704904871199814,                1.497443824078134, 2.691972687079431, 5.582798774291231, -4.422986561283165,                 -9.198581600334345, 4.481765170730647, 2.273520207553216, -22.649827853221336,                -17.747900013943308, 20.298314638496436, 6.861405135329779, -8.684712790954924,                -10.298639278062371, -9.896618896845819, 4.568568616351242, -15.313570491727944,                -13.762961360873966, 7.156100301980509, 16.722282219843990, 26.716200609071898,                -1.991466398777079, -2.523342564719335, 9.776486693095093, -5.297535127628603,                -16.639070567471094, -10.302057295211819, -23.549487860816846, 1.506624392156384,                -17.939174438345930, 13.105792202765040, -1.943329906928462, -1.516005841666695,                -0.759066561832886, 20.793137744128977, -2.485236153005426, 27.588238710486976,                2.658333257106881, -15.998337823623046, -5.550742066720694, -14.219077806826615},                1E-12);        // Check standard errors from R        errors = model.estimateRegressionParametersStandardErrors();        TestUtils.assertEquals(new double[] {0.10470063765677, 0.41684100584290,                0.43370143099691, 0.07694953606522}, errors, 1E-10);                // Check regression standard error against R        Assert.assertEquals(17.24710630547, model.estimateRegressionStandardError(), 1E-10);                // Check R-Square statistics against R        Assert.assertEquals(0.946350722085, model.calculateRSquared(), 1E-12);        Assert.assertEquals(0.9413600915813, model.calculateAdjustedRSquared(), 1E-12);    }    /**     * Test hat matrix computation     *     * @throws Exception     */    @Test    public void testHat() throws Exception {        /*         * This example is from "The Hat Matrix in Regression and ANOVA",         * David C. Hoaglin and Roy E. Welsch,         * The American Statistician, Vol. 32, No. 1 (Feb., 1978), pp. 17-22.         *         */        double[] design = new double[] {                11.14, .499, 11.1,                12.74, .558, 8.9,                13.13, .604, 8.8,                11.51, .441, 8.9,                12.38, .550, 8.8,                12.60, .528, 9.9,                11.13, .418, 10.7,                11.7, .480, 10.5,                11.02, .406, 10.5,                11.41, .467, 10.7        };        int nobs = 10;        int nvars = 2;        // Estimate the model        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();        model.newSampleData(design, nobs, nvars);        RealMatrix hat = model.calculateHat();        // Reference data is upper half of symmetric hat matrix        double[] referenceData = new double[] {                .418, -.002,  .079, -.274, -.046,  .181,  .128,  .222,  .050,  .242,                       .242,  .292,  .136,  .243,  .128, -.041,  .033, -.035,  .004,                              .417, -.019,  .273,  .187, -.126,  .044, -.153,  .004,                                     .604,  .197, -.038,  .168, -.022,  .275, -.028,                                            .252,  .111, -.030,  .019, -.010, -.010,                                                   .148,  .042,  .117,  .012,  .111,                                                          .262,  .145,  .277,  .174,                                                                 .154,  .120,  .168,                                                                        .315,  .148,                                                                               .187        };        // Check against reference data and verify symmetry        int k = 0;        for (int i = 0; i < 10; i++) {            for (int j = i; j < 10; j++) {                Assert.assertEquals(referenceData[k], hat.getEntry(i, j), 10e-3);                Assert.assertEquals(hat.getEntry(i, j), hat.getEntry(j, i), 10e-12);                k++;            }        }        /*         * Verify that residuals computed using the hat matrix are close to         * what we get from direct computation, i.e. r = (I - H) y         */        double[] residuals = model.estimateResiduals();        RealMatrix I = MatrixUtils.createRealIdentityMatrix(10);        double[] hatResiduals = I.subtract(hat).operate(model.Y).getData();        TestUtils.assertEquals(residuals, hatResiduals, 10e-12);    }    /**     * test calculateYVariance     */    @Test    public void testYVariance() {        // assumes: y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();        model.newSampleData(y, x);        TestUtils.assertEquals(model.calculateYVariance(), 3.5, 0);    }        /**     * Verifies that calculateYVariance and calculateResidualVariance return consistent     * values with direct variance computation from Y, residuals, respectively.     */    protected void checkVarianceConsistency(OLSMultipleLinearRegression model) throws Exception {        // Check Y variance consistency        TestUtils.assertEquals(StatUtils.variance(model.Y.getData()), model.calculateYVariance(), 0);                // Check residual variance consistency        double[] residuals = model.calculateResiduals().getData();        RealMatrix X = model.X;        TestUtils.assertEquals(                StatUtils.variance(model.calculateResiduals().getData()) * (residuals.length - 1),                model.calculateErrorVariance() * (X.getRowDimension() - X.getColumnDimension()), 1E-20);            }        /**     * Verifies that setting X and Y separately has the same effect as newSample(X,Y).     */    @Test    public void testNewSample2() throws Exception {        double[] y = new double[] {1, 2, 3, 4};         double[][] x = new double[][] {          {19, 22, 33},          {20, 30, 40},          {25, 35, 45},          {27, 37, 47}           };        OLSMultipleLinearRegression regression = new OLSMultipleLinearRegression();        regression.newSampleData(y, x);        RealMatrix combinedX = regression.X.copy();        RealVector combinedY = regression.Y.copy();        regression.newXSampleData(x);        regression.newYSampleData(y);        Assert.assertEquals(combinedX, regression.X);        Assert.assertEquals(combinedY, regression.Y);                // No intercept        regression.setNoIntercept(true);        regression.newSampleData(y, x);        combinedX = regression.X.copy();        combinedY = regression.Y.copy();        regression.newXSampleData(x);        regression.newYSampleData(y);        Assert.assertEquals(combinedX, regression.X);        Assert.assertEquals(combinedY, regression.Y);    }        @Test(expected=IllegalArgumentException.class)    public void testNewSampleDataYNull() {        createRegression().newSampleData(null, new double[][] {});    }        @Test(expected=IllegalArgumentException.class)    public void testNewSampleDataXNull() {        createRegression().newSampleData(new double[] {}, null);    }         /*     * This is a test based on the Wampler1 data set     * http://www.itl.nist.gov/div898/strd/lls/data/Wampler1.shtml     */    @Test    public void testWampler1() throws Exception {        double[] data = new double[]{            1, 0,            6, 1,            63, 2,            364, 3,            1365, 4,            3906, 5,            9331, 6,            19608, 7,            37449, 8,            66430, 9,            111111, 10,            177156, 11,            271453, 12,            402234, 13,            579195, 14,            813616, 15,            1118481, 16,            1508598, 17,            2000719, 18,            2613660, 19,            3368421, 20};        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();        final int nvars = 5;        final int nobs = 21;        double[] tmp = new double[(nvars + 1) * nobs];        int off = 0;        int off2 = 0;        for (int i = 0; i < nobs; i++) {            tmp[off2] = data[off];            tmp[off2 + 1] = data[off + 1];            tmp[off2 + 2] = tmp[off2 + 1] * tmp[off2 + 1];            tmp[off2 + 3] = tmp[off2 + 1] * tmp[off2 + 2];            tmp[off2 + 4] = tmp[off2 + 1] * tmp[off2 + 3];            tmp[off2 + 5] = tmp[off2 + 1] * tmp[off2 + 4];            off2 += (nvars + 1);            off += 2;        }        model.newSampleData(tmp, nobs, nvars);        double[] betaHat = model.estimateRegressionParameters();        TestUtils.assertEquals(betaHat,                new double[]{1.0,                    1.0, 1.0,                    1.0, 1.0,                    1.0}, 1E-8);        double[] se = model.estimateRegressionParametersStandardErrors();        TestUtils.assertEquals(se,                new double[]{0.0,                    0.0, 0.0,                    0.0, 0.0,                    0.0}, 1E-8);         TestUtils.assertEquals(1.0, model.calculateRSquared(), 1.0e-10);        TestUtils.assertEquals(0, model.estimateErrorVariance(), 1.0e-7);        TestUtils.assertEquals(0.00, model.calculateResidualSumOfSquares(), 1.0e-6);        return;    }        /*     * This is a test based on the Wampler2 data set     * http://www.itl.nist.gov/div898/strd/lls/data/Wampler2.shtml     */    @Test    public void testWampler2() throws Exception {        double[] data = new double[]{            1.00000, 0,            1.11111, 1,            1.24992, 2,            1.42753, 3,            1.65984, 4,            1.96875, 5,            2.38336, 6,            2.94117, 7,            3.68928, 8,            4.68559, 9,            6.00000, 10,            7.71561, 11,            9.92992, 12,            12.75603, 13,            16.32384, 14,            20.78125, 15,            26.29536, 16,            33.05367, 17,            41.26528, 18,            51.16209, 19,            63.00000, 20};        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();        final int nvars = 5;        final int nobs = 21;        double[] tmp = new double[(nvars + 1) * nobs];        int off = 0;        int off2 = 0;        for (int i = 0; i < nobs; i++) {            tmp[off2] = data[off];            tmp[off2 + 1] = data[off + 1];            tmp[off2 + 2] = tmp[off2 + 1] * tmp[off2 + 1];            tmp[off2 + 3] = tmp[off2 + 1] * tmp[off2 + 2];            tmp[off2 + 4] = tmp[off2 + 1] * tmp[off2 + 3];            tmp[off2 + 5] = tmp[off2 + 1] * tmp[off2 + 4];            off2 += (nvars + 1);            off += 2;        }        model.newSampleData(tmp, nobs, nvars);        double[] betaHat = model.estimateRegressionParameters();        TestUtils.assertEquals(betaHat,                new double[]{                    1.0,                    1.0e-1,                    1.0e-2,                    1.0e-3, 1.0e-4,                    1.0e-5}, 1E-8);        double[] se = model.estimateRegressionParametersStandardErrors();        TestUtils.assertEquals(se,                new double[]{0.0,                    0.0, 0.0,                    0.0, 0.0,                    0.0}, 1E-8);         TestUtils.assertEquals(1.0, model.calculateRSquared(), 1.0e-10);        TestUtils.assertEquals(0, model.estimateErrorVariance(), 1.0e-7);        TestUtils.assertEquals(0.00, model.calculateResidualSumOfSquares(), 1.0e-6);        return;    }        /*     * This is a test based on the Wampler3 data set     * http://www.itl.nist.gov/div898/strd/lls/data/Wampler3.shtml     */    @Test    public void testWampler3() throws Exception {        double[] data = new double[]{            760, 0,            -2042, 1,            2111, 2,            -1684, 3,            3888, 4,            1858, 5,            11379, 6,            17560, 7,            39287, 8,            64382, 9,            113159, 10,            175108, 11,            273291, 12,            400186, 13,            581243, 14,            811568, 15,            1121004, 16,            1506550, 17,            2002767, 18,            2611612, 19,            3369180, 20};        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();        final int nvars = 5;        final int nobs = 21;        double[] tmp = new double[(nvars + 1) * nobs];        int off = 0;        int off2 = 0;        for (int i = 0; i < nobs; i++) {            tmp[off2] = data[off];            tmp[off2 + 1] = data[off + 1];            tmp[off2 + 2] = tmp[off2 + 1] * tmp[off2 + 1];            tmp[off2 + 3] = tmp[off2 + 1] * tmp[off2 + 2];            tmp[off2 + 4] = tmp[off2 + 1] * tmp[off2 + 3];            tmp[off2 + 5] = tmp[off2 + 1] * tmp[off2 + 4];            off2 += (nvars + 1);            off += 2;        }        model.newSampleData(tmp, nobs, nvars);        double[] betaHat = model.estimateRegressionParameters();        TestUtils.assertEquals(betaHat,                new double[]{                    1.0,                    1.0,                    1.0,                    1.0,                    1.0,                    1.0}, 1E-8);         double[] se = model.estimateRegressionParametersStandardErrors();        TestUtils.assertEquals(se,                new double[]{2152.32624678170,                    2363.55173469681, 779.343524331583,                    101.475507550350, 5.64566512170752,                    0.112324854679312}, 1E-8); //        TestUtils.assertEquals(.999995559025820, model.calculateRSquared(), 1.0e-10);        TestUtils.assertEquals(5570284.53333333, model.estimateErrorVariance(), 1.0e-6);        TestUtils.assertEquals(83554268.0000000, model.calculateResidualSumOfSquares(), 1.0e-5);        return;    }    /*     * This is a test based on the Wampler4 data set     * http://www.itl.nist.gov/div898/strd/lls/data/Wampler4.shtml     */    @Test    public void testWampler4() throws Exception {        double[] data = new double[]{            75901, 0,            -204794, 1,            204863, 2,            -204436, 3,            253665, 4,            -200894, 5,            214131, 6,            -185192, 7,            221249, 8,            -138370, 9,            315911, 10,            -27644, 11,            455253, 12,            197434, 13,            783995, 14,            608816, 15,            1370781, 16,            1303798, 17,            2205519, 18,            2408860, 19,            3444321, 20};        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();        final int nvars = 5;        final int nobs = 21;        double[] tmp = new double[(nvars + 1) * nobs];        int off = 0;        int off2 = 0;        for (int i = 0; i < nobs; i++) {            tmp[off2] = data[off];            tmp[off2 + 1] = data[off + 1];            tmp[off2 + 2] = tmp[off2 + 1] * tmp[off2 + 1];            tmp[off2 + 3] = tmp[off2 + 1] * tmp[off2 + 2];            tmp[off2 + 4] = tmp[off2 + 1] * tmp[off2 + 3];            tmp[off2 + 5] = tmp[off2 + 1] * tmp[off2 + 4];            off2 += (nvars + 1);            off += 2;        }        model.newSampleData(tmp, nobs, nvars);        double[] betaHat = model.estimateRegressionParameters();        TestUtils.assertEquals(betaHat,                new double[]{                    1.0,                    1.0,                    1.0,                    1.0,                    1.0,                    1.0}, 1E-6);         double[] se = model.estimateRegressionParametersStandardErrors();        TestUtils.assertEquals(se,                new double[]{215232.624678170,                    236355.173469681, 77934.3524331583,                    10147.5507550350, 564.566512170752,                    11.2324854679312}, 1E-8);         TestUtils.assertEquals(.957478440825662, model.calculateRSquared(), 1.0e-10);        TestUtils.assertEquals(55702845333.3333, model.estimateErrorVariance(), 1.0e-4);        TestUtils.assertEquals(835542680000.000, model.calculateResidualSumOfSquares(), 1.0e-3);        return;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.regression;import java.util.Random;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.junit.Assert;import org.junit.Test;/** * Test cases for the TestStatistic class. * * @version $Id$ */public final class SimpleRegressionTest {    /*     * NIST "Norris" refernce data set from     * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat     * Strangely, order is {y,x}     */    private double[][] data = { { 0.1, 0.2 }, {338.8, 337.4 }, {118.1, 118.2 },            {888.0, 884.6 }, {9.2, 10.1 }, {228.1, 226.5 }, {668.5, 666.3 }, {998.5, 996.3 },            {449.1, 448.6 }, {778.9, 777.0 }, {559.2, 558.2 }, {0.3, 0.4 }, {0.1, 0.6 }, {778.1, 775.5 },            {668.8, 666.9 }, {339.3, 338.0 }, {448.9, 447.5 }, {10.8, 11.6 }, {557.7, 556.0 },            {228.3, 228.1 }, {998.0, 995.8 }, {888.8, 887.6 }, {119.6, 120.2 }, {0.3, 0.3 },            {0.6, 0.3 }, {557.6, 556.8 }, {339.3, 339.1 }, {888.0, 887.2 }, {998.5, 999.0 },            {778.9, 779.0 }, {10.2, 11.1 }, {117.6, 118.3 }, {228.9, 229.2 }, {668.4, 669.1 },            {449.2, 448.9 }, {0.2, 0.5 }    };    /*     * Correlation example from     * http://www.xycoon.com/correlation.htm     */    private double[][] corrData = { { 101.0, 99.2 }, {100.1, 99.0 }, {100.0, 100.0 },            {90.6, 111.6 }, {86.5, 122.2 }, {89.7, 117.6 }, {90.6, 121.1 }, {82.8, 136.0 },            {70.1, 154.2 }, {65.4, 153.6 }, {61.3, 158.5 }, {62.5, 140.6 }, {63.6, 136.2 },            {52.6, 168.0 }, {59.7, 154.3 }, {59.5, 149.0 }, {61.3, 165.5 }    };    /*     * From Moore and Mcabe, "Introduction to the Practice of Statistics"     * Example 10.3     */    private double[][] infData = { { 15.6, 5.2 }, {26.8, 6.1 }, {37.8, 8.7 }, {36.4, 8.5 },            {35.5, 8.8 }, {18.6, 4.9 }, {15.3, 4.5 }, {7.9, 2.5 }, {0.0, 1.1 }    };    /*     * Points to remove in the remove tests     */    private double[][] removeSingle = {infData[1]};    private double[][] removeMultiple = { infData[1], infData[2] };    private double removeX = infData[0][0];    private double removeY = infData[0][1];    /*     * Data with bad linear fit     */    private double[][] infData2 = { { 1, 1 }, {2, 0 }, {3, 5 }, {4, 2 },            {5, -1 }, {6, 12 }    };    @Test    public void testNorris() {        SimpleRegression regression = new SimpleRegression();        for (int i = 0; i < data.length; i++) {            regression.addData(data[i][1], data[i][0]);        }        // Tests against certified values from        // http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat        Assert.assertEquals("slope", 1.00211681802045, regression.getSlope(), 10E-12);        Assert.assertEquals("slope std err", 0.429796848199937E-03,                regression.getSlopeStdErr(),10E-12);        Assert.assertEquals("number of observations", 36, regression.getN());        Assert.assertEquals( "intercept", -0.262323073774029,            regression.getIntercept(),10E-12);        Assert.assertEquals("std err intercept", 0.232818234301152,            regression.getInterceptStdErr(),10E-12);        Assert.assertEquals("r-square", 0.999993745883712,            regression.getRSquare(), 10E-12);        Assert.assertEquals("SSR", 4255954.13232369,            regression.getRegressionSumSquares(), 10E-9);        Assert.assertEquals("MSE", 0.782864662630069,            regression.getMeanSquareError(), 10E-10);        Assert.assertEquals("SSE", 26.6173985294224,            regression.getSumSquaredErrors(),10E-9);        // ------------  End certified data tests        Assert.assertEquals( "predict(0)",  -0.262323073774029,            regression.predict(0), 10E-12);        Assert.assertEquals("predict(1)", 1.00211681802045 - 0.262323073774029,            regression.predict(1), 10E-12);    }    @Test    public void testCorr() {        SimpleRegression regression = new SimpleRegression();        regression.addData(corrData);        Assert.assertEquals("number of observations", 17, regression.getN());        Assert.assertEquals("r-square", .896123, regression.getRSquare(), 10E-6);        Assert.assertEquals("r", -0.94663767742, regression.getR(), 1E-10);    }    @Test    public void testNaNs() {        SimpleRegression regression = new SimpleRegression();        Assert.assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept()));        Assert.assertTrue("slope not NaN", Double.isNaN(regression.getSlope()));        Assert.assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));        Assert.assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));        Assert.assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));        Assert.assertTrue("e not NaN", Double.isNaN(regression.getR()));        Assert.assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare()));        Assert.assertTrue( "RSS not NaN", Double.isNaN(regression.getRegressionSumSquares()));        Assert.assertTrue("SSE not NaN",Double.isNaN(regression.getSumSquaredErrors()));        Assert.assertTrue("SSTO not NaN", Double.isNaN(regression.getTotalSumSquares()));        Assert.assertTrue("predict not NaN", Double.isNaN(regression.predict(0)));        regression.addData(1, 2);        regression.addData(1, 3);        // No x variation, so these should still blow...        Assert.assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept()));        Assert.assertTrue("slope not NaN", Double.isNaN(regression.getSlope()));        Assert.assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));        Assert.assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));        Assert.assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));        Assert.assertTrue("e not NaN", Double.isNaN(regression.getR()));        Assert.assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare()));        Assert.assertTrue("RSS not NaN", Double.isNaN(regression.getRegressionSumSquares()));        Assert.assertTrue("SSE not NaN", Double.isNaN(regression.getSumSquaredErrors()));        Assert.assertTrue("predict not NaN", Double.isNaN(regression.predict(0)));        // but SSTO should be OK        Assert.assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares()));        regression = new SimpleRegression();        regression.addData(1, 2);        regression.addData(3, 3);        // All should be OK except MSE, s(b0), s(b1) which need one more df        Assert.assertTrue("interceptNaN", !Double.isNaN(regression.getIntercept()));        Assert.assertTrue("slope NaN", !Double.isNaN(regression.getSlope()));        Assert.assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));        Assert.assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));        Assert.assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));        Assert.assertTrue("r NaN", !Double.isNaN(regression.getR()));        Assert.assertTrue("r-square NaN", !Double.isNaN(regression.getRSquare()));        Assert.assertTrue("RSS NaN", !Double.isNaN(regression.getRegressionSumSquares()));        Assert.assertTrue("SSE NaN", !Double.isNaN(regression.getSumSquaredErrors()));        Assert.assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares()));        Assert.assertTrue("predict NaN", !Double.isNaN(regression.predict(0)));        regression.addData(1, 4);        // MSE, MSE, s(b0), s(b1) should all be OK now        Assert.assertTrue("MSE NaN", !Double.isNaN(regression.getMeanSquareError()));        Assert.assertTrue("slope std err NaN", !Double.isNaN(regression.getSlopeStdErr()));        Assert.assertTrue("intercept std err NaN", !Double.isNaN(regression.getInterceptStdErr()));    }    @Test    public void testClear() {        SimpleRegression regression = new SimpleRegression();        regression.addData(corrData);        Assert.assertEquals("number of observations", 17, regression.getN());        regression.clear();        Assert.assertEquals("number of observations", 0, regression.getN());        regression.addData(corrData);        Assert.assertEquals("r-square", .896123, regression.getRSquare(), 10E-6);        regression.addData(data);        Assert.assertEquals("number of observations", 53, regression.getN());    }    @Test    public void testInference() throws Exception {        //----------  verified against R, version 1.8.1 -----        // infData        SimpleRegression regression = new SimpleRegression();        regression.addData(infData);        Assert.assertEquals("slope std err", 0.011448491,                regression.getSlopeStdErr(), 1E-10);        Assert.assertEquals("std err intercept", 0.286036932,                regression.getInterceptStdErr(),1E-8);        Assert.assertEquals("significance", 4.596e-07,                regression.getSignificance(),1E-8);        Assert.assertEquals("slope conf interval half-width", 0.0270713794287,                regression.getSlopeConfidenceInterval(),1E-8);        // infData2        regression = new SimpleRegression();        regression.addData(infData2);        Assert.assertEquals("slope std err", 1.07260253,                regression.getSlopeStdErr(), 1E-8);        Assert.assertEquals("std err intercept",4.17718672,                regression.getInterceptStdErr(),1E-8);        Assert.assertEquals("significance", 0.261829133982,                regression.getSignificance(),1E-11);        Assert.assertEquals("slope conf interval half-width", 2.97802204827,                regression.getSlopeConfidenceInterval(),1E-8);        //------------- End R-verified tests -------------------------------        //FIXME: get a real example to test against with alpha = .01        Assert.assertTrue("tighter means wider",                regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01));        try {            regression.getSlopeConfidenceInterval(1);            Assert.fail("expecting MathIllegalArgumentException for alpha = 1");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    @Test    public void testPerfect() throws Exception {        SimpleRegression regression = new SimpleRegression();        int n = 100;        for (int i = 0; i < n; i++) {            regression.addData(((double) i) / (n - 1), i);        }        Assert.assertEquals(0.0, regression.getSignificance(), 1.0e-5);        Assert.assertTrue(regression.getSlope() > 0.0);        Assert.assertTrue(regression.getSumSquaredErrors() >= 0.0);    }    @Test    public void testPerfectNegative() throws Exception {        SimpleRegression regression = new SimpleRegression();        int n = 100;        for (int i = 0; i < n; i++) {            regression.addData(- ((double) i) / (n - 1), i);        }        Assert.assertEquals(0.0, regression.getSignificance(), 1.0e-5);        Assert.assertTrue(regression.getSlope() < 0.0);    }    @Test    public void testRandom() throws Exception {        SimpleRegression regression = new SimpleRegression();        Random random = new Random(1);        int n = 100;        for (int i = 0; i < n; i++) {            regression.addData(((double) i) / (n - 1), random.nextDouble());        }        Assert.assertTrue( 0.0 < regression.getSignificance()                    && regression.getSignificance() < 1.0);    }    // Jira MATH-85 = Bugzilla 39432    @Test    public void testSSENonNegative() {        double[] y = { 8915.102, 8919.302, 8923.502 };        double[] x = { 1.107178495E2, 1.107264895E2, 1.107351295E2 };        SimpleRegression reg = new SimpleRegression();        for (int i = 0; i < x.length; i++) {            reg.addData(x[i], y[i]);        }        Assert.assertTrue(reg.getSumSquaredErrors() >= 0.0);    }    // Test remove X,Y (single observation)    @Test    public void testRemoveXY() throws Exception {        // Create regression with inference data then remove to test        SimpleRegression regression = new SimpleRegression();        regression.addData(infData);        regression.removeData(removeX, removeY);        regression.addData(removeX, removeY);        // Use the inference assertions to make sure that everything worked        Assert.assertEquals("slope std err", 0.011448491,                regression.getSlopeStdErr(), 1E-10);        Assert.assertEquals("std err intercept", 0.286036932,                regression.getInterceptStdErr(),1E-8);        Assert.assertEquals("significance", 4.596e-07,                regression.getSignificance(),1E-8);        Assert.assertEquals("slope conf interval half-width", 0.0270713794287,                regression.getSlopeConfidenceInterval(),1E-8);     }    // Test remove single observation in array    @Test    public void testRemoveSingle() throws Exception {        // Create regression with inference data then remove to test        SimpleRegression regression = new SimpleRegression();        regression.addData(infData);        regression.removeData(removeSingle);        regression.addData(removeSingle);        // Use the inference assertions to make sure that everything worked        Assert.assertEquals("slope std err", 0.011448491,                regression.getSlopeStdErr(), 1E-10);        Assert.assertEquals("std err intercept", 0.286036932,                regression.getInterceptStdErr(),1E-8);        Assert.assertEquals("significance", 4.596e-07,                regression.getSignificance(),1E-8);        Assert.assertEquals("slope conf interval half-width", 0.0270713794287,                regression.getSlopeConfidenceInterval(),1E-8);     }    // Test remove multiple observations    @Test    public void testRemoveMultiple() throws Exception {        // Create regression with inference data then remove to test        SimpleRegression regression = new SimpleRegression();        regression.addData(infData);        regression.removeData(removeMultiple);        regression.addData(removeMultiple);        // Use the inference assertions to make sure that everything worked        Assert.assertEquals("slope std err", 0.011448491,                regression.getSlopeStdErr(), 1E-10);        Assert.assertEquals("std err intercept", 0.286036932,                regression.getInterceptStdErr(),1E-8);        Assert.assertEquals("significance", 4.596e-07,                regression.getSignificance(),1E-8);        Assert.assertEquals("slope conf interval half-width", 0.0270713794287,                regression.getSlopeConfidenceInterval(),1E-8);     }    // Remove observation when empty    @Test    public void testRemoveObsFromEmpty() {        SimpleRegression regression = new SimpleRegression();        regression.removeData(removeX, removeY);        Assert.assertEquals(regression.getN(), 0);    }    // Remove single observation to empty    @Test    public void testRemoveObsFromSingle() {        SimpleRegression regression = new SimpleRegression();        regression.addData(removeX, removeY);        regression.removeData(removeX, removeY);        Assert.assertEquals(regression.getN(), 0);    }    // Remove multiple observations to empty    @Test    public void testRemoveMultipleToEmpty() {        SimpleRegression regression = new SimpleRegression();        regression.addData(removeMultiple);        regression.removeData(removeMultiple);        Assert.assertEquals(regression.getN(), 0);    }    // Remove multiple observations past empty (i.e. size of array > n)    @Test    public void testRemoveMultiplePastEmpty() {        SimpleRegression regression = new SimpleRegression();        regression.addData(removeX, removeY);        regression.removeData(removeMultiple);        Assert.assertEquals(regression.getN(), 0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.regression;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.stat.correlation.PearsonsCorrelation;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Test;import static org.junit.Assert.*;/** * MillerUpdatingRegression tests. */public class MillerUpdatingRegressionTest {    public MillerUpdatingRegressionTest() {    }    /* This is the Greene Airline Cost data.      * The data can be downloaded from http://www.indiana.edu/~statmath/stat/all/panel/airline.csv     */     private final static double[][] airdata = {        /*"I",*/new double[]{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},        /*"T",*/ new double[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},        /*"C",*/ new double[]{1140640, 1215690, 1309570, 1511530, 1676730, 1823740, 2022890, 2314760, 2639160, 3247620, 3787750, 3867750, 3996020, 4282880, 4748320, 569292, 640614, 777655, 999294, 1203970, 1358100, 1501350, 1709270, 2025400, 2548370, 3137740, 3557700, 3717740, 3962370, 4209390, 286298, 309290, 342056, 374595, 450037, 510412, 575347, 669331, 783799, 913883, 1041520, 1125800, 1096070, 1198930, 1170470, 145167, 170192, 247506, 309391, 354338, 373941, 420915, 474017, 532590, 676771, 880438, 1052020, 1193680, 1303390, 1436970, 91361, 95428, 98187, 115967, 138382, 156228, 183169, 210212, 274024, 356915, 432344, 524294, 530924, 581447, 610257, 68978, 74904, 83829, 98148, 118449, 133161, 145062, 170711, 199775, 276797, 381478, 506969, 633388, 804388, 1009500},        /*"Q",*/ new double[]{0.952757, 0.986757, 1.09198, 1.17578, 1.16017, 1.17376, 1.29051, 1.39067, 1.61273, 1.82544, 1.54604, 1.5279, 1.6602, 1.82231, 1.93646, 0.520635, 0.534627, 0.655192, 0.791575, 0.842945, 0.852892, 0.922843, 1, 1.19845, 1.34067, 1.32624, 1.24852, 1.25432, 1.37177, 1.38974, 0.262424, 0.266433, 0.306043, 0.325586, 0.345706, 0.367517, 0.409937, 0.448023, 0.539595, 0.539382, 0.467967, 0.450544, 0.468793, 0.494397, 0.493317, 0.086393, 0.09674, 0.1415, 0.169715, 0.173805, 0.164272, 0.170906, 0.17784, 0.192248, 0.242469, 0.256505, 0.249657, 0.273923, 0.371131, 0.421411, 0.051028, 0.052646, 0.056348, 0.066953, 0.070308, 0.073961, 0.084946, 0.095474, 0.119814, 0.150046, 0.144014, 0.1693, 0.172761, 0.18667, 0.213279, 0.037682, 0.039784, 0.044331, 0.050245, 0.055046, 0.052462, 0.056977, 0.06149, 0.069027, 0.092749, 0.11264, 0.154154, 0.186461, 0.246847, 0.304013},        /*"PF",*/ new double[]{106650, 110307, 110574, 121974, 196606, 265609, 263451, 316411, 384110, 569251, 871636, 997239, 938002, 859572, 823411, 103795, 111477, 118664, 114797, 215322, 281704, 304818, 348609, 374579, 544109, 853356, 1003200, 941977, 856533, 821361, 118788, 123798, 122882, 131274, 222037, 278721, 306564, 356073, 378311, 555267, 850322, 1015610, 954508, 886999, 844079, 114987, 120501, 121908, 127220, 209405, 263148, 316724, 363598, 389436, 547376, 850418, 1011170, 951934, 881323, 831374, 118222, 116223, 115853, 129372, 243266, 277930, 317273, 358794, 397667, 566672, 848393, 1005740, 958231, 872924, 844622, 117112, 119420, 116087, 122997, 194309, 307923, 323595, 363081, 386422, 564867, 874818, 1013170, 930477, 851676, 819476},        /*"LF",*/ new double[]{0.534487, 0.532328, 0.547736, 0.540846, 0.591167, 0.575417, 0.594495, 0.597409, 0.638522, 0.676287, 0.605735, 0.61436, 0.633366, 0.650117, 0.625603, 0.490851, 0.473449, 0.503013, 0.512501, 0.566782, 0.558133, 0.558799, 0.57207, 0.624763, 0.628706, 0.58915, 0.532612, 0.526652, 0.540163, 0.528775, 0.524334, 0.537185, 0.582119, 0.579489, 0.606592, 0.60727, 0.582425, 0.573972, 0.654256, 0.631055, 0.56924, 0.589682, 0.587953, 0.565388, 0.577078, 0.432066, 0.439669, 0.488932, 0.484181, 0.529925, 0.532723, 0.549067, 0.55714, 0.611377, 0.645319, 0.611734, 0.580884, 0.572047, 0.59457, 0.585525, 0.442875, 0.462473, 0.519118, 0.529331, 0.557797, 0.556181, 0.569327, 0.583465, 0.631818, 0.604723, 0.587921, 0.616159, 0.605868, 0.594688, 0.635545, 0.448539, 0.475889, 0.500562, 0.500344, 0.528897, 0.495361, 0.510342, 0.518296, 0.546723, 0.554276, 0.517766, 0.580049, 0.556024, 0.537791, 0.525775}    };    /**     * Test of hasIntercept method, of class MillerUpdatingRegression.     */    @Test    public void testHasIntercept() {        MillerUpdatingRegression instance = new MillerUpdatingRegression(10, false);        if (instance.hasIntercept()) {            fail("Should not have intercept");        }        instance = new MillerUpdatingRegression(10, true);        if (!instance.hasIntercept()) {            fail("Should have intercept");        }    }    /**     * Test of getN method, of class MillerUpdatingRegression.     */    @Test    public void testAddObsGetNClear() {        MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true);        double[][] xAll = new double[airdata[0].length][];        double[] y = new double[airdata[0].length];        for (int i = 0; i < airdata[0].length; i++) {            xAll[i] = new double[3];            xAll[i][0] = Math.log(airdata[3][i]);            xAll[i][1] = Math.log(airdata[4][i]);            xAll[i][2] = airdata[5][i];            y[i] = Math.log(airdata[2][i]);        }        instance.addObservations(xAll, y);        if (instance.getN() != xAll.length) {            fail("Number of observations not correct in bulk addition");        }        instance.clear();        for (int i = 0; i < xAll.length; i++) {            instance.addObservation(xAll[i], y[i]);        }        if (instance.getN() != xAll.length) {            fail("Number of observations not correct in drip addition");        }        return;    }    @Test    public void testNegativeTestAddObs() {        MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true);        try {            instance.addObservation(new double[]{1.0}, 0.0);            fail("Should throw IllegalArgumentException");        } catch (IllegalArgumentException iae) {        } catch (Exception e) {            fail("Should throw IllegalArgumentException");        }        try {            instance.addObservation(new double[]{1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}, 0.0);            fail("Should throw IllegalArgumentException");        } catch (IllegalArgumentException iae) {        } catch (Exception e) {            fail("Should throw IllegalArgumentException");        }        try {            instance.addObservation(new double[]{1.0, 1.0, 1.0}, 0.0);        } catch (Exception e) {            fail("Should throw IllegalArgumentException");        }        //now we try it without an intercept        instance = new MillerUpdatingRegression(3, false);        try {            instance.addObservation(new double[]{1.0}, 0.0);            fail("Should throw IllegalArgumentException [NOINTERCEPT]");        } catch (IllegalArgumentException iae) {        } catch (Exception e) {            fail("Should throw IllegalArgumentException [NOINTERCEPT]");        }        try {            instance.addObservation(new double[]{1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}, 0.0);            fail("Should throw IllegalArgumentException [NOINTERCEPT]");        } catch (IllegalArgumentException iae) {        } catch (Exception e) {            fail("Should throw IllegalArgumentException [NOINTERCEPT]");        }        try {            instance.addObservation(new double[]{1.0, 1.0, 1.0}, 0.0);        } catch (Exception e) {            fail("Should throw IllegalArgumentException [NOINTERCEPT]");        }    }    @Test    public void testNegativeTestAddMultipleObs() {        MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true);        try {            double[][] tst = {{1.0, 1.0, 1.0}, {1.20, 2.0, 2.1}};            double[] y = {1.0};            instance.addObservations(tst, y);            fail("Should throw IllegalArgumentException");        } catch (IllegalArgumentException iae) {        } catch (Exception e) {            fail("Should throw IllegalArgumentException");        }        try {            double[][] tst = {{1.0, 1.0, 1.0}, {1.20, 2.0, 2.1}};            double[] y = {1.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};            instance.addObservations(tst, y);            fail("Should throw IllegalArgumentException");        } catch (IllegalArgumentException iae) {        } catch (Exception e) {            fail("Should throw IllegalArgumentException");        }    }    /* Results can be found at http://www.indiana.edu/~statmath/stat/all/panel/panel4.html     * This test concerns a known data set     */    @Test    public void testRegressAirlineConstantExternal() {        MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false);        double[][] x = new double[airdata[0].length][];        double[] y = new double[airdata[0].length];        for (int i = 0; i < airdata[0].length; i++) {            x[i] = new double[4];            x[i][0] = 1.0;            x[i][1] = Math.log(airdata[3][i]);            x[i][2] = Math.log(airdata[4][i]);            x[i][3] = airdata[5][i];            y[i] = Math.log(airdata[2][i]);        }        instance.addObservations(x, y);        try {            RegressionResults result = instance.regress();            if (result == null) {                fail("The test case is a prototype.");            }            TestUtils.assertEquals(                    new double[]{9.5169, 0.8827, 0.4540, -1.6275},                    result.getParameterEstimates(), 1e-4);            TestUtils.assertEquals(                    new double[]{.2292445, .0132545, .0203042, .345302},                    result.getStdErrorOfEstimates(), 1.0e-4);            TestUtils.assertEquals(0.01552839, result.getMeanSquareError(), 1.0e-8);        } catch (Exception e) {            fail("Should not throw exception but does");        }    }    @Test    public void testRegressAirlineConstantInternal() {        MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true);        double[][] x = new double[airdata[0].length][];        double[] y = new double[airdata[0].length];        for (int i = 0; i < airdata[0].length; i++) {            x[i] = new double[3];            x[i][0] = Math.log(airdata[3][i]);            x[i][1] = Math.log(airdata[4][i]);            x[i][2] = airdata[5][i];            y[i] = Math.log(airdata[2][i]);        }        instance.addObservations(x, y);        try {            RegressionResults result = instance.regress();            if (result == null) {                fail("The test case is a prototype.");            }            TestUtils.assertEquals(                    new double[]{9.5169, 0.8827, 0.4540, -1.6275},                    result.getParameterEstimates(), 1e-4);            TestUtils.assertEquals(                    new double[]{.2292445, .0132545, .0203042, .345302},                    result.getStdErrorOfEstimates(), 1.0e-4);            TestUtils.assertEquals(0.9883, result.getRSquared(), 1.0e-4);            TestUtils.assertEquals(0.01552839, result.getMeanSquareError(), 1.0e-8);        } catch (Exception e) {            fail("Should not throw exception but does");        }    }    @Test    public void testFilippelli() throws MathException {        double[] data = new double[]{            0.8116, -6.860120914,            0.9072, -4.324130045,            0.9052, -4.358625055,            0.9039, -4.358426747,            0.8053, -6.955852379,            0.8377, -6.661145254,            0.8667, -6.355462942,            0.8809, -6.118102026,            0.7975, -7.115148017,            0.8162, -6.815308569,            0.8515, -6.519993057,            0.8766, -6.204119983,            0.8885, -5.853871964,            0.8859, -6.109523091,            0.8959, -5.79832982,            0.8913, -5.482672118,            0.8959, -5.171791386,            0.8971, -4.851705903,            0.9021, -4.517126416,            0.909, -4.143573228,            0.9139, -3.709075441,            0.9199, -3.499489089,            0.8692, -6.300769497,            0.8872, -5.953504836,            0.89, -5.642065153,            0.891, -5.031376979,            0.8977, -4.680685696,            0.9035, -4.329846955,            0.9078, -3.928486195,            0.7675, -8.56735134,            0.7705, -8.363211311,            0.7713, -8.107682739,            0.7736, -7.823908741,            0.7775, -7.522878745,            0.7841, -7.218819279,            0.7971, -6.920818754,            0.8329, -6.628932138,            0.8641, -6.323946875,            0.8804, -5.991399828,            0.7668, -8.781464495,            0.7633, -8.663140179,            0.7678, -8.473531488,            0.7697, -8.247337057,            0.77, -7.971428747,            0.7749, -7.676129393,            0.7796, -7.352812702,            0.7897, -7.072065318,            0.8131, -6.774174009,            0.8498, -6.478861916,            0.8741, -6.159517513,            0.8061, -6.835647144,            0.846, -6.53165267,            0.8751, -6.224098421,            0.8856, -5.910094889,            0.8919, -5.598599459,            0.8934, -5.290645224,            0.894, -4.974284616,            0.8957, -4.64454848,            0.9047, -4.290560426,            0.9129, -3.885055584,            0.9209, -3.408378962,            0.9219, -3.13200249,            0.7739, -8.726767166,            0.7681, -8.66695597,            0.7665, -8.511026475,            0.7703, -8.165388579,            0.7702, -7.886056648,            0.7761, -7.588043762,            0.7809, -7.283412422,            0.7961, -6.995678626,            0.8253, -6.691862621,            0.8602, -6.392544977,            0.8809, -6.067374056,            0.8301, -6.684029655,            0.8664, -6.378719832,            0.8834, -6.065855188,            0.8898, -5.752272167,            0.8964, -5.132414673,            0.8963, -4.811352704,            0.9074, -4.098269308,            0.9119, -3.66174277,            0.9228, -3.2644011        };        MillerUpdatingRegression model = new MillerUpdatingRegression(10, true);        int off = 0;        double[] tmp = new double[10];        int nobs = 82;        for (int i = 0; i < nobs; i++) {            tmp[0] = data[off + 1];//            tmp[1] = tmp[0] * tmp[0];//            tmp[2] = tmp[0] * tmp[1]; //^3//            tmp[3] = tmp[1] * tmp[1]; //^4//            tmp[4] = tmp[2] * tmp[1]; //^5//            tmp[5] = tmp[2] * tmp[2]; //^6//            tmp[6] = tmp[2] * tmp[3]; //^7//            tmp[7] = tmp[3] * tmp[3]; //^8//            tmp[8] = tmp[4] * tmp[3]; //^9//            tmp[9] = tmp[4] * tmp[4]; //^10                       tmp[1] = tmp[0] * tmp[0];            tmp[2] = tmp[0] * tmp[1];            tmp[3] = tmp[0] * tmp[2];            tmp[4] = tmp[0] * tmp[3];            tmp[5] = tmp[0] * tmp[4];            tmp[6] = tmp[0] * tmp[5];            tmp[7] = tmp[0] * tmp[6];            tmp[8] = tmp[0] * tmp[7];            tmp[9] = tmp[0] * tmp[8];            model.addObservation(tmp, data[off]);            off += 2;        }        RegressionResults result = model.regress();        double[] betaHat = result.getParameterEstimates();        TestUtils.assertEquals(betaHat,                new double[]{                    -1467.48961422980,                    -2772.17959193342,                    -2316.37108160893,                    -1127.97394098372,                    -354.478233703349,                    -75.1242017393757,                    -10.8753180355343,                    -1.06221498588947,                    -0.670191154593408E-01,                    -0.246781078275479E-02,                    -0.402962525080404E-04                }, 1E-5); ////        double[] se = result.getStdErrorOfEstimates();        TestUtils.assertEquals(se,                new double[]{                    298.084530995537,                    559.779865474950,                    466.477572127796,                    227.204274477751,                    71.6478660875927,                    15.2897178747400,                    2.23691159816033,                    0.221624321934227,                    0.142363763154724E-01,                    0.535617408889821E-03,                    0.896632837373868E-05                }, 1E-5); //        TestUtils.assertEquals(0.996727416185620, result.getRSquared(), 1.0e-8);        TestUtils.assertEquals(0.112091743968020E-04, result.getMeanSquareError(), 1.0e-10);        TestUtils.assertEquals(0.795851382172941E-03, result.getErrorSumSquares(), 1.0e-10);    }    @Test    public void testWampler1() throws MathException {        double[] data = new double[]{            1, 0,            6, 1,            63, 2,            364, 3,            1365, 4,            3906, 5,            9331, 6,            19608, 7,            37449, 8,            66430, 9,            111111, 10,            177156, 11,            271453, 12,            402234, 13,            579195, 14,            813616, 15,            1118481, 16,            1508598, 17,            2000719, 18,            2613660, 19,            3368421, 20};        MillerUpdatingRegression model = new MillerUpdatingRegression(5, true);        int off = 0;        double[] tmp = new double[5];        int nobs = 21;        for (int i = 0; i < nobs; i++) {            tmp[0] = data[off + 1];            tmp[1] = tmp[0] * tmp[0];            tmp[2] = tmp[0] * tmp[1];            tmp[3] = tmp[0] * tmp[2];            tmp[4] = tmp[0] * tmp[3];            model.addObservation(tmp, data[off]);            off += 2;        }        RegressionResults result = model.regress();        double[] betaHat = result.getParameterEstimates();        TestUtils.assertEquals(betaHat,                new double[]{1.0,                    1.0, 1.0,                    1.0, 1.0,                    1.0}, 1E-8); ////        double[] se = result.getStdErrorOfEstimates();        TestUtils.assertEquals(se,                new double[]{0.0,                    0.0, 0.0,                    0.0, 0.0,                    0.0}, 1E-8); //        TestUtils.assertEquals(1.0, result.getRSquared(), 1.0e-10);        TestUtils.assertEquals(0, result.getMeanSquareError(), 1.0e-7);        TestUtils.assertEquals(0.00, result.getErrorSumSquares(), 1.0e-6);        return;    }    @Test    public void testWampler2() throws MathException {        double[] data = new double[]{            1.00000, 0,            1.11111, 1,            1.24992, 2,            1.42753, 3,            1.65984, 4,            1.96875, 5,            2.38336, 6,            2.94117, 7,            3.68928, 8,            4.68559, 9,            6.00000, 10,            7.71561, 11,            9.92992, 12,            12.75603, 13,            16.32384, 14,            20.78125, 15,            26.29536, 16,            33.05367, 17,            41.26528, 18,            51.16209, 19,            63.00000, 20};        MillerUpdatingRegression model = new MillerUpdatingRegression(5, true);        int off = 0;        double[] tmp = new double[5];        int nobs = 21;        for (int i = 0; i < nobs; i++) {            tmp[0] = data[off + 1];            tmp[1] = tmp[0] * tmp[0];            tmp[2] = tmp[0] * tmp[1];            tmp[3] = tmp[0] * tmp[2];            tmp[4] = tmp[0] * tmp[3];            model.addObservation(tmp, data[off]);            off += 2;        }        RegressionResults result = model.regress();        double[] betaHat = result.getParameterEstimates();        TestUtils.assertEquals(betaHat,                new double[]{1.0,                    1.0e-1, 1.0e-2,                    1.0e-3, 1.0e-4,                    1.0e-5}, 1E-8); ////        double[] se = result.getStdErrorOfEstimates();        TestUtils.assertEquals(se,                new double[]{0.0,                    0.0, 0.0,                    0.0, 0.0,                    0.0}, 1E-8); //        TestUtils.assertEquals(1.0, result.getRSquared(), 1.0e-10);        TestUtils.assertEquals(0, result.getMeanSquareError(), 1.0e-7);        TestUtils.assertEquals(0.00, result.getErrorSumSquares(), 1.0e-6);        return;    }    @Test    public void testWampler3() throws MathException {        double[] data = new double[]{            760, 0,            -2042, 1,            2111, 2,            -1684, 3,            3888, 4,            1858, 5,            11379, 6,            17560, 7,            39287, 8,            64382, 9,            113159, 10,            175108, 11,            273291, 12,            400186, 13,            581243, 14,            811568, 15,            1121004, 16,            1506550, 17,            2002767, 18,            2611612, 19,            3369180, 20};        MillerUpdatingRegression model = new MillerUpdatingRegression(5, true);        int off = 0;        double[] tmp = new double[5];        int nobs = 21;        for (int i = 0; i < nobs; i++) {            tmp[0] = data[off + 1];            tmp[1] = tmp[0] * tmp[0];            tmp[2] = tmp[0] * tmp[1];            tmp[3] = tmp[0] * tmp[2];            tmp[4] = tmp[0] * tmp[3];            model.addObservation(tmp, data[off]);            off += 2;        }        RegressionResults result = model.regress();        double[] betaHat = result.getParameterEstimates();        TestUtils.assertEquals(betaHat,                new double[]{1.0,                    1.0, 1.0,                    1.0, 1.0,                    1.0}, 1E-8); //        double[] se = result.getStdErrorOfEstimates();        TestUtils.assertEquals(se,                new double[]{2152.32624678170,                    2363.55173469681, 779.343524331583,                    101.475507550350, 5.64566512170752,                    0.112324854679312}, 1E-8); //        TestUtils.assertEquals(.999995559025820, result.getRSquared(), 1.0e-10);        TestUtils.assertEquals(5570284.53333333, result.getMeanSquareError(), 1.0e-7);        TestUtils.assertEquals(83554268.0000000, result.getErrorSumSquares(), 1.0e-6);        return;    }    //@Test    public void testWampler4() throws MathException {        double[] data = new double[]{            75901, 0,            -204794, 1,            204863, 2,            -204436, 3,            253665, 4,            -200894, 5,            214131, 6,            -185192, 7,            221249, 8,            -138370, 9,            315911, 10,            -27644, 11,            455253, 12,            197434, 13,            783995, 14,            608816, 15,            1370781, 16,            1303798, 17,            2205519, 18,            2408860, 19,            3444321, 20};        MillerUpdatingRegression model = new MillerUpdatingRegression(5, true);        int off = 0;        double[] tmp = new double[5];        int nobs = 21;        for (int i = 0; i < nobs; i++) {            tmp[0] = data[off + 1];            tmp[1] = tmp[0] * tmp[0];            tmp[2] = tmp[0] * tmp[1];            tmp[3] = tmp[0] * tmp[2];            tmp[4] = tmp[0] * tmp[3];            model.addObservation(tmp, data[off]);            off += 2;        }        RegressionResults result = model.regress();        double[] betaHat = result.getParameterEstimates();        TestUtils.assertEquals(betaHat,                new double[]{1.0,                    1.0, 1.0,                    1.0, 1.0,                    1.0}, 1E-8); ////        double[] se = result.getStdErrorOfEstimates();        TestUtils.assertEquals(se,                new double[]{215232.624678170,                    236355.173469681, 77934.3524331583,                    10147.5507550350, 564.566512170752,                    11.2324854679312}, 1E-8); //        TestUtils.assertEquals(.957478440825662, result.getRSquared(), 1.0e-10);        TestUtils.assertEquals(55702845333.3333, result.getMeanSquareError(), 1.0e-4);        TestUtils.assertEquals(835542680000.000, result.getErrorSumSquares(), 1.0e-3);        return;    }    /**     * Test Longley dataset against certified values provided by NIST.     * Data Source: J. Longley (1967) "An Appraisal of Least Squares     * Programs for the Electronic Computer from the Point of View of the User"     * Journal of the American Statistical Association, vol. 62. September,     * pp. 819-841.     *     * Certified values (and data) are from NIST:     * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat     */    @Test    public void testLongly() throws Exception {        // Y values are first, then independent vars        // Each row is one observation        double[] design = new double[]{            60323, 83.0, 234289, 2356, 1590, 107608, 1947,            61122, 88.5, 259426, 2325, 1456, 108632, 1948,            60171, 88.2, 258054, 3682, 1616, 109773, 1949,            61187, 89.5, 284599, 3351, 1650, 110929, 1950,            63221, 96.2, 328975, 2099, 3099, 112075, 1951,            63639, 98.1, 346999, 1932, 3594, 113270, 1952,            64989, 99.0, 365385, 1870, 3547, 115094, 1953,            63761, 100.0, 363112, 3578, 3350, 116219, 1954,            66019, 101.2, 397469, 2904, 3048, 117388, 1955,            67857, 104.6, 419180, 2822, 2857, 118734, 1956,            68169, 108.4, 442769, 2936, 2798, 120445, 1957,            66513, 110.8, 444546, 4681, 2637, 121950, 1958,            68655, 112.6, 482704, 3813, 2552, 123366, 1959,            69564, 114.2, 502601, 3931, 2514, 125368, 1960,            69331, 115.7, 518173, 4806, 2572, 127852, 1961,            70551, 116.9, 554894, 4007, 2827, 130081, 1962        };        final int nobs = 16;        final int nvars = 6;        // Estimate the model        MillerUpdatingRegression model = new MillerUpdatingRegression(6, true);        int off = 0;        double[] tmp = new double[6];        for (int i = 0; i < nobs; i++) {            System.arraycopy(design, off + 1, tmp, 0, nvars);            model.addObservation(tmp, design[off]);            off += nvars + 1;        }        // Check expected beta values from NIST        RegressionResults result = model.regress();        double[] betaHat = result.getParameterEstimates();        TestUtils.assertEquals(betaHat,                new double[]{-3482258.63459582, 15.0618722713733,                    -0.358191792925910E-01, -2.02022980381683,                    -1.03322686717359, -0.511041056535807E-01,                    1829.15146461355}, 1E-8); //        // Check standard errors from NIST        double[] errors = result.getStdErrorOfEstimates();        TestUtils.assertEquals(new double[]{890420.383607373,                    84.9149257747669,                    0.334910077722432E-01,                    0.488399681651699,                    0.214274163161675,                    0.226073200069370,                    455.478499142212}, errors, 1E-6);//                // Check R-Square statistics against R        TestUtils.assertEquals(0.995479004577296, result.getRSquared(), 1E-12);        TestUtils.assertEquals(0.992465007628826, result.getAdjustedRSquared(), 1E-12);//        //        //        // Estimate model without intercept        model = new MillerUpdatingRegression(6, false);        off = 0;        for (int i = 0; i < nobs; i++) {            System.arraycopy(design, off + 1, tmp, 0, nvars);            model.addObservation(tmp, design[off]);            off += nvars + 1;        }        // Check expected beta values from R        result = model.regress();        betaHat = result.getParameterEstimates();        TestUtils.assertEquals(betaHat,                new double[]{-52.99357013868291, 0.07107319907358,                    -0.42346585566399, -0.57256866841929,                    -0.41420358884978, 48.41786562001326}, 1E-11);//                // Check standard errors from R        errors = result.getStdErrorOfEstimates();        TestUtils.assertEquals(new double[]{129.54486693117232, 0.03016640003786,                    0.41773654056612, 0.27899087467676, 0.32128496193363,                    17.68948737819961}, errors, 1E-11);//        //        // Check R-Square statistics against R        TestUtils.assertEquals(0.9999670130706, result.getRSquared(), 1E-12);        TestUtils.assertEquals(0.999947220913, result.getAdjustedRSquared(), 1E-12);    }//    @Test//    public void testRegressReorder() throws MathException {//        // System.out.println("testRegressReorder");//        MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false);//        double[][] x = new double[airdata[0].length][];//        double[] y = new double[airdata[0].length];//        for (int i = 0; i < airdata[0].length; i++) {//            x[i] = new double[4];//            x[i][0] = 1.0;//            x[i][1] = Math.log(airdata[3][i]);//            x[i][2] = Math.log(airdata[4][i]);//            x[i][3] = airdata[5][i];//            y[i] = Math.log(airdata[2][i]);//        }////        instance.addObservations(x, y);//        RegressionResults result = instance.regress();//        if (result == null) {//            fail("Null result....");//        }////        instance.reorderRegressors(new int[]{3, 2}, 0);//        RegressionResults resultInverse = instance.regress();////        double[] beta = result.getParameterEstimates();//        double[] betar = resultInverse.getParameterEstimates();//        if (Math.abs(beta[0] - betar[0]) > 1.0e-14) {//            fail("Parameters not correct after reorder (0,3)");//        }//        if (Math.abs(beta[1] - betar[1]) > 1.0e-14) {//            fail("Parameters not correct after reorder (1,2)");//        }//        if (Math.abs(beta[2] - betar[2]) > 1.0e-14) {//            fail("Parameters not correct after reorder (2,1)");//        }//        if (Math.abs(beta[3] - betar[3]) > 1.0e-14) {//            fail("Parameters not correct after reorder (3,0)");//        }//    }    @Test    public void testOneRedundantColumn() throws MathException {        MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false);        MillerUpdatingRegression instance2 = new MillerUpdatingRegression(5, false);        double[][] x = new double[airdata[0].length][];        double[][] x2 = new double[airdata[0].length][];        double[] y = new double[airdata[0].length];        for (int i = 0; i < airdata[0].length; i++) {            x[i] = new double[4];            x2[i] = new double[5];            x[i][0] = 1.0;            x[i][1] = Math.log(airdata[3][i]);            x[i][2] = Math.log(airdata[4][i]);            x[i][3] = airdata[5][i];            x2[i][0] = x[i][0];            x2[i][1] = x[i][1];            x2[i][2] = x[i][2];            x2[i][3] = x[i][3];            x2[i][4] = x[i][3];            y[i] = Math.log(airdata[2][i]);        }        instance.addObservations(x, y);        RegressionResults result = instance.regress();        if (result == null) {            fail("Could not estimate initial regression");        }        instance2.addObservations(x2, y);        RegressionResults resultRedundant = instance2.regress();        if (resultRedundant == null) {            fail("Could not estimate redundant regression");        }        double[] beta = result.getParameterEstimates();        double[] betar = resultRedundant.getParameterEstimates();        double[] se = result.getStdErrorOfEstimates();        double[] ser = resultRedundant.getStdErrorOfEstimates();        for (int i = 0; i < beta.length; i++) {            if (Math.abs(beta[i] - betar[i]) > 1.0e-8) {                fail("Parameters not correctly estimated");            }            if (Math.abs(se[i] - ser[i]) > 1.0e-8) {                fail("Standard errors not correctly estimated");            }            for (int j = 0; j < i; j++) {                if (Math.abs(result.getCovarianceOfParameters(i, j)                        - resultRedundant.getCovarianceOfParameters(i, j)) > 1.0e-8) {                    fail("Variance Covariance not correct");                }            }        }        TestUtils.assertEquals(result.getAdjustedRSquared(), resultRedundant.getAdjustedRSquared(), 1.0e-8);        TestUtils.assertEquals(result.getErrorSumSquares(), resultRedundant.getErrorSumSquares(), 1.0e-8);        TestUtils.assertEquals(result.getMeanSquareError(), resultRedundant.getMeanSquareError(), 1.0e-8);        TestUtils.assertEquals(result.getRSquared(), resultRedundant.getRSquared(), 1.0e-8);        return;    }    @Test    public void testThreeRedundantColumn() throws MathException {        MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false);        MillerUpdatingRegression instance2 = new MillerUpdatingRegression(7, false);        double[][] x = new double[airdata[0].length][];        double[][] x2 = new double[airdata[0].length][];        double[] y = new double[airdata[0].length];        for (int i = 0; i < airdata[0].length; i++) {            x[i] = new double[4];            x2[i] = new double[7];            x[i][0] = 1.0;            x[i][1] = Math.log(airdata[3][i]);            x[i][2] = Math.log(airdata[4][i]);            x[i][3] = airdata[5][i];            x2[i][0] = x[i][0];            x2[i][1] = x[i][0];            x2[i][2] = x[i][1];            x2[i][3] = x[i][2];            x2[i][4] = x[i][1];            x2[i][5] = x[i][3];            x2[i][6] = x[i][2];            y[i] = Math.log(airdata[2][i]);        }        instance.addObservations(x, y);        RegressionResults result = instance.regress();        if (result == null) {            fail("Could not estimate initial regression");        }        instance2.addObservations(x2, y);        RegressionResults resultRedundant = instance2.regress();        if (resultRedundant == null) {            fail("Could not estimate redundant regression");        }        double[] beta = result.getParameterEstimates();        double[] betar = resultRedundant.getParameterEstimates();        double[] se = result.getStdErrorOfEstimates();        double[] ser = resultRedundant.getStdErrorOfEstimates();        if (Math.abs(beta[0] - betar[0]) > 1.0e-8) {            fail("Parameters not correct after reorder (0,3)");        }        if (Math.abs(beta[1] - betar[2]) > 1.0e-8) {            fail("Parameters not correct after reorder (1,2)");        }        if (Math.abs(beta[2] - betar[3]) > 1.0e-8) {            fail("Parameters not correct after reorder (2,1)");        }        if (Math.abs(beta[3] - betar[5]) > 1.0e-8) {            fail("Parameters not correct after reorder (3,0)");        }        if (Math.abs(se[0] - ser[0]) > 1.0e-8) {            fail("Se not correct after reorder (0,3)");        }        if (Math.abs(se[1] - ser[2]) > 1.0e-8) {            fail("Se not correct after reorder (1,2)");        }        if (Math.abs(se[2] - ser[3]) > 1.0e-8) {            fail("Se not correct after reorder (2,1)");        }        if (Math.abs(se[3] - ser[5]) > 1.0e-8) {            fail("Se not correct after reorder (3,0)");        }        if (Math.abs(result.getCovarianceOfParameters(0, 0)                - resultRedundant.getCovarianceOfParameters(0, 0)) > 1.0e-8) {            fail("VCV not correct after reorder (0,0)");        }        if (Math.abs(result.getCovarianceOfParameters(0, 1)                - resultRedundant.getCovarianceOfParameters(0, 2)) > 1.0e-8) {            fail("VCV not correct after reorder (0,1)<->(0,2)");        }        if (Math.abs(result.getCovarianceOfParameters(0, 2)                - resultRedundant.getCovarianceOfParameters(0, 3)) > 1.0e-8) {            fail("VCV not correct after reorder (0,2)<->(0,1)");        }        if (Math.abs(result.getCovarianceOfParameters(0, 3)                - resultRedundant.getCovarianceOfParameters(0, 5)) > 1.0e-8) {            fail("VCV not correct after reorder (0,3)<->(0,3)");        }        if (Math.abs(result.getCovarianceOfParameters(1, 0)                - resultRedundant.getCovarianceOfParameters(2, 0)) > 1.0e-8) {            fail("VCV not correct after reorder (1,0)<->(2,0)");        }        if (Math.abs(result.getCovarianceOfParameters(1, 1)                - resultRedundant.getCovarianceOfParameters(2, 2)) > 1.0e-8) {            fail("VCV not correct  (1,1)<->(2,1)");        }        if (Math.abs(result.getCovarianceOfParameters(1, 2)                - resultRedundant.getCovarianceOfParameters(2, 3)) > 1.0e-8) {            fail("VCV not correct  (1,2)<->(2,2)");        }        if (Math.abs(result.getCovarianceOfParameters(2, 0)                - resultRedundant.getCovarianceOfParameters(3, 0)) > 1.0e-8) {            fail("VCV not correct  (2,0)<->(1,0)");        }        if (Math.abs(result.getCovarianceOfParameters(2, 1)                - resultRedundant.getCovarianceOfParameters(3, 2)) > 1.0e-8) {            fail("VCV not correct  (2,1)<->(1,2)");        }        if (Math.abs(result.getCovarianceOfParameters(3, 3)                - resultRedundant.getCovarianceOfParameters(5, 5)) > 1.0e-8) {            fail("VCV not correct  (3,3)<->(3,2)");        }        TestUtils.assertEquals(result.getAdjustedRSquared(), resultRedundant.getAdjustedRSquared(), 1.0e-8);        TestUtils.assertEquals(result.getErrorSumSquares(), resultRedundant.getErrorSumSquares(), 1.0e-8);        TestUtils.assertEquals(result.getMeanSquareError(), resultRedundant.getMeanSquareError(), 1.0e-8);        TestUtils.assertEquals(result.getRSquared(), resultRedundant.getRSquared(), 1.0e-8);        return;    }    @Test    public void testPCorr() {        MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false);        double[][] x = new double[airdata[0].length][];        double[] y = new double[airdata[0].length];        double[] cp = new double[10];        double[] yxcorr = new double[4];        double[] diag = new double[4];        double sumysq = 0.0;        int off = 0;        for (int i = 0; i < airdata[0].length; i++) {            x[i] = new double[4];            x[i][0] = 1.0;            x[i][1] = Math.log(airdata[3][i]);            x[i][2] = Math.log(airdata[4][i]);            x[i][3] = airdata[5][i];            y[i] = Math.log(airdata[2][i]);            off = 0;            for (int j = 0; j < 4; j++) {                double tmp = x[i][j];                for (int k = 0; k <= j; k++, off++) {                    cp[off] += tmp * x[i][k];                }                yxcorr[j] += tmp * y[i];            }            sumysq += y[i] * y[i];        }        PearsonsCorrelation pearson = new PearsonsCorrelation(x);        RealMatrix corr = pearson.getCorrelationMatrix();        off = 0;        for (int i = 0; i < 4; i++, off += (i + 1)) {            diag[i] = FastMath.sqrt(cp[off]);        }        instance.addObservations(x, y);        double[] pc = instance.getPartialCorrelations(0);        int idx = 0;        off = 0;        int off2 = 6;        for (int i = 0; i < 4; i++) {            for (int j = 0; j < i; j++) {                if (Math.abs(pc[idx] - cp[off] / (diag[i] * diag[j])) > 1.0e-8) {                    fail("Failed cross products... i = " + i + " j = " + j);                }                ++idx;                ++off;            }            ++off;            if (Math.abs(pc[i+off2] - yxcorr[ i] / (FastMath.sqrt(sumysq) * diag[i])) > 1.0e-8) {                fail("failed cross product i = " + i + " y");            }        }        double[] pc2 = instance.getPartialCorrelations(1);        idx = 0;        for (int i = 1; i < 4; i++) {            for (int j = 1; j < i; j++) {                if (Math.abs(pc2[idx] - corr.getEntry(j, i)) > 1.0e-8) {                    fail("Failed cross products... i = " + i + " j = " + j);                }                ++idx;            }        }        double[] pc3 = instance.getPartialCorrelations(2);        if (pc3 == null) {            fail("Should not be null");        }        return;    }    @Test    public void testHdiag() {        MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false);        double[][] x = new double[airdata[0].length][];        double[] y = new double[airdata[0].length];        for (int i = 0; i < airdata[0].length; i++) {            x[i] = new double[4];            x[i][0] = 1.0;            x[i][1] = Math.log(airdata[3][i]);            x[i][2] = Math.log(airdata[4][i]);            x[i][3] = airdata[5][i];            y[i] = Math.log(airdata[2][i]);        }        instance.addObservations(x, y);        OLSMultipleLinearRegression ols = new OLSMultipleLinearRegression();        ols.setNoIntercept(true);        ols.newSampleData(y, x);        RealMatrix rm = ols.calculateHat();        for (int i = 0; i < x.length; i++) {            TestUtils.assertEquals(instance.getDiagonalOfHatMatrix(x[i]), rm.getEntry(i, i), 1.0e-8);        }        return;    }    @Test    public void testHdiagConstant() {        MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true);        double[][] x = new double[airdata[0].length][];        double[] y = new double[airdata[0].length];        for (int i = 0; i < airdata[0].length; i++) {            x[i] = new double[3];            x[i][0] = Math.log(airdata[3][i]);            x[i][1] = Math.log(airdata[4][i]);            x[i][2] = airdata[5][i];            y[i] = Math.log(airdata[2][i]);        }        instance.addObservations(x, y);        OLSMultipleLinearRegression ols = new OLSMultipleLinearRegression();        ols.setNoIntercept(false);        ols.newSampleData(y, x);        RealMatrix rm = ols.calculateHat();        for (int i = 0; i < x.length; i++) {            TestUtils.assertEquals(instance.getDiagonalOfHatMatrix(x[i]), rm.getEntry(i, i), 1.0e-8);        }        return;    }            @Test    public void testSubsetRegression() throws MathException {                MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true);        MillerUpdatingRegression redRegression = new MillerUpdatingRegression(2, true);        double[][] x = new double[airdata[0].length][];        double[][] xReduced = new double[airdata[0].length][];        double[] y = new double[airdata[0].length];        for (int i = 0; i < airdata[0].length; i++) {            x[i] = new double[3];            x[i][0] = Math.log(airdata[3][i]);            x[i][1] = Math.log(airdata[4][i]);            x[i][2] = airdata[5][i];                        xReduced[i] = new double[2];            xReduced[i][0] = Math.log(airdata[3][i]);            xReduced[i][1] = Math.log(airdata[4][i]);                        y[i] = Math.log(airdata[2][i]);        }        instance.addObservations(x, y);        redRegression.addObservations(xReduced, y);                RegressionResults resultsInstance = instance.regress( new int[]{0,1,2} );        RegressionResults resultsReduced = redRegression.regress();                TestUtils.assertEquals(resultsInstance.getParameterEstimates(), resultsReduced.getParameterEstimates(), 1.0e-12);        TestUtils.assertEquals(resultsInstance.getStdErrorOfEstimates(), resultsReduced.getStdErrorOfEstimates(), 1.0e-12);    }        }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.regression;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.RealVector;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public abstract class MultipleLinearRegressionAbstractTest {    protected AbstractMultipleLinearRegression regression;    @Before    public void setUp(){        regression = createRegression();    }    protected abstract AbstractMultipleLinearRegression createRegression();    protected abstract int getNumberOfRegressors();    protected abstract int getSampleSize();    @Test    public void canEstimateRegressionParameters(){        double[] beta = regression.estimateRegressionParameters();        Assert.assertEquals(getNumberOfRegressors(), beta.length);    }    @Test    public void canEstimateResiduals(){        double[] e = regression.estimateResiduals();        Assert.assertEquals(getSampleSize(), e.length);    }    @Test    public void canEstimateRegressionParametersVariance(){        double[][] variance = regression.estimateRegressionParametersVariance();        Assert.assertEquals(getNumberOfRegressors(), variance.length);    }    @Test    public void canEstimateRegressandVariance(){        if (getSampleSize() > getNumberOfRegressors()) {            double variance = regression.estimateRegressandVariance();            Assert.assertTrue(variance > 0.0);        }    }        /**     * Verifies that newSampleData methods consistently insert unitary columns     * in design matrix.  Confirms the fix for MATH-411.     */    @Test    public void testNewSample() throws Exception {        double[] design = new double[] {          1, 19, 22, 33,          2, 20, 30, 40,          3, 25, 35, 45,          4, 27, 37, 47        };        double[] y = new double[] {1, 2, 3, 4};         double[][] x = new double[][] {          {19, 22, 33},          {20, 30, 40},          {25, 35, 45},          {27, 37, 47}           };        AbstractMultipleLinearRegression regression = createRegression();        regression.newSampleData(design, 4, 3);        RealMatrix flatX = regression.X.copy();        RealVector flatY = regression.Y.copy();        regression.newXSampleData(x);        regression.newYSampleData(y);        Assert.assertEquals(flatX, regression.X);        Assert.assertEquals(flatY, regression.Y);                // No intercept        regression.setNoIntercept(true);        regression.newSampleData(design, 4, 3);        flatX = regression.X.copy();        flatY = regression.Y.copy();        regression.newXSampleData(x);        regression.newYSampleData(y);        Assert.assertEquals(flatX, regression.X);        Assert.assertEquals(flatY, regression.Y);    }        @Test(expected=IllegalArgumentException.class)    public void testNewSampleNullData() throws Exception {        double[] data = null;        createRegression().newSampleData(data, 2, 3);     }        @Test(expected=IllegalArgumentException.class)    public void testNewSampleInvalidData() throws Exception {        double[] data = new double[] {1, 2, 3, 4};        createRegression().newSampleData(data, 2, 3);    }        @Test(expected=IllegalArgumentException.class)    public void testNewSampleInsufficientData() throws Exception {        double[] data = new double[] {1, 2, 3, 4};        createRegression().newSampleData(data, 1, 3);    }        @Test(expected=IllegalArgumentException.class)    public void testXSampleDataNull() {        createRegression().newXSampleData(null);    }        @Test(expected=IllegalArgumentException.class)    public void testYSampleDataNull() {        createRegression().newYSampleData(null);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.regression;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.apache.commons.math.TestUtils;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.RealVector;import org.apache.commons.math.random.CorrelatedRandomVectorGenerator;import org.apache.commons.math.random.JDKRandomGenerator;import org.apache.commons.math.random.GaussianRandomGenerator;import org.apache.commons.math.random.RandomGenerator;import org.apache.commons.math.stat.correlation.Covariance;import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;public class GLSMultipleLinearRegressionTest extends MultipleLinearRegressionAbstractTest {    private double[] y;    private double[][] x;    private double[][] omega;    private double[] longley = new double[] {            60323,83.0,234289,2356,1590,107608,1947,            61122,88.5,259426,2325,1456,108632,1948,            60171,88.2,258054,3682,1616,109773,1949,            61187,89.5,284599,3351,1650,110929,1950,            63221,96.2,328975,2099,3099,112075,1951,            63639,98.1,346999,1932,3594,113270,1952,            64989,99.0,365385,1870,3547,115094,1953,            63761,100.0,363112,3578,3350,116219,1954,            66019,101.2,397469,2904,3048,117388,1955,            67857,104.6,419180,2822,2857,118734,1956,            68169,108.4,442769,2936,2798,120445,1957,            66513,110.8,444546,4681,2637,121950,1958,            68655,112.6,482704,3813,2552,123366,1959,            69564,114.2,502601,3931,2514,125368,1960,            69331,115.7,518173,4806,2572,127852,1961,            70551,116.9,554894,4007,2827,130081,1962        };    @Before    @Override    public void setUp(){        y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};        x = new double[6][];        x[0] = new double[]{0, 0, 0, 0, 0};        x[1] = new double[]{2.0, 0, 0, 0, 0};        x[2] = new double[]{0, 3.0, 0, 0, 0};        x[3] = new double[]{0, 0, 4.0, 0, 0};        x[4] = new double[]{0, 0, 0, 5.0, 0};        x[5] = new double[]{0, 0, 0, 0, 6.0};        omega = new double[6][];        omega[0] = new double[]{1.0, 0, 0, 0, 0, 0};        omega[1] = new double[]{0, 2.0, 0, 0, 0, 0};        omega[2] = new double[]{0, 0, 3.0, 0, 0, 0};        omega[3] = new double[]{0, 0, 0, 4.0, 0, 0};        omega[4] = new double[]{0, 0, 0, 0, 5.0, 0};        omega[5] = new double[]{0, 0, 0, 0, 0, 6.0};        super.setUp();    }    @Test(expected=IllegalArgumentException.class)    public void cannotAddXSampleData() {        createRegression().newSampleData(new double[]{}, null, null);    }    @Test(expected=IllegalArgumentException.class)    public void cannotAddNullYSampleData() {        createRegression().newSampleData(null, new double[][]{}, null);    }    @Test(expected=IllegalArgumentException.class)    public void cannotAddSampleDataWithSizeMismatch() {        double[] y = new double[]{1.0, 2.0};        double[][] x = new double[1][];        x[0] = new double[]{1.0, 0};        createRegression().newSampleData(y, x, null);    }    @Test(expected=IllegalArgumentException.class)    public void cannotAddNullCovarianceData() {        createRegression().newSampleData(new double[]{}, new double[][]{}, null);    }    @Test(expected=IllegalArgumentException.class)    public void notEnoughData() {        double[]   reducedY = new double[y.length - 1];        double[][] reducedX = new double[x.length - 1][];        double[][] reducedO = new double[omega.length - 1][];        System.arraycopy(y,     0, reducedY, 0, reducedY.length);        System.arraycopy(x,     0, reducedX, 0, reducedX.length);        System.arraycopy(omega, 0, reducedO, 0, reducedO.length);        createRegression().newSampleData(reducedY, reducedX, reducedO);    }    @Test(expected=IllegalArgumentException.class)    public void cannotAddCovarianceDataWithSampleSizeMismatch() {        double[] y = new double[]{1.0, 2.0};        double[][] x = new double[2][];        x[0] = new double[]{1.0, 0};        x[1] = new double[]{0, 1.0};        double[][] omega = new double[1][];        omega[0] = new double[]{1.0, 0};        createRegression().newSampleData(y, x, omega);    }    @Test(expected=IllegalArgumentException.class)    public void cannotAddCovarianceDataThatIsNotSquare() {        double[] y = new double[]{1.0, 2.0};        double[][] x = new double[2][];        x[0] = new double[]{1.0, 0};        x[1] = new double[]{0, 1.0};        double[][] omega = new double[3][];        omega[0] = new double[]{1.0, 0};        omega[1] = new double[]{0, 1.0};        omega[2] = new double[]{0, 2.0};        createRegression().newSampleData(y, x, omega);    }    @Override    protected GLSMultipleLinearRegression createRegression() {        GLSMultipleLinearRegression regression = new GLSMultipleLinearRegression();        regression.newSampleData(y, x, omega);        return regression;    }    @Override    protected int getNumberOfRegressors() {        return x[0].length + 1;    }    @Override    protected int getSampleSize() {        return y.length;    }    /**     * test calculateYVariance     */    @Test    public void testYVariance() {        // assumes: y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};        GLSMultipleLinearRegression model = new GLSMultipleLinearRegression();        model.newSampleData(y, x, omega);        TestUtils.assertEquals(model.calculateYVariance(), 3.5, 0);    }        /**     * Verifies that setting X, Y and covariance separately has the same effect as newSample(X,Y,cov).     */    @Test    public void testNewSample2() throws Exception {        double[] y = new double[] {1, 2, 3, 4};         double[][] x = new double[][] {          {19, 22, 33},          {20, 30, 40},          {25, 35, 45},          {27, 37, 47}           };        double[][] covariance = MatrixUtils.createRealIdentityMatrix(4).scalarMultiply(2).getData();        GLSMultipleLinearRegression regression = new GLSMultipleLinearRegression();        regression.newSampleData(y, x, covariance);        RealMatrix combinedX = regression.X.copy();        RealVector combinedY = regression.Y.copy();        RealMatrix combinedCovInv = regression.getOmegaInverse();        regression.newXSampleData(x);        regression.newYSampleData(y);        Assert.assertEquals(combinedX, regression.X);        Assert.assertEquals(combinedY, regression.Y);        Assert.assertEquals(combinedCovInv, regression.getOmegaInverse());    }        /**     * Verifies that GLS with identity covariance matrix gives the same results     * as OLS.     */    @Test    public void testGLSOLSConsistency() throws Exception {              RealMatrix identityCov = MatrixUtils.createRealIdentityMatrix(16);        GLSMultipleLinearRegression glsModel = new GLSMultipleLinearRegression();        OLSMultipleLinearRegression olsModel = new OLSMultipleLinearRegression();        glsModel.newSampleData(longley, 16, 6);        olsModel.newSampleData(longley, 16, 6);        glsModel.newCovarianceData(identityCov.getData());        double[] olsBeta = olsModel.calculateBeta().getData();        double[] glsBeta = glsModel.calculateBeta().getData();        // TODO:  Should have assertRelativelyEquals(double[], double[], eps) in TestUtils        //        Should also add RealVector and RealMatrix versions        for (int i = 0; i < olsBeta.length; i++) {            TestUtils.assertRelativelyEquals(olsBeta[i], glsBeta[i], 10E-7);        }    }        /**     * Generate an error covariance matrix and sample data representing models     * with this error structure. Then verify that GLS estimated coefficients,     * on average, perform better than OLS.     */    @Test    public void testGLSEfficiency() throws Exception {        RandomGenerator rg = new JDKRandomGenerator();        rg.setSeed(200);  // Seed has been selected to generate non-trivial covariance                // Assume model has 16 observations (will use Longley data).  Start by generating        // non-constant variances for the 16 error terms.        final int nObs = 16;        double[] sigma = new double[nObs];        for (int i = 0; i < nObs; i++) {            sigma[i] = 10 * rg.nextDouble();        }                // Now generate 1000 error vectors to use to estimate the covariance matrix        // Columns are draws on N(0, sigma[col])        final int numSeeds = 1000;        RealMatrix errorSeeds = MatrixUtils.createRealMatrix(numSeeds, nObs);        for (int i = 0; i < numSeeds; i++) {            for (int j = 0; j < nObs; j++) {                errorSeeds.setEntry(i, j, rg.nextGaussian() * sigma[j]);            }        }                // Get covariance matrix for columns        RealMatrix cov = (new Covariance(errorSeeds)).getCovarianceMatrix();                  // Create a CorrelatedRandomVectorGenerator to use to generate correlated errors        GaussianRandomGenerator rawGenerator = new GaussianRandomGenerator(rg);        double[] errorMeans = new double[nObs];  // Counting on init to 0 here        CorrelatedRandomVectorGenerator gen = new CorrelatedRandomVectorGenerator(errorMeans, cov,         1.0e-12 * cov.getNorm(), rawGenerator);                // Now start generating models.  Use Longley X matrix on LHS        // and Longley OLS beta vector as "true" beta.  Generate        // Y values by XB + u where u is a CorrelatedRandomVector generated        // from cov.        OLSMultipleLinearRegression ols = new OLSMultipleLinearRegression();        ols.newSampleData(longley, nObs, 6);        final RealVector b = ols.calculateBeta().copy();        final RealMatrix x = ols.X.copy();                // Create a GLS model to reuse        GLSMultipleLinearRegression gls = new GLSMultipleLinearRegression();        gls.newSampleData(longley, nObs, 6);        gls.newCovarianceData(cov.getData());                // Create aggregators for stats measuring model performance        DescriptiveStatistics olsBetaStats = new DescriptiveStatistics();        DescriptiveStatistics glsBetaStats = new DescriptiveStatistics();                // Generate Y vectors for 10000 models, estimate GLS and OLS and        // Verify that OLS estimates are better        final int nModels = 10000;        for (int i = 0; i < nModels; i++) {                        // Generate y = xb + u with u cov            RealVector u = MatrixUtils.createRealVector(gen.nextVector());            double[] y = u.add(x.operate(b)).getData();                        // Estimate OLS parameters            ols.newYSampleData(y);            RealVector olsBeta = ols.calculateBeta();                        // Estimate GLS parameters            gls.newYSampleData(y);            RealVector glsBeta = gls.calculateBeta();                        // Record deviations from "true" beta            double dist = olsBeta.getDistance(b);            olsBetaStats.addValue(dist * dist);            dist = glsBeta.getDistance(b);            glsBetaStats.addValue(dist * dist);                    }                // Verify that GLS is on average more efficient, lower variance        assert(olsBetaStats.getMean() > 1.5 * glsBetaStats.getMean());        assert(olsBetaStats.getStandardDeviation() > glsBetaStats.getStandardDeviation());      }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.correlation;import org.apache.commons.math.TestUtils;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.linear.RealMatrix;import org.junit.Assert;import org.junit.Test;/** * Test cases for Spearman's rank correlation * * @since 2.0 * @version $Id$ */public class SpearmansRankCorrelationTest extends PearsonsCorrelationTest {    /**     * Test Longley dataset against R.     */    @Override    @Test    public void testLongly() throws Exception {        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);        RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();        double[] rData = new double[] {                1, 0.982352941176471, 0.985294117647059, 0.564705882352941, 0.2264705882352941, 0.976470588235294,                0.976470588235294, 0.982352941176471, 1, 0.997058823529412, 0.664705882352941, 0.2205882352941176,                0.997058823529412, 0.997058823529412, 0.985294117647059, 0.997058823529412, 1, 0.638235294117647,                0.2235294117647059, 0.9941176470588236, 0.9941176470588236, 0.564705882352941, 0.664705882352941,                0.638235294117647, 1, -0.3411764705882353, 0.685294117647059, 0.685294117647059, 0.2264705882352941,                0.2205882352941176, 0.2235294117647059, -0.3411764705882353, 1, 0.2264705882352941, 0.2264705882352941,                0.976470588235294, 0.997058823529412, 0.9941176470588236, 0.685294117647059, 0.2264705882352941, 1, 1,                0.976470588235294, 0.997058823529412, 0.9941176470588236, 0.685294117647059, 0.2264705882352941, 1, 1        };        TestUtils.assertEquals("Spearman's correlation matrix", createRealMatrix(rData, 7, 7), correlationMatrix, 10E-15);    }    /**     * Test R swiss fertility dataset.     */    @Test    public void testSwiss() throws Exception {        RealMatrix matrix = createRealMatrix(swissData, 47, 5);        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);        RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();        double[] rData = new double[] {                1, 0.2426642769364176, -0.660902996352354, -0.443257690360988, 0.4136455623012432,                0.2426642769364176, 1, -0.598859938748963, -0.650463814145816, 0.2886878090882852,               -0.660902996352354, -0.598859938748963, 1, 0.674603831406147, -0.4750575257171745,               -0.443257690360988, -0.650463814145816, 0.674603831406147, 1, -0.1444163088302244,                0.4136455623012432, 0.2886878090882852, -0.4750575257171745, -0.1444163088302244, 1        };        TestUtils.assertEquals("Spearman's correlation matrix", createRealMatrix(rData, 5, 5), correlationMatrix, 10E-15);    }    /**     * Constant column     */    @Override    @Test    public void testConstant() {        double[] noVariance = new double[] {1, 1, 1, 1};        double[] values = new double[] {1, 2, 3, 4};        Assert.assertTrue(Double.isNaN(new SpearmansCorrelation().correlation(noVariance, values)));    }    /**     * Insufficient data     */    @Override    @Test    public void testInsufficientData() {        double[] one = new double[] {1};        double[] two = new double[] {2};        try {            new SpearmansCorrelation().correlation(one, two);            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }        RealMatrix matrix = new BlockRealMatrix(new double[][] {{0},{1}});        try {            new SpearmansCorrelation(matrix);            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }    }    @Override    @Test    public void testConsistency() {        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);        double[][] data = matrix.getData();        double[] x = matrix.getColumn(0);        double[] y = matrix.getColumn(1);        Assert.assertEquals(new SpearmansCorrelation().correlation(x, y),                corrInstance.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE);        TestUtils.assertEquals("Correlation matrix", corrInstance.getCorrelationMatrix(),                new SpearmansCorrelation().computeCorrelationMatrix(data), Double.MIN_VALUE);    }    // Not relevant here    @Override    @Test    public void testStdErrorConsistency() throws Exception {}    @Override    @Test    public void testCovarianceConsistency() throws Exception {}}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.correlation;import org.apache.commons.math.TestUtils;import org.apache.commons.math.linear.Array2DRowRealMatrix;import org.apache.commons.math.linear.RealMatrix;import org.junit.Test;public class StorelessCovarianceTest {    protected final double[] longleyData = new double[] {            60323,83.0,234289,2356,1590,107608,1947,            61122,88.5,259426,2325,1456,108632,1948,            60171,88.2,258054,3682,1616,109773,1949,            61187,89.5,284599,3351,1650,110929,1950,            63221,96.2,328975,2099,3099,112075,1951,            63639,98.1,346999,1932,3594,113270,1952,            64989,99.0,365385,1870,3547,115094,1953,            63761,100.0,363112,3578,3350,116219,1954,            66019,101.2,397469,2904,3048,117388,1955,            67857,104.6,419180,2822,2857,118734,1956,            68169,108.4,442769,2936,2798,120445,1957,            66513,110.8,444546,4681,2637,121950,1958,            68655,112.6,482704,3813,2552,123366,1959,            69564,114.2,502601,3931,2514,125368,1960,            69331,115.7,518173,4806,2572,127852,1961,            70551,116.9,554894,4007,2827,130081,1962        };    protected final double[] swissData = new double[] {            80.2,17.0,15,12,9.96,            83.1,45.1,6,9,84.84,            92.5,39.7,5,5,93.40,            85.8,36.5,12,7,33.77,            76.9,43.5,17,15,5.16,            76.1,35.3,9,7,90.57,            83.8,70.2,16,7,92.85,            92.4,67.8,14,8,97.16,            82.4,53.3,12,7,97.67,            82.9,45.2,16,13,91.38,            87.1,64.5,14,6,98.61,            64.1,62.0,21,12,8.52,            66.9,67.5,14,7,2.27,            68.9,60.7,19,12,4.43,            61.7,69.3,22,5,2.82,            68.3,72.6,18,2,24.20,            71.7,34.0,17,8,3.30,            55.7,19.4,26,28,12.11,            54.3,15.2,31,20,2.15,            65.1,73.0,19,9,2.84,            65.5,59.8,22,10,5.23,            65.0,55.1,14,3,4.52,            56.6,50.9,22,12,15.14,            57.4,54.1,20,6,4.20,            72.5,71.2,12,1,2.40,            74.2,58.1,14,8,5.23,            72.0,63.5,6,3,2.56,            60.5,60.8,16,10,7.72,            58.3,26.8,25,19,18.46,            65.4,49.5,15,8,6.10,            75.5,85.9,3,2,99.71,            69.3,84.9,7,6,99.68,            77.3,89.7,5,2,100.00,            70.5,78.2,12,6,98.96,            79.4,64.9,7,3,98.22,            65.0,75.9,9,9,99.06,            92.2,84.6,3,3,99.46,            79.3,63.1,13,13,96.83,            70.4,38.4,26,12,5.62,            65.7,7.7,29,11,13.79,            72.7,16.7,22,13,11.22,            64.4,17.6,35,32,16.92,            77.6,37.6,15,7,4.97,            67.6,18.7,25,7,8.65,            35.0,1.2,37,53,42.34,            44.7,46.6,16,29,50.43,            42.8,27.7,22,29,58.33        };    protected final double[][] longleyDataSimple = {        {60323, 83.0},        {61122,88.5},        {60171, 88.2},        {61187, 89.5},        {63221, 96.2},        {63639, 98.1},        {64989, 99.0},        {63761, 100.0},        {66019, 101.2},        {67857, 104.6},        {68169, 108.4},        {66513, 110.8},        {68655, 112.6},        {69564, 114.2},        {69331, 115.7},        {70551, 116.9}    };    @Test    public void testLonglySimpleVar(){        double rCov = 12333921.73333333246;        StorelessBivariateCovariance cov = new StorelessBivariateCovariance();        for(int i=0;i<longleyDataSimple.length;i++){            cov.increment(longleyDataSimple[i][0],longleyDataSimple[i][0]);        }        TestUtils.assertEquals("simple covariance test", rCov, cov.getResult(), 10E-7);    }    @Test    public void testLonglySimpleCov(){        double rCov = 36796.660000;        StorelessBivariateCovariance cov = new StorelessBivariateCovariance();        for(int i=0;i<longleyDataSimple.length;i++){            cov.increment(longleyDataSimple[i][0], longleyDataSimple[i][1]);        }        TestUtils.assertEquals("simple covariance test", rCov, cov.getResult(), 10E-7);    }    /**     * Test Longley dataset against R.     * Data Source: J. Longley (1967) "An Appraisal of Least Squares     * Programs for the Electronic Computer from the Point of View of the User"     * Journal of the American Statistical Association, vol. 62. September,     * pp. 819-841.     *     * Data are from NIST:     * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat     */    @Test    public void testLonglyByRow() {        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        double[] rData = new double[] {         12333921.73333333246, 3.679666000000000e+04, 343330206.333333313,         1649102.666666666744, 1117681.066666666651, 23461965.733333334, 16240.93333333333248,         36796.66000000000, 1.164576250000000e+02, 1063604.115416667,         6258.666250000000, 3490.253750000000, 73503.000000000, 50.92333333333334,         343330206.33333331347, 1.063604115416667e+06, 9879353659.329166412,         56124369.854166664183, 30880428.345833335072, 685240944.600000024, 470977.90000000002328,         1649102.66666666674, 6.258666250000000e+03, 56124369.854166664,         873223.429166666698, -115378.762499999997, 4462741.533333333, 2973.03333333333330,         1117681.06666666665, 3.490253750000000e+03, 30880428.345833335,         -115378.762499999997, 484304.095833333326, 1764098.133333333, 1382.43333333333339,         23461965.73333333433, 7.350300000000000e+04, 685240944.600000024,         4462741.533333333209, 1764098.133333333302, 48387348.933333330, 32917.40000000000146,         16240.93333333333, 5.092333333333334e+01, 470977.900000000,         2973.033333333333, 1382.433333333333, 32917.40000000, 22.66666666666667        };        StorelessCovariance covMatrix = new StorelessCovariance(7, 7);        for(int i=0;i<matrix.getRowDimension();i++){            covMatrix.incrementRow(matrix.getRow(i));        }        RealMatrix covarianceMatrix = covMatrix.getCovarianceMatrix();        TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 7, 7), covarianceMatrix, 10E-7);    }    /**     * Test R Swiss fertility dataset against R.     * Data Source: R datasets package     */    @Test    public void testSwissFertilityByRow() {         RealMatrix matrix = createRealMatrix(swissData, 47, 5);         double[] rData = new double[] {           156.0424976873265, 100.1691489361702, -64.36692876965772, -79.7295097132285, 241.5632030527289,           100.169148936170251, 515.7994172062905, -124.39283071230344, -139.6574005550416, 379.9043755781684,           -64.3669287696577, -124.3928307123034, 63.64662349676226, 53.5758556891767, -190.5606105457909,           -79.7295097132285, -139.6574005550416, 53.57585568917669, 92.4560592044403, -61.6988297872340,            241.5632030527289, 379.9043755781684, -190.56061054579092, -61.6988297872340, 1739.2945371877890         };        StorelessCovariance covMatrix = new StorelessCovariance(5, 5);        for(int i=0;i<matrix.getRowDimension();i++){            covMatrix.incrementRow(matrix.getRow(i));        }        RealMatrix covarianceMatrix = covMatrix.getCovarianceMatrix();        TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 5, 5), covarianceMatrix, 10E-13);    }    /**     * Test Longley dataset against R.     * Data Source: J. Longley (1967) "An Appraisal of Least Squares     * Programs for the Electronic Computer from the Point of View of the User"     * Journal of the American Statistical Association, vol. 62. September,     * pp. 819-841.     *     * Data are from NIST:     * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat     */    @Test    public void testLonglyByEntry() {        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        double[] rData = new double[] {         12333921.73333333246, 3.679666000000000e+04, 343330206.333333313,         1649102.666666666744, 1117681.066666666651, 23461965.733333334, 16240.93333333333248,         36796.66000000000, 1.164576250000000e+02, 1063604.115416667,         6258.666250000000, 3490.253750000000, 73503.000000000, 50.92333333333334,         343330206.33333331347, 1.063604115416667e+06, 9879353659.329166412,         56124369.854166664183, 30880428.345833335072, 685240944.600000024, 470977.90000000002328,         1649102.66666666674, 6.258666250000000e+03, 56124369.854166664,         873223.429166666698, -115378.762499999997, 4462741.533333333, 2973.03333333333330,         1117681.06666666665, 3.490253750000000e+03, 30880428.345833335,         -115378.762499999997, 484304.095833333326, 1764098.133333333, 1382.43333333333339,         23461965.73333333433, 7.350300000000000e+04, 685240944.600000024,         4462741.533333333209, 1764098.133333333302, 48387348.933333330, 32917.40000000000146,         16240.93333333333, 5.092333333333334e+01, 470977.900000000,         2973.033333333333, 1382.433333333333, 32917.40000000, 22.66666666666667        };        int row = matrix.getRowDimension();        int col = matrix.getColumnDimension();        double x = 0.0;        double y = 0.0;        StorelessCovariance covMatrix = new StorelessCovariance(7, 7);        for(int i=0;i<row;i++){            for(int j=0;j<col;j++){                x = matrix.getEntry(i, j);                for(int k=0;k<col;k++){                    y = matrix.getEntry(i, k);                    covMatrix.incrementCovariance(j, k, x, y);                }            }        }        RealMatrix covarianceMatrix = covMatrix.getCovarianceMatrix();        TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 7, 7), covarianceMatrix, 10E-7);    }    /**     * Test R Swiss fertility dataset against R.     * Data Source: R datasets package     */    @Test    public void testSwissFertilityByEntry() {         RealMatrix matrix = createRealMatrix(swissData, 47, 5);         double[] rData = new double[] {           156.0424976873265, 100.1691489361702, -64.36692876965772, -79.7295097132285, 241.5632030527289,           100.169148936170251, 515.7994172062905, -124.39283071230344, -139.6574005550416, 379.9043755781684,           -64.3669287696577, -124.3928307123034, 63.64662349676226, 53.5758556891767, -190.5606105457909,           -79.7295097132285, -139.6574005550416, 53.57585568917669, 92.4560592044403, -61.6988297872340,            241.5632030527289, 379.9043755781684, -190.56061054579092, -61.6988297872340, 1739.2945371877890         };        int row = matrix.getRowDimension();        int col = matrix.getColumnDimension();        double x = 0.0;        double y = 0.0;        StorelessCovariance covMatrix = new StorelessCovariance(5, 5);        for(int i=0;i<row;i++){            for(int j=0;j<col;j++){                x = matrix.getEntry(i, j);                for(int k=0;k<col;k++){                    y = matrix.getEntry(i, k);                    covMatrix.incrementCovariance(j, k, x, y);                }            }        }        RealMatrix covarianceMatrix = covMatrix.getCovarianceMatrix();        TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 5, 5), covarianceMatrix, 10E-13);    }    protected RealMatrix createRealMatrix(double[] data, int nRows, int nCols) {        double[][] matrixData = new double[nRows][nCols];        int ptr = 0;        for (int i = 0; i < nRows; i++) {            System.arraycopy(data, ptr, matrixData[i], 0, nCols);            ptr += nCols;        }        return new Array2DRowRealMatrix(matrixData);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.correlation;import org.apache.commons.math.TestUtils;import org.apache.commons.math.distribution.TDistribution;import org.apache.commons.math.distribution.TDistributionImpl;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class PearsonsCorrelationTest {    protected final double[] longleyData = new double[] {            60323,83.0,234289,2356,1590,107608,1947,            61122,88.5,259426,2325,1456,108632,1948,            60171,88.2,258054,3682,1616,109773,1949,            61187,89.5,284599,3351,1650,110929,1950,            63221,96.2,328975,2099,3099,112075,1951,            63639,98.1,346999,1932,3594,113270,1952,            64989,99.0,365385,1870,3547,115094,1953,            63761,100.0,363112,3578,3350,116219,1954,            66019,101.2,397469,2904,3048,117388,1955,            67857,104.6,419180,2822,2857,118734,1956,            68169,108.4,442769,2936,2798,120445,1957,            66513,110.8,444546,4681,2637,121950,1958,            68655,112.6,482704,3813,2552,123366,1959,            69564,114.2,502601,3931,2514,125368,1960,            69331,115.7,518173,4806,2572,127852,1961,            70551,116.9,554894,4007,2827,130081,1962        };    protected final double[] swissData = new double[] {            80.2,17.0,15,12,9.96,            83.1,45.1,6,9,84.84,            92.5,39.7,5,5,93.40,            85.8,36.5,12,7,33.77,            76.9,43.5,17,15,5.16,            76.1,35.3,9,7,90.57,            83.8,70.2,16,7,92.85,            92.4,67.8,14,8,97.16,            82.4,53.3,12,7,97.67,            82.9,45.2,16,13,91.38,            87.1,64.5,14,6,98.61,            64.1,62.0,21,12,8.52,            66.9,67.5,14,7,2.27,            68.9,60.7,19,12,4.43,            61.7,69.3,22,5,2.82,            68.3,72.6,18,2,24.20,            71.7,34.0,17,8,3.30,            55.7,19.4,26,28,12.11,            54.3,15.2,31,20,2.15,            65.1,73.0,19,9,2.84,            65.5,59.8,22,10,5.23,            65.0,55.1,14,3,4.52,            56.6,50.9,22,12,15.14,            57.4,54.1,20,6,4.20,            72.5,71.2,12,1,2.40,            74.2,58.1,14,8,5.23,            72.0,63.5,6,3,2.56,            60.5,60.8,16,10,7.72,            58.3,26.8,25,19,18.46,            65.4,49.5,15,8,6.10,            75.5,85.9,3,2,99.71,            69.3,84.9,7,6,99.68,            77.3,89.7,5,2,100.00,            70.5,78.2,12,6,98.96,            79.4,64.9,7,3,98.22,            65.0,75.9,9,9,99.06,            92.2,84.6,3,3,99.46,            79.3,63.1,13,13,96.83,            70.4,38.4,26,12,5.62,            65.7,7.7,29,11,13.79,            72.7,16.7,22,13,11.22,            64.4,17.6,35,32,16.92,            77.6,37.6,15,7,4.97,            67.6,18.7,25,7,8.65,            35.0,1.2,37,53,42.34,            44.7,46.6,16,29,50.43,            42.8,27.7,22,29,58.33        };    /**     * Test Longley dataset against R.     */    @Test    public void testLongly() throws Exception {        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);        RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();        double[] rData = new double[] {                1.000000000000000, 0.9708985250610560, 0.9835516111796693, 0.5024980838759942,                0.4573073999764817, 0.960390571594376, 0.9713294591921188,                0.970898525061056, 1.0000000000000000, 0.9915891780247822, 0.6206333925590966,                0.4647441876006747, 0.979163432977498, 0.9911491900672053,                0.983551611179669, 0.9915891780247822, 1.0000000000000000, 0.6042609398895580,                0.4464367918926265, 0.991090069458478, 0.9952734837647849,                0.502498083875994, 0.6206333925590966, 0.6042609398895580, 1.0000000000000000,                -0.1774206295018783, 0.686551516365312, 0.6682566045621746,                0.457307399976482, 0.4647441876006747, 0.4464367918926265, -0.1774206295018783,                1.0000000000000000, 0.364416267189032, 0.4172451498349454,                0.960390571594376, 0.9791634329774981, 0.9910900694584777, 0.6865515163653120,                0.3644162671890320, 1.000000000000000, 0.9939528462329257,                0.971329459192119, 0.9911491900672053, 0.9952734837647849, 0.6682566045621746,                0.4172451498349454, 0.993952846232926, 1.0000000000000000        };        TestUtils.assertEquals("correlation matrix", createRealMatrix(rData, 7, 7), correlationMatrix, 10E-15);        double[] rPvalues = new double[] {                4.38904690369668e-10,                8.36353208910623e-12, 7.8159700933611e-14,                0.0472894097790304, 0.01030636128354301, 0.01316878049026582,                0.0749178049642416, 0.06971758330341182, 0.0830166169296545, 0.510948586323452,                3.693245043123738e-09, 4.327782576751815e-11, 1.167954621905665e-13, 0.00331028281967516, 0.1652293725106684,                3.95834476307755e-10, 1.114663916723657e-13, 1.332267629550188e-15, 0.00466039138541463, 0.1078477071581498, 7.771561172376096e-15        };        RealMatrix rPMatrix = createLowerTriangularRealMatrix(rPvalues, 7);        fillUpper(rPMatrix, 0d);        TestUtils.assertEquals("correlation p values", rPMatrix, corrInstance.getCorrelationPValues(), 10E-15);    }    /**     * Test R Swiss fertility dataset against R.     */    @Test    public void testSwissFertility() throws Exception {         RealMatrix matrix = createRealMatrix(swissData, 47, 5);         PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);         RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();         double[] rData = new double[] {               1.0000000000000000, 0.3530791836199747, -0.6458827064572875, -0.6637888570350691,  0.4636847006517939,                 0.3530791836199747, 1.0000000000000000,-0.6865422086171366, -0.6395225189483201, 0.4010950530487398,                -0.6458827064572875, -0.6865422086171366, 1.0000000000000000, 0.6984152962884830, -0.5727418060641666,                -0.6637888570350691, -0.6395225189483201, 0.6984152962884830, 1.0000000000000000, -0.1538589170909148,                 0.4636847006517939, 0.4010950530487398, -0.5727418060641666, -0.1538589170909148, 1.0000000000000000         };         TestUtils.assertEquals("correlation matrix", createRealMatrix(rData, 5, 5), correlationMatrix, 10E-15);         double[] rPvalues = new double[] {                 0.01491720061472623,                 9.45043734069043e-07, 9.95151527133974e-08,                 3.658616965962355e-07, 1.304590105694471e-06, 4.811397236181847e-08,                 0.001028523190118147, 0.005204433539191644, 2.588307925380906e-05, 0.301807756132683         };         RealMatrix rPMatrix = createLowerTriangularRealMatrix(rPvalues, 5);         fillUpper(rPMatrix, 0d);         TestUtils.assertEquals("correlation p values", rPMatrix, corrInstance.getCorrelationPValues(), 10E-15);    }        /**     * Test p-value near 0. JIRA: MATH-371     */    @Test    public void testPValueNearZero() throws Exception {        /*         * Create a dataset that has r -> 1, p -> 0 as dimension increases.         * Prior to the fix for MATH-371, p vanished for dimension >= 14.         * Post fix, p-values diminish smoothly, vanishing at dimension = 127.         * Tested value is ~1E-303.         */        int dimension = 120;         double[][] data = new double[dimension][2];        for (int i = 0; i < dimension; i++) {            data[i][0] = i;            data[i][1] = i + 1/((double)i + 1);        }        PearsonsCorrelation corrInstance = new PearsonsCorrelation(data);        Assert.assertTrue(corrInstance.getCorrelationPValues().getEntry(0, 1) > 0);    }        /**     * Constant column     */    @Test    public void testConstant() {        double[] noVariance = new double[] {1, 1, 1, 1};        double[] values = new double[] {1, 2, 3, 4};        Assert.assertTrue(Double.isNaN(new PearsonsCorrelation().correlation(noVariance, values)));    }    /**     * Insufficient data     */    @Test    public void testInsufficientData() {        double[] one = new double[] {1};        double[] two = new double[] {2};        try {            new PearsonsCorrelation().correlation(one, two);            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }        RealMatrix matrix = new BlockRealMatrix(new double[][] {{0},{1}});        try {            new PearsonsCorrelation(matrix);            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }    }    /**     * Verify that direct t-tests using standard error estimates are consistent     * with reported p-values     */    @Test    public void testStdErrorConsistency() throws Exception {        TDistribution tDistribution = new TDistributionImpl(45);        RealMatrix matrix = createRealMatrix(swissData, 47, 5);        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);        RealMatrix rValues = corrInstance.getCorrelationMatrix();        RealMatrix pValues = corrInstance.getCorrelationPValues();        RealMatrix stdErrors = corrInstance.getCorrelationStandardErrors();        for (int i = 0; i < 5; i++) {            for (int j = 0; j < i; j++) {                double t = FastMath.abs(rValues.getEntry(i, j)) / stdErrors.getEntry(i, j);                double p = 2 * (1 - tDistribution.cumulativeProbability(t));                Assert.assertEquals(p, pValues.getEntry(i, j), 10E-15);            }        }    }    /**     * Verify that creating correlation from covariance gives same results as     * direct computation from the original matrix     */    @Test    public void testCovarianceConsistency() throws Exception {        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);        Covariance covInstance = new Covariance(matrix);        PearsonsCorrelation corrFromCovInstance = new PearsonsCorrelation(covInstance);        TestUtils.assertEquals("correlation values", corrInstance.getCorrelationMatrix(),                corrFromCovInstance.getCorrelationMatrix(), 10E-15);        TestUtils.assertEquals("p values", corrInstance.getCorrelationPValues(),                corrFromCovInstance.getCorrelationPValues(), 10E-15);        TestUtils.assertEquals("standard errors", corrInstance.getCorrelationStandardErrors(),                corrFromCovInstance.getCorrelationStandardErrors(), 10E-15);        PearsonsCorrelation corrFromCovInstance2 =            new PearsonsCorrelation(covInstance.getCovarianceMatrix(), 16);        TestUtils.assertEquals("correlation values", corrInstance.getCorrelationMatrix(),                corrFromCovInstance2.getCorrelationMatrix(), 10E-15);        TestUtils.assertEquals("p values", corrInstance.getCorrelationPValues(),                corrFromCovInstance2.getCorrelationPValues(), 10E-15);        TestUtils.assertEquals("standard errors", corrInstance.getCorrelationStandardErrors(),                corrFromCovInstance2.getCorrelationStandardErrors(), 10E-15);    }    @Test    public void testConsistency() {        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);        double[][] data = matrix.getData();        double[] x = matrix.getColumn(0);        double[] y = matrix.getColumn(1);        Assert.assertEquals(new PearsonsCorrelation().correlation(x, y),                corrInstance.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE);        TestUtils.assertEquals("Correlation matrix", corrInstance.getCorrelationMatrix(),                new PearsonsCorrelation().computeCorrelationMatrix(data), Double.MIN_VALUE);    }    protected RealMatrix createRealMatrix(double[] data, int nRows, int nCols) {        double[][] matrixData = new double[nRows][nCols];        int ptr = 0;        for (int i = 0; i < nRows; i++) {            System.arraycopy(data, ptr, matrixData[i], 0, nCols);            ptr += nCols;        }        return new BlockRealMatrix(matrixData);    }    protected RealMatrix createLowerTriangularRealMatrix(double[] data, int dimension) {        int ptr = 0;        RealMatrix result = new BlockRealMatrix(dimension, dimension);        for (int i = 1; i < dimension; i++) {            for (int j = 0; j < i; j++) {                result.setEntry(i, j, data[ptr]);                ptr++;            }        }        return result;    }    protected void fillUpper(RealMatrix matrix, double diagonalValue) {        int dimension = matrix.getColumnDimension();        for (int i = 0; i < dimension; i++) {            matrix.setEntry(i, i, diagonalValue);            for (int j = i+1; j < dimension; j++) {                matrix.setEntry(i, j, matrix.getEntry(j, i));            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.correlation;import org.apache.commons.math.TestUtils;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.Array2DRowRealMatrix;import org.apache.commons.math.stat.descriptive.moment.Variance;import org.junit.Assert;import org.junit.Test;public class CovarianceTest {    protected final double[] longleyData = new double[] {            60323,83.0,234289,2356,1590,107608,1947,            61122,88.5,259426,2325,1456,108632,1948,            60171,88.2,258054,3682,1616,109773,1949,            61187,89.5,284599,3351,1650,110929,1950,            63221,96.2,328975,2099,3099,112075,1951,            63639,98.1,346999,1932,3594,113270,1952,            64989,99.0,365385,1870,3547,115094,1953,            63761,100.0,363112,3578,3350,116219,1954,            66019,101.2,397469,2904,3048,117388,1955,            67857,104.6,419180,2822,2857,118734,1956,            68169,108.4,442769,2936,2798,120445,1957,            66513,110.8,444546,4681,2637,121950,1958,            68655,112.6,482704,3813,2552,123366,1959,            69564,114.2,502601,3931,2514,125368,1960,            69331,115.7,518173,4806,2572,127852,1961,            70551,116.9,554894,4007,2827,130081,1962        };    protected final double[] swissData = new double[] {            80.2,17.0,15,12,9.96,            83.1,45.1,6,9,84.84,            92.5,39.7,5,5,93.40,            85.8,36.5,12,7,33.77,            76.9,43.5,17,15,5.16,            76.1,35.3,9,7,90.57,            83.8,70.2,16,7,92.85,            92.4,67.8,14,8,97.16,            82.4,53.3,12,7,97.67,            82.9,45.2,16,13,91.38,            87.1,64.5,14,6,98.61,            64.1,62.0,21,12,8.52,            66.9,67.5,14,7,2.27,            68.9,60.7,19,12,4.43,            61.7,69.3,22,5,2.82,            68.3,72.6,18,2,24.20,            71.7,34.0,17,8,3.30,            55.7,19.4,26,28,12.11,            54.3,15.2,31,20,2.15,            65.1,73.0,19,9,2.84,            65.5,59.8,22,10,5.23,            65.0,55.1,14,3,4.52,            56.6,50.9,22,12,15.14,            57.4,54.1,20,6,4.20,            72.5,71.2,12,1,2.40,            74.2,58.1,14,8,5.23,            72.0,63.5,6,3,2.56,            60.5,60.8,16,10,7.72,            58.3,26.8,25,19,18.46,            65.4,49.5,15,8,6.10,            75.5,85.9,3,2,99.71,            69.3,84.9,7,6,99.68,            77.3,89.7,5,2,100.00,            70.5,78.2,12,6,98.96,            79.4,64.9,7,3,98.22,            65.0,75.9,9,9,99.06,            92.2,84.6,3,3,99.46,            79.3,63.1,13,13,96.83,            70.4,38.4,26,12,5.62,            65.7,7.7,29,11,13.79,            72.7,16.7,22,13,11.22,            64.4,17.6,35,32,16.92,            77.6,37.6,15,7,4.97,            67.6,18.7,25,7,8.65,            35.0,1.2,37,53,42.34,            44.7,46.6,16,29,50.43,            42.8,27.7,22,29,58.33        };    /**     * Test Longley dataset against R.     * Data Source: J. Longley (1967) "An Appraisal of Least Squares     * Programs for the Electronic Computer from the Point of View of the User"     * Journal of the American Statistical Association, vol. 62. September,     * pp. 819-841.     *     * Data are from NIST:     * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat     */    @Test    public void testLongly() {        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();        double[] rData = new double[] {         12333921.73333333246, 3.679666000000000e+04, 343330206.333333313,         1649102.666666666744, 1117681.066666666651, 23461965.733333334, 16240.93333333333248,         36796.66000000000, 1.164576250000000e+02, 1063604.115416667,         6258.666250000000, 3490.253750000000, 73503.000000000, 50.92333333333334,         343330206.33333331347, 1.063604115416667e+06, 9879353659.329166412,         56124369.854166664183, 30880428.345833335072, 685240944.600000024, 470977.90000000002328,         1649102.66666666674, 6.258666250000000e+03, 56124369.854166664,         873223.429166666698, -115378.762499999997, 4462741.533333333, 2973.03333333333330,         1117681.06666666665, 3.490253750000000e+03, 30880428.345833335,         -115378.762499999997, 484304.095833333326, 1764098.133333333, 1382.43333333333339,         23461965.73333333433, 7.350300000000000e+04, 685240944.600000024,         4462741.533333333209, 1764098.133333333302, 48387348.933333330, 32917.40000000000146,         16240.93333333333, 5.092333333333334e+01, 470977.900000000,         2973.033333333333, 1382.433333333333, 32917.40000000, 22.66666666666667        };        TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 7, 7), covarianceMatrix, 10E-9);    }    /**     * Test R Swiss fertility dataset against R.     * Data Source: R datasets package     */    @Test    public void testSwissFertility() {         RealMatrix matrix = createRealMatrix(swissData, 47, 5);         RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();         double[] rData = new double[] {           156.0424976873265, 100.1691489361702, -64.36692876965772, -79.7295097132285, 241.5632030527289,           100.169148936170251, 515.7994172062905, -124.39283071230344, -139.6574005550416, 379.9043755781684,           -64.3669287696577, -124.3928307123034, 63.64662349676226, 53.5758556891767, -190.5606105457909,           -79.7295097132285, -139.6574005550416, 53.57585568917669, 92.4560592044403, -61.6988297872340,            241.5632030527289, 379.9043755781684, -190.56061054579092, -61.6988297872340, 1739.2945371877890         };         TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 5, 5), covarianceMatrix, 10E-13);    }    /**     * Constant column     */    @Test    public void testConstant() {        double[] noVariance = new double[] {1, 1, 1, 1};        double[] values = new double[] {1, 2, 3, 4};        Assert.assertEquals(0d, new Covariance().covariance(noVariance, values, true), Double.MIN_VALUE);        Assert.assertEquals(0d, new Covariance().covariance(noVariance, noVariance, true), Double.MIN_VALUE);    }    /**     * Insufficient data     */    @Test    public void testInsufficientData() {        double[] one = new double[] {1};        double[] two = new double[] {2};        try {            new Covariance().covariance(one, two, false);            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }        RealMatrix matrix = new Array2DRowRealMatrix(new double[][] {{0},{1}});        try {            new Covariance(matrix);            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }    }    /**     * Verify that diagonal entries are consistent with Variance computation and matrix matches     * column-by-column covariances     */    @Test    public void testConsistency() {        final RealMatrix matrix = createRealMatrix(swissData, 47, 5);        final RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();        // Variances on the diagonal        Variance variance = new Variance();        for (int i = 0; i < 5; i++) {            Assert.assertEquals(variance.evaluate(matrix.getColumn(i)), covarianceMatrix.getEntry(i,i), 10E-14);        }        // Symmetry, column-consistency        Assert.assertEquals(covarianceMatrix.getEntry(2, 3),                new Covariance().covariance(matrix.getColumn(2), matrix.getColumn(3), true), 10E-14);        Assert.assertEquals(covarianceMatrix.getEntry(2, 3), covarianceMatrix.getEntry(3, 2), Double.MIN_VALUE);        // All columns same -> all entries = column variance        RealMatrix repeatedColumns = new Array2DRowRealMatrix(47, 3);        for (int i = 0; i < 3; i++) {            repeatedColumns.setColumnMatrix(i, matrix.getColumnMatrix(0));        }        RealMatrix repeatedCovarianceMatrix = new Covariance(repeatedColumns).getCovarianceMatrix();        double columnVariance = variance.evaluate(matrix.getColumn(0));        for (int i = 0; i < 3; i++) {            for (int j = 0; j < 3; j++) {                Assert.assertEquals(columnVariance, repeatedCovarianceMatrix.getEntry(i, j), 10E-14);            }        }        // Check bias-correction defaults        double[][] data = matrix.getData();        TestUtils.assertEquals("Covariances",                covarianceMatrix, new Covariance().computeCovarianceMatrix(data),Double.MIN_VALUE);        TestUtils.assertEquals("Covariances",                covarianceMatrix, new Covariance().computeCovarianceMatrix(data, true),Double.MIN_VALUE);        double[] x = data[0];        double[] y = data[1];        Assert.assertEquals(new Covariance().covariance(x, y),                new Covariance().covariance(x, y, true), Double.MIN_VALUE);    }    protected RealMatrix createRealMatrix(double[] data, int nRows, int nCols) {        double[][] matrixData = new double[nRows][nCols];        int ptr = 0;        for (int i = 0; i < nRows; i++) {            System.arraycopy(data, ptr, matrixData[i], 0, nCols);            ptr += nCols;        }        return new Array2DRowRealMatrix(matrixData);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.data;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.net.URL;import java.util.HashMap;import java.util.Map;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;import org.apache.commons.math.stat.descriptive.SummaryStatistics;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;/** * @version $Id$ */public abstract class CertifiedDataAbstractTest {    private DescriptiveStatistics descriptives;    private SummaryStatistics summaries;    private Map<String, Double> certifiedValues;    @Before    public void setUp() throws IOException {        descriptives = new DescriptiveStatistics();        summaries = new SummaryStatistics();        certifiedValues = new HashMap<String, Double>();        loadData();    }    private void loadData() throws IOException {        BufferedReader in = null;        try {            URL resourceURL = getClass().getClassLoader().getResource(getResourceName());            in = new BufferedReader(new InputStreamReader(resourceURL.openStream()));            String line = in.readLine();            while (line != null) {                /* this call to StringUtils did little for the                 * following conditional structure                 */                line = line.trim();                // not empty line or comment                if (!("".equals(line) || line.startsWith("#"))) {                    int n = line.indexOf('=');                    if (n == -1) {                        // data value                        double value = Double.parseDouble(line);                        descriptives.addValue(value);                        summaries.addValue(value);                    } else {                        // certified value                        String name = line.substring(0, n).trim();                        String valueString = line.substring(n + 1).trim();                        Double value = Double.valueOf(valueString);                        certifiedValues.put(name, value);                    }                }                line = in.readLine();            }        } finally {            if (in != null) {                in.close();            }        }    }    protected abstract String getResourceName();    protected double getMaximumAbsoluteError() {        return 1.0e-5;    }    @After    public void tearDown() throws Exception {        descriptives.clear();        descriptives = null;        summaries.clear();        summaries = null;        certifiedValues.clear();        certifiedValues = null;    }    @Test    public void testCertifiedValues() {        for (String name : certifiedValues.keySet()) {            Double expectedValue = certifiedValues.get(name);            Double summariesValue = getProperty(summaries, name);            if (summariesValue != null) {                TestUtils.assertEquals("summary value for " + name + " is incorrect.",                                       summariesValue.doubleValue(), expectedValue.doubleValue(),                                       getMaximumAbsoluteError());            }            Double descriptivesValue = getProperty(descriptives, name);            if (descriptivesValue != null) {                TestUtils.assertEquals("descriptive value for " + name + " is incorrect.",                                       descriptivesValue.doubleValue(), expectedValue.doubleValue(),                                       getMaximumAbsoluteError());            }        }    }    protected Double getProperty(Object bean, String name) {        try {            // Get the value of prop            String prop = "get" + name.substring(0,1).toUpperCase() + name.substring(1);            Method meth = bean.getClass().getMethod(prop, new Class[0]);            Object property = meth.invoke(bean, new Object[0]);            if (meth.getReturnType().equals(Double.TYPE)) {                return (Double) property;            } else if (meth.getReturnType().equals(Long.TYPE)) {                return Double.valueOf(((Long) property).doubleValue());            } else {                Assert.fail("wrong type: " + meth.getReturnType().getName());            }        } catch (NoSuchMethodException nsme) {            // ignored        } catch (InvocationTargetException ite) {            Assert.fail(ite.getMessage());        } catch (IllegalAccessException iae) {            Assert.fail(iae.getMessage());        }        return null;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.data;/** * @version $Id$ */public class LotteryTest extends CertifiedDataAbstractTest {    @Override    protected String getResourceName() {        return "org/apache/commons/math/stat/data/Lottery.txt";    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.data;/** * @version $Id$ */public class LewTest extends CertifiedDataAbstractTest {    @Override    protected String getResourceName() {        return "org/apache/commons/math/stat/data/Lew.txt";    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.ranking;import org.apache.commons.math.TestUtils;import org.apache.commons.math.random.JDKRandomGenerator;import org.apache.commons.math.random.RandomGenerator;import org.junit.Test;/** * Test cases for NaturalRanking class * * @since 2.0 * @version $Id$ */public class NaturalRankingTest {    private final double[] exampleData = { 20, 17, 30, 42.3, 17, 50,            Double.NaN, Double.NEGATIVE_INFINITY, 17 };    private final double[] tiesFirst = { 0, 0, 2, 1, 4 };    private final double[] tiesLast = { 4, 4, 1, 0 };    private final double[] multipleNaNs = { 0, 1, Double.NaN, Double.NaN };    private final double[] multipleTies = { 3, 2, 5, 5, 6, 6, 1 };    private final double[] allSame = { 0, 0, 0, 0 };    @Test    public void testDefault() { // Ties averaged, NaNs maximal        NaturalRanking ranking = new NaturalRanking();        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 5, 3, 6, 7, 3, 8, 9, 1, 3 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 1.5, 1.5, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 3.5, 3.5, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 1, 2, 3.5, 3.5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 4.5, 4.5, 6.5, 6.5, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 2.5, 2.5, 2.5, 2.5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    @Test    public void testNaNsMaximalTiesMinimum() {        NaturalRanking ranking = new NaturalRanking(TiesStrategy.MINIMUM);        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 5, 2, 6, 7, 2, 8, 9, 1, 2 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 1, 1, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 3, 3, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 1, 2, 3, 3 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 4, 4, 6, 6, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 1, 1, 1, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    @Test    public void testNaNsRemovedTiesSequential() {        NaturalRanking ranking = new NaturalRanking(NaNStrategy.REMOVED,                TiesStrategy.SEQUENTIAL);        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 5, 2, 6, 7, 3, 8, 1, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 1, 2, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 3, 4, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 1, 2 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 4, 5, 6, 7, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 1, 2, 3, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    @Test    public void testNaNsMinimalTiesMaximum() {        NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL,                TiesStrategy.MAXIMUM);        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 6, 5, 7, 8, 5, 9, 2, 2, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 2, 2, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 4, 4, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 3, 4, 2, 2 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 5, 5, 7, 7, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 4, 4, 4, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    @Test    public void testNaNsMinimalTiesAverage() {        NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL);        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 6, 4, 7, 8, 4, 9, 1.5, 1.5, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 1.5, 1.5, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 3.5, 3.5, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 3, 4, 1.5, 1.5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 4.5, 4.5, 6.5, 6.5, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 2.5, 2.5, 2.5, 2.5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    @Test    public void testNaNsFixedTiesRandom() {        RandomGenerator randomGenerator = new JDKRandomGenerator();        randomGenerator.setSeed(1000);        NaturalRanking ranking = new NaturalRanking(NaNStrategy.FIXED,                randomGenerator);        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 5, 4, 6, 7, 3, 8, Double.NaN, 1, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 1, 1, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 3, 4, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 1, 2, Double.NaN, Double.NaN };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 5, 5, 7, 6, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 1, 3, 4, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    @Test    public void testNaNsAndInfs() {        double[] data = { 0, Double.POSITIVE_INFINITY, Double.NaN,                Double.NEGATIVE_INFINITY };        NaturalRanking ranking = new NaturalRanking(NaNStrategy.MAXIMAL);        double[] ranks = ranking.rank(data);        double[] correctRanks = new double[] { 2, 3.5, 3.5, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranking = new NaturalRanking(NaNStrategy.MINIMAL);        ranks = ranking.rank(data);        correctRanks = new double[] { 3, 4, 1.5, 1.5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat;import java.io.BufferedReader;import java.io.InputStreamReader;import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;import org.apache.commons.math.stat.descriptive.SummaryStatistics;import org.junit.Assert;import org.junit.Test;/** * Certified data test cases. * @version $Id$ */public class CertifiedDataTest {    protected double mean = Double.NaN;    protected double std = Double.NaN;    /**     * Test SummaryStatistics - implementations that do not store the data     * and use single pass algorithms to compute statistics    */    @Test    public void testSummaryStatistics() throws Exception {        SummaryStatistics u = new SummaryStatistics();        loadStats("data/PiDigits.txt", u);        Assert.assertEquals("PiDigits: std", std, u.getStandardDeviation(), 1E-13);        Assert.assertEquals("PiDigits: mean", mean, u.getMean(), 1E-13);        loadStats("data/Mavro.txt", u);        Assert.assertEquals("Mavro: std", std, u.getStandardDeviation(), 1E-14);        Assert.assertEquals("Mavro: mean", mean, u.getMean(), 1E-14);        loadStats("data/Michelso.txt", u);        Assert.assertEquals("Michelso: std", std, u.getStandardDeviation(), 1E-13);        Assert.assertEquals("Michelso: mean", mean, u.getMean(), 1E-13);        loadStats("data/NumAcc1.txt", u);        Assert.assertEquals("NumAcc1: std", std, u.getStandardDeviation(), 1E-14);        Assert.assertEquals("NumAcc1: mean", mean, u.getMean(), 1E-14);        loadStats("data/NumAcc2.txt", u);        Assert.assertEquals("NumAcc2: std", std, u.getStandardDeviation(), 1E-14);        Assert.assertEquals("NumAcc2: mean", mean, u.getMean(), 1E-14);    }    /**     * Test DescriptiveStatistics - implementations that store full array of     * values and execute multi-pass algorithms     */    @Test    public void testDescriptiveStatistics() throws Exception {        DescriptiveStatistics u = new DescriptiveStatistics();        loadStats("data/PiDigits.txt", u);        Assert.assertEquals("PiDigits: std", std, u.getStandardDeviation(), 1E-14);        Assert.assertEquals("PiDigits: mean", mean, u.getMean(), 1E-14);        loadStats("data/Mavro.txt", u);        Assert.assertEquals("Mavro: std", std, u.getStandardDeviation(), 1E-14);        Assert.assertEquals("Mavro: mean", mean, u.getMean(), 1E-14);        loadStats("data/Michelso.txt", u);        Assert.assertEquals("Michelso: std", std, u.getStandardDeviation(), 1E-14);        Assert.assertEquals("Michelso: mean", mean, u.getMean(), 1E-14);        loadStats("data/NumAcc1.txt", u);        Assert.assertEquals("NumAcc1: std", std, u.getStandardDeviation(), 1E-14);        Assert.assertEquals("NumAcc1: mean", mean, u.getMean(), 1E-14);        loadStats("data/NumAcc2.txt", u);        Assert.assertEquals("NumAcc2: std", std, u.getStandardDeviation(), 1E-14);        Assert.assertEquals("NumAcc2: mean", mean, u.getMean(), 1E-14);    }    /**     * loads a DescriptiveStatistics off of a test file     * @param file     * @param statistical summary     */    private void loadStats(String resource, Object u) throws Exception {        DescriptiveStatistics d = null;        SummaryStatistics s = null;        if (u instanceof DescriptiveStatistics) {            d = (DescriptiveStatistics) u;        } else {            s = (SummaryStatistics) u;        }        u.getClass().getDeclaredMethod(                "clear", new Class[]{}).invoke(u, new Object[]{});        mean = Double.NaN;        std = Double.NaN;        BufferedReader in =            new BufferedReader(                    new InputStreamReader(                            CertifiedDataTest.class.getResourceAsStream(resource)));        String line = null;        for (int j = 0; j < 60; j++) {            line = in.readLine();            if (j == 40) {                mean =                    Double.parseDouble(                            line.substring(line.lastIndexOf(":") + 1).trim());            }            if (j == 41) {                std =                    Double.parseDouble(                            line.substring(line.lastIndexOf(":") + 1).trim());            }        }        line = in.readLine();        while (line != null) {            if (d != null) {                d.addValue(Double.parseDouble(line.trim()));            }  else {                s.addValue(Double.parseDouble(line.trim()));            }            line = in.readLine();        }        in.close();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat;import java.io.BufferedReader;import java.io.StringReader;import java.util.Iterator;import org.apache.commons.math.TestUtils;import org.junit.Assert;import org.junit.Before;import org.junit.Test;/** * Test cases for the {@link Frequency} class. * * @version $Id$ */public final class FrequencyTest {    private long oneL = 1;    private long twoL = 2;    private long threeL = 3;    private int oneI = 1;    private int twoI = 2;    private int threeI=3;    private double tolerance = 10E-15;    private Frequency f = null;    @Before    public void setUp() {        f = new Frequency();    }    /** test freq counts */    @Test    public void testCounts() {        Assert.assertEquals("total count",0,f.getSumFreq());        f.addValue(oneL);        f.addValue(twoL);        f.addValue(1);        f.addValue(oneI);        Assert.assertEquals("one frequency count",3,f.getCount(1));        Assert.assertEquals("two frequency count",1,f.getCount(2));        Assert.assertEquals("three frequency count",0,f.getCount(3));        Assert.assertEquals("total count",4,f.getSumFreq());        Assert.assertEquals("zero cumulative frequency", 0, f.getCumFreq(0));        Assert.assertEquals("one cumulative frequency", 3,  f.getCumFreq(1));        Assert.assertEquals("two cumulative frequency", 4,  f.getCumFreq(2));        Assert.assertEquals("Integer argument cum freq",4, f.getCumFreq(Integer.valueOf(2)));        Assert.assertEquals("five cumulative frequency", 4,  f.getCumFreq(5));        Assert.assertEquals("foo cumulative frequency", 0,  f.getCumFreq("foo"));        f.clear();        Assert.assertEquals("total count",0,f.getSumFreq());        // userguide examples -------------------------------------------------------------------        f.addValue("one");        f.addValue("One");        f.addValue("oNe");        f.addValue("Z");        Assert.assertEquals("one cumulative frequency", 1 ,  f.getCount("one"));        Assert.assertEquals("Z cumulative pct", 0.5,  f.getCumPct("Z"), tolerance);        Assert.assertEquals("z cumulative pct", 1.0,  f.getCumPct("z"), tolerance);        Assert.assertEquals("Ot cumulative pct", 0.25,  f.getCumPct("Ot"), tolerance);        f.clear();        f = null;        Frequency f = new Frequency();        f.addValue(1);        f.addValue(Integer.valueOf(1));        f.addValue(Long.valueOf(1));        f.addValue(2);        f.addValue(Integer.valueOf(-1));        Assert.assertEquals("1 count", 3, f.getCount(1));        Assert.assertEquals("1 count", 3, f.getCount(Integer.valueOf(1)));        Assert.assertEquals("0 cum pct", 0.2, f.getCumPct(0), tolerance);        Assert.assertEquals("1 pct", 0.6, f.getPct(Integer.valueOf(1)), tolerance);        Assert.assertEquals("-2 cum pct", 0, f.getCumPct(-2), tolerance);        Assert.assertEquals("10 cum pct", 1, f.getCumPct(10), tolerance);        f = null;        f = new Frequency(String.CASE_INSENSITIVE_ORDER);        f.addValue("one");        f.addValue("One");        f.addValue("oNe");        f.addValue("Z");        Assert.assertEquals("one count", 3 ,  f.getCount("one"));        Assert.assertEquals("Z cumulative pct -- case insensitive", 1 ,  f.getCumPct("Z"), tolerance);        Assert.assertEquals("z cumulative pct -- case insensitive", 1 ,  f.getCumPct("z"), tolerance);        f = null;        f = new Frequency();        Assert.assertEquals(0L, f.getCount('a'));        Assert.assertEquals(0L, f.getCumFreq('b'));        TestUtils.assertEquals(Double.NaN, f.getPct('a'), 0.0);        TestUtils.assertEquals(Double.NaN, f.getCumPct('b'), 0.0);        f.addValue('a');        f.addValue('b');        f.addValue('c');        f.addValue('d');        Assert.assertEquals(1L, f.getCount('a'));        Assert.assertEquals(2L, f.getCumFreq('b'));        Assert.assertEquals(0.25, f.getPct('a'), 0.0);        Assert.assertEquals(0.5, f.getCumPct('b'), 0.0);        Assert.assertEquals(1.0, f.getCumPct('e'), 0.0);    }    /** test pcts */    @Test    public void testPcts() {        f.addValue(oneL);        f.addValue(twoL);        f.addValue(oneI);        f.addValue(twoI);        f.addValue(threeL);        f.addValue(threeL);        f.addValue(3);        f.addValue(threeI);        Assert.assertEquals("one pct",0.25,f.getPct(1),tolerance);        Assert.assertEquals("two pct",0.25,f.getPct(Long.valueOf(2)),tolerance);        Assert.assertEquals("three pct",0.5,f.getPct(threeL),tolerance);        Assert.assertEquals("five pct",0,f.getPct(5),tolerance);        Assert.assertEquals("foo pct",0,f.getPct("foo"),tolerance);        Assert.assertEquals("one cum pct",0.25,f.getCumPct(1),tolerance);        Assert.assertEquals("two cum pct",0.50,f.getCumPct(Long.valueOf(2)),tolerance);        Assert.assertEquals("Integer argument",0.50,f.getCumPct(Integer.valueOf(2)),tolerance);        Assert.assertEquals("three cum pct",1.0,f.getCumPct(threeL),tolerance);        Assert.assertEquals("five cum pct",1.0,f.getCumPct(5),tolerance);        Assert.assertEquals("zero cum pct",0.0,f.getCumPct(0),tolerance);        Assert.assertEquals("foo cum pct",0,f.getCumPct("foo"),tolerance);    }    /** test adding incomparable values */    @Test    public void testAdd() {        char aChar = 'a';        char bChar = 'b';        String aString = "a";        f.addValue(aChar);        f.addValue(bChar);        try {            f.addValue(aString);            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            f.addValue(2);            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        Assert.assertEquals("a pct",0.5,f.getPct(aChar),tolerance);        Assert.assertEquals("b cum pct",1.0,f.getCumPct(bChar),tolerance);        Assert.assertEquals("a string pct",0.0,f.getPct(aString),tolerance);        Assert.assertEquals("a string cum pct",0.0,f.getCumPct(aString),tolerance);        f = new Frequency();        f.addValue("One");        try {            f.addValue(new Integer("One"));            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }    /** test empty table */    @Test    public void testEmptyTable() {        Assert.assertEquals("freq sum, empty table", 0, f.getSumFreq());        Assert.assertEquals("count, empty table", 0, f.getCount(0));        Assert.assertEquals("count, empty table",0, f.getCount(Integer.valueOf(0)));        Assert.assertEquals("cum freq, empty table", 0, f.getCumFreq(0));        Assert.assertEquals("cum freq, empty table", 0, f.getCumFreq("x"));        Assert.assertTrue("pct, empty table", Double.isNaN(f.getPct(0)));        Assert.assertTrue("pct, empty table", Double.isNaN(f.getPct(Integer.valueOf(0))));        Assert.assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(0)));        Assert.assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(Integer.valueOf(0))));    }    /**     * Tests toString()     */    @Test    public void testToString() throws Exception {        f.addValue(oneL);        f.addValue(twoL);        f.addValue(oneI);        f.addValue(twoI);        String s = f.toString();        //System.out.println(s);        Assert.assertNotNull(s);        BufferedReader reader = new BufferedReader(new StringReader(s));        String line = reader.readLine(); // header line        Assert.assertNotNull(line);        line = reader.readLine(); // one's or two's line        Assert.assertNotNull(line);        line = reader.readLine(); // one's or two's line        Assert.assertNotNull(line);        line = reader.readLine(); // no more elements        Assert.assertNull(line);    }    @Test    public void testIntegerValues() {        Comparable<?> obj1 = null;        obj1 = Integer.valueOf(1);        Integer int1 = Integer.valueOf(1);        f.addValue(obj1);        f.addValue(int1);        f.addValue(2);        f.addValue(Long.valueOf(2));        Assert.assertEquals("Integer 1 count", 2, f.getCount(1));        Assert.assertEquals("Integer 1 count", 2, f.getCount(Integer.valueOf(1)));        Assert.assertEquals("Integer 1 count", 2, f.getCount(Long.valueOf(1)));        Assert.assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(1), tolerance);        Assert.assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(Long.valueOf(1)), tolerance);        Assert.assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(Integer.valueOf(1)), tolerance);        Iterator<?> it = f.valuesIterator();        while (it.hasNext()) {            Assert.assertTrue(it.next() instanceof Long);        }    }    @Test    public void testSerial() {        f.addValue(oneL);        f.addValue(twoL);        f.addValue(oneI);        f.addValue(twoI);        Assert.assertEquals(f, TestUtils.serializeAndRecover(f));    }        @Test    public void testGetUniqueCount() {        Assert.assertEquals(0, f.getUniqueCount());        f.addValue(oneL);        Assert.assertEquals(1, f.getUniqueCount());        f.addValue(oneL);        Assert.assertEquals(1, f.getUniqueCount());        f.addValue(twoI);        Assert.assertEquals(2, f.getUniqueCount());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.util.MathUtils;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link StatUtils} class. * @version $Id$ */public final class StatUtilsTest {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double min = 1;    private double max = 3;    private double tolerance = 10E-15;    private double nan = Double.NaN;    /** test stats */    @Test    public void testStats() {        double[] values = new double[] { one, two, two, three };        Assert.assertEquals("sum", sum, StatUtils.sum(values), tolerance);        Assert.assertEquals("sumsq", sumSq, StatUtils.sumSq(values), tolerance);        Assert.assertEquals("var", var, StatUtils.variance(values), tolerance);        Assert.assertEquals("var with mean", var, StatUtils.variance(values, mean), tolerance);        Assert.assertEquals("mean", mean, StatUtils.mean(values), tolerance);        Assert.assertEquals("min", min, StatUtils.min(values), tolerance);        Assert.assertEquals("max", max, StatUtils.max(values), tolerance);    }    @Test    public void testN0andN1Conditions() throws Exception {        double[] values = new double[0];        Assert.assertTrue(            "Mean of n = 0 set should be NaN",            Double.isNaN(StatUtils.mean(values)));        Assert.assertTrue(            "Variance of n = 0 set should be NaN",            Double.isNaN(StatUtils.variance(values)));        values = new double[] { one };        Assert.assertTrue(            "Mean of n = 1 set should be value of single item n1",            StatUtils.mean(values) == one);        Assert.assertTrue(            "Variance of n = 1 set should be zero",            StatUtils.variance(values) == 0);    }    @Test    public void testArrayIndexConditions() throws Exception {        double[] values = { 1.0, 2.0, 3.0, 4.0 };        Assert.assertEquals(            "Sum not expected",            5.0,            StatUtils.sum(values, 1, 2),            Double.MIN_VALUE);        Assert.assertEquals(            "Sum not expected",            3.0,            StatUtils.sum(values, 0, 2),            Double.MIN_VALUE);        Assert.assertEquals(            "Sum not expected",            7.0,            StatUtils.sum(values, 2, 2),            Double.MIN_VALUE);        try {            StatUtils.sum(values, 2, 3);            Assert.fail("Expected RuntimeException");        } catch (RuntimeException e) {            // expected        }        try {            StatUtils.sum(values, -1, 2);            Assert.fail("Expected RuntimeException");        } catch (RuntimeException e) {            // expected        }    }    @Test    public void testSumSq() {        double[] x = null;        // test null        try {            StatUtils.sumSq(x);            Assert.fail("null is not a valid data array.");        } catch (MathIllegalArgumentException ex) {            // success        }        try {            StatUtils.sumSq(x, 0, 4);            Assert.fail("null is not a valid data array.");        } catch (MathIllegalArgumentException ex) {            // success        }        // test empty        x = new double[] {};        TestUtils.assertEquals(0, StatUtils.sumSq(x), tolerance);        TestUtils.assertEquals(0, StatUtils.sumSq(x, 0, 0), tolerance);        // test one        x = new double[] {two};        TestUtils.assertEquals(4, StatUtils.sumSq(x), tolerance);        TestUtils.assertEquals(4, StatUtils.sumSq(x, 0, 1), tolerance);        // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(18, StatUtils.sumSq(x), tolerance);        TestUtils.assertEquals(8, StatUtils.sumSq(x, 1, 2), tolerance);    }    @Test    public void testProduct() {        double[] x = null;        // test null        try {            StatUtils.product(x);            Assert.fail("null is not a valid data array.");        } catch (MathIllegalArgumentException ex) {            // success        }        try {            StatUtils.product(x, 0, 4);            Assert.fail("null is not a valid data array.");        } catch (MathIllegalArgumentException ex) {            // success        }        // test empty        x = new double[] {};        TestUtils.assertEquals(1, StatUtils.product(x), tolerance);        TestUtils.assertEquals(1, StatUtils.product(x, 0, 0), tolerance);        // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.product(x), tolerance);        TestUtils.assertEquals(two, StatUtils.product(x, 0, 1), tolerance);        // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(12, StatUtils.product(x), tolerance);        TestUtils.assertEquals(4, StatUtils.product(x, 1, 2), tolerance);    }    @Test    public void testSumLog() {        double[] x = null;        // test null        try {            StatUtils.sumLog(x);            Assert.fail("null is not a valid data array.");        } catch (MathIllegalArgumentException ex) {            // success        }        try {            StatUtils.sumLog(x, 0, 4);            Assert.fail("null is not a valid data array.");        } catch (MathIllegalArgumentException ex) {            // success        }        // test empty        x = new double[] {};        TestUtils.assertEquals(0, StatUtils.sumLog(x), tolerance);        TestUtils.assertEquals(0, StatUtils.sumLog(x, 0, 0), tolerance);        // test one        x = new double[] {two};        TestUtils.assertEquals(FastMath.log(two), StatUtils.sumLog(x), tolerance);        TestUtils.assertEquals(FastMath.log(two), StatUtils.sumLog(x, 0, 1), tolerance);        // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(FastMath.log(one) + 2.0 * FastMath.log(two) + FastMath.log(three), StatUtils.sumLog(x), tolerance);        TestUtils.assertEquals(2.0 * FastMath.log(two), StatUtils.sumLog(x, 1, 2), tolerance);    }    @Test    public void testMean() {        double[] x = null;        try {            StatUtils.mean(x, 0, 4);            Assert.fail("null is not a valid data array.");        } catch (MathIllegalArgumentException ex) {            // success        }        // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.mean(x, 0, 0), tolerance);        // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.mean(x, 0, 1), tolerance);        // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(2.5, StatUtils.mean(x, 2, 2), tolerance);    }    @Test    public void testVariance() {        double[] x = null;        try {            StatUtils.variance(x, 0, 4);            Assert.fail("null is not a valid data array.");        } catch (MathIllegalArgumentException ex) {            // success        }        // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.variance(x, 0, 0), tolerance);        // test one        x = new double[] {two};        TestUtils.assertEquals(0.0, StatUtils.variance(x, 0, 1), tolerance);        // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(0.5, StatUtils.variance(x, 2, 2), tolerance);        // test precomputed mean        x = new double[] {one, two, two, three};        TestUtils.assertEquals(0.5, StatUtils.variance(x,2.5, 2, 2), tolerance);    }    @Test    public void testMax() {        double[] x = null;        try {            StatUtils.max(x, 0, 4);            Assert.fail("null is not a valid data array.");        } catch (MathIllegalArgumentException ex) {            // success        }        // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.max(x, 0, 0), tolerance);        // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.max(x, 0, 1), tolerance);        // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(three, StatUtils.max(x, 1, 3), tolerance);        // test first nan is ignored        x = new double[] {nan, two, three};        TestUtils.assertEquals(three, StatUtils.max(x), tolerance);        // test middle nan is ignored        x = new double[] {one, nan, three};        TestUtils.assertEquals(three, StatUtils.max(x), tolerance);        // test last nan is ignored        x = new double[] {one, two, nan};        TestUtils.assertEquals(two, StatUtils.max(x), tolerance);        // test all nan returns nan        x = new double[] {nan, nan, nan};        TestUtils.assertEquals(nan, StatUtils.max(x), tolerance);    }    @Test    public void testMin() {        double[] x = null;        try {            StatUtils.min(x, 0, 4);            Assert.fail("null is not a valid data array.");        } catch (MathIllegalArgumentException ex) {            // success        }        // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.min(x, 0, 0), tolerance);        // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.min(x, 0, 1), tolerance);        // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(two, StatUtils.min(x, 1, 3), tolerance);        // test first nan is ignored        x = new double[] {nan, two, three};        TestUtils.assertEquals(two, StatUtils.min(x), tolerance);        // test middle nan is ignored        x = new double[] {one, nan, three};        TestUtils.assertEquals(one, StatUtils.min(x), tolerance);        // test last nan is ignored        x = new double[] {one, two, nan};        TestUtils.assertEquals(one, StatUtils.min(x), tolerance);        // test all nan returns nan        x = new double[] {nan, nan, nan};        TestUtils.assertEquals(nan, StatUtils.min(x), tolerance);    }    @Test    public void testPercentile() {        double[] x = null;        // test null        try {            StatUtils.percentile(x, .25);            Assert.fail("null is not a valid data array.");        } catch (MathIllegalArgumentException ex) {            // success        }        try {            StatUtils.percentile(x, 0, 4, 0.25);            Assert.fail("null is not a valid data array.");        } catch (MathIllegalArgumentException ex) {            // success        }        // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 25), tolerance);        TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 0, 0, 25), tolerance);        // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.percentile(x, 25), tolerance);        TestUtils.assertEquals(two, StatUtils.percentile(x, 0, 1, 25), tolerance);        // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(2.5, StatUtils.percentile(x, 70), tolerance);        TestUtils.assertEquals(2.5, StatUtils.percentile(x, 1, 3, 62.5), tolerance);    }    @Test    public void testDifferenceStats() throws Exception {        double sample1[] = {1d, 2d, 3d, 4d};        double sample2[] = {1d, 3d, 4d, 2d};        double diff[] = {0d, -1d, -1d, 2d};        double small[] = {1d, 4d};        double meanDifference = StatUtils.meanDifference(sample1, sample2);        Assert.assertEquals(StatUtils.sumDifference(sample1, sample2), StatUtils.sum(diff), tolerance);        Assert.assertEquals(meanDifference, StatUtils.mean(diff), tolerance);        Assert.assertEquals(StatUtils.varianceDifference(sample1, sample2, meanDifference),                StatUtils.variance(diff), tolerance);        try {            StatUtils.meanDifference(sample1, small);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            StatUtils.varianceDifference(sample1, small, meanDifference);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            double[] single = {1.0};            StatUtils.varianceDifference(single, single, meanDifference);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testGeometricMean() throws Exception {        double[] test = null;        try {            StatUtils.geometricMean(test);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        test = new double[] {2, 4, 6, 8};        Assert.assertEquals(FastMath.exp(0.25d * StatUtils.sumLog(test)),                StatUtils.geometricMean(test), Double.MIN_VALUE);        Assert.assertEquals(FastMath.exp(0.5 * StatUtils.sumLog(test, 0, 2)),                StatUtils.geometricMean(test, 0, 2), Double.MIN_VALUE);    }            /**     * Run the test with the values 50 and 100 and assume standardized values         */    @Test    public void testNormalize1() {        double sample[] = { 50, 100 };        double expectedSample[] = { -25 / Math.sqrt(1250), 25 / Math.sqrt(1250) };        double[] out = StatUtils.normalize(sample);        for (int i = 0; i < out.length; i++) {            Assert.assertTrue(MathUtils.equals(out[i], expectedSample[i], 1));        }    }    /**     * Run with 77 random values, assuming that the outcome has a mean of 0 and a standard deviation of 1 with a     * precision of 1E-10.     */    @Test    public void testNormalize2() {        // create an sample with 77 values            int length = 77;        double sample[] = new double[length];        for (int i = 0; i < length; i++) {            sample[i] = Math.random();        }        // normalize this sample        double standardizedSample[] = StatUtils.normalize(sample);        DescriptiveStatistics stats = new DescriptiveStatistics();        // Add the data from the array        for (int i = 0; i < length; i++) {            stats.addValue(standardizedSample[i]);        }        // the calculations do have a limited precision            double distance = 1E-10;        // check the mean an standard deviation        Assert.assertEquals(0.0, stats.getMean(), distance);        Assert.assertEquals(1.0, stats.getStandardDeviation(), distance);    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry.euclidean.threed;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.util.MathUtils;import org.junit.Assert;import org.junit.Test;public class RotationTest {  @Test  public void testIdentity() {    Rotation r = Rotation.IDENTITY;    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);    checkAngle(r.getAngle(), 0);    r = new Rotation(-1, 0, 0, 0, false);    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);    checkAngle(r.getAngle(), 0);    r = new Rotation(42, 0, 0, 0, true);    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);    checkAngle(r.getAngle(), 0);  }  @Test  public void testAxisAngle() {    Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * FastMath.PI / 3);    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_J);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_K);    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_I);    double s = 1 / FastMath.sqrt(3);    checkVector(r.getAxis(), new Vector3D(s, s, s));    checkAngle(r.getAngle(), 2 * FastMath.PI / 3);    try {      new Rotation(new Vector3D(0, 0, 0), 2 * FastMath.PI / 3);      Assert.fail("an exception should have been thrown");    } catch (ArithmeticException e) {    }    r = new Rotation(Vector3D.PLUS_K, 1.5 * FastMath.PI);    checkVector(r.getAxis(), new Vector3D(0, 0, -1));    checkAngle(r.getAngle(), 0.5 * FastMath.PI);    r = new Rotation(Vector3D.PLUS_J, FastMath.PI);    checkVector(r.getAxis(), Vector3D.PLUS_J);    checkAngle(r.getAngle(), FastMath.PI);    checkVector(Rotation.IDENTITY.getAxis(), Vector3D.PLUS_I);  }  @Test  public void testRevert() {    Rotation r = new Rotation(0.001, 0.36, 0.48, 0.8, true);    Rotation reverted = r.revert();    checkRotation(r.applyTo(reverted), 1, 0, 0, 0);    checkRotation(reverted.applyTo(r), 1, 0, 0, 0);    Assert.assertEquals(r.getAngle(), reverted.getAngle(), 1.0e-12);    Assert.assertEquals(-1, Vector3D.dotProduct(r.getAxis(), reverted.getAxis()), 1.0e-12);  }  @Test  public void testVectorOnePair() {    Vector3D u = new Vector3D(3, 2, 1);    Vector3D v = new Vector3D(-4, 2, 2);    Rotation r = new Rotation(u, v);    checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm()));    checkAngle(new Rotation(u, u.negate()).getAngle(), FastMath.PI);    try {        new Rotation(u, Vector3D.ZERO);        Assert.fail("an exception should have been thrown");    } catch (IllegalArgumentException e) {        // expected behavior    }  }  @Test  public void testVectorTwoPairs() {    Vector3D u1 = new Vector3D(3, 0, 0);    Vector3D u2 = new Vector3D(0, 5, 0);    Vector3D v1 = new Vector3D(0, 0, 2);    Vector3D v2 = new Vector3D(-2, 0, 2);    Rotation r = new Rotation(u1, u2, v1, v2);    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.MINUS_I);    r = new Rotation(u1, u2, u1.negate(), u2.negate());    Vector3D axis = r.getAxis();    if (Vector3D.dotProduct(axis, Vector3D.PLUS_K) > 0) {      checkVector(axis, Vector3D.PLUS_K);    } else {      checkVector(axis, Vector3D.MINUS_K);    }    checkAngle(r.getAngle(), FastMath.PI);    double sqrt = FastMath.sqrt(2) / 2;    r = new Rotation(Vector3D.PLUS_I,  Vector3D.PLUS_J,                     new Vector3D(0.5, 0.5,  sqrt),                     new Vector3D(0.5, 0.5, -sqrt));    checkRotation(r, sqrt, 0.5, 0.5, 0);    r = new Rotation(u1, u2, u1, Vector3D.crossProduct(u1, u2));    checkRotation(r, sqrt, -sqrt, 0, 0);    checkRotation(new Rotation(u1, u2, u1, u2), 1, 0, 0, 0);    try {        new Rotation(u1, u2, Vector3D.ZERO, v2);        Assert.fail("an exception should have been thrown");    } catch (IllegalArgumentException e) {      // expected behavior    }  }  @Test  public void testMatrix()    throws NotARotationMatrixException {    try {      new Rotation(new double[][] {                     { 0.0, 1.0, 0.0 },                     { 1.0, 0.0, 0.0 }                   }, 1.0e-7);      Assert.fail("Expecting NotARotationMatrixException");    } catch (NotARotationMatrixException nrme) {      // expected behavior    }    try {      new Rotation(new double[][] {                     {  0.445888,  0.797184, -0.407040 },                     {  0.821760, -0.184320,  0.539200 },                     { -0.354816,  0.574912,  0.737280 }                   }, 1.0e-7);      Assert.fail("Expecting NotARotationMatrixException");    } catch (NotARotationMatrixException nrme) {      // expected behavior    }    try {        new Rotation(new double[][] {                       {  0.4,  0.8, -0.4 },                       { -0.4,  0.6,  0.7 },                       {  0.8, -0.2,  0.5 }                     }, 1.0e-15);        Assert.fail("Expecting NotARotationMatrixException");      } catch (NotARotationMatrixException nrme) {        // expected behavior      }    checkRotation(new Rotation(new double[][] {                                 {  0.445888,  0.797184, -0.407040 },                                 { -0.354816,  0.574912,  0.737280 },                                 {  0.821760, -0.184320,  0.539200 }                               }, 1.0e-10),                  0.8, 0.288, 0.384, 0.36);    checkRotation(new Rotation(new double[][] {                                 {  0.539200,  0.737280,  0.407040 },                                 {  0.184320, -0.574912,  0.797184 },                                 {  0.821760, -0.354816, -0.445888 }                              }, 1.0e-10),                  0.36, 0.8, 0.288, 0.384);    checkRotation(new Rotation(new double[][] {                                 { -0.445888,  0.797184, -0.407040 },                                 {  0.354816,  0.574912,  0.737280 },                                 {  0.821760,  0.184320, -0.539200 }                               }, 1.0e-10),                  0.384, 0.36, 0.8, 0.288);    checkRotation(new Rotation(new double[][] {                                 { -0.539200,  0.737280,  0.407040 },                                 { -0.184320, -0.574912,  0.797184 },                                 {  0.821760,  0.354816,  0.445888 }                               }, 1.0e-10),                  0.288, 0.384, 0.36, 0.8);    double[][] m1 = { { 0.0, 1.0, 0.0 },                      { 0.0, 0.0, 1.0 },                      { 1.0, 0.0, 0.0 } };    Rotation r = new Rotation(m1, 1.0e-7);    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_I);    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_J);    double[][] m2 = { { 0.83203, -0.55012, -0.07139 },                      { 0.48293,  0.78164, -0.39474 },                      { 0.27296,  0.29396,  0.91602 } };    r = new Rotation(m2, 1.0e-12);    double[][] m3 = r.getMatrix();    double d00 = m2[0][0] - m3[0][0];    double d01 = m2[0][1] - m3[0][1];    double d02 = m2[0][2] - m3[0][2];    double d10 = m2[1][0] - m3[1][0];    double d11 = m2[1][1] - m3[1][1];    double d12 = m2[1][2] - m3[1][2];    double d20 = m2[2][0] - m3[2][0];    double d21 = m2[2][1] - m3[2][1];    double d22 = m2[2][2] - m3[2][2];    Assert.assertTrue(FastMath.abs(d00) < 6.0e-6);    Assert.assertTrue(FastMath.abs(d01) < 6.0e-6);    Assert.assertTrue(FastMath.abs(d02) < 6.0e-6);    Assert.assertTrue(FastMath.abs(d10) < 6.0e-6);    Assert.assertTrue(FastMath.abs(d11) < 6.0e-6);    Assert.assertTrue(FastMath.abs(d12) < 6.0e-6);    Assert.assertTrue(FastMath.abs(d20) < 6.0e-6);    Assert.assertTrue(FastMath.abs(d21) < 6.0e-6);    Assert.assertTrue(FastMath.abs(d22) < 6.0e-6);    Assert.assertTrue(FastMath.abs(d00) > 4.0e-7);    Assert.assertTrue(FastMath.abs(d01) > 4.0e-7);    Assert.assertTrue(FastMath.abs(d02) > 4.0e-7);    Assert.assertTrue(FastMath.abs(d10) > 4.0e-7);    Assert.assertTrue(FastMath.abs(d11) > 4.0e-7);    Assert.assertTrue(FastMath.abs(d12) > 4.0e-7);    Assert.assertTrue(FastMath.abs(d20) > 4.0e-7);    Assert.assertTrue(FastMath.abs(d21) > 4.0e-7);    Assert.assertTrue(FastMath.abs(d22) > 4.0e-7);    for (int i = 0; i < 3; ++i) {      for (int j = 0; j < 3; ++j) {        double m3tm3 = m3[i][0] * m3[j][0]                     + m3[i][1] * m3[j][1]                     + m3[i][2] * m3[j][2];        if (i == j) {          Assert.assertTrue(FastMath.abs(m3tm3 - 1.0) < 1.0e-10);        } else {          Assert.assertTrue(FastMath.abs(m3tm3) < 1.0e-10);        }      }    }    checkVector(r.applyTo(Vector3D.PLUS_I),                new Vector3D(m3[0][0], m3[1][0], m3[2][0]));    checkVector(r.applyTo(Vector3D.PLUS_J),                new Vector3D(m3[0][1], m3[1][1], m3[2][1]));    checkVector(r.applyTo(Vector3D.PLUS_K),                new Vector3D(m3[0][2], m3[1][2], m3[2][2]));    double[][] m4 = { { 1.0,  0.0,  0.0 },                      { 0.0, -1.0,  0.0 },                      { 0.0,  0.0, -1.0 } };    r = new Rotation(m4, 1.0e-7);    checkAngle(r.getAngle(), FastMath.PI);    try {      double[][] m5 = { { 0.0, 0.0, 1.0 },                        { 0.0, 1.0, 0.0 },                        { 1.0, 0.0, 0.0 } };      r = new Rotation(m5, 1.0e-7);      Assert.fail("got " + r + ", should have caught an exception");    } catch (NotARotationMatrixException e) {      // expected    }  }  @Test  public void testAngles()    throws CardanEulerSingularityException {    RotationOrder[] CardanOrders = {      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX    };    for (int i = 0; i < CardanOrders.length; ++i) {      for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {        for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) {          for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {            Rotation r = new Rotation(CardanOrders[i], alpha1, alpha2, alpha3);            double[] angles = r.getAngles(CardanOrders[i]);            checkAngle(angles[0], alpha1);            checkAngle(angles[1], alpha2);            checkAngle(angles[2], alpha3);          }        }      }    }    RotationOrder[] EulerOrders = {            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ          };    for (int i = 0; i < EulerOrders.length; ++i) {      for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {        for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.3) {          for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {            Rotation r = new Rotation(EulerOrders[i],                                      alpha1, alpha2, alpha3);            double[] angles = r.getAngles(EulerOrders[i]);            checkAngle(angles[0], alpha1);            checkAngle(angles[1], alpha2);            checkAngle(angles[2], alpha3);          }        }      }    }  }  @Test  public void testSingularities() {    RotationOrder[] CardanOrders = {      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX    };    double[] singularCardanAngle = { FastMath.PI / 2, -FastMath.PI / 2 };    for (int i = 0; i < CardanOrders.length; ++i) {      for (int j = 0; j < singularCardanAngle.length; ++j) {        Rotation r = new Rotation(CardanOrders[i], 0.1, singularCardanAngle[j], 0.3);        try {          r.getAngles(CardanOrders[i]);          Assert.fail("an exception should have been caught");        } catch (CardanEulerSingularityException cese) {          // expected behavior        }      }    }    RotationOrder[] EulerOrders = {            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ          };    double[] singularEulerAngle = { 0, FastMath.PI };    for (int i = 0; i < EulerOrders.length; ++i) {      for (int j = 0; j < singularEulerAngle.length; ++j) {        Rotation r = new Rotation(EulerOrders[i], 0.1, singularEulerAngle[j], 0.3);        try {          r.getAngles(EulerOrders[i]);          Assert.fail("an exception should have been caught");        } catch (CardanEulerSingularityException cese) {          // expected behavior        }      }    }  }  @Test  public void testQuaternion() {    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);    double n = 23.5;    Rotation r2 = new Rotation(n * r1.getQ0(), n * r1.getQ1(),                               n * r1.getQ2(), n * r1.getQ3(),                               true);    for (double x = -0.9; x < 0.9; x += 0.2) {      for (double y = -0.9; y < 0.9; y += 0.2) {        for (double z = -0.9; z < 0.9; z += 0.2) {          Vector3D u = new Vector3D(x, y, z);          checkVector(r2.applyTo(u), r1.applyTo(u));        }      }    }    r1 = new Rotation( 0.288,  0.384,  0.36,  0.8, false);    checkRotation(r1, -r1.getQ0(), -r1.getQ1(), -r1.getQ2(), -r1.getQ3());  }  @Test  public void testCompose() {    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);    Rotation r3 = r2.applyTo(r1);    for (double x = -0.9; x < 0.9; x += 0.2) {      for (double y = -0.9; y < 0.9; y += 0.2) {        for (double z = -0.9; z < 0.9; z += 0.2) {          Vector3D u = new Vector3D(x, y, z);          checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));        }      }    }  }  @Test  public void testComposeInverse() {    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);    Rotation r3 = r2.applyInverseTo(r1);    for (double x = -0.9; x < 0.9; x += 0.2) {      for (double y = -0.9; y < 0.9; y += 0.2) {        for (double z = -0.9; z < 0.9; z += 0.2) {          Vector3D u = new Vector3D(x, y, z);          checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));        }      }    }  }  @Test  public void testApplyInverseTo() {    Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7);    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {      for (double phi = -1.55; phi < 1.55; phi += 0.2) {          Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi),                                    FastMath.sin(lambda) * FastMath.cos(phi),                                    FastMath.sin(phi));          r.applyInverseTo(r.applyTo(u));          checkVector(u, r.applyInverseTo(r.applyTo(u)));          checkVector(u, r.applyTo(r.applyInverseTo(u)));      }    }    r = Rotation.IDENTITY;    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {      for (double phi = -1.55; phi < 1.55; phi += 0.2) {          Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi),                                    FastMath.sin(lambda) * FastMath.cos(phi),                                    FastMath.sin(phi));          checkVector(u, r.applyInverseTo(r.applyTo(u)));          checkVector(u, r.applyTo(r.applyInverseTo(u)));      }    }    r = new Rotation(Vector3D.PLUS_K, FastMath.PI);    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {      for (double phi = -1.55; phi < 1.55; phi += 0.2) {          Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi),                                    FastMath.sin(lambda) * FastMath.cos(phi),                                    FastMath.sin(phi));          checkVector(u, r.applyInverseTo(r.applyTo(u)));          checkVector(u, r.applyTo(r.applyInverseTo(u)));      }    }  }  @Test  public void testIssue639(){      Vector3D u1 = new Vector3D(-1321008684645961.0 /  268435456.0,                                 -5774608829631843.0 /  268435456.0,                                 -3822921525525679.0 / 4294967296.0);      Vector3D u2 =new Vector3D( -5712344449280879.0 /    2097152.0,                                 -2275058564560979.0 /    1048576.0,                                  4423475992255071.0 /      65536.0);      Rotation rot = new Rotation(u1, u2, Vector3D.PLUS_I,Vector3D.PLUS_K);      Assert.assertEquals( 0.6228370359608200639829222, rot.getQ0(), 1.0e-15);      Assert.assertEquals( 0.0257707621456498790029987, rot.getQ1(), 1.0e-15);      Assert.assertEquals(-0.0000000002503012255839931, rot.getQ2(), 1.0e-15);      Assert.assertEquals(-0.7819270390861109450724902, rot.getQ3(), 1.0e-15);  }  private void checkVector(Vector3D v1, Vector3D v2) {    Assert.assertTrue(v1.subtract(v2).getNorm() < 1.0e-10);  }  private void checkAngle(double a1, double a2) {    Assert.assertEquals(a1, MathUtils.normalizeAngle(a2, a1), 1.0e-10);  }  private void checkRotation(Rotation r, double q0, double q1, double q2, double q3) {    Assert.assertEquals(0, Rotation.distance(r, new Rotation(q0, q1, q2, q3, false)), 1.0e-12);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry.euclidean.threed;import org.apache.commons.math.exception.MathArithmeticException;import org.apache.commons.math.random.Well1024a;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class Vector3DTest {    @Test    public void testConstructors() {        double r = FastMath.sqrt(2) /2;        checkVector(new Vector3D(2, new Vector3D(FastMath.PI / 3, -FastMath.PI / 4)),                    r, r * FastMath.sqrt(3), -2 * r);        checkVector(new Vector3D(2, Vector3D.PLUS_I,                                 -3, Vector3D.MINUS_K),                    2, 0, 3);        checkVector(new Vector3D(2, Vector3D.PLUS_I,                                 5, Vector3D.PLUS_J,                                 -3, Vector3D.MINUS_K),                    2, 5, 3);        checkVector(new Vector3D(2, Vector3D.PLUS_I,                                 5, Vector3D.PLUS_J,                                 5, Vector3D.MINUS_J,                                 -3, Vector3D.MINUS_K),                    2, 0, 3);    }    @Test    public void testCoordinates() {        Vector3D v = new Vector3D(1, 2, 3);        Assert.assertTrue(FastMath.abs(v.getX() - 1) < 1.0e-12);        Assert.assertTrue(FastMath.abs(v.getY() - 2) < 1.0e-12);        Assert.assertTrue(FastMath.abs(v.getZ() - 3) < 1.0e-12);    }    @Test    public void testNorm1() {        Assert.assertEquals(0.0, Vector3D.ZERO.getNorm1(), 0);        Assert.assertEquals(6.0, new Vector3D(1, -2, 3).getNorm1(), 0);    }    @Test    public void testNorm() {        Assert.assertEquals(0.0, Vector3D.ZERO.getNorm(), 0);        Assert.assertEquals(FastMath.sqrt(14), new Vector3D(1, 2, 3).getNorm(), 1.0e-12);    }    @Test    public void testNormInf() {        Assert.assertEquals(0.0, Vector3D.ZERO.getNormInf(), 0);        Assert.assertEquals(3.0, new Vector3D(1, -2, 3).getNormInf(), 0);    }    @Test    public void testDistance1() {        Vector3D v1 = new Vector3D(1, -2, 3);        Vector3D v2 = new Vector3D(-4, 2, 0);        Assert.assertEquals(0.0, Vector3D.distance1(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);        Assert.assertEquals(12.0, Vector3D.distance1(v1, v2), 1.0e-12);        Assert.assertEquals(v1.subtract(v2).getNorm1(), Vector3D.distance1(v1, v2), 1.0e-12);    }    @Test    public void testDistance() {        Vector3D v1 = new Vector3D(1, -2, 3);        Vector3D v2 = new Vector3D(-4, 2, 0);        Assert.assertEquals(0.0, Vector3D.distance(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);        Assert.assertEquals(FastMath.sqrt(50), Vector3D.distance(v1, v2), 1.0e-12);        Assert.assertEquals(v1.subtract(v2).getNorm(), Vector3D.distance(v1, v2), 1.0e-12);    }    @Test    public void testDistanceSq() {        Vector3D v1 = new Vector3D(1, -2, 3);        Vector3D v2 = new Vector3D(-4, 2, 0);        Assert.assertEquals(0.0, Vector3D.distanceSq(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);        Assert.assertEquals(50.0, Vector3D.distanceSq(v1, v2), 1.0e-12);        Assert.assertEquals(Vector3D.distance(v1, v2) * Vector3D.distance(v1, v2),                            Vector3D.distanceSq(v1, v2), 1.0e-12);  }    @Test    public void testDistanceInf() {        Vector3D v1 = new Vector3D(1, -2, 3);        Vector3D v2 = new Vector3D(-4, 2, 0);        Assert.assertEquals(0.0, Vector3D.distanceInf(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);        Assert.assertEquals(5.0, Vector3D.distanceInf(v1, v2), 1.0e-12);        Assert.assertEquals(v1.subtract(v2).getNormInf(), Vector3D.distanceInf(v1, v2), 1.0e-12);    }    @Test    public void testSubtract() {        Vector3D v1 = new Vector3D(1, 2, 3);        Vector3D v2 = new Vector3D(-3, -2, -1);        v1 = v1.subtract(v2);        checkVector(v1, 4, 4, 4);        checkVector(v2.subtract(v1), -7, -6, -5);        checkVector(v2.subtract(3, v1), -15, -14, -13);    }    @Test    public void testAdd() {        Vector3D v1 = new Vector3D(1, 2, 3);        Vector3D v2 = new Vector3D(-3, -2, -1);        v1 = v1.add(v2);        checkVector(v1, -2, 0, 2);        checkVector(v2.add(v1), -5, -2, 1);        checkVector(v2.add(3, v1), -9, -2, 5);    }    @Test    public void testScalarProduct() {        Vector3D v = new Vector3D(1, 2, 3);        v = v.scalarMultiply(3);        checkVector(v, 3, 6, 9);        checkVector(v.scalarMultiply(0.5), 1.5, 3, 4.5);    }    @Test    public void testVectorialProducts() {        Vector3D v1 = new Vector3D(2, 1, -4);        Vector3D v2 = new Vector3D(3, 1, -1);        Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v1, v2) - 11) < 1.0e-12);        Vector3D v3 = Vector3D.crossProduct(v1, v2);        checkVector(v3, 3, -10, -1);        Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v1, v3)) < 1.0e-12);        Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v2, v3)) < 1.0e-12);    }    @Test    public void testCrossProductCancellation() {        Vector3D v1 = new Vector3D(9070467121.0, 4535233560.0, 1);        Vector3D v2 = new Vector3D(9070467123.0, 4535233561.0, 1);        checkVector(Vector3D.crossProduct(v1, v2), -1, 2, 1);        double scale    = FastMath.scalb(1.0, 100);        Vector3D big1   = new Vector3D(scale, v1);        Vector3D small2 = new Vector3D(1 / scale, v2);        checkVector(Vector3D.crossProduct(big1, small2), -1, 2, 1);    }    @Test    public void testAngular() {        Assert.assertEquals(0,           Vector3D.PLUS_I.getAlpha(), 1.0e-10);        Assert.assertEquals(0,           Vector3D.PLUS_I.getDelta(), 1.0e-10);        Assert.assertEquals(FastMath.PI / 2, Vector3D.PLUS_J.getAlpha(), 1.0e-10);        Assert.assertEquals(0,           Vector3D.PLUS_J.getDelta(), 1.0e-10);        Assert.assertEquals(0,           Vector3D.PLUS_K.getAlpha(), 1.0e-10);        Assert.assertEquals(FastMath.PI / 2, Vector3D.PLUS_K.getDelta(), 1.0e-10);              Vector3D u = new Vector3D(-1, 1, -1);        Assert.assertEquals(3 * FastMath.PI /4, u.getAlpha(), 1.0e-10);        Assert.assertEquals(-1.0 / FastMath.sqrt(3), FastMath.sin(u.getDelta()), 1.0e-10);    }    @Test    public void testAngularSeparation() {        Vector3D v1 = new Vector3D(2, -1, 4);        Vector3D  k = v1.normalize();        Vector3D  i = k.orthogonal();        Vector3D v2 = k.scalarMultiply(FastMath.cos(1.2)).add(i.scalarMultiply(FastMath.sin(1.2)));        Assert.assertTrue(FastMath.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12);  }    @Test    public void testNormalize() {        Assert.assertEquals(1.0, new Vector3D(5, -4, 2).normalize().getNorm(), 1.0e-12);        try {            Vector3D.ZERO.normalize();            Assert.fail("an exception should have been thrown");        } catch (MathArithmeticException ae) {            // expected behavior        }    }    @Test    public void testOrthogonal() {        Vector3D v1 = new Vector3D(0.1, 2.5, 1.3);        Assert.assertEquals(0.0, Vector3D.dotProduct(v1, v1.orthogonal()), 1.0e-12);        Vector3D v2 = new Vector3D(2.3, -0.003, 7.6);        Assert.assertEquals(0.0, Vector3D.dotProduct(v2, v2.orthogonal()), 1.0e-12);        Vector3D v3 = new Vector3D(-1.7, 1.4, 0.2);        Assert.assertEquals(0.0, Vector3D.dotProduct(v3, v3.orthogonal()), 1.0e-12);        try {            new Vector3D(0, 0, 0).orthogonal();            Assert.fail("an exception should have been thrown");        } catch (MathArithmeticException ae) {            // expected behavior        }    }    @Test    public void testAngle() {        Assert.assertEquals(0.22572612855273393616,                            Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(4, 5, 6)),                            1.0e-12);        Assert.assertEquals(7.98595620686106654517199e-8,                            Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(2, 4, 6.000001)),                            1.0e-12);        Assert.assertEquals(3.14159257373023116985197793156,                            Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(-2, -4, -6.000001)),                            1.0e-12);        try {            Vector3D.angle(Vector3D.ZERO, Vector3D.PLUS_I);            Assert.fail("an exception should have been thrown");        } catch (MathArithmeticException ae) {            // expected behavior        }    }    @Test    public void testAccurateDotProduct() {        // the following two vectors are nearly but not exactly orthogonal        // naive dot product (i.e. computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z        // leads to a result of 0.0, instead of the correct -1.855129...        Vector3D u1 = new Vector3D(-1321008684645961.0 /  268435456.0,                                   -5774608829631843.0 /  268435456.0,                                   -7645843051051357.0 / 8589934592.0);        Vector3D u2 = new Vector3D(-5712344449280879.0 /    2097152.0,                                   -4550117129121957.0 /    2097152.0,                                    8846951984510141.0 /     131072.0);        double sNaive = u1.getX() * u2.getX() + u1.getY() * u2.getY() + u1.getZ() * u2.getZ();        double sAccurate = u1.dotProduct(u2);        Assert.assertEquals(0.0, sNaive, 1.0e-30);        Assert.assertEquals(-2088690039198397.0 / 1125899906842624.0, sAccurate, 1.0e-16);    }    @Test    public void testDotProduct() {        // we compare accurate versus naive dot product implementations        // on regular vectors (i.e. not extreme cases like in the previous test)        Well1024a random = new Well1024a(553267312521321234l);        for (int i = 0; i < 10000; ++i) {            double ux = 10000 * random.nextDouble();            double uy = 10000 * random.nextDouble();            double uz = 10000 * random.nextDouble();            double vx = 10000 * random.nextDouble();            double vy = 10000 * random.nextDouble();            double vz = 10000 * random.nextDouble();            double sNaive = ux * vx + uy * vy + uz * vz;            double sAccurate = new Vector3D(ux, uy, uz).dotProduct(new Vector3D(vx, vy, vz));            Assert.assertEquals(sNaive, sAccurate, 2.5e-16 * sAccurate);        }    }    @Test    public void testAccurateCrossProduct() {        // the vectors u1 and u2 are nearly but not exactly anti-parallel        // (7.31e-16 degrees from 180 degrees) naive cross product (i.e.        // computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z        // leads to a result of   [0.0009765, -0.0001220, -0.0039062],        // instead of the correct [0.0006913, -0.0001254, -0.0007909]        final Vector3D u1 = new Vector3D(-1321008684645961.0 /   268435456.0,                                         -5774608829631843.0 /   268435456.0,                                         -7645843051051357.0 /  8589934592.0);        final Vector3D u2 = new Vector3D( 1796571811118507.0 /  2147483648.0,                                          7853468008299307.0 /  2147483648.0,                                          2599586637357461.0 / 17179869184.0);        final Vector3D u3 = new Vector3D(12753243807587107.0 / 18446744073709551616.0,                                          -2313766922703915.0 / 18446744073709551616.0,                                           -227970081415313.0 /   288230376151711744.0);        Vector3D cNaive = new Vector3D(u1.getY() * u2.getZ() - u1.getZ() * u2.getY(),                                       u1.getZ() * u2.getX() - u1.getX() * u2.getZ(),                                       u1.getX() * u2.getY() - u1.getY() * u2.getX());        Vector3D cAccurate = u1.crossProduct(u2);        Assert.assertTrue(u3.distance(cNaive) > 2.9 * u3.getNorm());        Assert.assertEquals(0.0, u3.distance(cAccurate), 1.0e-30 * cAccurate.getNorm());    }    @Test    public void testCrossProduct() {        // we compare accurate versus naive cross product implementations        // on regular vectors (i.e. not extreme cases like in the previous test)        Well1024a random = new Well1024a(885362227452043214l);        for (int i = 0; i < 10000; ++i) {            double ux = 10000 * random.nextDouble();            double uy = 10000 * random.nextDouble();            double uz = 10000 * random.nextDouble();            double vx = 10000 * random.nextDouble();            double vy = 10000 * random.nextDouble();            double vz = 10000 * random.nextDouble();            Vector3D cNaive = new Vector3D(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx);            Vector3D cAccurate = new Vector3D(ux, uy, uz).crossProduct(new Vector3D(vx, vy, vz));            Assert.assertEquals(0.0, cAccurate.distance(cNaive), 6.0e-15 * cAccurate.getNorm());        }    }    private void checkVector(Vector3D v, double x, double y, double z) {        Assert.assertEquals(x, v.getX(), 1.0e-12);        Assert.assertEquals(y, v.getY(), 1.0e-12);        Assert.assertEquals(z, v.getZ(), 1.0e-12);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry.euclidean.threed;import java.util.Locale;public class Vector3DFormatTest extends Vector3DFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return '.';    }    @Override    protected Locale getLocale() {        return Locale.US;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry.euclidean.threed;import java.text.NumberFormat;import java.text.ParsePosition;import java.util.Locale;import org.apache.commons.math.geometry.euclidean.threed.Vector3D;import org.apache.commons.math.geometry.euclidean.threed.Vector3DFormat;import org.junit.Test;import org.junit.Assert;public abstract class Vector3DFormatAbstractTest {    Vector3DFormat vector3DFormat = null;    Vector3DFormat vector3DFormatSquare = null;    protected abstract Locale getLocale();    protected abstract char getDecimalCharacter();    protected Vector3DFormatAbstractTest() {        vector3DFormat = Vector3DFormat.getInstance(getLocale());        final NumberFormat nf = NumberFormat.getInstance(getLocale());        nf.setMaximumFractionDigits(2);        vector3DFormatSquare = new Vector3DFormat("[", "]", " : ", nf);    }    @Test    public void testSimpleNoDecimals() {        Vector3D c = new Vector3D(1, 1, 1);        String expected = "{1; 1; 1}";        String actual = vector3DFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testSimpleWithDecimals() {        Vector3D c = new Vector3D(1.23, 1.43, 1.63);        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = vector3DFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testSimpleWithDecimalsTrunc() {        Vector3D c = new Vector3D(1.2323, 1.4343, 1.6333);        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = vector3DFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testNegativeX() {        Vector3D c = new Vector3D(-1.2323, 1.4343, 1.6333);        String expected =            "{-1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = vector3DFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testNegativeY() {        Vector3D c = new Vector3D(1.2323, -1.4343, 1.6333);        String expected =            "{1"    + getDecimalCharacter() +            "23; -1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = vector3DFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testNegativeZ() {        Vector3D c = new Vector3D(1.2323, 1.4343, -1.6333);        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; -1" + getDecimalCharacter() +            "63}";        String actual = vector3DFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testNonDefaultSetting() {        Vector3D c = new Vector3D(1, 1, 1);        String expected = "[1 : 1 : 1]";        String actual = vector3DFormatSquare.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testDefaultFormatVector3D() {        Locale defaultLocal = Locale.getDefault();        Locale.setDefault(getLocale());        Vector3D c = new Vector3D(232.222, -342.33, 432.444);        String expected =            "{232"    + getDecimalCharacter() +            "22; -342" + getDecimalCharacter() +            "33; 432" + getDecimalCharacter() +            "44}";        String actual = (new Vector3DFormat()).format(c);        Assert.assertEquals(expected, actual);        Locale.setDefault(defaultLocal);    }    @Test    public void testNan() {        Vector3D c = Vector3D.NaN;        String expected = "{(NaN); (NaN); (NaN)}";        String actual = vector3DFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testPositiveInfinity() {        Vector3D c = Vector3D.POSITIVE_INFINITY;        String expected = "{(Infinity); (Infinity); (Infinity)}";        String actual = vector3DFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void tesNegativeInfinity() {        Vector3D c = Vector3D.NEGATIVE_INFINITY;        String expected = "{(-Infinity); (-Infinity); (-Infinity)}";        String actual = vector3DFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseSimpleNoDecimals() {        String source = "{1; 1; 1}";        Vector3D expected = new Vector3D(1, 1, 1);        Vector3D actual = vector3DFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseIgnoredWhitespace() {        Vector3D expected = new Vector3D(1, 1, 1);        ParsePosition pos1 = new ParsePosition(0);        String source1 = "{1;1;1}";        Assert.assertEquals(expected, vector3DFormat.parse(source1, pos1));        Assert.assertEquals(source1.length(), pos1.getIndex());        ParsePosition pos2 = new ParsePosition(0);        String source2 = " { 1 ; 1 ; 1 } ";        Assert.assertEquals(expected, vector3DFormat.parse(source2, pos2));        Assert.assertEquals(source2.length() - 1, pos2.getIndex());    }    @Test    public void testParseSimpleWithDecimals() {        String source =            "{1" + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        Vector3D expected = new Vector3D(1.23, 1.43, 1.63);        Vector3D actual = vector3DFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseSimpleWithDecimalsTrunc() {        String source =            "{1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);        Vector3D actual = vector3DFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseNegativeX() {        String source =            "{-1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(-1.2323, 1.4343, 1.6333);        Vector3D actual = vector3DFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseNegativeY() {        String source =            "{1" + getDecimalCharacter() +            "2323; -1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(1.2323, -1.4343, 1.6333);        Vector3D actual = vector3DFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseNegativeZ() {        String source =            "{1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; -1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(1.2323, 1.4343, -1.6333);        Vector3D actual = vector3DFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseNegativeAll() {        String source =            "{-1" + getDecimalCharacter() +            "2323; -1" + getDecimalCharacter() +            "4343; -1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(-1.2323, -1.4343, -1.6333);        Vector3D actual = vector3DFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseZeroX() {        String source =            "{0" + getDecimalCharacter() +            "0; -1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(0.0, -1.4343, 1.6333);        Vector3D actual = vector3DFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseNonDefaultSetting() {        String source =            "[1" + getDecimalCharacter() +            "2323 : 1" + getDecimalCharacter() +            "4343 : 1" + getDecimalCharacter() +            "6333]";        Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);        Vector3D actual = vector3DFormatSquare.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseNan() {        String source = "{(NaN); (NaN); (NaN)}";        Vector3D actual = vector3DFormat.parse(source);        Assert.assertEquals(Vector3D.NaN, actual);    }    @Test    public void testParsePositiveInfinity() {        String source = "{(Infinity); (Infinity); (Infinity)}";        Vector3D actual = vector3DFormat.parse(source);        Assert.assertEquals(Vector3D.POSITIVE_INFINITY, actual);    }    @Test    public void testParseNegativeInfinity() {        String source = "{(-Infinity); (-Infinity); (-Infinity)}";        Vector3D actual = vector3DFormat.parse(source);        Assert.assertEquals(Vector3D.NEGATIVE_INFINITY, actual);    }    @Test    public void testConstructorSingleFormat() {        NumberFormat nf = NumberFormat.getInstance();        Vector3DFormat cf = new Vector3DFormat(nf);        Assert.assertNotNull(cf);        Assert.assertEquals(nf, cf.getFormat());    }    @Test    public void testForgottenPrefix() {        ParsePosition pos = new ParsePosition(0);        Assert.assertNull(new Vector3DFormat().parse("1; 1; 1}", pos));        Assert.assertEquals(0, pos.getErrorIndex());    }    @Test    public void testForgottenSeparator() {        ParsePosition pos = new ParsePosition(0);        Assert.assertNull(new Vector3DFormat().parse("{1; 1 1}", pos));        Assert.assertEquals(6, pos.getErrorIndex());    }    @Test    public void testForgottenSuffix() {        ParsePosition pos = new ParsePosition(0);        Assert.assertNull(new Vector3DFormat().parse("{1; 1; 1 ", pos));        Assert.assertEquals(8, pos.getErrorIndex());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry.euclidean.threed;import java.util.Locale;public class FrenchVector3DFormatTest extends Vector3DFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return ',';    }    @Override    protected Locale getLocale() {        return Locale.FRENCH;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry.euclidean.threed;import org.apache.commons.math.geometry.euclidean.twod.PolygonsSet;import org.apache.commons.math.geometry.euclidean.twod.Vector2D;import org.apache.commons.math.geometry.partitioning.BSPTree;import org.apache.commons.math.geometry.partitioning.BSPTreeVisitor;import org.apache.commons.math.geometry.partitioning.BoundaryAttribute;import org.apache.commons.math.geometry.partitioning.Region;import org.apache.commons.math.geometry.partitioning.RegionFactory;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class PolyhedronsSetTest {    @Test    public void testBox() {        PolyhedronsSet tree = new PolyhedronsSet(0, 1, 0, 1, 0, 1);        Assert.assertEquals(1.0, tree.getSize(), 1.0e-10);        Assert.assertEquals(6.0, tree.getBoundarySize(), 1.0e-10);        Vector3D barycenter = (Vector3D) tree.getBarycenter();        Assert.assertEquals(0.5, barycenter.getX(), 1.0e-10);        Assert.assertEquals(0.5, barycenter.getY(), 1.0e-10);        Assert.assertEquals(0.5, barycenter.getZ(), 1.0e-10);        for (double x = -0.25; x < 1.25; x += 0.1) {            boolean xOK = (x >= 0.0) && (x <= 1.0);            for (double y = -0.25; y < 1.25; y += 0.1) {                boolean yOK = (y >= 0.0) && (y <= 1.0);                for (double z = -0.25; z < 1.25; z += 0.1) {                    boolean zOK = (z >= 0.0) && (z <= 1.0);                    Region.Location expected =                        (xOK && yOK && zOK) ? Region.Location.INSIDE : Region.Location.OUTSIDE;                    Assert.assertEquals(expected, tree.checkPoint(new Vector3D(x, y, z)));                }            }        }        checkPoints(Region.Location.BOUNDARY, tree, new Vector3D[] {            new Vector3D(0.0, 0.5, 0.5),            new Vector3D(1.0, 0.5, 0.5),            new Vector3D(0.5, 0.0, 0.5),            new Vector3D(0.5, 1.0, 0.5),            new Vector3D(0.5, 0.5, 0.0),            new Vector3D(0.5, 0.5, 1.0)        });        checkPoints(Region.Location.OUTSIDE, tree, new Vector3D[] {            new Vector3D(0.0, 1.2, 1.2),            new Vector3D(1.0, 1.2, 1.2),            new Vector3D(1.2, 0.0, 1.2),            new Vector3D(1.2, 1.0, 1.2),            new Vector3D(1.2, 1.2, 0.0),            new Vector3D(1.2, 1.2, 1.0)        });    }    @Test    public void testTetrahedron() {        Vector3D vertex1 = new Vector3D(1, 2, 3);        Vector3D vertex2 = new Vector3D(2, 2, 4);        Vector3D vertex3 = new Vector3D(2, 3, 3);        Vector3D vertex4 = new Vector3D(1, 3, 4);        @SuppressWarnings("unchecked")        PolyhedronsSet tree =            (PolyhedronsSet) new RegionFactory<Euclidean3D>().buildConvex(                new Plane(vertex3, vertex2, vertex1),                new Plane(vertex2, vertex3, vertex4),                new Plane(vertex4, vertex3, vertex1),                new Plane(vertex1, vertex2, vertex4));        Assert.assertEquals(1.0 / 3.0, tree.getSize(), 1.0e-10);        Assert.assertEquals(2.0 * FastMath.sqrt(3.0), tree.getBoundarySize(), 1.0e-10);        Vector3D barycenter = (Vector3D) tree.getBarycenter();        Assert.assertEquals(1.5, barycenter.getX(), 1.0e-10);        Assert.assertEquals(2.5, barycenter.getY(), 1.0e-10);        Assert.assertEquals(3.5, barycenter.getZ(), 1.0e-10);        double third = 1.0 / 3.0;        checkPoints(Region.Location.BOUNDARY, tree, new Vector3D[] {            vertex1, vertex2, vertex3, vertex4,            new Vector3D(third, vertex1, third, vertex2, third, vertex3),            new Vector3D(third, vertex2, third, vertex3, third, vertex4),            new Vector3D(third, vertex3, third, vertex4, third, vertex1),            new Vector3D(third, vertex4, third, vertex1, third, vertex2)        });        checkPoints(Region.Location.OUTSIDE, tree, new Vector3D[] {            new Vector3D(1, 2, 4),            new Vector3D(2, 2, 3),            new Vector3D(2, 3, 4),            new Vector3D(1, 3, 3)        });    }    @Test    public void testIsometry() {        Vector3D vertex1 = new Vector3D(1.1, 2.2, 3.3);        Vector3D vertex2 = new Vector3D(2.0, 2.4, 4.2);        Vector3D vertex3 = new Vector3D(2.8, 3.3, 3.7);        Vector3D vertex4 = new Vector3D(1.0, 3.6, 4.5);        @SuppressWarnings("unchecked")        PolyhedronsSet tree =            (PolyhedronsSet) new RegionFactory<Euclidean3D>().buildConvex(                new Plane(vertex3, vertex2, vertex1),                new Plane(vertex2, vertex3, vertex4),                new Plane(vertex4, vertex3, vertex1),                new Plane(vertex1, vertex2, vertex4));        Vector3D barycenter = (Vector3D) tree.getBarycenter();        Vector3D s = new Vector3D(10.2, 4.3, -6.7);        Vector3D c = new Vector3D(-0.2, 2.1, -3.2);        Rotation r = new Rotation(new Vector3D(6.2, -4.4, 2.1), 0.12);        tree = tree.rotate(c, r).translate(s);        Vector3D newB =            new Vector3D(1.0, s,                         1.0, c,                         1.0, r.applyTo(barycenter.subtract(c)));        Assert.assertEquals(0.0,                            newB.subtract(tree.getBarycenter()).getNorm(),                            1.0e-10);        final Vector3D[] expectedV = new Vector3D[] {            new Vector3D(1.0, s,                         1.0, c,                         1.0, r.applyTo(vertex1.subtract(c))),                         new Vector3D(1.0, s,                                      1.0, c,                                      1.0, r.applyTo(vertex2.subtract(c))),                                      new Vector3D(1.0, s,                                                   1.0, c,                                                   1.0, r.applyTo(vertex3.subtract(c))),                                                   new Vector3D(1.0, s,                                                                1.0, c,                                                                1.0, r.applyTo(vertex4.subtract(c)))        };        tree.getTree(true).visit(new BSPTreeVisitor<Euclidean3D>() {            public Order visitOrder(BSPTree<Euclidean3D> node) {                return Order.MINUS_SUB_PLUS;            }            public void visitInternalNode(BSPTree<Euclidean3D> node) {                @SuppressWarnings("unchecked")                BoundaryAttribute<Euclidean3D> attribute =                    (BoundaryAttribute<Euclidean3D>) node.getAttribute();                if (attribute.getPlusOutside() != null) {                    checkFacet((SubPlane) attribute.getPlusOutside());                }                if (attribute.getPlusInside() != null) {                    checkFacet((SubPlane) attribute.getPlusInside());                }            }            public void visitLeafNode(BSPTree<Euclidean3D> node) {            }            private void checkFacet(SubPlane facet) {                Plane plane = (Plane) facet.getHyperplane();                Vector2D[][] vertices =                    ((PolygonsSet) facet.getRemainingRegion()).getVertices();                Assert.assertEquals(1, vertices.length);                for (int i = 0; i < vertices[0].length; ++i) {                    Vector3D v = plane.toSpace(vertices[0][i]);                    double d = Double.POSITIVE_INFINITY;                    for (int k = 0; k < expectedV.length; ++k) {                        d = FastMath.min(d, v.subtract(expectedV[k]).getNorm());                    }                    Assert.assertEquals(0, d, 1.0e-10);                }            }        });    }    @Test    public void testBuildBox() {        double x = 1.0;        double y = 2.0;        double z = 3.0;        double w = 0.1;        double l = 1.0;        PolyhedronsSet tree =            new PolyhedronsSet(x - l, x + l, y - w, y + w, z - w, z + w);        Vector3D barycenter = (Vector3D) tree.getBarycenter();        Assert.assertEquals(x, barycenter.getX(), 1.0e-10);        Assert.assertEquals(y, barycenter.getY(), 1.0e-10);        Assert.assertEquals(z, barycenter.getZ(), 1.0e-10);        Assert.assertEquals(8 * l * w * w, tree.getSize(), 1.0e-10);        Assert.assertEquals(8 * w * (2 * l + w), tree.getBoundarySize(), 1.0e-10);    }    @Test    public void testCross() {        double x = 1.0;        double y = 2.0;        double z = 3.0;        double w = 0.1;        double l = 1.0;        PolyhedronsSet xBeam =            new PolyhedronsSet(x - l, x + l, y - w, y + w, z - w, z + w);        PolyhedronsSet yBeam =            new PolyhedronsSet(x - w, x + w, y - l, y + l, z - w, z + w);        PolyhedronsSet zBeam =            new PolyhedronsSet(x - w, x + w, y - w, y + w, z - l, z + l);        RegionFactory<Euclidean3D> factory = new RegionFactory<Euclidean3D>();        PolyhedronsSet tree = (PolyhedronsSet) factory.union(xBeam, factory.union(yBeam, zBeam));        Vector3D barycenter = (Vector3D) tree.getBarycenter();        Assert.assertEquals(x, barycenter.getX(), 1.0e-10);        Assert.assertEquals(y, barycenter.getY(), 1.0e-10);        Assert.assertEquals(z, barycenter.getZ(), 1.0e-10);        Assert.assertEquals(8 * w * w * (3 * l - 2 * w), tree.getSize(), 1.0e-10);        Assert.assertEquals(24 * w * (2 * l - w), tree.getBoundarySize(), 1.0e-10);    }    private void checkPoints(Region.Location expected, PolyhedronsSet tree, Vector3D[] points) {        for (int i = 0; i < points.length; ++i) {            Assert.assertEquals(expected, tree.checkPoint(points[i]));        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry.euclidean.threed;import java.lang.reflect.Field;import org.apache.commons.math.geometry.euclidean.threed.RotationOrder;import org.junit.Assert;import org.junit.Test;public class RotationOrderTest {  @Test  public void testName() {    RotationOrder[] orders = {      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX,      RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,      RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ    };    for (int i = 0; i < orders.length; ++i) {      Assert.assertEquals(getFieldName(orders[i]), orders[i].toString());    }  }  private String getFieldName(RotationOrder order) {    try {      Field[] fields = RotationOrder.class.getFields();      for (int i = 0; i < fields.length; ++i) {        if (fields[i].get(null) == order) {          return fields[i].getName();        }      }    } catch (IllegalAccessException iae) {      // ignored    }    return "unknown";  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry.euclidean.threed;import java.util.List;import org.apache.commons.math.geometry.euclidean.oned.Euclidean1D;import org.apache.commons.math.geometry.euclidean.oned.IntervalsSet;import org.apache.commons.math.geometry.partitioning.RegionFactory;import org.junit.Assert;import org.junit.Test;public class SubLineTest {    @Test    public void testEndPoints() {        Vector3D p1 = new Vector3D(-1, -7, 2);        Vector3D p2 = new Vector3D(7, -1, 0);        Segment segment = new Segment(p1, p2, new Line(p1, p2));        SubLine sub = new SubLine(segment);        List<Segment> segments = sub.getSegments();        Assert.assertEquals(1, segments.size());        Assert.assertEquals(0.0, new Vector3D(-1, -7, 2).distance(segments.get(0).getStart()), 1.0e-10);        Assert.assertEquals(0.0, new Vector3D( 7, -1, 0).distance(segments.get(0).getEnd()), 1.0e-10);    }    @Test    public void testNoEndPoints() {        SubLine wholeLine = new Line(new Vector3D(-1, 7, 2), new Vector3D(7, 1, 0)).wholeLine();        List<Segment> segments = wholeLine.getSegments();        Assert.assertEquals(1, segments.size());        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX()) &&                          segments.get(0).getStart().getX() < 0);        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY()) &&                          segments.get(0).getStart().getY() > 0);        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getZ()) &&                          segments.get(0).getStart().getZ() > 0);        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX()) &&                          segments.get(0).getEnd().getX() > 0);        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY()) &&                          segments.get(0).getEnd().getY() < 0);        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getZ()) &&                          segments.get(0).getEnd().getZ() < 0);    }    @Test    public void testNoSegments() {        SubLine empty = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, 0)),                                    (IntervalsSet) new RegionFactory<Euclidean1D>().getComplement(new IntervalsSet()));        List<Segment> segments = empty.getSegments();        Assert.assertEquals(0, segments.size());    }    @Test    public void testSeveralSegments() {        SubLine twoSubs = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, 0)),                                      (IntervalsSet) new RegionFactory<Euclidean1D>().union(new IntervalsSet(1, 2),                                                                                            new IntervalsSet(3, 4)));        List<Segment> segments = twoSubs.getSegments();        Assert.assertEquals(2, segments.size());    }    @Test    public void testHalfInfiniteNeg() {        SubLine empty = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, -2)),                                    new IntervalsSet(Double.NEGATIVE_INFINITY, 0.0));        List<Segment> segments = empty.getSegments();        Assert.assertEquals(1, segments.size());        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX()) &&                          segments.get(0).getStart().getX() < 0);        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY()) &&                          segments.get(0).getStart().getY() < 0);        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getZ()) &&                          segments.get(0).getStart().getZ() > 0);        Assert.assertEquals(0.0, new Vector3D(3, -4, 0).distance(segments.get(0).getEnd()), 1.0e-10);    }    @Test    public void testHalfInfinitePos() {        SubLine empty = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, -2)),                                    new IntervalsSet(0.0, Double.POSITIVE_INFINITY));        List<Segment> segments = empty.getSegments();        Assert.assertEquals(1, segments.size());        Assert.assertEquals(0.0, new Vector3D(3, -4, 0).distance(segments.get(0).getStart()), 1.0e-10);        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX()) &&                          segments.get(0).getEnd().getX() > 0);        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY()) &&                          segments.get(0).getEnd().getY() > 0);        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getZ()) &&                          segments.get(0).getEnd().getZ() < 0);    }    @Test    public void testIntersectionInsideInside() {        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(3, 1, 1));        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 2, 2));        Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);        Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, false)), 1.0e-12);    }    @Test    public void testIntersectionInsideBoundary() {        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(3, 1, 1));        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 1, 1));        Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);        Assert.assertNull(sub1.intersection(sub2, false));    }    @Test    public void testIntersectionInsideOutside() {        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(3, 1, 1));        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 0.5, 0.5));        Assert.assertNull(sub1.intersection(sub2, true));        Assert.assertNull(sub1.intersection(sub2, false));    }    @Test    public void testIntersectionBoundaryBoundary() {        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(2, 1, 1));        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 1, 1));        Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);        Assert.assertNull(sub1.intersection(sub2, false));    }    @Test    public void testIntersectionBoundaryOutside() {        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(2, 1, 1));        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 0.5, 0.5));        Assert.assertNull(sub1.intersection(sub2, true));        Assert.assertNull(sub1.intersection(sub2, false));    }    @Test    public void testIntersectionOutsideOutside() {        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(1.5, 1, 1));        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 0.5, 0.5));        Assert.assertNull(sub1.intersection(sub2, true));        Assert.assertNull(sub1.intersection(sub2, false));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry.euclidean.threed;import org.apache.commons.math.geometry.euclidean.threed.Line;import org.apache.commons.math.geometry.euclidean.threed.Plane;import org.apache.commons.math.geometry.euclidean.threed.Rotation;import org.apache.commons.math.geometry.euclidean.threed.Vector3D;import org.junit.Assert;import org.junit.Test;public class PlaneTest {    @Test    public void testContains() {        Plane p = new Plane(new Vector3D(0, 0, 1), new Vector3D(0, 0, 1));        Assert.assertTrue(p.contains(new Vector3D(0, 0, 1)));        Assert.assertTrue(p.contains(new Vector3D(17, -32, 1)));        Assert.assertTrue(! p.contains(new Vector3D(17, -32, 1.001)));    }    @Test    public void testOffset() {        Vector3D p1 = new Vector3D(1, 1, 1);        Plane p = new Plane(p1, new Vector3D(0.2, 0, 0));        Assert.assertEquals(-5.0, p.getOffset(new Vector3D(-4, 0, 0)), 1.0e-10);        Assert.assertEquals(+5.0, p.getOffset(new Vector3D(6, 10, -12)), 1.0e-10);        Assert.assertEquals(0.3,                            p.getOffset(new Vector3D(1.0, p1, 0.3, p.getNormal())),                            1.0e-10);        Assert.assertEquals(-0.3,                            p.getOffset(new Vector3D(1.0, p1, -0.3, p.getNormal())),                            1.0e-10);    }    @Test    public void testPoint() {        Plane p = new Plane(new Vector3D(2, -3, 1), new Vector3D(1, 4, 9));        Assert.assertTrue(p.contains(p.getOrigin()));    }    @Test    public void testThreePoints() {        Vector3D p1 = new Vector3D(1.2, 3.4, -5.8);        Vector3D p2 = new Vector3D(3.4, -5.8, 1.2);        Vector3D p3 = new Vector3D(-2.0, 4.3, 0.7);        Plane    p  = new Plane(p1, p2, p3);        Assert.assertTrue(p.contains(p1));        Assert.assertTrue(p.contains(p2));        Assert.assertTrue(p.contains(p3));    }    @Test    public void testRotate() {        Vector3D p1 = new Vector3D(1.2, 3.4, -5.8);        Vector3D p2 = new Vector3D(3.4, -5.8, 1.2);        Vector3D p3 = new Vector3D(-2.0, 4.3, 0.7);        Plane    p  = new Plane(p1, p2, p3);        Vector3D oldNormal = p.getNormal();        p = p.rotate(p2, new Rotation(p2.subtract(p1), 1.7));        Assert.assertTrue(p.contains(p1));        Assert.assertTrue(p.contains(p2));        Assert.assertTrue(! p.contains(p3));        p = p.rotate(p2, new Rotation(oldNormal, 0.1));        Assert.assertTrue(! p.contains(p1));        Assert.assertTrue(p.contains(p2));        Assert.assertTrue(! p.contains(p3));        p = p.rotate(p1, new Rotation(oldNormal, 0.1));        Assert.assertTrue(! p.contains(p1));        Assert.assertTrue(! p.contains(p2));        Assert.assertTrue(! p.contains(p3));    }    @Test    public void testTranslate() {        Vector3D p1 = new Vector3D(1.2, 3.4, -5.8);        Vector3D p2 = new Vector3D(3.4, -5.8, 1.2);        Vector3D p3 = new Vector3D(-2.0, 4.3, 0.7);        Plane    p  = new Plane(p1, p2, p3);        p = p.translate(new Vector3D(2.0, p.getU(), -1.5, p.getV()));        Assert.assertTrue(p.contains(p1));        Assert.assertTrue(p.contains(p2));        Assert.assertTrue(p.contains(p3));        p = p.translate(new Vector3D(-1.2, p.getNormal()));        Assert.assertTrue(! p.contains(p1));        Assert.assertTrue(! p.contains(p2));        Assert.assertTrue(! p.contains(p3));        p = p.translate(new Vector3D(+1.2, p.getNormal()));        Assert.assertTrue(p.contains(p1));        Assert.assertTrue(p.contains(p2));        Assert.assertTrue(p.contains(p3));    }    @Test    public void testIntersection() {        Plane p = new Plane(new Vector3D(1, 2, 3), new Vector3D(-4, 1, -5));        Line  l = new Line(new Vector3D(0.2, -3.5, 0.7), new Vector3D(1.2, -2.5, -0.3));        Vector3D point = p.intersection(l);        Assert.assertTrue(p.contains(point));        Assert.assertTrue(l.contains(point));        Assert.assertNull(p.intersection(new Line(new Vector3D(10, 10, 10),                                                  new Vector3D(10, 10, 10).add(p.getNormal().orthogonal()))));    }    @Test    public void testIntersection2() {        Vector3D p1  = new Vector3D (1.2, 3.4, -5.8);        Vector3D p2  = new Vector3D (3.4, -5.8, 1.2);        Plane    pA  = new Plane(p1, p2, new Vector3D (-2.0, 4.3, 0.7));        Plane    pB  = new Plane(p1, new Vector3D (11.4, -3.8, 5.1), p2);        Line     l   = pA.intersection(pB);        Assert.assertTrue(l.contains(p1));        Assert.assertTrue(l.contains(p2));        Assert.assertNull(pA.intersection(pA));    }    @Test    public void testIntersection3() {        Vector3D reference = new Vector3D (1.2, 3.4, -5.8);        Plane p1 = new Plane(reference, new Vector3D(1, 3, 3));        Plane p2 = new Plane(reference, new Vector3D(-2, 4, 0));        Plane p3 = new Plane(reference, new Vector3D(7, 0, -4));        Vector3D p = Plane.intersection(p1, p2, p3);        Assert.assertEquals(reference.getX(), p.getX(), 1.0e-10);        Assert.assertEquals(reference.getY(), p.getY(), 1.0e-10);        Assert.assertEquals(reference.getZ(), p.getZ(), 1.0e-10);    }    @Test    public void testSimilar() {        Vector3D p1  = new Vector3D (1.2, 3.4, -5.8);        Vector3D p2  = new Vector3D (3.4, -5.8, 1.2);        Vector3D p3  = new Vector3D (-2.0, 4.3, 0.7);        Plane    pA  = new Plane(p1, p2, p3);        Plane    pB  = new Plane(p1, new Vector3D (11.4, -3.8, 5.1), p2);        Assert.assertTrue(! pA.isSimilarTo(pB));        Assert.assertTrue(pA.isSimilarTo(pA));        Assert.assertTrue(pA.isSimilarTo(new Plane(p1, p3, p2)));        Vector3D shift = new Vector3D(0.3, pA.getNormal());        Assert.assertTrue(! pA.isSimilarTo(new Plane(p1.add(shift),                                                     p3.add(shift),                                                     p2.add(shift))));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry.euclidean.threed;import org.apache.commons.math.geometry.euclidean.threed.Line;import org.apache.commons.math.geometry.euclidean.threed.Vector3D;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class LineTest {    @Test    public void testContains() {        Vector3D p1 = new Vector3D(0, 0, 1);        Line l = new Line(p1, new Vector3D(0, 0, 2));        Assert.assertTrue(l.contains(p1));        Assert.assertTrue(l.contains(new Vector3D(1.0, p1, 0.3, l.getDirection())));        Vector3D u = l.getDirection().orthogonal();        Vector3D v = Vector3D.crossProduct(l.getDirection(), u);        for (double alpha = 0; alpha < 2 * FastMath.PI; alpha += 0.3) {            Assert.assertTrue(! l.contains(p1.add(new Vector3D(FastMath.cos(alpha), u,                                                               FastMath.sin(alpha), v))));        }    }    @Test    public void testSimilar() {        Vector3D p1  = new Vector3D (1.2, 3.4, -5.8);        Vector3D p2  = new Vector3D (3.4, -5.8, 1.2);        Line     lA  = new Line(p1, p2);        Line     lB  = new Line(p2, p1);        Assert.assertTrue(lA.isSimilarTo(lB));        Assert.assertTrue(! lA.isSimilarTo(new Line(p1, p1.add(lA.getDirection().orthogonal()))));    }    @Test    public void testPointDistance() {        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2));        Assert.assertEquals(FastMath.sqrt(3.0 / 2.0), l.distance(new Vector3D(1, 0, 1)), 1.0e-10);        Assert.assertEquals(0, l.distance(new Vector3D(0, -4, -4)), 1.0e-10);    }    @Test    public void testLineDistance() {        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2));        Assert.assertEquals(1.0,                            l.distance(new Line(new Vector3D(1, 0, 1), new Vector3D(1, 0, 2))),                            1.0e-10);        Assert.assertEquals(0.5,                            l.distance(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(-0.5, -1, -1))),                            1.0e-10);        Assert.assertEquals(0.0,                            l.distance(l),                            1.0e-10);        Assert.assertEquals(0.0,                            l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -5, -5))),                            1.0e-10);        Assert.assertEquals(0.0,                            l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -3, -4))),                            1.0e-10);        Assert.assertEquals(0.0,                            l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(1, -4, -4))),                            1.0e-10);        Assert.assertEquals(FastMath.sqrt(8),                            l.distance(new Line(new Vector3D(0, -4, 0), new Vector3D(1, -4, 0))),                            1.0e-10);    }    @Test    public void testClosest() {        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2));        Assert.assertEquals(0.0,                            l.closestPoint(new Line(new Vector3D(1, 0, 1), new Vector3D(1, 0, 2))).distance(new Vector3D(0, 0, 0)),                            1.0e-10);        Assert.assertEquals(0.5,                            l.closestPoint(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(-0.5, -1, -1))).distance(new Vector3D(-0.5, 0, 0)),                            1.0e-10);        Assert.assertEquals(0.0,                            l.closestPoint(l).distance(new Vector3D(0, 0, 0)),                            1.0e-10);        Assert.assertEquals(0.0,                            l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -5, -5))).distance(new Vector3D(0, 0, 0)),                            1.0e-10);        Assert.assertEquals(0.0,                            l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -3, -4))).distance(new Vector3D(0, -4, -4)),                            1.0e-10);        Assert.assertEquals(0.0,                            l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(1, -4, -4))).distance(new Vector3D(0, -4, -4)),                            1.0e-10);        Assert.assertEquals(0.0,                            l.closestPoint(new Line(new Vector3D(0, -4, 0), new Vector3D(1, -4, 0))).distance(new Vector3D(0, -2, -2)),                            1.0e-10);    }    @Test    public void testIntersection() {        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2));        Assert.assertNull(l.intersection(new Line(new Vector3D(1, 0, 1), new Vector3D(1, 0, 2))));        Assert.assertNull(l.intersection(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(-0.5, -1, -1))));        Assert.assertEquals(0.0,                            l.intersection(l).distance(new Vector3D(0, 0, 0)),                            1.0e-10);        Assert.assertEquals(0.0,                            l.intersection(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -5, -5))).distance(new Vector3D(0, 0, 0)),                            1.0e-10);        Assert.assertEquals(0.0,                            l.intersection(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -3, -4))).distance(new Vector3D(0, -4, -4)),                            1.0e-10);        Assert.assertEquals(0.0,                            l.intersection(new Line(new Vector3D(0, -4, -4), new Vector3D(1, -4, -4))).distance(new Vector3D(0, -4, -4)),                            1.0e-10);        Assert.assertNull(l.intersection(new Line(new Vector3D(0, -4, 0), new Vector3D(1, -4, 0))));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry.euclidean.oned;import java.util.List;import org.apache.commons.math.geometry.euclidean.oned.Interval;import org.apache.commons.math.geometry.euclidean.oned.IntervalsSet;import org.apache.commons.math.geometry.euclidean.oned.Vector1D;import org.apache.commons.math.geometry.partitioning.Region;import org.apache.commons.math.geometry.partitioning.RegionFactory;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class IntervalsSetTest {    @Test    public void testInterval() {        IntervalsSet set = new IntervalsSet(2.3, 5.7);        Assert.assertEquals(3.4, set.getSize(), 1.0e-10);        Assert.assertEquals(4.0, ((Vector1D) set.getBarycenter()).getX(), 1.0e-10);        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(2.3)));        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(5.7)));        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(1.2)));        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(8.7)));        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Vector1D(3.0)));        Assert.assertEquals(2.3, set.getInf(), 1.0e-10);        Assert.assertEquals(5.7, set.getSup(), 1.0e-10);    }    @Test    public void testInfinite() {        IntervalsSet set = new IntervalsSet(9.0, Double.POSITIVE_INFINITY);        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(9.0)));        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(8.4)));        for (double e = 1.0; e <= 6.0; e += 1.0) {            Assert.assertEquals(Region.Location.INSIDE,                                set.checkPoint(new Vector1D(FastMath.pow(10.0, e))));        }        Assert.assertTrue(Double.isInfinite(set.getSize()));        Assert.assertEquals(9.0, set.getInf(), 1.0e-10);        Assert.assertTrue(Double.isInfinite(set.getSup()));        set = (IntervalsSet) new RegionFactory<Euclidean1D>().getComplement(set);        Assert.assertEquals(9.0, set.getSup(), 1.0e-10);        Assert.assertTrue(Double.isInfinite(set.getInf()));    }    @Test    public void testMultiple() {        RegionFactory<Euclidean1D> factory = new RegionFactory<Euclidean1D>();        IntervalsSet set = (IntervalsSet)        factory.intersection(factory.union(factory.difference(new IntervalsSet(1.0, 6.0),                                                              new IntervalsSet(3.0, 5.0)),                                                              new IntervalsSet(9.0, Double.POSITIVE_INFINITY)),                                                              new IntervalsSet(Double.NEGATIVE_INFINITY, 11.0));        Assert.assertEquals(5.0, set.getSize(), 1.0e-10);        Assert.assertEquals(5.9, ((Vector1D) set.getBarycenter()).getX(), 1.0e-10);        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(0.0)));        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(4.0)));        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(8.0)));        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Vector1D(12.0)));        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Vector1D(1.2)));        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Vector1D(5.9)));        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Vector1D(9.01)));        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(5.0)));        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(11.0)));        Assert.assertEquals( 1.0, set.getInf(), 1.0e-10);        Assert.assertEquals(11.0, set.getSup(), 1.0e-10);        List<Interval> list = set.asList();        Assert.assertEquals(3, list.size());        Assert.assertEquals( 1.0, list.get(0).getLower(), 1.0e-10);        Assert.assertEquals( 3.0, list.get(0).getUpper(), 1.0e-10);        Assert.assertEquals( 5.0, list.get(1).getLower(), 1.0e-10);        Assert.assertEquals( 6.0, list.get(1).getUpper(), 1.0e-10);        Assert.assertEquals( 9.0, list.get(2).getLower(), 1.0e-10);        Assert.assertEquals(11.0, list.get(2).getUpper(), 1.0e-10);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry.euclidean.twod;import java.util.ArrayList;import java.util.List;import org.apache.commons.math.geometry.euclidean.oned.Interval;import org.apache.commons.math.geometry.euclidean.oned.IntervalsSet;import org.apache.commons.math.geometry.euclidean.oned.Vector1D;import org.apache.commons.math.geometry.euclidean.twod.Line;import org.apache.commons.math.geometry.euclidean.twod.Vector2D;import org.apache.commons.math.geometry.euclidean.twod.PolygonsSet;import org.apache.commons.math.geometry.partitioning.BSPTree;import org.apache.commons.math.geometry.partitioning.Region;import org.apache.commons.math.geometry.partitioning.RegionFactory;import org.apache.commons.math.geometry.partitioning.SubHyperplane;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class PolygonsSetTest {    @Test    public void testSimplyConnected() {        Vector2D[][] vertices = new Vector2D[][] {            new Vector2D[] {                new Vector2D(36.0, 22.0),                new Vector2D(39.0, 32.0),                new Vector2D(19.0, 32.0),                new Vector2D( 6.0, 16.0),                new Vector2D(31.0, 10.0),                new Vector2D(42.0, 16.0),                new Vector2D(34.0, 20.0),                new Vector2D(29.0, 19.0),                new Vector2D(23.0, 22.0),                new Vector2D(33.0, 25.0)            }        };        PolygonsSet set = buildSet(vertices);        Assert.assertEquals(Region.Location.OUTSIDE, set.checkPoint(new Vector2D(50.0, 30.0)));        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {            new Vector2D(30.0, 15.0),            new Vector2D(15.0, 20.0),            new Vector2D(24.0, 25.0),            new Vector2D(35.0, 30.0),            new Vector2D(19.0, 17.0)        });        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {            new Vector2D(50.0, 30.0),            new Vector2D(30.0, 35.0),            new Vector2D(10.0, 25.0),            new Vector2D(10.0, 10.0),            new Vector2D(40.0, 10.0),            new Vector2D(50.0, 15.0),            new Vector2D(30.0, 22.0)        });        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {            new Vector2D(30.0, 32.0),            new Vector2D(34.0, 20.0)        });        checkVertices(set.getVertices(), vertices);    }    @Test    public void testStair() {        Vector2D[][] vertices = new Vector2D[][] {            new Vector2D[] {                new Vector2D( 0.0, 0.0),                new Vector2D( 0.0, 2.0),                new Vector2D(-0.1, 2.0),                new Vector2D(-0.1, 1.0),                new Vector2D(-0.3, 1.0),                new Vector2D(-0.3, 1.5),                new Vector2D(-1.3, 1.5),                new Vector2D(-1.3, 2.0),                new Vector2D(-1.8, 2.0),                new Vector2D(-1.8 - 1.0 / FastMath.sqrt(2.0),                            2.0 - 1.0 / FastMath.sqrt(2.0))            }        };        PolygonsSet set = buildSet(vertices);        checkVertices(set.getVertices(), vertices);        Assert.assertEquals(1.1 + 0.95 * FastMath.sqrt(2.0), set.getSize(), 1.0e-10);    }    @Test    public void testHole() {        Vector2D[][] vertices = new Vector2D[][] {            new Vector2D[] {                new Vector2D(0.0, 0.0),                new Vector2D(3.0, 0.0),                new Vector2D(3.0, 3.0),                new Vector2D(0.0, 3.0)            }, new Vector2D[] {                new Vector2D(1.0, 2.0),                new Vector2D(2.0, 2.0),                new Vector2D(2.0, 1.0),                new Vector2D(1.0, 1.0)            }        };        PolygonsSet set = buildSet(vertices);        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {            new Vector2D(0.5, 0.5),            new Vector2D(1.5, 0.5),            new Vector2D(2.5, 0.5),            new Vector2D(0.5, 1.5),            new Vector2D(2.5, 1.5),            new Vector2D(0.5, 2.5),            new Vector2D(1.5, 2.5),            new Vector2D(2.5, 2.5),            new Vector2D(0.5, 1.0)        });        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {            new Vector2D(1.5, 1.5),            new Vector2D(3.5, 1.0),            new Vector2D(4.0, 1.5),            new Vector2D(6.0, 6.0)        });        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {            new Vector2D(1.0, 1.0),            new Vector2D(1.5, 0.0),            new Vector2D(1.5, 1.0),            new Vector2D(1.5, 2.0),            new Vector2D(1.5, 3.0),            new Vector2D(3.0, 3.0)        });        checkVertices(set.getVertices(), vertices);    }    @Test    public void testDisjointPolygons() {        Vector2D[][] vertices = new Vector2D[][] {            new Vector2D[] {                new Vector2D(0.0, 1.0),                new Vector2D(2.0, 1.0),                new Vector2D(1.0, 2.0)            }, new Vector2D[] {                new Vector2D(4.0, 0.0),                new Vector2D(5.0, 1.0),                new Vector2D(3.0, 1.0)            }        };        PolygonsSet set = buildSet(vertices);        Assert.assertEquals(Region.Location.INSIDE, set.checkPoint(new Vector2D(1.0, 1.5)));        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {            new Vector2D(1.0, 1.5),            new Vector2D(4.5, 0.8)        });        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {            new Vector2D(1.0, 0.0),            new Vector2D(3.5, 1.2),            new Vector2D(2.5, 1.0),            new Vector2D(3.0, 4.0)        });        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {            new Vector2D(1.0, 1.0),            new Vector2D(3.5, 0.5),            new Vector2D(0.0, 1.0)        });        checkVertices(set.getVertices(), vertices);    }    @Test    public void testOppositeHyperplanes() {        Vector2D[][] vertices = new Vector2D[][] {            new Vector2D[] {                new Vector2D(1.0, 0.0),                new Vector2D(2.0, 1.0),                new Vector2D(3.0, 1.0),                new Vector2D(2.0, 2.0),                new Vector2D(1.0, 1.0),                new Vector2D(0.0, 1.0)            }        };        PolygonsSet set = buildSet(vertices);        checkVertices(set.getVertices(), vertices);    }    @Test    public void testSingularPoint() {        Vector2D[][] vertices = new Vector2D[][] {            new Vector2D[] {                new Vector2D( 0.0,  0.0),                new Vector2D( 1.0,  0.0),                new Vector2D( 1.0,  1.0),                new Vector2D( 0.0,  1.0),                new Vector2D( 0.0,  0.0),                new Vector2D(-1.0,  0.0),                new Vector2D(-1.0, -1.0),                new Vector2D( 0.0, -1.0)            }        };        PolygonsSet set = buildSet(vertices);        checkVertices(set.getVertices(), vertices);    }    @Test    public void testLineIntersection() {        Vector2D[][] vertices = new Vector2D[][] {            new Vector2D[] {                new Vector2D( 0.0,  0.0),                new Vector2D( 2.0,  0.0),                new Vector2D( 2.0,  1.0),                new Vector2D( 3.0,  1.0),                new Vector2D( 3.0,  3.0),                new Vector2D( 1.0,  3.0),                new Vector2D( 1.0,  2.0),                new Vector2D( 0.0,  2.0)            }        };        PolygonsSet set = buildSet(vertices);        Line l1 = new Line(new Vector2D(-1.5, 0.0), FastMath.PI / 4);        SubLine s1 = (SubLine) set.intersection(l1.wholeHyperplane());        List<Interval> i1 = ((IntervalsSet) s1.getRemainingRegion()).asList();        Assert.assertEquals(2, i1.size());        Interval v10 = i1.get(0);        Vector2D p10Lower = l1.toSpace(new Vector1D(v10.getLower()));        Assert.assertEquals(0.0, p10Lower.getX(), 1.0e-10);        Assert.assertEquals(1.5, p10Lower.getY(), 1.0e-10);        Vector2D p10Upper = l1.toSpace(new Vector1D(v10.getUpper()));        Assert.assertEquals(0.5, p10Upper.getX(), 1.0e-10);        Assert.assertEquals(2.0, p10Upper.getY(), 1.0e-10);        Interval v11 = i1.get(1);        Vector2D p11Lower = l1.toSpace(new Vector1D(v11.getLower()));        Assert.assertEquals(1.0, p11Lower.getX(), 1.0e-10);        Assert.assertEquals(2.5, p11Lower.getY(), 1.0e-10);        Vector2D p11Upper = l1.toSpace(new Vector1D(v11.getUpper()));        Assert.assertEquals(1.5, p11Upper.getX(), 1.0e-10);        Assert.assertEquals(3.0, p11Upper.getY(), 1.0e-10);        Line l2 = new Line(new Vector2D(-1.0, 2.0), 0);        SubLine s2 = (SubLine) set.intersection(l2.wholeHyperplane());        List<Interval> i2 = ((IntervalsSet) s2.getRemainingRegion()).asList();        Assert.assertEquals(1, i2.size());        Interval v20 = i2.get(0);        Vector2D p20Lower = l2.toSpace(new Vector1D(v20.getLower()));        Assert.assertEquals(1.0, p20Lower.getX(), 1.0e-10);        Assert.assertEquals(2.0, p20Lower.getY(), 1.0e-10);        Vector2D p20Upper = l2.toSpace(new Vector1D(v20.getUpper()));        Assert.assertEquals(3.0, p20Upper.getX(), 1.0e-10);        Assert.assertEquals(2.0, p20Upper.getY(), 1.0e-10);    }    @Test    public void testUnlimitedSubHyperplane() {        Vector2D[][] vertices1 = new Vector2D[][] {            new Vector2D[] {                new Vector2D(0.0, 0.0),                new Vector2D(4.0, 0.0),                new Vector2D(1.4, 1.5),                new Vector2D(0.0, 3.5)            }        };        PolygonsSet set1 = buildSet(vertices1);        Vector2D[][] vertices2 = new Vector2D[][] {            new Vector2D[] {                new Vector2D(1.4,  0.2),                new Vector2D(2.8, -1.2),                new Vector2D(2.5,  0.6)            }        };        PolygonsSet set2 = buildSet(vertices2);        PolygonsSet set =            (PolygonsSet) new RegionFactory<Euclidean2D>().union(set1.copySelf(),                                                                 set2.copySelf());        checkVertices(set1.getVertices(), vertices1);        checkVertices(set2.getVertices(), vertices2);        checkVertices(set.getVertices(), new Vector2D[][] {            new Vector2D[] {                new Vector2D(0.0,  0.0),                new Vector2D(1.6,  0.0),                new Vector2D(2.8, -1.2),                new Vector2D(2.6,  0.0),                new Vector2D(4.0,  0.0),                new Vector2D(1.4,  1.5),                new Vector2D(0.0,  3.5)            }        });    }    @Test    public void testUnion() {        Vector2D[][] vertices1 = new Vector2D[][] {            new Vector2D[] {                new Vector2D( 0.0,  0.0),                new Vector2D( 2.0,  0.0),                new Vector2D( 2.0,  2.0),                new Vector2D( 0.0,  2.0)            }        };        PolygonsSet set1 = buildSet(vertices1);        Vector2D[][] vertices2 = new Vector2D[][] {            new Vector2D[] {                new Vector2D( 1.0,  1.0),                new Vector2D( 3.0,  1.0),                new Vector2D( 3.0,  3.0),                new Vector2D( 1.0,  3.0)            }        };        PolygonsSet set2 = buildSet(vertices2);        PolygonsSet set  = (PolygonsSet) new RegionFactory<Euclidean2D>().union(set1.copySelf(),                                                                                set2.copySelf());        checkVertices(set1.getVertices(), vertices1);        checkVertices(set2.getVertices(), vertices2);        checkVertices(set.getVertices(), new Vector2D[][] {            new Vector2D[] {                new Vector2D( 0.0,  0.0),                new Vector2D( 2.0,  0.0),                new Vector2D( 2.0,  1.0),                new Vector2D( 3.0,  1.0),                new Vector2D( 3.0,  3.0),                new Vector2D( 1.0,  3.0),                new Vector2D( 1.0,  2.0),                new Vector2D( 0.0,  2.0)            }        });        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {            new Vector2D(1.0, 1.0),            new Vector2D(0.5, 0.5),            new Vector2D(2.0, 2.0),            new Vector2D(2.5, 2.5),            new Vector2D(0.5, 1.5),            new Vector2D(1.5, 1.5),            new Vector2D(1.5, 0.5),            new Vector2D(1.5, 2.5),            new Vector2D(2.5, 1.5),            new Vector2D(2.5, 2.5)        });        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {            new Vector2D(-0.5, 0.5),            new Vector2D( 0.5, 2.5),            new Vector2D( 2.5, 0.5),            new Vector2D( 3.5, 2.5)        });        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {            new Vector2D(0.0, 0.0),            new Vector2D(0.5, 2.0),            new Vector2D(2.0, 0.5),            new Vector2D(2.5, 1.0),            new Vector2D(3.0, 2.5)        });    }    @Test    public void testIntersection() {        Vector2D[][] vertices1 = new Vector2D[][] {            new Vector2D[] {                new Vector2D( 0.0,  0.0),                new Vector2D( 2.0,  0.0),                new Vector2D( 2.0,  2.0),                new Vector2D( 0.0,  2.0)            }        };        PolygonsSet set1 = buildSet(vertices1);        Vector2D[][] vertices2 = new Vector2D[][] {            new Vector2D[] {                new Vector2D( 1.0,  1.0),                new Vector2D( 3.0,  1.0),                new Vector2D( 3.0,  3.0),                new Vector2D( 1.0,  3.0)            }        };        PolygonsSet set2 = buildSet(vertices2);        PolygonsSet set  = (PolygonsSet) new RegionFactory<Euclidean2D>().intersection(set1.copySelf(),                                                                                       set2.copySelf());        checkVertices(set1.getVertices(), vertices1);        checkVertices(set2.getVertices(), vertices2);        checkVertices(set.getVertices(), new Vector2D[][] {            new Vector2D[] {                new Vector2D( 1.0,  1.0),                new Vector2D( 2.0,  1.0),                new Vector2D( 2.0,  2.0),                new Vector2D( 1.0,  2.0)            }        });        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {            new Vector2D(1.5, 1.5)        });        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {            new Vector2D(0.5, 1.5),            new Vector2D(2.5, 1.5),            new Vector2D(1.5, 0.5),            new Vector2D(0.5, 0.5)        });        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {            new Vector2D(1.0, 1.0),            new Vector2D(2.0, 2.0),            new Vector2D(1.0, 1.5),            new Vector2D(1.5, 2.0)        });    }    @Test    public void testXor() {        Vector2D[][] vertices1 = new Vector2D[][] {            new Vector2D[] {                new Vector2D( 0.0,  0.0),                new Vector2D( 2.0,  0.0),                new Vector2D( 2.0,  2.0),                new Vector2D( 0.0,  2.0)            }        };        PolygonsSet set1 = buildSet(vertices1);        Vector2D[][] vertices2 = new Vector2D[][] {            new Vector2D[] {                new Vector2D( 1.0,  1.0),                new Vector2D( 3.0,  1.0),                new Vector2D( 3.0,  3.0),                new Vector2D( 1.0,  3.0)            }        };        PolygonsSet set2 = buildSet(vertices2);        PolygonsSet set  = (PolygonsSet) new RegionFactory<Euclidean2D>().xor(set1.copySelf(),                                                                              set2.copySelf());        checkVertices(set1.getVertices(), vertices1);        checkVertices(set2.getVertices(), vertices2);        checkVertices(set.getVertices(), new Vector2D[][] {            new Vector2D[] {                new Vector2D( 0.0,  0.0),                new Vector2D( 2.0,  0.0),                new Vector2D( 2.0,  1.0),                new Vector2D( 3.0,  1.0),                new Vector2D( 3.0,  3.0),                new Vector2D( 1.0,  3.0),                new Vector2D( 1.0,  2.0),                new Vector2D( 0.0,  2.0)            },            new Vector2D[] {                new Vector2D( 1.0,  1.0),                new Vector2D( 1.0,  2.0),                new Vector2D( 2.0,  2.0),                new Vector2D( 2.0,  1.0)            }        });        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {            new Vector2D(0.5, 0.5),            new Vector2D(2.5, 2.5),            new Vector2D(0.5, 1.5),            new Vector2D(1.5, 0.5),            new Vector2D(1.5, 2.5),            new Vector2D(2.5, 1.5),            new Vector2D(2.5, 2.5)        });        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {            new Vector2D(-0.5, 0.5),            new Vector2D( 0.5, 2.5),            new Vector2D( 2.5, 0.5),            new Vector2D( 1.5, 1.5),            new Vector2D( 3.5, 2.5)        });        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {            new Vector2D(1.0, 1.0),            new Vector2D(2.0, 2.0),            new Vector2D(1.5, 1.0),            new Vector2D(2.0, 1.5),            new Vector2D(0.0, 0.0),            new Vector2D(0.5, 2.0),            new Vector2D(2.0, 0.5),            new Vector2D(2.5, 1.0),            new Vector2D(3.0, 2.5)        });    }    @Test    public void testDifference() {        Vector2D[][] vertices1 = new Vector2D[][] {            new Vector2D[] {                new Vector2D( 0.0,  0.0),                new Vector2D( 2.0,  0.0),                new Vector2D( 2.0,  2.0),                new Vector2D( 0.0,  2.0)            }        };        PolygonsSet set1 = buildSet(vertices1);        Vector2D[][] vertices2 = new Vector2D[][] {            new Vector2D[] {                new Vector2D( 1.0,  1.0),                new Vector2D( 3.0,  1.0),                new Vector2D( 3.0,  3.0),                new Vector2D( 1.0,  3.0)            }        };        PolygonsSet set2 = buildSet(vertices2);        PolygonsSet set  = (PolygonsSet) new RegionFactory<Euclidean2D>().difference(set1.copySelf(),                                                                                     set2.copySelf());        checkVertices(set1.getVertices(), vertices1);        checkVertices(set2.getVertices(), vertices2);        checkVertices(set.getVertices(), new Vector2D[][] {            new Vector2D[] {                new Vector2D( 0.0,  0.0),                new Vector2D( 2.0,  0.0),                new Vector2D( 2.0,  1.0),                new Vector2D( 1.0,  1.0),                new Vector2D( 1.0,  2.0),                new Vector2D( 0.0,  2.0)            }        });        checkPoints(Region.Location.INSIDE, set, new Vector2D[] {            new Vector2D(0.5, 0.5),            new Vector2D(0.5, 1.5),            new Vector2D(1.5, 0.5)        });        checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] {            new Vector2D( 2.5, 2.5),            new Vector2D(-0.5, 0.5),            new Vector2D( 0.5, 2.5),            new Vector2D( 2.5, 0.5),            new Vector2D( 1.5, 1.5),            new Vector2D( 3.5, 2.5),            new Vector2D( 1.5, 2.5),            new Vector2D( 2.5, 1.5),            new Vector2D( 2.0, 1.5),            new Vector2D( 2.0, 2.0),            new Vector2D( 2.5, 1.0),            new Vector2D( 2.5, 2.5),            new Vector2D( 3.0, 2.5)        });        checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] {            new Vector2D(1.0, 1.0),            new Vector2D(1.5, 1.0),            new Vector2D(0.0, 0.0),            new Vector2D(0.5, 2.0),            new Vector2D(2.0, 0.5)        });    }    @Test    public void testEmptyDifference() {        Vector2D[][] vertices1 = new Vector2D[][] {            new Vector2D[] {                new Vector2D( 0.5, 3.5),                new Vector2D( 0.5, 4.5),                new Vector2D(-0.5, 4.5),                new Vector2D(-0.5, 3.5)            }        };        PolygonsSet set1 = buildSet(vertices1);        Vector2D[][] vertices2 = new Vector2D[][] {            new Vector2D[] {                new Vector2D( 1.0, 2.0),                new Vector2D( 1.0, 8.0),                new Vector2D(-1.0, 8.0),                new Vector2D(-1.0, 2.0)            }        };        PolygonsSet set2 = buildSet(vertices2);        Assert.assertTrue(new RegionFactory<Euclidean2D>().difference(set1.copySelf(), set2.copySelf()).isEmpty());    }    @Test    public void testChoppedHexagon() {        double pi6   = FastMath.PI / 6.0;        double sqrt3 = FastMath.sqrt(3.0);        SubLine[] hyp = {            new Line(new Vector2D(   0.0, 1.0),  5 * pi6).wholeHyperplane(),            new Line(new Vector2D(-sqrt3, 1.0),  7 * pi6).wholeHyperplane(),            new Line(new Vector2D(-sqrt3, 1.0),  9 * pi6).wholeHyperplane(),            new Line(new Vector2D(-sqrt3, 0.0), 11 * pi6).wholeHyperplane(),            new Line(new Vector2D(   0.0, 0.0), 13 * pi6).wholeHyperplane(),            new Line(new Vector2D(   0.0, 1.0),  3 * pi6).wholeHyperplane(),            new Line(new Vector2D(-5.0 * sqrt3 / 6.0, 0.0), 9 * pi6).wholeHyperplane()        };        hyp[1] = (SubLine) hyp[1].split(hyp[0].getHyperplane()).getMinus();        hyp[2] = (SubLine) hyp[2].split(hyp[1].getHyperplane()).getMinus();        hyp[3] = (SubLine) hyp[3].split(hyp[2].getHyperplane()).getMinus();        hyp[4] = (SubLine) hyp[4].split(hyp[3].getHyperplane()).getMinus().split(hyp[0].getHyperplane()).getMinus();        hyp[5] = (SubLine) hyp[5].split(hyp[4].getHyperplane()).getMinus().split(hyp[0].getHyperplane()).getMinus();        hyp[6] = (SubLine) hyp[6].split(hyp[3].getHyperplane()).getMinus().split(hyp[1].getHyperplane()).getMinus();        BSPTree<Euclidean2D> tree = new BSPTree<Euclidean2D>(Boolean.TRUE);        for (int i = hyp.length - 1; i >= 0; --i) {            tree = new BSPTree<Euclidean2D>(hyp[i], new BSPTree<Euclidean2D>(Boolean.FALSE), tree, null);        }        PolygonsSet set = new PolygonsSet(tree);        SubLine splitter =            new Line(new Vector2D(-2.0 * sqrt3 / 3.0, 0.0), 9 * pi6).wholeHyperplane();        PolygonsSet slice =            new PolygonsSet(new BSPTree<Euclidean2D>(splitter,                                                     set.getTree(false).split(splitter).getPlus(),                                                     new BSPTree<Euclidean2D>(Boolean.FALSE), null));        Assert.assertEquals(Region.Location.OUTSIDE,                            slice.checkPoint(new Vector2D(0.1, 0.5)));        Assert.assertEquals(11.0 / 3.0, slice.getBoundarySize(), 1.0e-10);    }    @Test    public void testConcentric() {        double h = FastMath.sqrt(3.0) / 2.0;        Vector2D[][] vertices1 = new Vector2D[][] {            new Vector2D[] {                new Vector2D( 0.00, 0.1 * h),                new Vector2D( 0.05, 0.1 * h),                new Vector2D( 0.10, 0.2 * h),                new Vector2D( 0.05, 0.3 * h),                new Vector2D(-0.05, 0.3 * h),                new Vector2D(-0.10, 0.2 * h),                new Vector2D(-0.05, 0.1 * h)            }        };        PolygonsSet set1 = buildSet(vertices1);        Vector2D[][] vertices2 = new Vector2D[][] {            new Vector2D[] {                new Vector2D( 0.00, 0.0 * h),                new Vector2D( 0.10, 0.0 * h),                new Vector2D( 0.20, 0.2 * h),                new Vector2D( 0.10, 0.4 * h),                new Vector2D(-0.10, 0.4 * h),                new Vector2D(-0.20, 0.2 * h),                new Vector2D(-0.10, 0.0 * h)            }        };        PolygonsSet set2 = buildSet(vertices2);        Assert.assertTrue(set2.contains(set1));    }    @Test    public void testBug20040520() {        BSPTree<Euclidean2D> a0 =            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.85, -0.05),                                                  new Vector2D(0.90, -0.10)),                                                  new BSPTree<Euclidean2D>(Boolean.FALSE),                                                  new BSPTree<Euclidean2D>(Boolean.TRUE),                                                  null);        BSPTree<Euclidean2D> a1 =            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.85, -0.10),                                                  new Vector2D(0.90, -0.10)),                                                  new BSPTree<Euclidean2D>(Boolean.FALSE), a0, null);        BSPTree<Euclidean2D> a2 =            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.90, -0.05),                                                  new Vector2D(0.85, -0.05)),                                                  new BSPTree<Euclidean2D>(Boolean.FALSE), a1, null);        BSPTree<Euclidean2D> a3 =            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.82, -0.05),                                                  new Vector2D(0.82, -0.08)),                                                  new BSPTree<Euclidean2D>(Boolean.FALSE),                                                  new BSPTree<Euclidean2D>(Boolean.TRUE),                                                  null);        BSPTree<Euclidean2D> a4 =            new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.85, -0.05),                                                   new Vector2D(0.80, -0.05),                                                   false),                                                   new BSPTree<Euclidean2D>(Boolean.FALSE), a3, null);        BSPTree<Euclidean2D> a5 =            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.82, -0.08),                                                  new Vector2D(0.82, -0.18)),                                                  new BSPTree<Euclidean2D>(Boolean.FALSE),                                                  new BSPTree<Euclidean2D>(Boolean.TRUE),                                                  null);        BSPTree<Euclidean2D> a6 =            new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.82, -0.18),                                                   new Vector2D(0.85, -0.15),                                                   true),                                                   new BSPTree<Euclidean2D>(Boolean.FALSE), a5, null);        BSPTree<Euclidean2D> a7 =            new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.85, -0.05),                                                   new Vector2D(0.82, -0.08),                                                   false),                                                   a4, a6, null);        BSPTree<Euclidean2D> a8 =            new BSPTree<Euclidean2D>(buildLine(new Vector2D(0.85, -0.25),                                               new Vector2D(0.85,  0.05)),                                               a2, a7, null);        BSPTree<Euclidean2D> a9 =            new BSPTree<Euclidean2D>(buildLine(new Vector2D(0.90,  0.05),                                               new Vector2D(0.90, -0.50)),                                               a8, new BSPTree<Euclidean2D>(Boolean.FALSE), null);        BSPTree<Euclidean2D> b0 =            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.92, -0.12),                                                  new Vector2D(0.92, -0.08)),                                                  new BSPTree<Euclidean2D>(Boolean.FALSE), new BSPTree<Euclidean2D>(Boolean.TRUE),                                                  null);        BSPTree<Euclidean2D> b1 =            new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.92, -0.08),                                                   new Vector2D(0.90, -0.10),                                                   true),                                                   new BSPTree<Euclidean2D>(Boolean.FALSE), b0, null);        BSPTree<Euclidean2D> b2 =            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.92, -0.18),                                                  new Vector2D(0.92, -0.12)),                                                  new BSPTree<Euclidean2D>(Boolean.FALSE), new BSPTree<Euclidean2D>(Boolean.TRUE),                                                  null);        BSPTree<Euclidean2D> b3 =            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.85, -0.15),                                                  new Vector2D(0.90, -0.20)),                                                  new BSPTree<Euclidean2D>(Boolean.FALSE), b2, null);        BSPTree<Euclidean2D> b4 =            new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.95, -0.15),                                                  new Vector2D(0.85, -0.05)),                                                  b1, b3, null);        BSPTree<Euclidean2D> b5 =            new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.85, -0.05),                                                   new Vector2D(0.85, -0.25),                                                   true),                                                   new BSPTree<Euclidean2D>(Boolean.FALSE), b4, null);        BSPTree<Euclidean2D> b6 =            new BSPTree<Euclidean2D>(buildLine(new Vector2D(0.0, -1.10),                                               new Vector2D(1.0, -0.10)),                                               new BSPTree<Euclidean2D>(Boolean.FALSE), b5, null);        PolygonsSet c =            (PolygonsSet) new RegionFactory<Euclidean2D>().union(new PolygonsSet(a9),                                                                 new PolygonsSet(b6));        checkPoints(Region.Location.INSIDE, c, new Vector2D[] {            new Vector2D(0.83, -0.06),            new Vector2D(0.83, -0.15),            new Vector2D(0.88, -0.15),            new Vector2D(0.88, -0.09),            new Vector2D(0.88, -0.07),            new Vector2D(0.91, -0.18),            new Vector2D(0.91, -0.10)        });        checkPoints(Region.Location.OUTSIDE, c, new Vector2D[] {            new Vector2D(0.80, -0.10),            new Vector2D(0.83, -0.50),            new Vector2D(0.83, -0.20),            new Vector2D(0.83, -0.02),            new Vector2D(0.87, -0.50),            new Vector2D(0.87, -0.20),            new Vector2D(0.87, -0.02),            new Vector2D(0.91, -0.20),            new Vector2D(0.91, -0.08),            new Vector2D(0.93, -0.15)        });        checkVertices(c.getVertices(),                      new Vector2D[][] {            new Vector2D[] {                new Vector2D(0.85, -0.15),                new Vector2D(0.90, -0.20),                new Vector2D(0.92, -0.18),                new Vector2D(0.92, -0.08),                new Vector2D(0.90, -0.10),                new Vector2D(0.90, -0.05),                new Vector2D(0.82, -0.05),                new Vector2D(0.82, -0.18),            }        });    }    @Test    public void testBug20041003() {        Line[] l = {            new Line(new Vector2D(0.0, 0.625000007541172),                     new Vector2D(1.0, 0.625000007541172)),                     new Line(new Vector2D(-0.19204433621902645, 0.0),                              new Vector2D(-0.19204433621902645, 1.0)),                              new Line(new Vector2D(-0.40303524786887,  0.4248364535319128),                                       new Vector2D(-1.12851149797877, -0.2634107480798909)),                                       new Line(new Vector2D(0.0, 2.0),                                                new Vector2D(1.0, 2.0))        };        BSPTree<Euclidean2D> node1 =            new BSPTree<Euclidean2D>(new SubLine(l[0],                                          new IntervalsSet(intersectionAbscissa(l[0], l[1]),                                                           intersectionAbscissa(l[0], l[2]))),                                                           new BSPTree<Euclidean2D>(Boolean.TRUE), new BSPTree<Euclidean2D>(Boolean.FALSE),                                                           null);        BSPTree<Euclidean2D> node2 =            new BSPTree<Euclidean2D>(new SubLine(l[1],                                          new IntervalsSet(intersectionAbscissa(l[1], l[2]),                                                           intersectionAbscissa(l[1], l[3]))),                                                           node1, new BSPTree<Euclidean2D>(Boolean.FALSE), null);        BSPTree<Euclidean2D> node3 =            new BSPTree<Euclidean2D>(new SubLine(l[2],                                          new IntervalsSet(intersectionAbscissa(l[2], l[3]),                                                           Double.POSITIVE_INFINITY)),                                                           node2, new BSPTree<Euclidean2D>(Boolean.FALSE), null);        BSPTree<Euclidean2D> node4 =            new BSPTree<Euclidean2D>(l[3].wholeHyperplane(), node3, new BSPTree<Euclidean2D>(Boolean.FALSE), null);        PolygonsSet set = new PolygonsSet(node4);        Assert.assertEquals(0, set.getVertices().length);    }    private PolygonsSet buildSet(Vector2D[][] vertices) {        ArrayList<SubHyperplane<Euclidean2D>> edges = new ArrayList<SubHyperplane<Euclidean2D>>();        for (int i = 0; i < vertices.length; ++i) {            int l = vertices[i].length;            for (int j = 0; j < l; ++j) {                edges.add(buildSegment(vertices[i][j], vertices[i][(j + 1) % l]));            }        }        return new PolygonsSet(edges);    }    private SubHyperplane<Euclidean2D> buildLine(Vector2D start, Vector2D end) {        return new Line(start, end).wholeHyperplane();    }    private double intersectionAbscissa(Line l0, Line l1) {        Vector2D p = l0.intersection(l1);        return (l0.toSubSpace(p)).getX();    }    private SubHyperplane<Euclidean2D> buildHalfLine(Vector2D start, Vector2D end,                                                     boolean startIsVirtual) {        Line   line  = new Line(start, end);        double lower = startIsVirtual        ? Double.NEGATIVE_INFINITY        : (line.toSubSpace(start)).getX();        double upper = startIsVirtual        ? (line.toSubSpace(end)).getX()        : Double.POSITIVE_INFINITY;        return new SubLine(line, new IntervalsSet(lower, upper));    }    private SubHyperplane<Euclidean2D> buildSegment(Vector2D start, Vector2D end) {        Line   line  = new Line(start, end);        double lower = (line.toSubSpace(start)).getX();        double upper = (line.toSubSpace(end)).getX();        return new SubLine(line, new IntervalsSet(lower, upper));    }    private void checkPoints(Region.Location expected, PolygonsSet set,                             Vector2D[] points) {        for (int i = 0; i < points.length; ++i) {            Assert.assertEquals(expected, set.checkPoint(points[i]));        }    }    private boolean checkInSegment(Vector2D p,                                   Vector2D p1, Vector2D p2,                                   double tolerance) {        Line line = new Line(p1, p2);        if (line.getOffset(p) < tolerance) {            double x  = (line.toSubSpace(p)).getX();            double x1 = (line.toSubSpace(p1)).getX();            double x2 = (line.toSubSpace(p2)).getX();            return (((x - x1) * (x - x2) <= 0.0)                    || (p1.distance(p) < tolerance)                    || (p2.distance(p) < tolerance));        } else {            return false;        }    }    private void checkVertices(Vector2D[][] rebuiltVertices,                               Vector2D[][] vertices) {        // each rebuilt vertex should be in a segment joining two original vertices        for (int i = 0; i < rebuiltVertices.length; ++i) {            for (int j = 0; j < rebuiltVertices[i].length; ++j) {                boolean inSegment = false;                Vector2D p = rebuiltVertices[i][j];                for (int k = 0; k < vertices.length; ++k) {                    Vector2D[] loop = vertices[k];                    int length = loop.length;                    for (int l = 0; (! inSegment) && (l < length); ++l) {                        inSegment = checkInSegment(p, loop[l], loop[(l + 1) % length], 1.0e-10);                    }                }                Assert.assertTrue(inSegment);            }        }        // each original vertex should have a corresponding rebuilt vertex        for (int k = 0; k < vertices.length; ++k) {            for (int l = 0; l < vertices[k].length; ++l) {                double min = Double.POSITIVE_INFINITY;                for (int i = 0; i < rebuiltVertices.length; ++i) {                    for (int j = 0; j < rebuiltVertices[i].length; ++j) {                        min = FastMath.min(vertices[k][l].distance(rebuiltVertices[i][j]),                                       min);                    }                }                Assert.assertEquals(0.0, min, 1.0e-10);            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry.euclidean.twod;import java.util.List;import org.apache.commons.math.geometry.euclidean.oned.Euclidean1D;import org.apache.commons.math.geometry.euclidean.oned.IntervalsSet;import org.apache.commons.math.geometry.partitioning.RegionFactory;import org.junit.Assert;import org.junit.Test;public class SubLineTest {    @Test    public void testEndPoints() {        Vector2D p1 = new Vector2D(-1, -7);        Vector2D p2 = new Vector2D(7, -1);        Segment segment = new Segment(p1, p2, new Line(p1, p2));        SubLine sub = new SubLine(segment);        List<Segment> segments = sub.getSegments();        Assert.assertEquals(1, segments.size());        Assert.assertEquals(0.0, new Vector2D(-1, -7).distance(segments.get(0).getStart()), 1.0e-10);        Assert.assertEquals(0.0, new Vector2D( 7, -1).distance(segments.get(0).getEnd()), 1.0e-10);    }    @Test    public void testNoEndPoints() {        SubLine wholeLine = new Line(new Vector2D(-1, 7), new Vector2D(7, 1)).wholeHyperplane();        List<Segment> segments = wholeLine.getSegments();        Assert.assertEquals(1, segments.size());        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX()) &&                          segments.get(0).getStart().getX() < 0);        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY()) &&                          segments.get(0).getStart().getY() > 0);        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX()) &&                          segments.get(0).getEnd().getX() > 0);        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY()) &&                          segments.get(0).getEnd().getY() < 0);    }    @Test    public void testNoSegments() {        SubLine empty = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1)),                                    new RegionFactory<Euclidean1D>().getComplement(new IntervalsSet()));        List<Segment> segments = empty.getSegments();        Assert.assertEquals(0, segments.size());    }    @Test    public void testSeveralSegments() {        SubLine twoSubs = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1)),                                    new RegionFactory<Euclidean1D>().union(new IntervalsSet(1, 2),                                                                           new IntervalsSet(3, 4)));        List<Segment> segments = twoSubs.getSegments();        Assert.assertEquals(2, segments.size());    }    @Test    public void testHalfInfiniteNeg() {        SubLine empty = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1)),                                    new IntervalsSet(Double.NEGATIVE_INFINITY, 0.0));        List<Segment> segments = empty.getSegments();        Assert.assertEquals(1, segments.size());        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX()) &&                          segments.get(0).getStart().getX() < 0);        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY()) &&                          segments.get(0).getStart().getY() < 0);        Assert.assertEquals(0.0, new Vector2D(3, -4).distance(segments.get(0).getEnd()), 1.0e-10);    }    @Test    public void testHalfInfinitePos() {        SubLine empty = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1)),                                    new IntervalsSet(0.0, Double.POSITIVE_INFINITY));        List<Segment> segments = empty.getSegments();        Assert.assertEquals(1, segments.size());        Assert.assertEquals(0.0, new Vector2D(3, -4).distance(segments.get(0).getStart()), 1.0e-10);        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX()) &&                          segments.get(0).getEnd().getX() > 0);        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY()) &&                          segments.get(0).getEnd().getY() > 0);    }    @Test    public void testIntersectionInsideInside() {        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(3, 1));        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 2));        Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);        Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, false)), 1.0e-12);    }    @Test    public void testIntersectionInsideBoundary() {        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(3, 1));        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 1));        Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);        Assert.assertNull(sub1.intersection(sub2, false));    }    @Test    public void testIntersectionInsideOutside() {        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(3, 1));        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 0.5));        Assert.assertNull(sub1.intersection(sub2, true));        Assert.assertNull(sub1.intersection(sub2, false));    }    @Test    public void testIntersectionBoundaryBoundary() {        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(2, 1));        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 1));        Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);        Assert.assertNull(sub1.intersection(sub2, false));    }    @Test    public void testIntersectionBoundaryOutside() {        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(2, 1));        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 0.5));        Assert.assertNull(sub1.intersection(sub2, true));        Assert.assertNull(sub1.intersection(sub2, false));    }    @Test    public void testIntersectionOutsideOutside() {        SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(1.5, 1));        SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 0.5));        Assert.assertNull(sub1.intersection(sub2, true));        Assert.assertNull(sub1.intersection(sub2, false));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry.euclidean.twod;import org.apache.commons.math.geometry.euclidean.oned.Euclidean1D;import org.apache.commons.math.geometry.euclidean.oned.Vector1D;import org.apache.commons.math.geometry.euclidean.twod.Line;import org.apache.commons.math.geometry.euclidean.twod.Vector2D;import org.apache.commons.math.geometry.partitioning.Transform;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;import java.awt.geom.AffineTransform;public class LineTest {    @Test    public void testContains() {        Line l = new Line(new Vector2D(0, 1), new Vector2D(1, 2));        Assert.assertTrue(l.contains(new Vector2D(0, 1)));        Assert.assertTrue(l.contains(new Vector2D(1, 2)));        Assert.assertTrue(l.contains(new Vector2D(7, 8)));        Assert.assertTrue(! l.contains(new Vector2D(8, 7)));    }    @Test    public void testAbscissa() {        Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2));        Assert.assertEquals(0.0,                            (l.toSubSpace(new Vector2D(-3,  4))).getX(),                            1.0e-10);        Assert.assertEquals(0.0,                            (l.toSubSpace(new Vector2D( 3, -4))).getX(),                            1.0e-10);        Assert.assertEquals(-5.0,                            (l.toSubSpace(new Vector2D( 7, -1))).getX(),                            1.0e-10);        Assert.assertEquals( 5.0,                             (l.toSubSpace(new Vector2D(-1, -7))).getX(),                             1.0e-10);    }    @Test    public void testOffset() {        Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2));        Assert.assertEquals(-5.0, l.getOffset(new Vector2D(5, -3)), 1.0e-10);        Assert.assertEquals(+5.0, l.getOffset(new Vector2D(-5, 2)), 1.0e-10);    }    @Test    public void testPointAt() {        Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2));        for (double a = -2.0; a < 2.0; a += 0.2) {            Vector1D pA = new Vector1D(a);            Vector2D point = l.toSpace(pA);            Assert.assertEquals(a, (l.toSubSpace(point)).getX(), 1.0e-10);            Assert.assertEquals(0.0, l.getOffset(point),   1.0e-10);            for (double o = -2.0; o < 2.0; o += 0.2) {                point = l.getPointAt(pA, o);                Assert.assertEquals(a, (l.toSubSpace(point)).getX(), 1.0e-10);                Assert.assertEquals(o, l.getOffset(point),   1.0e-10);            }        }    }    @Test    public void testOriginOffset() {        Line l1 = new Line(new Vector2D(0, 1), new Vector2D(1, 2));        Assert.assertEquals(FastMath.sqrt(0.5), l1.getOriginOffset(), 1.0e-10);        Line l2 = new Line(new Vector2D(1, 2), new Vector2D(0, 1));        Assert.assertEquals(-FastMath.sqrt(0.5), l2.getOriginOffset(), 1.0e-10);    }    @Test    public void testParallel() {        Line l1 = new Line(new Vector2D(0, 1), new Vector2D(1, 2));        Line l2 = new Line(new Vector2D(2, 2), new Vector2D(3, 3));        Assert.assertTrue(l1.isParallelTo(l2));        Line l3 = new Line(new Vector2D(1, 0), new Vector2D(0.5, -0.5));        Assert.assertTrue(l1.isParallelTo(l3));        Line l4 = new Line(new Vector2D(1, 0), new Vector2D(0.5, -0.51));        Assert.assertTrue(! l1.isParallelTo(l4));    }    @Test    public void testTransform() {        Line l1 = new Line(new Vector2D(1.0 ,1.0), new Vector2D(4.0 ,1.0));        Transform<Euclidean2D, Euclidean1D> t1 =            Line.getTransform(new AffineTransform(0.0, 0.5, -1.0, 0.0, 1.0, 1.5));        Assert.assertEquals(0.5 * FastMath.PI,                            ((Line) t1.apply(l1)).getAngle(),                            1.0e-10);        Line l2 = new Line(new Vector2D(0.0, 0.0), new Vector2D(1.0, 1.0));        Transform<Euclidean2D, Euclidean1D> t2 =            Line.getTransform(new AffineTransform(0.0, 0.5, -1.0, 0.0, 1.0, 1.5));        Assert.assertEquals(FastMath.atan2(1.0, -2.0),                            ((Line) t2.apply(l2)).getAngle(),                            1.0e-10);    }    @Test    public void testIntersection() {        Line    l1 = new Line(new Vector2D( 0, 1), new Vector2D(1, 2));        Line    l2 = new Line(new Vector2D(-1, 2), new Vector2D(2, 1));        Vector2D p  = l1.intersection(l2);        Assert.assertEquals(0.5, p.getX(), 1.0e-10);        Assert.assertEquals(1.5, p.getY(), 1.0e-10);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry.partitioning.utilities;import org.apache.commons.math.geometry.partitioning.utilities.AVLTree;import org.junit.Assert;import org.junit.Test;public class AVLTreeTest {    @Test    public void testInsert() {        // this array in this order allows to pass in all branches        // of the insertion algorithm        int[] array = { 16, 13, 15, 14,  2,  0, 12,  9,  8,  5,            11, 18, 19, 17,  4,  7,  1,  3,  6, 10 };        AVLTree<Integer> tree = buildTree(array);        Assert.assertEquals(array.length, tree.size());        for (int i = 0; i < array.length; ++i) {            Assert.assertEquals(array[i], value(tree.getNotSmaller(new Integer(array[i]))));        }        checkOrder(tree);    }    @Test    public void testDelete1() {        int[][][] arrays = {            { { 16, 13, 15, 14, 2, 0, 12, 9, 8, 5, 11, 18, 19, 17, 4, 7, 1, 3, 6, 10 },                { 11, 10, 9, 12, 16, 15, 13, 18, 5, 0, 3, 2, 14, 6, 19, 17, 8, 4, 7, 1 } },                { { 16, 13, 15, 14, 2, 0, 12, 9, 8, 5, 11, 18, 19, 17, 4, 7, 1, 3, 6, 10 },                    { 0, 17, 14, 15, 16, 18,  6 } },                    { { 6, 2, 7, 8, 1, 4, 3, 5 }, { 8 } },                    { { 6, 2, 7, 8, 1, 4, 5 }, { 8 } },                    { { 3, 7, 2, 1, 5, 8, 4 }, { 1 } },                    { { 3, 7, 2, 1, 5, 8, 6 }, { 1 } }        };        for (int i = 0; i < arrays.length; ++i) {            AVLTree<Integer> tree = buildTree(arrays[i][0]);            Assert.assertTrue(! tree.delete(new Integer(-2000)));            for (int j = 0; j < arrays[i][1].length; ++j) {                Assert.assertTrue(tree.delete(tree.getNotSmaller(new Integer(arrays[i][1][j])).getElement()));                Assert.assertEquals(arrays[i][0].length - j - 1, tree.size());            }        }    }    @Test    public void testNavigation() {        int[] array = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };        AVLTree<Integer> tree = buildTree(array);        AVLTree<Integer>.Node node = tree.getSmallest();        Assert.assertEquals(array[0], value(node));        for (int i = 0; i < array.length; ++i) {            Assert.assertEquals(array[i], value(node));            node = node.getNext();        }        Assert.assertNull(node);        node = tree.getLargest();        Assert.assertEquals(array[array.length - 1], value(node));        for (int i = array.length - 1; i >= 0; --i) {            Assert.assertEquals(array[i], value(node));            node = node.getPrevious();        }        Assert.assertNull(node);        checkOrder(tree);    }    @Test    public void testSearch() {        int[] array = { 2, 4, 6, 8, 10, 12, 14 };        AVLTree<Integer> tree = buildTree(array);        Assert.assertNull(tree.getNotLarger(new Integer(array[0] - 1)));        Assert.assertNull(tree.getNotSmaller(new Integer(array[array.length - 1] + 1)));        for (int i = 0; i < array.length; ++i) {            Assert.assertEquals(array[i],                                value(tree.getNotSmaller(new Integer(array[i] - 1))));            Assert.assertEquals(array[i],                                value(tree.getNotLarger(new Integer(array[i] + 1))));        }        checkOrder(tree);    }    @Test    public void testRepetition() {        int[] array = { 1, 1, 3, 3, 4, 5, 6, 7, 7, 7, 7, 7 };        AVLTree<Integer> tree = buildTree(array);        Assert.assertEquals(array.length, tree.size());        AVLTree<Integer>.Node node = tree.getNotSmaller(new Integer(3));        Assert.assertEquals(3, value(node));        Assert.assertEquals(1, value(node.getPrevious()));        Assert.assertEquals(3, value(node.getNext()));        Assert.assertEquals(4, value(node.getNext().getNext()));        node = tree.getNotLarger(new Integer(2));        Assert.assertEquals(1, value(node));        Assert.assertEquals(1, value(node.getPrevious()));        Assert.assertEquals(3, value(node.getNext()));        Assert.assertNull(node.getPrevious().getPrevious());        AVLTree<Integer>.Node otherNode = tree.getNotSmaller(new Integer(1));        Assert.assertTrue(node != otherNode);        Assert.assertEquals(1, value(otherNode));        Assert.assertNull(otherNode.getPrevious());        node = tree.getNotLarger(new Integer(10));        Assert.assertEquals(7, value(node));        Assert.assertNull(node.getNext());        node = node.getPrevious();        Assert.assertEquals(7, value(node));        node = node.getPrevious();        Assert.assertEquals(7, value(node));        node = node.getPrevious();        Assert.assertEquals(7, value(node));        node = node.getPrevious();        Assert.assertEquals(7, value(node));        node = node.getPrevious();        Assert.assertEquals(6, value(node));        checkOrder(tree);    }    private AVLTree<Integer> buildTree(int[] array) {        AVLTree<Integer> tree = new AVLTree<Integer>();        for (int i = 0; i < array.length; ++i) {            tree.insert(new Integer(array[i]));            tree.insert(null);        }        return tree;    }    private int value(AVLTree<Integer>.Node node) {        return node.getElement().intValue();    }    private void checkOrder(AVLTree<Integer> tree) {        AVLTree<Integer>.Node next = null;        for (AVLTree<Integer>.Node node = tree.getSmallest();        node != null;        node = next) {            next = node.getNext();            if (next != null) {                Assert.assertTrue(node.getElement().compareTo(next.getElement()) <= 0);            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;/** * This is an implementation of {@link UnmodifiableRealVectorAbstractTest} for * unmodifiable views of {@link OpenMapRealVector}. * * @version $Id$ */public class UnmodifiableOpenMapRealVectorTest    extends UnmodifiableRealVectorAbstractTest {    /** To ensure sufficient sparsity. */    public static final double PROBABILITY_OF_ZERO = 0.5;    /**     * Returns a random vector of type {@link ArrayRealVector}.     *     * @return a new random {@link ArrayRealVector}.     */    @Override    public RealVector createVector() {        OpenMapRealVector v = new OpenMapRealVector(DIM, EPS);        for (int i = 0; i < DIM; i++) {            if (RANDOM.nextDouble() > PROBABILITY_OF_ZERO) {                v.setEntry(i, RANDOM.nextDouble());            }        }        return v;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Random;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.junit.Test;import org.junit.Assert;public class QRSolverTest {    double[][] testData3x3NonSingular = {            { 12, -51,   4 },            {  6, 167, -68 },            { -4,  24, -41 }    };    double[][] testData3x3Singular = {            { 1, 2,  2 },            { 2, 4,  6 },            { 4, 8, 12 }    };    double[][] testData3x4 = {            { 12, -51,   4, 1 },            {  6, 167, -68, 2 },            { -4,  24, -41, 3 }    };    double[][] testData4x3 = {            { 12, -51,   4 },            {  6, 167, -68 },            { -4,  24, -41 },            { -5,  34,   7 }    };    /** test rank */    @Test    public void testRank() {        DecompositionSolver solver =            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();        Assert.assertTrue(solver.isNonSingular());        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();        Assert.assertFalse(solver.isNonSingular());        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x4)).getSolver();        Assert.assertTrue(solver.isNonSingular());        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData4x3)).getSolver();        Assert.assertTrue(solver.isNonSingular());    }    /** test solve dimension errors */    @Test    public void testSolveDimensionErrors() {        DecompositionSolver solver =            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);        try {            solver.solve(b);            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException iae) {            // expected behavior        }        try {            solver.solve(b.getColumnVector(0));            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException iae) {            // expected behavior        }    }    /** test solve rank errors */    @Test    public void testSolveRankErrors() {        DecompositionSolver solver =            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);        try {            solver.solve(b);            Assert.fail("an exception should have been thrown");        } catch (SingularMatrixException iae) {            // expected behavior        }        try {            solver.solve(b.getColumnVector(0));            Assert.fail("an exception should have been thrown");        } catch (SingularMatrixException iae) {            // expected behavior        }    }    /** test solve */    @Test    public void testSolve() {        QRDecomposition decomposition =            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular));        DecompositionSolver solver = decomposition.getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                { -102, 12250 }, { 544, 24500 }, { 167, -36750 }        });        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                { 1, 2515 }, { 2, 422 }, { -3, 898 }        });        // using RealMatrix        Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 2.0e-16 * xRef.getNorm());        // using double[][]        Assert.assertEquals(0, MatrixUtils.createRealMatrix(solver.solve(b.getData())).subtract(xRef).getNorm(), 2.0e-16 * xRef.getNorm());        // using ArrayRealVector        for (int i = 0; i < b.getColumnDimension(); ++i) {            final RealVector x = solver.solve(b.getColumnVector(i));            final double error = x.subtract(xRef.getColumnVector(i)).getNorm();            Assert.assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());        }        // using RealVector with an alternate implementation        for (int i = 0; i < b.getColumnDimension(); ++i) {            ArrayRealVectorTest.RealVectorTestImpl v =                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));            final RealVector x = solver.solve(v);            final double error = x.subtract(xRef.getColumnVector(i)).getNorm();            Assert.assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());        }    }    @Test    public void testOverdetermined() throws MathUserException {        final Random r    = new Random(5559252868205245l);        int          p    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        int          q    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        RealMatrix   a    = createTestMatrix(r, p, q);        RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);        // build a perturbed system: A.X + noise = B        RealMatrix b = a.multiply(xRef);        final double noise = 0.001;        b.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {            @Override            public double visit(int row, int column, double value) {                return value * (1.0 + noise * (2 * r.nextDouble() - 1));            }        });        // despite perturbation, the least square solution should be pretty good        RealMatrix x = new QRDecompositionImpl(a).getSolver().solve(b);        Assert.assertEquals(0, x.subtract(xRef).getNorm(), 0.01 * noise * p * q);    }    @Test    public void testUnderdetermined() throws MathUserException {        final Random r    = new Random(42185006424567123l);        int          p    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int          q    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        RealMatrix   a    = createTestMatrix(r, p, q);        RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);        RealMatrix   b    = a.multiply(xRef);        RealMatrix   x = new QRDecompositionImpl(a).getSolver().solve(b);        // too many equations, the system cannot be solved at all        Assert.assertTrue(x.subtract(xRef).getNorm() / (p * q) > 0.01);        // the last unknown should have been set to 0        Assert.assertEquals(0.0, x.getSubMatrix(p, q - 1, 0, x.getColumnDimension() - 1).getNorm(), 0);    }    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {        RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);        m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {                @Override                    public double visit(int row, int column, double value) {                    return 2.0 * r.nextDouble() - 1.0;                }            });        return m;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.apache.commons.math.linear.BiDiagonalTransformer;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class BiDiagonalTransformerTest {    private double[][] testSquare = {            { 24.0 / 25.0, 43.0 / 25.0 },            { 57.0 / 25.0, 24.0 / 25.0 }    };    private double[][] testNonSquare = {        {  -540.0 / 625.0,  963.0 / 625.0, -216.0 / 625.0 },        { -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 },        {  -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 },        {  -360.0 / 625.0,  192.0 / 625.0, 1756.0 / 625.0 },    };    @Test    public void testDimensions() {        checkdimensions(MatrixUtils.createRealMatrix(testSquare));        checkdimensions(MatrixUtils.createRealMatrix(testNonSquare));        checkdimensions(MatrixUtils.createRealMatrix(testNonSquare).transpose());    }    private void checkdimensions(RealMatrix matrix) {        final int m = matrix.getRowDimension();        final int n = matrix.getColumnDimension();        BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix);        Assert.assertEquals(m, transformer.getU().getRowDimension());        Assert.assertEquals(m, transformer.getU().getColumnDimension());        Assert.assertEquals(m, transformer.getB().getRowDimension());        Assert.assertEquals(n, transformer.getB().getColumnDimension());        Assert.assertEquals(n, transformer.getV().getRowDimension());        Assert.assertEquals(n, transformer.getV().getColumnDimension());    }    @Test    public void testAEqualUSVt() {        checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare));        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare));        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare).transpose());    }    private void checkAEqualUSVt(RealMatrix matrix) {        BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix);        RealMatrix u = transformer.getU();        RealMatrix b = transformer.getB();        RealMatrix v = transformer.getV();        double norm = u.multiply(b).multiply(v.transpose()).subtract(matrix).getNorm();        Assert.assertEquals(0, norm, 1.0e-14);    }    @Test    public void testUOrthogonal() {        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getU());        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getU());        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getU());    }    @Test    public void testVOrthogonal() {        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getV());        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getV());        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getV());    }    private void checkOrthogonal(RealMatrix m) {        RealMatrix mTm = m.transpose().multiply(m);        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());        Assert.assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14);    }    @Test    public void testBBiDiagonal() {        checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getB());        checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getB());        checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getB());    }    private void checkBiDiagonal(RealMatrix m) {        final int rows = m.getRowDimension();        final int cols = m.getColumnDimension();        for (int i = 0; i < rows; ++i) {            for (int j = 0; j < cols; ++j) {                if (rows < cols) {                    if ((i < j) || (i > j + 1)) {                        Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16);                    }                } else {                    if ((i < j - 1) || (i > j)) {                        Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16);                    }                }            }        }    }    @Test    public void testSingularMatrix() {       BiDiagonalTransformer transformer =            new BiDiagonalTransformer(MatrixUtils.createRealMatrix(new double[][] {                { 1.0, 2.0, 3.0 },                { 2.0, 3.0, 4.0 },                { 3.0, 5.0, 7.0 }            }));       final double s3  = FastMath.sqrt(3.0);       final double s14 = FastMath.sqrt(14.0);       final double s1553 = FastMath.sqrt(1553.0);       RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {           {  -1.0 / s14,  5.0 / (s3 * s14),  1.0 / s3 },           {  -2.0 / s14, -4.0 / (s3 * s14),  1.0 / s3 },           {  -3.0 / s14,  1.0 / (s3 * s14), -1.0 / s3 }       });       RealMatrix bRef = MatrixUtils.createRealMatrix(new double[][] {           { -s14, s1553 / s14,   0.0 },           {  0.0, -87 * s3 / (s14 * s1553), -s3 * s14 / s1553 },           {  0.0, 0.0, 0.0 }       });       RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {           { 1.0,   0.0,         0.0        },           { 0.0,  -23 / s1553,  32 / s1553 },           { 0.0,  -32 / s1553, -23 / s1553 }       });       // check values against known references       RealMatrix u = transformer.getU();       Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-14);       RealMatrix b = transformer.getB();       Assert.assertEquals(0, b.subtract(bRef).getNorm(), 1.0e-14);       RealMatrix v = transformer.getV();       Assert.assertEquals(0, v.subtract(vRef).getNorm(), 1.0e-14);       // check the same cached instance is returned the second time       Assert.assertTrue(u == transformer.getU());       Assert.assertTrue(b == transformer.getB());       Assert.assertTrue(v == transformer.getV());    }    @Test    public void testMatricesValues() {       BiDiagonalTransformer transformer =            new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare));       final double s17 = FastMath.sqrt(17.0);        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {                {  -8 / (5 * s17), 19 / (5 * s17) },                { -19 / (5 * s17), -8 / (5 * s17) }        });        RealMatrix bRef = MatrixUtils.createRealMatrix(new double[][] {                { -3 * s17 / 5, 32 * s17 / 85 },                {      0.0,     -5 * s17 / 17 }        });        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {                { 1.0,  0.0 },                { 0.0, -1.0 }        });        // check values against known references        RealMatrix u = transformer.getU();        Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-14);        RealMatrix b = transformer.getB();        Assert.assertEquals(0, b.subtract(bRef).getNorm(), 1.0e-14);        RealMatrix v = transformer.getV();        Assert.assertEquals(0, v.subtract(vRef).getNorm(), 1.0e-14);        // check the same cached instance is returned the second time        Assert.assertTrue(u == transformer.getU());        Assert.assertTrue(b == transformer.getB());        Assert.assertTrue(v == transformer.getV());    }    @Test    public void testUpperOrLower() {        Assert.assertTrue(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).isUpperBiDiagonal());        Assert.assertTrue(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).isUpperBiDiagonal());        Assert.assertFalse(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).isUpperBiDiagonal());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.text.NumberFormat;import java.text.ParsePosition;import java.util.Locale;import org.junit.Test;import org.junit.Assert;import org.apache.commons.math.exception.MathParseException;public abstract class RealVectorFormatAbstractTest {    RealVectorFormat realVectorFormat = null;    RealVectorFormat realVectorFormatSquare = null;    protected abstract Locale getLocale();    protected abstract char getDecimalCharacter();    public RealVectorFormatAbstractTest() {        realVectorFormat = RealVectorFormat.getInstance(getLocale());        final NumberFormat nf = NumberFormat.getInstance(getLocale());        nf.setMaximumFractionDigits(2);        realVectorFormatSquare = new RealVectorFormat("[", "]", " : ", nf);    }    @Test    public void testSimpleNoDecimals() {        ArrayRealVector c = new ArrayRealVector(new double[] {1, 1, 1});        String expected = "{1; 1; 1}";        String actual = realVectorFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testSimpleWithDecimals() {        ArrayRealVector c = new ArrayRealVector(new double[] {1.23, 1.43, 1.63});        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = realVectorFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testSimpleWithDecimalsTrunc() {        ArrayRealVector c = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = realVectorFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testNegativeX() {        ArrayRealVector c = new ArrayRealVector(new double[] {-1.2323, 1.4343, 1.6333});        String expected =            "{-1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = realVectorFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testNegativeY() {        ArrayRealVector c = new ArrayRealVector(new double[] {1.2323, -1.4343, 1.6333});        String expected =            "{1"    + getDecimalCharacter() +            "23; -1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = realVectorFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testNegativeZ() {        ArrayRealVector c = new ArrayRealVector(new double[] {1.2323, 1.4343, -1.6333});        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; -1" + getDecimalCharacter() +            "63}";        String actual = realVectorFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testNonDefaultSetting() {        ArrayRealVector c = new ArrayRealVector(new double[] {1, 1, 1});        String expected = "[1 : 1 : 1]";        String actual = realVectorFormatSquare.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testDefaultFormatRealVectorImpl() {        Locale defaultLocal = Locale.getDefault();        Locale.setDefault(getLocale());        ArrayRealVector c = new ArrayRealVector(new double[] {232.222, -342.33, 432.444});        String expected =            "{232"    + getDecimalCharacter() +            "22; -342" + getDecimalCharacter() +            "33; 432" + getDecimalCharacter() +            "44}";        String actual = (new RealVectorFormat()).format(c);        Assert.assertEquals(expected, actual);        Locale.setDefault(defaultLocal);    }    @Test    public void testNan() {        ArrayRealVector c = new ArrayRealVector(new double[] {Double.NaN, Double.NaN, Double.NaN});        String expected = "{(NaN); (NaN); (NaN)}";        String actual = realVectorFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testPositiveInfinity() {        ArrayRealVector c = new ArrayRealVector(new double[] {                Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY        });        String expected = "{(Infinity); (Infinity); (Infinity)}";        String actual = realVectorFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void tesNegativeInfinity() {        ArrayRealVector c = new ArrayRealVector(new double[] {                Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY        });        String expected = "{(-Infinity); (-Infinity); (-Infinity)}";        String actual = realVectorFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseSimpleNoDecimals() {        String source = "{1; 1; 1}";        ArrayRealVector expected = new ArrayRealVector(new double[] {1, 1, 1});        ArrayRealVector actual = realVectorFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseIgnoredWhitespace() {        ArrayRealVector expected = new ArrayRealVector(new double[] {1, 1, 1});        ParsePosition pos1 = new ParsePosition(0);        String source1 = "{1;1;1}";        Assert.assertEquals(expected, realVectorFormat.parse(source1, pos1));        Assert.assertEquals(source1.length(), pos1.getIndex());        ParsePosition pos2 = new ParsePosition(0);        String source2 = " { 1 ; 1 ; 1 } ";        Assert.assertEquals(expected, realVectorFormat.parse(source2, pos2));        Assert.assertEquals(source2.length() - 1, pos2.getIndex());    }    @Test    public void testParseSimpleWithDecimals() {        String source =            "{1" + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        ArrayRealVector expected = new ArrayRealVector(new double[] {1.23, 1.43, 1.63});        ArrayRealVector actual = realVectorFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseSimpleWithDecimalsTrunc() {        String source =            "{1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});        ArrayRealVector actual = realVectorFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseNegativeX() {        String source =            "{-1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {-1.2323, 1.4343, 1.6333});        ArrayRealVector actual = realVectorFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseNegativeY() {        String source =            "{1" + getDecimalCharacter() +            "2323; -1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, -1.4343, 1.6333});        ArrayRealVector actual = realVectorFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseNegativeZ() {        String source =            "{1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; -1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, -1.6333});        ArrayRealVector actual = realVectorFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseNegativeAll() {        String source =            "{-1" + getDecimalCharacter() +            "2323; -1" + getDecimalCharacter() +            "4343; -1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {-1.2323, -1.4343, -1.6333});        ArrayRealVector actual = realVectorFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseZeroX() {        String source =            "{0" + getDecimalCharacter() +            "0; -1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {0.0, -1.4343, 1.6333});        ArrayRealVector actual = realVectorFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseNonDefaultSetting() {        String source =            "[1" + getDecimalCharacter() +            "2323 : 1" + getDecimalCharacter() +            "4343 : 1" + getDecimalCharacter() +            "6333]";        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});        ArrayRealVector actual = realVectorFormatSquare.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseNan() {        String source = "{(NaN); (NaN); (NaN)}";        ArrayRealVector actual = realVectorFormat.parse(source);        Assert.assertEquals(new ArrayRealVector(new double[] {Double.NaN, Double.NaN, Double.NaN}), actual);    }    @Test    public void testParsePositiveInfinity() {        String source = "{(Infinity); (Infinity); (Infinity)}";        ArrayRealVector actual = realVectorFormat.parse(source);        Assert.assertEquals(new ArrayRealVector(new double[] {                Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY        }), actual);    }    @Test    public void testParseNegativeInfinity() {        String source = "{(-Infinity); (-Infinity); (-Infinity)}";        ArrayRealVector actual = realVectorFormat.parse(source);        Assert.assertEquals(new ArrayRealVector(new double[] {                Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY        }), actual);    }    @Test    public void testParseNoComponents() {        try {            realVectorFormat.parse("{ }");            Assert.fail("Expecting MathParseException");        } catch (MathParseException pe) {            // expected behavior        }    }    @Test    public void testParseManyComponents() {        ArrayRealVector parsed = realVectorFormat.parse("{0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0}");        Assert.assertEquals(24, parsed.getDimension());    }    @Test    public void testConstructorSingleFormat() {        NumberFormat nf = NumberFormat.getInstance();        RealVectorFormat cf = new RealVectorFormat(nf);        Assert.assertNotNull(cf);        Assert.assertEquals(nf, cf.getFormat());    }    @Test    public void testForgottenPrefix() {        ParsePosition pos = new ParsePosition(0);        final String source = "1; 1; 1}";        Assert.assertNull("Should not parse <"+source+">",new RealVectorFormat().parse(source, pos));        Assert.assertEquals(0, pos.getErrorIndex());    }    @Test    public void testForgottenSeparator() {        ParsePosition pos = new ParsePosition(0);        final String source = "{1; 1 1}";        Assert.assertNull("Should not parse <"+source+">",new RealVectorFormat().parse(source, pos));        Assert.assertEquals(6, pos.getErrorIndex());    }    @Test    public void testForgottenSuffix() {        ParsePosition pos = new ParsePosition(0);        final String source = "{1; 1; 1 ";        Assert.assertNull("Should not parse <"+source+">",new RealVectorFormat().parse(source, pos));        Assert.assertEquals(8, pos.getErrorIndex());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Locale;public class RealVectorFormatTest extends RealVectorFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return '.';    }    @Override    protected Locale getLocale() {        return Locale.US;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.junit.Assert;import org.junit.Test;public class CholeskySolverTest {    private double[][] testData = new double[][] {            {  1,  2,   4,   7,  11 },            {  2, 13,  23,  38,  58 },            {  4, 23,  77, 122, 182 },            {  7, 38, 122, 294, 430 },            { 11, 58, 182, 430, 855 }    };    /** test solve dimension errors */    @Test    public void testSolveDimensionErrors() {        DecompositionSolver solver =            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);        try {            solver.solve(b);            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException iae) {            // expected behavior        }        try {            solver.solve(b.getColumnVector(0));            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException iae) {            // expected behavior        }        try {            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException iae) {            // expected behavior        }    }    /** test solve */    @Test    public void testSolve() {        DecompositionSolver solver =            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                {   78,  -13,    1 },                {  414,  -62,   -1 },                { 1312, -202,  -37 },                { 2989, -542,  145 },                { 5510, -1465, 201 }        });        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                { 1,  0,  1 },                { 0,  1,  1 },                { 2,  1, -4 },                { 2,  2,  2 },                { 5, -3,  0 }        });        // using RealMatrix        Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);        // using double[][]        Assert.assertEquals(0, MatrixUtils.createRealMatrix(solver.solve(b.getData())).subtract(xRef).getNorm(), 1.0e-13);        // using ArrayRealVector        for (int i = 0; i < b.getColumnDimension(); ++i) {            Assert.assertEquals(0,                         solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }        // using RealVector with an alternate implementation        for (int i = 0; i < b.getColumnDimension(); ++i) {            ArrayRealVectorTest.RealVectorTestImpl v =                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));            Assert.assertEquals(0,                         solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }    }    /** test determinant */    @Test    public void testDeterminant() {        Assert.assertEquals(7290000.0, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15);    }    private double getDeterminant(RealMatrix m) {        return new CholeskyDecompositionImpl(m).getDeterminant();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Arrays;import java.util.Random;import org.junit.Test;import org.junit.Assert;import org.apache.commons.math.TestUtils;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionField;import org.apache.commons.math.exception.NoDataException;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.exception.OutOfRangeException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.exception.NotStrictlyPositiveException;import org.apache.commons.math.exception.MathIllegalArgumentException;/** * Test cases for the {@link BlockFieldMatrix} class. * * @version $Id$ */public final class BlockFieldMatrixTest {    // 3 x 3 identity matrix    protected Fraction[][] id = {            {new Fraction(1),new Fraction(0),new Fraction(0)},            {new Fraction(0),new Fraction(1),new Fraction(0)},            {new Fraction(0),new Fraction(0),new Fraction(1)}    };    // Test data for group operations    protected Fraction[][] testData = {            {new Fraction(1),new Fraction(2),new Fraction(3)},            {new Fraction(2),new Fraction(5),new Fraction(3)},            {new Fraction(1),new Fraction(0),new Fraction(8)}    };    protected Fraction[][] testDataLU = {            {new Fraction(2), new Fraction(5), new Fraction(3)},            {new Fraction(1, 2), new Fraction(-5, 2), new Fraction(13, 2)},            {new Fraction(1, 2), new Fraction(1, 5), new Fraction(1, 5)}    };    protected Fraction[][] testDataPlus2 = {            {new Fraction(3),new Fraction(4),new Fraction(5)},            {new Fraction(4),new Fraction(7),new Fraction(5)},            {new Fraction(3),new Fraction(2),new Fraction(10)}    };    protected Fraction[][] testDataMinus = {            {new Fraction(-1),new Fraction(-2),new Fraction(-3)},            {new Fraction(-2),new Fraction(-5),new Fraction(-3)},            {new Fraction(-1),new Fraction(0),new Fraction(-8)}    };    protected Fraction[] testDataRow1 = {new Fraction(1),new Fraction(2),new Fraction(3)};    protected Fraction[] testDataCol3 = {new Fraction(3),new Fraction(3),new Fraction(8)};    protected Fraction[][] testDataInv = {            {new Fraction(-40),new Fraction(16),new Fraction(9)},            {new Fraction(13),new Fraction(-5),new Fraction(-3)},            {new Fraction(5),new Fraction(-2),new Fraction(-1)}    };    protected Fraction[] preMultTest = {new Fraction(8), new Fraction(12), new Fraction(33)};    protected Fraction[][] testData2 = {            {new Fraction(1),new Fraction(2),new Fraction(3)},            {new Fraction(2),new Fraction(5),new Fraction(3)}    };    protected Fraction[][] testData2T = {            {new Fraction(1),new Fraction(2)},            {new Fraction(2),new Fraction(5)},            {new Fraction(3),new Fraction(3)}    };    protected Fraction[][] testDataPlusInv = {            {new Fraction(-39),new Fraction(18),new Fraction(12)},            {new Fraction(15),new Fraction(0),new Fraction(0)},            {new Fraction(6),new Fraction(-2),new Fraction(7)}    };    // lu decomposition tests    protected Fraction[][] luData = {            {new Fraction(2),new Fraction(3),new Fraction(3)},            {new Fraction(0),new Fraction(5),new Fraction(7)},            {new Fraction(6),new Fraction(9),new Fraction(8)}    };    protected Fraction[][] luDataLUDecomposition = {            {new Fraction(6),new Fraction(9),new Fraction(8)},            {new Fraction(0),new Fraction(5),new Fraction(7)},            {new Fraction(1, 3),new Fraction(0),new Fraction(1, 3)}    };    // singular matrices    protected Fraction[][] singular = { {new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(3)} };    protected Fraction[][] bigSingular = {            {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},            {new Fraction(2),new Fraction(5),new Fraction(3),new Fraction(4)},            {new Fraction(7),new Fraction(3),new Fraction(256),new Fraction(1930)},            {new Fraction(3),new Fraction(7),new Fraction(6),new Fraction(8)}    }; // 4th row = 1st + 2nd    protected Fraction[][] detData = {            {new Fraction(1),new Fraction(2),new Fraction(3)},            {new Fraction(4),new Fraction(5),new Fraction(6)},            {new Fraction(7),new Fraction(8),new Fraction(10)}    };    protected Fraction[][] detData2 = { {new Fraction(1), new Fraction(3)}, {new Fraction(2), new Fraction(4)}};    // vectors    protected Fraction[] testVector = {new Fraction(1),new Fraction(2),new Fraction(3)};    protected Fraction[] testVector2 = {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)};    // submatrix accessor tests    protected Fraction[][] subTestData = {            {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)},            {new Fraction(3, 2), new Fraction(5, 2), new Fraction(7, 2), new Fraction(9, 2)},            {new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8)},            {new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7)}    };    // array selections    protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4)}, {new Fraction(4), new Fraction(8)}};    protected Fraction[][] subRows03Cols12 = { {new Fraction(2), new Fraction(3)}, {new Fraction(5), new Fraction(6)}};    protected Fraction[][] subRows03Cols123 = {            {new Fraction(2), new Fraction(3), new Fraction(4)},            {new Fraction(5), new Fraction(6), new Fraction(7)}    };    // effective permutations    protected Fraction[][] subRows20Cols123 = {            {new Fraction(4), new Fraction(6), new Fraction(8)},            {new Fraction(2), new Fraction(3), new Fraction(4)}    };    protected Fraction[][] subRows31Cols31 = {{new Fraction(7), new Fraction(5)}, {new Fraction(9, 2), new Fraction(5, 2)}};    // contiguous ranges    protected Fraction[][] subRows01Cols23 = {{new Fraction(3),new Fraction(4)} , {new Fraction(7, 2), new Fraction(9, 2)}};    protected Fraction[][] subRows23Cols00 = {{new Fraction(2)} , {new Fraction(4)}};    protected Fraction[][] subRows00Cols33 = {{new Fraction(4)}};    // row matrices    protected Fraction[][] subRow0 = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}};    protected Fraction[][] subRow3 = {{new Fraction(4),new Fraction(5),new Fraction(6),new Fraction(7)}};    // column matrices    protected Fraction[][] subColumn1 = {{new Fraction(2)}, {new Fraction(5, 2)}, {new Fraction(4)}, {new Fraction(5)}};    protected Fraction[][] subColumn3 = {{new Fraction(4)}, {new Fraction(9, 2)}, {new Fraction(8)}, {new Fraction(7)}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    /** test dimensions */    @Test    public void testDimensions() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);        Assert.assertEquals("testData row dimension",3,m.getRowDimension());        Assert.assertEquals("testData column dimension",3,m.getColumnDimension());        Assert.assertTrue("testData is square",m.isSquare());        Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2);        Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        Assert.assertTrue("testData2 is not square",!m2.isSquare());    }    /** test copy functions */    @Test    public void testCopyFunctions() {        Random r = new Random(66636328996002l);        BlockFieldMatrix<Fraction> m1 = createRandomMatrix(r, 47, 83);        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(m1.getData());        Assert.assertEquals(m1, m2);        BlockFieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(m3.getData());        Assert.assertEquals(m3, m4);    }    /** test add */    @Test    public void testAdd() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);        FieldMatrix<Fraction> mPlusMInv = m.add(mInv);        Fraction[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                Assert.assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);            }        }    }    /** test add failure */    @Test    public void testAddFail() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);        try {            m.add(m2);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }     /** test m-n = m + -n */    @Test    public void testPlusMinus() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testDataInv);        TestUtils.assertEquals(m.subtract(m2), m2.scalarMultiply(new Fraction(-1)).add(m));        try {            m.subtract(new BlockFieldMatrix<Fraction>(testData2));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    /** test multiply */    @Test    public void testMultiply() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);        BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id);        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);        TestUtils.assertEquals(m.multiply(mInv), identity);        TestUtils.assertEquals(mInv.multiply(m), identity);        TestUtils.assertEquals(m.multiply(identity), m);        TestUtils.assertEquals(identity.multiply(mInv), mInv);        TestUtils.assertEquals(m2.multiply(identity), m2);        try {            m.multiply(new BlockFieldMatrix<Fraction>(bigSingular));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testSeveralBlocks() {        FieldMatrix<Fraction> m =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), 37, 41);        for (int i = 0; i < m.getRowDimension(); ++i) {            for (int j = 0; j < m.getColumnDimension(); ++j) {                m.setEntry(i, j, new Fraction(i * 11 + j, 11));            }        }        FieldMatrix<Fraction> mT = m.transpose();        Assert.assertEquals(m.getRowDimension(), mT.getColumnDimension());        Assert.assertEquals(m.getColumnDimension(), mT.getRowDimension());        for (int i = 0; i < mT.getRowDimension(); ++i) {            for (int j = 0; j < mT.getColumnDimension(); ++j) {                Assert.assertEquals(m.getEntry(j, i), mT.getEntry(i, j));            }        }        FieldMatrix<Fraction> mPm = m.add(m);        for (int i = 0; i < mPm.getRowDimension(); ++i) {            for (int j = 0; j < mPm.getColumnDimension(); ++j) {                Assert.assertEquals(m.getEntry(i, j).multiply(new Fraction(2)), mPm.getEntry(i, j));            }        }        FieldMatrix<Fraction> mPmMm = mPm.subtract(m);        for (int i = 0; i < mPmMm.getRowDimension(); ++i) {            for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {                Assert.assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j));            }        }        FieldMatrix<Fraction> mTm = mT.multiply(m);        for (int i = 0; i < mTm.getRowDimension(); ++i) {            for (int j = 0; j < mTm.getColumnDimension(); ++j) {                Fraction sum = Fraction.ZERO;                for (int k = 0; k < mT.getColumnDimension(); ++k) {                    sum = sum.add(new Fraction(k * 11 + i, 11).multiply(new Fraction(k * 11 + j, 11)));                }                Assert.assertEquals(sum, mTm.getEntry(i, j));            }        }        FieldMatrix<Fraction> mmT = m.multiply(mT);        for (int i = 0; i < mmT.getRowDimension(); ++i) {            for (int j = 0; j < mmT.getColumnDimension(); ++j) {                Fraction sum = Fraction.ZERO;                for (int k = 0; k < m.getColumnDimension(); ++k) {                    sum = sum.add(new Fraction(i * 11 + k, 11).multiply(new Fraction(j * 11 + k, 11)));                }                Assert.assertEquals(sum, mmT.getEntry(i, j));            }        }        FieldMatrix<Fraction> sub1 = m.getSubMatrix(2, 9, 5, 20);        for (int i = 0; i < sub1.getRowDimension(); ++i) {            for (int j = 0; j < sub1.getColumnDimension(); ++j) {                Assert.assertEquals(new Fraction((i + 2) * 11 + (j + 5), 11), sub1.getEntry(i, j));            }        }        FieldMatrix<Fraction> sub2 = m.getSubMatrix(10, 12, 3, 40);        for (int i = 0; i < sub2.getRowDimension(); ++i) {            for (int j = 0; j < sub2.getColumnDimension(); ++j) {                Assert.assertEquals(new Fraction((i + 10) * 11 + (j + 3), 11), sub2.getEntry(i, j));            }        }        FieldMatrix<Fraction> sub3 = m.getSubMatrix(30, 34, 0, 5);        for (int i = 0; i < sub3.getRowDimension(); ++i) {            for (int j = 0; j < sub3.getColumnDimension(); ++j) {                Assert.assertEquals(new Fraction((i + 30) * 11 + (j + 0), 11), sub3.getEntry(i, j));            }        }        FieldMatrix<Fraction> sub4 = m.getSubMatrix(30, 32, 32, 35);        for (int i = 0; i < sub4.getRowDimension(); ++i) {            for (int j = 0; j < sub4.getColumnDimension(); ++j) {                Assert.assertEquals(new Fraction((i + 30) * 11 + (j + 32), 11), sub4.getEntry(i, j));            }        }    }    //Additional Test for BlockFieldMatrix<Fraction>Test.testMultiply    private Fraction[][] d3 = new Fraction[][] {            {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},            {new Fraction(5),new Fraction(6),new Fraction(7),new Fraction(8)}    };    private Fraction[][] d4 = new Fraction[][] {            {new Fraction(1)},            {new Fraction(2)},            {new Fraction(3)},            {new Fraction(4)}    };    private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}};    @Test    public void testMultiply2() {       FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);       FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4);       FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5);       TestUtils.assertEquals(m3.multiply(m4), m5);   }    /** test trace */    @Test    public void testTrace() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id);        Assert.assertEquals(new Fraction(3),m.getTrace());        m = new BlockFieldMatrix<Fraction>(testData2);        try {            m.getTrace();            Assert.fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }    }    /** test scalarAdd */    @Test    public void testScalarAdd() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(new BlockFieldMatrix<Fraction>(testDataPlus2),                               m.scalarAdd(new Fraction(2)));    }    /** test operate */    @Test    public void testOperate() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id);        TestUtils.assertEquals(testVector, m.operate(testVector));        TestUtils.assertEquals(testVector, m.operate(new ArrayFieldVector<Fraction>(testVector)).getData());        m = new BlockFieldMatrix<Fraction>(bigSingular);        try {            m.operate(testVector);            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    @Test    public void testOperateLarge() {        int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;        int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;        int r =  BlockFieldMatrix.BLOCK_SIZE / 2;        Random random = new Random(111007463902334l);        FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q);        FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r);        FieldMatrix<Fraction> m1m2 = m1.multiply(m2);        for (int i = 0; i < r; ++i) {            TestUtils.assertEquals(m1m2.getColumn(i), m1.operate(m2.getColumn(i)));        }    }    @Test    public void testOperatePremultiplyLarge() {        int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;        int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;        int r =  BlockFieldMatrix.BLOCK_SIZE / 2;        Random random = new Random(111007463902334l);        FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q);        FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r);        FieldMatrix<Fraction> m1m2 = m1.multiply(m2);        for (int i = 0; i < p; ++i) {            TestUtils.assertEquals(m1m2.getRow(i), m2.preMultiply(m1.getRow(i)));        }    }    /** test issue MATH-209 */    @Test    public void testMath209() {        FieldMatrix<Fraction> a = new BlockFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(1), new Fraction(2) },                { new Fraction(3), new Fraction(4) },                { new Fraction(5), new Fraction(6) }        });        Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });        Assert.assertEquals(a.getRowDimension(), b.length);        Assert.assertEquals( new Fraction(3), b[0]);        Assert.assertEquals( new Fraction(7), b[1]);        Assert.assertEquals(new Fraction(11), b[2]);    }    /** test transpose */    @Test    public void testTranspose() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();        TestUtils.assertEquals(mIT, mTI);        m = new BlockFieldMatrix<Fraction>(testData2);        FieldMatrix<Fraction> mt = new BlockFieldMatrix<Fraction>(testData2T);        TestUtils.assertEquals(mt, m.transpose());    }    /** test preMultiply by vector */    @Test    public void testPremultiplyVector() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(m.preMultiply(testVector), preMultTest);        TestUtils.assertEquals(m.preMultiply(new ArrayFieldVector<Fraction>(testVector).getData()),                               preMultTest);        m = new BlockFieldMatrix<Fraction>(bigSingular);        try {            m.preMultiply(testVector);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    @Test    public void testPremultiply() {        FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);        FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4);        FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5);        TestUtils.assertEquals(m4.preMultiply(m3), m5);        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);        BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id);        TestUtils.assertEquals(m.preMultiply(mInv), identity);        TestUtils.assertEquals(mInv.preMultiply(m), identity);        TestUtils.assertEquals(m.preMultiply(identity), m);        TestUtils.assertEquals(identity.preMultiply(mInv), mInv);        try {            m.preMultiply(new BlockFieldMatrix<Fraction>(bigSingular));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    @Test    public void testGetVectors() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(m.getRow(0), testDataRow1);        TestUtils.assertEquals(m.getColumn(2), testDataCol3);        try {            m.getRow(10);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // ignored        }        try {            m.getColumn(-1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // ignored        }    }    @Test    public void testGetEntry() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        Assert.assertEquals(m.getEntry(0,1),new Fraction(2));        try {            m.getEntry(10, 4);            Assert.fail ("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    /** test examples in user guide */    @Test    public void testExamples() {        // Create a real matrix with two rows and three columns        Fraction[][] matrixData = {                {new Fraction(1),new Fraction(2),new Fraction(3)},                {new Fraction(2),new Fraction(5),new Fraction(3)}        };        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(matrixData);        // One more with three rows, two columns        Fraction[][] matrixData2 = {                {new Fraction(1),new Fraction(2)},                {new Fraction(2),new Fraction(5)},                {new Fraction(1), new Fraction(7)}        };        FieldMatrix<Fraction> n = new BlockFieldMatrix<Fraction>(matrixData2);        // Now multiply m by n        FieldMatrix<Fraction> p = m.multiply(n);        Assert.assertEquals(2, p.getRowDimension());        Assert.assertEquals(2, p.getColumnDimension());        // Invert p        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();        Assert.assertEquals(2, pInverse.getRowDimension());        Assert.assertEquals(2, pInverse.getColumnDimension());        // Solve example        Fraction[][] coefficientsData = {                {new Fraction(2), new Fraction(3), new Fraction(-2)},                {new Fraction(-1), new Fraction(7), new Fraction(6)},                {new Fraction(4), new Fraction(-3), new Fraction(-5)}        };        FieldMatrix<Fraction> coefficients = new BlockFieldMatrix<Fraction>(coefficientsData);        Fraction[] constants = {new Fraction(1), new Fraction(-2), new Fraction(1)};        Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);        Assert.assertEquals(new Fraction(2).multiply(solution[0]).                     add(new Fraction(3).multiply(solution[1])).                     subtract(new Fraction(2).multiply(solution[2])),                     constants[0]);        Assert.assertEquals(new Fraction(-1).multiply(solution[0]).                     add(new Fraction(7).multiply(solution[1])).                     add(new Fraction(6).multiply(solution[2])),                     constants[1]);        Assert.assertEquals(new Fraction(4).multiply(solution[0]).                     subtract(new Fraction(3).multiply(solution[1])).                     subtract(new Fraction(5).multiply(solution[2])),                     constants[2]);    }    // test submatrix accessors    @Test    public void testGetSubMatrix() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkGetSubMatrix(m, null,  1, 0, 2, 4);        checkGetSubMatrix(m, null, -1, 1, 2, 2);        checkGetSubMatrix(m, null,  1, 0, 2, 2);        checkGetSubMatrix(m, null,  1, 0, 2, 4);        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 });        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 });    }    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,                                   int startRow, int endRow, int startColumn, int endColumn) {        try {            FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);            if (reference != null) {                Assert.assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);            } else {                Assert.fail("Expecting OutOfRangeException or NotStrictlyPositiveException"                     + " or NumberIsTooSmallException or NoDataException");            }        } catch (OutOfRangeException e) {            if (reference != null) {                throw e;            }        } catch (NotStrictlyPositiveException e) {            if (reference != null) {                throw e;            }        } catch (NumberIsTooSmallException e) {            if (reference != null) {                throw e;            }        } catch (NoDataException e) {            if (reference != null) {                throw e;            }        }    }    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,                                   int[] selectedRows, int[] selectedColumns) {        try {            FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);            if (reference != null) {                Assert.assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);            } else {                Assert.fail("Expecting OutOfRangeException");            }        } catch (OutOfRangeException e) {            if (reference != null) {                throw e;            }        } catch (NotStrictlyPositiveException e) {            if (reference != null) {                throw e;            }        } catch (NumberIsTooSmallException e) {            if (reference != null) {                throw e;            }        } catch (NoDataException e) {            if (reference != null) {                throw e;            }        }    }    @Test    public void testGetSetMatrixLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        FieldMatrix<Fraction> sub =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n - 4, n - 4).scalarAdd(new Fraction(1));        m.setSubMatrix(sub.getData(), 2, 2);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {                    Assert.assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    Assert.assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        Assert.assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));    }    @Test    public void testCopySubMatrix() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkCopy(m, null,  1, 0, 2, 4);        checkCopy(m, null, -1, 1, 2, 2);        checkCopy(m, null,  1, 0, 2, 2);        checkCopy(m, null,  1, 0, 2, 4);        checkCopy(m, null, new int[] {}, new int[] { 0 });        checkCopy(m, null, new int[] { 0 }, new int[] { 4 });    }    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,                           int startRow, int endRow, int startColumn, int endColumn) {        try {            Fraction[][] sub = (reference == null) ?                             new Fraction[1][1] :                             new Fraction[reference.length][reference[0].length];            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);            if (reference != null) {                Assert.assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));            } else {                Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");            }        } catch (OutOfRangeException e) {            if (reference != null) {                throw e;            }        } catch (NumberIsTooSmallException e) {            if (reference != null) {                throw e;            }        } catch (NoDataException e) {            if (reference != null) {                throw e;            }        }    }    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,                           int[] selectedRows, int[] selectedColumns) {        try {            Fraction[][] sub = (reference == null) ?                    new Fraction[1][1] :                    new Fraction[reference.length][reference[0].length];            m.copySubMatrix(selectedRows, selectedColumns, sub);            if (reference != null) {                Assert.assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));            } else {                Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");            }        } catch (OutOfRangeException e) {            if (reference != null) {                throw e;            }        } catch (NumberIsTooSmallException e) {            if (reference != null) {                throw e;            }        } catch (NoDataException e) {            if (reference != null) {                throw e;            }        }    }    @Test    public void testGetRowMatrix() {        FieldMatrix<Fraction> m     = new BlockFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mRow0 = new BlockFieldMatrix<Fraction>(subRow0);        FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3);        Assert.assertEquals("Row0", mRow0, m.getRowMatrix(0));        Assert.assertEquals("Row3", mRow3, m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getRowMatrix(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetRowMatrix() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3);        Assert.assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowMatrix(0, mRow3);        Assert.assertEquals(mRow3, m.getRowMatrix(0));        try {            m.setRowMatrix(-1, mRow3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setRowMatrix(0, m);            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetSetRowMatrixLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        FieldMatrix<Fraction> sub =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), 1, n).scalarAdd(new Fraction(1));        m.setRowMatrix(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    Assert.assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    Assert.assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        Assert.assertEquals(sub, m.getRowMatrix(2));    }    @Test    public void testGetColumnMatrix() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mColumn1 = new BlockFieldMatrix<Fraction>(subColumn1);        FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3);        Assert.assertEquals(mColumn1, m.getColumnMatrix(1));        Assert.assertEquals(mColumn3, m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getColumnMatrix(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetColumnMatrix() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3);        Assert.assertNotSame(mColumn3, m.getColumnMatrix(1));        m.setColumnMatrix(1, mColumn3);        Assert.assertEquals(mColumn3, m.getColumnMatrix(1));        try {            m.setColumnMatrix(-1, mColumn3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setColumnMatrix(0, m);            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetSetColumnMatrixLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        FieldMatrix<Fraction> sub =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, 1).scalarAdd(new Fraction(1));        m.setColumnMatrix(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    Assert.assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    Assert.assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        Assert.assertEquals(sub, m.getColumnMatrix(2));    }    @Test    public void testGetRowVector() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);        Assert.assertEquals(mRow0, m.getRowVector(0));        Assert.assertEquals(mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getRowVector(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetRowVector() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);        Assert.assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowVector(0, mRow3);        Assert.assertEquals(mRow3, m.getRowVector(0));        try {            m.setRowVector(-1, mRow3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setRowVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetSetRowVectorLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        FieldVector<Fraction> sub = new ArrayFieldVector<Fraction>(n, new Fraction(1));        m.setRowVector(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    Assert.assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    Assert.assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        Assert.assertEquals(sub, m.getRowVector(2));    }    @Test    public void testGetColumnVector() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);        Assert.assertEquals(mColumn1, m.getColumnVector(1));        Assert.assertEquals(mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getColumnVector(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetColumnVector() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);        Assert.assertNotSame(mColumn3, m.getColumnVector(1));        m.setColumnVector(1, mColumn3);        Assert.assertEquals(mColumn3, m.getColumnVector(1));        try {            m.setColumnVector(-1, mColumn3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setColumnVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetSetColumnVectorLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        FieldVector<Fraction> sub = new ArrayFieldVector<Fraction>(n, new Fraction(1));        m.setColumnVector(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    Assert.assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    Assert.assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        Assert.assertEquals(sub, m.getColumnVector(2));    }    private FieldVector<Fraction> columnToVector(Fraction[][] column) {        Fraction[] data = new Fraction[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayFieldVector<Fraction>(data, false);    }    @Test    public void testGetRow() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        checkArrays(subRow0[0], m.getRow(0));        checkArrays(subRow3[0], m.getRow(3));        try {            m.getRow(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getRow(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetRow() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]);        m.setRow(0, subRow3[0]);        checkArrays(subRow3[0], m.getRow(0));        try {            m.setRow(-1, subRow3[0]);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setRow(0, new Fraction[5]);            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetSetRowLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        Fraction[] sub = new Fraction[n];        Arrays.fill(sub, new Fraction(1));        m.setRow(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    Assert.assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    Assert.assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        checkArrays(sub, m.getRow(2));    }    @Test    public void testGetColumn() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        Fraction[] mColumn1 = columnToArray(subColumn1);        Fraction[] mColumn3 = columnToArray(subColumn3);        checkArrays(mColumn1, m.getColumn(1));        checkArrays(mColumn3, m.getColumn(3));        try {            m.getColumn(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getColumn(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetColumn() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        Fraction[] mColumn3 = columnToArray(subColumn3);        Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]);        m.setColumn(1, mColumn3);        checkArrays(mColumn3, m.getColumn(1));        try {            m.setColumn(-1, mColumn3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setColumn(0, new Fraction[5]);            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetSetColumnLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        Fraction[] sub = new Fraction[n];        Arrays.fill(sub, new Fraction(1));        m.setColumn(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    Assert.assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    Assert.assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        checkArrays(sub, m.getColumn(2));    }    private Fraction[] columnToArray(Fraction[][] column) {        Fraction[] data = new Fraction[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return data;    }    private void checkArrays(Fraction[] expected, Fraction[] actual) {        Assert.assertEquals(expected.length, actual.length);        for (int i = 0; i < expected.length; ++i) {            Assert.assertEquals(expected[i], actual[i]);        }    }    @Test    public void testEqualsAndHashCode() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> m1 = (BlockFieldMatrix<Fraction>) m.copy();        BlockFieldMatrix<Fraction> mt = (BlockFieldMatrix<Fraction>) m.transpose();        Assert.assertTrue(m.hashCode() != mt.hashCode());        Assert.assertEquals(m.hashCode(), m1.hashCode());        Assert.assertEquals(m, m);        Assert.assertEquals(m, m1);        Assert.assertFalse(m.equals(null));        Assert.assertFalse(m.equals(mt));        Assert.assertFalse(m.equals(new BlockFieldMatrix<Fraction>(bigSingular)));    }    @Test    public void testToString() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        Assert.assertEquals("BlockFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}", m.toString());    }    @Test    public void testSetSubMatrix() throws Exception {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        m.setSubMatrix(detData2,1,1);        FieldMatrix<Fraction> expected = new BlockFieldMatrix<Fraction>            (new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(2),new Fraction(1),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});        Assert.assertEquals(expected, m);        m.setSubMatrix(detData2,0,0);        expected = new BlockFieldMatrix<Fraction>            (new Fraction[][] {{new Fraction(1),new Fraction(3),new Fraction(3)},{new Fraction(2),new Fraction(4),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});        Assert.assertEquals(expected, m);        m.setSubMatrix(testDataPlus2,0,0);        expected = new BlockFieldMatrix<Fraction>            (new Fraction[][] {{new Fraction(3),new Fraction(4),new Fraction(5)},{new Fraction(4),new Fraction(7),new Fraction(5)},{new Fraction(3),new Fraction(2),new Fraction(10)}});        Assert.assertEquals(expected, m);        // javadoc example        BlockFieldMatrix<Fraction> matrix =            new BlockFieldMatrix<Fraction>(new Fraction[][] {                    {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)},                    {new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8)},                    {new Fraction(9), new Fraction(0), new Fraction(1) , new Fraction(2)}            });        matrix.setSubMatrix(new Fraction[][] {                {new Fraction(3), new Fraction(4)},                {new Fraction(5), new Fraction(6)}        }, 1, 1);        expected =            new BlockFieldMatrix<Fraction>(new Fraction[][] {                    {new Fraction(1), new Fraction(2), new Fraction(3),new Fraction(4)},                    {new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8)},                    {new Fraction(9), new Fraction(5) ,new Fraction(6), new Fraction(2)}            });        Assert.assertEquals(expected, matrix);        // dimension overflow        try {            m.setSubMatrix(testData,1,1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        // dimension underflow        try {            m.setSubMatrix(testData,-1,1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        try {            m.setSubMatrix(testData,1,-1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        // null        try {            m.setSubMatrix(null,1,1);            Assert.fail("expecting NullArgumentException");        } catch (NullArgumentException e) {            // expected        }        // ragged        try {            m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected        }        // empty        try {            m.setSubMatrix(new Fraction[][] {{}}, 0, 0);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected        }    }    @Test    public void testWalk() throws MathUserException {        int rows    = 150;        int columns = 75;        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInRowOrder(new SetVisitor());        GetVisitor getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        Assert.assertEquals(rows * columns, getVisitor.getCount());        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            Assert.assertEquals(new Fraction(0), m.getEntry(i, 0));            Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            Assert.assertEquals(new Fraction(0), m.getEntry(0, j));            Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInColumnOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        Assert.assertEquals(rows * columns, getVisitor.getCount());        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            Assert.assertEquals(new Fraction(0), m.getEntry(i, 0));            Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            Assert.assertEquals(new Fraction(0), m.getEntry(0, j));            Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor);        Assert.assertEquals(rows * columns, getVisitor.getCount());        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            Assert.assertEquals(new Fraction(0), m.getEntry(i, 0));            Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            Assert.assertEquals(new Fraction(0), m.getEntry(0, j));            Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor);        Assert.assertEquals(rows * columns, getVisitor.getCount());        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            Assert.assertEquals(new Fraction(0), m.getEntry(i, 0));            Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            Assert.assertEquals(new Fraction(0), m.getEntry(0, j));            Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }    }    @Test    public void testSerial()  {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        Assert.assertEquals(m,TestUtils.serializeAndRecover(m));    }    private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Fraction> {        public SetVisitor() {            super(Fraction.ZERO);        }        @Override        public Fraction visit(int i, int j, Fraction value) {            return new Fraction(i * 11 + j, 11);        }    }    private static class GetVisitor extends DefaultFieldMatrixPreservingVisitor<Fraction> {        private int count;        public GetVisitor() {            super(Fraction.ZERO);            count = 0;        }        @Override        public void visit(int i, int j, Fraction value) {            ++count;            Assert.assertEquals(new Fraction(i * 11 + j, 11), value);        }        public int getCount() {            return count;        }    }    private BlockFieldMatrix<Fraction> createRandomMatrix(Random r, int rows, int columns) {        BlockFieldMatrix<Fraction> m =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        for (int i = 0; i < rows; ++i) {            for (int j = 0; j < columns; ++j) {                int p = r.nextInt(20) - 10;                int q = r.nextInt(20) - 10;                if (q == 0) {                    q = 1;                }                m.setEntry(i, j, new Fraction(p, q));            }        }        return m;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.junit.Test;import org.junit.Assert;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.exception.OutOfRangeException;import org.apache.commons.math.exception.NoDataException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.exception.MathIllegalStateException;/** * Test cases for the {@link Array2DRowRealMatrix} class. * * @version $Id$ */public final class Array2DRowRealMatrixTest {    // 3 x 3 identity matrix    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };    // Test data for group operations    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},       {-1d,0d,-8d} };    protected double[] testDataRow1 = {1d,2d,3d};    protected double[] testDataCol3 = {3d,3d,8d};    protected double[][] testDataInv =        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };    protected double[] preMultTest = {8,12,33};    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};    protected double[][] testDataPlusInv =        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };    // lu decomposition tests    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},            {0.33333333333333,0d,0.33333333333333} };    // singular matrices    protected double[][] singular = { {2d,3d}, {2d,3d} };    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};    // vectors    protected double[] testVector = {1,2,3};    protected double[] testVector2 = {1,2,3,4};    // submatrix accessor tests    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},            {2, 4, 6, 8}, {4, 5, 6, 7}};    // array selections    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};    // effective permutations    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};    // contiguous ranges    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};    protected double[][] subRows23Cols00 = {{2} , {4}};    protected double[][] subRows00Cols33 = {{4}};    // row matrices    protected double[][] subRow0 = {{1,2,3,4}};    protected double[][] subRow3 = {{4,5,6,7}};    // column matrices    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    protected double powerTolerance = 10E-16;    /** test dimensions */    @Test    public void testDimensions() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);        Assert.assertEquals("testData row dimension",3,m.getRowDimension());        Assert.assertEquals("testData column dimension",3,m.getColumnDimension());        Assert.assertTrue("testData is square",m.isSquare());        Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2);        Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        Assert.assertTrue("testData2 is not square",!m2.isSquare());    }    /** test copy functions */    @Test    public void testCopyFunctions() {        Array2DRowRealMatrix m1 = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(m1.getData());        Assert.assertEquals(m2,m1);        Array2DRowRealMatrix m3 = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m4 = new Array2DRowRealMatrix(m3.getData(), false);        Assert.assertEquals(m4,m3);    }    /** test add */    @Test    public void testAdd() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);        RealMatrix mPlusMInv = m.add(mInv);        double[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                Assert.assertEquals("sum entry entry",                    testDataPlusInv[row][col],sumEntries[row][col],                        entryTolerance);            }        }    }    /** test add failure */    @Test    public void testAddFail() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);        try {            m.add(m2);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    /** test norm */    @Test    public void testNorm() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);        Assert.assertEquals("testData norm",14d,m.getNorm(),entryTolerance);        Assert.assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);    }    /** test Frobenius norm */    @Test    public void testFrobeniusNorm() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);        Assert.assertEquals("testData Frobenius norm", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);        Assert.assertEquals("testData2 Frobenius norm", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);    }     /** test m-n = m + -n */    @Test    public void testPlusMinus() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testDataInv);        TestUtils.assertEquals("m-n = m + -n",m.subtract(m2),            m2.scalarMultiply(-1d).add(m),entryTolerance);        try {            m.subtract(new Array2DRowRealMatrix(testData2));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    /** test multiply */    @Test    public void testMultiply() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);        Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);        TestUtils.assertEquals("inverse multiply",m.multiply(mInv),            identity,entryTolerance);        TestUtils.assertEquals("inverse multiply",mInv.multiply(m),            identity,entryTolerance);        TestUtils.assertEquals("identity multiply",m.multiply(identity),            m,entryTolerance);        TestUtils.assertEquals("identity multiply",identity.multiply(mInv),            mInv,entryTolerance);        TestUtils.assertEquals("identity multiply",m2.multiply(identity),            m2,entryTolerance);        try {            m.multiply(new Array2DRowRealMatrix(bigSingular));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    //Additional Test for Array2DRowRealMatrixTest.testMultiply    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};    private double[][] d4 = new double[][] {{1},{2},{3},{4}};    private double[][] d5 = new double[][] {{30},{70}};    @Test    public void testMultiply2() {       RealMatrix m3 = new Array2DRowRealMatrix(d3);       RealMatrix m4 = new Array2DRowRealMatrix(d4);       RealMatrix m5 = new Array2DRowRealMatrix(d5);       TestUtils.assertEquals("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);   }    @Test    public void testPower() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);        Array2DRowRealMatrix mPlusInv = new Array2DRowRealMatrix(testDataPlusInv);        Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id);        TestUtils.assertEquals("m^0", m.power(0),            identity, entryTolerance);        TestUtils.assertEquals("mInv^0", mInv.power(0),                identity, entryTolerance);        TestUtils.assertEquals("mPlusInv^0", mPlusInv.power(0),                identity, entryTolerance);        TestUtils.assertEquals("m^1", m.power(1),                m, entryTolerance);        TestUtils.assertEquals("mInv^1", mInv.power(1),                mInv, entryTolerance);        TestUtils.assertEquals("mPlusInv^1", mPlusInv.power(1),                mPlusInv, entryTolerance);        RealMatrix C1 = m.copy();        RealMatrix C2 = mInv.copy();        RealMatrix C3 = mPlusInv.copy();        for (int i = 2; i <= 10; ++i) {            C1 = C1.multiply(m);            C2 = C2.multiply(mInv);            C3 = C3.multiply(mPlusInv);            TestUtils.assertEquals("m^" + i, m.power(i),                    C1, entryTolerance);            TestUtils.assertEquals("mInv^" + i, mInv.power(i),                    C2, entryTolerance);            TestUtils.assertEquals("mPlusInv^" + i, mPlusInv.power(i),                    C3, entryTolerance);        }        try {            Array2DRowRealMatrix mNotSquare = new Array2DRowRealMatrix(testData2T);            mNotSquare.power(2);            Assert.fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }        try {            m.power(-1);            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test trace */    @Test    public void testTrace() {        RealMatrix m = new Array2DRowRealMatrix(id);        Assert.assertEquals("identity trace",3d,m.getTrace(),entryTolerance);        m = new Array2DRowRealMatrix(testData2);        try {            m.getTrace();            Assert.fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }    }    /** test sclarAdd */    @Test    public void testScalarAdd() {        RealMatrix m = new Array2DRowRealMatrix(testData);        TestUtils.assertEquals("scalar add",new Array2DRowRealMatrix(testDataPlus2),            m.scalarAdd(2d),entryTolerance);    }    /** test operate */    @Test    public void testOperate() {        RealMatrix m = new Array2DRowRealMatrix(id);        TestUtils.assertEquals("identity operate", testVector,                    m.operate(testVector), entryTolerance);        TestUtils.assertEquals("identity operate", testVector,                    m.operate(new ArrayRealVector(testVector)).getData(), entryTolerance);        m = new Array2DRowRealMatrix(bigSingular);        try {            m.operate(testVector);            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    /** test issue MATH-209 */    @Test    public void testMath209() {        RealMatrix a = new Array2DRowRealMatrix(new double[][] {                { 1, 2 }, { 3, 4 }, { 5, 6 }        }, false);        double[] b = a.operate(new double[] { 1, 1 });        Assert.assertEquals(a.getRowDimension(), b.length);        Assert.assertEquals( 3.0, b[0], 1.0e-12);        Assert.assertEquals( 7.0, b[1], 1.0e-12);        Assert.assertEquals(11.0, b[2], 1.0e-12);    }    /** test transpose */    @Test    public void testTranspose() {        RealMatrix m = new Array2DRowRealMatrix(testData);        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();        TestUtils.assertEquals("inverse-transpose", mIT, mTI, normTolerance);        m = new Array2DRowRealMatrix(testData2);        RealMatrix mt = new Array2DRowRealMatrix(testData2T);        TestUtils.assertEquals("transpose",mt,m.transpose(),normTolerance);    }    /** test preMultiply by vector */    @Test    public void testPremultiplyVector() {        RealMatrix m = new Array2DRowRealMatrix(testData);        TestUtils.assertEquals("premultiply", m.preMultiply(testVector),                    preMultTest, normTolerance);        TestUtils.assertEquals("premultiply", m.preMultiply(new ArrayRealVector(testVector).getData()),                    preMultTest, normTolerance);        m = new Array2DRowRealMatrix(bigSingular);        try {            m.preMultiply(testVector);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    @Test    public void testPremultiply() {        RealMatrix m3 = new Array2DRowRealMatrix(d3);        RealMatrix m4 = new Array2DRowRealMatrix(d4);        RealMatrix m5 = new Array2DRowRealMatrix(d5);        TestUtils.assertEquals("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);        Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id);        TestUtils.assertEquals("inverse multiply",m.preMultiply(mInv),                identity,entryTolerance);        TestUtils.assertEquals("inverse multiply",mInv.preMultiply(m),                identity,entryTolerance);        TestUtils.assertEquals("identity multiply",m.preMultiply(identity),                m,entryTolerance);        TestUtils.assertEquals("identity multiply",identity.preMultiply(mInv),                mInv,entryTolerance);        try {            m.preMultiply(new Array2DRowRealMatrix(bigSingular));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    @Test    public void testGetVectors() {        RealMatrix m = new Array2DRowRealMatrix(testData);        TestUtils.assertEquals("get row",m.getRow(0),testDataRow1,entryTolerance);        TestUtils.assertEquals("get col",m.getColumn(2),testDataCol3,entryTolerance);        try {            m.getRow(10);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // ignored        }        try {            m.getColumn(-1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // ignored        }    }    @Test    public void testGetEntry() {        RealMatrix m = new Array2DRowRealMatrix(testData);        Assert.assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);        try {            m.getEntry(10, 4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    /** test examples in user guide */    @Test    public void testExamples() {        // Create a real matrix with two rows and three columns        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};        RealMatrix m = new Array2DRowRealMatrix(matrixData);        // One more with three rows, two columns        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};        RealMatrix n = new Array2DRowRealMatrix(matrixData2);        // Now multiply m by n        RealMatrix p = m.multiply(n);        Assert.assertEquals(2, p.getRowDimension());        Assert.assertEquals(2, p.getColumnDimension());        // Invert p        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();        Assert.assertEquals(2, pInverse.getRowDimension());        Assert.assertEquals(2, pInverse.getColumnDimension());        // Solve example        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};        RealMatrix coefficients = new Array2DRowRealMatrix(coefficientsData);        RealVector constants = new ArrayRealVector(new double[]{1, -2, 1}, false);        RealVector solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);        final double cst0 = constants.getEntry(0);        final double cst1 = constants.getEntry(1);        final double cst2 = constants.getEntry(2);        final double sol0 = solution.getEntry(0);        final double sol1 = solution.getEntry(1);        final double sol2 = solution.getEntry(2);        Assert.assertEquals(2 * sol0 + 3 * sol1 -2 * sol2, cst0, 1E-12);        Assert.assertEquals(-1 * sol0 + 7 * sol1 + 6 * sol2, cst1, 1E-12);        Assert.assertEquals(4 * sol0 - 3 * sol1 -5 * sol2, cst2, 1E-12);    }    // test submatrix accessors    @Test    public void testGetSubMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int startRow, int endRow, int startColumn, int endColumn,                                   boolean mustFail) {        try {            RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);            Assert.assertEquals(new Array2DRowRealMatrix(reference), sub);            if (mustFail) {                Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");            }        } catch (OutOfRangeException e) {            if (!mustFail) {                throw e;            }        } catch (NumberIsTooSmallException e) {            if (!mustFail) {                throw e;            }        } catch (NoDataException e) {            if (!mustFail) {                throw e;            }        }    }    private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int[] selectedRows, int[] selectedColumns,                                   boolean mustFail) {        try {            RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);            Assert.assertEquals(new Array2DRowRealMatrix(reference), sub);            if (mustFail) {                Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");            }        } catch (OutOfRangeException e) {            if (!mustFail) {                throw e;            }        } catch (NumberIsTooSmallException e) {            if (!mustFail) {                throw e;            }        } catch (NoDataException e) {            if (!mustFail) {                throw e;            }        }    }    @Test    public void testCopySubMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);        checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, -1, 1, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkCopy(RealMatrix m, double[][] reference,                           int startRow, int endRow, int startColumn, int endColumn,                           boolean mustFail) {        try {            double[][] sub = (reference == null) ?                             new double[1][1] :                             new double[reference.length][reference[0].length];            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);            Assert.assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));            if (mustFail) {                Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");            }        } catch (OutOfRangeException e) {            if (!mustFail) {                throw e;            }        } catch (NumberIsTooSmallException e) {            if (!mustFail) {                throw e;            }        } catch (NoDataException e) {            if (!mustFail) {                throw e;            }        }    }    private void checkCopy(RealMatrix m, double[][] reference,                           int[] selectedRows, int[] selectedColumns,                           boolean mustFail) {        try {            double[][] sub = (reference == null) ?                    new double[1][1] :                    new double[reference.length][reference[0].length];            m.copySubMatrix(selectedRows, selectedColumns, sub);            Assert.assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));            if (mustFail) {                Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");            }        } catch (OutOfRangeException e) {            if (!mustFail) {                throw e;            }        } catch (NumberIsTooSmallException e) {            if (!mustFail) {                throw e;            }        } catch (NoDataException e) {            if (!mustFail) {                throw e;            }        }    }    @Test    public void testGetRowMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealMatrix mRow0 = new Array2DRowRealMatrix(subRow0);        RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3);        Assert.assertEquals("Row0", mRow0,                m.getRowMatrix(0));        Assert.assertEquals("Row3", mRow3,                m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getRowMatrix(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetRowMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3);        Assert.assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowMatrix(0, mRow3);        Assert.assertEquals(mRow3, m.getRowMatrix(0));        try {            m.setRowMatrix(-1, mRow3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setRowMatrix(0, m);            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetColumnMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealMatrix mColumn1 = new Array2DRowRealMatrix(subColumn1);        RealMatrix mColumn3 = new Array2DRowRealMatrix(subColumn3);        Assert.assertEquals("Column1", mColumn1,                m.getColumnMatrix(1));        Assert.assertEquals("Column3", mColumn3,                m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getColumnMatrix(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetColumnMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealMatrix mColumn3 = new Array2DRowRealMatrix(subColumn3);        Assert.assertNotSame(mColumn3, m.getColumnMatrix(1));        m.setColumnMatrix(1, mColumn3);        Assert.assertEquals(mColumn3, m.getColumnMatrix(1));        try {            m.setColumnMatrix(-1, mColumn3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setColumnMatrix(0, m);            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetRowVector() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealVector mRow0 = new ArrayRealVector(subRow0[0]);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        Assert.assertEquals("Row0", mRow0, m.getRowVector(0));        Assert.assertEquals("Row3", mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getRowVector(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetRowVector() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        Assert.assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowVector(0, mRow3);        Assert.assertEquals(mRow3, m.getRowVector(0));        try {            m.setRowVector(-1, mRow3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setRowVector(0, new ArrayRealVector(5));            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetColumnVector() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealVector mColumn1 = columnToVector(subColumn1);        RealVector mColumn3 = columnToVector(subColumn3);        Assert.assertEquals("Column1", mColumn1, m.getColumnVector(1));        Assert.assertEquals("Column3", mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getColumnVector(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetColumnVector() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealVector mColumn3 = columnToVector(subColumn3);        Assert.assertNotSame(mColumn3, m.getColumnVector(1));        m.setColumnVector(1, mColumn3);        Assert.assertEquals(mColumn3, m.getColumnVector(1));        try {            m.setColumnVector(-1, mColumn3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setColumnVector(0, new ArrayRealVector(5));            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    private RealVector columnToVector(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayRealVector(data, false);    }    @Test    public void testGetRow() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        checkArrays(subRow0[0], m.getRow(0));        checkArrays(subRow3[0], m.getRow(3));        try {            m.getRow(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getRow(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetRow() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]);        m.setRow(0, subRow3[0]);        checkArrays(subRow3[0], m.getRow(0));        try {            m.setRow(-1, subRow3[0]);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setRow(0, new double[5]);            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetColumn() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        double[] mColumn1 = columnToArray(subColumn1);        double[] mColumn3 = columnToArray(subColumn3);        checkArrays(mColumn1, m.getColumn(1));        checkArrays(mColumn3, m.getColumn(3));        try {            m.getColumn(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getColumn(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetColumn() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        double[] mColumn3 = columnToArray(subColumn3);        Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]);        m.setColumn(1, mColumn3);        checkArrays(mColumn3, m.getColumn(1));        try {            m.setColumn(-1, mColumn3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setColumn(0, new double[5]);            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    private double[] columnToArray(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return data;    }    private void checkArrays(double[] expected, double[] actual) {        Assert.assertEquals(expected.length, actual.length);        for (int i = 0; i < expected.length; ++i) {            Assert.assertEquals(expected[i], actual[i], 0);        }    }    @Test    public void testEqualsAndHashCode() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m1 = (Array2DRowRealMatrix) m.copy();        Array2DRowRealMatrix mt = (Array2DRowRealMatrix) m.transpose();        Assert.assertTrue(m.hashCode() != mt.hashCode());        Assert.assertEquals(m.hashCode(), m1.hashCode());        Assert.assertEquals(m, m);        Assert.assertEquals(m, m1);        Assert.assertFalse(m.equals(null));        Assert.assertFalse(m.equals(mt));        Assert.assertFalse(m.equals(new Array2DRowRealMatrix(bigSingular)));    }    @Test    public void testToString() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Assert.assertEquals("Array2DRowRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",                m.toString());        m = new Array2DRowRealMatrix();        Assert.assertEquals("Array2DRowRealMatrix{}",                m.toString());    }    @Test    public void testSetSubMatrix() throws Exception {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        m.setSubMatrix(detData2,1,1);        RealMatrix expected = MatrixUtils.createRealMatrix            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});        Assert.assertEquals(expected, m);        m.setSubMatrix(detData2,0,0);        expected = MatrixUtils.createRealMatrix            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});        Assert.assertEquals(expected, m);        m.setSubMatrix(testDataPlus2,0,0);        expected = MatrixUtils.createRealMatrix            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});        Assert.assertEquals(expected, m);        // dimension overflow        try {            m.setSubMatrix(testData,1,1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        // dimension underflow        try {            m.setSubMatrix(testData,-1,1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        try {            m.setSubMatrix(testData,1,-1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        // null        try {            m.setSubMatrix(null,1,1);            Assert.fail("expecting NullArgumentException");        } catch (NullArgumentException e) {            // expected        }        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix();        try {            m2.setSubMatrix(testData,0,1);            Assert.fail("expecting MathIllegalStateException");        } catch (MathIllegalStateException e) {            // expected        }        try {            m2.setSubMatrix(testData,1,0);            Assert.fail("expecting MathIllegalStateException");        } catch (MathIllegalStateException e) {            // expected        }        // ragged        try {            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected        }        // empty        try {            m.setSubMatrix(new double[][] {{}}, 0, 0);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected        }    }    @Test    public void testWalk() throws MathUserException {        int rows    = 150;        int columns = 75;        RealMatrix m = new Array2DRowRealMatrix(rows, columns);        m.walkInRowOrder(new SetVisitor());        GetVisitor getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        Assert.assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowRealMatrix(rows, columns);        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            Assert.assertEquals(0.0, m.getEntry(i, 0), 0);            Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            Assert.assertEquals(0.0, m.getEntry(0, j), 0);            Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new Array2DRowRealMatrix(rows, columns);        m.walkInColumnOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        Assert.assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowRealMatrix(rows, columns);        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            Assert.assertEquals(0.0, m.getEntry(i, 0), 0);            Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            Assert.assertEquals(0.0, m.getEntry(0, j), 0);            Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new Array2DRowRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor);        Assert.assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            Assert.assertEquals(0.0, m.getEntry(i, 0), 0);            Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            Assert.assertEquals(0.0, m.getEntry(0, j), 0);            Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new Array2DRowRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor);        Assert.assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            Assert.assertEquals(0.0, m.getEntry(i, 0), 0);            Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            Assert.assertEquals(0.0, m.getEntry(0, j), 0);            Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }    }    @Test    public void testSerial()  {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Assert.assertEquals(m,TestUtils.serializeAndRecover(m));    }    private static class SetVisitor extends DefaultRealMatrixChangingVisitor {        @Override        public double visit(int i, int j, double value) {            return i + j / 1024.0;        }    }    private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {        private int count = 0;        @Override        public void visit(int i, int j, double value) {            ++count;            Assert.assertEquals(i + j / 1024.0, value, 0.0);        }        public int getCount() {            return count;        }    }    //--------------- -----------------Protected methods    /** extracts the l  and u matrices from compact lu representation */    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) {        if (!lu.isSquare()) {            throw new NonSquareMatrixException(lu.getRowDimension(), lu.getColumnDimension());        }        if (lowerData.length != lowerData[0].length) {            throw new DimensionMismatchException(lowerData.length, lowerData[0].length);        }        if (upperData.length != upperData[0].length) {            throw new DimensionMismatchException(upperData.length, upperData[0].length);        }        if (lowerData.length != upperData.length) {            throw new DimensionMismatchException(lowerData.length, upperData.length);        }        if (lowerData.length != lu.getRowDimension()) {            throw new DimensionMismatchException(lowerData.length, lu.getRowDimension());        }        int n = lu.getRowDimension();        for (int i = 0; i < n; i++) {            for (int j = 0; j < n; j++) {                if (j < i) {                    lowerData[i][j] = lu.getEntry(i, j);                    upperData[i][j] = 0d;                } else if (i == j) {                    lowerData[i][j] = 1d;                    upperData[i][j] = lu.getEntry(i, j);                } else {                    lowerData[i][j] = 0d;                    upperData[i][j] = lu.getEntry(i, j);                }            }        }    }    /** Returns the result of applying the given row permutation to the matrix */    protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) {        if (!matrix.isSquare()) {            throw new NonSquareMatrixException(matrix.getRowDimension(),                                               matrix.getColumnDimension());        }        if (matrix.getRowDimension() != permutation.length) {            throw new DimensionMismatchException(matrix.getRowDimension(), permutation.length);        }        int n = matrix.getRowDimension();        int m = matrix.getColumnDimension();        double out[][] = new double[m][n];        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                out[i][j] = matrix.getEntry(permutation[i], j);            }        }        return new Array2DRowRealMatrix(out);    }//    /** Useful for debugging *///    private void dumpMatrix(RealMatrix m) {//          for (int i = 0; i < m.getRowDimension(); i++) {//              String os = "";//              for (int j = 0; j < m.getColumnDimension(); j++) {//                  os += m.getEntry(i, j) + " ";//              }//              System.out.println(os);//          }//    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionConversionException;import org.apache.commons.math.fraction.FractionField;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link SparseFieldVector} class. * * @version $Id$ */public class SparseFieldVectorTest {    //    protected Fraction[][] ma1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)}, {new Fraction(7), new Fraction(8), new Fraction(9)}};    protected Fraction[] vec1 = {new Fraction(1), new Fraction(2), new Fraction(3)};    protected Fraction[] vec2 = {new Fraction(4), new Fraction(5), new Fraction(6)};    protected Fraction[] vec3 = {new Fraction(7), new Fraction(8), new Fraction(9)};    protected Fraction[] vec4 = {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8), new Fraction(9)};    protected Fraction[] vec_null = {new Fraction(0), new Fraction(0), new Fraction(0)};    protected Fraction[] dvec1 = {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8),new Fraction(9)};    protected Fraction[][] mat1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)},{ new Fraction(7), new Fraction(8), new Fraction(9)}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    protected FractionField field = FractionField.getInstance();    @Test    public void testMapFunctions() throws FractionConversionException {        SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);        //octave =  v1 .+ 2.0        FieldVector<Fraction> v_mapAdd = v1.mapAdd(new Fraction(2));        Fraction[] result_mapAdd = {new Fraction(3), new Fraction(4), new Fraction(5)};        Assert.assertArrayEquals("compare vectors" ,result_mapAdd,v_mapAdd.getData());        //octave =  v1 .+ 2.0        FieldVector<Fraction> v_mapAddToSelf = v1.copy();        v_mapAddToSelf.mapAddToSelf(new Fraction(2));        Fraction[] result_mapAddToSelf = {new Fraction(3), new Fraction(4), new Fraction(5)};        Assert.assertArrayEquals("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData());        //octave =  v1 .- 2.0        FieldVector<Fraction> v_mapSubtract = v1.mapSubtract(new Fraction(2));        Fraction[] result_mapSubtract = {new Fraction(-1), new Fraction(0), new Fraction(1)};        Assert.assertArrayEquals("compare vectors" ,result_mapSubtract,v_mapSubtract.getData());        //octave =  v1 .- 2.0        FieldVector<Fraction> v_mapSubtractToSelf = v1.copy();        v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));        Fraction[] result_mapSubtractToSelf = {new Fraction(-1), new Fraction(0), new Fraction(1)};        Assert.assertArrayEquals("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData());        //octave =  v1 .* 2.0        FieldVector<Fraction> v_mapMultiply = v1.mapMultiply(new Fraction(2));        Fraction[] result_mapMultiply = {new Fraction(2), new Fraction(4), new Fraction(6)};        Assert.assertArrayEquals("compare vectors" ,result_mapMultiply,v_mapMultiply.getData());        //octave =  v1 .* 2.0        FieldVector<Fraction> v_mapMultiplyToSelf = v1.copy();        v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));        Fraction[] result_mapMultiplyToSelf = {new Fraction(2), new Fraction(4), new Fraction(6)};        Assert.assertArrayEquals("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());        //octave =  v1 ./ 2.0        FieldVector<Fraction> v_mapDivide = v1.mapDivide(new Fraction(2));        Fraction[] result_mapDivide = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)};        Assert.assertArrayEquals("compare vectors" ,result_mapDivide,v_mapDivide.getData());        //octave =  v1 ./ 2.0        FieldVector<Fraction> v_mapDivideToSelf = v1.copy();        v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));        Fraction[] result_mapDivideToSelf = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)};        Assert.assertArrayEquals("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData());        //octave =  v1 .^-1        FieldVector<Fraction> v_mapInv = v1.mapInv();        Fraction[] result_mapInv = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};        Assert.assertArrayEquals("compare vectors" ,result_mapInv,v_mapInv.getData());        //octave =  v1 .^-1        FieldVector<Fraction> v_mapInvToSelf = v1.copy();        v_mapInvToSelf.mapInvToSelf();        Fraction[] result_mapInvToSelf = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};        Assert.assertArrayEquals("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData());    }    @Test    public void testBasicFunctions() throws FractionConversionException {        SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);        SparseFieldVector<Fraction> v2 = new SparseFieldVector<Fraction>(field,vec2);        SparseFieldVector<Fraction> v2_t = new SparseFieldVector<Fraction>(field,vec2);        //octave =  v1 + v2        FieldVector<Fraction> v_add = v1.add(v2);        Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)};        Assert.assertArrayEquals("compare vect" ,v_add.getData(),result_add);        SparseFieldVector<Fraction> vt2 = new SparseFieldVector<Fraction>(field,vec2);        FieldVector<Fraction> v_add_i = v1.add(vt2);        Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)};        Assert.assertArrayEquals("compare vect" ,v_add_i.getData(),result_add_i);        //octave =  v1 - v2        SparseFieldVector<Fraction> v_subtract = v1.subtract(v2);        Fraction[] result_subtract = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};        assertClose("compare vect" ,v_subtract.getData(),result_subtract,normTolerance);        FieldVector<Fraction> v_subtract_i = v1.subtract(vt2);        Fraction[] result_subtract_i = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};        assertClose("compare vect" ,v_subtract_i.getData(),result_subtract_i,normTolerance);        // octave v1 .* v2        FieldVector<Fraction>  v_ebeMultiply = v1.ebeMultiply(v2);        Fraction[] result_ebeMultiply = {new Fraction(4), new Fraction(10), new Fraction(18)};        assertClose("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);        FieldVector<Fraction>  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);        Fraction[] result_ebeMultiply_2 = {new Fraction(4), new Fraction(10), new Fraction(18)};        assertClose("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);        // octave v1 ./ v2        FieldVector<Fraction>  v_ebeDivide = v1.ebeDivide(v2);        Fraction[] result_ebeDivide = {new Fraction(0.25d), new Fraction(0.4d), new Fraction(0.5d)};        assertClose("compare vect" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);        FieldVector<Fraction>  v_ebeDivide_2 = v1.ebeDivide(v2_t);        Fraction[] result_ebeDivide_2 = {new Fraction(0.25d), new Fraction(0.4d), new Fraction(0.5d)};        assertClose("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);        // octave  dot(v1,v2)        Fraction dot =  v1.dotProduct(v2);        Assert.assertEquals("compare val ",new Fraction(32), dot);        // octave  dot(v1,v2_t)        Fraction dot_2 =  v1.dotProduct(v2_t);        Assert.assertEquals("compare val ",new Fraction(32), dot_2);        FieldMatrix<Fraction> m_outerProduct = v1.outerProduct(v2);        Assert.assertEquals("compare val ",new Fraction(4), m_outerProduct.getEntry(0,0));        FieldMatrix<Fraction> m_outerProduct_2 = v1.outerProduct(v2_t);        Assert.assertEquals("compare val ",new Fraction(4), m_outerProduct_2.getEntry(0,0));    }    @Test    public void testOuterProduct() {        final SparseFieldVector<Fraction> u            = new SparseFieldVector<Fraction>(FractionField.getInstance(),                                              new Fraction[] {new Fraction(1),                                                              new Fraction(2),                                                              new Fraction(-3)});        final SparseFieldVector<Fraction> v            = new SparseFieldVector<Fraction>(FractionField.getInstance(),                                              new Fraction[] {new Fraction(4),                                                              new Fraction(-2)});        final FieldMatrix<Fraction> uv = u.outerProduct(v);        final double tol = Math.ulp(1d);        Assert.assertEquals(new Fraction(4).doubleValue(), uv.getEntry(0, 0).doubleValue(), tol);        Assert.assertEquals(new Fraction(-2).doubleValue(), uv.getEntry(0, 1).doubleValue(), tol);        Assert.assertEquals(new Fraction(8).doubleValue(), uv.getEntry(1, 0).doubleValue(), tol);        Assert.assertEquals(new Fraction(-4).doubleValue(), uv.getEntry(1, 1).doubleValue(), tol);        Assert.assertEquals(new Fraction(-12).doubleValue(), uv.getEntry(2, 0).doubleValue(), tol);        Assert.assertEquals(new Fraction(6).doubleValue(), uv.getEntry(2, 1).doubleValue(), tol);    }    @Test    public void testMisc() {        SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);        String out1 = v1.toString();        Assert.assertTrue("some output ",  out1.length()!=0);        try {            v1.checkVectorDimensions(2);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected behavior        }    }    @Test    public void testPredicates() {        SparseFieldVector<Fraction> v = new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) });        v.setEntry(0, field.getZero());        Assert.assertEquals(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) }));        Assert.assertNotSame(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2), new Fraction(3) }));    }    /** verifies that two vectors are close (sup norm) */    protected void assertEquals(String msg, Fraction[] m, Fraction[] n) {        if (m.length != n.length) {            Assert.fail("vectors have different lengths");        }        for (int i = 0; i < m.length; i++) {            Assert.assertEquals(msg + " " +  i + " elements differ", m[i],n[i]);        }    }    /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, Fraction[] m, Fraction[] n, double tolerance) {        if (m.length != n.length) {            Assert.fail("vectors have different lengths");        }        for (int i = 0; i < m.length; i++) {            Assert.assertEquals(msg + " " +  i + " elements differ", m[i].doubleValue(),n[i].doubleValue(), tolerance);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.junit.Test;import org.junit.Assert;import org.apache.commons.math.TestUtils;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.exception.OutOfRangeException;import org.apache.commons.math.exception.NoDataException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.exception.MathIllegalArgumentException;/** * Test cases for the {@link OpenMapRealMatrix} class. * * @version $Id$ *          2008) $ */public final class SparseRealMatrixTest {    // 3 x 3 identity matrix    protected double[][] id = { { 1d, 0d, 0d }, { 0d, 1d, 0d }, { 0d, 0d, 1d } };    // Test data for group operations    protected double[][] testData = { { 1d, 2d, 3d }, { 2d, 5d, 3d },            { 1d, 0d, 8d } };    protected double[][] testDataLU = { { 2d, 5d, 3d }, { .5d, -2.5d, 6.5d },            { 0.5d, 0.2d, .2d } };    protected double[][] testDataPlus2 = { { 3d, 4d, 5d }, { 4d, 7d, 5d },            { 3d, 2d, 10d } };    protected double[][] testDataMinus = { { -1d, -2d, -3d },            { -2d, -5d, -3d }, { -1d, 0d, -8d } };    protected double[] testDataRow1 = { 1d, 2d, 3d };    protected double[] testDataCol3 = { 3d, 3d, 8d };    protected double[][] testDataInv = { { -40d, 16d, 9d }, { 13d, -5d, -3d },            { 5d, -2d, -1d } };    protected double[] preMultTest = { 8, 12, 33 };    protected double[][] testData2 = { { 1d, 2d, 3d }, { 2d, 5d, 3d } };    protected double[][] testData2T = { { 1d, 2d }, { 2d, 5d }, { 3d, 3d } };    protected double[][] testDataPlusInv = { { -39d, 18d, 12d },            { 15d, 0d, 0d }, { 6d, -2d, 7d } };    // lu decomposition tests    protected double[][] luData = { { 2d, 3d, 3d }, { 0d, 5d, 7d }, { 6d, 9d, 8d } };    protected double[][] luDataLUDecomposition = { { 6d, 9d, 8d },            { 0d, 5d, 7d }, { 0.33333333333333, 0d, 0.33333333333333 } };    // singular matrices    protected double[][] singular = { { 2d, 3d }, { 2d, 3d } };    protected double[][] bigSingular = { { 1d, 2d, 3d, 4d },            { 2d, 5d, 3d, 4d }, { 7d, 3d, 256d, 1930d }, { 3d, 7d, 6d, 8d } }; // 4th    // row    // =    // 1st    // +    // 2nd    protected double[][] detData = { { 1d, 2d, 3d }, { 4d, 5d, 6d },            { 7d, 8d, 10d } };    protected double[][] detData2 = { { 1d, 3d }, { 2d, 4d } };    // vectors    protected double[] testVector = { 1, 2, 3 };    protected double[] testVector2 = { 1, 2, 3, 4 };    // submatrix accessor tests    protected double[][] subTestData = { { 1, 2, 3, 4 },            { 1.5, 2.5, 3.5, 4.5 }, { 2, 4, 6, 8 }, { 4, 5, 6, 7 } };    // array selections    protected double[][] subRows02Cols13 = { { 2, 4 }, { 4, 8 } };    protected double[][] subRows03Cols12 = { { 2, 3 }, { 5, 6 } };    protected double[][] subRows03Cols123 = { { 2, 3, 4 }, { 5, 6, 7 } };    // effective permutations    protected double[][] subRows20Cols123 = { { 4, 6, 8 }, { 2, 3, 4 } };    protected double[][] subRows31Cols31 = { { 7, 5 }, { 4.5, 2.5 } };    // contiguous ranges    protected double[][] subRows01Cols23 = { { 3, 4 }, { 3.5, 4.5 } };    protected double[][] subRows23Cols00 = { { 2 }, { 4 } };    protected double[][] subRows00Cols33 = { { 4 } };    // row matrices    protected double[][] subRow0 = { { 1, 2, 3, 4 } };    protected double[][] subRow3 = { { 4, 5, 6, 7 } };    // column matrices    protected double[][] subColumn1 = { { 2 }, { 2.5 }, { 4 }, { 5 } };    protected double[][] subColumn3 = { { 4 }, { 4.5 }, { 8 }, { 7 } };    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    /** test dimensions */    @Test    public void testDimensions() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix m2 = createSparseMatrix(testData2);        Assert.assertEquals("testData row dimension", 3, m.getRowDimension());        Assert.assertEquals("testData column dimension", 3, m.getColumnDimension());        Assert.assertTrue("testData is square", m.isSquare());        Assert.assertEquals("testData2 row dimension", m2.getRowDimension(), 2);        Assert.assertEquals("testData2 column dimension", m2.getColumnDimension(), 3);        Assert.assertTrue("testData2 is not square", !m2.isSquare());    }    /** test copy functions */    @Test    public void testCopyFunctions() {        OpenMapRealMatrix m1 = createSparseMatrix(testData);        RealMatrix m2 = m1.copy();        Assert.assertEquals(m1.getClass(), m2.getClass());        Assert.assertEquals((m2), m1);        OpenMapRealMatrix m3 = createSparseMatrix(testData);        RealMatrix m4 = m3.copy();        Assert.assertEquals(m3.getClass(), m4.getClass());        Assert.assertEquals((m4), m3);    }    /** test add */    @Test    public void testAdd() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix mInv = createSparseMatrix(testDataInv);        OpenMapRealMatrix mDataPlusInv = createSparseMatrix(testDataPlusInv);        RealMatrix mPlusMInv = m.add(mInv);        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                Assert.assertEquals("sum entry entry",                    mDataPlusInv.getEntry(row, col), mPlusMInv.getEntry(row, col),                    entryTolerance);            }        }    }    /** test add failure */    @Test    public void testAddFail() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix m2 = createSparseMatrix(testData2);        try {            m.add(m2);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    /** test norm */    @Test    public void testNorm() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix m2 = createSparseMatrix(testData2);        Assert.assertEquals("testData norm", 14d, m.getNorm(), entryTolerance);        Assert.assertEquals("testData2 norm", 7d, m2.getNorm(), entryTolerance);    }    /** test m-n = m + -n */    @Test    public void testPlusMinus() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix n = createSparseMatrix(testDataInv);        assertClose("m-n = m + -n", m.subtract(n),            n.scalarMultiply(-1d).add(m), entryTolerance);        try {            m.subtract(createSparseMatrix(testData2));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    /** test multiply */    @Test    public void testMultiply() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix mInv = createSparseMatrix(testDataInv);        OpenMapRealMatrix identity = createSparseMatrix(id);        OpenMapRealMatrix m2 = createSparseMatrix(testData2);        assertClose("inverse multiply", m.multiply(mInv), identity,                entryTolerance);        assertClose("inverse multiply", m.multiply(new BlockRealMatrix(testDataInv)), identity,                    entryTolerance);        assertClose("inverse multiply", mInv.multiply(m), identity,                entryTolerance);        assertClose("identity multiply", m.multiply(identity), m,                entryTolerance);        assertClose("identity multiply", identity.multiply(mInv), mInv,                entryTolerance);        assertClose("identity multiply", m2.multiply(identity), m2,                entryTolerance);        try {            m.multiply(createSparseMatrix(bigSingular));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    // Additional Test for Array2DRowRealMatrixTest.testMultiply    private double[][] d3 = new double[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };    private double[][] d4 = new double[][] { { 1 }, { 2 }, { 3 }, { 4 } };    private double[][] d5 = new double[][] { { 30 }, { 70 } };    @Test    public void testMultiply2() {        RealMatrix m3 = createSparseMatrix(d3);        RealMatrix m4 = createSparseMatrix(d4);        RealMatrix m5 = createSparseMatrix(d5);        assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);    }    /** test trace */    @Test    public void testTrace() {        RealMatrix m = createSparseMatrix(id);        Assert.assertEquals("identity trace", 3d, m.getTrace(), entryTolerance);        m = createSparseMatrix(testData2);        try {            m.getTrace();            Assert.fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }    }    /** test sclarAdd */    @Test    public void testScalarAdd() {        RealMatrix m = createSparseMatrix(testData);        assertClose("scalar add", createSparseMatrix(testDataPlus2),            m.scalarAdd(2d), entryTolerance);    }    /** test operate */    @Test    public void testOperate() {        RealMatrix m = createSparseMatrix(id);        assertClose("identity operate", testVector, m.operate(testVector),                entryTolerance);        assertClose("identity operate", testVector, m.operate(                new ArrayRealVector(testVector)).getData(), entryTolerance);        m = createSparseMatrix(bigSingular);        try {            m.operate(testVector);            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    /** test issue MATH-209 */    @Test    public void testMath209() {        RealMatrix a = createSparseMatrix(new double[][] {                { 1, 2 }, { 3, 4 }, { 5, 6 } });        double[] b = a.operate(new double[] { 1, 1 });        Assert.assertEquals(a.getRowDimension(), b.length);        Assert.assertEquals(3.0, b[0], 1.0e-12);        Assert.assertEquals(7.0, b[1], 1.0e-12);        Assert.assertEquals(11.0, b[2], 1.0e-12);    }    /** test transpose */    @Test    public void testTranspose() {        RealMatrix m = createSparseMatrix(testData);        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();        assertClose("inverse-transpose", mIT, mTI, normTolerance);        m = createSparseMatrix(testData2);        RealMatrix mt = createSparseMatrix(testData2T);        assertClose("transpose",mt,m.transpose(),normTolerance);    }    /** test preMultiply by vector */    @Test    public void testPremultiplyVector() {        RealMatrix m = createSparseMatrix(testData);        assertClose("premultiply", m.preMultiply(testVector), preMultTest,            normTolerance);        assertClose("premultiply", m.preMultiply(            new ArrayRealVector(testVector).getData()), preMultTest, normTolerance);        m = createSparseMatrix(bigSingular);        try {            m.preMultiply(testVector);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    @Test    public void testPremultiply() {        RealMatrix m3 = createSparseMatrix(d3);        RealMatrix m4 = createSparseMatrix(d4);        RealMatrix m5 = createSparseMatrix(d5);        assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix mInv = createSparseMatrix(testDataInv);        OpenMapRealMatrix identity = createSparseMatrix(id);        assertClose("inverse multiply", m.preMultiply(mInv), identity,                entryTolerance);        assertClose("inverse multiply", mInv.preMultiply(m), identity,                entryTolerance);        assertClose("identity multiply", m.preMultiply(identity), m,                entryTolerance);        assertClose("identity multiply", identity.preMultiply(mInv), mInv,                entryTolerance);        try {            m.preMultiply(createSparseMatrix(bigSingular));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    @Test    public void testGetVectors() {        RealMatrix m = createSparseMatrix(testData);        assertClose("get row", m.getRow(0), testDataRow1, entryTolerance);        assertClose("get col", m.getColumn(2), testDataCol3, entryTolerance);        try {            m.getRow(10);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // ignored        }        try {            m.getColumn(-1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // ignored        }    }    @Test    public void testGetEntry() {        RealMatrix m = createSparseMatrix(testData);        Assert.assertEquals("get entry", m.getEntry(0, 1), 2d, entryTolerance);        try {            m.getEntry(10, 4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    /** test examples in user guide */    @Test    public void testExamples() {        // Create a real matrix with two rows and three columns        double[][] matrixData = { { 1d, 2d, 3d }, { 2d, 5d, 3d } };        RealMatrix m = createSparseMatrix(matrixData);        // One more with three rows, two columns        double[][] matrixData2 = { { 1d, 2d }, { 2d, 5d }, { 1d, 7d } };        RealMatrix n = createSparseMatrix(matrixData2);        // Now multiply m by n        RealMatrix p = m.multiply(n);        Assert.assertEquals(2, p.getRowDimension());        Assert.assertEquals(2, p.getColumnDimension());        // Invert p        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();        Assert.assertEquals(2, pInverse.getRowDimension());        Assert.assertEquals(2, pInverse.getColumnDimension());        // Solve example        double[][] coefficientsData = { { 2, 3, -2 }, { -1, 7, 6 },                { 4, -3, -5 } };        RealMatrix coefficients = createSparseMatrix(coefficientsData);        RealVector constants = new ArrayRealVector(new double[]{ 1, -2, 1 }, false);        RealVector solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);        final double cst0 = constants.getEntry(0);        final double cst1 = constants.getEntry(1);        final double cst2 = constants.getEntry(2);        final double sol0 = solution.getEntry(0);        final double sol1 = solution.getEntry(1);        final double sol2 = solution.getEntry(2);        Assert.assertEquals(2 * sol0 + 3 * sol1 - 2 * sol2, cst0, 1E-12);        Assert.assertEquals(-1 * sol0 + 7 * sol1 + 6 * sol2, cst1, 1E-12);        Assert.assertEquals(4 * sol0 - 3 * sol1 - 5 * sol2, cst2, 1E-12);    }    // test submatrix accessors    @Test    public void testSubMatrix() {        RealMatrix m = createSparseMatrix(subTestData);        RealMatrix mRows23Cols00 = createSparseMatrix(subRows23Cols00);        RealMatrix mRows00Cols33 = createSparseMatrix(subRows00Cols33);        RealMatrix mRows01Cols23 = createSparseMatrix(subRows01Cols23);        RealMatrix mRows02Cols13 = createSparseMatrix(subRows02Cols13);        RealMatrix mRows03Cols12 = createSparseMatrix(subRows03Cols12);        RealMatrix mRows03Cols123 = createSparseMatrix(subRows03Cols123);        RealMatrix mRows20Cols123 = createSparseMatrix(subRows20Cols123);        RealMatrix mRows31Cols31 = createSparseMatrix(subRows31Cols31);        Assert.assertEquals("Rows23Cols00", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));        Assert.assertEquals("Rows00Cols33", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));        Assert.assertEquals("Rows01Cols23", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));        Assert.assertEquals("Rows02Cols13", mRows02Cols13,            m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 }));        Assert.assertEquals("Rows03Cols12", mRows03Cols12,            m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 }));        Assert.assertEquals("Rows03Cols123", mRows03Cols123,            m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 }));        Assert.assertEquals("Rows20Cols123", mRows20Cols123,            m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 }));        Assert.assertEquals("Rows31Cols31", mRows31Cols31,            m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));        Assert.assertEquals("Rows31Cols31", mRows31Cols31,            m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));        try {            m.getSubMatrix(1, 0, 2, 4);            Assert.fail("Expecting NumberIsTooSmallException");        } catch (NumberIsTooSmallException ex) {            // expected        }        try {            m.getSubMatrix(-1, 1, 2, 2);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getSubMatrix(1, 0, 2, 2);            Assert.fail("Expecting NumberIsTooSmallException");        } catch (NumberIsTooSmallException ex) {            // expected        }        try {            m.getSubMatrix(1, 0, 2, 4);            Assert.fail("Expecting NumberIsTooSmallException");        } catch (NumberIsTooSmallException ex) {            // expected        }        try {            m.getSubMatrix(new int[] {}, new int[] { 0 });            Assert.fail("Expecting NoDataException");        } catch (NoDataException ex) {            // expected        }        try {            m.getSubMatrix(new int[] { 0 }, new int[] { 4 });            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testGetRowMatrix() {        RealMatrix m = createSparseMatrix(subTestData);        RealMatrix mRow0 = createSparseMatrix(subRow0);        RealMatrix mRow3 = createSparseMatrix(subRow3);        Assert.assertEquals("Row0", mRow0, m.getRowMatrix(0));        Assert.assertEquals("Row3", mRow3, m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getRowMatrix(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testGetColumnMatrix() {        RealMatrix m = createSparseMatrix(subTestData);        RealMatrix mColumn1 = createSparseMatrix(subColumn1);        RealMatrix mColumn3 = createSparseMatrix(subColumn3);        Assert.assertEquals("Column1", mColumn1, m.getColumnMatrix(1));        Assert.assertEquals("Column3", mColumn3, m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getColumnMatrix(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testGetRowVector() {        RealMatrix m = createSparseMatrix(subTestData);        RealVector mRow0 = new ArrayRealVector(subRow0[0]);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        Assert.assertEquals("Row0", mRow0, m.getRowVector(0));        Assert.assertEquals("Row3", mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getRowVector(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testGetColumnVector() {        RealMatrix m = createSparseMatrix(subTestData);        RealVector mColumn1 = columnToVector(subColumn1);        RealVector mColumn3 = columnToVector(subColumn3);        Assert.assertEquals("Column1", mColumn1, m.getColumnVector(1));        Assert.assertEquals("Column3", mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getColumnVector(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    private RealVector columnToVector(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayRealVector(data, false);    }    @Test    public void testEqualsAndHashCode() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix m1 = m.copy();        OpenMapRealMatrix mt = (OpenMapRealMatrix) m.transpose();        Assert.assertTrue(m.hashCode() != mt.hashCode());        Assert.assertEquals(m.hashCode(), m1.hashCode());        Assert.assertEquals(m, m);        Assert.assertEquals(m, m1);        Assert.assertFalse(m.equals(null));        Assert.assertFalse(m.equals(mt));        Assert.assertFalse(m.equals(createSparseMatrix(bigSingular)));    }    @Test    public void testToString() {        OpenMapRealMatrix m = createSparseMatrix(testData);        Assert.assertEquals("OpenMapRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",            m.toString());        m = new OpenMapRealMatrix(1, 1);        Assert.assertEquals("OpenMapRealMatrix{{0.0}}", m.toString());    }    @Test    public void testSetSubMatrix() {        OpenMapRealMatrix m = createSparseMatrix(testData);        m.setSubMatrix(detData2, 1, 1);        RealMatrix expected = createSparseMatrix(new double[][] {                { 1.0, 2.0, 3.0 }, { 2.0, 1.0, 3.0 }, { 1.0, 2.0, 4.0 } });        Assert.assertEquals(expected, m);        m.setSubMatrix(detData2, 0, 0);        expected = createSparseMatrix(new double[][] {                { 1.0, 3.0, 3.0 }, { 2.0, 4.0, 3.0 }, { 1.0, 2.0, 4.0 } });        Assert.assertEquals(expected, m);        m.setSubMatrix(testDataPlus2, 0, 0);        expected = createSparseMatrix(new double[][] {                { 3.0, 4.0, 5.0 }, { 4.0, 7.0, 5.0 }, { 3.0, 2.0, 10.0 } });        Assert.assertEquals(expected, m);        // javadoc example        OpenMapRealMatrix matrix =            createSparseMatrix(new double[][] {        { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 0, 1, 2 } });        matrix.setSubMatrix(new double[][] { { 3, 4 }, { 5, 6 } }, 1, 1);        expected = createSparseMatrix(new double[][] {                { 1, 2, 3, 4 }, { 5, 3, 4, 8 }, { 9, 5, 6, 2 } });        Assert.assertEquals(expected, matrix);        // dimension overflow        try {            m.setSubMatrix(testData, 1, 1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        // dimension underflow        try {            m.setSubMatrix(testData, -1, 1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        try {            m.setSubMatrix(testData, 1, -1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        // null        try {            m.setSubMatrix(null, 1, 1);            Assert.fail("expecting NullArgumentException");        } catch (NullArgumentException e) {            // expected        }        try {            new OpenMapRealMatrix(0, 0);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected        }        // ragged        try {            m.setSubMatrix(new double[][] { { 1 }, { 2, 3 } }, 0, 0);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected        }        // empty        try {            m.setSubMatrix(new double[][] { {} }, 0, 0);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected        }    }    @Test    public void testSerial()  {        OpenMapRealMatrix m = createSparseMatrix(testData);        Assert.assertEquals(m,TestUtils.serializeAndRecover(m));    }    // --------------- -----------------Protected methods    /** verifies that two matrices are close (1-norm) */    protected void assertClose(String msg, RealMatrix m, RealMatrix n,            double tolerance) {        Assert.assertTrue(msg, m.subtract(n).getNorm() < tolerance);    }    /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, double[] m, double[] n,            double tolerance) {        if (m.length != n.length) {            Assert.fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            Assert.assertEquals(msg + " " + i + " elements differ", m[i], n[i],                    tolerance);        }    }    private OpenMapRealMatrix createSparseMatrix(double[][] data) {        OpenMapRealMatrix matrix = new OpenMapRealMatrix(data.length, data[0].length);        for (int row = 0; row < data.length; row++) {            for (int col = 0; col < data[row].length; col++) {                matrix.setEntry(row, col, data[row][col]);            }        }        return matrix;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.junit.Assert;import org.junit.Test;public class SingularValueSolverTest {    private double[][] testSquare = {            { 24.0 / 25.0, 43.0 / 25.0 },            { 57.0 / 25.0, 24.0 / 25.0 }    };    private static final double normTolerance = 10e-14;    /** test solve dimension errors */    @Test    public void testSolveDimensionErrors() {        DecompositionSolver solver =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);        try {            solver.solve(b);            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException iae) {            // expected behavior        }        try {            solver.solve(b.getColumnVector(0));            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException iae) {            // expected behavior        }        try {            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException iae) {            // expected behavior        }    }    /** test least square solve */    @Test    public void testLeastSquareSolve() {        RealMatrix m =            MatrixUtils.createRealMatrix(new double[][] {                                   { 1.0, 0.0 },                                   { 0.0, 0.0 }                               });        DecompositionSolver solver = new SingularValueDecompositionImpl(m).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {            { 11, 12 }, { 21, 22 }        });        RealMatrix xMatrix = solver.solve(b);        Assert.assertEquals(11, xMatrix.getEntry(0, 0), 1.0e-15);        Assert.assertEquals(12, xMatrix.getEntry(0, 1), 1.0e-15);        Assert.assertEquals(0, xMatrix.getEntry(1, 0), 1.0e-15);        Assert.assertEquals(0, xMatrix.getEntry(1, 1), 1.0e-15);        RealVector xColVec = solver.solve(b.getColumnVector(0));        Assert.assertEquals(11, xColVec.getEntry(0), 1.0e-15);        Assert.assertEquals(0, xColVec.getEntry(1), 1.0e-15);        RealVector xColOtherVec = solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));        Assert.assertEquals(11, xColOtherVec.getEntry(0), 1.0e-15);        Assert.assertEquals(0, xColOtherVec.getEntry(1), 1.0e-15);    }    /** test solve */    @Test    public void testSolve() {        DecompositionSolver solver =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                { 1, 2, 3 }, { 0, -5, 1 }        });        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                { -8.0 / 25.0, -263.0 / 75.0, -29.0 / 75.0 },                { 19.0 / 25.0,   78.0 / 25.0,  49.0 / 25.0 }        });        // using RealMatrix        Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), normTolerance);        // using double[][]        Assert.assertEquals(0, MatrixUtils.createRealMatrix(solver.solve(b.getData())).subtract(xRef).getNorm(), normTolerance);        // using ArrayRealVector        for (int i = 0; i < b.getColumnDimension(); ++i) {            Assert.assertEquals(0,                         solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }        // using RealVector with an alternate implementation        for (int i = 0; i < b.getColumnDimension(); ++i) {            ArrayRealVectorTest.RealVectorTestImpl v =                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));            Assert.assertEquals(0,                         solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }    }    /** test condition number */    @Test    public void testConditionNumber() {        SingularValueDecompositionImpl svd =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));        // replace 1.0e-15 with 1.5e-15        Assert.assertEquals(3.0, svd.getConditionNumber(), 1.5e-15);    }    @Test    public void testMath320B() {        RealMatrix rm = new Array2DRowRealMatrix(new double[][] {            { 1.0, 2.0 }, { 1.0, 2.0 }        });        SingularValueDecomposition svd =            new SingularValueDecompositionImpl(rm);        RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());        Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 2.0e-15);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations under * the License. */package org.apache.commons.math.linear;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Set;import java.util.HashSet;import java.util.Iterator;import java.util.Random;import junit.framework.Assert;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.analysis.function.Sin;import org.apache.commons.math.exception.MathUnsupportedOperationException;import org.apache.commons.math.linear.RealVector.Entry;import org.junit.Test;/** * This is an abstract test of the {@link * RealVector#unmodifiableRealVector(RealVector) unmodifiable vector} * implementation. These unmodifiable vectors decorate a (modifiable) * {@link RealVector}; therefore, a new implementation of this abstract * test should be considered for each implementation of * {@link RealVector}. * * @version $Id$ * */public abstract class UnmodifiableRealVectorAbstractTest {    /** The dimension of the randomly generated vectors. */    protected static final int DIM = 100;    /** Absolute tolerance. */    protected static final double EPS = 10 * Math.ulp(1d);    /**     * The list of methods which are excluded from the general test     * {@link #testAllButExcluded()}.     */    protected static final Set<String> EXCLUDE = new HashSet<String>();    /** The random number generator (always initialized with the same seed. */    protected static final Random RANDOM;    static {        EXCLUDE.add("getEntry");        EXCLUDE.add("setEntry");        EXCLUDE.add("getSubVector");        EXCLUDE.add("setSubVector");        EXCLUDE.add("iterator");        EXCLUDE.add("sparseIterator");        // Excluded because they are inherited from "Object".        for (Method m : Object.class.getMethods()) {            EXCLUDE.add(m.getName());        }        RANDOM = new Random(20110813);    }    /**     * Returns {@code true} if the specified {@code double} are equal (within a     * given tolerance).     *     * @param x First {@code double}.     * @param y Second {@code double}.     * @return {@code true} if {@code x} and {@code y} are equal.     */    public static boolean equals(final double x, final double y) {        if (x == y) {            return true;        } else if (Math.abs(x) <= EPS) {            return Math.abs(y) <= EPS;        } else if (Math.abs(y) <= EPS) {            return Math.abs(x) <= EPS;        } else {            return Math.abs(x - y) <= EPS * Math.min(Math.abs(x), Math.abs(y));        }    }    /**     * Returns {@code true} if the specified {@code double} arrays are equal     * (within a given tolerance).     *     * @param x First array.     * @param y Second array.     * @return {@code true} if {@code x} and {@code y} are equal.     */    public static boolean equals(final double[] x, final double[] y) {        if (x.length != y.length) {            return false;        }        final int n = x.length;        for (int i = 0; i < n; i++) {            if (!equals(x[i], y[i])) {                return false;            }        }        return true;    }    /**     * Returns {@code true} if the specified {@code RealVector} are equal     * (within a given tolerance).     *     * @param x First vector.     * @param y Second vector.     * @return {@code true} if {@code x} and {@code y} are equal.     */    public static boolean equals(final RealVector x, final RealVector y) {        if (x.getDimension() != y.getDimension()) {            return false;        }        final int n = x.getDimension();        for (int i = 0; i < n; i++) {            if (!equals(x.getEntry(i), y.getEntry(i))) {                return false;            }        }        return true;    }    /**     * Returns {@code true} if the specified {@code RealVector} is equal to the     * specified {@code double} array (within a given tolerance).     *     * @param x Vector.     * @param y Array.     * @return {@code true} if {@code x} and {@code y} are equal.     */    public static boolean equals(final RealVector x, final double[] y) {        if (x.getDimension() != y.length) {            return false;        }        final int n = x.getDimension();        for (int i = 0; i < n; i++) {            if (!equals(x.getEntry(i), y[i])) {                return false;            }        }        return true;    }    /**     * Returns {@code true} if the specified {@code RealMatrix} are equal     * (within a given tolerance).     *     * @param x First matrix.     * @param y Second matrix.     * @return {@code true} if {@code x} and {@code y} are equal.     */    public static boolean equals(final RealMatrix x, final RealMatrix y) {        if (x.getRowDimension() != y.getRowDimension()) {            return false;        }        if (x.getColumnDimension() != y.getColumnDimension()) {            return false;        }        final int rows = x.getRowDimension();        final int cols = x.getColumnDimension();        for (int i = 0; i < rows; i++) {            for (int j = 0; j < cols; j++) {                if (!equals(x.getEntry(i, j), y.getEntry(i, j))) {                    return false;                }            }        }        return true;    }    /**     * Returns {@code true} if the specified {@code Object} are equal.     *     * @param x First object.     * @param y Second object.     * @return {@code true} if {@code x} and {@code y} are equal.     * @throws IllegalArgumentException if {@code x} and {@code y} could     * not be compared.     */    public static boolean equals(final Object x, final Object y) {        if (x instanceof Boolean) {            if (y instanceof Boolean) {                return ((Boolean) x).booleanValue() == ((Boolean) y)                        .booleanValue();            } else {                return false;            }        }        if (x instanceof Integer) {            if (y instanceof Integer) {                return ((Integer) x).intValue() == ((Integer) y).intValue();            } else {                return false;            }        } else if (x instanceof Double) {            if (y instanceof Double) {                return equals(((Double) x).doubleValue(),                        ((Double) y).doubleValue());            } else {                return false;            }        } else if (x instanceof double[]) {            if (y instanceof double[]) {                return equals((double[]) x, (double[]) y);            } else if (y instanceof RealVector) {                return equals((RealVector) y, (double[]) x);            } else {                return false;            }        } else if (x instanceof RealVector) {            if (y instanceof double[]) {                return equals((RealVector) x, (double[]) y);            } else if (y instanceof RealVector) {                return equals((RealVector) x, (RealVector) y);            } else {                return false;            }        } else if (x instanceof RealMatrix) {            if (y instanceof RealMatrix) {                return equals((RealMatrix) x, (RealMatrix) y);            } else {                return false;            }        } else {            throw new IllegalArgumentException("could not compare " + x + ", "                    + y);        }    }    /**     * Creates a new random vector of a specified type. This vector is then to     * be wrapped in an unmodifiable vector.     *     * @return a new random vector.     */    public abstract RealVector createVector();    /**     * Creates a new random object of the specified type.     *     * @param c Class of the object to be created.     * @return a new random object.     * @throws IllegalArgumentException if the specified class is not     * recognized by this method.     */    public Object createParameter(final Class<?> c) {        if (c == Integer.TYPE) {            return Integer.valueOf(RANDOM.nextInt());        } else if (c == Double.TYPE) {            return Double.valueOf(RANDOM.nextDouble());        } else if (c == double[].class) {            final double[] v = new double[DIM];            for (int i = 0; i < DIM; i++) {                v[i] = RANDOM.nextDouble();            }            return v;        } else if (c.isAssignableFrom(RealVector.class)) {            return createVector();        } else if (c.isAssignableFrom(UnivariateRealFunction.class)) {            return new Sin();        } else {            throw new IllegalArgumentException("could not create " + c);        }    }    /**     * This is the general test of most methods in the     * {@link RealVector#unmodifiableRealVector(RealVector) unmodifiable vector}.     * It works as follows.     * First, an unmodifiable view of a copy of the specified random vector     * {@code u} is created: this defines {@code v}. Then the <em>same</em>     * method {@code m} is invoked on {@code u} and {@code v}, with randomly     * generated parameters {@code args}.     * If it turns out that {@code u} has changed after the call of method     * {@code m}, then this test checks that the call of this method on     * {@code v} resulted in a {@link MathUnsupportedOperationException}. If     * {@code u} was not modified, then this test checks that the results     * returned by the call of method {@code m} on {@code u} and {@code v}     * returned the same result.     *     * @param m Method to be tested.     * @param u Random vector from which the unmodifiable view is to be     *constructed.     * @param args Arguments to be passed to method {@code m}.     */    private void callMethod(final Method m,                            final RealVector u,                            final Object... args)        throws IllegalAccessException,               IllegalArgumentException,               InvocationTargetException {        final RealVector uu = u.copy();        final RealVector v = RealVector.unmodifiableRealVector(u.copy());        Object exp = m.invoke(u, args);        if (equals(uu, u)) {            Object act = m.invoke(v, args);            Assert.assertTrue(m.toGenericString() + ", unmodifiable vector has changed",                              equals(uu, v));            Assert.assertTrue(m.toGenericString() + ", wrong result",                              equals(exp, act));        } else {            boolean flag = false;            try {                m.invoke(v, args);            } catch (InvocationTargetException e) {                if (e.getCause() instanceof MathUnsupportedOperationException) {                    flag = true;                }            }            Assert.assertTrue(m.toGenericString()+", exception should have been thrown", flag);        }    }    /**     * This test calls {@link #callMethod(Method, RealVector, Object...)} on     * every method defined in interface {@link RealVector}. It generates the     * appropriate random arguments. Some methods are manually excluded (see     * {@link #EXCLUDE}), they must be handled by separate tests.     */    @Test    public void testAllButExcluded()        throws IllegalAccessException,               IllegalArgumentException,               InvocationTargetException {        Method[] method = RealVector.class.getMethods();        for (int i = 0; i < method.length; i++) {            Method m = method[i];            if (!EXCLUDE.contains(m.getName())) {                RealVector u = (RealVector) createParameter(RealVector.class);                Class<?>[] paramType = m.getParameterTypes();                Object[] param = new Object[paramType.length];                for (int j = 0; j < paramType.length; j++) {                    param[j] = createParameter(paramType[j]);                }                callMethod(m, u, param);            }        }    }    @Test    public void testGetEntry() {        RealVector u = createVector();        RealVector v = RealVector.unmodifiableRealVector(u);        for (int i = 0; i < DIM; i++) {            Assert.assertTrue(equals(u.getEntry(i), v.getEntry(i)));        }    }    @Test(expected = MathUnsupportedOperationException.class)    public void testSetEntry() {        RealVector u = createVector();        RealVector v = RealVector.unmodifiableRealVector(u);        for (int i = 0; i < DIM; i++) {            v.setEntry(i, 0d);        }    }    @Test    public void testGetSubVector() {        RealVector u = createVector();        RealVector v = RealVector.unmodifiableRealVector(u);        for (int i = 0; i < DIM; i++) {            for (int n = 1; n < DIM - i; n++) {                RealVector exp = u.getSubVector(i, n);                RealVector act = v.getSubVector(i, n);                Assert.assertTrue(equals(exp, act));            }        }    }    @Test(expected = MathUnsupportedOperationException.class)    public void testSetSubVector() {        RealVector u = createVector();        RealVector v = RealVector.unmodifiableRealVector(u);        v.setSubVector(0, new ArrayRealVector());    }    @Test    public void testIterator() {        RealVector u = createVector();        Iterator<Entry> i = u.iterator();        RealVector v = RealVector.unmodifiableRealVector(u.copy());        Iterator<Entry> j = v.iterator();        boolean flag;        while (i.hasNext()) {            Assert.assertTrue(j.hasNext());            Entry exp = i.next();            Entry act = j.next();            Assert.assertTrue(equals(exp.getIndex(), act.getIndex()));            Assert.assertTrue(equals(exp.getValue(), act.getValue()));            exp.setIndex(RANDOM.nextInt(DIM));            act.setIndex(RANDOM.nextInt(DIM));            flag = false;            try {                act.setValue(RANDOM.nextDouble());            } catch (MathUnsupportedOperationException e) {                flag = true;            }            Assert.assertTrue("exception should have been thrown", flag);        }        Assert.assertFalse(j.hasNext());    }    @Test    public void testSparseIterator() {        RealVector u = createVector();        Iterator<Entry> i = u.sparseIterator();        RealVector v = RealVector.unmodifiableRealVector(u.copy());        Iterator<Entry> j = v.sparseIterator();        boolean flag;        while (i.hasNext()) {            Assert.assertTrue(j.hasNext());            Entry exp = i.next();            Entry act = j.next();            Assert.assertTrue(equals(exp.getIndex(), act.getIndex()));            Assert.assertTrue(equals(exp.getValue(), act.getValue()));            exp.setIndex(RANDOM.nextInt(DIM));            act.setIndex(RANDOM.nextInt(DIM));            flag = false;            try {                act.setValue(RANDOM.nextDouble());            } catch (MathUnsupportedOperationException e) {                flag = true;            }            Assert.assertTrue("exception should have been thrown", flag);        }        Assert.assertFalse(j.hasNext());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.junit.Test;import org.junit.Assert;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.linear.RealVector.Entry;import java.util.Iterator;import java.util.Random;/** * Tests for {@link RealVector}. */public class RealVectorTest {    private double[] vec1 = { 1d, 2d, 3d, 4d, 5d };    private double[] vec2 = { -3d, 0d, 0d, 2d, 1d };    private static class TestVectorImpl extends RealVector {        private double[] values;        TestVectorImpl(double[] values) {            this.values = values;        }        @Override        public double[] toArray() { return values; }        @Override        public RealVector copy() {            return new TestVectorImpl(values.clone());        }        UnsupportedOperationException unsupported() {            return new UnsupportedOperationException("Test implementation only supports methods necessary for testing");        }        @Override        public RealVector add(RealVector v) {            RealVector result = new ArrayRealVector(v);            return result.add(this);        }        @Override        public RealVector subtract(RealVector v) {            RealVector result = new ArrayRealVector(v);            return result.subtract(this).mapMultiplyToSelf(-1);        }        @Override        public RealVector mapAddToSelf(double d) {            for(int i=0; i<values.length; i++) {                values[i] += d;            }            return this;        }        @Override        public RealVector mapSubtractToSelf(double d) {            for(int i=0; i<values.length; i++) {                values[i] -= d;            }            return this;        }        @Override        public RealVector mapMultiplyToSelf(double d) {            for(int i=0; i<values.length; i++) {                values[i] *= d;            }            return this;        }        @Override        public RealVector mapDivideToSelf(double d) {            for(int i=0; i<values.length; i++) {                values[i] /= d;            }            return this;        }        public RealVector ebeMultiply(RealVector v) {            throw unsupported();        }        public RealVector ebeDivide(RealVector v) {            throw unsupported();        }        @Override        public double dotProduct(RealVector v) {            throw unsupported();        }        @Override        public double getNorm() {            throw unsupported();        }        @Override        public double getL1Norm() {            throw unsupported();        }        @Override        public double getLInfNorm() {            throw unsupported();        }        public RealVector projection(RealVector v) {            throw unsupported();        }        public double getEntry(int index) {            return values[index];        }        public void setEntry(int index, double value) {            values[index] = value;        }        public int getDimension() {            return values.length;        }        public RealVector append(RealVector v) {            throw unsupported();        }        public RealVector append(double d) {            throw unsupported();        }        public RealVector append(double[] a) {            throw unsupported();        }        public RealVector getSubVector(int index, int n) {            throw unsupported();        }        public void setSubVector(int index, double[] v) {            throw unsupported();        }        public void setSubVector(int index, RealVector v) {            throw unsupported();        }        public boolean isNaN() {            throw unsupported();        }        public boolean isInfinite() {            throw unsupported();        }    }    @Test    public void testMap() throws Exception {        double[] vec1Squared = { 1d, 4d, 9d, 16d, 25d };        RealVector v = new TestVectorImpl(vec1.clone());        RealVector w = v.map(new UnivariateRealFunction() { public double value(double x) { return x * x; } });        double[] d2 = w.toArray();        Assert.assertEquals(vec1Squared.length, d2.length);        for(int i=0; i<vec1Squared.length; i++) {            Assert.assertEquals(vec1Squared[i], d2[i], 0);        }    }    @Test    public void testIterator() throws Exception {        RealVector v = new TestVectorImpl(vec2.clone());        Entry e;        int i = 0;        for(Iterator<Entry> it = v.iterator(); it.hasNext() && (e = it.next()) != null; i++) {            Assert.assertEquals(vec2[i], e.getValue(), 0);        }    }    @Test    public void testSparseIterator() throws Exception {        RealVector v = new TestVectorImpl(vec2.clone());        Entry e;        int i = 0;        double[] nonDefaultV2 = { -3d, 2d, 1d };        for(Iterator<Entry> it = v.sparseIterator(); it.hasNext() && (e = it.next()) != null; i++) {            Assert.assertEquals(nonDefaultV2[i], e.getValue(), 0);        }        double [] onlyOne = {0d, 1.0, 0d};        v = new TestVectorImpl(onlyOne);        for(Iterator<Entry> it = v.sparseIterator(); it.hasNext() && (e = it.next()) != null; ) {            Assert.assertEquals(onlyOne[1], e.getValue(), 0);        }    }    @Test    public void testClone() throws Exception {        double[] d = new double[1000000];        Random r = new Random(1234);        for(int i=0;i<d.length; i++) d[i] = r.nextDouble();        Assert.assertTrue(new ArrayRealVector(d).getNorm() > 0);        double[] c = d.clone();        c[0] = 1;        Assert.assertNotSame(c[0], d[0]);        d[0] = 1;        Assert.assertEquals(new ArrayRealVector(d).getNorm(), new ArrayRealVector(c).getNorm(), 0);    }    @Test(expected=DimensionMismatchException.class)    public void testCombinePrecondition() {        final double a = 1d;        final double b = 2d;        double[] aux = new double[] { 3d, 4d, 5d };        final TestVectorImpl x = new TestVectorImpl(aux);        aux = new double[] { 6d, 7d };        final TestVectorImpl y = new TestVectorImpl(aux);        x.combine(a, b, y);    }    @Test    public void testCombine() {        final Random random = new Random(20110726);        final int dim = 10;        final double a = (2 * random.nextDouble() - 1);        final double b = (2 * random.nextDouble() - 1);        final RealVector x = new TestVectorImpl(new double[dim]);        final RealVector y = new TestVectorImpl(new double[dim]);        final double[] expected = new double[dim];        for (int i = 0; i < dim; i++) {            final double xi = 2 * random.nextDouble() - 1;            final double yi = 2 * random.nextDouble() - 1;            x.setEntry(i, xi);            y.setEntry(i, yi);            expected[i] = a * xi + b * yi;        }        final RealVector z = x.combine(a, b, y);        Assert.assertTrue(z != x);        final double[] actual = z.toArray();        for (int i = 0; i < dim; i++) {            final double delta;            if (expected[i] == 0d) {                delta = Math.ulp(1d);            } else {                delta = Math.ulp(expected[i]);            }            Assert.assertEquals("elements [" + i + "] differ", expected[i],                                actual[i], delta);        }    }    @Test(expected=DimensionMismatchException.class)    public void testCombineToSelfPrecondition() {        final double a = 1d;        final double b = 2d;        double[] aux = new double[] { 3d, 4d, 5d };        final TestVectorImpl x = new TestVectorImpl(aux);        aux = new double[] { 6d, 7d };        final TestVectorImpl y = new TestVectorImpl(aux);        x.combineToSelf(a, b, y);    }    @Test    public void testCombineToSelf() {        final Random random = new Random(20110726);        final int dim = 10;        final double a = (2 * random.nextDouble() - 1);        final double b = (2 * random.nextDouble() - 1);        final RealVector x = new TestVectorImpl(new double[dim]);        final RealVector y = new TestVectorImpl(new double[dim]);        final double[] expected = new double[dim];        for (int i = 0; i < dim; i++) {            final double xi = 2 * random.nextDouble() - 1;            final double yi = 2 * random.nextDouble() - 1;            x.setEntry(i, xi);            y.setEntry(i, yi);            expected[i] = a * xi + b * yi;        }        Assert.assertSame(x, x.combineToSelf(a, b, y));        final double[] actual = x.toArray();        for (int i = 0; i < dim; i++) {            final double delta;            if (expected[i] == 0d) {                delta = Math.ulp(1d);            } else {                delta = Math.ulp(expected[i]);            }            Assert.assertEquals("elements [" + i + "] differ", expected[i],                                actual[i], delta);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.io.Serializable;import java.util.Iterator;import org.junit.Assert;import org.junit.Test;import org.apache.commons.math.TestUtils;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.exception.MathArithmeticException;import org.apache.commons.math.exception.OutOfRangeException;import org.apache.commons.math.analysis.function.Abs;import org.apache.commons.math.analysis.function.Acos;import org.apache.commons.math.analysis.function.Asin;import org.apache.commons.math.analysis.function.Atan;import org.apache.commons.math.analysis.function.Cbrt;import org.apache.commons.math.analysis.function.Cosh;import org.apache.commons.math.analysis.function.Cos;import org.apache.commons.math.analysis.function.Exp;import org.apache.commons.math.analysis.function.Expm1;import org.apache.commons.math.analysis.function.Inverse;import org.apache.commons.math.analysis.function.Log10;import org.apache.commons.math.analysis.function.Log1p;import org.apache.commons.math.analysis.function.Log;import org.apache.commons.math.analysis.function.Sinh;import org.apache.commons.math.analysis.function.Sin;import org.apache.commons.math.analysis.function.Sqrt;import org.apache.commons.math.analysis.function.Tanh;import org.apache.commons.math.analysis.function.Tan;import org.apache.commons.math.analysis.function.Floor;import org.apache.commons.math.analysis.function.Ceil;import org.apache.commons.math.analysis.function.Rint;import org.apache.commons.math.analysis.function.Signum;import org.apache.commons.math.analysis.function.Ulp;import org.apache.commons.math.analysis.function.Power;/** * Test cases for the {@link OpenMapRealVector} class. * * @version $Id$ */public class SparseRealVectorTest {    //    protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};    protected double[] vec1 = {1d, 2d, 3d};    protected double[] vec2 = {4d, 5d, 6d};    protected double[] vec3 = {7d, 8d, 9d};    protected double[] vec4 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};    protected double[] vec5 = { -4d, 0d, 3d, 1d, -6d, 3d};    protected double[] vec_null = {0d, 0d, 0d};    protected Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};    protected double[][] mat1 = {{1d, 2d, 3d}, {4d, 5d, 6d},{ 7d, 8d, 9d}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    // Testclass to test the RealVector interface    // only with enough content to support the test    public static class SparseRealVectorTestImpl extends RealVector implements Serializable {        private static final long serialVersionUID = -6251371752518113791L;        /** Entries of the vector. */        protected double data[];        public SparseRealVectorTestImpl(double[] d) {            data = d.clone();        }        private UnsupportedOperationException unsupported() {            return new UnsupportedOperationException("Not supported, unneeded for test purposes");        }        @Override        public RealVector map(UnivariateRealFunction function) {            throw unsupported();        }        @Override        public RealVector mapToSelf(UnivariateRealFunction function) {            throw unsupported();        }        @Override        public Iterator<Entry> iterator() {            throw unsupported();        }        @Override        public RealVector copy() {            return new SparseRealVectorTestImpl(data);        }        @Override        public RealVector add(RealVector v) {            throw unsupported();        }        @Override        public RealVector subtract(RealVector v) {            throw unsupported();        }        @Override        public RealVector mapAdd(double d) {            throw unsupported();        }        @Override        public RealVector mapAddToSelf(double d) {            throw unsupported();        }        @Override        public RealVector mapSubtract(double d) {            throw unsupported();        }        @Override        public RealVector mapSubtractToSelf(double d) {            throw unsupported();        }        @Override        public RealVector mapMultiply(double d) {            double[] out = new double[data.length];            for (int i = 0; i < data.length; i++) {                out[i] = data[i] * d;            }            return new OpenMapRealVector(out);        }        @Override        public RealVector mapMultiplyToSelf(double d) {            throw unsupported();        }        @Override        public RealVector mapDivide(double d) {            throw unsupported();        }        @Override        public RealVector mapDivideToSelf(double d) {            throw unsupported();        }        public RealVector ebeMultiply(RealVector v) {            throw unsupported();        }        public RealVector ebeDivide(RealVector v) {            throw unsupported();        }        @Override        public double[] getData() {            return data.clone();        }        @Override        public double dotProduct(RealVector v) {            double dot = 0;            for (int i = 0; i < data.length; i++) {                dot += data[i] * v.getEntry(i);            }            return dot;        }        @Override        public double getNorm() {            throw unsupported();        }        @Override        public double getL1Norm() {            throw unsupported();        }        @Override        public double getLInfNorm() {            throw unsupported();        }        @Override        public double getDistance(RealVector v) {            throw unsupported();        }        @Override        public double getL1Distance(RealVector v) {            throw unsupported();        }        @Override        public double getLInfDistance(RealVector v) {            throw unsupported();        }        @Override        public RealVector unitVector() {            throw unsupported();        }        @Override        public void unitize() {            throw unsupported();        }        public RealVector projection(RealVector v) {            throw unsupported();        }        @Override        public RealMatrix outerProduct(RealVector v) {            throw unsupported();        }        public double getEntry(int index) {            return data[index];        }        public int getDimension() {            return data.length;        }        public RealVector append(RealVector v) {            throw unsupported();        }        public RealVector append(double d) {            throw unsupported();        }        public RealVector getSubVector(int index, int n) {            throw unsupported();        }        public void setEntry(int index, double value) {            data[index] = value;        }        @Override        public void setSubVector(int index, RealVector v) {            throw unsupported();        }        @Override        public void set(double value) {            throw unsupported();        }        @Override        public double[] toArray() {            throw unsupported();        }        public boolean isNaN() {            throw unsupported();        }        public boolean isInfinite() {            throw unsupported();        }    }    @Test    public void testConstructors() {        OpenMapRealVector v0 = new OpenMapRealVector();        Assert.assertEquals("testData len", 0, v0.getDimension());        OpenMapRealVector v1 = new OpenMapRealVector(7);        Assert.assertEquals("testData len", 7, v1.getDimension());        Assert.assertEquals("testData is 0.0 ", 0.0, v1.getEntry(6), 0);        OpenMapRealVector v3 = new OpenMapRealVector(vec1);        Assert.assertEquals("testData len", 3, v3.getDimension());        Assert.assertEquals("testData is 2.0 ", 2.0, v3.getEntry(1), 0);        //SparseRealVector v4 = new SparseRealVector(vec4, 3, 2);        //Assert.assertEquals("testData len", 2, v4.getDimension());        //Assert.assertEquals("testData is 4.0 ", 4.0, v4.getEntry(0));        //try {        //    new SparseRealVector(vec4, 8, 3);        //    Assert.fail("MathIllegalArgumentException expected");        //} catch (MathIllegalArgumentException ex) {            // expected behavior        //}        RealVector v5_i = new OpenMapRealVector(dvec1);        Assert.assertEquals("testData len", 9, v5_i.getDimension());        Assert.assertEquals("testData is 9.0 ", 9.0, v5_i.getEntry(8), 0);        OpenMapRealVector v5 = new OpenMapRealVector(dvec1);        Assert.assertEquals("testData len", 9, v5.getDimension());        Assert.assertEquals("testData is 9.0 ", 9.0, v5.getEntry(8), 0);        OpenMapRealVector v7 = new OpenMapRealVector(v1);        Assert.assertEquals("testData len", 7, v7.getDimension());        Assert.assertEquals("testData is 0.0 ", 0.0, v7.getEntry(6), 0);        SparseRealVectorTestImpl v7_i = new SparseRealVectorTestImpl(vec1);        OpenMapRealVector v7_2 = new OpenMapRealVector(v7_i);        Assert.assertEquals("testData len", 3, v7_2.getDimension());        Assert.assertEquals("testData is 0.0 ", 2.0d, v7_2.getEntry(1), 0);        OpenMapRealVector v8 = new OpenMapRealVector(v1);        Assert.assertEquals("testData len", 7, v8.getDimension());        Assert.assertEquals("testData is 0.0 ", 0.0, v8.getEntry(6), 0);    }    @Test    public void testDataInOut() {        OpenMapRealVector v1 = new OpenMapRealVector(vec1);        OpenMapRealVector v2 = new OpenMapRealVector(vec2);        OpenMapRealVector v4 = new OpenMapRealVector(vec4);        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2);        RealVector v_append_1 = v1.append(v2);        Assert.assertEquals("testData len", 6, v_append_1.getDimension());        Assert.assertEquals("testData is 4.0 ", 4.0, v_append_1.getEntry(3), 0);        RealVector v_append_2 = v1.append(2.0);        Assert.assertEquals("testData len", 4, v_append_2.getDimension());        Assert.assertEquals("testData is 2.0 ", 2.0, v_append_2.getEntry(3), 0);        RealVector v_append_4 = v1.append(v2_t);        Assert.assertEquals("testData len", 6, v_append_4.getDimension());        Assert.assertEquals("testData is 4.0 ", 4.0, v_append_4.getEntry(3), 0);        RealVector vout5 = v4.getSubVector(3, 3);        Assert.assertEquals("testData len", 3, vout5.getDimension());        Assert.assertEquals("testData is 4.0 ", 5.0, vout5.getEntry(1), 0);        try {            v4.getSubVector(3, 7);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException ex) {            // expected behavior        }        OpenMapRealVector v_set1 = v1.copy();        v_set1.setEntry(1, 11.0);        Assert.assertEquals("testData is 11.0 ", 11.0, v_set1.getEntry(1), 0);        try {            v_set1.setEntry(3, 11.0);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException ex) {            // expected behavior        }        OpenMapRealVector v_set2 = v4.copy();        v_set2.setSubVector(3, v1);        Assert.assertEquals("testData is 1.0 ", 1.0, v_set2.getEntry(3), 0);        Assert.assertEquals("testData is 7.0 ", 7.0, v_set2.getEntry(6), 0);        try {            v_set2.setSubVector(7, v1);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException ex) {            // expected behavior        }        OpenMapRealVector v_set3 = v1.copy();        v_set3.set(13.0);        Assert.assertEquals("testData is 13.0 ", 13.0, v_set3.getEntry(2), 0);        try {            v_set3.getEntry(23);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException ex) {            // expected behavior        }        OpenMapRealVector v_set4 = v4.copy();        v_set4.setSubVector(3, v2_t);        Assert.assertEquals("testData is 1.0 ", 4.0, v_set4.getEntry(3), 0);        Assert.assertEquals("testData is 7.0 ", 7.0, v_set4.getEntry(6), 0);        try {            v_set4.setSubVector(7, v2_t);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException ex) {            // expected behavior        }    }    @Test    public void testMapFunctions() {        OpenMapRealVector v1 = new OpenMapRealVector(vec1);        //octave =  v1 .+ 2.0        RealVector v_mapAdd = v1.mapAdd(2.0d);        double[] result_mapAdd = {3d, 4d, 5d};        assertClose("compare vectors" ,result_mapAdd,v_mapAdd.getData(),normTolerance);        //octave =  v1 .+ 2.0        RealVector v_mapAddToSelf = v1.copy();        v_mapAddToSelf.mapAddToSelf(2.0d);        double[] result_mapAddToSelf = {3d, 4d, 5d};        assertClose("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData(),normTolerance);        //octave =  v1 .- 2.0        RealVector v_mapSubtract = v1.mapSubtract(2.0d);        double[] result_mapSubtract = {-1d, 0d, 1d};        assertClose("compare vectors" ,result_mapSubtract,v_mapSubtract.getData(),normTolerance);        //octave =  v1 .- 2.0        RealVector v_mapSubtractToSelf = v1.copy();        v_mapSubtractToSelf.mapSubtractToSelf(2.0d);        double[] result_mapSubtractToSelf = {-1d, 0d, 1d};        assertClose("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData(),normTolerance);        //octave =  v1 .* 2.0        RealVector v_mapMultiply = v1.mapMultiply(2.0d);        double[] result_mapMultiply = {2d, 4d, 6d};        assertClose("compare vectors" ,result_mapMultiply,v_mapMultiply.getData(),normTolerance);        //octave =  v1 .* 2.0        RealVector v_mapMultiplyToSelf = v1.copy();        v_mapMultiplyToSelf.mapMultiplyToSelf(2.0d);        double[] result_mapMultiplyToSelf = {2d, 4d, 6d};        assertClose("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData(),normTolerance);        //octave =  v1 ./ 2.0        RealVector v_mapDivide = v1.mapDivide(2.0d);        double[] result_mapDivide = {.5d, 1d, 1.5d};        assertClose("compare vectors" ,result_mapDivide,v_mapDivide.getData(),normTolerance);        //octave =  v1 ./ 2.0        RealVector v_mapDivideToSelf = v1.copy();        v_mapDivideToSelf.mapDivideToSelf(2.0d);        double[] result_mapDivideToSelf = {.5d, 1d, 1.5d};        assertClose("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData(),normTolerance);        //octave =  v1 .^ 2.0        RealVector v_mapPow = v1.map(new Power(2));        double[] result_mapPow = {1d, 4d, 9d};        assertClose("compare vectors" ,result_mapPow,v_mapPow.getData(),normTolerance);        //octave =  v1 .^ 2.0        RealVector v_mapPowToSelf = v1.copy();        v_mapPowToSelf.mapToSelf(new Power(2));        double[] result_mapPowToSelf = {1d, 4d, 9d};        assertClose("compare vectors" ,result_mapPowToSelf,v_mapPowToSelf.getData(),normTolerance);        //octave =  exp(v1)        RealVector v_mapExp = v1.map(new Exp());        double[] result_mapExp = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};        assertClose("compare vectors" ,result_mapExp,v_mapExp.getData(),normTolerance);        //octave =  exp(v1)        RealVector v_mapExpToSelf = v1.copy();        v_mapExpToSelf.mapToSelf(new Exp());        double[] result_mapExpToSelf = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};        assertClose("compare vectors" ,result_mapExpToSelf,v_mapExpToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapExpm1 = v1.map(new Expm1());        double[] result_mapExpm1 = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};        assertClose("compare vectors" ,result_mapExpm1,v_mapExpm1.getData(),normTolerance);        //octave =  ???        RealVector v_mapExpm1ToSelf = v1.copy();        v_mapExpm1ToSelf.mapToSelf(new Expm1());        double[] result_mapExpm1ToSelf = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};        assertClose("compare vectors" ,result_mapExpm1ToSelf,v_mapExpm1ToSelf.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLog = v1.map(new Log());        double[] result_mapLog = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};        assertClose("compare vectors" ,result_mapLog,v_mapLog.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLogToSelf = v1.copy();        v_mapLogToSelf.mapToSelf(new Log());        double[] result_mapLogToSelf = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};        assertClose("compare vectors" ,result_mapLogToSelf,v_mapLogToSelf.getData(),normTolerance);        //octave =  log10(v1)        RealVector v_mapLog10 = v1.map(new Log10());        double[] result_mapLog10 = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};        assertClose("compare vectors" ,result_mapLog10,v_mapLog10.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLog10ToSelf = v1.copy();        v_mapLog10ToSelf.mapToSelf(new Log10());        double[] result_mapLog10ToSelf = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};        assertClose("compare vectors" ,result_mapLog10ToSelf,v_mapLog10ToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapLog1p = v1.map(new Log1p());        double[] result_mapLog1p = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};        assertClose("compare vectors" ,result_mapLog1p,v_mapLog1p.getData(),normTolerance);        //octave =  ???        RealVector v_mapLog1pToSelf = v1.copy();        v_mapLog1pToSelf.mapToSelf(new Log1p());        double[] result_mapLog1pToSelf = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};        assertClose("compare vectors" ,result_mapLog1pToSelf,v_mapLog1pToSelf.getData(),normTolerance);        //octave =  cosh(v1)        RealVector v_mapCosh = v1.map(new Cosh());        double[] result_mapCosh = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};        assertClose("compare vectors" ,result_mapCosh,v_mapCosh.getData(),normTolerance);        //octave =  cosh(v1)        RealVector v_mapCoshToSelf = v1.copy();        v_mapCoshToSelf.mapToSelf(new Cosh());        double[] result_mapCoshToSelf = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};        assertClose("compare vectors" ,result_mapCoshToSelf,v_mapCoshToSelf.getData(),normTolerance);        //octave =  sinh(v1)        RealVector v_mapSinh = v1.map(new Sinh());        double[] result_mapSinh = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};        assertClose("compare vectors" ,result_mapSinh,v_mapSinh.getData(),normTolerance);        //octave =  sinh(v1)        RealVector v_mapSinhToSelf = v1.copy();        v_mapSinhToSelf.mapToSelf(new Sinh());        double[] result_mapSinhToSelf = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};        assertClose("compare vectors" ,result_mapSinhToSelf,v_mapSinhToSelf.getData(),normTolerance);        //octave =  tanh(v1)        RealVector v_mapTanh = v1.map(new Tanh());        double[] result_mapTanh = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};        assertClose("compare vectors" ,result_mapTanh,v_mapTanh.getData(),normTolerance);        //octave =  tanh(v1)        RealVector v_mapTanhToSelf = v1.copy();        v_mapTanhToSelf.mapToSelf(new Tanh());        double[] result_mapTanhToSelf = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};        assertClose("compare vectors" ,result_mapTanhToSelf,v_mapTanhToSelf.getData(),normTolerance);        //octave =  cos(v1)        RealVector v_mapCos = v1.map(new Cos());        double[] result_mapCos = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};        assertClose("compare vectors" ,result_mapCos,v_mapCos.getData(),normTolerance);        //octave =  cos(v1)        RealVector v_mapCosToSelf = v1.copy();        v_mapCosToSelf.mapToSelf(new Cos());        double[] result_mapCosToSelf = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};        assertClose("compare vectors" ,result_mapCosToSelf,v_mapCosToSelf.getData(),normTolerance);        //octave =  sin(v1)        RealVector v_mapSin = v1.map(new Sin());        double[] result_mapSin = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};        assertClose("compare vectors" ,result_mapSin,v_mapSin.getData(),normTolerance);        //octave =  sin(v1)        RealVector v_mapSinToSelf = v1.copy();        v_mapSinToSelf.mapToSelf(new Sin());        double[] result_mapSinToSelf = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};        assertClose("compare vectors" ,result_mapSinToSelf,v_mapSinToSelf.getData(),normTolerance);        //octave =  tan(v1)        RealVector v_mapTan = v1.map(new Tan());        double[] result_mapTan = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};        assertClose("compare vectors" ,result_mapTan,v_mapTan.getData(),normTolerance);        //octave =  tan(v1)        RealVector v_mapTanToSelf = v1.copy();        v_mapTanToSelf.mapToSelf(new Tan());        double[] result_mapTanToSelf = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};        assertClose("compare vectors" ,result_mapTanToSelf,v_mapTanToSelf.getData(),normTolerance);        double[] vat_a = {0d, 0.5d, 1.0d};        OpenMapRealVector vat = new OpenMapRealVector(vat_a);        //octave =  acos(vat)        RealVector v_mapAcos = vat.map(new Acos());        double[] result_mapAcos = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};        assertClose("compare vectors" ,result_mapAcos,v_mapAcos.getData(),normTolerance);        //octave =  acos(vat)        RealVector v_mapAcosToSelf = vat.copy();        v_mapAcosToSelf.mapToSelf(new Acos());        double[] result_mapAcosToSelf = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};        assertClose("compare vectors" ,result_mapAcosToSelf,v_mapAcosToSelf.getData(),normTolerance);        //octave =  asin(vat)        RealVector v_mapAsin = vat.map(new Asin());        double[] result_mapAsin = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};        assertClose("compare vectors" ,result_mapAsin,v_mapAsin.getData(),normTolerance);        //octave =  asin(vat)        RealVector v_mapAsinToSelf = vat.copy();        v_mapAsinToSelf.mapToSelf(new Asin());        double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};        assertClose("compare vectors" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);        //octave =  atan(vat)        RealVector v_mapAtan = vat.map(new Atan());        double[] result_mapAtan = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};        assertClose("compare vectors" ,result_mapAtan,v_mapAtan.getData(),normTolerance);        //octave =  atan(vat)        RealVector v_mapAtanToSelf = vat.copy();        v_mapAtanToSelf.mapToSelf(new Atan());        double[] result_mapAtanToSelf = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};        assertClose("compare vectors" ,result_mapAtanToSelf,v_mapAtanToSelf.getData(),normTolerance);        //octave =  v1 .^-1        RealVector v_mapInv = v1.map(new Inverse());        double[] result_mapInv = {1d,0.5d,3.333333333333333e-01d};        assertClose("compare vectors" ,result_mapInv,v_mapInv.getData(),normTolerance);        //octave =  v1 .^-1        RealVector v_mapInvToSelf = v1.copy();        v_mapInvToSelf.mapToSelf(new Inverse());        double[] result_mapInvToSelf = {1d,0.5d,3.333333333333333e-01d};        assertClose("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData(),normTolerance);        double[] abs_a = {-1.0d, 0.0d, 1.0d};        OpenMapRealVector abs_v = new OpenMapRealVector(abs_a);        //octave =  abs(abs_v)        RealVector v_mapAbs = abs_v.map(new Abs());        double[] result_mapAbs = {1d,0d,1d};        assertClose("compare vectors" ,result_mapAbs,v_mapAbs.getData(),normTolerance);        //octave = abs(abs_v)        RealVector v_mapAbsToSelf = abs_v.copy();        v_mapAbsToSelf.mapToSelf(new Abs());        double[] result_mapAbsToSelf = {1d,0d,1d};        assertClose("compare vectors" ,result_mapAbsToSelf,v_mapAbsToSelf.getData(),normTolerance);        //octave =   sqrt(v1)        RealVector v_mapSqrt = v1.map(new Sqrt());        double[] result_mapSqrt = {1d,1.414213562373095e+00d,1.732050807568877e+00d};        assertClose("compare vectors" ,result_mapSqrt,v_mapSqrt.getData(),normTolerance);        //octave =  sqrt(v1)        RealVector v_mapSqrtToSelf = v1.copy();        v_mapSqrtToSelf.mapToSelf(new Sqrt());        double[] result_mapSqrtToSelf = {1d,1.414213562373095e+00d,1.732050807568877e+00d};        assertClose("compare vectors" ,result_mapSqrtToSelf,v_mapSqrtToSelf.getData(),normTolerance);        double[] cbrt_a = {-2.0d, 0.0d, 2.0d};        OpenMapRealVector cbrt_v = new OpenMapRealVector(cbrt_a);        //octave =  ???        RealVector v_mapCbrt = cbrt_v.map(new Cbrt());        double[] result_mapCbrt = {-1.2599210498948732d,0d,1.2599210498948732d};        assertClose("compare vectors" ,result_mapCbrt,v_mapCbrt.getData(),normTolerance);        //octave = ???        RealVector v_mapCbrtToSelf = cbrt_v.copy();        v_mapCbrtToSelf.mapToSelf(new Cbrt());        double[] result_mapCbrtToSelf =  {-1.2599210498948732d,0d,1.2599210498948732d};        assertClose("compare vectors" ,result_mapCbrtToSelf,v_mapCbrtToSelf.getData(),normTolerance);        double[] ceil_a = {-1.1d, 0.9d, 1.1d};        OpenMapRealVector ceil_v = new OpenMapRealVector(ceil_a);        //octave =  ceil(ceil_v)        RealVector v_mapCeil = ceil_v.map(new Ceil());        double[] result_mapCeil = {-1d,1d,2d};        assertClose("compare vectors" ,result_mapCeil,v_mapCeil.getData(),normTolerance);        //octave = ceil(ceil_v)        RealVector v_mapCeilToSelf = ceil_v.copy();        v_mapCeilToSelf.mapToSelf(new Ceil());        double[] result_mapCeilToSelf =  {-1d,1d,2d};        assertClose("compare vectors" ,result_mapCeilToSelf,v_mapCeilToSelf.getData(),normTolerance);        //octave =  floor(ceil_v)        RealVector v_mapFloor = ceil_v.map(new Floor());        double[] result_mapFloor = {-2d,0d,1d};        assertClose("compare vectors" ,result_mapFloor,v_mapFloor.getData(),normTolerance);        //octave = floor(ceil_v)        RealVector v_mapFloorToSelf = ceil_v.copy();        v_mapFloorToSelf.mapToSelf(new Floor());        double[] result_mapFloorToSelf =  {-2d,0d,1d};        assertClose("compare vectors" ,result_mapFloorToSelf,v_mapFloorToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapRint = ceil_v.map(new Rint());        double[] result_mapRint = {-1d,1d,1d};        assertClose("compare vectors" ,result_mapRint,v_mapRint.getData(),normTolerance);        //octave = ???        RealVector v_mapRintToSelf = ceil_v.copy();        v_mapRintToSelf.mapToSelf(new Rint());        double[] result_mapRintToSelf =  {-1d,1d,1d};        assertClose("compare vectors" ,result_mapRintToSelf,v_mapRintToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapSignum = ceil_v.map(new Signum());        double[] result_mapSignum = {-1d,1d,1d};        assertClose("compare vectors" ,result_mapSignum,v_mapSignum.getData(),normTolerance);        //octave = ???        RealVector v_mapSignumToSelf = ceil_v.copy();        v_mapSignumToSelf.mapToSelf(new Signum());        double[] result_mapSignumToSelf =  {-1d,1d,1d};        assertClose("compare vectors" ,result_mapSignumToSelf,v_mapSignumToSelf.getData(),normTolerance);        // Is with the used resolutions of limited value as test        //octave =  ???        RealVector v_mapUlp = ceil_v.map(new Ulp());        double[] result_mapUlp = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};        assertClose("compare vectors" ,result_mapUlp,v_mapUlp.getData(),normTolerance);        //octave = ???        RealVector v_mapUlpToSelf = ceil_v.copy();        v_mapUlpToSelf.mapToSelf(new Ulp());        double[] result_mapUlpToSelf = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};        assertClose("compare vectors" ,result_mapUlpToSelf,v_mapUlpToSelf.getData(),normTolerance);    }    @Test    public void testBasicFunctions() {        OpenMapRealVector v1 = new OpenMapRealVector(vec1);        OpenMapRealVector v2 = new OpenMapRealVector(vec2);        OpenMapRealVector v5 = new OpenMapRealVector(vec5);        OpenMapRealVector v_null = new OpenMapRealVector(vec_null);        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2);        // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307        double d_getNorm = v5.getNorm();        Assert.assertEquals("compare values  ", 8.4261497731763586307, d_getNorm, normTolerance);        // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17        double d_getL1Norm = v5.getL1Norm();        Assert.assertEquals("compare values  ", 17.0, d_getL1Norm, normTolerance);        // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6        double d_getLInfNorm = v5.getLInfNorm();        Assert.assertEquals("compare values  ", 6.0, d_getLInfNorm, normTolerance);        //octave =  sqrt(sumsq(v1-v2))        double dist = v1.getDistance(v2);        Assert.assertEquals("compare values  ",v1.subtract(v2).getNorm(), dist, normTolerance);        //octave =  sqrt(sumsq(v1-v2))        double dist_2 = v1.getDistance(v2_t);        Assert.assertEquals("compare values  ", v1.subtract(v2).getNorm(),dist_2, normTolerance);        //octave =  ???        double d_getL1Distance = v1. getL1Distance(v2);        Assert.assertEquals("compare values  ", 9d, d_getL1Distance, normTolerance);        double d_getL1Distance_2 = v1. getL1Distance(v2_t);        Assert.assertEquals("compare values  ", 9d, d_getL1Distance_2, normTolerance);        //octave =  ???        double d_getLInfDistance = v1. getLInfDistance(v2);        Assert.assertEquals("compare values  ", 3d, d_getLInfDistance, normTolerance);        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);        Assert.assertEquals("compare values  ", 3d, d_getLInfDistance_2, normTolerance);        //octave =  v1 + v2        OpenMapRealVector v_add = v1.add(v2);        double[] result_add = {5d, 7d, 9d};        assertClose("compare vect" ,v_add.getData(),result_add,normTolerance);        SparseRealVectorTestImpl vt2 = new SparseRealVectorTestImpl(vec2);        RealVector v_add_i = v1.add(vt2);        double[] result_add_i = {5d, 7d, 9d};        assertClose("compare vect" ,v_add_i.getData(),result_add_i,normTolerance);        //octave =  v1 - v2        OpenMapRealVector v_subtract = v1.subtract(v2);        double[] result_subtract = {-3d, -3d, -3d};        assertClose("compare vect" ,v_subtract.getData(),result_subtract,normTolerance);        RealVector v_subtract_i = v1.subtract(vt2);        double[] result_subtract_i = {-3d, -3d, -3d};        assertClose("compare vect" ,v_subtract_i.getData(),result_subtract_i,normTolerance);        // octave v1 .* v2        RealVector  v_ebeMultiply = v1.ebeMultiply(v2);        double[] result_ebeMultiply = {4d, 10d, 18d};        assertClose("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);        double[] result_ebeMultiply_2 = {4d, 10d, 18d};        assertClose("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);        // octave v1 ./ v2        RealVector  v_ebeDivide = v1.ebeDivide(v2);        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};        assertClose("compare vect" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};        assertClose("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);        // octave  dot(v1,v2)        double dot =  v1.dotProduct(v2);        Assert.assertEquals("compare val ",32d, dot, normTolerance);        // octave  dot(v1,v2_t)        double dot_2 =  v1.dotProduct(v2_t);        Assert.assertEquals("compare val ",32d, dot_2, normTolerance);        RealMatrix m_outerProduct = v1.outerProduct(v2);        Assert.assertEquals("compare val ",4d, m_outerProduct.getEntry(0,0), normTolerance);        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);        Assert.assertEquals("compare val ",4d, m_outerProduct_2.getEntry(0,0), normTolerance);        RealVector v_unitVector = v1.unitVector();        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());        assertClose("compare vect" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);        try {            v_null.unitVector();            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException ex) {            // expected behavior        }        OpenMapRealVector v_unitize = v1.copy();        v_unitize.unitize();        assertClose("compare vect" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);        try {            v_null.unitize();            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException ex) {            // expected behavior        }        RealVector v_projection = v1.projection(v2);        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};        assertClose("compare vect", v_projection.getData(), result_projection, normTolerance);        RealVector v_projection_2 = v1.projection(v2_t);        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};        assertClose("compare vect", v_projection_2.getData(), result_projection_2, normTolerance);    }    @Test    public void testOuterProduct() {        final OpenMapRealVector u = new OpenMapRealVector(new double[] {1, 2, -3});        final OpenMapRealVector v = new OpenMapRealVector(new double[] {4, -2});        final RealMatrix uv = u.outerProduct(v);        final double tol = Math.ulp(1d);        Assert.assertEquals(4, uv.getEntry(0, 0), tol);        Assert.assertEquals(-2, uv.getEntry(0, 1), tol);        Assert.assertEquals(8, uv.getEntry(1, 0), tol);        Assert.assertEquals(-4, uv.getEntry(1, 1), tol);        Assert.assertEquals(-12, uv.getEntry(2, 0), tol);        Assert.assertEquals(6, uv.getEntry(2, 1), tol);    }    @Test    public void testMisc() {        OpenMapRealVector v1 = new OpenMapRealVector(vec1);        String out1 = v1.toString();        Assert.assertTrue("some output ",  out1.length()!=0);        try {            v1.checkVectorDimensions(2);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected behavior        }    }    @Test    public void testPredicates() {        OpenMapRealVector v = new OpenMapRealVector(new double[] { 0, 1, 2 });        Assert.assertFalse(v.isNaN());        v.setEntry(1, Double.NaN);        Assert.assertTrue(v.isNaN());        Assert.assertFalse(v.isInfinite());        v.setEntry(0, Double.POSITIVE_INFINITY);        Assert.assertFalse(v.isInfinite()); // NaN has higher priority than infinity        v.setEntry(1, 1);        Assert.assertTrue(v.isInfinite());        v.setEntry(0, 0);        Assert.assertEquals(v, new OpenMapRealVector(new double[] { 0, 1, 2 }));        Assert.assertNotSame(v, new OpenMapRealVector(new double[] { 0, 1, 2 + FastMath.ulp(2)}));        Assert.assertNotSame(v, new OpenMapRealVector(new double[] { 0, 1, 2, 3 }));    }    @Test    public void testSerial()  {        OpenMapRealVector v = new OpenMapRealVector(new double[] { 0, 1, 2 });        Assert.assertEquals(v,TestUtils.serializeAndRecover(v));    }    /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, double[] m, double[] n,                               double tolerance) {        if (m.length != n.length) {            Assert.fail("vectors have different lengths");        }        for (int i = 0; i < m.length; i++) {            Assert.assertEquals(msg + " " +  i + " elements differ", m[i],n[i],tolerance);        }    }    /* Check that the operations do not throw an exception (cf. MATH-645). */    @Test    public void testConcurrentModification() {        final RealVector u = new OpenMapRealVector(3, 1e-6);        u.setEntry(0, 1);        u.setEntry(1, 0);        u.setEntry(2, 2);        final RealVector v1 = new OpenMapRealVector(3, 1e-6);        v1.setEntry(0, 0);        v1.setEntry(1, 3);        v1.setEntry(2, 0);        RealVector w;        w = u.ebeMultiply(v1);        w = u.ebeDivide(v1);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.io.BufferedReader;import java.io.DataInputStream;import java.io.IOException;import java.io.InputStreamReader;import java.util.Random;import org.junit.Assert;import org.junit.Test;public class SingularValueDecompositionImplTest {    private double[][] testSquare = {            { 24.0 / 25.0, 43.0 / 25.0 },            { 57.0 / 25.0, 24.0 / 25.0 }    };    private double[][] testNonSquare = {        {  -540.0 / 625.0,  963.0 / 625.0, -216.0 / 625.0 },        { -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 },        {  -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 },        {  -360.0 / 625.0,  192.0 / 625.0, 1756.0 / 625.0 },    };    private static final double normTolerance = 10e-14;    @Test    public void testMoreRows() {        final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };        final int rows    = singularValues.length + 2;        final int columns = singularValues.length;        Random r = new Random(15338437322523l);        SingularValueDecomposition svd =            new SingularValueDecompositionImpl(createTestMatrix(r, rows, columns, singularValues));        double[] computedSV = svd.getSingularValues();        Assert.assertEquals(singularValues.length, computedSV.length);        for (int i = 0; i < singularValues.length; ++i) {            Assert.assertEquals(singularValues[i], computedSV[i], 1.0e-10);        }    }    @Test    public void testMoreColumns() {        final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };        final int rows    = singularValues.length;        final int columns = singularValues.length + 2;        Random r = new Random(732763225836210l);        SingularValueDecomposition svd =            new SingularValueDecompositionImpl(createTestMatrix(r, rows, columns, singularValues));        double[] computedSV = svd.getSingularValues();        Assert.assertEquals(singularValues.length, computedSV.length);        for (int i = 0; i < singularValues.length; ++i) {            Assert.assertEquals(singularValues[i], computedSV[i], 1.0e-10);        }    }    /** test dimensions */    @Test    public void testDimensions() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testSquare);        final int m = matrix.getRowDimension();        final int n = matrix.getColumnDimension();        SingularValueDecomposition svd = new SingularValueDecompositionImpl(matrix);        Assert.assertEquals(m, svd.getU().getRowDimension());        Assert.assertEquals(m, svd.getU().getColumnDimension());        Assert.assertEquals(m, svd.getS().getColumnDimension());        Assert.assertEquals(n, svd.getS().getColumnDimension());        Assert.assertEquals(n, svd.getV().getRowDimension());        Assert.assertEquals(n, svd.getV().getColumnDimension());    }    /** Test based on a dimension 4 Hadamard matrix. */    @Test    public void testHadamard() {        RealMatrix matrix = new Array2DRowRealMatrix(new double[][] {                {15.0 / 2.0,  5.0 / 2.0,  9.0 / 2.0,  3.0 / 2.0 },                { 5.0 / 2.0, 15.0 / 2.0,  3.0 / 2.0,  9.0 / 2.0 },                { 9.0 / 2.0,  3.0 / 2.0, 15.0 / 2.0,  5.0 / 2.0 },                { 3.0 / 2.0,  9.0 / 2.0,  5.0 / 2.0, 15.0 / 2.0 }        }, false);        SingularValueDecomposition svd = new SingularValueDecompositionImpl(matrix);        Assert.assertEquals(16.0, svd.getSingularValues()[0], 1.0e-14);        Assert.assertEquals( 8.0, svd.getSingularValues()[1], 1.0e-14);        Assert.assertEquals( 4.0, svd.getSingularValues()[2], 1.0e-14);        Assert.assertEquals( 2.0, svd.getSingularValues()[3], 1.0e-14);        RealMatrix fullCovariance = new Array2DRowRealMatrix(new double[][] {                {  85.0 / 1024, -51.0 / 1024, -75.0 / 1024,  45.0 / 1024 },                { -51.0 / 1024,  85.0 / 1024,  45.0 / 1024, -75.0 / 1024 },                { -75.0 / 1024,  45.0 / 1024,  85.0 / 1024, -51.0 / 1024 },                {  45.0 / 1024, -75.0 / 1024, -51.0 / 1024,  85.0 / 1024 }        }, false);        Assert.assertEquals(0.0,                     fullCovariance.subtract(svd.getCovariance(0.0)).getNorm(),                     1.0e-14);        RealMatrix halfCovariance = new Array2DRowRealMatrix(new double[][] {                {   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024 },                {  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024 },                {   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024 },                {  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024 }        }, false);        Assert.assertEquals(0.0,                     halfCovariance.subtract(svd.getCovariance(6.0)).getNorm(),                     1.0e-14);    }    /** test A = USVt */    @Test    public void testAEqualUSVt() {        checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare));        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare));        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare).transpose());    }    public void checkAEqualUSVt(final RealMatrix matrix) {        SingularValueDecomposition svd = new SingularValueDecompositionImpl(matrix);        RealMatrix u = svd.getU();        RealMatrix s = svd.getS();        RealMatrix v = svd.getV();        double norm = u.multiply(s).multiply(v.transpose()).subtract(matrix).getNorm();        Assert.assertEquals(0, norm, normTolerance);    }    /** test that U is orthogonal */    @Test    public void testUOrthogonal() {        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getU());        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare)).getU());        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getU());    }    /** test that V is orthogonal */    @Test    public void testVOrthogonal() {        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getV());        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare)).getV());        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getV());    }    public void checkOrthogonal(final RealMatrix m) {        RealMatrix mTm = m.transpose().multiply(m);        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());        Assert.assertEquals(0, mTm.subtract(id).getNorm(), normTolerance);    }    /** test matrices values */    // This test is useless since whereas the columns of U and V are linked    // together, the actual triplet (U,S,V) is not uniquely defined.    public void testMatricesValues1() {       SingularValueDecomposition svd =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {                { 3.0 / 5.0, -4.0 / 5.0 },                { 4.0 / 5.0,  3.0 / 5.0 }        });        RealMatrix sRef = MatrixUtils.createRealMatrix(new double[][] {                { 3.0, 0.0 },                { 0.0, 1.0 }        });        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {                { 4.0 / 5.0,  3.0 / 5.0 },                { 3.0 / 5.0, -4.0 / 5.0 }        });        // check values against known references        RealMatrix u = svd.getU();        Assert.assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);        RealMatrix s = svd.getS();        Assert.assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);        RealMatrix v = svd.getV();        Assert.assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);        // check the same cached instance is returned the second time        Assert.assertTrue(u == svd.getU());        Assert.assertTrue(s == svd.getS());        Assert.assertTrue(v == svd.getV());    }    /** test matrices values */    // This test is useless since whereas the columns of U and V are linked    // together, the actual triplet (U,S,V) is not uniquely defined.    public void useless_testMatricesValues2() {        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {            {  0.0 / 5.0,  3.0 / 5.0,  0.0 / 5.0 },            { -4.0 / 5.0,  0.0 / 5.0, -3.0 / 5.0 },            {  0.0 / 5.0,  4.0 / 5.0,  0.0 / 5.0 },            { -3.0 / 5.0,  0.0 / 5.0,  4.0 / 5.0 }        });        RealMatrix sRef = MatrixUtils.createRealMatrix(new double[][] {            { 4.0, 0.0, 0.0 },            { 0.0, 3.0, 0.0 },            { 0.0, 0.0, 2.0 }        });        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {            {  80.0 / 125.0,  -60.0 / 125.0, 75.0 / 125.0 },            {  24.0 / 125.0,  107.0 / 125.0, 60.0 / 125.0 },            { -93.0 / 125.0,  -24.0 / 125.0, 80.0 / 125.0 }        });        // check values against known references        SingularValueDecomposition svd =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare));        RealMatrix u = svd.getU();        Assert.assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);        RealMatrix s = svd.getS();        Assert.assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);        RealMatrix v = svd.getV();        Assert.assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);        // check the same cached instance is returned the second time        Assert.assertTrue(u == svd.getU());        Assert.assertTrue(s == svd.getS());        Assert.assertTrue(v == svd.getV());    }     /** test MATH-465 */    @Test    public void testRank() {        double[][] d = { { 1, 1, 1 }, { 0, 0, 0 }, { 1, 2, 3 } };        RealMatrix m = new Array2DRowRealMatrix(d);        SingularValueDecomposition svd = new SingularValueDecompositionImpl(m);                Assert.assertEquals(2, svd.getRank());            }        /** test MATH-583 */    @Test    public void testStability1() {        RealMatrix m = new Array2DRowRealMatrix(201, 201);        loadRealMatrix(m,"matrix1.csv");        try {            new SingularValueDecompositionImpl(m);        } catch (Exception e) {            Assert.fail("Exception whilst constructing SVD");        }          }        /** test MATH-327 */    @Test    public void testStability2() {        RealMatrix m = new Array2DRowRealMatrix(7, 168);        loadRealMatrix(m,"matrix2.csv");        try {            new SingularValueDecompositionImpl(m);        } catch (Throwable e) {            Assert.fail("Exception whilst constructing SVD");        }          }        private void loadRealMatrix(RealMatrix m, String resourceName) {        try {            DataInputStream in = new DataInputStream(getClass().getResourceAsStream(resourceName));            BufferedReader br = new BufferedReader(new InputStreamReader(in));            String strLine;            int row = 0;            while ((strLine = br.readLine()) != null) {                int col = 0;                for (String entry : strLine.split(",")) {                    m.setEntry(row, col++, Double.parseDouble(entry));                }                row++;            }            in.close();        } catch (IOException e) {}          }        /** test condition number */    @Test    public void testConditionNumber() {        SingularValueDecompositionImpl svd =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));        // replace 1.0e-15 with 1.5e-15        Assert.assertEquals(3.0, svd.getConditionNumber(), 1.5e-15);    }    @Test    public void testInverseConditionNumber() {        SingularValueDecompositionImpl svd =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));        Assert.assertEquals(1.0/3.0, svd.getInverseConditionNumber(), 1.5e-15);    }        private RealMatrix createTestMatrix(final Random r, final int rows, final int columns,                                        final double[] singularValues) {        final RealMatrix u =            EigenDecompositionImplTest.createOrthogonalMatrix(r, rows);        final RealMatrix d =            EigenDecompositionImplTest.createDiagonalMatrix(singularValues, rows, columns);        final RealMatrix v =            EigenDecompositionImplTest.createOrthogonalMatrix(r, columns);        return u.multiply(d).multiply(v);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.junit.Test;import org.junit.Assert;import org.apache.commons.math.TestUtils;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionField;public class FieldLUDecompositionImplTest {    private Fraction[][] testData = {            { new Fraction(1), new Fraction(2), new Fraction(3)},            { new Fraction(2), new Fraction(5), new Fraction(3)},            { new Fraction(1), new Fraction(0), new Fraction(8)}    };    private Fraction[][] testDataMinus = {            { new Fraction(-1), new Fraction(-2), new Fraction(-3)},            { new Fraction(-2), new Fraction(-5), new Fraction(-3)},            { new Fraction(-1),  new Fraction(0), new Fraction(-8)}    };    private Fraction[][] luData = {            { new Fraction(2), new Fraction(3), new Fraction(3) },            { new Fraction(2), new Fraction(3), new Fraction(7) },            { new Fraction(6), new Fraction(6), new Fraction(8) }    };    // singular matrices    private Fraction[][] singular = {            { new Fraction(2), new Fraction(3) },            { new Fraction(2), new Fraction(3) }    };    private Fraction[][] bigSingular = {            { new Fraction(1), new Fraction(2),   new Fraction(3),    new Fraction(4) },            { new Fraction(2), new Fraction(5),   new Fraction(3),    new Fraction(4) },            { new Fraction(7), new Fraction(3), new Fraction(256), new Fraction(1930) },            { new Fraction(3), new Fraction(7),   new Fraction(6),    new Fraction(8) }    }; // 4th row = 1st + 2nd    /** test dimensions */    @Test    public void testDimensions() {        FieldMatrix<Fraction> matrix =            new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);        FieldLUDecomposition<Fraction> LU = new FieldLUDecompositionImpl<Fraction>(matrix);        Assert.assertEquals(testData.length, LU.getL().getRowDimension());        Assert.assertEquals(testData.length, LU.getL().getColumnDimension());        Assert.assertEquals(testData.length, LU.getU().getRowDimension());        Assert.assertEquals(testData.length, LU.getU().getColumnDimension());        Assert.assertEquals(testData.length, LU.getP().getRowDimension());        Assert.assertEquals(testData.length, LU.getP().getColumnDimension());    }    /** test non-square matrix */    @Test    public void testNonSquare() {        try {            // we don't use FractionField.getInstance() for testing purposes            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                    { Fraction.ZERO, Fraction.ZERO },                    { Fraction.ZERO, Fraction.ZERO },                    { Fraction.ZERO, Fraction.ZERO }            }));            Assert.fail("Expected NonSquareMatrixException");        } catch (NonSquareMatrixException ime) {            // expected behavior        }    }    /** test PA = LU */    @Test    public void testPAEqualLU() {        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);        FieldLUDecomposition<Fraction> lu = new FieldLUDecompositionImpl<Fraction>(matrix);        FieldMatrix<Fraction> l = lu.getL();        FieldMatrix<Fraction> u = lu.getU();        FieldMatrix<Fraction> p = lu.getP();        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testDataMinus);        lu = new FieldLUDecompositionImpl<Fraction>(matrix);        l = lu.getL();        u = lu.getU();        p = lu.getP();        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), 17, 17);        for (int i = 0; i < matrix.getRowDimension(); ++i) {            matrix.setEntry(i, i, Fraction.ONE);        }        lu = new FieldLUDecompositionImpl<Fraction>(matrix);        l = lu.getL();        u = lu.getU();        p = lu.getP();        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), singular);        lu = new FieldLUDecompositionImpl<Fraction>(matrix);        Assert.assertFalse(lu.getSolver().isNonSingular());        Assert.assertNull(lu.getL());        Assert.assertNull(lu.getU());        Assert.assertNull(lu.getP());        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), bigSingular);        lu = new FieldLUDecompositionImpl<Fraction>(matrix);        Assert.assertFalse(lu.getSolver().isNonSingular());        Assert.assertNull(lu.getL());        Assert.assertNull(lu.getU());        Assert.assertNull(lu.getP());    }    /** test that L is lower triangular with unit diagonal */    @Test    public void testLLowerTriangular() {        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);        FieldMatrix<Fraction> l = new FieldLUDecompositionImpl<Fraction>(matrix).getL();        for (int i = 0; i < l.getRowDimension(); i++) {            Assert.assertEquals(Fraction.ONE, l.getEntry(i, i));            for (int j = i + 1; j < l.getColumnDimension(); j++) {                Assert.assertEquals(Fraction.ZERO, l.getEntry(i, j));            }        }    }    /** test that U is upper triangular */    @Test    public void testUUpperTriangular() {        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);        FieldMatrix<Fraction> u = new FieldLUDecompositionImpl<Fraction>(matrix).getU();        for (int i = 0; i < u.getRowDimension(); i++) {            for (int j = 0; j < i; j++) {                Assert.assertEquals(Fraction.ZERO, u.getEntry(i, j));            }        }    }    /** test that P is a permutation matrix */    @Test    public void testPPermutation() {        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);        FieldMatrix<Fraction> p   = new FieldLUDecompositionImpl<Fraction>(matrix).getP();        FieldMatrix<Fraction> ppT = p.multiply(p.transpose());        FieldMatrix<Fraction> id  =            new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),                                          p.getRowDimension(), p.getRowDimension());        for (int i = 0; i < id.getRowDimension(); ++i) {            id.setEntry(i, i, Fraction.ONE);        }        TestUtils.assertEquals(id, ppT);        for (int i = 0; i < p.getRowDimension(); i++) {            int zeroCount  = 0;            int oneCount   = 0;            int otherCount = 0;            for (int j = 0; j < p.getColumnDimension(); j++) {                final Fraction e = p.getEntry(i, j);                if (e.equals(Fraction.ZERO)) {                    ++zeroCount;                } else if (e.equals(Fraction.ONE)) {                    ++oneCount;                } else {                    ++otherCount;                }            }            Assert.assertEquals(p.getColumnDimension() - 1, zeroCount);            Assert.assertEquals(1, oneCount);            Assert.assertEquals(0, otherCount);        }        for (int j = 0; j < p.getColumnDimension(); j++) {            int zeroCount  = 0;            int oneCount   = 0;            int otherCount = 0;            for (int i = 0; i < p.getRowDimension(); i++) {                final Fraction e = p.getEntry(i, j);                if (e.equals(Fraction.ZERO)) {                    ++zeroCount;                } else if (e.equals(Fraction.ONE)) {                    ++oneCount;                } else {                    ++otherCount;                }            }            Assert.assertEquals(p.getRowDimension() - 1, zeroCount);            Assert.assertEquals(1, oneCount);            Assert.assertEquals(0, otherCount);        }    }    /** test singular */    @Test    public void testSingular() {        FieldLUDecomposition<Fraction> lu =            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData));        Assert.assertTrue(lu.getSolver().isNonSingular());        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), singular));        Assert.assertFalse(lu.getSolver().isNonSingular());        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), bigSingular));        Assert.assertFalse(lu.getSolver().isNonSingular());    }    /** test matrices values */    @Test    public void testMatricesValues1() {       FieldLUDecomposition<Fraction> lu =            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData));        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {                { new Fraction(1), new Fraction(0), new Fraction(0) },                { new Fraction(2), new Fraction(1), new Fraction(0) },                { new Fraction(1), new Fraction(-2), new Fraction(1) }        });        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {                { new Fraction(1),  new Fraction(2), new Fraction(3) },                { new Fraction(0), new Fraction(1), new Fraction(-3) },                { new Fraction(0),  new Fraction(0), new Fraction(-1) }        });        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {                { new Fraction(1), new Fraction(0), new Fraction(0) },                { new Fraction(0), new Fraction(1), new Fraction(0) },                { new Fraction(0), new Fraction(0), new Fraction(1) }        });        int[] pivotRef = { 0, 1, 2 };        // check values against known references        FieldMatrix<Fraction> l = lu.getL();        TestUtils.assertEquals(lRef, l);        FieldMatrix<Fraction> u = lu.getU();        TestUtils.assertEquals(uRef, u);        FieldMatrix<Fraction> p = lu.getP();        TestUtils.assertEquals(pRef, p);        int[] pivot = lu.getPivot();        for (int i = 0; i < pivotRef.length; ++i) {            Assert.assertEquals(pivotRef[i], pivot[i]);        }        // check the same cached instance is returned the second time        Assert.assertTrue(l == lu.getL());        Assert.assertTrue(u == lu.getU());        Assert.assertTrue(p == lu.getP());    }    /** test matrices values */    @Test    public void testMatricesValues2() {       FieldLUDecomposition<Fraction> lu =            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), luData));        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {                { new Fraction(1), new Fraction(0), new Fraction(0) },                { new Fraction(3), new Fraction(1), new Fraction(0) },                { new Fraction(1), new Fraction(0), new Fraction(1) }        });        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {                { new Fraction(2), new Fraction(3), new Fraction(3)    },                { new Fraction(0), new Fraction(-3), new Fraction(-1)  },                { new Fraction(0), new Fraction(0), new Fraction(4) }        });        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {                { new Fraction(1), new Fraction(0), new Fraction(0) },                { new Fraction(0), new Fraction(0), new Fraction(1) },                { new Fraction(0), new Fraction(1), new Fraction(0) }        });        int[] pivotRef = { 0, 2, 1 };        // check values against known references        FieldMatrix<Fraction> l = lu.getL();        TestUtils.assertEquals(lRef, l);        FieldMatrix<Fraction> u = lu.getU();        TestUtils.assertEquals(uRef, u);        FieldMatrix<Fraction> p = lu.getP();        TestUtils.assertEquals(pRef, p);        int[] pivot = lu.getPivot();        for (int i = 0; i < pivotRef.length; ++i) {            Assert.assertEquals(pivotRef[i], pivot[i]);        }        // check the same cached instance is returned the second time        Assert.assertTrue(l == lu.getL());        Assert.assertTrue(u == lu.getU());        Assert.assertTrue(p == lu.getP());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;/** * This is an implementation of {@link UnmodifiableRealVectorAbstractTest} for * unmodifiable views of {@link ArrayRealVectorTest}. * * @version $Id$ */public class UnmodifiableArrayRealVectorTest    extends UnmodifiableRealVectorAbstractTest {    /**     * Returns a random vector of type {@link ArrayRealVector}.     *     * @return a new random {@link ArrayRealVector}.     */    @Override    public RealVector createVector() {        ArrayRealVector v = new ArrayRealVector(DIM);        for (int i = 0; i < DIM; i++) {            v.setEntry(i, RANDOM.nextDouble());        }        return v;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.io.Serializable;import java.util.Iterator;import java.util.Random;import org.apache.commons.math.TestUtils;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.analysis.function.Abs;import org.apache.commons.math.analysis.function.Acos;import org.apache.commons.math.analysis.function.Asin;import org.apache.commons.math.analysis.function.Atan;import org.apache.commons.math.analysis.function.Cbrt;import org.apache.commons.math.analysis.function.Ceil;import org.apache.commons.math.analysis.function.Cos;import org.apache.commons.math.analysis.function.Cosh;import org.apache.commons.math.analysis.function.Exp;import org.apache.commons.math.analysis.function.Expm1;import org.apache.commons.math.analysis.function.Floor;import org.apache.commons.math.analysis.function.Inverse;import org.apache.commons.math.analysis.function.Log;import org.apache.commons.math.analysis.function.Log10;import org.apache.commons.math.analysis.function.Log1p;import org.apache.commons.math.analysis.function.Power;import org.apache.commons.math.analysis.function.Rint;import org.apache.commons.math.analysis.function.Signum;import org.apache.commons.math.analysis.function.Sin;import org.apache.commons.math.analysis.function.Sinh;import org.apache.commons.math.analysis.function.Sqrt;import org.apache.commons.math.analysis.function.Tan;import org.apache.commons.math.analysis.function.Tanh;import org.apache.commons.math.analysis.function.Ulp;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.MathArithmeticException;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.exception.OutOfRangeException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link ArrayRealVector} class. * * @version $Id$ */public class ArrayRealVectorTest {    //    protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};    protected double[] vec1 = {1d, 2d, 3d};    protected double[] vec2 = {4d, 5d, 6d};    protected double[] vec3 = {7d, 8d, 9d};    protected double[] vec4 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};    protected double[] vec5 = { -4d, 0d, 3d, 1d, -6d, 3d};    protected double[] vec_null = {0d, 0d, 0d};    protected Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};    protected double[][] mat1 = {{1d, 2d, 3d}, {4d, 5d, 6d},{ 7d, 8d, 9d}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    // Testclass to test the RealVector interface    // only with enough content to support the test    public static class RealVectorTestImpl extends RealVector        implements Serializable {        /** Serializable version identifier. */        private static final long serialVersionUID = 4715341047369582908L;        /** Entries of the vector. */        protected double data[];        public RealVectorTestImpl(double[] d) {            data = d.clone();        }        private UnsupportedOperationException unsupported() {            return new UnsupportedOperationException("Not supported, unneeded for test purposes");        }        public RealVector map(UnivariateRealFunction function) {            throw unsupported();        }        public RealVector mapToSelf(UnivariateRealFunction function) {            throw unsupported();        }        public Iterator<Entry> iterator() {            return new Iterator<Entry>() {                int i = 0;                public boolean hasNext() {                    return i<data.length;                }                public Entry next() {                    final int j = i++;                    Entry e = new Entry() {                        @Override                        public double getValue() {                            return data[j];                        }                        @Override                        public void setValue(double newValue) {                            data[j] = newValue;                        }                    };                    e.setIndex(j);                    return e;                }                public void remove() { }            };        }        public Iterator<Entry> sparseIterator() {            return iterator();        }        public RealVector copy() {            throw unsupported();        }        public RealVector add(RealVector v) {            throw unsupported();        }        public RealVector add(double[] v) {            throw unsupported();        }        public RealVector subtract(RealVector v) {            throw unsupported();        }        public RealVector subtract(double[] v) {            throw unsupported();        }        public RealVector mapAdd(double d) {            throw unsupported();        }        public RealVector mapAddToSelf(double d) {            throw unsupported();        }        public RealVector mapSubtract(double d) {            throw unsupported();        }        public RealVector mapSubtractToSelf(double d) {            throw unsupported();        }        public RealVector mapMultiply(double d) {            double[] out = new double[data.length];            for (int i = 0; i < data.length; i++) {                out[i] = data[i] * d;            }            return new ArrayRealVector(out);        }        public RealVector mapMultiplyToSelf(double d) {            throw unsupported();        }        public RealVector mapDivide(double d) {            throw unsupported();        }        public RealVector mapDivideToSelf(double d) {            throw unsupported();        }        public RealVector ebeMultiply(RealVector v) {            throw unsupported();        }        public RealVector ebeMultiply(double[] v) {            throw unsupported();        }        public RealVector ebeDivide(RealVector v) {            throw unsupported();        }        public RealVector ebeDivide(double[] v) {            throw unsupported();        }        public double[] getData() {            return data.clone();        }        public double dotProduct(RealVector v) {            double dot = 0;            for (int i = 0; i < data.length; i++) {                dot += data[i] * v.getEntry(i);            }            return dot;        }        public double dotProduct(double[] v) {            double dot = 0;            for (int i = 0; i < data.length; i++) {                dot += data[i] * v[i];            }            return dot;        }        public double cosine(RealVector v) {            throw unsupported();        }        public double cosine(double[] v) {            throw unsupported();        }        public double getNorm() {            throw unsupported();        }        public double getL1Norm() {            throw unsupported();        }        public double getLInfNorm() {            throw unsupported();        }        public double getDistance(RealVector v) {            throw unsupported();        }        public double getDistance(double[] v) {            throw unsupported();        }        public double getL1Distance(RealVector v) {            throw unsupported();        }        public double getL1Distance(double[] v) {            throw unsupported();        }        public double getLInfDistance(RealVector v) {            throw unsupported();        }        public double getLInfDistance(double[] v) {            throw unsupported();        }        public RealVector unitVector() {            throw unsupported();        }        public void unitize() {            throw unsupported();        }        public RealVector projection(RealVector v) {            throw unsupported();        }        public RealVector projection(double[] v) {            throw unsupported();        }        public RealMatrix outerProduct(RealVector v) {            throw unsupported();        }        public RealMatrix outerProduct(double[] v) {            throw unsupported();        }        public double getEntry(int index) {            return data[index];        }        public int getDimension() {            return data.length;        }        public RealVector append(RealVector v) {            throw unsupported();        }        public RealVector append(double d) {            throw unsupported();        }        public RealVector append(double[] a) {            throw unsupported();        }        public RealVector getSubVector(int index, int n) {            throw unsupported();        }        public void setEntry(int index, double value) {            throw unsupported();        }        public void setSubVector(int index, RealVector v) {            throw unsupported();        }        public void setSubVector(int index, double[] v) {            throw unsupported();        }        public void set(double value) {            throw unsupported();        }        public double[] toArray() {            throw unsupported();        }        public boolean isNaN() {            throw unsupported();        }        public boolean isInfinite() {            throw unsupported();        }        public RealVector combine(double a, double b, double[] y) {            throw unsupported();        }        public RealVector combine(double a, double b, RealVector y) {            throw unsupported();        }        public RealVector combineToSelf(double a, double b, double[] y) {            throw unsupported();        }        public RealVector combineToSelf(double a, double b, RealVector y) {            throw unsupported();        }    }    @Test    public void testConstructors() {        ArrayRealVector v0 = new ArrayRealVector();        Assert.assertEquals("testData len", 0, v0.getDimension());        ArrayRealVector v1 = new ArrayRealVector(7);        Assert.assertEquals("testData len", 7, v1.getDimension());        Assert.assertEquals("testData is 0.0 ", 0.0, v1.getEntry(6), 0);        ArrayRealVector v2 = new ArrayRealVector(5, 1.23);        Assert.assertEquals("testData len", 5, v2.getDimension());        Assert.assertEquals("testData is 1.23 ", 1.23, v2.getEntry(4), 0);        ArrayRealVector v3 = new ArrayRealVector(vec1);        Assert.assertEquals("testData len", 3, v3.getDimension());        Assert.assertEquals("testData is 2.0 ", 2.0, v3.getEntry(1), 0);        ArrayRealVector v3_bis = new ArrayRealVector(vec1, true);        Assert.assertEquals("testData len", 3, v3_bis.getDimension());        Assert.assertEquals("testData is 2.0 ", 2.0, v3_bis.getEntry(1), 0);        Assert.assertNotSame(v3_bis.getDataRef(), vec1);        Assert.assertNotSame(v3_bis.getData(), vec1);        ArrayRealVector v3_ter = new ArrayRealVector(vec1, false);        Assert.assertEquals("testData len", 3, v3_ter.getDimension());        Assert.assertEquals("testData is 2.0 ", 2.0, v3_ter.getEntry(1), 0);        Assert.assertSame(v3_ter.getDataRef(), vec1);        Assert.assertNotSame(v3_ter.getData(), vec1);        ArrayRealVector v4 = new ArrayRealVector(vec4, 3, 2);        Assert.assertEquals("testData len", 2, v4.getDimension());        Assert.assertEquals("testData is 4.0 ", 4.0, v4.getEntry(0), 0);        try {            new ArrayRealVector(vec4, 8, 3);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected behavior        }        RealVector v5_i = new ArrayRealVector(dvec1);        Assert.assertEquals("testData len", 9, v5_i.getDimension());        Assert.assertEquals("testData is 9.0 ", 9.0, v5_i.getEntry(8), 0);        ArrayRealVector v5 = new ArrayRealVector(dvec1);        Assert.assertEquals("testData len", 9, v5.getDimension());        Assert.assertEquals("testData is 9.0 ", 9.0, v5.getEntry(8), 0);        ArrayRealVector v6 = new ArrayRealVector(dvec1, 3, 2);        Assert.assertEquals("testData len", 2, v6.getDimension());        Assert.assertEquals("testData is 4.0 ", 4.0, v6.getEntry(0), 0);        try {            new ArrayRealVector(dvec1, 8, 3);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected behavior        }        ArrayRealVector v7 = new ArrayRealVector(v1);        Assert.assertEquals("testData len", 7, v7.getDimension());        Assert.assertEquals("testData is 0.0 ", 0.0, v7.getEntry(6), 0);        RealVectorTestImpl v7_i = new RealVectorTestImpl(vec1);        ArrayRealVector v7_2 = new ArrayRealVector(v7_i);        Assert.assertEquals("testData len", 3, v7_2.getDimension());        Assert.assertEquals("testData is 0.0 ", 2.0d, v7_2.getEntry(1), 0);        ArrayRealVector v8 = new ArrayRealVector(v1, true);        Assert.assertEquals("testData len", 7, v8.getDimension());        Assert.assertEquals("testData is 0.0 ", 0.0, v8.getEntry(6), 0);        Assert.assertNotSame("testData not same object ", v1.data, v8.data);        ArrayRealVector v8_2 = new ArrayRealVector(v1, false);        Assert.assertEquals("testData len", 7, v8_2.getDimension());        Assert.assertEquals("testData is 0.0 ", 0.0, v8_2.getEntry(6), 0);        Assert.assertEquals("testData same object ", v1.data, v8_2.data);        ArrayRealVector v9 = new ArrayRealVector(v1, v3);        Assert.assertEquals("testData len", 10, v9.getDimension());        Assert.assertEquals("testData is 1.0 ", 1.0, v9.getEntry(7), 0);        ArrayRealVector v10 = new ArrayRealVector(v2, new RealVectorTestImpl(vec3));        Assert.assertEquals("testData len", 8, v10.getDimension());        Assert.assertEquals("testData is 1.23 ", 1.23, v10.getEntry(4), 0);        Assert.assertEquals("testData is 7.0 ", 7.0, v10.getEntry(5), 0);        ArrayRealVector v11 = new ArrayRealVector(new RealVectorTestImpl(vec3), v2);        Assert.assertEquals("testData len", 8, v11.getDimension());        Assert.assertEquals("testData is 9.0 ", 9.0, v11.getEntry(2), 0);        Assert.assertEquals("testData is 1.23 ", 1.23, v11.getEntry(3), 0);        ArrayRealVector v12 = new ArrayRealVector(v2, vec3);        Assert.assertEquals("testData len", 8, v12.getDimension());        Assert.assertEquals("testData is 1.23 ", 1.23, v12.getEntry(4), 0);        Assert.assertEquals("testData is 7.0 ", 7.0, v12.getEntry(5), 0);        ArrayRealVector v13 = new ArrayRealVector(vec3, v2);        Assert.assertEquals("testData len", 8, v13.getDimension());        Assert.assertEquals("testData is 9.0 ", 9.0, v13.getEntry(2), 0);        Assert.assertEquals("testData is 1.23 ", 1.23, v13.getEntry(3), 0);        ArrayRealVector v14 = new ArrayRealVector(vec3, vec4);        Assert.assertEquals("testData len", 12, v14.getDimension());        Assert.assertEquals("testData is 9.0 ", 9.0, v14.getEntry(2), 0);        Assert.assertEquals("testData is 1.0 ", 1.0, v14.getEntry(3), 0);    }    @Test    public void testDataInOut() {        ArrayRealVector v1 = new ArrayRealVector(vec1);        ArrayRealVector v2 = new ArrayRealVector(vec2);        ArrayRealVector v4 = new ArrayRealVector(vec4);        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);        RealVector v_append_1 = v1.append(v2);        Assert.assertEquals("testData len", 6, v_append_1.getDimension());        Assert.assertEquals("testData is 4.0 ", 4.0, v_append_1.getEntry(3), 0);        RealVector v_append_2 = v1.append(2.0);        Assert.assertEquals("testData len", 4, v_append_2.getDimension());        Assert.assertEquals("testData is 2.0 ", 2.0, v_append_2.getEntry(3), 0);        RealVector v_append_4 = v1.append(v2_t);        Assert.assertEquals("testData len", 6, v_append_4.getDimension());        Assert.assertEquals("testData is 4.0 ", 4.0, v_append_4.getEntry(3), 0);        RealVector v_append_5 = v1.append((RealVector) v2);        Assert.assertEquals("testData len", 6, v_append_5.getDimension());        Assert.assertEquals("testData is 4.0 ", 4.0, v_append_5.getEntry(3), 0);        RealVector v_copy = v1.copy();        Assert.assertEquals("testData len", 3, v_copy.getDimension());        Assert.assertNotSame("testData not same object ", v1.data, v_copy.getData());        double[] a_double = v1.toArray();        Assert.assertEquals("testData len", 3, a_double.length);        Assert.assertNotSame("testData not same object ", v1.data, a_double);//      ArrayRealVector vout4 = (ArrayRealVector) v1.clone();//      Assert.assertEquals("testData len", 3, vout4.getDimension());//      Assert.assertEquals("testData not same object ", v1.data, vout4.data);        RealVector vout5 = v4.getSubVector(3, 3);        Assert.assertEquals("testData len", 3, vout5.getDimension());        Assert.assertEquals("testData is 4.0 ", 5.0, vout5.getEntry(1), 0);        try {            v4.getSubVector(3, 7);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException ex) {            // expected behavior        }        ArrayRealVector v_set1 = v1.copy();        v_set1.setEntry(1, 11.0);        Assert.assertEquals("testData is 11.0 ", 11.0, v_set1.getEntry(1), 0);        try {            v_set1.setEntry(3, 11.0);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException ex) {            // expected behavior        }        ArrayRealVector v_set3 = v1.copy();        v_set3.set(13.0);        Assert.assertEquals("testData is 13.0 ", 13.0, v_set3.getEntry(2), 0);        try {            v_set3.getEntry(23);            Assert.fail("ArrayIndexOutOfBoundsException expected");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected behavior        }        ArrayRealVector v_set4 = v4.copy();        v_set4.setSubVector(3, v2_t);        Assert.assertEquals("testData is 1.0 ", 4.0, v_set4.getEntry(3), 0);        Assert.assertEquals("testData is 7.0 ", 7.0, v_set4.getEntry(6), 0);        try {            v_set4.setSubVector(7, v2_t);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException ex) {            // expected behavior        }        ArrayRealVector vout10 = v1.copy();        ArrayRealVector vout10_2 = v1.copy();        Assert.assertEquals(vout10, vout10_2);        vout10_2.setEntry(0, 1.1);        Assert.assertNotSame(vout10, vout10_2);    }    @Test    public void testMapFunctions() {        ArrayRealVector v1 = new ArrayRealVector(vec1);        //octave =  v1 .+ 2.0        RealVector v_mapAdd = v1.mapAdd(2.0d);        double[] result_mapAdd = {3d, 4d, 5d};        assertClose("compare vectors" ,result_mapAdd,v_mapAdd.getData(),normTolerance);        //octave =  v1 .+ 2.0        RealVector v_mapAddToSelf = v1.copy();        v_mapAddToSelf.mapAddToSelf(2.0d);        double[] result_mapAddToSelf = {3d, 4d, 5d};        assertClose("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData(),normTolerance);        //octave =  v1 .- 2.0        RealVector v_mapSubtract = v1.mapSubtract(2.0d);        double[] result_mapSubtract = {-1d, 0d, 1d};        assertClose("compare vectors" ,result_mapSubtract,v_mapSubtract.getData(),normTolerance);        //octave =  v1 .- 2.0        RealVector v_mapSubtractToSelf = v1.copy();        v_mapSubtractToSelf.mapSubtractToSelf(2.0d);        double[] result_mapSubtractToSelf = {-1d, 0d, 1d};        assertClose("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData(),normTolerance);        //octave =  v1 .* 2.0        RealVector v_mapMultiply = v1.mapMultiply(2.0d);        double[] result_mapMultiply = {2d, 4d, 6d};        assertClose("compare vectors" ,result_mapMultiply,v_mapMultiply.getData(),normTolerance);        //octave =  v1 .* 2.0        RealVector v_mapMultiplyToSelf = v1.copy();        v_mapMultiplyToSelf.mapMultiplyToSelf(2.0d);        double[] result_mapMultiplyToSelf = {2d, 4d, 6d};        assertClose("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData(),normTolerance);        //octave =  v1 ./ 2.0        RealVector v_mapDivide = v1.mapDivide(2.0d);        double[] result_mapDivide = {.5d, 1d, 1.5d};        assertClose("compare vectors" ,result_mapDivide,v_mapDivide.getData(),normTolerance);        //octave =  v1 ./ 2.0        RealVector v_mapDivideToSelf = v1.copy();        v_mapDivideToSelf.mapDivideToSelf(2.0d);        double[] result_mapDivideToSelf = {.5d, 1d, 1.5d};        assertClose("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData(),normTolerance);        //octave =  v1 .^ 2.0        RealVector v_mapPow = v1.map(new Power(2));        double[] result_mapPow = {1d, 4d, 9d};        assertClose("compare vectors" ,result_mapPow,v_mapPow.getData(),normTolerance);        //octave =  v1 .^ 2.0        RealVector v_mapPowToSelf = v1.copy();        v_mapPowToSelf.mapToSelf(new Power(2));        double[] result_mapPowToSelf = {1d, 4d, 9d};        assertClose("compare vectors" ,result_mapPowToSelf,v_mapPowToSelf.getData(),normTolerance);        //octave =  exp(v1)        RealVector v_mapExp = v1.map(new Exp());        double[] result_mapExp = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};        assertClose("compare vectors" ,result_mapExp,v_mapExp.getData(),normTolerance);        //octave =  exp(v1)        RealVector v_mapExpToSelf = v1.copy();        v_mapExpToSelf.mapToSelf(new Exp());        double[] result_mapExpToSelf = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};        assertClose("compare vectors" ,result_mapExpToSelf,v_mapExpToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapExpm1 = v1.map(new Expm1());        double[] result_mapExpm1 = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};        assertClose("compare vectors" ,result_mapExpm1,v_mapExpm1.getData(),normTolerance);        //octave =  ???        RealVector v_mapExpm1ToSelf = v1.copy();        v_mapExpm1ToSelf.mapToSelf(new Expm1());        double[] result_mapExpm1ToSelf = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};        assertClose("compare vectors" ,result_mapExpm1ToSelf,v_mapExpm1ToSelf.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLog = v1.map(new Log());        double[] result_mapLog = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};        assertClose("compare vectors" ,result_mapLog,v_mapLog.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLogToSelf = v1.copy();        v_mapLogToSelf.mapToSelf(new Log());        double[] result_mapLogToSelf = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};        assertClose("compare vectors" ,result_mapLogToSelf,v_mapLogToSelf.getData(),normTolerance);        //octave =  log10(v1)        RealVector v_mapLog10 = v1.map(new Log10());        double[] result_mapLog10 = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};        assertClose("compare vectors" ,result_mapLog10,v_mapLog10.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLog10ToSelf = v1.copy();        v_mapLog10ToSelf.mapToSelf(new Log10());        double[] result_mapLog10ToSelf = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};        assertClose("compare vectors" ,result_mapLog10ToSelf,v_mapLog10ToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapLog1p = v1.map(new Log1p());        double[] result_mapLog1p = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};        assertClose("compare vectors" ,result_mapLog1p,v_mapLog1p.getData(),normTolerance);        //octave =  ???        RealVector v_mapLog1pToSelf = v1.copy();        v_mapLog1pToSelf.mapToSelf(new Log1p());        double[] result_mapLog1pToSelf = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};        assertClose("compare vectors" ,result_mapLog1pToSelf,v_mapLog1pToSelf.getData(),normTolerance);        //octave =  cosh(v1)        RealVector v_mapCosh = v1.map(new Cosh());        double[] result_mapCosh = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};        assertClose("compare vectors" ,result_mapCosh,v_mapCosh.getData(),normTolerance);        //octave =  cosh(v1)        RealVector v_mapCoshToSelf = v1.copy();        v_mapCoshToSelf.mapToSelf(new Cosh());        double[] result_mapCoshToSelf = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};        assertClose("compare vectors" ,result_mapCoshToSelf,v_mapCoshToSelf.getData(),normTolerance);        //octave =  sinh(v1)        RealVector v_mapSinh = v1.map(new Sinh());        double[] result_mapSinh = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};        assertClose("compare vectors" ,result_mapSinh,v_mapSinh.getData(),normTolerance);        //octave =  sinh(v1)        RealVector v_mapSinhToSelf = v1.copy();        v_mapSinhToSelf.mapToSelf(new Sinh());        double[] result_mapSinhToSelf = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};        assertClose("compare vectors" ,result_mapSinhToSelf,v_mapSinhToSelf.getData(),normTolerance);        //octave =  tanh(v1)        RealVector v_mapTanh = v1.map(new Tanh());        double[] result_mapTanh = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};        assertClose("compare vectors" ,result_mapTanh,v_mapTanh.getData(),normTolerance);        //octave =  tanh(v1)        RealVector v_mapTanhToSelf = v1.copy();        v_mapTanhToSelf.mapToSelf(new Tanh());        double[] result_mapTanhToSelf = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};        assertClose("compare vectors" ,result_mapTanhToSelf,v_mapTanhToSelf.getData(),normTolerance);        //octave =  cos(v1)        RealVector v_mapCos = v1.map(new Cos());        double[] result_mapCos = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};        assertClose("compare vectors" ,result_mapCos,v_mapCos.getData(),normTolerance);        //octave =  cos(v1)        RealVector v_mapCosToSelf = v1.copy();        v_mapCosToSelf.mapToSelf(new Cos());        double[] result_mapCosToSelf = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};        assertClose("compare vectors" ,result_mapCosToSelf,v_mapCosToSelf.getData(),normTolerance);        //octave =  sin(v1)        RealVector v_mapSin = v1.map(new Sin());        double[] result_mapSin = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};        assertClose("compare vectors" ,result_mapSin,v_mapSin.getData(),normTolerance);        //octave =  sin(v1)        RealVector v_mapSinToSelf = v1.copy();        v_mapSinToSelf.mapToSelf(new Sin());        double[] result_mapSinToSelf = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};        assertClose("compare vectors" ,result_mapSinToSelf,v_mapSinToSelf.getData(),normTolerance);        //octave =  tan(v1)        RealVector v_mapTan = v1.map(new Tan());        double[] result_mapTan = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};        assertClose("compare vectors" ,result_mapTan,v_mapTan.getData(),normTolerance);        //octave =  tan(v1)        RealVector v_mapTanToSelf = v1.copy();        v_mapTanToSelf.mapToSelf(new Tan());        double[] result_mapTanToSelf = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};        assertClose("compare vectors" ,result_mapTanToSelf,v_mapTanToSelf.getData(),normTolerance);        double[] vat_a = {0d, 0.5d, 1.0d};        ArrayRealVector vat = new ArrayRealVector(vat_a);        //octave =  acos(vat)        RealVector v_mapAcos = vat.map(new Acos());        double[] result_mapAcos = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};        assertClose("compare vectors" ,result_mapAcos,v_mapAcos.getData(),normTolerance);        //octave =  acos(vat)        RealVector v_mapAcosToSelf = vat.copy();        v_mapAcosToSelf.mapToSelf(new Acos());        double[] result_mapAcosToSelf = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};        assertClose("compare vectors" ,result_mapAcosToSelf,v_mapAcosToSelf.getData(),normTolerance);        //octave =  asin(vat)        RealVector v_mapAsin = vat.map(new Asin());        double[] result_mapAsin = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};        assertClose("compare vectors" ,result_mapAsin,v_mapAsin.getData(),normTolerance);        //octave =  asin(vat)        RealVector v_mapAsinToSelf = vat.copy();        v_mapAsinToSelf.mapToSelf(new Asin());        double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};        assertClose("compare vectors" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);        //octave =  atan(vat)        RealVector v_mapAtan = vat.map(new Atan());        double[] result_mapAtan = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};        assertClose("compare vectors" ,result_mapAtan,v_mapAtan.getData(),normTolerance);        //octave =  atan(vat)        RealVector v_mapAtanToSelf = vat.copy();        v_mapAtanToSelf.mapToSelf(new Atan());        double[] result_mapAtanToSelf = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};        assertClose("compare vectors" ,result_mapAtanToSelf,v_mapAtanToSelf.getData(),normTolerance);        //octave =  v1 .^-1        RealVector v_mapInv = v1.map(new Inverse());        double[] result_mapInv = {1d,0.5d,3.333333333333333e-01d};        assertClose("compare vectors" ,result_mapInv,v_mapInv.getData(),normTolerance);        //octave =  v1 .^-1        RealVector v_mapInvToSelf = v1.copy();        v_mapInvToSelf.mapToSelf(new Inverse());        double[] result_mapInvToSelf = {1d,0.5d,3.333333333333333e-01d};        assertClose("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData(),normTolerance);        double[] abs_a = {-1.0d, 0.0d, 1.0d};        ArrayRealVector abs_v = new ArrayRealVector(abs_a);        //octave =  abs(abs_v)        RealVector v_mapAbs = abs_v.map(new Abs());        double[] result_mapAbs = {1d,0d,1d};        assertClose("compare vectors" ,result_mapAbs,v_mapAbs.getData(),normTolerance);        //octave = abs(abs_v)        RealVector v_mapAbsToSelf = abs_v.copy();        v_mapAbsToSelf.mapToSelf(new Abs());        double[] result_mapAbsToSelf = {1d,0d,1d};        assertClose("compare vectors" ,result_mapAbsToSelf,v_mapAbsToSelf.getData(),normTolerance);        //octave =   sqrt(v1)        RealVector v_mapSqrt = v1.map(new Sqrt());        double[] result_mapSqrt = {1d,1.414213562373095e+00d,1.732050807568877e+00d};        assertClose("compare vectors" ,result_mapSqrt,v_mapSqrt.getData(),normTolerance);        //octave =  sqrt(v1)        RealVector v_mapSqrtToSelf = v1.copy();        v_mapSqrtToSelf.mapToSelf(new Sqrt());        double[] result_mapSqrtToSelf = {1d,1.414213562373095e+00d,1.732050807568877e+00d};        assertClose("compare vectors" ,result_mapSqrtToSelf,v_mapSqrtToSelf.getData(),normTolerance);        double[] cbrt_a = {-2.0d, 0.0d, 2.0d};        ArrayRealVector cbrt_v = new ArrayRealVector(cbrt_a);        //octave =  ???        RealVector v_mapCbrt = cbrt_v.map(new Cbrt());        double[] result_mapCbrt = {-1.2599210498948732d,0d,1.2599210498948732d};        assertClose("compare vectors" ,result_mapCbrt,v_mapCbrt.getData(),normTolerance);        //octave = ???        RealVector v_mapCbrtToSelf = cbrt_v.copy();        v_mapCbrtToSelf.mapToSelf(new Cbrt());        double[] result_mapCbrtToSelf =  {-1.2599210498948732d,0d,1.2599210498948732d};        assertClose("compare vectors" ,result_mapCbrtToSelf,v_mapCbrtToSelf.getData(),normTolerance);        double[] ceil_a = {-1.1d, 0.9d, 1.1d};        ArrayRealVector ceil_v = new ArrayRealVector(ceil_a);        //octave =  ceil(ceil_v)        RealVector v_mapCeil = ceil_v.map(new Ceil());        double[] result_mapCeil = {-1d,1d,2d};        assertClose("compare vectors" ,result_mapCeil,v_mapCeil.getData(),normTolerance);        //octave = ceil(ceil_v)        RealVector v_mapCeilToSelf = ceil_v.copy();        v_mapCeilToSelf.mapToSelf(new Ceil());        double[] result_mapCeilToSelf =  {-1d,1d,2d};        assertClose("compare vectors" ,result_mapCeilToSelf,v_mapCeilToSelf.getData(),normTolerance);        //octave =  floor(ceil_v)        RealVector v_mapFloor = ceil_v.map(new Floor());        double[] result_mapFloor = {-2d,0d,1d};        assertClose("compare vectors" ,result_mapFloor,v_mapFloor.getData(),normTolerance);        //octave = floor(ceil_v)        RealVector v_mapFloorToSelf = ceil_v.copy();        v_mapFloorToSelf.mapToSelf(new Floor());        double[] result_mapFloorToSelf =  {-2d,0d,1d};        assertClose("compare vectors" ,result_mapFloorToSelf,v_mapFloorToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapRint = ceil_v.map(new Rint());        double[] result_mapRint = {-1d,1d,1d};        assertClose("compare vectors" ,result_mapRint,v_mapRint.getData(),normTolerance);        //octave = ???        RealVector v_mapRintToSelf = ceil_v.copy();        v_mapRintToSelf.mapToSelf(new Rint());        double[] result_mapRintToSelf =  {-1d,1d,1d};        assertClose("compare vectors" ,result_mapRintToSelf,v_mapRintToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapSignum = ceil_v.map(new Signum());        double[] result_mapSignum = {-1d,1d,1d};        assertClose("compare vectors" ,result_mapSignum,v_mapSignum.getData(),normTolerance);        //octave = ???        RealVector v_mapSignumToSelf = ceil_v.copy();        v_mapSignumToSelf.mapToSelf(new Signum());        double[] result_mapSignumToSelf =  {-1d,1d,1d};        assertClose("compare vectors" ,result_mapSignumToSelf,v_mapSignumToSelf.getData(),normTolerance);        // Is with the used resolutions of limited value as test        //octave =  ???        RealVector v_mapUlp = ceil_v.map(new Ulp());        double[] result_mapUlp = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};        assertClose("compare vectors" ,result_mapUlp,v_mapUlp.getData(),normTolerance);        //octave = ???        RealVector v_mapUlpToSelf = ceil_v.copy();        v_mapUlpToSelf.mapToSelf(new Ulp());        double[] result_mapUlpToSelf = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};        assertClose("compare vectors" ,result_mapUlpToSelf,v_mapUlpToSelf.getData(),normTolerance);    }    @Test    public void testBasicFunctions() {        ArrayRealVector v1 = new ArrayRealVector(vec1);        ArrayRealVector v2 = new ArrayRealVector(vec2);        ArrayRealVector v5 = new ArrayRealVector(vec5);        ArrayRealVector v_null = new ArrayRealVector(vec_null);        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);        // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307        double d_getNorm = v5.getNorm();        Assert.assertEquals("compare values  ", 8.4261497731763586307, d_getNorm, normTolerance);        // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17        double d_getL1Norm = v5.getL1Norm();        Assert.assertEquals("compare values  ", 17.0, d_getL1Norm, normTolerance);        // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6        double d_getLInfNorm = v5.getLInfNorm();        Assert.assertEquals("compare values  ", 6.0, d_getLInfNorm, normTolerance);        //octave =  sqrt(sumsq(v1-v2))        double dist = v1.getDistance(v2);        Assert.assertEquals("compare values  ",v1.subtract(v2).getNorm(), dist, normTolerance);        //octave =  sqrt(sumsq(v1-v2))        double dist_2 = v1.getDistance(v2_t);        Assert.assertEquals("compare values  ", v1.subtract(v2).getNorm(),dist_2, normTolerance);        //octave =  sqrt(sumsq(v1-v2))        double dist_3 = v1.getDistance((RealVector) v2);        Assert.assertEquals("compare values  ", v1.subtract(v2).getNorm(),dist_3, normTolerance);        //octave =  ???        double d_getL1Distance = v1. getL1Distance(v2);        Assert.assertEquals("compare values  ", 9d, d_getL1Distance, normTolerance);        double d_getL1Distance_2 = v1.getL1Distance(v2_t);        Assert.assertEquals("compare values  ", 9d, d_getL1Distance_2, normTolerance);        double d_getL1Distance_3 = v1.getL1Distance((RealVector) v2);        Assert.assertEquals("compare values  ", 9d, d_getL1Distance_3, normTolerance);        //octave =  ???        double d_getLInfDistance = v1.getLInfDistance(v2);        Assert.assertEquals("compare values  ", 3d, d_getLInfDistance, normTolerance);        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);        Assert.assertEquals("compare values  ", 3d, d_getLInfDistance_2, normTolerance);        double d_getLInfDistance_3 = v1. getLInfDistance((RealVector) v2);        Assert.assertEquals("compare values  ", 3d, d_getLInfDistance_3, normTolerance);        //octave =  v1 + v2        ArrayRealVector v_add = v1.add(v2);        double[] result_add = {5d, 7d, 9d};        assertClose("compare vect" ,v_add.getData(), result_add, normTolerance);        RealVectorTestImpl vt2 = new RealVectorTestImpl(vec2);        RealVector v_add_i = v1.add(vt2);        double[] result_add_i = {5d, 7d, 9d};        assertClose("compare vect" ,v_add_i.getData(),result_add_i,normTolerance);        //octave =  v1 - v2        ArrayRealVector v_subtract = v1.subtract(v2);        double[] result_subtract = {-3d, -3d, -3d};        assertClose("compare vect" ,v_subtract.getData(),result_subtract,normTolerance);        RealVector v_subtract_i = v1.subtract(vt2);        double[] result_subtract_i = {-3d, -3d, -3d};        assertClose("compare vect" ,v_subtract_i.getData(),result_subtract_i,normTolerance);        // octave v1 .* v2        ArrayRealVector  v_ebeMultiply = v1.ebeMultiply(v2);        double[] result_ebeMultiply = {4d, 10d, 18d};        assertClose("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);        double[] result_ebeMultiply_2 = {4d, 10d, 18d};        assertClose("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);        RealVector  v_ebeMultiply_3 = v1.ebeMultiply((RealVector) v2);        double[] result_ebeMultiply_3 = {4d, 10d, 18d};        assertClose("compare vect" ,v_ebeMultiply_3.getData(),result_ebeMultiply_3,normTolerance);        // octave v1 ./ v2        ArrayRealVector  v_ebeDivide = v1.ebeDivide(v2);        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};        assertClose("compare vect" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};        assertClose("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);        RealVector  v_ebeDivide_3 = v1.ebeDivide((RealVector) v2);        double[] result_ebeDivide_3 = {0.25d, 0.4d, 0.5d};        assertClose("compare vect" ,v_ebeDivide_3.getData(),result_ebeDivide_3,normTolerance);        // octave  dot(v1,v2)        double dot =  v1.dotProduct(v2);        Assert.assertEquals("compare val ",32d, dot, normTolerance);        // octave  dot(v1,v2_t)        double dot_2 =  v1.dotProduct(v2_t);        Assert.assertEquals("compare val ",32d, dot_2, normTolerance);        RealMatrix m_outerProduct = v1.outerProduct(v2);        Assert.assertEquals("compare val ",4d, m_outerProduct.getEntry(0,0), normTolerance);        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);        Assert.assertEquals("compare val ",4d, m_outerProduct_2.getEntry(0,0), normTolerance);        RealMatrix m_outerProduct_3 = v1.outerProduct((RealVector) v2);        Assert.assertEquals("compare val ",4d, m_outerProduct_3.getEntry(0,0), normTolerance);        RealVector v_unitVector = v1.unitVector();        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());        assertClose("compare vect" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);        try {            v_null.unitVector();            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException ex) {            // expected behavior        }        ArrayRealVector v_unitize = v1.copy();        v_unitize.unitize();        assertClose("compare vect" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);        try {            v_null.unitize();            Assert.fail("Expecting MathArithmeticException");        } catch (MathArithmeticException ex) {            // expected behavior        }        RealVector v_projection = v1.projection(v2);        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};        assertClose("compare vect", v_projection.getData(), result_projection, normTolerance);        RealVector v_projection_2 = v1.projection(v2_t);        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};        assertClose("compare vect", v_projection_2.getData(), result_projection_2, normTolerance);    }    @Test    public void testMisc() {        ArrayRealVector v1 = new ArrayRealVector(vec1);        ArrayRealVector v4 = new ArrayRealVector(vec4);        RealVector v4_2 = new ArrayRealVector(vec4);        String out1 = v1.toString();        Assert.assertTrue("some output ",  out1.length()!=0);        /*         double[] dout1 = v1.copyOut();        Assert.assertEquals("testData len", 3, dout1.length);        Assert.assertNotSame("testData not same object ", v1.data, dout1);         */        try {            v1.checkVectorDimensions(2);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected behavior        }       try {            v1.checkVectorDimensions(v4);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected behavior        }        try {            v1.checkVectorDimensions(v4_2);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected behavior        }    }    @Test    public void testPredicates() {        ArrayRealVector v = new ArrayRealVector(new double[] { 0, 1, 2 });        Assert.assertFalse(v.isNaN());        v.setEntry(1, Double.NaN);        Assert.assertTrue(v.isNaN());        Assert.assertFalse(v.isInfinite());        v.setEntry(0, Double.POSITIVE_INFINITY);        Assert.assertFalse(v.isInfinite());        v.setEntry(1, 1);        Assert.assertTrue(v.isInfinite());        v.setEntry(0, 1);        Assert.assertFalse(v.isInfinite());        v.setEntry(0, 0);        Assert.assertEquals(v, new ArrayRealVector(new double[] { 0, 1, 2 }));        Assert.assertNotSame(v, new ArrayRealVector(new double[] { 0, 1, 2 + FastMath.ulp(2)}));        Assert.assertNotSame(v, new ArrayRealVector(new double[] { 0, 1, 2, 3 }));        Assert.assertEquals(new ArrayRealVector(new double[] { Double.NaN, 1, 2 }).hashCode(),                     new ArrayRealVector(new double[] { 0, Double.NaN, 2 }).hashCode());        Assert.assertTrue(new ArrayRealVector(new double[] { Double.NaN, 1, 2 }).hashCode() !=                   new ArrayRealVector(new double[] { 0, 1, 2 }).hashCode());        Assert.assertTrue(v.equals(v));        Assert.assertTrue(v.equals(v.copy()));        Assert.assertFalse(v.equals(null));        Assert.assertFalse(v.equals(v.getDataRef()));        Assert.assertFalse(v.equals(v.getSubVector(0, v.getDimension() - 1)));        Assert.assertTrue(v.equals(v.getSubVector(0, v.getDimension())));    }    @Test    public void testSerial()  {        ArrayRealVector v = new ArrayRealVector(new double[] { 0, 1, 2 });        Assert.assertEquals(v,TestUtils.serializeAndRecover(v));    }    @Test    public void testZeroVectors() {        Assert.assertEquals(0, new ArrayRealVector(new double[0]).getDimension());        Assert.assertEquals(0, new ArrayRealVector(new double[0], true).getDimension());        Assert.assertEquals(0, new ArrayRealVector(new double[0], false).getDimension());    }    @Test    public void testMinMax()  {        ArrayRealVector v1 = new ArrayRealVector(new double[] { 0, -6, 4, 12, 7 });        Assert.assertEquals(1,  v1.getMinIndex());        Assert.assertEquals(-6, v1.getMinValue(), 1.0e-12);        Assert.assertEquals(3,  v1.getMaxIndex());        Assert.assertEquals(12, v1.getMaxValue(), 1.0e-12);        ArrayRealVector v2 = new ArrayRealVector(new double[] { Double.NaN, 3, Double.NaN, -2 });        Assert.assertEquals(3,  v2.getMinIndex());        Assert.assertEquals(-2, v2.getMinValue(), 1.0e-12);        Assert.assertEquals(1,  v2.getMaxIndex());        Assert.assertEquals(3, v2.getMaxValue(), 1.0e-12);        ArrayRealVector v3 = new ArrayRealVector(new double[] { Double.NaN, Double.NaN });        Assert.assertEquals(-1,  v3.getMinIndex());        Assert.assertTrue(Double.isNaN(v3.getMinValue()));        Assert.assertEquals(-1,  v3.getMaxIndex());        Assert.assertTrue(Double.isNaN(v3.getMaxValue()));        ArrayRealVector v4 = new ArrayRealVector(new double[0]);        Assert.assertEquals(-1,  v4.getMinIndex());        Assert.assertTrue(Double.isNaN(v4.getMinValue()));        Assert.assertEquals(-1,  v4.getMaxIndex());        Assert.assertTrue(Double.isNaN(v4.getMaxValue()));    }    @Test    public void testCosine() {        final ArrayRealVector v = new ArrayRealVector(new double[] {1, 0, 0});        double[] wData = new double[] {1, 1, 0};        RealVector w = new ArrayRealVector(wData);        Assert.assertEquals(FastMath.sqrt(2) / 2, v.cosine(w), normTolerance);        wData = new double[] {1, 0, 0};        w = new ArrayRealVector(wData);        Assert.assertEquals(1, v.cosine(w), normTolerance);        wData = new double[] {0, 1, 0};        w = new ArrayRealVector(wData);        Assert.assertEquals(0, v.cosine(w), 0);        wData = new double[] {-1, 0, 0};        w = new ArrayRealVector(wData);        Assert.assertEquals(-1, v.cosine(w), normTolerance);    }    @Test(expected=MathArithmeticException.class)    public void testCosinePrecondition1() {        final ArrayRealVector v = new ArrayRealVector(new double[] {0, 0, 0});        final ArrayRealVector w = new ArrayRealVector(new double[] {1, 0, 0});        v.cosine(w);    }    @Test(expected=MathArithmeticException.class)    public void testCosinePrecondition2() {        final ArrayRealVector v = new ArrayRealVector(new double[] {0, 0, 0});        final ArrayRealVector w = new ArrayRealVector(new double[] {1, 0, 0});        w.cosine(v);    }    @Test(expected=DimensionMismatchException.class)    public void testCosinePrecondition3() {        final ArrayRealVector v = new ArrayRealVector(new double[] {1, 2, 3});        final ArrayRealVector w = new ArrayRealVector(new double[] {1, 2, 3, 4});        v.cosine(w);    }    @Test    public void testOuterProduct() {        final ArrayRealVector u = new ArrayRealVector(new double[] {1, 2, -3});        final ArrayRealVector v = new ArrayRealVector(new double[] {4, -2});        final RealMatrix uv = u.outerProduct(v);        final double tol = Math.ulp(1d);        Assert.assertEquals(4, uv.getEntry(0, 0), tol);        Assert.assertEquals(-2, uv.getEntry(0, 1), tol);        Assert.assertEquals(8, uv.getEntry(1, 0), tol);        Assert.assertEquals(-4, uv.getEntry(1, 1), tol);        Assert.assertEquals(-12, uv.getEntry(2, 0), tol);        Assert.assertEquals(6, uv.getEntry(2, 1), tol);    }    @Test(expected=DimensionMismatchException.class)    public void testCombinePreconditionSameType() {        final double a = 1d;        final double b = 2d;        double[] aux = new double[] { 3d, 4d, 5d };        final RealVector x = new ArrayRealVector(aux, false);        aux = new double[] { 6d, 7d };        final RealVector y = new ArrayRealVector(aux, false);        x.combine(a, b, y);    }    @Test    public void testCombineSameType() {        final Random random = new Random(20110726);        final int dim = 10;        final double a = (2 * random.nextDouble() - 1);        final double b = (2 * random.nextDouble() - 1);        final RealVector x = new ArrayRealVector(dim);        final RealVector y = new ArrayRealVector(dim);        final double[] expected = new double[dim];        for (int i = 0; i < dim; i++) {            final double xi = 2 * random.nextDouble() - 1;            final double yi = 2 * random.nextDouble() - 1;            x.setEntry(i, xi);            y.setEntry(i, yi);            expected[i] = a * xi + b * yi;        }        final double[] actual = x.combine(a, b, y).getData();        for (int i = 0; i < dim; i++) {            final double delta;            if (expected[i] == 0d) {                delta = Math.ulp(1d);            } else {                delta = Math.ulp(expected[i]);            }            Assert.assertEquals("elements [" + i + "] differ",                                expected[i],                                actual[i],                                delta);        }    }    @Test(expected=DimensionMismatchException.class)    public void testCombinePreconditionMixedType() {        final double a = 1d;        final double b = 2d;        double[] aux = new double[] { 3d, 4d, 5d };        final RealVector x = new ArrayRealVector(aux, false);        aux = new double[] { 6d, 7d };        final RealVector y = new OpenMapRealVector(aux);        x.combine(a, b, y);    }    @Test    public void testCombineMixedTypes() {        final Random random = new Random(20110726);        final int dim = 10;        final double a = (2 * random.nextDouble() - 1);        final double b = (2 * random.nextDouble() - 1);        final RealVector x = new ArrayRealVector(dim);        final RealVector y = new OpenMapRealVector(dim, 0d);        final double[] expected = new double[dim];        for (int i = 0; i < dim; i++) {            final double xi = 2 * random.nextDouble() - 1;            final double yi = 2 * random.nextDouble() - 1;            x.setEntry(i, xi);            y.setEntry(i, yi);            expected[i] = a * xi + b * yi;        }        final double[] actual = x.combine(a, b, y).getData();        for (int i = 0; i < dim; i++) {            final double delta;            if (expected[i] == 0d) {                delta = Math.ulp(1d);            } else {                delta = Math.ulp(expected[i]);            }            Assert.assertEquals("elements [" + i + "] differ",                                expected[i],                                actual[i],                                delta);        }    }    @Test(expected=DimensionMismatchException.class)    public void testCombineToSelfPreconditionSameType() {        final double a = 1d;        final double b = 2d;        double[] aux = new double[] { 3d, 4d, 5d };        final RealVector x = new ArrayRealVector(aux, false);        aux = new double[] { 6d, 7d };        final RealVector y = new ArrayRealVector(aux, false);        x.combineToSelf(a, b, y);    }    @Test    public void testCombineToSelfSameType() {        final Random random = new Random(20110726);        final int dim = 10;        final double a = (2 * random.nextDouble() - 1);        final double b = (2 * random.nextDouble() - 1);        final RealVector x = new ArrayRealVector(dim);        final RealVector y = new ArrayRealVector(dim);        final double[] expected = new double[dim];        for (int i = 0; i < dim; i++) {            final double xi = 2 * random.nextDouble() - 1;            final double yi = 2 * random.nextDouble() - 1;            x.setEntry(i, xi);            y.setEntry(i, yi);            expected[i] = a * xi + b * yi;        }        Assert.assertSame(x, x.combineToSelf(a, b, y));        final double[] actual = x.getData();        for (int i = 0; i < dim; i++) {            final double delta;            if (expected[i] == 0d) {                delta = Math.ulp(1d);            } else {                delta = Math.ulp(expected[i]);            }            Assert.assertEquals("elements [" + i + "] differ",                                expected[i],                                actual[i],                                delta);        }    }    @Test(expected=DimensionMismatchException.class)    public void testCombineToSelfPreconditionMixedType() {        final double a = 1d;        final double b = 2d;        double[] aux = new double[] { 3d, 4d, 5d };        final RealVector x = new ArrayRealVector(aux, false);        aux = new double[] { 6d, 7d };        final RealVector y = new OpenMapRealVector(aux);        x.combineToSelf(a, b, y);    }    @Test    public void testCombineToSelfMixedTypes() {        final Random random = new Random(20110726);        final int dim = 10;        final double a = (2 * random.nextDouble() - 1);        final double b = (2 * random.nextDouble() - 1);        final RealVector x = new ArrayRealVector(dim);        final RealVector y = new OpenMapRealVector(dim, 0d);        final double[] expected = new double[dim];        for (int i = 0; i < dim; i++) {            final double xi = 2 * random.nextDouble() - 1;            final double yi = 2 * random.nextDouble() - 1;            x.setEntry(i, xi);            y.setEntry(i, yi);            expected[i] = a * xi + b * yi;        }        Assert.assertSame(x, x.combineToSelf(a, b, y));        final double[] actual = x.getData();        for (int i = 0; i < dim; i++) {            final double delta;            if (expected[i] == 0d) {                delta = Math.ulp(1d);            } else {                delta = Math.ulp(expected[i]);            }            Assert.assertEquals("elements [" + i + "] differ",                                expected[i],                                actual[i],                                delta);        }    }    /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, double[] m, double[] n,            double tolerance) {        if (m.length != n.length) {            Assert.fail("vectors have different lengths");        }        for (int i = 0; i < m.length; i++) {            Assert.assertEquals(msg + " " +  i + " elements differ", m[i],n[i],tolerance);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Random;import org.apache.commons.math.util.MathUtils;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.junit.Test;import org.junit.Assert;public class EigenSolverTest {    /** test non invertible matrix */    @Test    public void testNonInvertible() {        Random r = new Random(9994100315209l);        RealMatrix m =            EigenDecompositionImplTest.createTestMatrix(r, new double[] { 1.0, 0.0, -1.0, -2.0, -3.0 });        DecompositionSolver es = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN).getSolver();        Assert.assertFalse(es.isNonSingular());        try {            es.getInverse();            Assert.fail("an exception should have been thrown");        } catch (SingularMatrixException ime) {            // expected behavior        }    }    /** test invertible matrix */    @Test    public void testInvertible() {        Random r = new Random(9994100315209l);        RealMatrix m =            EigenDecompositionImplTest.createTestMatrix(r, new double[] { 1.0, 0.5, -1.0, -2.0, -3.0 });        DecompositionSolver es = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN).getSolver();        Assert.assertTrue(es.isNonSingular());        RealMatrix inverse = es.getInverse();        RealMatrix error =            m.multiply(inverse).subtract(MatrixUtils.createRealIdentityMatrix(m.getRowDimension()));        Assert.assertEquals(0, error.getNorm(), 4.0e-15);    }    /** test solve dimension errors */    @Test    public void testSolveDimensionErrors() {        final double[] refValues = new double[] {            2.003, 2.002, 2.001, 1.001, 1.000, 0.001        };        final RealMatrix matrix = EigenDecompositionImplTest.createTestMatrix(new Random(35992629946426l), refValues);        DecompositionSolver es = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);        try {            es.solve(b);            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException iae) {            // expected behavior        }        try {            es.solve(b.getColumnVector(0));            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException iae) {            // expected behavior        }        try {            es.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException iae) {            // expected behavior        }    }    /** test solve */    @Test    public void testSolve() {        RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {                { 91,  5, 29, 32, 40, 14 },                {  5, 34, -1,  0,  2, -1 },                { 29, -1, 12,  9, 21,  8 },                { 32,  0,  9, 14,  9,  0 },                { 40,  2, 21,  9, 51, 19 },                { 14, -1,  8,  0, 19, 14 }        });        DecompositionSolver es = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                { 1561, 269, 188 },                {   69, -21,  70 },                {  739, 108,  63 },                {  324,  86,  59 },                { 1624, 194, 107 },                {  796,  69,  36 }        });        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                { 1,   2, 1 },                { 2,  -1, 2 },                { 4,   2, 3 },                { 8,  -1, 0 },                { 16,  2, 0 },                { 32, -1, 0 }        });        // using RealMatrix        RealMatrix solution=es.solve(b);        Assert.assertEquals(0, solution.subtract(xRef).getNorm(), 2.5e-12);        // using double[][]        solution = MatrixUtils.createRealMatrix(es.solve(b.getData()));        Assert.assertEquals(0, solution.subtract(xRef).getNorm(), 2.5e-12);        // using RealVector        for (int i = 0; i < b.getColumnDimension(); ++i) {            Assert.assertEquals(0,                         es.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),                         2.0e-11);        }        // using RealVector with an alternate implementation        for (int i = 0; i < b.getColumnDimension(); ++i) {            ArrayRealVectorTest.RealVectorTestImpl v =                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));            Assert.assertEquals(0,                         es.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),                         2.0e-11);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Locale;public class FrenchRealVectorFormatTest extends RealVectorFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return ',';    }    @Override    protected Locale getLocale() {        return Locale.FRENCH;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.math.BigDecimal;import org.apache.commons.math.TestUtils;import org.apache.commons.math.fraction.BigFraction;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionConversionException;import org.apache.commons.math.fraction.FractionField;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.exception.NotStrictlyPositiveException;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link MatrixUtils} class. * * @version $Id$ */public final class MatrixUtilsTest {    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    protected double[][] nullMatrix = null;    protected double[] row = {1,2,3};    protected BigDecimal[] bigRow =        {new BigDecimal(1),new BigDecimal(2),new BigDecimal(3)};    protected String[] stringRow = {"1", "2", "3"};    protected Fraction[] fractionRow =        {new Fraction(1),new Fraction(2),new Fraction(3)};    protected double[][] rowMatrix = {{1,2,3}};    protected BigDecimal[][] bigRowMatrix =        {{new BigDecimal(1), new BigDecimal(2), new BigDecimal(3)}};    protected String[][] stringRowMatrix = {{"1", "2", "3"}};    protected Fraction[][] fractionRowMatrix =        {{new Fraction(1), new Fraction(2), new Fraction(3)}};    protected double[] col = {0,4,6};    protected BigDecimal[] bigCol =        {new BigDecimal(0),new BigDecimal(4),new BigDecimal(6)};    protected String[] stringCol = {"0","4","6"};    protected Fraction[] fractionCol =        {new Fraction(0),new Fraction(4),new Fraction(6)};    protected double[] nullDoubleArray = null;    protected double[][] colMatrix = {{0},{4},{6}};    protected BigDecimal[][] bigColMatrix =        {{new BigDecimal(0)},{new BigDecimal(4)},{new BigDecimal(6)}};    protected String[][] stringColMatrix = {{"0"}, {"4"}, {"6"}};    protected Fraction[][] fractionColMatrix =        {{new Fraction(0)},{new Fraction(4)},{new Fraction(6)}};    @Test    public void testCreateRealMatrix() {        Assert.assertEquals(new BlockRealMatrix(testData),                MatrixUtils.createRealMatrix(testData));        try {            MatrixUtils.createRealMatrix(new double[][] {{1}, {1,2}});  // ragged            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createRealMatrix(new double[][] {{}, {}});  // no columns            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createRealMatrix(null);  // null            Assert.fail("Expecting NullArgumentException");        } catch (NullArgumentException ex) {            // expected        }    }    @Test    public void testcreateFieldMatrix() {        Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(asFraction(testData)),                     MatrixUtils.createFieldMatrix(asFraction(testData)));        Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), fractionColMatrix),                     MatrixUtils.createFieldMatrix(fractionColMatrix));        try {            MatrixUtils.createFieldMatrix(asFraction(new double[][] {{1}, {1,2}}));  // ragged            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createFieldMatrix(asFraction(new double[][] {{}, {}}));  // no columns            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createFieldMatrix((Fraction[][])null);  // null            Assert.fail("Expecting NullArgumentException");        } catch (NullArgumentException ex) {            // expected        }    }    @Test    public void testCreateRowRealMatrix() {        Assert.assertEquals(MatrixUtils.createRowRealMatrix(row),                     new BlockRealMatrix(rowMatrix));        try {            MatrixUtils.createRowRealMatrix(new double[] {});  // empty            Assert.fail("Expecting NotStrictlyPositiveException");        } catch (NotStrictlyPositiveException ex) {            // expected        }        try {            MatrixUtils.createRowRealMatrix(null);  // null            Assert.fail("Expecting NullArgumentException");        } catch (NullArgumentException ex) {            // expected        }    }    @Test    public void testCreateRowFieldMatrix() {        Assert.assertEquals(MatrixUtils.createRowFieldMatrix(asFraction(row)),                     new Array2DRowFieldMatrix<Fraction>(asFraction(rowMatrix)));        Assert.assertEquals(MatrixUtils.createRowFieldMatrix(fractionRow),                     new Array2DRowFieldMatrix<Fraction>(fractionRowMatrix));        try {            MatrixUtils.createRowFieldMatrix(new Fraction[] {});  // empty            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createRowFieldMatrix((Fraction[]) null);  // null            Assert.fail("Expecting NullArgumentException");        } catch (NullArgumentException ex) {            // expected        }    }    @Test    public void testCreateColumnRealMatrix() {        Assert.assertEquals(MatrixUtils.createColumnRealMatrix(col),                     new BlockRealMatrix(colMatrix));        try {            MatrixUtils.createColumnRealMatrix(new double[] {});  // empty            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createColumnRealMatrix(null);  // null            Assert.fail("Expecting NullArgumentException");        } catch (NullArgumentException ex) {            // expected        }    }    @Test    public void testCreateColumnFieldMatrix() {        Assert.assertEquals(MatrixUtils.createColumnFieldMatrix(asFraction(col)),                     new Array2DRowFieldMatrix<Fraction>(asFraction(colMatrix)));        Assert.assertEquals(MatrixUtils.createColumnFieldMatrix(fractionCol),                     new Array2DRowFieldMatrix<Fraction>(fractionColMatrix));        try {            MatrixUtils.createColumnFieldMatrix(new Fraction[] {});  // empty            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createColumnFieldMatrix((Fraction[]) null);  // null            Assert.fail("Expecting NullArgumentException");        } catch (NullArgumentException ex) {            // expected        }    }    /**     * Verifies that the matrix is an identity matrix     */    protected void checkIdentityMatrix(RealMatrix m) {        for (int i = 0; i < m.getRowDimension(); i++) {            for (int j =0; j < m.getColumnDimension(); j++) {                if (i == j) {                    Assert.assertEquals(m.getEntry(i, j), 1d, 0);                } else {                    Assert.assertEquals(m.getEntry(i, j), 0d, 0);                }            }        }    }    @Test    public void testCreateIdentityMatrix() {        checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(3));        checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(2));        checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(1));        try {            MatrixUtils.createRealIdentityMatrix(0);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    /**     * Verifies that the matrix is an identity matrix     */    protected void checkIdentityFieldMatrix(FieldMatrix<Fraction> m) {        for (int i = 0; i < m.getRowDimension(); i++) {            for (int j =0; j < m.getColumnDimension(); j++) {                if (i == j) {                    Assert.assertEquals(m.getEntry(i, j), Fraction.ONE);                } else {                    Assert.assertEquals(m.getEntry(i, j), Fraction.ZERO);                }            }        }    }    @Test    public void testcreateFieldIdentityMatrix() {        checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 3));        checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 2));        checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 1));        try {            MatrixUtils.createRealIdentityMatrix(0);            Assert.fail("Expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testBigFractionConverter() {        BigFraction[][] bfData = {                { new BigFraction(1), new BigFraction(2), new BigFraction(3) },                { new BigFraction(2), new BigFraction(5), new BigFraction(3) },                { new BigFraction(1), new BigFraction(0), new BigFraction(8) }        };        FieldMatrix<BigFraction> m = new Array2DRowFieldMatrix<BigFraction>(bfData, false);        RealMatrix converted = MatrixUtils.bigFractionMatrixToRealMatrix(m);        RealMatrix reference = new Array2DRowRealMatrix(testData, false);        Assert.assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0);    }    @Test    public void testFractionConverter() {        Fraction[][] fData = {                { new Fraction(1), new Fraction(2), new Fraction(3) },                { new Fraction(2), new Fraction(5), new Fraction(3) },                { new Fraction(1), new Fraction(0), new Fraction(8) }        };        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(fData, false);        RealMatrix converted = MatrixUtils.fractionMatrixToRealMatrix(m);        RealMatrix reference = new Array2DRowRealMatrix(testData, false);        Assert.assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0);    }    public static final Fraction[][] asFraction(double[][] data) {        Fraction d[][] = new Fraction[data.length][];        try {            for (int i = 0; i < data.length; ++i) {                double[] dataI = data[i];                Fraction[] dI  = new Fraction[dataI.length];                for (int j = 0; j < dataI.length; ++j) {                    dI[j] = new Fraction(dataI[j]);                }                d[i] = dI;            }        } catch (FractionConversionException fce) {            Assert.fail(fce.getMessage());        }        return d;    }    public static final Fraction[] asFraction(double[] data) {        Fraction d[] = new Fraction[data.length];        try {            for (int i = 0; i < data.length; ++i) {                d[i] = new Fraction(data[i]);            }        } catch (FractionConversionException fce) {            Assert.fail(fce.getMessage());        }        return d;    }      @Test     public void testSolveLowerTriangularSystem(){        RealMatrix rm = new Array2DRowRealMatrix(                new double[][] { {2,0,0,0 }, { 1,1,0,0 }, { 3,3,3,0 }, { 3,3,3,4 } },                       false);        RealVector b = new ArrayRealVector(new double[] { 2,3,4,8 }, false);        MatrixUtils.solveLowerTriangularSystem(rm, b);        TestUtils.assertEquals( new double[]{1,2,-1.66666666666667, 1.0}  , b.getData() , 1.0e-12);    }             /*     * Taken from R manual http://stat.ethz.ch/R-manual/R-patched/library/base/html/backsolve.html     */    @Test    public void testSolveUpperTriangularSystem(){        RealMatrix rm = new Array2DRowRealMatrix(                new double[][] { {1,2,3 }, { 0,1,1 }, { 0,0,2 } },                       false);        RealVector b = new ArrayRealVector(new double[] { 8,4,2 }, false);        MatrixUtils.solveUpperTriangularSystem(rm, b);        TestUtils.assertEquals( new double[]{-1,3,1}  , b.getData() , 1.0e-12);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.junit.Test;import org.junit.Assert;public class LUDecompositionImplTest {    private double[][] testData = {            { 1.0, 2.0, 3.0},            { 2.0, 5.0, 3.0},            { 1.0, 0.0, 8.0}    };    private double[][] testDataMinus = {            { -1.0, -2.0, -3.0},            { -2.0, -5.0, -3.0},            { -1.0,  0.0, -8.0}    };    private double[][] luData = {            { 2.0, 3.0, 3.0 },            { 0.0, 5.0, 7.0 },            { 6.0, 9.0, 8.0 }    };    // singular matrices    private double[][] singular = {            { 2.0, 3.0 },            { 2.0, 3.0 }    };    private double[][] bigSingular = {            { 1.0, 2.0,   3.0,    4.0 },            { 2.0, 5.0,   3.0,    4.0 },            { 7.0, 3.0, 256.0, 1930.0 },            { 3.0, 7.0,   6.0,    8.0 }    }; // 4th row = 1st + 2nd    private static final double entryTolerance = 10e-16;    private static final double normTolerance = 10e-14;    /** test dimensions */    @Test    public void testDimensions() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        LUDecomposition LU = new LUDecompositionImpl(matrix);        Assert.assertEquals(testData.length, LU.getL().getRowDimension());        Assert.assertEquals(testData.length, LU.getL().getColumnDimension());        Assert.assertEquals(testData.length, LU.getU().getRowDimension());        Assert.assertEquals(testData.length, LU.getU().getColumnDimension());        Assert.assertEquals(testData.length, LU.getP().getRowDimension());        Assert.assertEquals(testData.length, LU.getP().getColumnDimension());    }    /** test non-square matrix */    @Test    public void testNonSquare() {        try {            new LUDecompositionImpl(MatrixUtils.createRealMatrix(new double[3][2]));            Assert.fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ime) {            // expected behavior        }    }    /** test PA = LU */    @Test    public void testPAEqualLU() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        LUDecomposition lu = new LUDecompositionImpl(matrix);        RealMatrix l = lu.getL();        RealMatrix u = lu.getU();        RealMatrix p = lu.getP();        double norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();        Assert.assertEquals(0, norm, normTolerance);        matrix = MatrixUtils.createRealMatrix(testDataMinus);        lu = new LUDecompositionImpl(matrix);        l = lu.getL();        u = lu.getU();        p = lu.getP();        norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();        Assert.assertEquals(0, norm, normTolerance);        matrix = MatrixUtils.createRealIdentityMatrix(17);        lu = new LUDecompositionImpl(matrix);        l = lu.getL();        u = lu.getU();        p = lu.getP();        norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();        Assert.assertEquals(0, norm, normTolerance);        matrix = MatrixUtils.createRealMatrix(singular);        lu = new LUDecompositionImpl(matrix);        Assert.assertFalse(lu.getSolver().isNonSingular());        Assert.assertNull(lu.getL());        Assert.assertNull(lu.getU());        Assert.assertNull(lu.getP());        matrix = MatrixUtils.createRealMatrix(bigSingular);        lu = new LUDecompositionImpl(matrix);        Assert.assertFalse(lu.getSolver().isNonSingular());        Assert.assertNull(lu.getL());        Assert.assertNull(lu.getU());        Assert.assertNull(lu.getP());    }    /** test that L is lower triangular with unit diagonal */    @Test    public void testLLowerTriangular() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        RealMatrix l = new LUDecompositionImpl(matrix).getL();        for (int i = 0; i < l.getRowDimension(); i++) {            Assert.assertEquals(l.getEntry(i, i), 1, entryTolerance);            for (int j = i + 1; j < l.getColumnDimension(); j++) {                Assert.assertEquals(l.getEntry(i, j), 0, entryTolerance);            }        }    }    /** test that U is upper triangular */    @Test    public void testUUpperTriangular() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        RealMatrix u = new LUDecompositionImpl(matrix).getU();        for (int i = 0; i < u.getRowDimension(); i++) {            for (int j = 0; j < i; j++) {                Assert.assertEquals(u.getEntry(i, j), 0, entryTolerance);            }        }    }    /** test that P is a permutation matrix */    @Test    public void testPPermutation() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        RealMatrix p   = new LUDecompositionImpl(matrix).getP();        RealMatrix ppT = p.multiply(p.transpose());        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(p.getRowDimension());        Assert.assertEquals(0, ppT.subtract(id).getNorm(), normTolerance);        for (int i = 0; i < p.getRowDimension(); i++) {            int zeroCount  = 0;            int oneCount   = 0;            int otherCount = 0;            for (int j = 0; j < p.getColumnDimension(); j++) {                final double e = p.getEntry(i, j);                if (e == 0) {                    ++zeroCount;                } else if (e == 1) {                    ++oneCount;                } else {                    ++otherCount;                }            }            Assert.assertEquals(p.getColumnDimension() - 1, zeroCount);            Assert.assertEquals(1, oneCount);            Assert.assertEquals(0, otherCount);        }        for (int j = 0; j < p.getColumnDimension(); j++) {            int zeroCount  = 0;            int oneCount   = 0;            int otherCount = 0;            for (int i = 0; i < p.getRowDimension(); i++) {                final double e = p.getEntry(i, j);                if (e == 0) {                    ++zeroCount;                } else if (e == 1) {                    ++oneCount;                } else {                    ++otherCount;                }            }            Assert.assertEquals(p.getRowDimension() - 1, zeroCount);            Assert.assertEquals(1, oneCount);            Assert.assertEquals(0, otherCount);        }    }    /** test singular */    @Test    public void testSingular() {        LUDecomposition lu =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData));        Assert.assertTrue(lu.getSolver().isNonSingular());        lu = new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular));        Assert.assertFalse(lu.getSolver().isNonSingular());        lu = new LUDecompositionImpl(MatrixUtils.createRealMatrix(bigSingular));        Assert.assertFalse(lu.getSolver().isNonSingular());    }    /** test matrices values */    @Test    public void testMatricesValues1() {       LUDecomposition lu =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData));        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {                { 1.0, 0.0, 0.0 },                { 0.5, 1.0, 0.0 },                { 0.5, 0.2, 1.0 }        });        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {                { 2.0,  5.0, 3.0 },                { 0.0, -2.5, 6.5 },                { 0.0,  0.0, 0.2 }        });        RealMatrix pRef = MatrixUtils.createRealMatrix(new double[][] {                { 0.0, 1.0, 0.0 },                { 0.0, 0.0, 1.0 },                { 1.0, 0.0, 0.0 }        });        int[] pivotRef = { 1, 2, 0 };        // check values against known references        RealMatrix l = lu.getL();        Assert.assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);        RealMatrix u = lu.getU();        Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);        RealMatrix p = lu.getP();        Assert.assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);        int[] pivot = lu.getPivot();        for (int i = 0; i < pivotRef.length; ++i) {            Assert.assertEquals(pivotRef[i], pivot[i]);        }        // check the same cached instance is returned the second time        Assert.assertTrue(l == lu.getL());        Assert.assertTrue(u == lu.getU());        Assert.assertTrue(p == lu.getP());    }    /** test matrices values */    @Test    public void testMatricesValues2() {       LUDecomposition lu =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(luData));        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {                {    1.0,    0.0, 0.0 },                {    0.0,    1.0, 0.0 },                { 1.0 / 3.0, 0.0, 1.0 }        });        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {                { 6.0, 9.0,    8.0    },                { 0.0, 5.0,    7.0    },                { 0.0, 0.0, 1.0 / 3.0 }        });        RealMatrix pRef = MatrixUtils.createRealMatrix(new double[][] {                { 0.0, 0.0, 1.0 },                { 0.0, 1.0, 0.0 },                { 1.0, 0.0, 0.0 }        });        int[] pivotRef = { 2, 1, 0 };        // check values against known references        RealMatrix l = lu.getL();        Assert.assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);        RealMatrix u = lu.getU();        Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);        RealMatrix p = lu.getP();        Assert.assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);        int[] pivot = lu.getPivot();        for (int i = 0; i < pivotRef.length; ++i) {            Assert.assertEquals(pivotRef[i], pivot[i]);        }        // check the same cached instance is returned the second time        Assert.assertTrue(l == lu.getL());        Assert.assertTrue(u == lu.getU());        Assert.assertTrue(p == lu.getP());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.junit.Test;import org.junit.Assert;import org.apache.commons.math.Field;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionConversionException;import org.apache.commons.math.fraction.FractionField;import org.apache.commons.math.exception.NoDataException;import org.apache.commons.math.exception.OutOfRangeException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.exception.MathIllegalArgumentException;/** * Test cases for the {@link SparseFieldMatrix} class. * * @version $Id$ */public class SparseFieldMatrixTest {    // 3 x 3 identity matrix    protected Fraction[][] id = { {new Fraction(1), new Fraction(0), new Fraction(0) }, { new Fraction(0), new Fraction(1), new Fraction(0) }, { new Fraction(0), new Fraction(0), new Fraction(1) } };    // Test data for group operations    protected Fraction[][] testData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) },            { new Fraction(1), new Fraction(0), new Fraction(8) } };    protected Fraction[][] testDataLU = null;    protected Fraction[][] testDataPlus2 = { { new Fraction(3), new Fraction(4), new Fraction(5) }, { new Fraction(4), new Fraction(7), new Fraction(5) },            { new Fraction(3), new Fraction(2), new Fraction(10) } };    protected Fraction[][] testDataMinus = { { new Fraction(-1), new Fraction(-2), new Fraction(-3) },            { new Fraction(-2), new Fraction(-5), new Fraction(-3) }, { new Fraction(-1), new Fraction(0), new Fraction(-8) } };    protected Fraction[] testDataRow1 = { new Fraction(1), new Fraction(2), new Fraction(3) };    protected Fraction[] testDataCol3 = { new Fraction(3), new Fraction(3), new Fraction(8) };    protected Fraction[][] testDataInv = { { new Fraction(-40), new Fraction(16), new Fraction(9) }, { new Fraction(13), new Fraction(-5), new Fraction(-3) },            { new Fraction(5), new Fraction(-2), new Fraction(-1) } };    protected Fraction[] preMultTest = { new Fraction(8), new Fraction(12), new Fraction(33) };    protected Fraction[][] testData2 = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) } };    protected Fraction[][] testData2T = { { new Fraction(1), new Fraction(2) }, { new Fraction(2), new Fraction(5) }, { new Fraction(3), new Fraction(3) } };    protected Fraction[][] testDataPlusInv = { { new Fraction(-39), new Fraction(18), new Fraction(12) },            { new Fraction(15), new Fraction(0), new Fraction(0) }, { new Fraction(6), new Fraction(-2), new Fraction(7) } };    // lu decomposition tests    protected Fraction[][] luData = { { new Fraction(2), new Fraction(3), new Fraction(3) }, { new Fraction(0), new Fraction(5), new Fraction(7) }, { new Fraction(6), new Fraction(9), new Fraction(8) } };    protected Fraction[][] luDataLUDecomposition = null;    // singular matrices    protected Fraction[][] singular = { { new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(3) } };    protected Fraction[][] bigSingular = { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) },            { new Fraction(2), new Fraction(5), new Fraction(3), new Fraction(4) }, { new Fraction(7), new Fraction(3), new Fraction(256), new Fraction(1930) }, { new Fraction(3), new Fraction(7), new Fraction(6), new Fraction(8) } }; // 4th    // row    // =    // 1st    // +    // 2nd    protected Fraction[][] detData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(4), new Fraction(5), new Fraction(6) },            { new Fraction(7), new Fraction(8), new Fraction(10) } };    protected Fraction[][] detData2 = { { new Fraction(1), new Fraction(3) }, { new Fraction(2), new Fraction(4) } };    // vectors    protected Fraction[] testVector = { new Fraction(1), new Fraction(2), new Fraction(3) };    protected Fraction[] testVector2 = { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) };    // submatrix accessor tests    protected Fraction[][] subTestData = null;    // array selections    protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4) }, { new Fraction(4), new Fraction(8) } };    protected Fraction[][] subRows03Cols12 = { { new Fraction(2), new Fraction(3) }, { new Fraction(5), new Fraction(6) } };    protected Fraction[][] subRows03Cols123 = { { new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7) } };    // effective permutations    protected Fraction[][] subRows20Cols123 = { { new Fraction(4), new Fraction(6), new Fraction(8) }, { new Fraction(2), new Fraction(3), new Fraction(4) } };    protected Fraction[][] subRows31Cols31 = null;    // contiguous ranges    protected Fraction[][] subRows01Cols23 = null;    protected Fraction[][] subRows23Cols00 = { { new Fraction(2) }, { new Fraction(4) } };    protected Fraction[][] subRows00Cols33 = { { new Fraction(4) } };    // row matrices    protected Fraction[][] subRow0 = { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) } };    protected Fraction[][] subRow3 = { { new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7) } };    // column matrices    protected Fraction[][] subColumn1 = null;    protected Fraction[][] subColumn3 = null;    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    protected Field<Fraction> field = FractionField.getInstance();    public SparseFieldMatrixTest() {        try {            testDataLU = new Fraction[][]{ { new Fraction(2), new Fraction(5), new Fraction(3) }, { new Fraction(.5d), new Fraction(-2.5d), new Fraction(6.5d) },                    { new Fraction(0.5d), new Fraction(0.2d), new Fraction(.2d) } };            luDataLUDecomposition = new Fraction[][]{ { new Fraction(6), new Fraction(9), new Fraction(8) },                { new Fraction(0), new Fraction(5), new Fraction(7) }, { new Fraction(0.33333333333333), new Fraction(0), new Fraction(0.33333333333333) } };            subTestData = new Fraction [][]{ { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) },                    { new Fraction(1.5), new Fraction(2.5), new Fraction(3.5), new Fraction(4.5) }, { new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8) }, { new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7) } };            subRows31Cols31 = new Fraction[][]{ { new Fraction(7), new Fraction(5) }, { new Fraction(4.5), new Fraction(2.5) } };            subRows01Cols23 = new Fraction[][]{ { new Fraction(3), new Fraction(4) }, { new Fraction(3.5), new Fraction(4.5) } };            subColumn1 = new Fraction [][]{ { new Fraction(2) }, { new Fraction(2.5) }, { new Fraction(4) }, { new Fraction(5) } };            subColumn3 = new Fraction[][]{ { new Fraction(4) }, { new Fraction(4.5) }, { new Fraction(8) }, { new Fraction(7) } };        } catch (FractionConversionException e) {            // ignore, can't happen        }    }    /** test dimensions */    @Test    public void testDimensions() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);        Assert.assertEquals("testData row dimension", 3, m.getRowDimension());        Assert.assertEquals("testData column dimension", 3, m.getColumnDimension());        Assert.assertTrue("testData is square", m.isSquare());        Assert.assertEquals("testData2 row dimension", m2.getRowDimension(), 2);        Assert.assertEquals("testData2 column dimension", m2.getColumnDimension(), 3);        Assert.assertTrue("testData2 is not square", !m2.isSquare());    }    /** test copy functions */    @Test    public void testCopyFunctions() {        SparseFieldMatrix<Fraction> m1 = createSparseMatrix(testData);        FieldMatrix<Fraction> m2 = m1.copy();        Assert.assertEquals(m1.getClass(), m2.getClass());        Assert.assertEquals((m2), m1);        SparseFieldMatrix<Fraction> m3 = createSparseMatrix(testData);        FieldMatrix<Fraction> m4 = m3.copy();        Assert.assertEquals(m3.getClass(), m4.getClass());        Assert.assertEquals((m4), m3);    }    /** test add */    @Test    public void testAdd() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv);        SparseFieldMatrix<Fraction> mDataPlusInv = createSparseMatrix(testDataPlusInv);        FieldMatrix<Fraction> mPlusMInv = m.add(mInv);        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                Assert.assertEquals("sum entry entry",                    mDataPlusInv.getEntry(row, col).doubleValue(), mPlusMInv.getEntry(row, col).doubleValue(),                    entryTolerance);            }        }    }    /** test add failure */    @Test    public void testAddFail() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);        try {            m.add(m2);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    /** test m-n = m + -n */    @Test    public void testPlusMinus() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> n = createSparseMatrix(testDataInv);        assertClose("m-n = m + -n", m.subtract(n),            n.scalarMultiply(new Fraction(-1)).add(m), entryTolerance);        try {            m.subtract(createSparseMatrix(testData2));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    /** test multiply */    @Test    public void testMultiply() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv);        SparseFieldMatrix<Fraction> identity = createSparseMatrix(id);        SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);        assertClose("inverse multiply", m.multiply(mInv), identity,                entryTolerance);        assertClose("inverse multiply", m.multiply(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testDataInv)), identity,                    entryTolerance);        assertClose("inverse multiply", mInv.multiply(m), identity,                entryTolerance);        assertClose("identity multiply", m.multiply(identity), m,                entryTolerance);        assertClose("identity multiply", identity.multiply(mInv), mInv,                entryTolerance);        assertClose("identity multiply", m2.multiply(identity), m2,                entryTolerance);        try {            m.multiply(createSparseMatrix(bigSingular));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    // Additional Test for Array2DRowRealMatrixTest.testMultiply    private Fraction[][] d3 = new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8) } };    private Fraction[][] d4 = new Fraction[][] { { new Fraction(1) }, { new Fraction(2) }, { new Fraction(3) }, { new Fraction(4) } };    private Fraction[][] d5 = new Fraction[][] { { new Fraction(30) }, { new Fraction(70) } };    @Test    public void testMultiply2() {        FieldMatrix<Fraction> m3 = createSparseMatrix(d3);        FieldMatrix<Fraction> m4 = createSparseMatrix(d4);        FieldMatrix<Fraction> m5 = createSparseMatrix(d5);        assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);    }    /** test trace */    @Test    public void testTrace() {        FieldMatrix<Fraction> m = createSparseMatrix(id);        Assert.assertEquals("identity trace", 3d, m.getTrace().doubleValue(), entryTolerance);        m = createSparseMatrix(testData2);        try {            m.getTrace();            Assert.fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }    }    /** test sclarAdd */    @Test    public void testScalarAdd() {        FieldMatrix<Fraction> m = createSparseMatrix(testData);        assertClose("scalar add", createSparseMatrix(testDataPlus2),            m.scalarAdd(new Fraction(2)), entryTolerance);    }    /** test operate */    @Test    public void testOperate() {        FieldMatrix<Fraction> m = createSparseMatrix(id);        assertClose("identity operate", testVector, m.operate(testVector),                entryTolerance);        assertClose("identity operate", testVector, m.operate(                new ArrayFieldVector<Fraction>(testVector)).getData(), entryTolerance);        m = createSparseMatrix(bigSingular);        try {            m.operate(testVector);            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    /** test issue MATH-209 */    @Test    public void testMath209() {        FieldMatrix<Fraction> a = createSparseMatrix(new Fraction[][] {                { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } });        Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });        Assert.assertEquals(a.getRowDimension(), b.length);        Assert.assertEquals(3.0, b[0].doubleValue(), 1.0e-12);        Assert.assertEquals(7.0, b[1].doubleValue(), 1.0e-12);        Assert.assertEquals(11.0, b[2].doubleValue(), 1.0e-12);    }    /** test transpose */    @Test    public void testTranspose() {        FieldMatrix<Fraction> m = createSparseMatrix(testData);        FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();        assertClose("inverse-transpose", mIT, mTI, normTolerance);        m = createSparseMatrix(testData2);        FieldMatrix<Fraction> mt = createSparseMatrix(testData2T);        assertClose("transpose",mt,m.transpose(),normTolerance);    }    /** test preMultiply by vector */    @Test    public void testPremultiplyVector() {        FieldMatrix<Fraction> m = createSparseMatrix(testData);        assertClose("premultiply", m.preMultiply(testVector), preMultTest,            normTolerance);        assertClose("premultiply", m.preMultiply(            new ArrayFieldVector<Fraction>(testVector).getData()), preMultTest, normTolerance);        m = createSparseMatrix(bigSingular);        try {            m.preMultiply(testVector);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    @Test    public void testPremultiply() {        FieldMatrix<Fraction> m3 = createSparseMatrix(d3);        FieldMatrix<Fraction> m4 = createSparseMatrix(d4);        FieldMatrix<Fraction> m5 = createSparseMatrix(d5);        assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv);        SparseFieldMatrix<Fraction> identity = createSparseMatrix(id);        assertClose("inverse multiply", m.preMultiply(mInv), identity,                entryTolerance);        assertClose("inverse multiply", mInv.preMultiply(m), identity,                entryTolerance);        assertClose("identity multiply", m.preMultiply(identity), m,                entryTolerance);        assertClose("identity multiply", identity.preMultiply(mInv), mInv,                entryTolerance);        try {            m.preMultiply(createSparseMatrix(bigSingular));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    @Test    public void testGetVectors() {        FieldMatrix<Fraction> m = createSparseMatrix(testData);        assertClose("get row", m.getRow(0), testDataRow1, entryTolerance);        assertClose("get col", m.getColumn(2), testDataCol3, entryTolerance);        try {            m.getRow(10);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // ignored        }        try {            m.getColumn(-1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // ignored        }    }    @Test    public void testGetEntry() {        FieldMatrix<Fraction> m = createSparseMatrix(testData);        Assert.assertEquals("get entry", m.getEntry(0, 1).doubleValue(), 2d, entryTolerance);        try {            m.getEntry(10, 4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    /** test examples in user guide */    @Test    public void testExamples() {        // Create a real matrix with two rows and three columns        Fraction[][] matrixData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) } };        FieldMatrix<Fraction> m = createSparseMatrix(matrixData);        // One more with three rows, two columns        Fraction[][] matrixData2 = { { new Fraction(1), new Fraction(2) }, { new Fraction(2), new Fraction(5) }, { new Fraction(1), new Fraction(7) } };        FieldMatrix<Fraction> n = createSparseMatrix(matrixData2);        // Now multiply m by n        FieldMatrix<Fraction> p = m.multiply(n);        Assert.assertEquals(2, p.getRowDimension());        Assert.assertEquals(2, p.getColumnDimension());        // Invert p        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();        Assert.assertEquals(2, pInverse.getRowDimension());        Assert.assertEquals(2, pInverse.getColumnDimension());        // Solve example        Fraction[][] coefficientsData = { { new Fraction(2), new Fraction(3), new Fraction(-2) }, { new Fraction(-1), new Fraction(7), new Fraction(6) },                { new Fraction(4), new Fraction(-3), new Fraction(-5) } };        FieldMatrix<Fraction> coefficients = createSparseMatrix(coefficientsData);        Fraction[] constants = { new Fraction(1), new Fraction(-2), new Fraction(1) };        Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);        Assert.assertEquals((new Fraction(2).multiply((solution[0])).add(new Fraction(3).multiply(solution[1])).subtract(new Fraction(2).multiply(solution[2]))).doubleValue(),                constants[0].doubleValue(), 1E-12);        Assert.assertEquals(((new Fraction(-1).multiply(solution[0])).add(new Fraction(7).multiply(solution[1])).add(new Fraction(6).multiply(solution[2]))).doubleValue(),                constants[1].doubleValue(), 1E-12);        Assert.assertEquals(((new Fraction(4).multiply(solution[0])).subtract(new Fraction(3).multiply( solution[1])).subtract(new Fraction(5).multiply(solution[2]))).doubleValue(),                constants[2].doubleValue(), 1E-12);    }    // test submatrix accessors    @Test    public void testSubMatrix() {        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);        FieldMatrix<Fraction> mRows23Cols00 = createSparseMatrix(subRows23Cols00);        FieldMatrix<Fraction> mRows00Cols33 = createSparseMatrix(subRows00Cols33);        FieldMatrix<Fraction> mRows01Cols23 = createSparseMatrix(subRows01Cols23);        FieldMatrix<Fraction> mRows02Cols13 = createSparseMatrix(subRows02Cols13);        FieldMatrix<Fraction> mRows03Cols12 = createSparseMatrix(subRows03Cols12);        FieldMatrix<Fraction> mRows03Cols123 = createSparseMatrix(subRows03Cols123);        FieldMatrix<Fraction> mRows20Cols123 = createSparseMatrix(subRows20Cols123);        FieldMatrix<Fraction> mRows31Cols31 = createSparseMatrix(subRows31Cols31);        Assert.assertEquals("Rows23Cols00", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));        Assert.assertEquals("Rows00Cols33", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));        Assert.assertEquals("Rows01Cols23", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));        Assert.assertEquals("Rows02Cols13", mRows02Cols13,            m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 }));        Assert.assertEquals("Rows03Cols12", mRows03Cols12,            m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 }));        Assert.assertEquals("Rows03Cols123", mRows03Cols123,            m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 }));        Assert.assertEquals("Rows20Cols123", mRows20Cols123,            m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 }));        Assert.assertEquals("Rows31Cols31", mRows31Cols31,            m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));        Assert.assertEquals("Rows31Cols31", mRows31Cols31,            m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));        try {            m.getSubMatrix(1, 0, 2, 4);            Assert.fail("Expecting NumberIsTooSmallException");        } catch (NumberIsTooSmallException ex) {            // expected        }        try {            m.getSubMatrix(-1, 1, 2, 2);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getSubMatrix(1, 0, 2, 2);            Assert.fail("Expecting NumberIsTooSmallException");        } catch (NumberIsTooSmallException ex) {            // expected        }        try {            m.getSubMatrix(1, 0, 2, 4);            Assert.fail("Expecting NumberIsTooSmallException");        } catch (NumberIsTooSmallException ex) {            // expected        }        try {            m.getSubMatrix(new int[] {}, new int[] { 0 });            Assert.fail("Expecting NoDataException");        } catch (NoDataException ex) {            // expected        }        try {            m.getSubMatrix(new int[] { 0 }, new int[] { 4 });            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testGetRowMatrix() {        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);        FieldMatrix<Fraction> mRow0 = createSparseMatrix(subRow0);        FieldMatrix<Fraction> mRow3 = createSparseMatrix(subRow3);        Assert.assertEquals("Row0", mRow0, m.getRowMatrix(0));        Assert.assertEquals("Row3", mRow3, m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getRowMatrix(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testGetColumnMatrix() {        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);        FieldMatrix<Fraction> mColumn1 = createSparseMatrix(subColumn1);        FieldMatrix<Fraction> mColumn3 = createSparseMatrix(subColumn3);        Assert.assertEquals("Column1", mColumn1, m.getColumnMatrix(1));        Assert.assertEquals("Column3", mColumn3, m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getColumnMatrix(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testGetRowVector() {        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);        FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);        Assert.assertEquals("Row0", mRow0, m.getRowVector(0));        Assert.assertEquals("Row3", mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getRowVector(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testGetColumnVector() {        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);        FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);        Assert.assertEquals("Column1", mColumn1, m.getColumnVector(1));        Assert.assertEquals("Column3", mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getColumnVector(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    private FieldVector<Fraction> columnToVector(Fraction[][] column) {        Fraction[] data = new Fraction[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayFieldVector<Fraction>(data, false);    }    @Test    public void testEqualsAndHashCode() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> m1 = (SparseFieldMatrix<Fraction>) m.copy();        SparseFieldMatrix<Fraction> mt = (SparseFieldMatrix<Fraction>) m.transpose();        Assert.assertTrue(m.hashCode() != mt.hashCode());        Assert.assertEquals(m.hashCode(), m1.hashCode());        Assert.assertEquals(m, m);        Assert.assertEquals(m, m1);        Assert.assertFalse(m.equals(null));        Assert.assertFalse(m.equals(mt));        Assert.assertFalse(m.equals(createSparseMatrix(bigSingular)));    }    /* Disable for now    @Test    public void testToString() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        Assert.assertEquals("SparseFieldMatrix<Fraction>{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",            m.toString());        m = new SparseFieldMatrix<Fraction>(field, 1, 1);        Assert.assertEquals("SparseFieldMatrix<Fraction>{{0.0}}", m.toString());    }    */    @Test    public void testSetSubMatrix() throws Exception {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        m.setSubMatrix(detData2, 1, 1);        FieldMatrix<Fraction> expected = createSparseMatrix(new Fraction[][] {                { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(1), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } });        Assert.assertEquals(expected, m);        m.setSubMatrix(detData2, 0, 0);        expected = createSparseMatrix(new Fraction[][] {                { new Fraction(1), new Fraction(3), new Fraction(3) }, { new Fraction(2), new Fraction(4), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } });        Assert.assertEquals(expected, m);        m.setSubMatrix(testDataPlus2, 0, 0);        expected = createSparseMatrix(new Fraction[][] {                { new Fraction(3), new Fraction(4), new Fraction(5) }, { new Fraction(4), new Fraction(7), new Fraction(5) }, { new Fraction(3), new Fraction(2), new Fraction(10) } });        Assert.assertEquals(expected, m);        // javadoc example        SparseFieldMatrix<Fraction> matrix =            createSparseMatrix(new Fraction[][] {        { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8) }, { new Fraction(9), new Fraction(0), new Fraction(1), new Fraction(2) } });        matrix.setSubMatrix(new Fraction[][] { { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } }, 1, 1);        expected = createSparseMatrix(new Fraction[][] {                { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8) }, { new Fraction(9), new Fraction(5), new Fraction(6), new Fraction(2) } });        Assert.assertEquals(expected, matrix);        // dimension overflow        try {            m.setSubMatrix(testData, 1, 1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        // dimension underflow        try {            m.setSubMatrix(testData, -1, 1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        try {            m.setSubMatrix(testData, 1, -1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        // null        try {            m.setSubMatrix(null, 1, 1);            Assert.fail("expecting NullArgumentException");        } catch (NullArgumentException e) {            // expected        }        try {            new SparseFieldMatrix<Fraction>(field, 0, 0);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected        }        // ragged        try {            m.setSubMatrix(new Fraction[][] { { new Fraction(1) }, { new Fraction(2), new Fraction(3) } }, 0, 0);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected        }        // empty        try {            m.setSubMatrix(new Fraction[][] { {} }, 0, 0);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected        }    }    // --------------- -----------------Protected methods    /** verifies that two matrices are close (1-norm) */    protected void assertClose(String msg, FieldMatrix<Fraction> m, FieldMatrix<Fraction> n,            double tolerance) {        for(int i=0; i < m.getRowDimension(); i++){            for(int j=0; j < m.getColumnDimension(); j++){                Assert.assertEquals(msg, m.getEntry(i,j).doubleValue(), n.getEntry(i,j).doubleValue(), tolerance);            }        }    }    /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, Fraction[] m, Fraction[] n,            double tolerance) {        if (m.length != n.length) {            Assert.fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            Assert.assertEquals(msg + " " + i + " elements differ", m[i].doubleValue(), n[i].doubleValue(),                    tolerance);        }    }    private SparseFieldMatrix<Fraction> createSparseMatrix(Fraction[][] data) {        SparseFieldMatrix<Fraction> matrix = new SparseFieldMatrix<Fraction>(field, data.length, data[0].length);        for (int row = 0; row < data.length; row++) {            for (int col = 0; col < data[row].length; col++) {                matrix.setEntry(row, col, data[row][col]);            }        }        return matrix;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Arrays;import org.apache.commons.math.util.FastMath;import org.junit.Test;import org.junit.Assert;public class TriDiagonalTransformerTest {    private double[][] testSquare5 = {            { 1, 2, 3, 1, 1 },            { 2, 1, 1, 3, 1 },            { 3, 1, 1, 1, 2 },            { 1, 3, 1, 2, 1 },            { 1, 1, 2, 1, 3 }    };    private double[][] testSquare3 = {            { 1, 3, 4 },            { 3, 2, 2 },            { 4, 2, 0 }    };    @Test    public void testNonSquare() {        try {            new TriDiagonalTransformer(MatrixUtils.createRealMatrix(new double[3][2]));            Assert.fail("an exception should have been thrown");        } catch (NonSquareMatrixException ime) {            // expected behavior        }    }    @Test    public void testAEqualQTQt() {        checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare5));        checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare3));    }    private void checkAEqualQTQt(RealMatrix matrix) {        TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);        RealMatrix q  = transformer.getQ();        RealMatrix qT = transformer.getQT();        RealMatrix t  = transformer.getT();        double norm = q.multiply(t).multiply(qT).subtract(matrix).getNorm();        Assert.assertEquals(0, norm, 4.0e-15);    }    @Test    public void testNoAccessBelowDiagonal() {        checkNoAccessBelowDiagonal(testSquare5);        checkNoAccessBelowDiagonal(testSquare3);    }    private void checkNoAccessBelowDiagonal(double[][] data) {        double[][] modifiedData = new double[data.length][];        for (int i = 0; i < data.length; ++i) {            modifiedData[i] = data[i].clone();            Arrays.fill(modifiedData[i], 0, i, Double.NaN);        }        RealMatrix matrix = MatrixUtils.createRealMatrix(modifiedData);        TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);        RealMatrix q  = transformer.getQ();        RealMatrix qT = transformer.getQT();        RealMatrix t  = transformer.getT();        double norm = q.multiply(t).multiply(qT).subtract(MatrixUtils.createRealMatrix(data)).getNorm();        Assert.assertEquals(0, norm, 4.0e-15);    }    @Test    public void testQOrthogonal() {        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQ());        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQ());    }    @Test    public void testQTOrthogonal() {        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQT());        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQT());    }    private void checkOrthogonal(RealMatrix m) {        RealMatrix mTm = m.transpose().multiply(m);        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());        Assert.assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-15);    }    @Test    public void testTTriDiagonal() {        checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getT());        checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getT());    }    private void checkTriDiagonal(RealMatrix m) {        final int rows = m.getRowDimension();        final int cols = m.getColumnDimension();        for (int i = 0; i < rows; ++i) {            for (int j = 0; j < cols; ++j) {                if ((i < j - 1) || (i > j + 1)) {                    Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16);                }            }        }    }    @Test    public void testMatricesValues5() {        checkMatricesValues(testSquare5,                            new double[][] {                                { 1.0,  0.0,                 0.0,                  0.0,                   0.0 },                                { 0.0, -0.5163977794943222,  0.016748280772542083, 0.839800693771262,     0.16669620021405473 },                                { 0.0, -0.7745966692414833, -0.4354553000860955,  -0.44989322880603355,  -0.08930153582895772 },                                { 0.0, -0.2581988897471611,  0.6364346693566014,  -0.30263204032131164,   0.6608313651342882 },                                { 0.0, -0.2581988897471611,  0.6364346693566009,  -0.027289660803112598, -0.7263191580755246 }                            },                            new double[] { 1, 4.4, 1.433099579242636, -0.89537362758743, 2.062274048344794 },                            new double[] { -FastMath.sqrt(15), -3.0832882879592476, 0.6082710842351517, 1.1786086405912128 });    }    @Test    public void testMatricesValues3() {        checkMatricesValues(testSquare3,                            new double[][] {                                {  1.0,  0.0,  0.0 },                                {  0.0, -0.6,  0.8 },                                {  0.0, -0.8, -0.6 },                            },                            new double[] { 1, 2.64, -0.64 },                            new double[] { -5, -1.52 });    }    private void checkMatricesValues(double[][] matrix, double[][] qRef,                                     double[] mainDiagnonal,                                     double[] secondaryDiagonal) {        TriDiagonalTransformer transformer =            new TriDiagonalTransformer(MatrixUtils.createRealMatrix(matrix));        // check values against known references        RealMatrix q = transformer.getQ();        Assert.assertEquals(0, q.subtract(MatrixUtils.createRealMatrix(qRef)).getNorm(), 1.0e-14);        RealMatrix t = transformer.getT();        double[][] tData = new double[mainDiagnonal.length][mainDiagnonal.length];        for (int i = 0; i < mainDiagnonal.length; ++i) {            tData[i][i] = mainDiagnonal[i];            if (i > 0) {                tData[i][i - 1] = secondaryDiagonal[i - 1];            }            if (i < secondaryDiagonal.length) {                tData[i][i + 1] = secondaryDiagonal[i];            }        }        Assert.assertEquals(0, t.subtract(MatrixUtils.createRealMatrix(tData)).getNorm(), 1.0e-14);        // check the same cached instance is returned the second time        Assert.assertTrue(q == transformer.getQ());        Assert.assertTrue(t == transformer.getT());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Arrays;import java.util.Random;import org.junit.Test;import org.junit.Assert;import org.apache.commons.math.TestUtils;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.exception.OutOfRangeException;import org.apache.commons.math.exception.NoDataException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.exception.MathIllegalArgumentException;/** * Test cases for the {@link BlockRealMatrix} class. * * @version $Id$ */public final class BlockRealMatrixTest {    // 3 x 3 identity matrix    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };    // Test data for group operations    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},       {-1d,0d,-8d} };    protected double[] testDataRow1 = {1d,2d,3d};    protected double[] testDataCol3 = {3d,3d,8d};    protected double[][] testDataInv =        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };    protected double[] preMultTest = {8,12,33};    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};    protected double[][] testDataPlusInv =        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };    // lu decomposition tests    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},            {0.33333333333333,0d,0.33333333333333} };    // singular matrices    protected double[][] singular = { {2d,3d}, {2d,3d} };    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};    // vectors    protected double[] testVector = {1,2,3};    protected double[] testVector2 = {1,2,3,4};    // submatrix accessor tests    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},            {2, 4, 6, 8}, {4, 5, 6, 7}};    // array selections    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};    // effective permutations    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};    // contiguous ranges    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};    protected double[][] subRows23Cols00 = {{2} , {4}};    protected double[][] subRows00Cols33 = {{4}};    // row matrices    protected double[][] subRow0 = {{1,2,3,4}};    protected double[][] subRow3 = {{4,5,6,7}};    // column matrices    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    /** test dimensions */    @Test    public void testDimensions() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m2 = new BlockRealMatrix(testData2);        Assert.assertEquals("testData row dimension",3,m.getRowDimension());        Assert.assertEquals("testData column dimension",3,m.getColumnDimension());        Assert.assertTrue("testData is square",m.isSquare());        Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2);        Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        Assert.assertTrue("testData2 is not square",!m2.isSquare());    }    /** test copy functions */    @Test    public void testCopyFunctions() {        Random r = new Random(66636328996002l);        BlockRealMatrix m1 = createRandomMatrix(r, 47, 83);        BlockRealMatrix m2 = new BlockRealMatrix(m1.getData());        Assert.assertEquals(m1, m2);        BlockRealMatrix m3 = new BlockRealMatrix(testData);        BlockRealMatrix m4 = new BlockRealMatrix(m3.getData());        Assert.assertEquals(m3, m4);    }    /** test add */    @Test    public void testAdd() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);        RealMatrix mPlusMInv = m.add(mInv);        double[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                Assert.assertEquals("sum entry entry",                    testDataPlusInv[row][col],sumEntries[row][col],                        entryTolerance);            }        }    }    /** test add failure */    @Test    public void testAddFail() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m2 = new BlockRealMatrix(testData2);        try {            m.add(m2);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    /** test norm */    @Test    public void testNorm() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m2 = new BlockRealMatrix(testData2);        Assert.assertEquals("testData norm",14d,m.getNorm(),entryTolerance);        Assert.assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);    }    /** test Frobenius norm */    @Test    public void testFrobeniusNorm() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m2 = new BlockRealMatrix(testData2);        Assert.assertEquals("testData Frobenius norm", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);        Assert.assertEquals("testData2 Frobenius norm", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);    }    /** test m-n = m + -n */    @Test    public void testPlusMinus() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m2 = new BlockRealMatrix(testDataInv);        assertClose(m.subtract(m2), m2.scalarMultiply(-1d).add(m), entryTolerance);        try {            m.subtract(new BlockRealMatrix(testData2));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    /** test multiply */    @Test    public void testMultiply() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);        BlockRealMatrix identity = new BlockRealMatrix(id);        BlockRealMatrix m2 = new BlockRealMatrix(testData2);        assertClose(m.multiply(mInv), identity, entryTolerance);        assertClose(mInv.multiply(m), identity, entryTolerance);        assertClose(m.multiply(identity), m, entryTolerance);        assertClose(identity.multiply(mInv), mInv, entryTolerance);        assertClose(m2.multiply(identity), m2, entryTolerance);        try {            m.multiply(new BlockRealMatrix(bigSingular));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // expected        }    }    @Test    public void testSeveralBlocks() {        RealMatrix m = new BlockRealMatrix(35, 71);        for (int i = 0; i < m.getRowDimension(); ++i) {            for (int j = 0; j < m.getColumnDimension(); ++j) {                m.setEntry(i, j, i + j / 1024.0);            }        }        RealMatrix mT = m.transpose();        Assert.assertEquals(m.getRowDimension(), mT.getColumnDimension());        Assert.assertEquals(m.getColumnDimension(), mT.getRowDimension());        for (int i = 0; i < mT.getRowDimension(); ++i) {            for (int j = 0; j < mT.getColumnDimension(); ++j) {                Assert.assertEquals(m.getEntry(j, i), mT.getEntry(i, j), 0);            }        }        RealMatrix mPm = m.add(m);        for (int i = 0; i < mPm.getRowDimension(); ++i) {            for (int j = 0; j < mPm.getColumnDimension(); ++j) {                Assert.assertEquals(2 * m.getEntry(i, j), mPm.getEntry(i, j), 0);            }        }        RealMatrix mPmMm = mPm.subtract(m);        for (int i = 0; i < mPmMm.getRowDimension(); ++i) {            for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {                Assert.assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j), 0);            }        }        RealMatrix mTm = mT.multiply(m);        for (int i = 0; i < mTm.getRowDimension(); ++i) {            for (int j = 0; j < mTm.getColumnDimension(); ++j) {                double sum = 0;                for (int k = 0; k < mT.getColumnDimension(); ++k) {                    sum += (k + i / 1024.0) * (k + j / 1024.0);                }                Assert.assertEquals(sum, mTm.getEntry(i, j), 0);            }        }        RealMatrix mmT = m.multiply(mT);        for (int i = 0; i < mmT.getRowDimension(); ++i) {            for (int j = 0; j < mmT.getColumnDimension(); ++j) {                double sum = 0;                for (int k = 0; k < m.getColumnDimension(); ++k) {                    sum += (i + k / 1024.0) * (j + k / 1024.0);                }                Assert.assertEquals(sum, mmT.getEntry(i, j), 0);            }        }        RealMatrix sub1 = m.getSubMatrix(2, 9, 5, 20);        for (int i = 0; i < sub1.getRowDimension(); ++i) {            for (int j = 0; j < sub1.getColumnDimension(); ++j) {                Assert.assertEquals((i + 2) + (j + 5) / 1024.0, sub1.getEntry(i, j), 0);            }        }        RealMatrix sub2 = m.getSubMatrix(10, 12, 3, 70);        for (int i = 0; i < sub2.getRowDimension(); ++i) {            for (int j = 0; j < sub2.getColumnDimension(); ++j) {                Assert.assertEquals((i + 10) + (j + 3) / 1024.0, sub2.getEntry(i, j), 0);            }        }        RealMatrix sub3 = m.getSubMatrix(30, 34, 0, 5);        for (int i = 0; i < sub3.getRowDimension(); ++i) {            for (int j = 0; j < sub3.getColumnDimension(); ++j) {                Assert.assertEquals((i + 30) + (j + 0) / 1024.0, sub3.getEntry(i, j), 0);            }        }        RealMatrix sub4 = m.getSubMatrix(30, 32, 62, 65);        for (int i = 0; i < sub4.getRowDimension(); ++i) {            for (int j = 0; j < sub4.getColumnDimension(); ++j) {                Assert.assertEquals((i + 30) + (j + 62) / 1024.0, sub4.getEntry(i, j), 0);            }        }    }    //Additional Test for BlockRealMatrixTest.testMultiply    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};    private double[][] d4 = new double[][] {{1},{2},{3},{4}};    private double[][] d5 = new double[][] {{30},{70}};    @Test    public void testMultiply2() {        RealMatrix m3 = new BlockRealMatrix(d3);        RealMatrix m4 = new BlockRealMatrix(d4);        RealMatrix m5 = new BlockRealMatrix(d5);        assertClose(m3.multiply(m4), m5, entryTolerance);    }    /** test trace */    @Test    public void testTrace() {        RealMatrix m = new BlockRealMatrix(id);        Assert.assertEquals("identity trace",3d,m.getTrace(),entryTolerance);        m = new BlockRealMatrix(testData2);        try {            m.getTrace();            Assert.fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }    }    /** test scalarAdd */    @Test    public void testScalarAdd() {        RealMatrix m = new BlockRealMatrix(testData);        assertClose(new BlockRealMatrix(testDataPlus2), m.scalarAdd(2d), entryTolerance);    }    /** test operate */    @Test    public void testOperate() {        RealMatrix m = new BlockRealMatrix(id);        assertClose(testVector, m.operate(testVector), entryTolerance);        assertClose(testVector, m.operate(new ArrayRealVector(testVector)).getData(), entryTolerance);        m = new BlockRealMatrix(bigSingular);        try {            m.operate(testVector);            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    @Test    public void testOperateLarge() {        int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2;        int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2;        int r =  3 * BlockRealMatrix.BLOCK_SIZE;        Random random = new Random(111007463902334l);        RealMatrix m1 = createRandomMatrix(random, p, q);        RealMatrix m2 = createRandomMatrix(random, q, r);        RealMatrix m1m2 = m1.multiply(m2);        for (int i = 0; i < r; ++i) {            checkArrays(m1m2.getColumn(i), m1.operate(m2.getColumn(i)));        }    }    @Test    public void testOperatePremultiplyLarge() {        int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2;        int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2;        int r =  3 * BlockRealMatrix.BLOCK_SIZE;        Random random = new Random(111007463902334l);        RealMatrix m1 = createRandomMatrix(random, p, q);        RealMatrix m2 = createRandomMatrix(random, q, r);        RealMatrix m1m2 = m1.multiply(m2);        for (int i = 0; i < p; ++i) {            checkArrays(m1m2.getRow(i), m2.preMultiply(m1.getRow(i)));        }    }    /** test issue MATH-209 */    @Test    public void testMath209() {        RealMatrix a = new BlockRealMatrix(new double[][] {                { 1, 2 }, { 3, 4 }, { 5, 6 }        });        double[] b = a.operate(new double[] { 1, 1 });        Assert.assertEquals(a.getRowDimension(), b.length);        Assert.assertEquals( 3.0, b[0], 1.0e-12);        Assert.assertEquals( 7.0, b[1], 1.0e-12);        Assert.assertEquals(11.0, b[2], 1.0e-12);    }    /** test transpose */    @Test    public void testTranspose() {        RealMatrix m = new BlockRealMatrix(testData);        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();        assertClose(mIT, mTI, normTolerance);        m = new BlockRealMatrix(testData2);        RealMatrix mt = new BlockRealMatrix(testData2T);        assertClose(mt, m.transpose(), normTolerance);    }    /** test preMultiply by vector */    @Test    public void testPremultiplyVector() {        RealMatrix m = new BlockRealMatrix(testData);        assertClose(m.preMultiply(testVector), preMultTest, normTolerance);        assertClose(m.preMultiply(new ArrayRealVector(testVector).getData()),                    preMultTest, normTolerance);        m = new BlockRealMatrix(bigSingular);        try {            m.preMultiply(testVector);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    @Test    public void testPremultiply() {        RealMatrix m3 = new BlockRealMatrix(d3);        RealMatrix m4 = new BlockRealMatrix(d4);        RealMatrix m5 = new BlockRealMatrix(d5);        assertClose(m4.preMultiply(m3), m5, entryTolerance);        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);        BlockRealMatrix identity = new BlockRealMatrix(id);        assertClose(m.preMultiply(mInv), identity, entryTolerance);        assertClose(mInv.preMultiply(m), identity, entryTolerance);        assertClose(m.preMultiply(identity), m, entryTolerance);        assertClose(identity.preMultiply(mInv), mInv, entryTolerance);        try {            m.preMultiply(new BlockRealMatrix(bigSingular));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    @Test    public void testGetVectors() {        RealMatrix m = new BlockRealMatrix(testData);        assertClose(m.getRow(0), testDataRow1, entryTolerance);        assertClose(m.getColumn(2), testDataCol3, entryTolerance);        try {            m.getRow(10);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // ignored        }        try {            m.getColumn(-1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // ignored        }    }    @Test    public void testGetEntry() {        RealMatrix m = new BlockRealMatrix(testData);        Assert.assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);        try {            m.getEntry(10, 4);            Assert.fail ("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    /** test examples in user guide */    @Test    public void testExamples() {        // Create a real matrix with two rows and three columns        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};        RealMatrix m = new BlockRealMatrix(matrixData);        // One more with three rows, two columns        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};        RealMatrix n = new BlockRealMatrix(matrixData2);        // Now multiply m by n        RealMatrix p = m.multiply(n);        Assert.assertEquals(2, p.getRowDimension());        Assert.assertEquals(2, p.getColumnDimension());        // Invert p        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();        Assert.assertEquals(2, pInverse.getRowDimension());        Assert.assertEquals(2, pInverse.getColumnDimension());        // Solve example        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};        RealMatrix coefficients = new BlockRealMatrix(coefficientsData);        RealVector constants = new ArrayRealVector(new double[]{1, -2, 1}, false);        RealVector solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);        final double cst0 = constants.getEntry(0);        final double cst1 = constants.getEntry(1);        final double cst2 = constants.getEntry(2);        final double sol0 = solution.getEntry(0);        final double sol1 = solution.getEntry(1);        final double sol2 = solution.getEntry(2);        Assert.assertEquals(2 * sol0 + 3 * sol1 -2 * sol2, cst0, 1E-12);        Assert.assertEquals(-1 * sol0 + 7 * sol1 + 6 * sol2, cst1, 1E-12);        Assert.assertEquals(4 * sol0 - 3 * sol1 -5 * sol2, cst2, 1E-12);    }    // test submatrix accessors    @Test    public void testGetSubMatrix() {        RealMatrix m = new BlockRealMatrix(subTestData);        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkGetSubMatrix(m, null,  1, 0, 2, 4);        checkGetSubMatrix(m, null, -1, 1, 2, 2);        checkGetSubMatrix(m, null,  1, 0, 2, 2);        checkGetSubMatrix(m, null,  1, 0, 2, 4);        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 });        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 });    }    private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int startRow, int endRow, int startColumn, int endColumn) {        try {            RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);            if (reference != null) {                Assert.assertEquals(new BlockRealMatrix(reference), sub);            } else {                Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");            }        } catch (OutOfRangeException e) {            if (reference != null) {                throw e;            }        } catch (NumberIsTooSmallException e) {            if (reference != null) {                throw e;            }        } catch (NoDataException e) {            if (reference != null) {                throw e;            }        }    }    private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int[] selectedRows, int[] selectedColumns) {        try {            RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);            if (reference != null) {                Assert.assertEquals(new BlockRealMatrix(reference), sub);            } else {                Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallExceptiono r NoDataException");            }        } catch (OutOfRangeException e) {            if (reference != null) {                throw e;            }        } catch (NumberIsTooSmallException e) {            if (reference != null) {                throw e;            }        } catch (NoDataException e) {            if (reference != null) {                throw e;            }        }    }    @Test    public void testGetSetMatrixLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        RealMatrix sub = new BlockRealMatrix(n - 4, n - 4).scalarAdd(1);        m.setSubMatrix(sub.getData(), 2, 2);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {                    Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        Assert.assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));    }    @Test    public void testCopySubMatrix() {        RealMatrix m = new BlockRealMatrix(subTestData);        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkCopy(m, null,  1, 0, 2, 4);        checkCopy(m, null, -1, 1, 2, 2);        checkCopy(m, null,  1, 0, 2, 2);        checkCopy(m, null,  1, 0, 2, 4);        checkCopy(m, null, new int[] {},    new int[] { 0 });        checkCopy(m, null, new int[] { 0 }, new int[] { 4 });    }    private void checkCopy(RealMatrix m, double[][] reference,                           int startRow, int endRow, int startColumn, int endColumn) {        try {            double[][] sub = (reference == null) ?                             new double[1][1] :                             new double[reference.length][reference[0].length];            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);            if (reference != null) {                Assert.assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));            } else {                Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");            }        } catch (OutOfRangeException e) {            if (reference != null) {                throw e;            }        } catch (NumberIsTooSmallException e) {            if (reference != null) {                throw e;            }        } catch (NoDataException e) {            if (reference != null) {                throw e;            }        }    }    private void checkCopy(RealMatrix m, double[][] reference,                           int[] selectedRows, int[] selectedColumns) {        try {            double[][] sub = (reference == null) ?                    new double[1][1] :                    new double[reference.length][reference[0].length];            m.copySubMatrix(selectedRows, selectedColumns, sub);            if (reference != null) {                Assert.assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));            } else {                Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");            }        } catch (OutOfRangeException e) {            if (reference != null) {                throw e;            }        } catch (NumberIsTooSmallException e) {            if (reference != null) {                throw e;            }        } catch (NoDataException e) {            if (reference != null) {                throw e;            }        }    }    @Test    public void testGetRowMatrix() {        RealMatrix m     = new BlockRealMatrix(subTestData);        RealMatrix mRow0 = new BlockRealMatrix(subRow0);        RealMatrix mRow3 = new BlockRealMatrix(subRow3);        Assert.assertEquals("Row0", mRow0, m.getRowMatrix(0));        Assert.assertEquals("Row3", mRow3, m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getRowMatrix(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetRowMatrix() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealMatrix mRow3 = new BlockRealMatrix(subRow3);        Assert.assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowMatrix(0, mRow3);        Assert.assertEquals(mRow3, m.getRowMatrix(0));        try {            m.setRowMatrix(-1, mRow3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setRowMatrix(0, m);            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetSetRowMatrixLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        RealMatrix sub = new BlockRealMatrix(1, n).scalarAdd(1);        m.setRowMatrix(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        Assert.assertEquals(sub, m.getRowMatrix(2));    }    @Test    public void testGetColumnMatrix() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealMatrix mColumn1 = new BlockRealMatrix(subColumn1);        RealMatrix mColumn3 = new BlockRealMatrix(subColumn3);        Assert.assertEquals(mColumn1, m.getColumnMatrix(1));        Assert.assertEquals(mColumn3, m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getColumnMatrix(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetColumnMatrix() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealMatrix mColumn3 = new BlockRealMatrix(subColumn3);        Assert.assertNotSame(mColumn3, m.getColumnMatrix(1));        m.setColumnMatrix(1, mColumn3);        Assert.assertEquals(mColumn3, m.getColumnMatrix(1));        try {            m.setColumnMatrix(-1, mColumn3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setColumnMatrix(0, m);            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetSetColumnMatrixLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        RealMatrix sub = new BlockRealMatrix(n, 1).scalarAdd(1);        m.setColumnMatrix(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        Assert.assertEquals(sub, m.getColumnMatrix(2));    }    @Test    public void testGetRowVector() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealVector mRow0 = new ArrayRealVector(subRow0[0]);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        Assert.assertEquals(mRow0, m.getRowVector(0));        Assert.assertEquals(mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getRowVector(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetRowVector() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        Assert.assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowVector(0, mRow3);        Assert.assertEquals(mRow3, m.getRowVector(0));        try {            m.setRowVector(-1, mRow3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setRowVector(0, new ArrayRealVector(5));            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetSetRowVectorLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        RealVector sub = new ArrayRealVector(n, 1.0);        m.setRowVector(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        Assert.assertEquals(sub, m.getRowVector(2));    }    @Test    public void testGetColumnVector() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealVector mColumn1 = columnToVector(subColumn1);        RealVector mColumn3 = columnToVector(subColumn3);        Assert.assertEquals(mColumn1, m.getColumnVector(1));        Assert.assertEquals(mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getColumnVector(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetColumnVector() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealVector mColumn3 = columnToVector(subColumn3);        Assert.assertNotSame(mColumn3, m.getColumnVector(1));        m.setColumnVector(1, mColumn3);        Assert.assertEquals(mColumn3, m.getColumnVector(1));        try {            m.setColumnVector(-1, mColumn3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setColumnVector(0, new ArrayRealVector(5));            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetSetColumnVectorLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        RealVector sub = new ArrayRealVector(n, 1.0);        m.setColumnVector(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        Assert.assertEquals(sub, m.getColumnVector(2));    }    private RealVector columnToVector(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayRealVector(data, false);    }    @Test    public void testGetRow() {        RealMatrix m = new BlockRealMatrix(subTestData);        checkArrays(subRow0[0], m.getRow(0));        checkArrays(subRow3[0], m.getRow(3));        try {            m.getRow(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getRow(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetRow() {        RealMatrix m = new BlockRealMatrix(subTestData);        Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]);        m.setRow(0, subRow3[0]);        checkArrays(subRow3[0], m.getRow(0));        try {            m.setRow(-1, subRow3[0]);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setRow(0, new double[5]);            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetSetRowLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        double[] sub = new double[n];        Arrays.fill(sub, 1.0);        m.setRow(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        checkArrays(sub, m.getRow(2));    }    @Test    public void testGetColumn() {        RealMatrix m = new BlockRealMatrix(subTestData);        double[] mColumn1 = columnToArray(subColumn1);        double[] mColumn3 = columnToArray(subColumn3);        checkArrays(mColumn1, m.getColumn(1));        checkArrays(mColumn3, m.getColumn(3));        try {            m.getColumn(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getColumn(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetColumn() {        RealMatrix m = new BlockRealMatrix(subTestData);        double[] mColumn3 = columnToArray(subColumn3);        Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]);        m.setColumn(1, mColumn3);        checkArrays(mColumn3, m.getColumn(1));        try {            m.setColumn(-1, mColumn3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setColumn(0, new double[5]);            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetSetColumnLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        double[] sub = new double[n];        Arrays.fill(sub, 1.0);        m.setColumn(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    Assert.assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    Assert.assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        checkArrays(sub, m.getColumn(2));    }    private double[] columnToArray(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return data;    }    private void checkArrays(double[] expected, double[] actual) {        Assert.assertEquals(expected.length, actual.length);        for (int i = 0; i < expected.length; ++i) {            Assert.assertEquals(expected[i], actual[i], 0);        }    }    @Test    public void testEqualsAndHashCode() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m1 = m.copy();        BlockRealMatrix mt = m.transpose();        Assert.assertTrue(m.hashCode() != mt.hashCode());        Assert.assertEquals(m.hashCode(), m1.hashCode());        Assert.assertEquals(m, m);        Assert.assertEquals(m, m1);        Assert.assertFalse(m.equals(null));        Assert.assertFalse(m.equals(mt));        Assert.assertFalse(m.equals(new BlockRealMatrix(bigSingular)));    }    @Test    public void testToString() {        BlockRealMatrix m = new BlockRealMatrix(testData);        Assert.assertEquals("BlockRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",                m.toString());    }    @Test    public void testSetSubMatrix() throws Exception {        BlockRealMatrix m = new BlockRealMatrix(testData);        m.setSubMatrix(detData2,1,1);        RealMatrix expected = new BlockRealMatrix            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});        Assert.assertEquals(expected, m);        m.setSubMatrix(detData2,0,0);        expected = new BlockRealMatrix            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});        Assert.assertEquals(expected, m);        m.setSubMatrix(testDataPlus2,0,0);        expected = new BlockRealMatrix            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});        Assert.assertEquals(expected, m);        // javadoc example        BlockRealMatrix matrix = new BlockRealMatrix            (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});        matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1);        expected = new BlockRealMatrix            (new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}});        Assert.assertEquals(expected, matrix);        // dimension overflow        try {            m.setSubMatrix(testData,1,1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        // dimension underflow        try {            m.setSubMatrix(testData,-1,1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        try {            m.setSubMatrix(testData,1,-1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        // null        try {            m.setSubMatrix(null,1,1);            Assert.fail("expecting NullArgumentException");        } catch (NullArgumentException e) {            // expected        }        // ragged        try {            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected        }        // empty        try {            m.setSubMatrix(new double[][] {{}}, 0, 0);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected        }    }    @Test    public void testWalk() throws MathUserException {        int rows    = 150;        int columns = 75;        RealMatrix m = new BlockRealMatrix(rows, columns);        m.walkInRowOrder(new SetVisitor());        GetVisitor getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        Assert.assertEquals(rows * columns, getVisitor.getCount());        m = new BlockRealMatrix(rows, columns);        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            Assert.assertEquals(0.0, m.getEntry(i, 0), 0);            Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            Assert.assertEquals(0.0, m.getEntry(0, j), 0);            Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new BlockRealMatrix(rows, columns);        m.walkInColumnOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        Assert.assertEquals(rows * columns, getVisitor.getCount());        m = new BlockRealMatrix(rows, columns);        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            Assert.assertEquals(0.0, m.getEntry(i, 0), 0);            Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            Assert.assertEquals(0.0, m.getEntry(0, j), 0);            Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new BlockRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor);        Assert.assertEquals(rows * columns, getVisitor.getCount());        m = new BlockRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            Assert.assertEquals(0.0, m.getEntry(i, 0), 0);            Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            Assert.assertEquals(0.0, m.getEntry(0, j), 0);            Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new BlockRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor);        Assert.assertEquals(rows * columns, getVisitor.getCount());        m = new BlockRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            Assert.assertEquals(0.0, m.getEntry(i, 0), 0);            Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            Assert.assertEquals(0.0, m.getEntry(0, j), 0);            Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }    }    @Test    public void testSerial()  {        BlockRealMatrix m = new BlockRealMatrix(testData);        Assert.assertEquals(m,TestUtils.serializeAndRecover(m));    }    private static class SetVisitor extends DefaultRealMatrixChangingVisitor {        @Override        public double visit(int i, int j, double value) {            return i + j / 1024.0;        }    }    private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {        private int count = 0;        @Override        public void visit(int i, int j, double value) {            ++count;            Assert.assertEquals(i + j / 1024.0, value, 0.0);        }        public int getCount() {            return count;        }    }    //--------------- -----------------Protected methods    /** verifies that two matrices are close (1-norm) */    protected void assertClose(RealMatrix m, RealMatrix n, double tolerance) {        Assert.assertTrue(m.subtract(n).getNorm() < tolerance);    }    /** verifies that two vectors are close (sup norm) */    protected void assertClose(double[] m, double[] n, double tolerance) {        if (m.length != n.length) {            Assert.fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            Assert.assertEquals(m[i], n[i], tolerance);        }    }    private BlockRealMatrix createRandomMatrix(Random r, int rows, int columns) {        BlockRealMatrix m = new BlockRealMatrix(rows, columns);        for (int i = 0; i < rows; ++i) {            for (int j = 0; j < columns; ++j) {                m.setEntry(i, j, 200 * r.nextDouble() - 100);            }        }        return m;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.io.Serializable;import java.lang.reflect.Array;import org.apache.commons.math.Field;import org.apache.commons.math.FieldElement;import org.apache.commons.math.TestUtils;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.exception.OutOfRangeException;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionField;import org.junit.Assert;import org.junit.Test;/** * Test cases for the {@link ArrayFieldVector} class. * * @version $Id$ */public class ArrayFieldVectorTest {    //    protected Fraction[][] ma1 = {            {new Fraction(1), new Fraction(2), new Fraction(3)},            {new Fraction(4), new Fraction(5), new Fraction(6)},            {new Fraction(7), new Fraction(8), new Fraction(9)}    };    protected Fraction[] vec1 = {new Fraction(1), new Fraction(2), new Fraction(3)};    protected Fraction[] vec2 = {new Fraction(4), new Fraction(5), new Fraction(6)};    protected Fraction[] vec3 = {new Fraction(7), new Fraction(8), new Fraction(9)};    protected Fraction[] vec4 = { new Fraction(1), new Fraction(2), new Fraction(3),                                  new Fraction(4), new Fraction(5), new Fraction(6),                                  new Fraction(7), new Fraction(8), new Fraction(9)};    protected Fraction[] vec_null = {new Fraction(0), new Fraction(0), new Fraction(0)};    protected Fraction[] dvec1 = {new Fraction(1), new Fraction(2), new Fraction(3),                                  new Fraction(4), new Fraction(5), new Fraction(6),                                  new Fraction(7), new Fraction(8), new Fraction(9)};    protected Fraction[][] mat1 = {            {new Fraction(1), new Fraction(2), new Fraction(3)},            {new Fraction(4), new Fraction(5), new Fraction(6)},            {new Fraction(7), new Fraction(8), new Fraction(9)}    };    // Testclass to test the FieldVector<Fraction> interface    // only with enough content to support the test    public static class FieldVectorTestImpl<T extends FieldElement<T>>        implements FieldVector<T>, Serializable {        private static final long serialVersionUID = 3970959016014158539L;        private final Field<T> field;        /** Entries of the vector. */        protected T[] data;        /** Build an array of elements.         * @param length size of the array to build         * @return a new array         */        @SuppressWarnings("unchecked") // field is of type T        private T[] buildArray(final int length) {            return (T[]) Array.newInstance(field.getZero().getClass(), length);        }        public FieldVectorTestImpl(T[] d) {            field = d[0].getField();            data = d.clone();        }        public Field<T> getField() {            return field;        }        private UnsupportedOperationException unsupported() {            return new UnsupportedOperationException("Not supported, unneeded for test purposes");        }        public FieldVector<T> copy() {            throw unsupported();        }        public FieldVector<T> add(FieldVector<T> v) {            throw unsupported();        }        public FieldVector<T> add(T[] v) {            throw unsupported();        }        public FieldVector<T> subtract(FieldVector<T> v) {            throw unsupported();        }        public FieldVector<T> subtract(T[] v) {            throw unsupported();        }        public FieldVector<T> mapAdd(T d) {            throw unsupported();        }        public FieldVector<T> mapAddToSelf(T d) {            throw unsupported();        }        public FieldVector<T> mapSubtract(T d) {            throw unsupported();        }        public FieldVector<T> mapSubtractToSelf(T d) {            throw unsupported();        }        public FieldVector<T> mapMultiply(T d) {            T[] out = buildArray(data.length);            for (int i = 0; i < data.length; i++) {                out[i] = data[i].multiply(d);            }            return new FieldVectorTestImpl<T>(out);        }        public FieldVector<T> mapMultiplyToSelf(T d) {            throw unsupported();        }        public FieldVector<T> mapDivide(T d) {            throw unsupported();        }        public FieldVector<T> mapDivideToSelf(T d) {            throw unsupported();        }        public FieldVector<T> mapInv() {            throw unsupported();        }        public FieldVector<T> mapInvToSelf() {            throw unsupported();        }        public FieldVector<T> ebeMultiply(FieldVector<T> v) {            throw unsupported();        }        public FieldVector<T> ebeMultiply(T[] v) {            throw unsupported();        }        public FieldVector<T> ebeDivide(FieldVector<T> v) {            throw unsupported();        }        public FieldVector<T> ebeDivide(T[] v) {            throw unsupported();        }        public T[] getData() {            return data.clone();        }        public T dotProduct(FieldVector<T> v) {            T dot = field.getZero();            for (int i = 0; i < data.length; i++) {                dot = dot.add(data[i].multiply(v.getEntry(i)));            }            return dot;        }        public T dotProduct(T[] v) {            T dot = field.getZero();            for (int i = 0; i < data.length; i++) {                dot = dot.add(data[i].multiply(v[i]));            }            return dot;        }        public FieldVector<T> projection(FieldVector<T> v) {            throw unsupported();        }        public FieldVector<T> projection(T[] v) {            throw unsupported();        }        public FieldMatrix<T> outerProduct(FieldVector<T> v) {            throw unsupported();        }        public FieldMatrix<T> outerProduct(T[] v) {            throw unsupported();        }        public T getEntry(int index) {            return data[index];        }        public int getDimension() {            return data.length;        }        public FieldVector<T> append(FieldVector<T> v) {            throw unsupported();        }        public FieldVector<T> append(T d) {            throw unsupported();        }        public FieldVector<T> append(T[] a) {            throw unsupported();        }        public FieldVector<T> getSubVector(int index, int n) {            throw unsupported();        }        public void setEntry(int index, T value) {            throw unsupported();        }        public void setSubVector(int index, FieldVector<T> v) {            throw unsupported();        }        public void setSubVector(int index, T[] v) {            throw unsupported();        }        public void set(T value) {            throw unsupported();        }        public T[] toArray() {            throw unsupported();        }    }    @Test    public void testConstructors() {        ArrayFieldVector<Fraction> v0 = new ArrayFieldVector<Fraction>(FractionField.getInstance());        Assert.assertEquals(0, v0.getDimension());        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(FractionField.getInstance(), 7);        Assert.assertEquals(7, v1.getDimension());        Assert.assertEquals(new Fraction(0), v1.getEntry(6));        ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(5, new Fraction(123, 100));        Assert.assertEquals(5, v2.getDimension());        Assert.assertEquals(new Fraction(123, 100), v2.getEntry(4));        ArrayFieldVector<Fraction> v3 = new ArrayFieldVector<Fraction>(FractionField.getInstance(), vec1);        Assert.assertEquals(3, v3.getDimension());        Assert.assertEquals(new Fraction(2), v3.getEntry(1));        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(FractionField.getInstance(), vec4, 3, 2);        Assert.assertEquals(2, v4.getDimension());        Assert.assertEquals(new Fraction(4), v4.getEntry(0));        try {            new ArrayFieldVector<Fraction>(vec4, 8, 3);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected behavior        }        FieldVector<Fraction> v5_i = new ArrayFieldVector<Fraction>(dvec1);        Assert.assertEquals(9, v5_i.getDimension());        Assert.assertEquals(new Fraction(9), v5_i.getEntry(8));        ArrayFieldVector<Fraction> v5 = new ArrayFieldVector<Fraction>(dvec1);        Assert.assertEquals(9, v5.getDimension());        Assert.assertEquals(new Fraction(9), v5.getEntry(8));        ArrayFieldVector<Fraction> v6 = new ArrayFieldVector<Fraction>(dvec1, 3, 2);        Assert.assertEquals(2, v6.getDimension());        Assert.assertEquals(new Fraction(4), v6.getEntry(0));        try {            new ArrayFieldVector<Fraction>(dvec1, 8, 3);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected behavior        }        ArrayFieldVector<Fraction> v7 = new ArrayFieldVector<Fraction>(v1);        Assert.assertEquals(7, v7.getDimension());        Assert.assertEquals(new Fraction(0), v7.getEntry(6));        FieldVectorTestImpl<Fraction> v7_i = new FieldVectorTestImpl<Fraction>(vec1);        ArrayFieldVector<Fraction> v7_2 = new ArrayFieldVector<Fraction>(v7_i);        Assert.assertEquals(3, v7_2.getDimension());        Assert.assertEquals(new Fraction(2), v7_2.getEntry(1));        ArrayFieldVector<Fraction> v8 = new ArrayFieldVector<Fraction>(v1, true);        Assert.assertEquals(7, v8.getDimension());        Assert.assertEquals(new Fraction(0), v8.getEntry(6));        Assert.assertNotSame("testData not same object ", v1.data, v8.data);        ArrayFieldVector<Fraction> v8_2 = new ArrayFieldVector<Fraction>(v1, false);        Assert.assertEquals(7, v8_2.getDimension());        Assert.assertEquals(new Fraction(0), v8_2.getEntry(6));        Assert.assertArrayEquals(v1.data, v8_2.data);        ArrayFieldVector<Fraction> v9 = new ArrayFieldVector<Fraction>(v1, v3);        Assert.assertEquals(10, v9.getDimension());        Assert.assertEquals(new Fraction(1), v9.getEntry(7));    }    @Test    public void testDataInOut() {        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);        ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(vec2);        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4);        FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2);        FieldVector<Fraction> v_append_1 = v1.append(v2);        Assert.assertEquals(6, v_append_1.getDimension());        Assert.assertEquals(new Fraction(4), v_append_1.getEntry(3));        FieldVector<Fraction> v_append_2 = v1.append(new Fraction(2));        Assert.assertEquals(4, v_append_2.getDimension());        Assert.assertEquals(new Fraction(2), v_append_2.getEntry(3));        FieldVector<Fraction> v_append_3 = v1.append(vec2);        Assert.assertEquals(6, v_append_3.getDimension());        Assert.assertEquals(new Fraction(4), v_append_3.getEntry(3));        FieldVector<Fraction> v_append_4 = v1.append(v2_t);        Assert.assertEquals(6, v_append_4.getDimension());        Assert.assertEquals(new Fraction(4), v_append_4.getEntry(3));        FieldVector<Fraction> v_copy = v1.copy();        Assert.assertEquals(3, v_copy.getDimension());        Assert.assertNotSame("testData not same object ", v1.data, v_copy.getData());        Fraction[] a_frac = v1.toArray();        Assert.assertEquals(3, a_frac.length);        Assert.assertNotSame("testData not same object ", v1.data, a_frac);//      ArrayFieldVector<Fraction> vout4 = (ArrayFieldVector<Fraction>) v1.clone();//      Assert.assertEquals(3, vout4.getDimension());//      Assert.assertEquals(v1.data, vout4.data);        FieldVector<Fraction> vout5 = v4.getSubVector(3, 3);        Assert.assertEquals(3, vout5.getDimension());        Assert.assertEquals(new Fraction(5), vout5.getEntry(1));        try {            v4.getSubVector(3, 7);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException ex) {            // expected behavior        }        ArrayFieldVector<Fraction> v_set1 = (ArrayFieldVector<Fraction>) v1.copy();        v_set1.setEntry(1, new Fraction(11));        Assert.assertEquals(new Fraction(11), v_set1.getEntry(1));        try {            v_set1.setEntry(3, new Fraction(11));            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException ex) {            // expected behavior        }        ArrayFieldVector<Fraction> v_set2 = (ArrayFieldVector<Fraction>) v4.copy();        v_set2.set(3, v1);        Assert.assertEquals(new Fraction(1), v_set2.getEntry(3));        Assert.assertEquals(new Fraction(7), v_set2.getEntry(6));        try {            v_set2.set(7, v1);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException ex) {            // expected behavior        }        ArrayFieldVector<Fraction> v_set3 = (ArrayFieldVector<Fraction>) v1.copy();        v_set3.set(new Fraction(13));        Assert.assertEquals(new Fraction(13), v_set3.getEntry(2));        try {            v_set3.getEntry(23);            Assert.fail("ArrayIndexOutOfBoundsException expected");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected behavior        }        ArrayFieldVector<Fraction> v_set4 = (ArrayFieldVector<Fraction>) v4.copy();        v_set4.setSubVector(3, v2_t);        Assert.assertEquals(new Fraction(4), v_set4.getEntry(3));        Assert.assertEquals(new Fraction(7), v_set4.getEntry(6));        try {            v_set4.setSubVector(7, v2_t);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException ex) {            // expected behavior        }        ArrayFieldVector<Fraction> vout10 = (ArrayFieldVector<Fraction>) v1.copy();        ArrayFieldVector<Fraction> vout10_2 = (ArrayFieldVector<Fraction>) v1.copy();        Assert.assertEquals(vout10, vout10_2);        vout10_2.setEntry(0, new Fraction(11, 10));        Assert.assertNotSame(vout10, vout10_2);    }    @Test    public void testMapFunctions() {        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);        //octave =  v1 .+ 2.0        FieldVector<Fraction> v_mapAdd = v1.mapAdd(new Fraction(2));        Fraction[] result_mapAdd = {new Fraction(3), new Fraction(4), new Fraction(5)};        checkArray("compare vectors" ,result_mapAdd,v_mapAdd.getData());        //octave =  v1 .+ 2.0        FieldVector<Fraction> v_mapAddToSelf = v1.copy();        v_mapAddToSelf.mapAddToSelf(new Fraction(2));        Fraction[] result_mapAddToSelf = {new Fraction(3), new Fraction(4), new Fraction(5)};        checkArray("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData());        //octave =  v1 .- 2.0        FieldVector<Fraction> v_mapSubtract = v1.mapSubtract(new Fraction(2));        Fraction[] result_mapSubtract = {new Fraction(-1), new Fraction(0), new Fraction(1)};        checkArray("compare vectors" ,result_mapSubtract,v_mapSubtract.getData());        //octave =  v1 .- 2.0        FieldVector<Fraction> v_mapSubtractToSelf = v1.copy();        v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));        Fraction[] result_mapSubtractToSelf = {new Fraction(-1), new Fraction(0), new Fraction(1)};        checkArray("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData());        //octave =  v1 .* 2.0        FieldVector<Fraction> v_mapMultiply = v1.mapMultiply(new Fraction(2));        Fraction[] result_mapMultiply = {new Fraction(2), new Fraction(4), new Fraction(6)};        checkArray("compare vectors" ,result_mapMultiply,v_mapMultiply.getData());        //octave =  v1 .* 2.0        FieldVector<Fraction> v_mapMultiplyToSelf = v1.copy();        v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));        Fraction[] result_mapMultiplyToSelf = {new Fraction(2), new Fraction(4), new Fraction(6)};        checkArray("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());        //octave =  v1 ./ 2.0        FieldVector<Fraction> v_mapDivide = v1.mapDivide(new Fraction(2));        Fraction[] result_mapDivide = {new Fraction(1, 2), new Fraction(1), new Fraction(3, 2)};        checkArray("compare vectors" ,result_mapDivide,v_mapDivide.getData());        //octave =  v1 ./ 2.0        FieldVector<Fraction> v_mapDivideToSelf = v1.copy();        v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));        Fraction[] result_mapDivideToSelf = {new Fraction(1, 2), new Fraction(1), new Fraction(3, 2)};        checkArray("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData());        //octave =  v1 .^-1        FieldVector<Fraction> v_mapInv = v1.mapInv();        Fraction[] result_mapInv = {new Fraction(1),new Fraction(1, 2),new Fraction(1, 3)};        checkArray("compare vectors" ,result_mapInv,v_mapInv.getData());        //octave =  v1 .^-1        FieldVector<Fraction> v_mapInvToSelf = v1.copy();        v_mapInvToSelf.mapInvToSelf();        Fraction[] result_mapInvToSelf = {new Fraction(1),new Fraction(1, 2),new Fraction(1, 3)};        checkArray("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData());    }    @Test    public void testBasicFunctions() {        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);        ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(vec2);        new ArrayFieldVector<Fraction>(vec_null);        FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2);        //octave =  v1 + v2        ArrayFieldVector<Fraction> v_add = v1.add(v2);        Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)};        checkArray("compare vect" ,v_add.getData(),result_add);        FieldVectorTestImpl<Fraction> vt2 = new FieldVectorTestImpl<Fraction>(vec2);        FieldVector<Fraction> v_add_i = v1.add(vt2);        Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)};        checkArray("compare vect" ,v_add_i.getData(),result_add_i);        //octave =  v1 - v2        ArrayFieldVector<Fraction> v_subtract = v1.subtract(v2);        Fraction[] result_subtract = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};        checkArray("compare vect" ,v_subtract.getData(),result_subtract);        FieldVector<Fraction> v_subtract_i = v1.subtract(vt2);        Fraction[] result_subtract_i = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};        checkArray("compare vect" ,v_subtract_i.getData(),result_subtract_i);        // octave v1 .* v2        ArrayFieldVector<Fraction>  v_ebeMultiply = v1.ebeMultiply(v2);        Fraction[] result_ebeMultiply = {new Fraction(4), new Fraction(10), new Fraction(18)};        checkArray("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply);        FieldVector<Fraction>  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);        Fraction[] result_ebeMultiply_2 = {new Fraction(4), new Fraction(10), new Fraction(18)};        checkArray("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2);        // octave v1 ./ v2        ArrayFieldVector<Fraction>  v_ebeDivide = v1.ebeDivide(v2);        Fraction[] result_ebeDivide = {new Fraction(1, 4), new Fraction(2, 5), new Fraction(1, 2)};        checkArray("compare vect" ,v_ebeDivide.getData(),result_ebeDivide);        FieldVector<Fraction>  v_ebeDivide_2 = v1.ebeDivide(v2_t);        Fraction[] result_ebeDivide_2 = {new Fraction(1, 4), new Fraction(2, 5), new Fraction(1, 2)};        checkArray("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2);        // octave  dot(v1,v2)        Fraction dot =  v1.dotProduct(v2);        Assert.assertEquals("compare val ",new Fraction(32), dot);        // octave  dot(v1,v2_t)        Fraction dot_2 =  v1.dotProduct(v2_t);        Assert.assertEquals("compare val ",new Fraction(32), dot_2);        FieldMatrix<Fraction> m_outerProduct = v1.outerProduct(v2);        Assert.assertEquals("compare val ",new Fraction(4), m_outerProduct.getEntry(0,0));        FieldMatrix<Fraction> m_outerProduct_2 = v1.outerProduct(v2_t);        Assert.assertEquals("compare val ",new Fraction(4), m_outerProduct_2.getEntry(0,0));        ArrayFieldVector<Fraction> v_projection = v1.projection(v2);        Fraction[] result_projection = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)};        checkArray("compare vect", v_projection.getData(), result_projection);        FieldVector<Fraction> v_projection_2 = v1.projection(v2_t);        Fraction[] result_projection_2 = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)};        checkArray("compare vect", v_projection_2.getData(), result_projection_2);    }    @Test    public void testMisc() {        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4);        FieldVector<Fraction> v4_2 = new ArrayFieldVector<Fraction>(vec4);        String out1 = v1.toString();        Assert.assertTrue("some output ",  out1.length()!=0);        /*         Fraction[] dout1 = v1.copyOut();        Assert.assertEquals(3, dout1.length);        assertNotSame("testData not same object ", v1.data, dout1);         */        try {            v1.checkVectorDimensions(2);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected behavior        }       try {            v1.checkVectorDimensions(v4);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected behavior        }        try {            v1.checkVectorDimensions(v4_2);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected behavior        }    }    @Test    public void testSerial()  {        ArrayFieldVector<Fraction> v = new ArrayFieldVector<Fraction>(vec1);        Assert.assertEquals(v,TestUtils.serializeAndRecover(v));    }    @Test    public void testZeroVectors() {        // when the field is not specified, array cannot be empty        try {            new ArrayFieldVector<Fraction>(new Fraction[0]);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected behavior        }        try {            new ArrayFieldVector<Fraction>(new Fraction[0], true);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected behavior        }        try {            new ArrayFieldVector<Fraction>(new Fraction[0], false);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // expected behavior        }        // when the field is specified, array can be empty        Assert.assertEquals(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), new Fraction[0]).getDimension());        Assert.assertEquals(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), new Fraction[0], true).getDimension());        Assert.assertEquals(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), new Fraction[0], false).getDimension());    }    @Test    public void testOuterProduct() {        final ArrayFieldVector<Fraction> u            = new ArrayFieldVector<Fraction>(FractionField.getInstance(),                                             new Fraction[] {new Fraction(1),                                                             new Fraction(2),                                                             new Fraction(-3)});        final ArrayFieldVector<Fraction> v            = new ArrayFieldVector<Fraction>(FractionField.getInstance(),                                             new Fraction[] {new Fraction(4),                                                             new Fraction(-2)});        final FieldMatrix<Fraction> uv = u.outerProduct(v);        final double tol = Math.ulp(1d);        Assert.assertEquals(new Fraction(4).doubleValue(), uv.getEntry(0, 0).doubleValue(), tol);        Assert.assertEquals(new Fraction(-2).doubleValue(), uv.getEntry(0, 1).doubleValue(), tol);        Assert.assertEquals(new Fraction(8).doubleValue(), uv.getEntry(1, 0).doubleValue(), tol);        Assert.assertEquals(new Fraction(-4).doubleValue(), uv.getEntry(1, 1).doubleValue(), tol);        Assert.assertEquals(new Fraction(-12).doubleValue(), uv.getEntry(2, 0).doubleValue(), tol);        Assert.assertEquals(new Fraction(6).doubleValue(), uv.getEntry(2, 1).doubleValue(), tol);    }    /** verifies that two vectors are equals */    protected void checkArray(String msg, Fraction[] m, Fraction[] n) {        if (m.length != n.length) {            Assert.fail("vectors have different lengths");        }        for (int i = 0; i < m.length; i++) {            Assert.assertEquals(msg + " " +  i + " elements differ", m[i],n[i]);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.junit.Assert;import org.junit.Test;/** * Test for {@link MatrixDimensionMismatchException}. *  * @version $Id$ */public class MatrixDimensionMismatchExceptionTest {    @Test    public void testAccessors() {        final MatrixDimensionMismatchException e            = new MatrixDimensionMismatchException(1, 2, 3, 4);        Assert.assertEquals(1, e.getWrongRowDimension());        Assert.assertEquals(2, e.getWrongColumnDimension());        Assert.assertEquals(3, e.getExpectedRowDimension());        Assert.assertEquals(4, e.getExpectedColumnDimension());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.junit.Test;import org.junit.Assert;import org.apache.commons.math.TestUtils;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionField;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.exception.MathIllegalStateException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.NoDataException;import org.apache.commons.math.exception.OutOfRangeException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.exception.NotStrictlyPositiveException;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.exception.MathIllegalArgumentException;/** * Test cases for the {@link Array2DRowFieldMatrix} class. * * @version $Id$ */public final class FieldMatrixImplTest {    // 3 x 3 identity matrix    protected Fraction[][] id = { {new Fraction(1),new Fraction(0),new Fraction(0)}, {new Fraction(0),new Fraction(1),new Fraction(0)}, {new Fraction(0),new Fraction(0),new Fraction(1)} };    // Test data for group operations    protected Fraction[][] testData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)}, {new Fraction(1),new Fraction(0),new Fraction(8)} };    protected Fraction[][] testDataLU = {{new Fraction(2), new Fraction(5), new Fraction(3)}, {new Fraction(1, 2), new Fraction(-5, 2), new Fraction(13, 2)}, {new Fraction(1, 2), new Fraction(1, 5), new Fraction(1, 5)}};    protected Fraction[][] testDataPlus2 = { {new Fraction(3),new Fraction(4),new Fraction(5)}, {new Fraction(4),new Fraction(7),new Fraction(5)}, {new Fraction(3),new Fraction(2),new Fraction(10)} };    protected Fraction[][] testDataMinus = { {new Fraction(-1),new Fraction(-2),new Fraction(-3)}, {new Fraction(-2),new Fraction(-5),new Fraction(-3)},       {new Fraction(-1),new Fraction(0),new Fraction(-8)} };    protected Fraction[] testDataRow1 = {new Fraction(1),new Fraction(2),new Fraction(3)};    protected Fraction[] testDataCol3 = {new Fraction(3),new Fraction(3),new Fraction(8)};    protected Fraction[][] testDataInv =        { {new Fraction(-40),new Fraction(16),new Fraction(9)}, {new Fraction(13),new Fraction(-5),new Fraction(-3)}, {new Fraction(5),new Fraction(-2),new Fraction(-1)} };    protected Fraction[] preMultTest = {new Fraction(8),new Fraction(12),new Fraction(33)};    protected Fraction[][] testData2 ={ {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)}};    protected Fraction[][] testData2T = { {new Fraction(1),new Fraction(2)}, {new Fraction(2),new Fraction(5)}, {new Fraction(3),new Fraction(3)}};    protected Fraction[][] testDataPlusInv =        { {new Fraction(-39),new Fraction(18),new Fraction(12)}, {new Fraction(15),new Fraction(0),new Fraction(0)}, {new Fraction(6),new Fraction(-2),new Fraction(7)} };    // lu decomposition tests    protected Fraction[][] luData = { {new Fraction(2),new Fraction(3),new Fraction(3)}, {new Fraction(0),new Fraction(5),new Fraction(7)}, {new Fraction(6),new Fraction(9),new Fraction(8)} };    protected Fraction[][] luDataLUDecomposition = { {new Fraction(6),new Fraction(9),new Fraction(8)}, {new Fraction(0),new Fraction(5),new Fraction(7)},            {new Fraction(1, 3),new Fraction(0),new Fraction(1, 3)} };    // singular matrices    protected Fraction[][] singular = { {new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(3)} };    protected Fraction[][] bigSingular = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}, {new Fraction(2),new Fraction(5),new Fraction(3),new Fraction(4)},        {new Fraction(7),new Fraction(3),new Fraction(256),new Fraction(1930)}, {new Fraction(3),new Fraction(7),new Fraction(6),new Fraction(8)}}; // 4th row = 1st + 2nd    protected Fraction[][] detData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(4),new Fraction(5),new Fraction(6)}, {new Fraction(7),new Fraction(8),new Fraction(10)} };    protected Fraction[][] detData2 = { {new Fraction(1), new Fraction(3)}, {new Fraction(2), new Fraction(4)}};    // vectors    protected Fraction[] testVector = {new Fraction(1),new Fraction(2),new Fraction(3)};    protected Fraction[] testVector2 = {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)};    // submatrix accessor tests    protected Fraction[][] subTestData = {{new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)}, {new Fraction(3, 2), new Fraction(5, 2), new Fraction(7, 2), new Fraction(9, 2)},            {new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8)}, {new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7)}};    // array selections    protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4)}, {new Fraction(4), new Fraction(8)}};    protected Fraction[][] subRows03Cols12 = { {new Fraction(2), new Fraction(3)}, {new Fraction(5), new Fraction(6)}};    protected Fraction[][] subRows03Cols123 = { {new Fraction(2), new Fraction(3), new Fraction(4)} , {new Fraction(5), new Fraction(6), new Fraction(7)}};    // effective permutations    protected Fraction[][] subRows20Cols123 = { {new Fraction(4), new Fraction(6), new Fraction(8)} , {new Fraction(2), new Fraction(3), new Fraction(4)}};    protected Fraction[][] subRows31Cols31 = {{new Fraction(7), new Fraction(5)}, {new Fraction(9, 2), new Fraction(5, 2)}};    // contiguous ranges    protected Fraction[][] subRows01Cols23 = {{new Fraction(3),new Fraction(4)} , {new Fraction(7, 2), new Fraction(9, 2)}};    protected Fraction[][] subRows23Cols00 = {{new Fraction(2)} , {new Fraction(4)}};    protected Fraction[][] subRows00Cols33 = {{new Fraction(4)}};    // row matrices    protected Fraction[][] subRow0 = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}};    protected Fraction[][] subRow3 = {{new Fraction(4),new Fraction(5),new Fraction(6),new Fraction(7)}};    // column matrices    protected Fraction[][] subColumn1 = {{new Fraction(2)}, {new Fraction(5, 2)}, {new Fraction(4)}, {new Fraction(5)}};    protected Fraction[][] subColumn3 = {{new Fraction(4)}, {new Fraction(9, 2)}, {new Fraction(8)}, {new Fraction(7)}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    /** test dimensions */    @Test    public void testDimensions() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);        Assert.assertEquals("testData row dimension",3,m.getRowDimension());        Assert.assertEquals("testData column dimension",3,m.getColumnDimension());        Assert.assertTrue("testData is square",m.isSquare());        Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2);        Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        Assert.assertTrue("testData2 is not square",!m2.isSquare());    }    /** test copy functions */    @Test    public void testCopyFunctions() {        Array2DRowFieldMatrix<Fraction> m1 = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(m1.getData());        Assert.assertEquals(m2,m1);        Array2DRowFieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(m3.getData(), false);        Assert.assertEquals(m4,m3);    }    /** test add */    @Test    public void testAdd() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);        FieldMatrix<Fraction> mPlusMInv = m.add(mInv);        Fraction[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                Assert.assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);            }        }    }    /** test add failure */    @Test    public void testAddFail() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);        try {            m.add(m2);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }     /** test m-n = m + -n */    @Test    public void testPlusMinus() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testDataInv);        TestUtils.assertEquals(m.subtract(m2),m2.scalarMultiply(new Fraction(-1)).add(m));        try {            m.subtract(new Array2DRowFieldMatrix<Fraction>(testData2));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    /** test multiply */    @Test     public void testMultiply() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);        Array2DRowFieldMatrix<Fraction> identity = new Array2DRowFieldMatrix<Fraction>(id);        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);        TestUtils.assertEquals(m.multiply(mInv), identity);        TestUtils.assertEquals(mInv.multiply(m), identity);        TestUtils.assertEquals(m.multiply(identity), m);        TestUtils.assertEquals(identity.multiply(mInv), mInv);        TestUtils.assertEquals(m2.multiply(identity), m2);        try {            m.multiply(new Array2DRowFieldMatrix<Fraction>(bigSingular));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    //Additional Test for Array2DRowFieldMatrix<Fraction>Test.testMultiply    private Fraction[][] d3 = new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},{new Fraction(5),new Fraction(6),new Fraction(7),new Fraction(8)}};    private Fraction[][] d4 = new Fraction[][] {{new Fraction(1)},{new Fraction(2)},{new Fraction(3)},{new Fraction(4)}};    private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}};    @Test    public void testMultiply2() {       FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3);       FieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(d4);       FieldMatrix<Fraction> m5 = new Array2DRowFieldMatrix<Fraction>(d5);       TestUtils.assertEquals(m3.multiply(m4), m5);   }    @Test    public void testPower() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        FieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);        FieldMatrix<Fraction> mPlusInv = new Array2DRowFieldMatrix<Fraction>(testDataPlusInv);        FieldMatrix<Fraction> identity = new Array2DRowFieldMatrix<Fraction>(id);                TestUtils.assertEquals(m.power(0), identity);                TestUtils.assertEquals(mInv.power(0), identity);                TestUtils.assertEquals(mPlusInv.power(0), identity);                TestUtils.assertEquals(m.power(1), m);                TestUtils.assertEquals(mInv.power(1), mInv);                TestUtils.assertEquals(mPlusInv.power(1), mPlusInv);                 FieldMatrix<Fraction> C1 = m.copy();        FieldMatrix<Fraction> C2 = mInv.copy();        FieldMatrix<Fraction> C3 = mPlusInv.copy();                // stop at 5 to avoid overflow        for (int i = 2; i <= 5; ++i) {            C1 = C1.multiply(m);            C2 = C2.multiply(mInv);            C3 = C3.multiply(mPlusInv);                        TestUtils.assertEquals(m.power(i), C1);                    TestUtils.assertEquals(mInv.power(i), C2);                    TestUtils.assertEquals(mPlusInv.power(i), C3);                    }                try {            FieldMatrix<Fraction> mNotSquare = new Array2DRowFieldMatrix<Fraction>(testData2T);            mNotSquare.power(2);            Assert.fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }                try {            m.power(-1);            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test trace */    @Test    public void testTrace() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(id);        Assert.assertEquals("identity trace",new Fraction(3),m.getTrace());        m = new Array2DRowFieldMatrix<Fraction>(testData2);        try {            m.getTrace();            Assert.fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }    }    /** test sclarAdd */    @Test    public void testScalarAdd() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(new Array2DRowFieldMatrix<Fraction>(testDataPlus2), m.scalarAdd(new Fraction(2)));    }    /** test operate */    @Test    public void testOperate() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(id);        TestUtils.assertEquals(testVector, m.operate(testVector));        TestUtils.assertEquals(testVector, m.operate(new ArrayFieldVector<Fraction>(testVector)).getData());        m = new Array2DRowFieldMatrix<Fraction>(bigSingular);        try {            m.operate(testVector);            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    /** test issue MATH-209 */    @Test    public void testMath209() {        FieldMatrix<Fraction> a = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) }        }, false);        Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });        Assert.assertEquals(a.getRowDimension(), b.length);        Assert.assertEquals( new Fraction(3), b[0]);        Assert.assertEquals( new Fraction(7), b[1]);        Assert.assertEquals(new Fraction(11), b[2]);    }    /** test transpose */    @Test    public void testTranspose() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();        TestUtils.assertEquals(mIT, mTI);        m = new Array2DRowFieldMatrix<Fraction>(testData2);        FieldMatrix<Fraction> mt = new Array2DRowFieldMatrix<Fraction>(testData2T);        TestUtils.assertEquals(mt, m.transpose());    }    /** test preMultiply by vector */    @Test    public void testPremultiplyVector() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(m.preMultiply(testVector), preMultTest);        TestUtils.assertEquals(m.preMultiply(new ArrayFieldVector<Fraction>(testVector).getData()),                               preMultTest);        m = new Array2DRowFieldMatrix<Fraction>(bigSingular);        try {            m.preMultiply(testVector);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    @Test    public void testPremultiply() {        FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3);        FieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(d4);        FieldMatrix<Fraction> m5 = new Array2DRowFieldMatrix<Fraction>(d5);        TestUtils.assertEquals(m4.preMultiply(m3), m5);        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);        Array2DRowFieldMatrix<Fraction> identity = new Array2DRowFieldMatrix<Fraction>(id);        TestUtils.assertEquals(m.preMultiply(mInv), identity);        TestUtils.assertEquals(mInv.preMultiply(m), identity);        TestUtils.assertEquals(m.preMultiply(identity), m);        TestUtils.assertEquals(identity.preMultiply(mInv), mInv);        try {            m.preMultiply(new Array2DRowFieldMatrix<Fraction>(bigSingular));            Assert.fail("Expecting illegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    @Test    public void testGetVectors() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(m.getRow(0), testDataRow1);        TestUtils.assertEquals(m.getColumn(2), testDataCol3);        try {            m.getRow(10);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // ignored        }        try {            m.getColumn(-1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // ignored        }    }    @Test    public void testGetEntry() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Assert.assertEquals("get entry", m.getEntry(0,1), new Fraction(2));        try {            m.getEntry(10, 4);            Assert.fail ("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    /** test examples in user guide */    @Test    public void testExamples() {        // Create a real matrix with two rows and three columns        Fraction[][] matrixData = {                {new Fraction(1),new Fraction(2),new Fraction(3)},                {new Fraction(2),new Fraction(5),new Fraction(3)}        };        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(matrixData);        // One more with three rows, two columns        Fraction[][] matrixData2 = {                {new Fraction(1),new Fraction(2)},                {new Fraction(2),new Fraction(5)},                {new Fraction(1), new Fraction(7)}        };        FieldMatrix<Fraction> n = new Array2DRowFieldMatrix<Fraction>(matrixData2);        // Now multiply m by n        FieldMatrix<Fraction> p = m.multiply(n);        Assert.assertEquals(2, p.getRowDimension());        Assert.assertEquals(2, p.getColumnDimension());        // Invert p        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();        Assert.assertEquals(2, pInverse.getRowDimension());        Assert.assertEquals(2, pInverse.getColumnDimension());        // Solve example        Fraction[][] coefficientsData = {                {new Fraction(2), new Fraction(3), new Fraction(-2)},                {new Fraction(-1), new Fraction(7), new Fraction(6)},                {new Fraction(4), new Fraction(-3), new Fraction(-5)}        };        FieldMatrix<Fraction> coefficients = new Array2DRowFieldMatrix<Fraction>(coefficientsData);        Fraction[] constants = {new Fraction(1), new Fraction(-2), new Fraction(1)};        Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);        Assert.assertEquals(new Fraction(2).multiply(solution[0]).                     add(new Fraction(3).multiply(solution[1])).                     subtract(new Fraction(2).multiply(solution[2])), constants[0]);        Assert.assertEquals(new Fraction(-1).multiply(solution[0]).                     add(new Fraction(7).multiply(solution[1])).                     add(new Fraction(6).multiply(solution[2])), constants[1]);        Assert.assertEquals(new Fraction(4).multiply(solution[0]).                     subtract(new Fraction(3).multiply(solution[1])).                     subtract(new Fraction(5).multiply(solution[2])), constants[2]);    }    // test submatrix accessors    @Test    public void testGetSubMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkGetSubMatrix(m, null,  1, 0, 2, 4);        checkGetSubMatrix(m, null, -1, 1, 2, 2);        checkGetSubMatrix(m, null,  1, 0, 2, 2);        checkGetSubMatrix(m, null,  1, 0, 2, 4);        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 });        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 });    }    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,                                   int startRow, int endRow, int startColumn, int endColumn) {        try {            FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);            if (reference != null) {                Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);            } else {                Assert.fail("Expecting OutOfRangeException or NotStrictlyPositiveException"                     + " or NumberIsTooSmallException or NoDataException");            }        } catch (OutOfRangeException e) {            if (reference != null) {                throw e;            }        } catch (NotStrictlyPositiveException e) {            if (reference != null) {                throw e;            }        } catch (NumberIsTooSmallException e) {            if (reference != null) {                throw e;            }        } catch (NoDataException e) {            if (reference != null) {                throw e;            }        }    }    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,                                   int[] selectedRows, int[] selectedColumns) {        try {            FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);            if (reference != null) {                Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);            } else {                Assert.fail("Expecting OutOfRangeException or NotStrictlyPositiveException"                     + " or NumberIsTooSmallException or NoDataException");            }        } catch (OutOfRangeException e) {            if (reference != null) {                throw e;            }        } catch (NotStrictlyPositiveException e) {            if (reference != null) {                throw e;            }        } catch (NumberIsTooSmallException e) {            if (reference != null) {                throw e;            }        } catch (NoDataException e) {            if (reference != null) {                throw e;            }        }    }    @Test    public void testCopySubMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkCopy(m, null,  1, 0, 2, 4);        checkCopy(m, null, -1, 1, 2, 2);        checkCopy(m, null,  1, 0, 2, 2);        checkCopy(m, null,  1, 0, 2, 4);        checkCopy(m, null, new int[] {},    new int[] { 0 });        checkCopy(m, null, new int[] { 0 }, new int[] { 4 });    }    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,                           int startRow, int endRow, int startColumn, int endColumn) {        try {            Fraction[][] sub = (reference == null) ?                             new Fraction[1][1] :                             new Fraction[reference.length][reference[0].length];            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);            if (reference != null) {                Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));            } else {                Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");            }        } catch (OutOfRangeException e) {            if (reference != null) {                throw e;            }        } catch (NumberIsTooSmallException e) {            if (reference != null) {                throw e;            }        } catch (NoDataException e) {            if (reference != null) {                throw e;            }        }    }    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,                           int[] selectedRows, int[] selectedColumns) {        try {            Fraction[][] sub = (reference == null) ?                    new Fraction[1][1] :                    new Fraction[reference.length][reference[0].length];            m.copySubMatrix(selectedRows, selectedColumns, sub);            if (reference != null) {                Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));            } else {                Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException");            }        } catch (OutOfRangeException e) {            if (reference != null) {                throw e;            }        } catch (NumberIsTooSmallException e) {            if (reference != null) {                throw e;            }        } catch (NoDataException e) {            if (reference != null) {                throw e;            }        }    }    @Test    public void testGetRowMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mRow0 = new Array2DRowFieldMatrix<Fraction>(subRow0);        FieldMatrix<Fraction> mRow3 = new Array2DRowFieldMatrix<Fraction>(subRow3);        Assert.assertEquals("Row0", mRow0,                m.getRowMatrix(0));        Assert.assertEquals("Row3", mRow3,                m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getRowMatrix(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetRowMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mRow3 = new Array2DRowFieldMatrix<Fraction>(subRow3);        Assert.assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowMatrix(0, mRow3);        Assert.assertEquals(mRow3, m.getRowMatrix(0));        try {            m.setRowMatrix(-1, mRow3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setRowMatrix(0, m);            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetColumnMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mColumn1 = new Array2DRowFieldMatrix<Fraction>(subColumn1);        FieldMatrix<Fraction> mColumn3 = new Array2DRowFieldMatrix<Fraction>(subColumn3);        Assert.assertEquals("Column1", mColumn1,                m.getColumnMatrix(1));        Assert.assertEquals("Column3", mColumn3,                m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getColumnMatrix(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetColumnMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mColumn3 = new Array2DRowFieldMatrix<Fraction>(subColumn3);        Assert.assertNotSame(mColumn3, m.getColumnMatrix(1));        m.setColumnMatrix(1, mColumn3);        Assert.assertEquals(mColumn3, m.getColumnMatrix(1));        try {            m.setColumnMatrix(-1, mColumn3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setColumnMatrix(0, m);            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetRowVector() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);        Assert.assertEquals("Row0", mRow0, m.getRowVector(0));        Assert.assertEquals("Row3", mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getRowVector(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetRowVector() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);        Assert.assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowVector(0, mRow3);        Assert.assertEquals(mRow3, m.getRowVector(0));        try {            m.setRowVector(-1, mRow3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setRowVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetColumnVector() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);        Assert.assertEquals("Column1", mColumn1, m.getColumnVector(1));        Assert.assertEquals("Column3", mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getColumnVector(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetColumnVector() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);        Assert.assertNotSame(mColumn3, m.getColumnVector(1));        m.setColumnVector(1, mColumn3);        Assert.assertEquals(mColumn3, m.getColumnVector(1));        try {            m.setColumnVector(-1, mColumn3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setColumnVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    private FieldVector<Fraction> columnToVector(Fraction[][] column) {        Fraction[] data = new Fraction[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayFieldVector<Fraction>(data, false);    }    @Test    public void testGetRow() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        checkArrays(subRow0[0], m.getRow(0));        checkArrays(subRow3[0], m.getRow(3));        try {            m.getRow(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getRow(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetRow() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]);        m.setRow(0, subRow3[0]);        checkArrays(subRow3[0], m.getRow(0));        try {            m.setRow(-1, subRow3[0]);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setRow(0, new Fraction[5]);            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    @Test    public void testGetColumn() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        Fraction[] mColumn1 = columnToArray(subColumn1);        Fraction[] mColumn3 = columnToArray(subColumn3);        checkArrays(mColumn1, m.getColumn(1));        checkArrays(mColumn3, m.getColumn(3));        try {            m.getColumn(-1);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.getColumn(4);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }    }    @Test    public void testSetColumn() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        Fraction[] mColumn3 = columnToArray(subColumn3);        Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]);        m.setColumn(1, mColumn3);        checkArrays(mColumn3, m.getColumn(1));        try {            m.setColumn(-1, mColumn3);            Assert.fail("Expecting OutOfRangeException");        } catch (OutOfRangeException ex) {            // expected        }        try {            m.setColumn(0, new Fraction[5]);            Assert.fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    private Fraction[] columnToArray(Fraction[][] column) {        Fraction[] data = new Fraction[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return data;    }    private void checkArrays(Fraction[] expected, Fraction[] actual) {        Assert.assertEquals(expected.length, actual.length);        for (int i = 0; i < expected.length; ++i) {            Assert.assertEquals(expected[i], actual[i]);        }    }    @Test    public void testEqualsAndHashCode() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m1 = (Array2DRowFieldMatrix<Fraction>) m.copy();        Array2DRowFieldMatrix<Fraction> mt = (Array2DRowFieldMatrix<Fraction>) m.transpose();        Assert.assertTrue(m.hashCode() != mt.hashCode());        Assert.assertEquals(m.hashCode(), m1.hashCode());        Assert.assertEquals(m, m);        Assert.assertEquals(m, m1);        Assert.assertFalse(m.equals(null));        Assert.assertFalse(m.equals(mt));        Assert.assertFalse(m.equals(new Array2DRowFieldMatrix<Fraction>(bigSingular)));    }    @Test    public void testToString() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Assert.assertEquals("Array2DRowFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}", m.toString());        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance());        Assert.assertEquals("Array2DRowFieldMatrix{}", m.toString());    }    @Test    public void testSetSubMatrix() throws Exception {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        m.setSubMatrix(detData2,1,1);        FieldMatrix<Fraction> expected = new Array2DRowFieldMatrix<Fraction>            (new Fraction[][] {                    {new Fraction(1),new Fraction(2),new Fraction(3)},                    {new Fraction(2),new Fraction(1),new Fraction(3)},                    {new Fraction(1),new Fraction(2),new Fraction(4)}             });        Assert.assertEquals(expected, m);        m.setSubMatrix(detData2,0,0);        expected = new Array2DRowFieldMatrix<Fraction>            (new Fraction[][] {                    {new Fraction(1),new Fraction(3),new Fraction(3)},                    {new Fraction(2),new Fraction(4),new Fraction(3)},                    {new Fraction(1),new Fraction(2),new Fraction(4)}             });        Assert.assertEquals(expected, m);        m.setSubMatrix(testDataPlus2,0,0);        expected = new Array2DRowFieldMatrix<Fraction>            (new Fraction[][] {                    {new Fraction(3),new Fraction(4),new Fraction(5)},                    {new Fraction(4),new Fraction(7),new Fraction(5)},                    {new Fraction(3),new Fraction(2),new Fraction(10)}             });        Assert.assertEquals(expected, m);        // dimension overflow        try {            m.setSubMatrix(testData,1,1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        // dimension underflow        try {            m.setSubMatrix(testData,-1,1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        try {            m.setSubMatrix(testData,1,-1);            Assert.fail("expecting OutOfRangeException");        } catch (OutOfRangeException e) {            // expected        }        // null        try {            m.setSubMatrix(null, 1, 1);            Assert.fail("expecting NullArgumentException");        } catch (NullArgumentException e) {            // expected        }        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance());        try {            m2.setSubMatrix(testData,0,1);            Assert.fail("expecting MathIllegalStateException");        } catch (MathIllegalStateException e) {            // expected        }        try {            m2.setSubMatrix(testData,1,0);            Assert.fail("expecting MathIllegalStateException");        } catch (MathIllegalStateException e) {            // expected        }        // ragged        try {            m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected        }        // empty        try {            m.setSubMatrix(new Fraction[][] {{}}, 0, 0);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException e) {            // expected        }    }    @Test    public void testWalk() throws MathUserException {        int rows    = 150;        int columns = 75;        FieldMatrix<Fraction> m =            new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInRowOrder(new SetVisitor());        GetVisitor getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        Assert.assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            Assert.assertEquals(new Fraction(0), m.getEntry(i, 0));            Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            Assert.assertEquals(new Fraction(0), m.getEntry(0, j));            Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInColumnOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        Assert.assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            Assert.assertEquals(new Fraction(0), m.getEntry(i, 0));            Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            Assert.assertEquals(new Fraction(0), m.getEntry(0, j));            Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor);        Assert.assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            Assert.assertEquals(new Fraction(0), m.getEntry(i, 0));            Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            Assert.assertEquals(new Fraction(0), m.getEntry(0, j));            Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor);        Assert.assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);        Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            Assert.assertEquals(new Fraction(0), m.getEntry(i, 0));            Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            Assert.assertEquals(new Fraction(0), m.getEntry(0, j));            Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }    }    @Test    public void testSerial()  {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Assert.assertEquals(m,TestUtils.serializeAndRecover(m));    }    private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Fraction> {        public SetVisitor() {            super(Fraction.ZERO);        }        @Override        public Fraction visit(int i, int j, Fraction value) {            return new Fraction(i * 1024 + j, 1024);        }    }    private static class GetVisitor extends DefaultFieldMatrixPreservingVisitor<Fraction> {        private int count;        public GetVisitor() {            super(Fraction.ZERO);            count = 0;        }        @Override        public void visit(int i, int j, Fraction value) {            ++count;            Assert.assertEquals(new Fraction(i * 1024 + j, 1024), value);        }        public int getCount() {            return count;        }    }    //--------------- -----------------Protected methods    /** extracts the l  and u matrices from compact lu representation */    protected void splitLU(FieldMatrix<Fraction> lu,                           Fraction[][] lowerData,                           Fraction[][] upperData) {        if (!lu.isSquare()) {            throw new NonSquareMatrixException(lu.getRowDimension(), lu.getColumnDimension());        }        if (lowerData.length != lowerData[0].length) {            throw new DimensionMismatchException(lowerData.length, lowerData[0].length);        }        if (upperData.length != upperData[0].length) {            throw new DimensionMismatchException(upperData.length, upperData[0].length);        }        if (lowerData.length != upperData.length) {            throw new DimensionMismatchException(lowerData.length, upperData.length);        }        if (lowerData.length != lu.getRowDimension()) {            throw new DimensionMismatchException(lowerData.length, lu.getRowDimension());        }        int n = lu.getRowDimension();        for (int i = 0; i < n; i++) {            for (int j = 0; j < n; j++) {                if (j < i) {                    lowerData[i][j] = lu.getEntry(i, j);                    upperData[i][j] = Fraction.ZERO;                } else if (i == j) {                    lowerData[i][j] = Fraction.ONE;                    upperData[i][j] = lu.getEntry(i, j);                } else {                    lowerData[i][j] = Fraction.ZERO;                    upperData[i][j] = lu.getEntry(i, j);                }            }        }    }    /** Returns the result of applying the given row permutation to the matrix */    protected FieldMatrix<Fraction> permuteRows(FieldMatrix<Fraction> matrix, int[] permutation) {        if (!matrix.isSquare()) {            throw new NonSquareMatrixException(matrix.getRowDimension(),                                               matrix.getColumnDimension());        }        if (matrix.getRowDimension() != permutation.length) {            throw new DimensionMismatchException(matrix.getRowDimension(), permutation.length);        }        int n = matrix.getRowDimension();        int m = matrix.getColumnDimension();        Fraction out[][] = new Fraction[m][n];        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                out[i][j] = matrix.getEntry(permutation[i], j);            }        }        return new Array2DRowFieldMatrix<Fraction>(out);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.junit.Test;import org.junit.Assert;public class LUSolverTest {    private double[][] testData = {            { 1.0, 2.0, 3.0},            { 2.0, 5.0, 3.0},            { 1.0, 0.0, 8.0}    };    private double[][] luData = {            { 2.0, 3.0, 3.0 },            { 0.0, 5.0, 7.0 },            { 6.0, 9.0, 8.0 }    };    // singular matrices    private double[][] singular = {            { 2.0, 3.0 },            { 2.0, 3.0 }    };    private double[][] bigSingular = {            { 1.0, 2.0,   3.0,    4.0 },            { 2.0, 5.0,   3.0,    4.0 },            { 7.0, 3.0, 256.0, 1930.0 },            { 3.0, 7.0,   6.0,    8.0 }    }; // 4th row = 1st + 2nd    /** test threshold impact */    @Test    public void testThreshold() {        final RealMatrix matrix = MatrixUtils.createRealMatrix(new double[][] {                                                       { 1.0, 2.0, 3.0},                                                       { 2.0, 5.0, 3.0},                                                       { 4.000001, 9.0, 9.0}                                                     });        Assert.assertFalse(new LUDecompositionImpl(matrix, 1.0e-5).getSolver().isNonSingular());        Assert.assertTrue(new LUDecompositionImpl(matrix, 1.0e-10).getSolver().isNonSingular());    }    /** test singular */    @Test    public void testSingular() {        DecompositionSolver solver =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();        Assert.assertTrue(solver.isNonSingular());        solver = new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular)).getSolver();        Assert.assertFalse(solver.isNonSingular());        solver = new LUDecompositionImpl(MatrixUtils.createRealMatrix(bigSingular)).getSolver();        Assert.assertFalse(solver.isNonSingular());    }    /** test solve dimension errors */    @Test    public void testSolveDimensionErrors() {        DecompositionSolver solver =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);        try {            solver.solve(b);            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException iae) {            // expected behavior        }        try {            solver.solve(b.getColumnVector(0));            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException iae) {            // expected behavior        }        try {            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));            Assert.fail("an exception should have been thrown");        } catch (MathIllegalArgumentException iae) {            // expected behavior        }    }    /** test solve singularity errors */    @Test    public void testSolveSingularityErrors() {        DecompositionSolver solver =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);        try {            solver.solve(b);            Assert.fail("an exception should have been thrown");        } catch (SingularMatrixException ime) {            // expected behavior        }        try {            solver.solve(b.getColumnVector(0));            Assert.fail("an exception should have been thrown");        } catch (SingularMatrixException ime) {            // expected behavior        }        try {            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));            Assert.fail("an exception should have been thrown");        } catch (SingularMatrixException ime) {            // expected behavior        }    }    /** test solve */    @Test    public void testSolve() {        DecompositionSolver solver =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                { 1, 0 }, { 2, -5 }, { 3, 1 }        });        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                { 19, -71 }, { -6, 22 }, { -2, 9 }        });        // using RealMatrix        Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);        // using double[][]        Assert.assertEquals(0, MatrixUtils.createRealMatrix(solver.solve(b.getData())).subtract(xRef).getNorm(), 1.0e-13);        // using ArrayRealVector        for (int i = 0; i < b.getColumnDimension(); ++i) {            Assert.assertEquals(0,                         solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }        // using RealVector with an alternate implementation        for (int i = 0; i < b.getColumnDimension(); ++i) {            ArrayRealVectorTest.RealVectorTestImpl v =                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));            Assert.assertEquals(0,                         solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }    }    /** test determinant */    @Test    public void testDeterminant() {        Assert.assertEquals( -1, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15);        Assert.assertEquals(-10, getDeterminant(MatrixUtils.createRealMatrix(luData)), 1.0e-14);        Assert.assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(singular)), 1.0e-17);        Assert.assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(bigSingular)), 1.0e-10);    }    private double getDeterminant(RealMatrix m) {        return new LUDecompositionImpl(m).getDeterminant();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Random;import org.apache.commons.math.exception.MathUserException;import org.junit.Assert;import org.junit.Test;public class QRDecompositionImplTest {    double[][] testData3x3NonSingular = {            { 12, -51, 4 },            { 6, 167, -68 },            { -4, 24, -41 }, };    double[][] testData3x3Singular = {            { 1, 4, 7, },            { 2, 5, 8, },            { 3, 6, 9, }, };    double[][] testData3x4 = {            { 12, -51, 4, 1 },            { 6, 167, -68, 2 },            { -4, 24, -41, 3 }, };    double[][] testData4x3 = {            { 12, -51, 4, },            { 6, 167, -68, },            { -4, 24, -41, },            { -5, 34, 7, }, };    private static final double entryTolerance = 10e-16;    private static final double normTolerance = 10e-14;    /** test dimensions      * @throws MathUserException */    @Test    public void testDimensions() throws MathUserException {        checkDimension(MatrixUtils.createRealMatrix(testData3x3NonSingular));        checkDimension(MatrixUtils.createRealMatrix(testData4x3));        checkDimension(MatrixUtils.createRealMatrix(testData3x4));        Random r = new Random(643895747384642l);        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        checkDimension(createTestMatrix(r, p, q));        checkDimension(createTestMatrix(r, q, p));    }    private void checkDimension(RealMatrix m) {        int rows = m.getRowDimension();        int columns = m.getColumnDimension();        QRDecomposition qr = new QRDecompositionImpl(m);        Assert.assertEquals(rows,    qr.getQ().getRowDimension());        Assert.assertEquals(rows,    qr.getQ().getColumnDimension());        Assert.assertEquals(rows,    qr.getR().getRowDimension());        Assert.assertEquals(columns, qr.getR().getColumnDimension());    }    /** test A = QR      * @throws MathUserException */    @Test    public void testAEqualQR() throws MathUserException {        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3NonSingular));        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3Singular));        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x4));        checkAEqualQR(MatrixUtils.createRealMatrix(testData4x3));        Random r = new Random(643895747384642l);        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        checkAEqualQR(createTestMatrix(r, p, q));        checkAEqualQR(createTestMatrix(r, q, p));    }    private void checkAEqualQR(RealMatrix m) {        QRDecomposition qr = new QRDecompositionImpl(m);        double norm = qr.getQ().multiply(qr.getR()).subtract(m).getNorm();        Assert.assertEquals(0, norm, normTolerance);    }    /** test the orthogonality of Q      * @throws MathUserException */    @Test    public void testQOrthogonal() throws MathUserException {        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3NonSingular));        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3Singular));        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x4));        checkQOrthogonal(MatrixUtils.createRealMatrix(testData4x3));        Random r = new Random(643895747384642l);        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        checkQOrthogonal(createTestMatrix(r, p, q));        checkQOrthogonal(createTestMatrix(r, q, p));    }    private void checkQOrthogonal(RealMatrix m) {        QRDecomposition qr = new QRDecompositionImpl(m);        RealMatrix eye = MatrixUtils.createRealIdentityMatrix(m.getRowDimension());        double norm = qr.getQT().multiply(qr.getQ()).subtract(eye).getNorm();        Assert.assertEquals(0, norm, normTolerance);    }    /** test that R is upper triangular */    @Test    public void testRUpperTriangular() throws MathUserException {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());        matrix = MatrixUtils.createRealMatrix(testData3x4);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());        matrix = MatrixUtils.createRealMatrix(testData4x3);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());        Random r = new Random(643895747384642l);        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        matrix = createTestMatrix(r, p, q);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());        matrix = createTestMatrix(r, p, q);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());    }    private void checkUpperTriangular(RealMatrix m) throws MathUserException {        m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {            @Override            public void visit(int row, int column, double value) {                if (column < row) {                    Assert.assertEquals(0.0, value, entryTolerance);                }            }        });    }    /** test that H is trapezoidal      * @throws MathUserException */    @Test    public void testHTrapezoidal() throws MathUserException {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());        matrix = MatrixUtils.createRealMatrix(testData3x4);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());        matrix = MatrixUtils.createRealMatrix(testData4x3);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());        Random r = new Random(643895747384642l);        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        matrix = createTestMatrix(r, p, q);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());        matrix = createTestMatrix(r, p, q);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());    }    private void checkTrapezoidal(RealMatrix m) throws MathUserException {        m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {            @Override            public void visit(int row, int column, double value) {                if (column > row) {                    Assert.assertEquals(0.0, value, entryTolerance);                }            }        });    }    /** test matrices values */    @Test    public void testMatricesValues() {        QRDecomposition qr =            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular));        RealMatrix qRef = MatrixUtils.createRealMatrix(new double[][] {                { -12.0 / 14.0,   69.0 / 175.0,  -58.0 / 175.0 },                {  -6.0 / 14.0, -158.0 / 175.0,    6.0 / 175.0 },                {   4.0 / 14.0,  -30.0 / 175.0, -165.0 / 175.0 }        });        RealMatrix rRef = MatrixUtils.createRealMatrix(new double[][] {                { -14.0,  -21.0, 14.0 },                {   0.0, -175.0, 70.0 },                {   0.0,    0.0, 35.0 }        });        RealMatrix hRef = MatrixUtils.createRealMatrix(new double[][] {                { 26.0 / 14.0, 0.0, 0.0 },                {  6.0 / 14.0, 648.0 / 325.0, 0.0 },                { -4.0 / 14.0,  36.0 / 325.0, 2.0 }        });        // check values against known references        RealMatrix q = qr.getQ();        Assert.assertEquals(0, q.subtract(qRef).getNorm(), 1.0e-13);        RealMatrix qT = qr.getQT();        Assert.assertEquals(0, qT.subtract(qRef.transpose()).getNorm(), 1.0e-13);        RealMatrix r = qr.getR();        Assert.assertEquals(0, r.subtract(rRef).getNorm(), 1.0e-13);        RealMatrix h = qr.getH();        Assert.assertEquals(0, h.subtract(hRef).getNorm(), 1.0e-13);        // check the same cached instance is returned the second time        Assert.assertTrue(q == qr.getQ());        Assert.assertTrue(r == qr.getR());        Assert.assertTrue(h == qr.getH());    }    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {        RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);        m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){            @Override            public double visit(int row, int column, double value) {                return 2.0 * r.nextDouble() - 1.0;            }        });        return m;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.junit.Test;import org.junit.Assert;public class CholeskyDecompositionImplTest {    private double[][] testData = new double[][] {            {  1,  2,   4,   7,  11 },            {  2, 13,  23,  38,  58 },            {  4, 23,  77, 122, 182 },            {  7, 38, 122, 294, 430 },            { 11, 58, 182, 430, 855 }    };    /** test dimensions */    @Test    public void testDimensions() {        CholeskyDecomposition llt =            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData));        Assert.assertEquals(testData.length, llt.getL().getRowDimension());        Assert.assertEquals(testData.length, llt.getL().getColumnDimension());        Assert.assertEquals(testData.length, llt.getLT().getRowDimension());        Assert.assertEquals(testData.length, llt.getLT().getColumnDimension());    }    /** test non-square matrix */    @Test(expected = NonSquareMatrixException.class)    public void testNonSquare() {        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[3][2]));    }    /** test non-symmetric matrix */    @Test(expected = NonSymmetricMatrixException.class)    public void testNotSymmetricMatrixException() {        double[][] changed = testData.clone();        changed[0][changed[0].length - 1] += 1.0e-5;        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(changed));    }    /** test non positive definite matrix */    @Test(expected = NonPositiveDefiniteMatrixException.class)    public void testNotPositiveDefinite() {        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {                { 14, 11, 13, 15, 24 },                { 11, 34, 13, 8,  25 },                { 13, 13, 14, 15, 21 },                { 15, 8,  15, 18, 23 },                { 24, 25, 21, 23, 45 }        }));    }    @Test(expected = NonPositiveDefiniteMatrixException.class)    public void testMath274() {        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {                { 0.40434286, -0.09376327, 0.30328980, 0.04909388 },                {-0.09376327,  0.10400408, 0.07137959, 0.04762857 },                { 0.30328980,  0.07137959, 0.30458776, 0.04882449 },                { 0.04909388,  0.04762857, 0.04882449, 0.07543265 }        }));    }    /** test A = LLT */    @Test    public void testAEqualLLT() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        CholeskyDecomposition llt = new CholeskyDecompositionImpl(matrix);        RealMatrix l  = llt.getL();        RealMatrix lt = llt.getLT();        double norm = l.multiply(lt).subtract(matrix).getNorm();        Assert.assertEquals(0, norm, 1.0e-15);    }    /** test that L is lower triangular */    @Test    public void testLLowerTriangular() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        RealMatrix l = new CholeskyDecompositionImpl(matrix).getL();        for (int i = 0; i < l.getRowDimension(); i++) {            for (int j = i + 1; j < l.getColumnDimension(); j++) {                Assert.assertEquals(0.0, l.getEntry(i, j), 0.0);            }        }    }    /** test that LT is transpose of L */    @Test    public void testLTTransposed() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        CholeskyDecomposition llt = new CholeskyDecompositionImpl(matrix);        RealMatrix l  = llt.getL();        RealMatrix lt = llt.getLT();        double norm = l.subtract(lt.transpose()).getNorm();        Assert.assertEquals(0, norm, 1.0e-15);    }    /** test matrices values */    @Test    public void testMatricesValues() {        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {                {  1,  0,  0,  0,  0 },                {  2,  3,  0,  0,  0 },                {  4,  5,  6,  0,  0 },                {  7,  8,  9, 10,  0 },                { 11, 12, 13, 14, 15 }        });       CholeskyDecomposition llt =            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData));        // check values against known references        RealMatrix l = llt.getL();        Assert.assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);        RealMatrix lt = llt.getLT();        Assert.assertEquals(0, lt.subtract(lRef.transpose()).getNorm(), 1.0e-13);        // check the same cached instance is returned the second time        Assert.assertTrue(l  == llt.getL());        Assert.assertTrue(lt == llt.getLT());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Arrays;import java.util.Random;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.util.MathUtils;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public class EigenDecompositionImplTest {    private double[] refValues;    private RealMatrix matrix;    @Test    public void testDimension1() {        RealMatrix matrix =            MatrixUtils.createRealMatrix(new double[][] { { 1.5 } });        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        Assert.assertEquals(1.5, ed.getRealEigenvalue(0), 1.0e-15);    }    @Test    public void testDimension2() {        RealMatrix matrix =            MatrixUtils.createRealMatrix(new double[][] {                    { 59.0, 12.0 },                    { 12.0, 66.0 }            });        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        Assert.assertEquals(75.0, ed.getRealEigenvalue(0), 1.0e-15);        Assert.assertEquals(50.0, ed.getRealEigenvalue(1), 1.0e-15);    }    @Test    public void testDimension3() {        RealMatrix matrix =            MatrixUtils.createRealMatrix(new double[][] {                                   {  39632.0, -4824.0, -16560.0 },                                   {  -4824.0,  8693.0,   7920.0 },                                   { -16560.0,  7920.0,  17300.0 }                               });        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        Assert.assertEquals(50000.0, ed.getRealEigenvalue(0), 3.0e-11);        Assert.assertEquals(12500.0, ed.getRealEigenvalue(1), 3.0e-11);        Assert.assertEquals( 3125.0, ed.getRealEigenvalue(2), 3.0e-11);    }    @Test    public void testDimension3MultipleRoot() {        RealMatrix matrix =            MatrixUtils.createRealMatrix(new double[][] {                    {  5,   10,   15 },                    { 10,   20,   30 },                    { 15,   30,   45 }            });        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        Assert.assertEquals(70.0, ed.getRealEigenvalue(0), 3.0e-11);        Assert.assertEquals(0.0,  ed.getRealEigenvalue(1), 3.0e-11);        Assert.assertEquals(0.0,  ed.getRealEigenvalue(2), 3.0e-11);    }    @Test    public void testDimension4WithSplit() {        RealMatrix matrix =            MatrixUtils.createRealMatrix(new double[][] {                                   {  0.784, -0.288,  0.000,  0.000 },                                   { -0.288,  0.616,  0.000,  0.000 },                                   {  0.000,  0.000,  0.164, -0.048 },                                   {  0.000,  0.000, -0.048,  0.136 }                               });        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        Assert.assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);        Assert.assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);        Assert.assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);        Assert.assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);    }    @Test    public void testDimension4WithoutSplit() {        RealMatrix matrix =            MatrixUtils.createRealMatrix(new double[][] {                                   {  0.5608, -0.2016,  0.1152, -0.2976 },                                   { -0.2016,  0.4432, -0.2304,  0.1152 },                                   {  0.1152, -0.2304,  0.3088, -0.1344 },                                   { -0.2976,  0.1152, -0.1344,  0.3872 }                               });        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        Assert.assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);        Assert.assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);        Assert.assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);        Assert.assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);    }    // the following test triggered an ArrayIndexOutOfBoundsException in commons-math 2.0    @Test    public void testMath308() {        double[] mainTridiagonal = {            22.330154644539597, 46.65485522478641, 17.393672330044705, 54.46687435351116, 80.17800767709437        };        double[] secondaryTridiagonal = {            13.04450406501361, -5.977590941539671, 2.9040909856707517, 7.1570352792841225        };        // the reference values have been computed using routine DSTEMR        // from the fortran library LAPACK version 3.2.1        double[] refEigenValues = {            82.044413207204002, 53.456697699894512, 52.536278520113882, 18.847969733754262, 14.138204224043099        };        RealVector[] refEigenVectors = {            new ArrayRealVector(new double[] { -0.000462690386766, -0.002118073109055,  0.011530080757413,  0.252322434584915,  0.967572088232592 }),            new ArrayRealVector(new double[] {  0.314647769490148,  0.750806415553905, -0.167700312025760, -0.537092972407375,  0.143854968127780 }),            new ArrayRealVector(new double[] {  0.222368839324646,  0.514921891363332, -0.021377019336614,  0.801196801016305, -0.207446991247740 }),            new ArrayRealVector(new double[] { -0.713933751051495,  0.190582113553930, -0.671410443368332,  0.056056055955050, -0.006541576993581 }),            new ArrayRealVector(new double[] { -0.584677060845929,  0.367177264979103,  0.721453187784497, -0.052971054621812,  0.005740715188257 })        };        EigenDecomposition decomposition =            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);        double[] eigenValues = decomposition.getRealEigenvalues();        for (int i = 0; i < refEigenValues.length; ++i) {            Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-5);            Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 2.0e-7);        }    }    @Test    public void testMathpbx02() {        double[] mainTridiagonal = {              7484.860960227216, 18405.28129035345, 13855.225609560746,             10016.708722343366, 559.8117399576674, 6750.190788301587,                71.21428769782159        };        double[] secondaryTridiagonal = {             -4175.088570476366,1975.7955858241994,5193.178422374075,              1995.286659169179,75.34535882933804,-234.0808002076056        };        // the reference values have been computed using routine DSTEMR        // from the fortran library LAPACK version 3.2.1        double[] refEigenValues = {                20654.744890306974412,16828.208208485466457,                6893.155912634994820,6757.083016675340332,                5887.799885688558788,64.309089923240379,                57.992628792736340        };        RealVector[] refEigenVectors = {                new ArrayRealVector(new double[] {-0.270356342026904, 0.852811091326997, 0.399639490702077, 0.198794657813990, 0.019739323307666, 0.000106983022327, -0.000001216636321}),                new ArrayRealVector(new double[] {0.179995273578326,-0.402807848153042,0.701870993525734,0.555058211014888,0.068079148898236,0.000509139115227,-0.000007112235617}),                new ArrayRealVector(new double[] {-0.399582721284727,-0.056629954519333,-0.514406488522827,0.711168164518580,0.225548081276367,0.125943999652923,-0.004321507456014}),                new ArrayRealVector(new double[] {0.058515721572821,0.010200130057739,0.063516274916536,-0.090696087449378,-0.017148420432597,0.991318870265707,-0.034707338554096}),                new ArrayRealVector(new double[] {0.855205995537564,0.327134656629775,-0.265382397060548,0.282690729026706,0.105736068025572,-0.009138126622039,0.000367751821196}),                new ArrayRealVector(new double[] {-0.002913069901144,-0.005177515777101,0.041906334478672,-0.109315918416258,0.436192305456741,0.026307315639535,0.891797507436344}),                new ArrayRealVector(new double[] {-0.005738311176435,-0.010207611670378,0.082662420517928,-0.215733886094368,0.861606487840411,-0.025478530652759,-0.451080697503958})        };        // the following line triggers the exception        EigenDecomposition decomposition =            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);        double[] eigenValues = decomposition.getRealEigenvalues();        for (int i = 0; i < refEigenValues.length; ++i) {            Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-3);            if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {                Assert.assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);            } else {                Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);            }        }    }    @Test    public void testMathpbx03() {        double[] mainTridiagonal = {            1809.0978259647177,3395.4763425956166,1832.1894584712693,3804.364873592377,            806.0482458637571,2403.656427234185,28.48691431556015        };        double[] secondaryTridiagonal = {            -656.8932064545833,-469.30804108920734,-1021.7714889369421,            -1152.540497328983,-939.9765163817368,-12.885877015422391        };        // the reference values have been computed using routine DSTEMR        // from the fortran library LAPACK version 3.2.1        double[] refEigenValues = {            4603.121913685183245,3691.195818048970978,2743.442955402465032,1657.596442107321764,            1336.797819095331306,30.129865209677519,17.035352085224986        };        RealVector[] refEigenVectors = {            new ArrayRealVector(new double[] {-0.036249830202337,0.154184732411519,-0.346016328392363,0.867540105133093,-0.294483395433451,0.125854235969548,-0.000354507444044}),            new ArrayRealVector(new double[] {-0.318654191697157,0.912992309960507,-0.129270874079777,-0.184150038178035,0.096521712579439,-0.070468788536461,0.000247918177736}),            new ArrayRealVector(new double[] {-0.051394668681147,0.073102235876933,0.173502042943743,-0.188311980310942,-0.327158794289386,0.905206581432676,-0.004296342252659}),            new ArrayRealVector(new double[] {0.838150199198361,0.193305209055716,-0.457341242126146,-0.166933875895419,0.094512811358535,0.119062381338757,-0.000941755685226}),            new ArrayRealVector(new double[] {0.438071395458547,0.314969169786246,0.768480630802146,0.227919171600705,-0.193317045298647,-0.170305467485594,0.001677380536009}),            new ArrayRealVector(new double[] {-0.003726503878741,-0.010091946369146,-0.067152015137611,-0.113798146542187,-0.313123000097908,-0.118940107954918,0.932862311396062}),            new ArrayRealVector(new double[] {0.009373003194332,0.025570377559400,0.170955836081348,0.291954519805750,0.807824267665706,0.320108347088646,0.360202112392266}),        };        // the following line triggers the exception        EigenDecomposition decomposition =            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);        double[] eigenValues = decomposition.getRealEigenvalues();        for (int i = 0; i < refEigenValues.length; ++i) {            Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-4);            if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {                Assert.assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);            } else {                Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);            }        }    }    /** test a matrix already in tridiagonal form. */    @Test    public void testTridiagonal() {        Random r = new Random(4366663527842l);        double[] ref = new double[30];        for (int i = 0; i < ref.length; ++i) {            if (i < 5) {                ref[i] = 2 * r.nextDouble() - 1;            } else {                ref[i] = 0.0001 * r.nextDouble() + 6;            }        }        Arrays.sort(ref);        TriDiagonalTransformer t =            new TriDiagonalTransformer(createTestMatrix(r, ref));        EigenDecomposition ed =            new EigenDecompositionImpl(t.getMainDiagonalRef(),                                       t.getSecondaryDiagonalRef(),                                       MathUtils.SAFE_MIN);        double[] eigenValues = ed.getRealEigenvalues();        Assert.assertEquals(ref.length, eigenValues.length);        for (int i = 0; i < ref.length; ++i) {            Assert.assertEquals(ref[ref.length - i - 1], eigenValues[i], 2.0e-14);        }    }    /** test dimensions */    @Test    public void testDimensions() {        final int m = matrix.getRowDimension();        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        Assert.assertEquals(m, ed.getV().getRowDimension());        Assert.assertEquals(m, ed.getV().getColumnDimension());        Assert.assertEquals(m, ed.getD().getColumnDimension());        Assert.assertEquals(m, ed.getD().getColumnDimension());        Assert.assertEquals(m, ed.getVT().getRowDimension());        Assert.assertEquals(m, ed.getVT().getColumnDimension());    }    /** test eigenvalues */    @Test    public void testEigenvalues() {        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        double[] eigenValues = ed.getRealEigenvalues();        Assert.assertEquals(refValues.length, eigenValues.length);        for (int i = 0; i < refValues.length; ++i) {            Assert.assertEquals(refValues[i], eigenValues[i], 3.0e-15);        }    }    /** test eigenvalues for a big matrix. */    @Test    public void testBigMatrix() {        Random r = new Random(17748333525117l);        double[] bigValues = new double[200];        for (int i = 0; i < bigValues.length; ++i) {            bigValues[i] = 2 * r.nextDouble() - 1;        }        Arrays.sort(bigValues);        EigenDecomposition ed =            new EigenDecompositionImpl(createTestMatrix(r, bigValues), MathUtils.SAFE_MIN);        double[] eigenValues = ed.getRealEigenvalues();        Assert.assertEquals(bigValues.length, eigenValues.length);        for (int i = 0; i < bigValues.length; ++i) {            Assert.assertEquals(bigValues[bigValues.length - i - 1], eigenValues[i], 2.0e-14);        }    }    /** test eigenvectors */    @Test    public void testEigenvectors() {        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        for (int i = 0; i < matrix.getRowDimension(); ++i) {            double lambda = ed.getRealEigenvalue(i);            RealVector v  = ed.getEigenvector(i);            RealVector mV = matrix.operate(v);            Assert.assertEquals(0, mV.subtract(v.mapMultiplyToSelf(lambda)).getNorm(), 1.0e-13);        }    }    /** test A = VDVt */    @Test    public void testAEqualVDVt() {        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        RealMatrix v  = ed.getV();        RealMatrix d  = ed.getD();        RealMatrix vT = ed.getVT();        double norm = v.multiply(d).multiply(vT).subtract(matrix).getNorm();        Assert.assertEquals(0, norm, 6.0e-13);    }    /** test that V is orthogonal */    @Test    public void testVOrthogonal() {        RealMatrix v = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN).getV();        RealMatrix vTv = v.transpose().multiply(v);        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension());        Assert.assertEquals(0, vTv.subtract(id).getNorm(), 2.0e-13);    }    /** test diagonal matrix */    @Test    public void testDiagonal() {        double[] diagonal = new double[] { -3.0, -2.0, 2.0, 5.0 };        RealMatrix m = createDiagonalMatrix(diagonal, diagonal.length, diagonal.length);        EigenDecomposition ed = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN);        Assert.assertEquals(diagonal[0], ed.getRealEigenvalue(3), 2.0e-15);        Assert.assertEquals(diagonal[1], ed.getRealEigenvalue(2), 2.0e-15);        Assert.assertEquals(diagonal[2], ed.getRealEigenvalue(1), 2.0e-15);        Assert.assertEquals(diagonal[3], ed.getRealEigenvalue(0), 2.0e-15);    }    /**     * Matrix with eigenvalues {8, -1, -1}     */    @Test    public void testRepeatedEigenvalue() {        RealMatrix repeated = MatrixUtils.createRealMatrix(new double[][] {                {3,  2,  4},                {2,  0,  2},                {4,  2,  3}        });        EigenDecomposition ed = new EigenDecompositionImpl(repeated, MathUtils.SAFE_MIN);        checkEigenValues((new double[] {8, -1, -1}), ed, 1E-12);        checkEigenVector((new double[] {2, 1, 2}), ed, 1E-12);    }    /**     * Matrix with eigenvalues {2, 0, 12}     */    @Test    public void testDistinctEigenvalues() {        RealMatrix distinct = MatrixUtils.createRealMatrix(new double[][] {                {3, 1, -4},                {1, 3, -4},                {-4, -4, 8}        });        EigenDecomposition ed = new EigenDecompositionImpl(distinct, MathUtils.SAFE_MIN);        checkEigenValues((new double[] {2, 0, 12}), ed, 1E-12);        checkEigenVector((new double[] {1, -1, 0}), ed, 1E-12);        checkEigenVector((new double[] {1, 1, 1}), ed, 1E-12);        checkEigenVector((new double[] {-1, -1, 2}), ed, 1E-12);    }    /**     * Verifies operation on indefinite matrix     */    @Test    public void testZeroDivide() {        RealMatrix indefinite = MatrixUtils.createRealMatrix(new double [][] {                { 0.0, 1.0, -1.0 },                { 1.0, 1.0, 0.0 },                { -1.0,0.0, 1.0 }        });        EigenDecomposition ed = new EigenDecompositionImpl(indefinite, MathUtils.SAFE_MIN);        checkEigenValues((new double[] {2, 1, -1}), ed, 1E-12);        double isqrt3 = 1/FastMath.sqrt(3.0);        checkEigenVector((new double[] {isqrt3,isqrt3,-isqrt3}), ed, 1E-12);        double isqrt2 = 1/FastMath.sqrt(2.0);        checkEigenVector((new double[] {0.0,-isqrt2,-isqrt2}), ed, 1E-12);        double isqrt6 = 1/FastMath.sqrt(6.0);        checkEigenVector((new double[] {2*isqrt6,-isqrt6,isqrt6}), ed, 1E-12);    }    /**     * Verifies that the given EigenDecomposition has eigenvalues equivalent to     * the targetValues, ignoring the order of the values and allowing     * values to differ by tolerance.     */    protected void checkEigenValues(double[] targetValues,            EigenDecomposition ed, double tolerance) {        double[] observed = ed.getRealEigenvalues();        for (int i = 0; i < observed.length; i++) {            Assert.assertTrue(isIncludedValue(observed[i], targetValues, tolerance));            Assert.assertTrue(isIncludedValue(targetValues[i], observed, tolerance));        }    }    /**     * Returns true iff there is an entry within tolerance of value in     * searchArray.     */    private boolean isIncludedValue(double value, double[] searchArray,            double tolerance) {       boolean found = false;       int i = 0;       while (!found && i < searchArray.length) {           if (FastMath.abs(value - searchArray[i]) < tolerance) {               found = true;           }           i++;       }       return found;    }    /**     * Returns true iff eigenVector is a scalar multiple of one of the columns     * of ed.getV().  Does not try linear combinations - i.e., should only be     * used to find vectors in one-dimensional eigenspaces.     */    protected void checkEigenVector(double[] eigenVector,            EigenDecomposition ed, double tolerance) {        Assert.assertTrue(isIncludedColumn(eigenVector, ed.getV(), tolerance));    }    /**     * Returns true iff there is a column that is a scalar multiple of column     * in searchMatrix (modulo tolerance)     */    private boolean isIncludedColumn(double[] column, RealMatrix searchMatrix,            double tolerance) {        boolean found = false;        int i = 0;        while (!found && i < searchMatrix.getColumnDimension()) {            double multiplier = 1.0;            boolean matching = true;            int j = 0;            while (matching && j < searchMatrix.getRowDimension()) {                double colEntry = searchMatrix.getEntry(j, i);                // Use the first entry where both are non-zero as scalar                if (FastMath.abs(multiplier - 1.0) <= FastMath.ulp(1.0) && FastMath.abs(colEntry) > 1E-14                        && FastMath.abs(column[j]) > 1e-14) {                    multiplier = colEntry / column[j];                }                if (FastMath.abs(column[j] * multiplier - colEntry) > tolerance) {                    matching = false;                }                j++;            }            found = matching;            i++;        }        return found;    }    @Before    public void setUp() {        refValues = new double[] {                2.003, 2.002, 2.001, 1.001, 1.000, 0.001        };        matrix = createTestMatrix(new Random(35992629946426l), refValues);    }    @After    public void tearDown() {        refValues = null;        matrix    = null;    }    static RealMatrix createTestMatrix(final Random r, final double[] eigenValues) {        final int n = eigenValues.length;        final RealMatrix v = createOrthogonalMatrix(r, n);        final RealMatrix d = createDiagonalMatrix(eigenValues, n, n);        return v.multiply(d).multiply(v.transpose());    }    public static RealMatrix createOrthogonalMatrix(final Random r, final int size) {        final double[][] data = new double[size][size];        for (int i = 0; i < size; ++i) {            final double[] dataI = data[i];            double norm2 = 0;            do {                // generate randomly row I                for (int j = 0; j < size; ++j) {                    dataI[j] = 2 * r.nextDouble() - 1;                }                // project the row in the subspace orthogonal to previous rows                for (int k = 0; k < i; ++k) {                    final double[] dataK = data[k];                    double dotProduct = 0;                    for (int j = 0; j < size; ++j) {                        dotProduct += dataI[j] * dataK[j];                    }                    for (int j = 0; j < size; ++j) {                        dataI[j] -= dotProduct * dataK[j];                    }                }                // normalize the row                norm2 = 0;                for (final double dataIJ : dataI) {                    norm2 += dataIJ * dataIJ;                }                final double inv = 1.0 / FastMath.sqrt(norm2);                for (int j = 0; j < size; ++j) {                    dataI[j] *= inv;                }            } while (norm2 * size < 0.01);        }        return MatrixUtils.createRealMatrix(data);    }    public static RealMatrix createDiagonalMatrix(final double[] diagonal,                                                  final int rows, final int columns) {        final double[][] dData = new double[rows][columns];        for (int i = 0; i < FastMath.min(rows, columns); ++i) {            dData[i][i] = diagonal[i];        }        return MatrixUtils.createRealMatrix(dData);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.dfp;import org.apache.commons.math.analysis.solvers.AllowedSolution;import org.apache.commons.math.exception.MathInternalError;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.junit.Assert;import org.junit.Before;import org.junit.Test;/** * Test case for {@link BracketingNthOrderBrentSolverDFP bracketing n<sup>th</sup> order Brent} solver. * * @version $Id$ */public final class BracketingNthOrderBrentSolverDFPTest {    @Test(expected=NumberIsTooSmallException.class)    public void testInsufficientOrder3() {        new BracketingNthOrderBrentSolverDFP(relativeAccuracy, absoluteAccuracy,                                             functionValueAccuracy, 1);    }    @Test    public void testConstructorOK() {        BracketingNthOrderBrentSolverDFP solver =                new BracketingNthOrderBrentSolverDFP(relativeAccuracy, absoluteAccuracy,                                                     functionValueAccuracy, 2);        Assert.assertEquals(2, solver.getMaximalOrder());    }    @Test    public void testConvergenceOnFunctionAccuracy() {        BracketingNthOrderBrentSolverDFP solver =                new BracketingNthOrderBrentSolverDFP(relativeAccuracy, absoluteAccuracy,                                                     field.newDfp(1.0e-20), 20);        UnivariateDfpFunction f = new UnivariateDfpFunction() {            public Dfp value(Dfp x) {                Dfp one     = field.getOne();                Dfp oneHalf = one.divide(2);                Dfp xMo     = x.subtract(one);                Dfp xMh     = x.subtract(oneHalf);                Dfp xPh     = x.add(oneHalf);                Dfp xPo     = x.add(one);                return xMo.multiply(xMh).multiply(x).multiply(xPh).multiply(xPo);            }        };        Dfp result = solver.solve(20, f, field.newDfp(0.2), field.newDfp(0.9),                                  field.newDfp(0.4), AllowedSolution.BELOW_SIDE);        Assert.assertTrue(f.value(result).abs().lessThan(solver.getFunctionValueAccuracy()));        Assert.assertTrue(f.value(result).negativeOrNull());        Assert.assertTrue(result.subtract(field.newDfp(0.5)).subtract(solver.getAbsoluteAccuracy()).positiveOrNull());        result = solver.solve(20, f, field.newDfp(-0.9), field.newDfp(-0.2),                              field.newDfp(-0.4), AllowedSolution.ABOVE_SIDE);        Assert.assertTrue(f.value(result).abs().lessThan(solver.getFunctionValueAccuracy()));        Assert.assertTrue(f.value(result).positiveOrNull());        Assert.assertTrue(result.add(field.newDfp(0.5)).subtract(solver.getAbsoluteAccuracy()).negativeOrNull());    }    @Test    public void testNeta() {        // the following test functions come from Beny Neta's paper:        // "Several New Methods for solving Equations"        // intern J. Computer Math Vol 23 pp 265-282        // available here: http://www.math.nps.navy.mil/~bneta/SeveralNewMethods.PDF        for (AllowedSolution allowed : AllowedSolution.values()) {            check(new UnivariateDfpFunction() {                public Dfp value(Dfp x) {                    return DfpMath.sin(x).subtract(x.divide(2));                }            }, 200, -2.0, 2.0, allowed);            check(new UnivariateDfpFunction() {                public Dfp value(Dfp x) {                    return DfpMath.pow(x, 5).add(x).subtract(field.newDfp(10000));                }            }, 200, -5.0, 10.0, allowed);            check(new UnivariateDfpFunction() {                public Dfp value(Dfp x) {                    return x.sqrt().subtract(field.getOne().divide(x)).subtract(field.newDfp(3));                }            }, 200, 0.001, 10.0, allowed);            check(new UnivariateDfpFunction() {                public Dfp value(Dfp x) {                    return DfpMath.exp(x).add(x).subtract(field.newDfp(20));                }            }, 200, -5.0, 5.0, allowed);            check(new UnivariateDfpFunction() {                public Dfp value(Dfp x) {                    return DfpMath.log(x).add(x.sqrt()).subtract(field.newDfp(5));                }            }, 200, 0.001, 10.0, allowed);            check(new UnivariateDfpFunction() {                public Dfp value(Dfp x) {                    return x.subtract(field.getOne()).multiply(x).multiply(x).subtract(field.getOne());                }            }, 200, -0.5, 1.5, allowed);        }    }    private void check(UnivariateDfpFunction f, int maxEval, double min, double max,                       AllowedSolution allowedSolution) {        BracketingNthOrderBrentSolverDFP solver =                new BracketingNthOrderBrentSolverDFP(relativeAccuracy, absoluteAccuracy,                                                     functionValueAccuracy, 20);        Dfp xResult = solver.solve(maxEval, f, field.newDfp(min), field.newDfp(max),                                   allowedSolution);        Dfp yResult = f.value(xResult);        switch (allowedSolution) {        case ANY_SIDE :            Assert.assertTrue(yResult.abs().lessThan(functionValueAccuracy.multiply(2)));            break;        case LEFT_SIDE : {            boolean increasing = f.value(xResult).add(absoluteAccuracy).greaterThan(yResult);            Assert.assertTrue(increasing ? yResult.negativeOrNull() : yResult.positiveOrNull());            break;        }        case RIGHT_SIDE : {            boolean increasing = f.value(xResult).add(absoluteAccuracy).greaterThan(yResult);            Assert.assertTrue(increasing ? yResult.positiveOrNull() : yResult.negativeOrNull());            break;        }        case BELOW_SIDE :            Assert.assertTrue(yResult.negativeOrNull());            break;        case ABOVE_SIDE :            Assert.assertTrue(yResult.positiveOrNull());            break;        default :            // this should never happen            throw new MathInternalError(null);        }    }    @Before    public void setUp() {        field                 = new DfpField(50);        absoluteAccuracy      = field.newDfp(1.0e-45);        relativeAccuracy      = field.newDfp(1.0e-45);        functionValueAccuracy = field.newDfp(1.0e-45);    }    private DfpField field;    private Dfp      absoluteAccuracy;    private Dfp      relativeAccuracy;    private Dfp      functionValueAccuracy;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.dfp;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public class DfpDecTest {    private DfpField field;    private Dfp pinf;    private Dfp ninf;    @Before    public void setUp() {        // Some basic setup.  Define some constants and clear the status flags        field = new DfpField(20);        pinf = new DfpDec(field, 1).divide(new DfpDec(field, 0));        ninf = new DfpDec(field, -1).divide(new DfpDec(field, 0));        ninf.getField().clearIEEEFlags();    }    @After    public void tearDown() {        field = null;        pinf    = null;        ninf    = null;    }    // Generic test function.  Takes params x and y and tests them for     // equality.  Then checks the status flags against the flags argument.    // If the test fail, it prints the desc string    private void test(Dfp x, Dfp y, int flags, String desc) {        boolean b = x.equals(y);        if (!x.equals(y) && !x.unequal(y))  // NaNs involved             b = (x.toString().equals(y.toString()));        if (x.equals(new DfpDec(field, 0)))  // distinguish +/- zero            b = (b && (x.toString().equals(y.toString())));        b = (b && x.getField().getIEEEFlags() == flags);        if (!b)            Assert.assertTrue("assersion failed "+desc+" x = "+x.toString()+" flags = "+x.getField().getIEEEFlags(), b);        x.getField().clearIEEEFlags();    }    @Test    public void testRound()    {        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);        test(new DfpDec(field, "12345678901234567890"),             new DfpDec(field, "12345678901234568000"),             DfpField.FLAG_INEXACT, "Round #1");        test(new DfpDec(field, "0.12345678901234567890"),             new DfpDec(field, "0.12345678901234568"),             DfpField.FLAG_INEXACT, "Round #2");        test(new DfpDec(field, "0.12345678901234567500"),             new DfpDec(field, "0.12345678901234568"),             DfpField.FLAG_INEXACT, "Round #3");        test(new DfpDec(field, "0.12345678901234568500"),             new DfpDec(field, "0.12345678901234568"),             DfpField.FLAG_INEXACT, "Round #4");        test(new DfpDec(field, "0.12345678901234568501"),             new DfpDec(field, "0.12345678901234569"),             DfpField.FLAG_INEXACT, "Round #5");        test(new DfpDec(field, "0.12345678901234568499"),             new DfpDec(field, "0.12345678901234568"),             DfpField.FLAG_INEXACT, "Round #6");        test(new DfpDec(field, "1.2345678901234567890"),             new DfpDec(field, "1.2345678901234568"),             DfpField.FLAG_INEXACT, "Round #7");        test(new DfpDec(field, "1.2345678901234567500"),             new DfpDec(field, "1.2345678901234568"),             DfpField.FLAG_INEXACT, "Round #8");        test(new DfpDec(field, "1.2345678901234568500"),             new DfpDec(field, "1.2345678901234568"),             DfpField.FLAG_INEXACT, "Round #9");        test(new DfpDec(field, "1.2345678901234568000").add(new DfpDec(field, ".0000000000000000501")),             new DfpDec(field, "1.2345678901234569"),             DfpField.FLAG_INEXACT, "Round #10");        test(new DfpDec(field, "1.2345678901234568499"),             new DfpDec(field, "1.2345678901234568"),             DfpField.FLAG_INEXACT, "Round #11");        test(new DfpDec(field, "12.345678901234567890"),             new DfpDec(field, "12.345678901234568"),             DfpField.FLAG_INEXACT, "Round #12");        test(new DfpDec(field, "12.345678901234567500"),             new DfpDec(field, "12.345678901234568"),             DfpField.FLAG_INEXACT, "Round #13");        test(new DfpDec(field, "12.345678901234568500"),             new DfpDec(field, "12.345678901234568"),             DfpField.FLAG_INEXACT, "Round #14");        test(new DfpDec(field, "12.345678901234568").add(new DfpDec(field, ".000000000000000501")),             new DfpDec(field, "12.345678901234569"),             DfpField.FLAG_INEXACT, "Round #15");        test(new DfpDec(field, "12.345678901234568499"),             new DfpDec(field, "12.345678901234568"),             DfpField.FLAG_INEXACT, "Round #16");        test(new DfpDec(field, "123.45678901234567890"),             new DfpDec(field, "123.45678901234568"),             DfpField.FLAG_INEXACT, "Round #17");        test(new DfpDec(field, "123.45678901234567500"),             new DfpDec(field, "123.45678901234568"),             DfpField.FLAG_INEXACT, "Round #18");        test(new DfpDec(field, "123.45678901234568500"),             new DfpDec(field, "123.45678901234568"),             DfpField.FLAG_INEXACT, "Round #19");        test(new DfpDec(field, "123.456789012345685").add(new DfpDec(field, ".00000000000000501")),             new DfpDec(field, "123.45678901234569"),             DfpField.FLAG_INEXACT, "Round #20");        test(new DfpDec(field, "123.45678901234568499"),             new DfpDec(field, "123.45678901234568"),             DfpField.FLAG_INEXACT, "Round #21");        field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN);        // Round down        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.9")),             new DfpDec(field, "12345678901234567"),             DfpField.FLAG_INEXACT, "Round #22");        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.99999999")),             new DfpDec(field, "12345678901234567"),             DfpField.FLAG_INEXACT, "Round #23");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.99999999")),             new DfpDec(field, "-12345678901234567"),             DfpField.FLAG_INEXACT, "Round #24");        field.setRoundingMode(DfpField.RoundingMode.ROUND_UP);        // Round up        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.1")),             new DfpDec(field, "12345678901234568"),             DfpField.FLAG_INEXACT, "Round #25");        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.0001")),             new DfpDec(field, "12345678901234568"),             DfpField.FLAG_INEXACT, "Round #26");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.1")),             new DfpDec(field, "-12345678901234568"),             DfpField.FLAG_INEXACT, "Round #27");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.0001")),             new DfpDec(field, "-12345678901234568"),             DfpField.FLAG_INEXACT, "Round #28");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "0")),             new DfpDec(field, "-12345678901234567"),             0, "Round #28.5");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP);        // Round half up        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.499999999999")),             new DfpDec(field, "12345678901234567"),             DfpField.FLAG_INEXACT, "Round #29");        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.50000001")),             new DfpDec(field, "12345678901234568"),             DfpField.FLAG_INEXACT, "Round #30");        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.5")),             new DfpDec(field, "12345678901234568"),             DfpField.FLAG_INEXACT, "Round #30.5");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.499999999999")),             new DfpDec(field, "-12345678901234567"),             DfpField.FLAG_INEXACT, "Round #31");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.50000001")),             new DfpDec(field, "-12345678901234568"),             DfpField.FLAG_INEXACT, "Round #32");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN);        // Round half down        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.5001")),             new DfpDec(field, "12345678901234568"),             DfpField.FLAG_INEXACT, "Round #33");        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.5000")),             new DfpDec(field, "12345678901234567"),             DfpField.FLAG_INEXACT, "Round #34");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.5001")),             new DfpDec(field, "-12345678901234568"),             DfpField.FLAG_INEXACT, "Round #35");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.6")),             new DfpDec(field, "-12345678901234568"),             DfpField.FLAG_INEXACT, "Round #35.5");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.5000")),             new DfpDec(field, "-12345678901234567"),             DfpField.FLAG_INEXACT, "Round #36");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD);        // Round half odd        test(new DfpDec(field, "12345678901234568").add(new DfpDec(field, "0.5000")),             new DfpDec(field, "12345678901234569"),             DfpField.FLAG_INEXACT, "Round #37");        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.5000")),             new DfpDec(field, "12345678901234567"),             DfpField.FLAG_INEXACT, "Round #38");        test(new DfpDec(field, "-12345678901234568").add(new DfpDec(field, "-0.5000")),             new DfpDec(field, "-12345678901234569"),             DfpField.FLAG_INEXACT, "Round #39");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.5000")),             new DfpDec(field, "-12345678901234567"),             DfpField.FLAG_INEXACT, "Round #40");        field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL);        // Round ceil        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.0001")),             new DfpDec(field, "12345678901234568"),             DfpField.FLAG_INEXACT, "Round #41");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.9999")),             new DfpDec(field, "-12345678901234567"),             DfpField.FLAG_INEXACT, "Round #42");        field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR);        // Round floor        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.9999")),             new DfpDec(field, "12345678901234567"),             DfpField.FLAG_INEXACT, "Round #43");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.0001")),             new DfpDec(field, "-12345678901234568"),             DfpField.FLAG_INEXACT, "Round #44");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);  // reset    }    @Test    public void testRoundDecimal10()    {        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);        test(new Decimal10(field, "1234567891234567890"),             new Decimal10(field, "1234567891000000000"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #1");        test(new Decimal10(field, "0.1234567891634567890"),             new Decimal10(field, "0.1234567892"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #2");        test(new Decimal10(field, "0.1234567891500000000"),             new Decimal10(field, "0.1234567892"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #3");        test(new Decimal10(field, "0.1234567890500"),             new Decimal10(field, "0.1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #4");        test(new Decimal10(field, "0.1234567890501"),             new Decimal10(field, "0.1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #5");        test(new Decimal10(field, "0.1234567890499"),             new Decimal10(field, "0.1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #6");        test(new Decimal10(field, "1.234567890890"),             new Decimal10(field, "1.234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #7");        test(new Decimal10(field, "1.234567891500"),             new Decimal10(field, "1.234567892"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #8");        test(new Decimal10(field, "1.234567890500"),             new Decimal10(field, "1.234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #9");        test(new Decimal10(field, "1.234567890000").add(new Decimal10(field, ".000000000501")),             new Decimal10(field, "1.234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #10");        test(new Decimal10(field, "1.234567890499"),             new Decimal10(field, "1.234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #11");        test(new Decimal10(field, "12.34567890890"),             new Decimal10(field, "12.34567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #12");        test(new Decimal10(field, "12.34567891500"),             new Decimal10(field, "12.34567892"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #13");        test(new Decimal10(field, "12.34567890500"),             new Decimal10(field, "12.34567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #14");        test(new Decimal10(field, "12.34567890").add(new Decimal10(field, ".00000000501")),             new Decimal10(field, "12.34567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #15");        test(new Decimal10(field, "12.34567890499"),             new Decimal10(field, "12.34567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #16");        test(new Decimal10(field, "123.4567890890"),             new Decimal10(field, "123.4567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #17");        test(new Decimal10(field, "123.4567891500"),             new Decimal10(field, "123.4567892"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #18");        test(new Decimal10(field, "123.4567890500"),             new Decimal10(field, "123.4567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #19");        test(new Decimal10(field, "123.4567890").add(new Decimal10(field, ".0000000501")),             new Decimal10(field, "123.4567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #20");        test(new Decimal10(field, "123.4567890499"),             new Decimal10(field, "123.4567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #21");        field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN);        // RoundDecimal10 down        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.9")),             new Decimal10(field, "1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #22");        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.99999999")),             new Decimal10(field, "1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #23");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.99999999")),             new Decimal10(field, "-1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #24");        field.setRoundingMode(DfpField.RoundingMode.ROUND_UP);        // RoundDecimal10 up        test(new Decimal10(field, 1234567890).add(new Decimal10(field, "0.1")),             new Decimal10(field, 1234567891l),             DfpField.FLAG_INEXACT, "RoundDecimal10 #25");        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.0001")),             new Decimal10(field, "1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #26");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.1")),             new Decimal10(field, "-1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #27");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.0001")),             new Decimal10(field, "-1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #28");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "0")),             new Decimal10(field, "-1234567890"),             0, "RoundDecimal10 #28.5");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP);        // RoundDecimal10 half up        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.4999999999")),             new Decimal10(field, "1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #29");        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.50000001")),             new Decimal10(field, "1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #30");        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.5")),             new Decimal10(field, "1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #30.5");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.4999999999")),             new Decimal10(field, "-1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #31");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.50000001")),             new Decimal10(field, "-1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #32");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN);        // RoundDecimal10 half down        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.5001")),             new Decimal10(field, "1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #33");        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.5000")),             new Decimal10(field, "1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #34");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.5001")),             new Decimal10(field, "-1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #35");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.6")),             new Decimal10(field, "-1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #35.5");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.5000")),             new Decimal10(field, "-1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #36");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD);        // RoundDecimal10 half odd        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.5000")),             new Decimal10(field, "1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #37");        test(new Decimal10(field, "1234567891").add(new Decimal10(field, "0.5000")),             new Decimal10(field, "1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #38");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.5000")),             new Decimal10(field, "-1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #39");        test(new Decimal10(field, "-1234567891").add(new Decimal10(field, "-0.5000")),             new Decimal10(field, "-1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #40");        field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL);        // RoundDecimal10 ceil        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.0001")),             new Decimal10(field, "1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #41");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.9999")),             new Decimal10(field, "-1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #42");        field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR);        // RoundDecimal10 floor        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.9999")),             new Decimal10(field, "1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #43");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.0001")),             new Decimal10(field, "-1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #44");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);  // reset    }    @Test    public void testNextAfter()    {        test(new DfpDec(field, 1).nextAfter(pinf),             new DfpDec(field, "1.0000000000000001"),             0, "NextAfter #1");        test(new DfpDec(field, "1.0000000000000001").nextAfter(ninf),             new DfpDec(field, 1),             0, "NextAfter #1.5");        test(new DfpDec(field, 1).nextAfter(ninf),             new DfpDec(field, "0.99999999999999999"),             0, "NextAfter #2");        test(new DfpDec(field, "0.99999999999999999").nextAfter(new DfpDec(field, 2)),             new DfpDec(field, 1),             0, "NextAfter #3");        test(new DfpDec(field, -1).nextAfter(ninf),             new DfpDec(field, "-1.0000000000000001"),             0, "NextAfter #4");        test(new DfpDec(field, -1).nextAfter(pinf),             new DfpDec(field, "-0.99999999999999999"),             0, "NextAfter #5");        test(new DfpDec(field, "-0.99999999999999999").nextAfter(new DfpDec(field, -2)),             new DfpDec(field, (byte) -1),             0, "NextAfter #6");        test(new DfpDec(field, (byte) 2).nextAfter(new DfpDec(field, 2)),             new DfpDec(field, 2l),             0, "NextAfter #7");        test(new DfpDec(field, 0).nextAfter(new DfpDec(field, 0)),             new DfpDec(field, 0),             0, "NextAfter #8");        test(new DfpDec(field, -2).nextAfter(new DfpDec(field, -2)),             new DfpDec(field, -2),             0, "NextAfter #9");        test(new DfpDec(field, 0).nextAfter(new DfpDec(field, 1)),             new DfpDec(field, "1e-131092"),             DfpField.FLAG_UNDERFLOW, "NextAfter #10");        test(new DfpDec(field, 0).nextAfter(new DfpDec(field, -1)),             new DfpDec(field, "-1e-131092"),             DfpField.FLAG_UNDERFLOW, "NextAfter #11");        test(new DfpDec(field, "-1e-131092").nextAfter(pinf),             new DfpDec(field, "-0"),             DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, "Next After #12");        test(new DfpDec(field, "1e-131092").nextAfter(ninf),              new DfpDec(field, "0"),             DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, "Next After #13");        test(new DfpDec(field, "9.9999999999999999e131078").nextAfter(pinf),             pinf,             DfpField.FLAG_OVERFLOW|DfpField.FLAG_INEXACT, "Next After #14");    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.dfp;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.util.MathUtils;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public class DfpTest {    private DfpField field;    private Dfp pinf;    private Dfp ninf;    private Dfp nan;    private Dfp snan;    private Dfp qnan;    @Before    public void setUp() {        // Some basic setup.  Define some constants and clear the status flags        field = new DfpField(20);        pinf = field.newDfp("1").divide(field.newDfp("0"));        ninf = field.newDfp("-1").divide(field.newDfp("0"));        nan = field.newDfp("0").divide(field.newDfp("0"));        snan = field.newDfp((byte)1, Dfp.SNAN);        qnan = field.newDfp((byte)1, Dfp.QNAN);        ninf.getField().clearIEEEFlags();    }    @After    public void tearDown() {        field = null;        pinf    = null;        ninf    = null;        nan     = null;        snan    = null;        qnan    = null;    }    // Generic test function.  Takes params x and y and tests them for     // equality.  Then checks the status flags against the flags argument.    // If the test fail, it prints the desc string    private void test(Dfp x, Dfp y, int flags, String desc)    {        boolean b = x.equals(y);        if (!x.equals(y) && !x.unequal(y))  // NaNs involved             b = (x.toString().equals(y.toString()));        if (x.equals(field.newDfp("0")))  // distinguish +/- zero            b = (b && (x.toString().equals(y.toString())));        b = (b && x.getField().getIEEEFlags() == flags);        if (!b)            Assert.assertTrue("assersion failed "+desc+" x = "+x.toString()+" flags = "+x.getField().getIEEEFlags(), b);        x.getField().clearIEEEFlags();    }    @Test    public void testByteConstructor() {        Assert.assertEquals("0.", new Dfp(field, (byte) 0).toString());        Assert.assertEquals("1.", new Dfp(field, (byte) 1).toString());        Assert.assertEquals("-1.", new Dfp(field, (byte) -1).toString());        Assert.assertEquals("-128.", new Dfp(field, Byte.MIN_VALUE).toString());        Assert.assertEquals("127.", new Dfp(field, Byte.MAX_VALUE).toString());    }    @Test    public void testIntConstructor() {        Assert.assertEquals("0.", new Dfp(field, 0).toString());        Assert.assertEquals("1.", new Dfp(field, 1).toString());        Assert.assertEquals("-1.", new Dfp(field, -1).toString());        Assert.assertEquals("1234567890.", new Dfp(field, 1234567890).toString());        Assert.assertEquals("-1234567890.", new Dfp(field, -1234567890).toString());        Assert.assertEquals("-2147483648.", new Dfp(field, Integer.MIN_VALUE).toString());        Assert.assertEquals("2147483647.", new Dfp(field, Integer.MAX_VALUE).toString());    }    @Test    public void testLongConstructor() {        Assert.assertEquals("0.", new Dfp(field, 0l).toString());        Assert.assertEquals("1.", new Dfp(field, 1l).toString());        Assert.assertEquals("-1.", new Dfp(field, -1l).toString());        Assert.assertEquals("1234567890.", new Dfp(field, 1234567890l).toString());        Assert.assertEquals("-1234567890.", new Dfp(field, -1234567890l).toString());        Assert.assertEquals("-9223372036854775808.", new Dfp(field, Long.MIN_VALUE).toString());        Assert.assertEquals("9223372036854775807.", new Dfp(field, Long.MAX_VALUE).toString());    }    /*     *  Test addition     */    @Test    public void testAdd()    {        test(field.newDfp("1").add(field.newDfp("1")),      // Basic tests   1+1 = 2             field.newDfp("2"),              0, "Add #1");        test(field.newDfp("1").add(field.newDfp("-1")),     // 1 + (-1) = 0             field.newDfp("0"),              0, "Add #2");        test(field.newDfp("-1").add(field.newDfp("1")),     // (-1) + 1 = 0             field.newDfp("0"),              0, "Add #3");        test(field.newDfp("-1").add(field.newDfp("-1")),     // (-1) + (-1) = -2             field.newDfp("-2"),              0, "Add #4");        // rounding mode is round half even        test(field.newDfp("1").add(field.newDfp("1e-16")),     // rounding on add             field.newDfp("1.0000000000000001"),              0, "Add #5");        test(field.newDfp("1").add(field.newDfp("1e-17")),     // rounding on add             field.newDfp("1"),              DfpField.FLAG_INEXACT, "Add #6");        test(field.newDfp("0.90999999999999999999").add(field.newDfp("0.1")),     // rounding on add             field.newDfp("1.01"),              DfpField.FLAG_INEXACT, "Add #7");        test(field.newDfp(".10000000000000005000").add(field.newDfp(".9")),     // rounding on add             field.newDfp("1."),              DfpField.FLAG_INEXACT, "Add #8");        test(field.newDfp(".10000000000000015000").add(field.newDfp(".9")),     // rounding on add             field.newDfp("1.0000000000000002"),              DfpField.FLAG_INEXACT, "Add #9");        test(field.newDfp(".10000000000000014999").add(field.newDfp(".9")),     // rounding on add             field.newDfp("1.0000000000000001"),              DfpField.FLAG_INEXACT, "Add #10");        test(field.newDfp(".10000000000000015001").add(field.newDfp(".9")),     // rounding on add             field.newDfp("1.0000000000000002"),              DfpField.FLAG_INEXACT, "Add #11");        test(field.newDfp(".11111111111111111111").add(field.newDfp("11.1111111111111111")), // rounding on add             field.newDfp("11.22222222222222222222"),              DfpField.FLAG_INEXACT, "Add #12");        test(field.newDfp(".11111111111111111111").add(field.newDfp("1111111111111111.1111")), // rounding on add             field.newDfp("1111111111111111.2222"),              DfpField.FLAG_INEXACT, "Add #13");        test(field.newDfp(".11111111111111111111").add(field.newDfp("11111111111111111111")), // rounding on add             field.newDfp("11111111111111111111"),              DfpField.FLAG_INEXACT, "Add #14");        test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("-1e131052")), // overflow on add             field.newDfp("9.9999999999999999998e131071"),              0, "Add #15");        test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("1e131052")), // overflow on add             pinf,              DfpField.FLAG_OVERFLOW, "Add #16");        test(field.newDfp("-9.9999999999999999999e131071").add(field.newDfp("-1e131052")), // overflow on add             ninf,              DfpField.FLAG_OVERFLOW, "Add #17");        test(field.newDfp("-9.9999999999999999999e131071").add(field.newDfp("1e131052")), // overflow on add             field.newDfp("-9.9999999999999999998e131071"),              0, "Add #18");        test(field.newDfp("1e-131072").add(field.newDfp("1e-131072")), // underflow on add             field.newDfp("2e-131072"),              0, "Add #19");        test(field.newDfp("1.0000000000000001e-131057").add(field.newDfp("-1e-131057")), // underflow on add             field.newDfp("1e-131073"),              DfpField.FLAG_UNDERFLOW, "Add #20");        test(field.newDfp("1.1e-131072").add(field.newDfp("-1e-131072")), // underflow on add             field.newDfp("1e-131073"),              DfpField.FLAG_UNDERFLOW, "Add #21");        test(field.newDfp("1.0000000000000001e-131072").add(field.newDfp("-1e-131072")), // underflow on add             field.newDfp("1e-131088"),              DfpField.FLAG_UNDERFLOW, "Add #22");        test(field.newDfp("1.0000000000000001e-131078").add(field.newDfp("-1e-131078")), // underflow on add             field.newDfp("0"),              DfpField.FLAG_UNDERFLOW, "Add #23");        test(field.newDfp("1.0").add(field.newDfp("-1e-20")), // loss of precision on alignment?             field.newDfp("0.99999999999999999999"),              0, "Add #23.1");        test(field.newDfp("-0.99999999999999999999").add(field.newDfp("1")), // proper normalization?             field.newDfp("0.00000000000000000001"),              0, "Add #23.2");        test(field.newDfp("1").add(field.newDfp("0")), // adding zeros             field.newDfp("1"),              0, "Add #24");        test(field.newDfp("0").add(field.newDfp("0")), // adding zeros             field.newDfp("0"),              0, "Add #25");        test(field.newDfp("-0").add(field.newDfp("0")), // adding zeros             field.newDfp("0"),              0, "Add #26");        test(field.newDfp("0").add(field.newDfp("-0")), // adding zeros             field.newDfp("0"),              0, "Add #27");        test(field.newDfp("-0").add(field.newDfp("-0")), // adding zeros             field.newDfp("-0"),              0, "Add #28");        test(field.newDfp("1e-20").add(field.newDfp("0")), // adding zeros             field.newDfp("1e-20"),              0, "Add #29");        test(field.newDfp("1e-40").add(field.newDfp("0")), // adding zeros             field.newDfp("1e-40"),              0, "Add #30");        test(pinf.add(ninf), // adding infinities             nan,              DfpField.FLAG_INVALID, "Add #31");        test(ninf.add(pinf), // adding infinities             nan,              DfpField.FLAG_INVALID, "Add #32");        test(ninf.add(ninf), // adding infinities             ninf,              0, "Add #33");        test(pinf.add(pinf), // adding infinities             pinf,              0, "Add #34");        test(pinf.add(field.newDfp("0")), // adding infinities             pinf,              0, "Add #35");        test(pinf.add(field.newDfp("-1e131071")), // adding infinities             pinf,              0, "Add #36");        test(pinf.add(field.newDfp("1e131071")), // adding infinities             pinf,              0, "Add #37");        test(field.newDfp("0").add(pinf), // adding infinities             pinf,              0, "Add #38");        test(field.newDfp("-1e131071").add(pinf), // adding infinities             pinf,              0, "Add #39");        test(field.newDfp("1e131071").add(pinf), // adding infinities             pinf,              0, "Add #40");        test(ninf.add(field.newDfp("0")), // adding infinities             ninf,              0, "Add #41");        test(ninf.add(field.newDfp("-1e131071")), // adding infinities             ninf,              0, "Add #42");        test(ninf.add(field.newDfp("1e131071")), // adding infinities             ninf,              0, "Add #43");        test(field.newDfp("0").add(ninf), // adding infinities             ninf,              0, "Add #44");        test(field.newDfp("-1e131071").add(ninf), // adding infinities             ninf,              0, "Add #45");        test(field.newDfp("1e131071").add(ninf), // adding infinities             ninf,              0, "Add #46");        test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("5e131051")),  // overflow             pinf,             DfpField.FLAG_OVERFLOW, "Add #47");        test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("4.9999999999999999999e131051")),  // overflow             field.newDfp("9.9999999999999999999e131071"),             DfpField.FLAG_INEXACT, "Add #48");        test(nan.add(field.newDfp("1")),             nan,             0, "Add #49");        test(field.newDfp("1").add(nan),             nan,             0, "Add #50");        test(field.newDfp("12345678123456781234").add(field.newDfp("0.12345678123456781234")),             field.newDfp("12345678123456781234"),             DfpField.FLAG_INEXACT, "Add #51");        test(field.newDfp("12345678123456781234").add(field.newDfp("123.45678123456781234")),             field.newDfp("12345678123456781357"),             DfpField.FLAG_INEXACT, "Add #52");        test(field.newDfp("123.45678123456781234").add(field.newDfp("12345678123456781234")),             field.newDfp("12345678123456781357"),             DfpField.FLAG_INEXACT, "Add #53");        test(field.newDfp("12345678123456781234").add(field.newDfp(".00001234567812345678")),             field.newDfp("12345678123456781234"),             DfpField.FLAG_INEXACT, "Add #54");        test(field.newDfp("12345678123456781234").add(field.newDfp(".00000000123456781234")),             field.newDfp("12345678123456781234"),             DfpField.FLAG_INEXACT, "Add #55");        test(field.newDfp("-0").add(field.newDfp("-0")),             field.newDfp("-0"),             0, "Add #56");         test(field.newDfp("0").add(field.newDfp("-0")),             field.newDfp("0"),             0, "Add #57");         test(field.newDfp("-0").add(field.newDfp("0")),             field.newDfp("0"),             0, "Add #58");         test(field.newDfp("0").add(field.newDfp("0")),             field.newDfp("0"),             0, "Add #59");     }    ////////////////////////////////////////////////////////////////////////////////////////////////////////    // Test comparisons    // utility function to help test comparisons    private void cmptst(Dfp a, Dfp b, String op, boolean result, double num)    {        if (op == "equal")            if (a.equals(b) != result)                Assert.fail("assersion failed.  "+op+" compare #"+num);        if (op == "unequal")            if (a.unequal(b) != result)                Assert.fail("assersion failed.  "+op+" compare #"+num);        if (op == "lessThan")            if (a.lessThan(b) != result)                Assert.fail("assersion failed.  "+op+" compare #"+num);        if (op == "greaterThan")            if (a.greaterThan(b) != result)                Assert.fail("assersion failed.  "+op+" compare #"+num);    }    @Test    public void  testCompare()    {        // test equal() comparison        // check zero vs. zero        field.clearIEEEFlags();        cmptst(field.newDfp("0"), field.newDfp("0"), "equal", true, 1);         // 0 == 0        cmptst(field.newDfp("0"), field.newDfp("-0"), "equal", true, 2);        // 0 == -0        cmptst(field.newDfp("-0"), field.newDfp("-0"), "equal", true, 3);       // -0 == -0        cmptst(field.newDfp("-0"), field.newDfp("0"), "equal", true, 4);        // -0 == 0        // check zero vs normal numbers        cmptst(field.newDfp("0"), field.newDfp("1"), "equal", false, 5);         // 0 == 1        cmptst(field.newDfp("1"), field.newDfp("0"), "equal", false, 6);         // 1 == 0        cmptst(field.newDfp("-1"), field.newDfp("0"), "equal", false, 7);        // -1 == 0        cmptst(field.newDfp("0"), field.newDfp("-1"), "equal", false, 8);        // 0 == -1        cmptst(field.newDfp("0"), field.newDfp("1e-131072"), "equal", false, 9); // 0 == 1e-131072        // check flags         if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        cmptst(field.newDfp("0"), field.newDfp("1e-131078"), "equal", false, 10); // 0 == 1e-131078        // check flags  -- underflow should be set        if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        field.clearIEEEFlags();        cmptst(field.newDfp("0"), field.newDfp("1e+131071"), "equal", false, 11); // 0 == 1e+131071        // check zero vs infinities        cmptst(field.newDfp("0"), pinf, "equal", false, 12);    // 0 == pinf        cmptst(field.newDfp("0"), ninf, "equal", false, 13);    // 0 == ninf        cmptst(field.newDfp("-0"), pinf, "equal", false, 14);   // -0 == pinf        cmptst(field.newDfp("-0"), ninf, "equal", false, 15);   // -0 == ninf        cmptst(pinf, field.newDfp("0"), "equal", false, 16);    // pinf == 0        cmptst(ninf, field.newDfp("0"), "equal", false, 17);    // ninf == 0        cmptst(pinf, field.newDfp("-0"), "equal", false, 18);   // pinf == -0        cmptst(ninf, field.newDfp("-0"), "equal", false, 19);   // ninf == -0        cmptst(ninf, pinf, "equal", false, 19.10);     // ninf == pinf        cmptst(pinf, ninf, "equal", false, 19.11);     // pinf == ninf        cmptst(pinf, pinf, "equal", true, 19.12);     // pinf == pinf        cmptst(ninf, ninf, "equal", true, 19.13);     // ninf == ninf        // check some normal numbers        cmptst(field.newDfp("1"), field.newDfp("1"), "equal", true, 20);   // 1 == 1        cmptst(field.newDfp("1"), field.newDfp("-1"), "equal", false, 21);   // 1 == -1        cmptst(field.newDfp("-1"), field.newDfp("-1"), "equal", true, 22);   // -1 == -1        cmptst(field.newDfp("1"), field.newDfp("1.0000000000000001"), "equal", false, 23);   // 1 == 1.0000000000000001        // The tests below checks to ensure that comparisons don't set FLAG_INEXACT        // 100000 == 1.0000000000000001        cmptst(field.newDfp("1e20"), field.newDfp("1.0000000000000001"), "equal", false, 24);        if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        cmptst(field.newDfp("0.000001"), field.newDfp("1e-6"), "equal", true, 25);        // check some nans -- nans shouldnt equal anything        cmptst(snan, snan, "equal", false, 27);        cmptst(qnan, qnan, "equal", false, 28);        cmptst(snan, qnan, "equal", false, 29);        cmptst(qnan, snan, "equal", false, 30);        cmptst(qnan, field.newDfp("0"), "equal", false, 31);        cmptst(snan, field.newDfp("0"), "equal", false, 32);        cmptst(field.newDfp("0"), snan, "equal", false, 33);        cmptst(field.newDfp("0"), qnan, "equal", false, 34);        cmptst(qnan, pinf, "equal", false, 35);        cmptst(snan, pinf, "equal", false, 36);        cmptst(pinf, snan, "equal", false, 37);        cmptst(pinf, qnan, "equal", false, 38);        cmptst(qnan, ninf, "equal", false, 39);        cmptst(snan, ninf, "equal", false, 40);        cmptst(ninf, snan, "equal", false, 41);        cmptst(ninf, qnan, "equal", false, 42);        cmptst(qnan, field.newDfp("-1"), "equal", false, 43);        cmptst(snan, field.newDfp("-1"), "equal", false, 44);        cmptst(field.newDfp("-1"), snan, "equal", false, 45);        cmptst(field.newDfp("-1"), qnan, "equal", false, 46);        cmptst(qnan, field.newDfp("1"), "equal", false, 47);        cmptst(snan, field.newDfp("1"), "equal", false, 48);        cmptst(field.newDfp("1"), snan, "equal", false, 49);        cmptst(field.newDfp("1"), qnan, "equal", false, 50);        cmptst(snan.negate(), snan, "equal", false, 51);        cmptst(qnan.negate(), qnan, "equal", false, 52);        //        // Tests for un equal  -- do it all over again        //        cmptst(field.newDfp("0"), field.newDfp("0"), "unequal", false, 1);         // 0 == 0        cmptst(field.newDfp("0"), field.newDfp("-0"), "unequal", false, 2);        // 0 == -0        cmptst(field.newDfp("-0"), field.newDfp("-0"), "unequal", false, 3);       // -0 == -0        cmptst(field.newDfp("-0"), field.newDfp("0"), "unequal", false, 4);        // -0 == 0        // check zero vs normal numbers        cmptst(field.newDfp("0"), field.newDfp("1"), "unequal", true, 5);         // 0 == 1        cmptst(field.newDfp("1"), field.newDfp("0"), "unequal", true, 6);         // 1 == 0        cmptst(field.newDfp("-1"), field.newDfp("0"), "unequal", true, 7);        // -1 == 0        cmptst(field.newDfp("0"), field.newDfp("-1"), "unequal", true, 8);        // 0 == -1        cmptst(field.newDfp("0"), field.newDfp("1e-131072"), "unequal", true, 9); // 0 == 1e-131072        // check flags         if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        cmptst(field.newDfp("0"), field.newDfp("1e-131078"), "unequal", true, 10); // 0 == 1e-131078        // check flags  -- underflow should be set        if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        field.clearIEEEFlags();        cmptst(field.newDfp("0"), field.newDfp("1e+131071"), "unequal", true, 11); // 0 == 1e+131071        // check zero vs infinities        cmptst(field.newDfp("0"), pinf, "unequal", true, 12);    // 0 == pinf        cmptst(field.newDfp("0"), ninf, "unequal", true, 13);    // 0 == ninf        cmptst(field.newDfp("-0"), pinf, "unequal", true, 14);   // -0 == pinf        cmptst(field.newDfp("-0"), ninf, "unequal", true, 15);   // -0 == ninf        cmptst(pinf, field.newDfp("0"), "unequal", true, 16);    // pinf == 0        cmptst(ninf, field.newDfp("0"), "unequal", true, 17);    // ninf == 0        cmptst(pinf, field.newDfp("-0"), "unequal", true, 18);   // pinf == -0        cmptst(ninf, field.newDfp("-0"), "unequal", true, 19);   // ninf == -0        cmptst(ninf, pinf, "unequal", true, 19.10);     // ninf == pinf        cmptst(pinf, ninf, "unequal", true, 19.11);     // pinf == ninf        cmptst(pinf, pinf, "unequal", false, 19.12);     // pinf == pinf        cmptst(ninf, ninf, "unequal", false, 19.13);     // ninf == ninf        // check some normal numbers        cmptst(field.newDfp("1"), field.newDfp("1"), "unequal", false, 20);   // 1 == 1        cmptst(field.newDfp("1"), field.newDfp("-1"), "unequal", true, 21);   // 1 == -1        cmptst(field.newDfp("-1"), field.newDfp("-1"), "unequal", false, 22);   // -1 == -1        cmptst(field.newDfp("1"), field.newDfp("1.0000000000000001"), "unequal", true, 23);   // 1 == 1.0000000000000001        // The tests below checks to ensure that comparisons don't set FLAG_INEXACT        // 100000 == 1.0000000000000001        cmptst(field.newDfp("1e20"), field.newDfp("1.0000000000000001"), "unequal", true, 24);        if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        cmptst(field.newDfp("0.000001"), field.newDfp("1e-6"), "unequal", false, 25);        // check some nans -- nans shouldnt be unequal to anything        cmptst(snan, snan, "unequal", false, 27);        cmptst(qnan, qnan, "unequal", false, 28);        cmptst(snan, qnan, "unequal", false, 29);        cmptst(qnan, snan, "unequal", false, 30);        cmptst(qnan, field.newDfp("0"), "unequal", false, 31);        cmptst(snan, field.newDfp("0"), "unequal", false, 32);        cmptst(field.newDfp("0"), snan, "unequal", false, 33);        cmptst(field.newDfp("0"), qnan, "unequal", false, 34);        cmptst(qnan, pinf, "unequal", false, 35);        cmptst(snan, pinf, "unequal", false, 36);        cmptst(pinf, snan, "unequal", false, 37);        cmptst(pinf, qnan, "unequal", false, 38);        cmptst(qnan, ninf, "unequal", false, 39);        cmptst(snan, ninf, "unequal", false, 40);        cmptst(ninf, snan, "unequal", false, 41);        cmptst(ninf, qnan, "unequal", false, 42);        cmptst(qnan, field.newDfp("-1"), "unequal", false, 43);        cmptst(snan, field.newDfp("-1"), "unequal", false, 44);        cmptst(field.newDfp("-1"), snan, "unequal", false, 45);        cmptst(field.newDfp("-1"), qnan, "unequal", false, 46);        cmptst(qnan, field.newDfp("1"), "unequal", false, 47);        cmptst(snan, field.newDfp("1"), "unequal", false, 48);        cmptst(field.newDfp("1"), snan, "unequal", false, 49);        cmptst(field.newDfp("1"), qnan, "unequal", false, 50);        cmptst(snan.negate(), snan, "unequal", false, 51);        cmptst(qnan.negate(), qnan, "unequal", false, 52);        if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare unequal flags = "+field.getIEEEFlags());        //        // Tests for lessThan  -- do it all over again        //        cmptst(field.newDfp("0"), field.newDfp("0"), "lessThan", false, 1);         // 0 < 0        cmptst(field.newDfp("0"), field.newDfp("-0"), "lessThan", false, 2);        // 0 < -0        cmptst(field.newDfp("-0"), field.newDfp("-0"), "lessThan", false, 3);       // -0 < -0        cmptst(field.newDfp("-0"), field.newDfp("0"), "lessThan", false, 4);        // -0 < 0        // check zero vs normal numbers        cmptst(field.newDfp("0"), field.newDfp("1"), "lessThan", true, 5);         // 0 < 1        cmptst(field.newDfp("1"), field.newDfp("0"), "lessThan", false, 6);         // 1 < 0        cmptst(field.newDfp("-1"), field.newDfp("0"), "lessThan", true, 7);        // -1 < 0        cmptst(field.newDfp("0"), field.newDfp("-1"), "lessThan", false, 8);        // 0 < -1        cmptst(field.newDfp("0"), field.newDfp("1e-131072"), "lessThan", true, 9); // 0 < 1e-131072        // check flags         if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        cmptst(field.newDfp("0"), field.newDfp("1e-131078"), "lessThan", true, 10); // 0 < 1e-131078        // check flags  -- underflow should be set        if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        field.clearIEEEFlags();        cmptst(field.newDfp("0"), field.newDfp("1e+131071"), "lessThan", true, 11); // 0 < 1e+131071        // check zero vs infinities        cmptst(field.newDfp("0"), pinf, "lessThan", true, 12);    // 0 < pinf        cmptst(field.newDfp("0"), ninf, "lessThan", false, 13);    // 0 < ninf        cmptst(field.newDfp("-0"), pinf, "lessThan", true, 14);   // -0 < pinf        cmptst(field.newDfp("-0"), ninf, "lessThan", false, 15);   // -0 < ninf        cmptst(pinf, field.newDfp("0"), "lessThan", false, 16);    // pinf < 0        cmptst(ninf, field.newDfp("0"), "lessThan", true, 17);    // ninf < 0        cmptst(pinf, field.newDfp("-0"), "lessThan", false, 18);   // pinf < -0        cmptst(ninf, field.newDfp("-0"), "lessThan", true, 19);   // ninf < -0        cmptst(ninf, pinf, "lessThan", true, 19.10);     // ninf < pinf        cmptst(pinf, ninf, "lessThan", false, 19.11);     // pinf < ninf        cmptst(pinf, pinf, "lessThan", false, 19.12);     // pinf < pinf        cmptst(ninf, ninf, "lessThan", false, 19.13);     // ninf < ninf        // check some normal numbers        cmptst(field.newDfp("1"), field.newDfp("1"), "lessThan", false, 20);   // 1 < 1        cmptst(field.newDfp("1"), field.newDfp("-1"), "lessThan", false, 21);   // 1 < -1        cmptst(field.newDfp("-1"), field.newDfp("-1"), "lessThan", false, 22);   // -1 < -1        cmptst(field.newDfp("1"), field.newDfp("1.0000000000000001"), "lessThan", true, 23);   // 1 < 1.0000000000000001        // The tests below checks to ensure that comparisons don't set FLAG_INEXACT        // 100000 < 1.0000000000000001        cmptst(field.newDfp("1e20"), field.newDfp("1.0000000000000001"), "lessThan", false, 24);        if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        cmptst(field.newDfp("0.000001"), field.newDfp("1e-6"), "lessThan", false, 25);        // check some nans -- nans shouldnt be lessThan to anything        cmptst(snan, snan, "lessThan", false, 27);        cmptst(qnan, qnan, "lessThan", false, 28);        cmptst(snan, qnan, "lessThan", false, 29);        cmptst(qnan, snan, "lessThan", false, 30);        cmptst(qnan, field.newDfp("0"), "lessThan", false, 31);        cmptst(snan, field.newDfp("0"), "lessThan", false, 32);        cmptst(field.newDfp("0"), snan, "lessThan", false, 33);        cmptst(field.newDfp("0"), qnan, "lessThan", false, 34);        cmptst(qnan, pinf, "lessThan", false, 35);        cmptst(snan, pinf, "lessThan", false, 36);        cmptst(pinf, snan, "lessThan", false, 37);        cmptst(pinf, qnan, "lessThan", false, 38);        cmptst(qnan, ninf, "lessThan", false, 39);        cmptst(snan, ninf, "lessThan", false, 40);        cmptst(ninf, snan, "lessThan", false, 41);        cmptst(ninf, qnan, "lessThan", false, 42);        cmptst(qnan, field.newDfp("-1"), "lessThan", false, 43);        cmptst(snan, field.newDfp("-1"), "lessThan", false, 44);        cmptst(field.newDfp("-1"), snan, "lessThan", false, 45);        cmptst(field.newDfp("-1"), qnan, "lessThan", false, 46);        cmptst(qnan, field.newDfp("1"), "lessThan", false, 47);        cmptst(snan, field.newDfp("1"), "lessThan", false, 48);        cmptst(field.newDfp("1"), snan, "lessThan", false, 49);        cmptst(field.newDfp("1"), qnan, "lessThan", false, 50);        cmptst(snan.negate(), snan, "lessThan", false, 51);        cmptst(qnan.negate(), qnan, "lessThan", false, 52);        //lessThan compares with nans should raise FLAG_INVALID        if (field.getIEEEFlags() != DfpField.FLAG_INVALID)            Assert.fail("assersion failed.  compare lessThan flags = "+field.getIEEEFlags());        field.clearIEEEFlags();        //        // Tests for greaterThan  -- do it all over again        //        cmptst(field.newDfp("0"), field.newDfp("0"), "greaterThan", false, 1);         // 0 > 0        cmptst(field.newDfp("0"), field.newDfp("-0"), "greaterThan", false, 2);        // 0 > -0        cmptst(field.newDfp("-0"), field.newDfp("-0"), "greaterThan", false, 3);       // -0 > -0        cmptst(field.newDfp("-0"), field.newDfp("0"), "greaterThan", false, 4);        // -0 > 0        // check zero vs normal numbers        cmptst(field.newDfp("0"), field.newDfp("1"), "greaterThan", false, 5);         // 0 > 1        cmptst(field.newDfp("1"), field.newDfp("0"), "greaterThan", true, 6);         // 1 > 0        cmptst(field.newDfp("-1"), field.newDfp("0"), "greaterThan", false, 7);        // -1 > 0        cmptst(field.newDfp("0"), field.newDfp("-1"), "greaterThan", true, 8);        // 0 > -1        cmptst(field.newDfp("0"), field.newDfp("1e-131072"), "greaterThan", false, 9); // 0 > 1e-131072        // check flags         if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        cmptst(field.newDfp("0"), field.newDfp("1e-131078"), "greaterThan", false, 10); // 0 > 1e-131078        // check flags  -- underflow should be set        if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        field.clearIEEEFlags();        cmptst(field.newDfp("0"), field.newDfp("1e+131071"), "greaterThan", false, 11); // 0 > 1e+131071        // check zero vs infinities        cmptst(field.newDfp("0"), pinf, "greaterThan", false, 12);    // 0 > pinf        cmptst(field.newDfp("0"), ninf, "greaterThan", true, 13);    // 0 > ninf        cmptst(field.newDfp("-0"), pinf, "greaterThan", false, 14);   // -0 > pinf        cmptst(field.newDfp("-0"), ninf, "greaterThan", true, 15);   // -0 > ninf        cmptst(pinf, field.newDfp("0"), "greaterThan", true, 16);    // pinf > 0        cmptst(ninf, field.newDfp("0"), "greaterThan", false, 17);    // ninf > 0        cmptst(pinf, field.newDfp("-0"), "greaterThan", true, 18);   // pinf > -0        cmptst(ninf, field.newDfp("-0"), "greaterThan", false, 19);   // ninf > -0        cmptst(ninf, pinf, "greaterThan", false, 19.10);     // ninf > pinf        cmptst(pinf, ninf, "greaterThan", true, 19.11);     // pinf > ninf        cmptst(pinf, pinf, "greaterThan", false, 19.12);     // pinf > pinf        cmptst(ninf, ninf, "greaterThan", false, 19.13);     // ninf > ninf        // check some normal numbers        cmptst(field.newDfp("1"), field.newDfp("1"), "greaterThan", false, 20);   // 1 > 1        cmptst(field.newDfp("1"), field.newDfp("-1"), "greaterThan", true, 21);   // 1 > -1        cmptst(field.newDfp("-1"), field.newDfp("-1"), "greaterThan", false, 22);   // -1 > -1        cmptst(field.newDfp("1"), field.newDfp("1.0000000000000001"), "greaterThan", false, 23);   // 1 > 1.0000000000000001        // The tests below checks to ensure that comparisons don't set FLAG_INEXACT        // 100000 > 1.0000000000000001        cmptst(field.newDfp("1e20"), field.newDfp("1.0000000000000001"), "greaterThan", true, 24);        if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        cmptst(field.newDfp("0.000001"), field.newDfp("1e-6"), "greaterThan", false, 25);        // check some nans -- nans shouldnt be greaterThan to anything        cmptst(snan, snan, "greaterThan", false, 27);        cmptst(qnan, qnan, "greaterThan", false, 28);        cmptst(snan, qnan, "greaterThan", false, 29);        cmptst(qnan, snan, "greaterThan", false, 30);        cmptst(qnan, field.newDfp("0"), "greaterThan", false, 31);        cmptst(snan, field.newDfp("0"), "greaterThan", false, 32);        cmptst(field.newDfp("0"), snan, "greaterThan", false, 33);        cmptst(field.newDfp("0"), qnan, "greaterThan", false, 34);        cmptst(qnan, pinf, "greaterThan", false, 35);        cmptst(snan, pinf, "greaterThan", false, 36);        cmptst(pinf, snan, "greaterThan", false, 37);        cmptst(pinf, qnan, "greaterThan", false, 38);        cmptst(qnan, ninf, "greaterThan", false, 39);        cmptst(snan, ninf, "greaterThan", false, 40);        cmptst(ninf, snan, "greaterThan", false, 41);        cmptst(ninf, qnan, "greaterThan", false, 42);        cmptst(qnan, field.newDfp("-1"), "greaterThan", false, 43);        cmptst(snan, field.newDfp("-1"), "greaterThan", false, 44);        cmptst(field.newDfp("-1"), snan, "greaterThan", false, 45);        cmptst(field.newDfp("-1"), qnan, "greaterThan", false, 46);        cmptst(qnan, field.newDfp("1"), "greaterThan", false, 47);        cmptst(snan, field.newDfp("1"), "greaterThan", false, 48);        cmptst(field.newDfp("1"), snan, "greaterThan", false, 49);        cmptst(field.newDfp("1"), qnan, "greaterThan", false, 50);        cmptst(snan.negate(), snan, "greaterThan", false, 51);        cmptst(qnan.negate(), qnan, "greaterThan", false, 52);        //greaterThan compares with nans should raise FLAG_INVALID        if (field.getIEEEFlags() != DfpField.FLAG_INVALID)            Assert.fail("assersion failed.  compare greaterThan flags = "+field.getIEEEFlags());        field.clearIEEEFlags();    }    //    // Test multiplication    //    @Test    public void testMultiply()    {        test(field.newDfp("1").multiply(field.newDfp("1")),      // Basic tests   1*1 = 1             field.newDfp("1"),              0, "Multiply #1");        test(field.newDfp("1").multiply(1),             // Basic tests   1*1 = 1             field.newDfp("1"),              0, "Multiply #2");        test(field.newDfp("-1").multiply(field.newDfp("1")),     // Basic tests   -1*1 = -1             field.newDfp("-1"),              0, "Multiply #3");        test(field.newDfp("-1").multiply(1),            // Basic tests   -1*1 = -1             field.newDfp("-1"),              0, "Multiply #4");        // basic tests with integers        test(field.newDfp("2").multiply(field.newDfp("3")),             field.newDfp("6"),              0, "Multiply #5");        test(field.newDfp("2").multiply(3),             field.newDfp("6"),              0, "Multiply #6");        test(field.newDfp("-2").multiply(field.newDfp("3")),             field.newDfp("-6"),              0, "Multiply #7");        test(field.newDfp("-2").multiply(3),             field.newDfp("-6"),              0, "Multiply #8");        test(field.newDfp("2").multiply(field.newDfp("-3")),             field.newDfp("-6"),              0, "Multiply #9");        test(field.newDfp("-2").multiply(field.newDfp("-3")),             field.newDfp("6"),              0, "Multiply #10");        //multiply by zero        test(field.newDfp("-2").multiply(field.newDfp("0")),             field.newDfp("-0"),              0, "Multiply #11");        test(field.newDfp("-2").multiply(0),             field.newDfp("-0"),              0, "Multiply #12");        test(field.newDfp("2").multiply(field.newDfp("0")),             field.newDfp("0"),              0, "Multiply #13");        test(field.newDfp("2").multiply(0),             field.newDfp("0"),              0, "Multiply #14");        test(field.newDfp("2").multiply(pinf),             pinf,             0, "Multiply #15");        test(field.newDfp("2").multiply(ninf),             ninf,             0, "Multiply #16");        test(field.newDfp("-2").multiply(pinf),             ninf,             0, "Multiply #17");        test(field.newDfp("-2").multiply(ninf),             pinf,             0, "Multiply #18");        test(ninf.multiply(field.newDfp("-2")),             pinf,             0, "Multiply #18.1");        test(field.newDfp("5e131071").multiply(2),             pinf,             DfpField.FLAG_OVERFLOW, "Multiply #19");                test(field.newDfp("5e131071").multiply(field.newDfp("1.999999999999999")),             field.newDfp("9.9999999999999950000e131071"),             0, "Multiply #20");                test(field.newDfp("-5e131071").multiply(2),             ninf,             DfpField.FLAG_OVERFLOW, "Multiply #22");                test(field.newDfp("-5e131071").multiply(field.newDfp("1.999999999999999")),             field.newDfp("-9.9999999999999950000e131071"),             0, "Multiply #23");                test(field.newDfp("1e-65539").multiply(field.newDfp("1e-65539")),             field.newDfp("1e-131078"),             DfpField.FLAG_UNDERFLOW, "Multiply #24");        test(field.newDfp("1").multiply(nan),             nan,             0, "Multiply #25");        test(nan.multiply(field.newDfp("1")),             nan,             0, "Multiply #26");        test(nan.multiply(pinf),             nan,             0, "Multiply #27");        test(pinf.multiply(nan),             nan,             0, "Multiply #27");        test(pinf.multiply(field.newDfp("0")),             nan,             DfpField.FLAG_INVALID, "Multiply #28");        test(field.newDfp("0").multiply(pinf),             nan,             DfpField.FLAG_INVALID, "Multiply #29");        test(pinf.multiply(pinf),             pinf,             0, "Multiply #30");        test(ninf.multiply(pinf),             ninf,             0, "Multiply #31");        test(pinf.multiply(ninf),             ninf,             0, "Multiply #32");        test(ninf.multiply(ninf),             pinf,             0, "Multiply #33");        test(pinf.multiply(1),             pinf,             0, "Multiply #34");        test(pinf.multiply(0),             nan,             DfpField.FLAG_INVALID, "Multiply #35");        test(nan.multiply(1),             nan,             0, "Multiply #36");        test(field.newDfp("1").multiply(10000),  // out of range             nan,             DfpField.FLAG_INVALID, "Multiply #37");        test(field.newDfp("1").multiply(-1),  // out of range             nan,             DfpField.FLAG_INVALID, "Multiply #38");    }    @Test    public void testDivide()    {        test(field.newDfp("1").divide(nan),      // divide by NaN = NaN             nan,              0, "Divide #1");        test(nan.divide(field.newDfp("1")),      // NaN / number = NaN             nan,              0, "Divide #2");        test(pinf.divide(field.newDfp("1")),             pinf,             0, "Divide #3");        test(pinf.divide(field.newDfp("-1")),             ninf,             0, "Divide #4");        test(pinf.divide(pinf),             nan,             DfpField.FLAG_INVALID, "Divide #5");        test(ninf.divide(pinf),             nan,             DfpField.FLAG_INVALID, "Divide #6");        test(pinf.divide(ninf),             nan,             DfpField.FLAG_INVALID, "Divide #7");        test(ninf.divide(ninf),             nan,             DfpField.FLAG_INVALID, "Divide #8");        test(field.newDfp("0").divide(field.newDfp("0")),             nan,             DfpField.FLAG_DIV_ZERO, "Divide #9");        test(field.newDfp("1").divide(field.newDfp("0")),             pinf,             DfpField.FLAG_DIV_ZERO, "Divide #10");        test(field.newDfp("1").divide(field.newDfp("-0")),             ninf,             DfpField.FLAG_DIV_ZERO, "Divide #11");        test(field.newDfp("-1").divide(field.newDfp("0")),             ninf,             DfpField.FLAG_DIV_ZERO, "Divide #12");        test(field.newDfp("-1").divide(field.newDfp("-0")),             pinf,             DfpField.FLAG_DIV_ZERO, "Divide #13");        test(field.newDfp("1").divide(field.newDfp("3")),             field.newDfp("0.33333333333333333333"),             DfpField.FLAG_INEXACT, "Divide #14");        test(field.newDfp("1").divide(field.newDfp("6")),             field.newDfp("0.16666666666666666667"),             DfpField.FLAG_INEXACT, "Divide #15");        test(field.newDfp("10").divide(field.newDfp("6")),             field.newDfp("1.6666666666666667"),             DfpField.FLAG_INEXACT, "Divide #16");        test(field.newDfp("100").divide(field.newDfp("6")),             field.newDfp("16.6666666666666667"),             DfpField.FLAG_INEXACT, "Divide #17");        test(field.newDfp("1000").divide(field.newDfp("6")),             field.newDfp("166.6666666666666667"),             DfpField.FLAG_INEXACT, "Divide #18");        test(field.newDfp("10000").divide(field.newDfp("6")),             field.newDfp("1666.6666666666666667"),             DfpField.FLAG_INEXACT, "Divide #19");        test(field.newDfp("1").divide(field.newDfp("1")),             field.newDfp("1"),             0, "Divide #20");        test(field.newDfp("1").divide(field.newDfp("-1")),             field.newDfp("-1"),             0, "Divide #21");        test(field.newDfp("-1").divide(field.newDfp("1")),             field.newDfp("-1"),             0, "Divide #22");        test(field.newDfp("-1").divide(field.newDfp("-1")),             field.newDfp("1"),             0, "Divide #23");        test(field.newDfp("1e-65539").divide(field.newDfp("1e65539")),             field.newDfp("1e-131078"),             DfpField.FLAG_UNDERFLOW, "Divide #24");        test(field.newDfp("1e65539").divide(field.newDfp("1e-65539")),             pinf,             DfpField.FLAG_OVERFLOW, "Divide #24");        test(field.newDfp("2").divide(field.newDfp("1.5")),     // test trial-divisor too high             field.newDfp("1.3333333333333333"),             DfpField.FLAG_INEXACT, "Divide #25");        test(field.newDfp("2").divide(pinf),             field.newDfp("0"),             0, "Divide #26");        test(field.newDfp("2").divide(ninf),             field.newDfp("-0"),             0, "Divide #27");        test(field.newDfp("0").divide(field.newDfp("1")),             field.newDfp("0"),             0, "Divide #28");    }    @Test    public void testDivideInt()    {        test(nan.divide(1),      // NaN / number = NaN             nan,              0, "DivideInt #1");        test(pinf.divide(1),             pinf,             0, "DivideInt #2");        test(field.newDfp("0").divide(0),             nan,             DfpField.FLAG_DIV_ZERO, "DivideInt #3");        test(field.newDfp("1").divide(0),             pinf,             DfpField.FLAG_DIV_ZERO, "DivideInt #4");        test(field.newDfp("-1").divide(0),             ninf,             DfpField.FLAG_DIV_ZERO, "DivideInt #5");        test(field.newDfp("1").divide(3),             field.newDfp("0.33333333333333333333"),             DfpField.FLAG_INEXACT, "DivideInt #6");        test(field.newDfp("1").divide(6),             field.newDfp("0.16666666666666666667"),             DfpField.FLAG_INEXACT, "DivideInt #7");        test(field.newDfp("10").divide(6),             field.newDfp("1.6666666666666667"),             DfpField.FLAG_INEXACT, "DivideInt #8");        test(field.newDfp("100").divide(6),             field.newDfp("16.6666666666666667"),             DfpField.FLAG_INEXACT, "DivideInt #9");        test(field.newDfp("1000").divide(6),             field.newDfp("166.6666666666666667"),             DfpField.FLAG_INEXACT, "DivideInt #10");        test(field.newDfp("10000").divide(6),             field.newDfp("1666.6666666666666667"),             DfpField.FLAG_INEXACT, "DivideInt #20");        test(field.newDfp("1").divide(1),             field.newDfp("1"),             0, "DivideInt #21");        test(field.newDfp("1e-131077").divide(10),             field.newDfp("1e-131078"),             DfpField.FLAG_UNDERFLOW, "DivideInt #22");        test(field.newDfp("0").divide(1),             field.newDfp("0"),             0, "DivideInt #23");        test(field.newDfp("1").divide(10000),             nan,             DfpField.FLAG_INVALID, "DivideInt #24");        test(field.newDfp("1").divide(-1),             nan,             DfpField.FLAG_INVALID, "DivideInt #25");    }    @Test    public void testNextAfter()    {        test(field.newDfp("1").nextAfter(pinf),             field.newDfp("1.0000000000000001"),             0, "NextAfter #1");        test(field.newDfp("1.0000000000000001").nextAfter(ninf),             field.newDfp("1"),             0, "NextAfter #1.5");        test(field.newDfp("1").nextAfter(ninf),             field.newDfp("0.99999999999999999999"),             0, "NextAfter #2");        test(field.newDfp("0.99999999999999999999").nextAfter(field.newDfp("2")),             field.newDfp("1"),             0, "NextAfter #3");        test(field.newDfp("-1").nextAfter(ninf),             field.newDfp("-1.0000000000000001"),             0, "NextAfter #4");        test(field.newDfp("-1").nextAfter(pinf),             field.newDfp("-0.99999999999999999999"),             0, "NextAfter #5");        test(field.newDfp("-0.99999999999999999999").nextAfter(field.newDfp("-2")),             field.newDfp("-1"),             0, "NextAfter #6");        test(field.newDfp("2").nextAfter(field.newDfp("2")),             field.newDfp("2"),             0, "NextAfter #7");        test(field.newDfp("0").nextAfter(field.newDfp("0")),             field.newDfp("0"),             0, "NextAfter #8");        test(field.newDfp("-2").nextAfter(field.newDfp("-2")),             field.newDfp("-2"),             0, "NextAfter #9");        test(field.newDfp("0").nextAfter(field.newDfp("1")),             field.newDfp("1e-131092"),             DfpField.FLAG_UNDERFLOW, "NextAfter #10");        test(field.newDfp("0").nextAfter(field.newDfp("-1")),             field.newDfp("-1e-131092"),             DfpField.FLAG_UNDERFLOW, "NextAfter #11");        test(field.newDfp("-1e-131092").nextAfter(pinf),             field.newDfp("-0"),             DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, "Next After #12");        test(field.newDfp("1e-131092").nextAfter(ninf),              field.newDfp("0"),             DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, "Next After #13");        test(field.newDfp("9.9999999999999999999e131078").nextAfter(pinf),             pinf,             DfpField.FLAG_OVERFLOW|DfpField.FLAG_INEXACT, "Next After #14");    }    @Test    public void testToString()    {        Assert.assertEquals("toString #1", "Infinity", pinf.toString());        Assert.assertEquals("toString #2", "-Infinity", ninf.toString());        Assert.assertEquals("toString #3", "NaN", nan.toString());        Assert.assertEquals("toString #4", "NaN", field.newDfp((byte) 1, Dfp.QNAN).toString());        Assert.assertEquals("toString #5", "NaN", field.newDfp((byte) 1, Dfp.SNAN).toString());        Assert.assertEquals("toString #6", "1.2300000000000000e100", field.newDfp("1.23e100").toString());        Assert.assertEquals("toString #7", "-1.2300000000000000e100", field.newDfp("-1.23e100").toString());        Assert.assertEquals("toString #8", "12345678.1234", field.newDfp("12345678.1234").toString());        Assert.assertEquals("toString #9", "0.00001234", field.newDfp("0.00001234").toString());    }    @Test    public void testRound()    {        field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN);        // Round down        test(field.newDfp("12345678901234567890").add(field.newDfp("0.9")),             field.newDfp("12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #1");        test(field.newDfp("12345678901234567890").add(field.newDfp("0.99999999")),             field.newDfp("12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #2");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.99999999")),             field.newDfp("-12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #3");        field.setRoundingMode(DfpField.RoundingMode.ROUND_UP);        // Round up        test(field.newDfp("12345678901234567890").add(field.newDfp("0.1")),             field.newDfp("12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #4");        test(field.newDfp("12345678901234567890").add(field.newDfp("0.0001")),             field.newDfp("12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #5");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.1")),             field.newDfp("-12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #6");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.0001")),             field.newDfp("-12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #7");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP);        // Round half up        test(field.newDfp("12345678901234567890").add(field.newDfp("0.4999")),             field.newDfp("12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #8");        test(field.newDfp("12345678901234567890").add(field.newDfp("0.5000")),             field.newDfp("12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #9");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.4999")),             field.newDfp("-12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #10");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5000")),             field.newDfp("-12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #11");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN);        // Round half down        test(field.newDfp("12345678901234567890").add(field.newDfp("0.5001")),             field.newDfp("12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #12");        test(field.newDfp("12345678901234567890").add(field.newDfp("0.5000")),             field.newDfp("12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #13");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5001")),             field.newDfp("-12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #14");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5000")),             field.newDfp("-12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #15");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD);        // Round half odd        test(field.newDfp("12345678901234567890").add(field.newDfp("0.5000")),             field.newDfp("12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #16");        test(field.newDfp("12345678901234567891").add(field.newDfp("0.5000")),             field.newDfp("12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #17");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5000")),             field.newDfp("-12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #18");        test(field.newDfp("-12345678901234567891").add(field.newDfp("-0.5000")),             field.newDfp("-12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #19");        field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL);        // Round ceil        test(field.newDfp("12345678901234567890").add(field.newDfp("0.0001")),             field.newDfp("12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #20");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.9999")),             field.newDfp("-12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #21");        field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR);        // Round floor        test(field.newDfp("12345678901234567890").add(field.newDfp("0.9999")),             field.newDfp("12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #22");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.0001")),             field.newDfp("-12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #23");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);  // reset    }    @Test    public void testCeil()    {        test(field.newDfp("1234.0000000000000001").ceil(),             field.newDfp("1235"),             DfpField.FLAG_INEXACT, "Ceil #1");    }    @Test    public void testFloor()    {        test(field.newDfp("1234.9999999999999999").floor(),             field.newDfp("1234"),             DfpField.FLAG_INEXACT, "Floor #1");    }    @Test    public void testRint()    {        test(field.newDfp("1234.50000000001").rint(),             field.newDfp("1235"),             DfpField.FLAG_INEXACT, "Rint #1");        test(field.newDfp("1234.5000").rint(),             field.newDfp("1234"),             DfpField.FLAG_INEXACT, "Rint #2");        test(field.newDfp("1235.5000").rint(),             field.newDfp("1236"),             DfpField.FLAG_INEXACT, "Rint #3");    }    @Test    public void testCopySign()    {        test(Dfp.copysign(field.newDfp("1234."), field.newDfp("-1")),             field.newDfp("-1234"),             0, "CopySign #1");        test(Dfp.copysign(field.newDfp("-1234."), field.newDfp("-1")),             field.newDfp("-1234"),             0, "CopySign #2");        test(Dfp.copysign(field.newDfp("-1234."), field.newDfp("1")),             field.newDfp("1234"),             0, "CopySign #3");        test(Dfp.copysign(field.newDfp("1234."), field.newDfp("1")),             field.newDfp("1234"),             0, "CopySign #4");    }    @Test    public void testIntValue()    {        Assert.assertEquals("intValue #1", 1234, field.newDfp("1234").intValue());        Assert.assertEquals("intValue #2", -1234, field.newDfp("-1234").intValue());        Assert.assertEquals("intValue #3", 1234, field.newDfp("1234.5").intValue());        Assert.assertEquals("intValue #4", 1235, field.newDfp("1234.500001").intValue());        Assert.assertEquals("intValue #5", 2147483647, field.newDfp("1e1000").intValue());        Assert.assertEquals("intValue #6", -2147483648, field.newDfp("-1e1000").intValue());    }    @Test    public void testLog10K()    {        Assert.assertEquals("log10K #1", 1, field.newDfp("123456").log10K());        Assert.assertEquals("log10K #2", 2, field.newDfp("123456789").log10K());        Assert.assertEquals("log10K #3", 0, field.newDfp("2").log10K());        Assert.assertEquals("log10K #3", 0, field.newDfp("1").log10K());        Assert.assertEquals("log10K #4", -1, field.newDfp("0.1").log10K());    }    @Test    public void testPower10K()    {        Dfp d = field.newDfp();        test(d.power10K(0), field.newDfp("1"), 0, "Power10 #1");        test(d.power10K(1), field.newDfp("10000"), 0, "Power10 #2");        test(d.power10K(2), field.newDfp("100000000"), 0, "Power10 #3");        test(d.power10K(-1), field.newDfp("0.0001"), 0, "Power10 #4");        test(d.power10K(-2), field.newDfp("0.00000001"), 0, "Power10 #5");        test(d.power10K(-3), field.newDfp("0.000000000001"), 0, "Power10 #6");    }    @Test    public void testLog10()    {        Assert.assertEquals("log10 #1", 1, field.newDfp("12").log10());        Assert.assertEquals("log10 #2", 2, field.newDfp("123").log10());        Assert.assertEquals("log10 #3", 3, field.newDfp("1234").log10());        Assert.assertEquals("log10 #4", 4, field.newDfp("12345").log10());        Assert.assertEquals("log10 #5", 5, field.newDfp("123456").log10());        Assert.assertEquals("log10 #6", 6, field.newDfp("1234567").log10());        Assert.assertEquals("log10 #6", 7, field.newDfp("12345678").log10());        Assert.assertEquals("log10 #7", 8, field.newDfp("123456789").log10());        Assert.assertEquals("log10 #8", 9, field.newDfp("1234567890").log10());        Assert.assertEquals("log10 #9", 10, field.newDfp("12345678901").log10());        Assert.assertEquals("log10 #10", 11, field.newDfp("123456789012").log10());        Assert.assertEquals("log10 #11", 12, field.newDfp("1234567890123").log10());        Assert.assertEquals("log10 #12", 0, field.newDfp("2").log10());        Assert.assertEquals("log10 #13", 0, field.newDfp("1").log10());        Assert.assertEquals("log10 #14", -1, field.newDfp("0.12").log10());        Assert.assertEquals("log10 #15", -2, field.newDfp("0.012").log10());    }    @Test    public void testPower10()    {        Dfp d = field.newDfp();        test(d.power10(0), field.newDfp("1"), 0, "Power10 #1");        test(d.power10(1), field.newDfp("10"), 0, "Power10 #2");        test(d.power10(2), field.newDfp("100"), 0, "Power10 #3");        test(d.power10(3), field.newDfp("1000"), 0, "Power10 #4");        test(d.power10(4), field.newDfp("10000"), 0, "Power10 #5");        test(d.power10(5), field.newDfp("100000"), 0, "Power10 #6");        test(d.power10(6), field.newDfp("1000000"), 0, "Power10 #7");        test(d.power10(7), field.newDfp("10000000"), 0, "Power10 #8");        test(d.power10(8), field.newDfp("100000000"), 0, "Power10 #9");        test(d.power10(9), field.newDfp("1000000000"), 0, "Power10 #10");        test(d.power10(-1), field.newDfp(".1"), 0, "Power10 #11");        test(d.power10(-2), field.newDfp(".01"), 0, "Power10 #12");        test(d.power10(-3), field.newDfp(".001"), 0, "Power10 #13");        test(d.power10(-4), field.newDfp(".0001"), 0, "Power10 #14");        test(d.power10(-5), field.newDfp(".00001"), 0, "Power10 #15");        test(d.power10(-6), field.newDfp(".000001"), 0, "Power10 #16");        test(d.power10(-7), field.newDfp(".0000001"), 0, "Power10 #17");        test(d.power10(-8), field.newDfp(".00000001"), 0, "Power10 #18");        test(d.power10(-9), field.newDfp(".000000001"), 0, "Power10 #19");        test(d.power10(-10), field.newDfp(".0000000001"), 0, "Power10 #20");    }    @Test    public void testRemainder()    {        test(field.newDfp("10").remainder(field.newDfp("3")),             field.newDfp("1"),             DfpField.FLAG_INEXACT, "Remainder #1");        test(field.newDfp("9").remainder(field.newDfp("3")),             field.newDfp("0"),             0, "Remainder #2");        test(field.newDfp("-9").remainder(field.newDfp("3")),             field.newDfp("-0"),             0, "Remainder #3");    }    @Test    public void testSqrt()    {        test(field.newDfp("0").sqrt(),             field.newDfp("0"),             0, "Sqrt #1");        test(field.newDfp("-0").sqrt(),             field.newDfp("-0"),             0, "Sqrt #2");        test(field.newDfp("1").sqrt(),             field.newDfp("1"),             0, "Sqrt #3");        test(field.newDfp("2").sqrt(),             field.newDfp("1.4142135623730950"),             DfpField.FLAG_INEXACT, "Sqrt #4");        test(field.newDfp("3").sqrt(),             field.newDfp("1.7320508075688773"),             DfpField.FLAG_INEXACT, "Sqrt #5");        test(field.newDfp("5").sqrt(),             field.newDfp("2.2360679774997897"),             DfpField.FLAG_INEXACT, "Sqrt #6");        test(field.newDfp("500").sqrt(),             field.newDfp("22.3606797749978970"),             DfpField.FLAG_INEXACT, "Sqrt #6.2");        test(field.newDfp("50000").sqrt(),             field.newDfp("223.6067977499789696"),             DfpField.FLAG_INEXACT, "Sqrt #6.3");        test(field.newDfp("-1").sqrt(),             nan,             DfpField.FLAG_INVALID, "Sqrt #7");        test(pinf.sqrt(),             pinf,             0, "Sqrt #8");        test(field.newDfp((byte) 1, Dfp.QNAN).sqrt(),             nan,             0, "Sqrt #9");        test(field.newDfp((byte) 1, Dfp.SNAN).sqrt(),             nan,             DfpField.FLAG_INVALID, "Sqrt #9");    }    @Test    public void testIssue567() {        DfpField field = new DfpField(100);        Assert.assertEquals(0.0, field.getZero().toDouble(), MathUtils.SAFE_MIN);        Assert.assertEquals(0.0, field.newDfp(0.0).toDouble(), MathUtils.SAFE_MIN);        Assert.assertEquals(-1, FastMath.copySign(1, field.newDfp(-0.0).toDouble()), MathUtils.EPSILON);        Assert.assertEquals(+1, FastMath.copySign(1, field.newDfp(+0.0).toDouble()), MathUtils.EPSILON);    }    @Test    public void testIsZero() {        Assert.assertTrue(field.getZero().isZero());        Assert.assertTrue(field.getZero().negate().isZero());        Assert.assertTrue(field.newDfp(+0.0).isZero());        Assert.assertTrue(field.newDfp(-0.0).isZero());        Assert.assertFalse(field.newDfp(1.0e-90).isZero());        Assert.assertFalse(nan.isZero());        Assert.assertFalse(nan.negate().isZero());        Assert.assertFalse(pinf.isZero());        Assert.assertFalse(pinf.negate().isZero());        Assert.assertFalse(ninf.isZero());        Assert.assertFalse(ninf.negate().isZero());    }    @Test    public void testSignPredicates() {        Assert.assertTrue(field.getZero().negativeOrNull());        Assert.assertTrue(field.getZero().positiveOrNull());        Assert.assertFalse(field.getZero().strictlyNegative());        Assert.assertFalse(field.getZero().strictlyPositive());        Assert.assertTrue(field.getZero().negate().negativeOrNull());        Assert.assertTrue(field.getZero().negate().positiveOrNull());        Assert.assertFalse(field.getZero().negate().strictlyNegative());        Assert.assertFalse(field.getZero().negate().strictlyPositive());        Assert.assertFalse(field.getOne().negativeOrNull());        Assert.assertTrue(field.getOne().positiveOrNull());        Assert.assertFalse(field.getOne().strictlyNegative());        Assert.assertTrue(field.getOne().strictlyPositive());        Assert.assertTrue(field.getOne().negate().negativeOrNull());        Assert.assertFalse(field.getOne().negate().positiveOrNull());        Assert.assertTrue(field.getOne().negate().strictlyNegative());        Assert.assertFalse(field.getOne().negate().strictlyPositive());        Assert.assertFalse(nan.negativeOrNull());        Assert.assertFalse(nan.positiveOrNull());        Assert.assertFalse(nan.strictlyNegative());        Assert.assertFalse(nan.strictlyPositive());        Assert.assertFalse(nan.negate().negativeOrNull());        Assert.assertFalse(nan.negate().positiveOrNull());        Assert.assertFalse(nan.negate().strictlyNegative());        Assert.assertFalse(nan.negate().strictlyPositive());        Assert.assertFalse(pinf.negativeOrNull());        Assert.assertTrue(pinf.positiveOrNull());        Assert.assertFalse(pinf.strictlyNegative());        Assert.assertTrue(pinf.strictlyPositive());        Assert.assertTrue(pinf.negate().negativeOrNull());        Assert.assertFalse(pinf.negate().positiveOrNull());        Assert.assertTrue(pinf.negate().strictlyNegative());        Assert.assertFalse(pinf.negate().strictlyPositive());        Assert.assertTrue(ninf.negativeOrNull());        Assert.assertFalse(ninf.positiveOrNull());        Assert.assertTrue(ninf.strictlyNegative());        Assert.assertFalse(ninf.strictlyPositive());        Assert.assertFalse(ninf.negate().negativeOrNull());        Assert.assertTrue(ninf.negate().positiveOrNull());        Assert.assertFalse(ninf.negate().strictlyNegative());        Assert.assertTrue(ninf.negate().strictlyPositive());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.dfp;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public class DfpMathTest {    private DfpField factory;    private Dfp pinf;    private Dfp ninf;    private Dfp nan;    private Dfp qnan;    @Before    public void setUp() {        // Some basic setup.  Define some constants and clear the status flags        factory = new DfpField(20);        pinf = factory.newDfp("1").divide(factory.newDfp("0"));        ninf = factory.newDfp("-1").divide(factory.newDfp("0"));        nan = factory.newDfp("0").divide(factory.newDfp("0"));        qnan = factory.newDfp((byte)1, Dfp.QNAN);        ninf.getField().clearIEEEFlags();        // force loading of dfpmath        Dfp pi = factory.getPi();        pi.getField().clearIEEEFlags();    }    @After    public void tearDown() {        pinf = null;        ninf = null;        nan  = null;        qnan = null;    }    // Generic test function.  Takes params x and y and tests them for     // equality.  Then checks the status flags against the flags argument.    // If the test fail, it prints the desc string    private void test(Dfp x, Dfp y, int flags, String desc)    {        boolean b = x.equals(y);        if (!x.equals(y) && !x.unequal(y))  // NaNs involved             b = (x.toString().equals(y.toString()));        if (x.equals(factory.newDfp("0")))  // distinguish +/- zero            b = (b && (x.toString().equals(y.toString())));        b = (b && x.getField().getIEEEFlags() == flags);        if (!b)            Assert.assertTrue("assersion failed "+desc+" x = "+x.toString()+" flags = "+x.getField().getIEEEFlags(), b);        x.getField().clearIEEEFlags();    }    @Test    public void testPow()      {        // Test special cases  exponent of zero        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("0")),                   factory.newDfp("1"),              0, "pow #1");        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("-0")),                   factory.newDfp("1"),              0, "pow #2");        test(DfpMath.pow(factory.newDfp("2"), factory.newDfp("0")),                   factory.newDfp("1"),              0, "pow #3");        test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("-0")),                   factory.newDfp("1"),              0, "pow #4");        test(DfpMath.pow(pinf, factory.newDfp("-0")),                   factory.newDfp("1"),              0, "pow #5");        test(DfpMath.pow(pinf, factory.newDfp("0")),             factory.newDfp("1"),              0, "pow #6");        test(DfpMath.pow(ninf, factory.newDfp("-0")),                   factory.newDfp("1"),              0, "pow #7");        test(DfpMath.pow(ninf, factory.newDfp("0")),             factory.newDfp("1"),              0, "pow #8");        test(DfpMath.pow(qnan, factory.newDfp("0")),             factory.newDfp("1"),              0, "pow #8");        // exponent of one        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("1")),             factory.newDfp("0"),              0, "pow #9");        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("1")),                   factory.newDfp("-0"),              0, "pow #10");        test(DfpMath.pow(factory.newDfp("2"), factory.newDfp("1")),             factory.newDfp("2"),              0, "pow #11");        test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("1")),             factory.newDfp("-2"),              0, "pow #12");        test(DfpMath.pow(pinf, factory.newDfp("1")),                   pinf,              0, "pow #13");        test(DfpMath.pow(ninf, factory.newDfp("1")),             ninf,              0, "pow #14");        test(DfpMath.pow(qnan, factory.newDfp("1")),             qnan,              DfpField.FLAG_INVALID, "pow #14.1");        // exponent of NaN        test(DfpMath.pow(factory.newDfp("0"), qnan),             qnan,              DfpField.FLAG_INVALID, "pow #15");        test(DfpMath.pow(factory.newDfp("-0"), qnan),                   qnan,              DfpField.FLAG_INVALID, "pow #16");        test(DfpMath.pow(factory.newDfp("2"), qnan),             qnan,              DfpField.FLAG_INVALID, "pow #17");        test(DfpMath.pow(factory.newDfp("-2"), qnan),             qnan,              DfpField.FLAG_INVALID, "pow #18");        test(DfpMath.pow(pinf, qnan),                   qnan,              DfpField.FLAG_INVALID, "pow #19");        test(DfpMath.pow(ninf, qnan),             qnan,              DfpField.FLAG_INVALID, "pow #20");        test(DfpMath.pow(qnan, qnan),             qnan,              DfpField.FLAG_INVALID, "pow #21");        // radix of NaN        test(DfpMath.pow(qnan, factory.newDfp("1")),             qnan,              DfpField.FLAG_INVALID, "pow #22");        test(DfpMath.pow(qnan, factory.newDfp("-1")),                   qnan,             DfpField.FLAG_INVALID, "pow #23");        test(DfpMath.pow(qnan, pinf),             qnan,             DfpField.FLAG_INVALID, "pow #24");        test(DfpMath.pow(qnan, ninf),             qnan,              DfpField.FLAG_INVALID, "pow #25");        test(DfpMath.pow(qnan, qnan),             qnan,              DfpField.FLAG_INVALID, "pow #26");        // (x > 1) ^ pinf = pinf,    (x < -1) ^ pinf = pinf        test(DfpMath.pow(factory.newDfp("2"), pinf),             pinf,              0, "pow #27");        test(DfpMath.pow(factory.newDfp("-2"), pinf),                   pinf,             0, "pow #28");        test(DfpMath.pow(pinf, pinf),             pinf,             0, "pow #29");        test(DfpMath.pow(ninf, pinf),             pinf,              0, "pow #30");        // (x > 1) ^ ninf = +0,    (x < -1) ^ ninf = +0        test(DfpMath.pow(factory.newDfp("2"), ninf),             factory.getZero(),              0, "pow #31");        test(DfpMath.pow(factory.newDfp("-2"), ninf),                   factory.getZero(),             0, "pow #32");        test(DfpMath.pow(pinf, ninf),             factory.getZero(),             0, "pow #33");        test(DfpMath.pow(ninf, ninf),             factory.getZero(),              0, "pow #34");        // (-1 < x < 1) ^ pinf = 0        test(DfpMath.pow(factory.newDfp("0.5"), pinf),             factory.getZero(),              0, "pow #35");        test(DfpMath.pow(factory.newDfp("-0.5"), pinf),                   factory.getZero(),             0, "pow #36");        // (-1 < x < 1) ^ ninf = pinf         test(DfpMath.pow(factory.newDfp("0.5"), ninf),             pinf,              0, "pow #37");        test(DfpMath.pow(factory.newDfp("-0.5"), ninf),                   pinf,             0, "pow #38");        // +/- 1  ^ +/-inf  = NaN        test(DfpMath.pow(factory.getOne(), pinf),             qnan,              DfpField.FLAG_INVALID, "pow #39");        test(DfpMath.pow(factory.getOne(), ninf),                   qnan,             DfpField.FLAG_INVALID, "pow #40");        test(DfpMath.pow(factory.newDfp("-1"), pinf),             qnan,              DfpField.FLAG_INVALID, "pow #41");        test(DfpMath.pow(factory.getOne().negate(), ninf),                   qnan,             DfpField.FLAG_INVALID, "pow #42");        // +0  ^ +anything except 0, NAN  = +0        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("1")),             factory.newDfp("0"),             0, "pow #43");        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("1e30")),             factory.newDfp("0"),             0, "pow #44");        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("1e-30")),             factory.newDfp("0"),             0, "pow #45");        test(DfpMath.pow(factory.newDfp("0"), pinf),             factory.newDfp("0"),             0, "pow #46");        // -0  ^ +anything except 0, NAN, odd integer  = +0        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("2")),             factory.newDfp("0"),             0, "pow #47");        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("1e30")),             factory.newDfp("0"),             0, "pow #48");        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("1e-30")),             factory.newDfp("0"),             DfpField.FLAG_INEXACT, "pow #49");        test(DfpMath.pow(factory.newDfp("-0"), pinf),             factory.newDfp("0"),             0, "pow #50");        // +0  ^ -anything except 0, NAN  = +INF        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("-1")),             pinf,             0, "pow #51");        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("-1e30")),             pinf,             0, "pow #52");        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("-1e-30")),             pinf,             0, "pow #53");        test(DfpMath.pow(factory.newDfp("0"), ninf),             pinf,             0, "pow #54");        // -0  ^ -anything except 0, NAN, odd integer  = +INF        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-2")),             pinf,             0, "pow #55");        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-1e30")),             pinf,             0, "pow #56");        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-1e-30")),             pinf,             DfpField.FLAG_INEXACT, "pow #57");        test(DfpMath.pow(factory.newDfp("-0"), ninf),             pinf,             0, "pow #58");        // -0  ^ -odd integer   =  -INF        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-1")),             ninf,             DfpField.FLAG_INEXACT, "pow #59");        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-12345")),             ninf,             DfpField.FLAG_INEXACT, "pow #60");        // -0  ^ +odd integer   =  -0        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("3")),             factory.newDfp("-0"),             DfpField.FLAG_INEXACT, "pow #61");        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("12345")),             factory.newDfp("-0"),             DfpField.FLAG_INEXACT, "pow #62");        // pinf  ^ +anything   = pinf         test(DfpMath.pow(pinf, factory.newDfp("3")),             pinf,             0, "pow #63");        test(DfpMath.pow(pinf, factory.newDfp("1e30")),             pinf,             0, "pow #64");        test(DfpMath.pow(pinf, factory.newDfp("1e-30")),             pinf,             0, "pow #65");        test(DfpMath.pow(pinf, pinf),             pinf,             0, "pow #66");        // pinf  ^ -anything   = +0         test(DfpMath.pow(pinf, factory.newDfp("-3")),             factory.getZero(),             0, "pow #67");        test(DfpMath.pow(pinf, factory.newDfp("-1e30")),             factory.getZero(),             0, "pow #68");        test(DfpMath.pow(pinf, factory.newDfp("-1e-30")),             factory.getZero(),             0, "pow #69");        test(DfpMath.pow(pinf, ninf),             factory.getZero(),             0, "pow #70");        // ninf  ^ anything   = -0 ^ -anything        // ninf  ^ -anything except 0, NAN, odd integer  = +0        test(DfpMath.pow(ninf, factory.newDfp("-2")),             factory.newDfp("0"),             0, "pow #71");        test(DfpMath.pow(ninf, factory.newDfp("-1e30")),             factory.newDfp("0"),             0, "pow #72");        test(DfpMath.pow(ninf, factory.newDfp("-1e-30")),             factory.newDfp("0"),             DfpField.FLAG_INEXACT, "pow #73");        test(DfpMath.pow(ninf, ninf),             factory.newDfp("0"),             0, "pow #74");        // ninf  ^ +anything except 0, NAN, odd integer  = +INF        test(DfpMath.pow(ninf, factory.newDfp("2")),             pinf,             0, "pow #75");        test(DfpMath.pow(ninf, factory.newDfp("1e30")),             pinf,             0, "pow #76");        test(DfpMath.pow(ninf, factory.newDfp("1e-30")),             pinf,             DfpField.FLAG_INEXACT, "pow #77");        test(DfpMath.pow(ninf, pinf),             pinf,             0, "pow #78");        // ninf  ^ +odd integer   =  -INF        test(DfpMath.pow(ninf, factory.newDfp("3")),             ninf,             DfpField.FLAG_INEXACT, "pow #79");        test(DfpMath.pow(ninf, factory.newDfp("12345")),             ninf,             DfpField.FLAG_INEXACT, "pow #80");        // ninf  ^ -odd integer   =  -0        test(DfpMath.pow(ninf, factory.newDfp("-3")),             factory.newDfp("-0"),             DfpField.FLAG_INEXACT, "pow #81");        test(DfpMath.pow(ninf, factory.newDfp("-12345")),             factory.newDfp("-0"),             DfpField.FLAG_INEXACT, "pow #82");        // -anything ^ integer         test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("3")),             factory.newDfp("-8"),             DfpField.FLAG_INEXACT, "pow #83");        test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("16")),             factory.newDfp("65536"),             0, "pow #84");        test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("-3")),             factory.newDfp("-0.125"),             DfpField.FLAG_INEXACT, "pow #85");        test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("-4")),             factory.newDfp("0.0625"),             0, "pow #86");        // -anything ^ noninteger = NaN        test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("-4.1")),             qnan,             DfpField.FLAG_INVALID|DfpField.FLAG_INEXACT, "pow #87");        // Some fractional cases.        test(DfpMath.pow(factory.newDfp("2"),factory.newDfp("1.5")),             factory.newDfp("2.8284271247461901"),              DfpField.FLAG_INEXACT, "pow #88");    }    @Test    public void testSin()    {        test(DfpMath.sin(pinf),             nan,             DfpField.FLAG_INVALID|DfpField.FLAG_INEXACT, "sin #1");        test(DfpMath.sin(nan),             nan,             DfpField.FLAG_INVALID|DfpField.FLAG_INEXACT, "sin #2");        test(DfpMath.sin(factory.getZero()),             factory.getZero(),             DfpField.FLAG_INEXACT, "sin #3");        test(DfpMath.sin(factory.getPi()),             factory.getZero(),             DfpField.FLAG_INEXACT, "sin #4");        test(DfpMath.sin(factory.getPi().negate()),             factory.newDfp("-0"),             DfpField.FLAG_INEXACT, "sin #5");        test(DfpMath.sin(factory.getPi().multiply(2)),             factory.getZero(),             DfpField.FLAG_INEXACT, "sin #6");        test(DfpMath.sin(factory.getPi().divide(2)),             factory.getOne(),             DfpField.FLAG_INEXACT, "sin #7");        test(DfpMath.sin(factory.getPi().divide(2).negate()),             factory.getOne().negate(),             DfpField.FLAG_INEXACT, "sin #8");        test(DfpMath.sin(DfpMath.atan(factory.getOne())),  // pi/4             factory.newDfp("0.5").sqrt(),             DfpField.FLAG_INEXACT, "sin #9");        test(DfpMath.sin(DfpMath.atan(factory.getOne())).negate(),  // -pi/4             factory.newDfp("0.5").sqrt().negate(),             DfpField.FLAG_INEXACT, "sin #10");        test(DfpMath.sin(DfpMath.atan(factory.getOne())).negate(),  // -pi/4             factory.newDfp("0.5").sqrt().negate(),             DfpField.FLAG_INEXACT, "sin #11");        test(DfpMath.sin(factory.newDfp("0.1")),             factory.newDfp("0.0998334166468281523"),             DfpField.FLAG_INEXACT, "sin #12");        test(DfpMath.sin(factory.newDfp("0.2")),             factory.newDfp("0.19866933079506121546"),             DfpField.FLAG_INEXACT, "sin #13");        test(DfpMath.sin(factory.newDfp("0.3")),             factory.newDfp("0.2955202066613395751"),             DfpField.FLAG_INEXACT, "sin #14");        test(DfpMath.sin(factory.newDfp("0.4")),             factory.newDfp("0.38941834230865049166"),             DfpField.FLAG_INEXACT, "sin #15");        test(DfpMath.sin(factory.newDfp("0.5")),             factory.newDfp("0.47942553860420300026"),  // off by one ULP             DfpField.FLAG_INEXACT, "sin #16");        test(DfpMath.sin(factory.newDfp("0.6")),             factory.newDfp("0.56464247339503535721"),  // off by one ULP             DfpField.FLAG_INEXACT, "sin #17");        test(DfpMath.sin(factory.newDfp("0.7")),             factory.newDfp("0.64421768723769105367"),               DfpField.FLAG_INEXACT, "sin #18");        test(DfpMath.sin(factory.newDfp("0.8")),                     factory.newDfp("0.71735609089952276163"),             DfpField.FLAG_INEXACT, "sin #19");        test(DfpMath.sin(factory.newDfp("0.9")),        // off by one ULP             factory.newDfp("0.78332690962748338847"),             DfpField.FLAG_INEXACT, "sin #20");        test(DfpMath.sin(factory.newDfp("1.0")),             factory.newDfp("0.84147098480789650666"),             DfpField.FLAG_INEXACT, "sin #21");        test(DfpMath.sin(factory.newDfp("1.1")),             factory.newDfp("0.89120736006143533995"),             DfpField.FLAG_INEXACT, "sin #22");        test(DfpMath.sin(factory.newDfp("1.2")),             factory.newDfp("0.93203908596722634968"),             DfpField.FLAG_INEXACT, "sin #23");        test(DfpMath.sin(factory.newDfp("1.3")),             factory.newDfp("0.9635581854171929647"),             DfpField.FLAG_INEXACT, "sin #24");        test(DfpMath.sin(factory.newDfp("1.4")),             factory.newDfp("0.98544972998846018066"),             DfpField.FLAG_INEXACT, "sin #25");        test(DfpMath.sin(factory.newDfp("1.5")),             factory.newDfp("0.99749498660405443096"),             DfpField.FLAG_INEXACT, "sin #26");        test(DfpMath.sin(factory.newDfp("1.6")),             factory.newDfp("0.99957360304150516323"),             DfpField.FLAG_INEXACT, "sin #27");    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import java.math.BigDecimal;import java.math.BigInteger;import java.text.NumberFormat;import java.text.ParseException;import java.util.Locale;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public class BigFractionFormatTest {    BigFractionFormat properFormat = null;    BigFractionFormat improperFormat = null;    protected Locale getLocale() {        return Locale.getDefault();    }    @Before    public void setUp() throws Exception {        properFormat = BigFractionFormat.getProperInstance(getLocale());        improperFormat = BigFractionFormat.getImproperInstance(getLocale());    }    @Test    public void testFormat() {        BigFraction c = new BigFraction(1, 2);        String expected = "1 / 2";        String actual = properFormat.format(c);        Assert.assertEquals(expected, actual);        actual = improperFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testFormatNegative() {        BigFraction c = new BigFraction(-1, 2);        String expected = "-1 / 2";        String actual = properFormat.format(c);        Assert.assertEquals(expected, actual);        actual = improperFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testFormatZero() {        BigFraction c = new BigFraction(0, 1);        String expected = "0 / 1";        String actual = properFormat.format(c);        Assert.assertEquals(expected, actual);        actual = improperFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testFormatImproper() {        BigFraction c = new BigFraction(5, 3);        String actual = properFormat.format(c);        Assert.assertEquals("1 2 / 3", actual);        actual = improperFormat.format(c);        Assert.assertEquals("5 / 3", actual);    }    @Test    public void testFormatImproperNegative() {        BigFraction c = new BigFraction(-5, 3);        String actual = properFormat.format(c);        Assert.assertEquals("-1 2 / 3", actual);        actual = improperFormat.format(c);        Assert.assertEquals("-5 / 3", actual);    }    @Test    public void testParse() {        String source = "1 / 2";        try {            BigFraction c = properFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(BigInteger.ONE, c.getNumerator());            Assert.assertEquals(BigInteger.valueOf(2l), c.getDenominator());            c = improperFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(BigInteger.ONE, c.getNumerator());            Assert.assertEquals(BigInteger.valueOf(2l), c.getDenominator());        } catch (ParseException ex) {            Assert.fail(ex.getMessage());        }    }    @Test    public void testParseInteger() {        String source = "10";        try {            BigFraction c = properFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(BigInteger.TEN, c.getNumerator());            Assert.assertEquals(BigInteger.ONE, c.getDenominator());        } catch (ParseException ex) {            Assert.fail(ex.getMessage());        }        try {            BigFraction c = improperFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(BigInteger.TEN, c.getNumerator());            Assert.assertEquals(BigInteger.ONE, c.getDenominator());        } catch (ParseException ex) {            Assert.fail(ex.getMessage());        }    }    @Test    public void testParseInvalid() {        String source = "a";        String msg = "should not be able to parse '10 / a'.";        try {            properFormat.parse(source);            Assert.fail(msg);        } catch (ParseException ex) {            // success        }        try {            improperFormat.parse(source);            Assert.fail(msg);        } catch (ParseException ex) {            // success        }    }    @Test    public void testParseInvalidDenominator() {        String source = "10 / a";        String msg = "should not be able to parse '10 / a'.";        try {            properFormat.parse(source);            Assert.fail(msg);        } catch (ParseException ex) {            // success        }        try {            improperFormat.parse(source);            Assert.fail(msg);        } catch (ParseException ex) {            // success        }    }    @Test    public void testParseNegative() {        try {            String source = "-1 / 2";            BigFraction c = properFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(-1, c.getNumeratorAsInt());            Assert.assertEquals(2, c.getDenominatorAsInt());            c = improperFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(-1, c.getNumeratorAsInt());            Assert.assertEquals(2, c.getDenominatorAsInt());            source = "1 / -2";            c = properFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(-1, c.getNumeratorAsInt());            Assert.assertEquals(2, c.getDenominatorAsInt());            c = improperFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(-1, c.getNumeratorAsInt());            Assert.assertEquals(2, c.getDenominatorAsInt());        } catch (ParseException ex) {            Assert.fail(ex.getMessage());        }    }    @Test    public void testParseProper() {        String source = "1 2 / 3";        try {            BigFraction c = properFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(5, c.getNumeratorAsInt());            Assert.assertEquals(3, c.getDenominatorAsInt());        } catch (ParseException ex) {            Assert.fail(ex.getMessage());        }        try {            improperFormat.parse(source);            Assert.fail("invalid improper fraction.");        } catch (ParseException ex) {            // success        }    }    @Test    public void testParseProperNegative() {        String source = "-1 2 / 3";        try {            BigFraction c = properFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(-5, c.getNumeratorAsInt());            Assert.assertEquals(3, c.getDenominatorAsInt());        } catch (ParseException ex) {            Assert.fail(ex.getMessage());        }        try {            improperFormat.parse(source);            Assert.fail("invalid improper fraction.");        } catch (ParseException ex) {            // success        }    }    @Test    public void testParseProperInvalidMinus() {        String source = "2 -2 / 3";        try {            properFormat.parse(source);            Assert.fail("invalid minus in improper fraction.");        } catch (ParseException ex) {            // expected        }        source = "2 2 / -3";        try {            properFormat.parse(source);            Assert.fail("invalid minus in improper fraction.");        } catch (ParseException ex) {            // expected        }    }    @Test    public void testParseBig() throws ParseException {        BigFraction f1 =            improperFormat.parse("167213075789791382630275400487886041651764456874403" +                                 " / " +                                 "53225575123090058458126718248444563466137046489291");        Assert.assertEquals(FastMath.PI, f1.doubleValue(), 0.0);        BigFraction f2 =            properFormat.parse("3 " +                               "7536350420521207255895245742552351253353317406530" +                               " / " +                               "53225575123090058458126718248444563466137046489291");        Assert.assertEquals(FastMath.PI, f2.doubleValue(), 0.0);        Assert.assertEquals(f1, f2);        BigDecimal pi =            new BigDecimal("3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068");        Assert.assertEquals(pi, f1.bigDecimalValue(99, BigDecimal.ROUND_HALF_EVEN));    }    @Test    public void testNumeratorFormat() {        NumberFormat old = properFormat.getNumeratorFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        properFormat.setNumeratorFormat(nf);        Assert.assertEquals(nf, properFormat.getNumeratorFormat());        properFormat.setNumeratorFormat(old);        old = improperFormat.getNumeratorFormat();        nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        improperFormat.setNumeratorFormat(nf);        Assert.assertEquals(nf, improperFormat.getNumeratorFormat());        improperFormat.setNumeratorFormat(old);    }    @Test    public void testDenominatorFormat() {        NumberFormat old = properFormat.getDenominatorFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        properFormat.setDenominatorFormat(nf);        Assert.assertEquals(nf, properFormat.getDenominatorFormat());        properFormat.setDenominatorFormat(old);        old = improperFormat.getDenominatorFormat();        nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        improperFormat.setDenominatorFormat(nf);        Assert.assertEquals(nf, improperFormat.getDenominatorFormat());        improperFormat.setDenominatorFormat(old);    }    @Test    public void testWholeFormat() {        ProperBigFractionFormat format = (ProperBigFractionFormat)properFormat;        NumberFormat old = format.getWholeFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        format.setWholeFormat(nf);        Assert.assertEquals(nf, format.getWholeFormat());        format.setWholeFormat(old);    }    @Test    public void testLongFormat() {        Assert.assertEquals("10 / 1", improperFormat.format(10l));    }    @Test    public void testDoubleFormat() {        Assert.assertEquals("1 / 16", improperFormat.format(0.0625));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import org.apache.commons.math.ConvergenceException;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.exception.MathArithmeticException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * @version $Id$ */public class FractionTest {    private void assertFraction(int expectedNumerator, int expectedDenominator, Fraction actual) {        Assert.assertEquals(expectedNumerator, actual.getNumerator());        Assert.assertEquals(expectedDenominator, actual.getDenominator());    }    @Test    public void testConstructor() throws Exception {        assertFraction(0, 1, new Fraction(0, 1));        assertFraction(0, 1, new Fraction(0, 2));        assertFraction(0, 1, new Fraction(0, -1));        assertFraction(1, 2, new Fraction(1, 2));        assertFraction(1, 2, new Fraction(2, 4));        assertFraction(-1, 2, new Fraction(-1, 2));        assertFraction(-1, 2, new Fraction(1, -2));        assertFraction(-1, 2, new Fraction(-2, 4));        assertFraction(-1, 2, new Fraction(2, -4));        // overflow        try {            new Fraction(Integer.MIN_VALUE, -1);            Assert.fail();        } catch (MathArithmeticException ex) {            // success        }        try {            new Fraction(1, Integer.MIN_VALUE);            Assert.fail();        } catch (MathArithmeticException ex) {            // success        }        assertFraction(0, 1, new Fraction(0.00000000000001));        assertFraction(2, 5, new Fraction(0.40000000000001));        assertFraction(15, 1, new Fraction(15.0000000000001));    }    @Test    public void testGoldenRatio() {        try {            // the golden ratio is notoriously a difficult number for continuous fraction            new Fraction((1 + FastMath.sqrt(5)) / 2, 1.0e-12, 25);            Assert.fail("an exception should have been thrown");        } catch (ConvergenceException ce) {            // expected behavior        }    }    // MATH-179    @Test    public void testDoubleConstructor() throws ConvergenceException  {        assertFraction(1, 2, new Fraction((double)1 / (double)2));        assertFraction(1, 3, new Fraction((double)1 / (double)3));        assertFraction(2, 3, new Fraction((double)2 / (double)3));        assertFraction(1, 4, new Fraction((double)1 / (double)4));        assertFraction(3, 4, new Fraction((double)3 / (double)4));        assertFraction(1, 5, new Fraction((double)1 / (double)5));        assertFraction(2, 5, new Fraction((double)2 / (double)5));        assertFraction(3, 5, new Fraction((double)3 / (double)5));        assertFraction(4, 5, new Fraction((double)4 / (double)5));        assertFraction(1, 6, new Fraction((double)1 / (double)6));        assertFraction(5, 6, new Fraction((double)5 / (double)6));        assertFraction(1, 7, new Fraction((double)1 / (double)7));        assertFraction(2, 7, new Fraction((double)2 / (double)7));        assertFraction(3, 7, new Fraction((double)3 / (double)7));        assertFraction(4, 7, new Fraction((double)4 / (double)7));        assertFraction(5, 7, new Fraction((double)5 / (double)7));        assertFraction(6, 7, new Fraction((double)6 / (double)7));        assertFraction(1, 8, new Fraction((double)1 / (double)8));        assertFraction(3, 8, new Fraction((double)3 / (double)8));        assertFraction(5, 8, new Fraction((double)5 / (double)8));        assertFraction(7, 8, new Fraction((double)7 / (double)8));        assertFraction(1, 9, new Fraction((double)1 / (double)9));        assertFraction(2, 9, new Fraction((double)2 / (double)9));        assertFraction(4, 9, new Fraction((double)4 / (double)9));        assertFraction(5, 9, new Fraction((double)5 / (double)9));        assertFraction(7, 9, new Fraction((double)7 / (double)9));        assertFraction(8, 9, new Fraction((double)8 / (double)9));        assertFraction(1, 10, new Fraction((double)1 / (double)10));        assertFraction(3, 10, new Fraction((double)3 / (double)10));        assertFraction(7, 10, new Fraction((double)7 / (double)10));        assertFraction(9, 10, new Fraction((double)9 / (double)10));        assertFraction(1, 11, new Fraction((double)1 / (double)11));        assertFraction(2, 11, new Fraction((double)2 / (double)11));        assertFraction(3, 11, new Fraction((double)3 / (double)11));        assertFraction(4, 11, new Fraction((double)4 / (double)11));        assertFraction(5, 11, new Fraction((double)5 / (double)11));        assertFraction(6, 11, new Fraction((double)6 / (double)11));        assertFraction(7, 11, new Fraction((double)7 / (double)11));        assertFraction(8, 11, new Fraction((double)8 / (double)11));        assertFraction(9, 11, new Fraction((double)9 / (double)11));        assertFraction(10, 11, new Fraction((double)10 / (double)11));    }    // MATH-181    @Test    public void testDigitLimitConstructor() throws ConvergenceException  {        assertFraction(2, 5, new Fraction(0.4,   9));        assertFraction(2, 5, new Fraction(0.4,  99));        assertFraction(2, 5, new Fraction(0.4, 999));        assertFraction(3, 5,      new Fraction(0.6152,    9));        assertFraction(8, 13,     new Fraction(0.6152,   99));        assertFraction(510, 829,  new Fraction(0.6152,  999));        assertFraction(769, 1250, new Fraction(0.6152, 9999));    }    @Test    public void testIntegerOverflow() {        checkIntegerOverflow(0.75000000001455192);        checkIntegerOverflow(1.0e10);    }    private void checkIntegerOverflow(double a) {        try {            new Fraction(a, 1.0e-12, 1000);            Assert.fail("an exception should have been thrown");        } catch (ConvergenceException ce) {            // expected behavior        }    }    @Test    public void testEpsilonLimitConstructor() throws ConvergenceException  {        assertFraction(2, 5, new Fraction(0.4, 1.0e-5, 100));        assertFraction(3, 5,      new Fraction(0.6152, 0.02, 100));        assertFraction(8, 13,     new Fraction(0.6152, 1.0e-3, 100));        assertFraction(251, 408,  new Fraction(0.6152, 1.0e-4, 100));        assertFraction(251, 408,  new Fraction(0.6152, 1.0e-5, 100));        assertFraction(510, 829,  new Fraction(0.6152, 1.0e-6, 100));        assertFraction(769, 1250, new Fraction(0.6152, 1.0e-7, 100));    }    @Test    public void testCompareTo() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(1, 3);        Fraction third = new Fraction(1, 2);        Assert.assertEquals(0, first.compareTo(first));        Assert.assertEquals(0, first.compareTo(third));        Assert.assertEquals(1, first.compareTo(second));        Assert.assertEquals(-1, second.compareTo(first));        // these two values are different approximations of PI        // the first  one is approximately PI - 3.07e-18        // the second one is approximately PI + 1.936e-17        Fraction pi1 = new Fraction(1068966896, 340262731);        Fraction pi2 = new Fraction( 411557987, 131002976);        Assert.assertEquals(-1, pi1.compareTo(pi2));        Assert.assertEquals( 1, pi2.compareTo(pi1));        Assert.assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);    }    @Test    public void testDoubleValue() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(1, 3);        Assert.assertEquals(0.5, first.doubleValue(), 0.0);        Assert.assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);    }    @Test    public void testFloatValue() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(1, 3);        Assert.assertEquals(0.5f, first.floatValue(), 0.0f);        Assert.assertEquals((float)(1.0 / 3.0), second.floatValue(), 0.0f);    }    @Test    public void testIntValue() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(3, 2);        Assert.assertEquals(0, first.intValue());        Assert.assertEquals(1, second.intValue());    }    @Test    public void testLongValue() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(3, 2);        Assert.assertEquals(0L, first.longValue());        Assert.assertEquals(1L, second.longValue());    }    @Test    public void testConstructorDouble() throws Exception {        assertFraction(1, 2, new Fraction(0.5));        assertFraction(1, 3, new Fraction(1.0 / 3.0));        assertFraction(17, 100, new Fraction(17.0 / 100.0));        assertFraction(317, 100, new Fraction(317.0 / 100.0));        assertFraction(-1, 2, new Fraction(-0.5));        assertFraction(-1, 3, new Fraction(-1.0 / 3.0));        assertFraction(-17, 100, new Fraction(17.0 / -100.0));        assertFraction(-317, 100, new Fraction(-317.0 / 100.0));    }    @Test    public void testAbs() {        Fraction a = new Fraction(10, 21);        Fraction b = new Fraction(-10, 21);        Fraction c = new Fraction(10, -21);        assertFraction(10, 21, a.abs());        assertFraction(10, 21, b.abs());        assertFraction(10, 21, c.abs());    }    @Test    public void testReciprocal() {        Fraction f = null;        f = new Fraction(50, 75);        f = f.reciprocal();        Assert.assertEquals(3, f.getNumerator());        Assert.assertEquals(2, f.getDenominator());        f = new Fraction(4, 3);        f = f.reciprocal();        Assert.assertEquals(3, f.getNumerator());        Assert.assertEquals(4, f.getDenominator());        f = new Fraction(-15, 47);        f = f.reciprocal();        Assert.assertEquals(-47, f.getNumerator());        Assert.assertEquals(15, f.getDenominator());        f = new Fraction(0, 3);        try {            f = f.reciprocal();            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException ex) {}        // large values        f = new Fraction(Integer.MAX_VALUE, 1);        f = f.reciprocal();        Assert.assertEquals(1, f.getNumerator());        Assert.assertEquals(Integer.MAX_VALUE, f.getDenominator());    }    @Test    public void testNegate() {        Fraction f = null;        f = new Fraction(50, 75);        f = f.negate();        Assert.assertEquals(-2, f.getNumerator());        Assert.assertEquals(3, f.getDenominator());        f = new Fraction(-50, 75);        f = f.negate();        Assert.assertEquals(2, f.getNumerator());        Assert.assertEquals(3, f.getDenominator());        // large values        f = new Fraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE);        f = f.negate();        Assert.assertEquals(Integer.MIN_VALUE+2, f.getNumerator());        Assert.assertEquals(Integer.MAX_VALUE, f.getDenominator());        f = new Fraction(Integer.MIN_VALUE, 1);        try {            f = f.negate();            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException ex) {}    }    @Test    public void testAdd() {        Fraction a = new Fraction(1, 2);        Fraction b = new Fraction(2, 3);        assertFraction(1, 1, a.add(a));        assertFraction(7, 6, a.add(b));        assertFraction(7, 6, b.add(a));        assertFraction(4, 3, b.add(b));        Fraction f1 = new Fraction(Integer.MAX_VALUE - 1, 1);        Fraction f2 = Fraction.ONE;        Fraction f = f1.add(f2);        Assert.assertEquals(Integer.MAX_VALUE, f.getNumerator());        Assert.assertEquals(1, f.getDenominator());        f = f1.add(1);        Assert.assertEquals(Integer.MAX_VALUE, f.getNumerator());        Assert.assertEquals(1, f.getDenominator());        f1 = new Fraction(-1, 13*13*2*2);        f2 = new Fraction(-2, 13*17*2);        f = f1.add(f2);        Assert.assertEquals(13*13*17*2*2, f.getDenominator());        Assert.assertEquals(-17 - 2*13*2, f.getNumerator());        try {            f.add(null);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {}        // if this fraction is added naively, it will overflow.        // check that it doesn't.        f1 = new Fraction(1,32768*3);        f2 = new Fraction(1,59049);        f = f1.add(f2);        Assert.assertEquals(52451, f.getNumerator());        Assert.assertEquals(1934917632, f.getDenominator());        f1 = new Fraction(Integer.MIN_VALUE, 3);        f2 = new Fraction(1,3);        f = f1.add(f2);        Assert.assertEquals(Integer.MIN_VALUE+1, f.getNumerator());        Assert.assertEquals(3, f.getDenominator());        f1 = new Fraction(Integer.MAX_VALUE - 1, 1);        f2 = Fraction.ONE;        f = f1.add(f2);        Assert.assertEquals(Integer.MAX_VALUE, f.getNumerator());        Assert.assertEquals(1, f.getDenominator());        try {            f = f.add(Fraction.ONE); // should overflow            Assert.fail("expecting MathArithmeticException but got: " + f.toString());        } catch (MathArithmeticException ex) {}        // denominator should not be a multiple of 2 or 3 to trigger overflow        f1 = new Fraction(Integer.MIN_VALUE, 5);        f2 = new Fraction(-1,5);        try {            f = f1.add(f2); // should overflow            Assert.fail("expecting MathArithmeticException but got: " + f.toString());        } catch (MathArithmeticException ex) {}        try {            f= new Fraction(-Integer.MAX_VALUE, 1);            f = f.add(f);            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException ex) {}        try {            f= new Fraction(-Integer.MAX_VALUE, 1);            f = f.add(f);            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException ex) {}        f1 = new Fraction(3,327680);        f2 = new Fraction(2,59049);        try {            f = f1.add(f2); // should overflow            Assert.fail("expecting MathArithmeticException but got: " + f.toString());        } catch (MathArithmeticException ex) {}    }    @Test    public void testDivide() {        Fraction a = new Fraction(1, 2);        Fraction b = new Fraction(2, 3);        assertFraction(1, 1, a.divide(a));        assertFraction(3, 4, a.divide(b));        assertFraction(4, 3, b.divide(a));        assertFraction(1, 1, b.divide(b));        Fraction f1 = new Fraction(3, 5);        Fraction f2 = Fraction.ZERO;        try {            f1.divide(f2);            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException ex) {}        f1 = new Fraction(0, 5);        f2 = new Fraction(2, 7);        Fraction f = f1.divide(f2);        Assert.assertSame(Fraction.ZERO, f);        f1 = new Fraction(2, 7);        f2 = Fraction.ONE;        f = f1.divide(f2);        Assert.assertEquals(2, f.getNumerator());        Assert.assertEquals(7, f.getDenominator());        f1 = new Fraction(1, Integer.MAX_VALUE);        f = f1.divide(f1);        Assert.assertEquals(1, f.getNumerator());        Assert.assertEquals(1, f.getDenominator());        f1 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        f2 = new Fraction(1, Integer.MAX_VALUE);        f = f1.divide(f2);        Assert.assertEquals(Integer.MIN_VALUE, f.getNumerator());        Assert.assertEquals(1, f.getDenominator());        try {            f.divide(null);            Assert.fail("MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {}        try {            f1 = new Fraction(1, Integer.MAX_VALUE);            f = f1.divide(f1.reciprocal());  // should overflow            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException ex) {}        try {            f1 = new Fraction(1, -Integer.MAX_VALUE);            f = f1.divide(f1.reciprocal());  // should overflow            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException ex) {}        f1 = new Fraction(6, 35);        f  = f1.divide(15);        Assert.assertEquals(2, f.getNumerator());        Assert.assertEquals(175, f.getDenominator());    }    @Test    public void testMultiply() {        Fraction a = new Fraction(1, 2);        Fraction b = new Fraction(2, 3);        assertFraction(1, 4, a.multiply(a));        assertFraction(1, 3, a.multiply(b));        assertFraction(1, 3, b.multiply(a));        assertFraction(4, 9, b.multiply(b));        Fraction f1 = new Fraction(Integer.MAX_VALUE, 1);        Fraction f2 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        Fraction f = f1.multiply(f2);        Assert.assertEquals(Integer.MIN_VALUE, f.getNumerator());        Assert.assertEquals(1, f.getDenominator());        try {            f.multiply(null);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {}        f1 = new Fraction(6, 35);        f  = f1.multiply(15);        Assert.assertEquals(18, f.getNumerator());        Assert.assertEquals(7, f.getDenominator());    }    @Test    public void testSubtract() {        Fraction a = new Fraction(1, 2);        Fraction b = new Fraction(2, 3);        assertFraction(0, 1, a.subtract(a));        assertFraction(-1, 6, a.subtract(b));        assertFraction(1, 6, b.subtract(a));        assertFraction(0, 1, b.subtract(b));        Fraction f = new Fraction(1,1);        try {            f.subtract(null);            Assert.fail("expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {}        // if this fraction is subtracted naively, it will overflow.        // check that it doesn't.        Fraction f1 = new Fraction(1,32768*3);        Fraction f2 = new Fraction(1,59049);        f = f1.subtract(f2);        Assert.assertEquals(-13085, f.getNumerator());        Assert.assertEquals(1934917632, f.getDenominator());        f1 = new Fraction(Integer.MIN_VALUE, 3);        f2 = new Fraction(1,3).negate();        f = f1.subtract(f2);        Assert.assertEquals(Integer.MIN_VALUE+1, f.getNumerator());        Assert.assertEquals(3, f.getDenominator());        f1 = new Fraction(Integer.MAX_VALUE, 1);        f2 = Fraction.ONE;        f = f1.subtract(f2);        Assert.assertEquals(Integer.MAX_VALUE-1, f.getNumerator());        Assert.assertEquals(1, f.getDenominator());        f = f1.subtract(1);        Assert.assertEquals(Integer.MAX_VALUE-1, f.getNumerator());        Assert.assertEquals(1, f.getDenominator());        try {            f1 = new Fraction(1, Integer.MAX_VALUE);            f2 = new Fraction(1, Integer.MAX_VALUE - 1);            f = f1.subtract(f2);            Assert.fail("expecting MathArithmeticException");  //should overflow        } catch (MathArithmeticException ex) {}        // denominator should not be a multiple of 2 or 3 to trigger overflow        f1 = new Fraction(Integer.MIN_VALUE, 5);        f2 = new Fraction(1,5);        try {            f = f1.subtract(f2); // should overflow            Assert.fail("expecting MathArithmeticException but got: " + f.toString());        } catch (MathArithmeticException ex) {}        try {            f= new Fraction(Integer.MIN_VALUE, 1);            f = f.subtract(Fraction.ONE);            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException ex) {}        try {            f= new Fraction(Integer.MAX_VALUE, 1);            f = f.subtract(Fraction.ONE.negate());            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException ex) {}        f1 = new Fraction(3,327680);        f2 = new Fraction(2,59049);        try {            f = f1.subtract(f2); // should overflow            Assert.fail("expecting MathArithmeticException but got: " + f.toString());        } catch (MathArithmeticException ex) {}    }    @Test    public void testEqualsAndHashCode() {        Fraction zero  = new Fraction(0,1);        Fraction nullFraction = null;        Assert.assertTrue( zero.equals(zero));        Assert.assertFalse(zero.equals(nullFraction));        Assert.assertFalse(zero.equals(Double.valueOf(0)));        Fraction zero2 = new Fraction(0,2);        Assert.assertTrue(zero.equals(zero2));        Assert.assertEquals(zero.hashCode(), zero2.hashCode());        Fraction one = new Fraction(1,1);        Assert.assertFalse((one.equals(zero) ||zero.equals(one)));    }    @Test    public void testGetReducedFraction() {        Fraction threeFourths = new Fraction(3, 4);        Assert.assertTrue(threeFourths.equals(Fraction.getReducedFraction(6, 8)));        Assert.assertTrue(Fraction.ZERO.equals(Fraction.getReducedFraction(0, -1)));        try {            Fraction.getReducedFraction(1, 0);            Assert.fail("expecting MathArithmeticException");        } catch (MathArithmeticException ex) {            // expected        }        Assert.assertEquals(Fraction.getReducedFraction                (2, Integer.MIN_VALUE).getNumerator(),-1);        Assert.assertEquals(Fraction.getReducedFraction                (1, -1).getNumerator(), -1);    }    @Test    public void testToString() {        Assert.assertEquals("0", new Fraction(0, 3).toString());        Assert.assertEquals("3", new Fraction(6, 2).toString());        Assert.assertEquals("2 / 3", new Fraction(18, 27).toString());    }    @Test    public void testSerial() throws FractionConversionException {        Fraction[] fractions = {            new Fraction(3, 4), Fraction.ONE, Fraction.ZERO,            new Fraction(17), new Fraction(FastMath.PI, 1000),            new Fraction(-5, 2)        };        for (Fraction fraction : fractions) {            Assert.assertEquals(fraction, TestUtils.serializeAndRecover(fraction));        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import java.math.BigDecimal;import java.math.BigInteger;import org.apache.commons.math.ConvergenceException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class BigFractionTest {    private void assertFraction(int expectedNumerator, int expectedDenominator, BigFraction actual) {        Assert.assertEquals(expectedNumerator, actual.getNumeratorAsInt());        Assert.assertEquals(expectedDenominator, actual.getDenominatorAsInt());    }    private void assertFraction(long expectedNumerator, long expectedDenominator, BigFraction actual) {        Assert.assertEquals(expectedNumerator, actual.getNumeratorAsLong());        Assert.assertEquals(expectedDenominator, actual.getDenominatorAsLong());    }    @Test    public void testConstructor() throws Exception {        assertFraction(0, 1, new BigFraction(0, 1));        assertFraction(0, 1, new BigFraction(0l, 2l));        assertFraction(0, 1, new BigFraction(0, -1));        assertFraction(1, 2, new BigFraction(1, 2));        assertFraction(1, 2, new BigFraction(2, 4));        assertFraction(-1, 2, new BigFraction(-1, 2));        assertFraction(-1, 2, new BigFraction(1, -2));        assertFraction(-1, 2, new BigFraction(-2, 4));        assertFraction(-1, 2, new BigFraction(2, -4));        assertFraction(11, 1, new BigFraction(11));        assertFraction(11, 1, new BigFraction(11l));        assertFraction(11, 1, new BigFraction(new BigInteger("11")));        assertFraction(0, 1, new BigFraction(0.00000000000001, 1.0e-5, 100));        assertFraction(2, 5, new BigFraction(0.40000000000001, 1.0e-5, 100));        assertFraction(15, 1, new BigFraction(15.0000000000001, 1.0e-5, 100));        Assert.assertEquals(0.00000000000001, new BigFraction(0.00000000000001).doubleValue(), 0.0);        Assert.assertEquals(0.40000000000001, new BigFraction(0.40000000000001).doubleValue(), 0.0);        Assert.assertEquals(15.0000000000001, new BigFraction(15.0000000000001).doubleValue(), 0.0);        assertFraction(3602879701896487l, 9007199254740992l, new BigFraction(0.40000000000001));        assertFraction(1055531162664967l, 70368744177664l, new BigFraction(15.0000000000001));        try {            new BigFraction(null, BigInteger.ONE);            Assert.fail("Expecting NullArgumentException");        } catch (NullArgumentException npe) {            // expected        }        try {            new BigFraction(BigInteger.ONE, null);            Assert.fail("Expecting NullArgumentException");        } catch (NullArgumentException npe) {            // expected        }        try {            new BigFraction(BigInteger.ONE, BigInteger.ZERO);            Assert.fail("Expecting ArithmeticException");        } catch (ArithmeticException npe) {            // expected        }        try {            new BigFraction(2.0 * Integer.MAX_VALUE, 1.0e-5, 100000);            Assert.fail("Expecting FractionConversionException");        } catch (FractionConversionException fce) {            // expected        }    }    @Test    public void testGoldenRatio() {        try {            // the golden ratio is notoriously a difficult number for continuous            // fraction            new BigFraction((1 + FastMath.sqrt(5)) / 2, 1.0e-12, 25);            Assert.fail("an exception should have been thrown");        } catch (ConvergenceException ce) {            // expected behavior        }    }    // MATH-179    @Test    public void testDoubleConstructor() throws ConvergenceException {        assertFraction(1, 2, new BigFraction((double) 1 / (double) 2, 1.0e-5, 100));        assertFraction(1, 3, new BigFraction((double) 1 / (double) 3, 1.0e-5, 100));        assertFraction(2, 3, new BigFraction((double) 2 / (double) 3, 1.0e-5, 100));        assertFraction(1, 4, new BigFraction((double) 1 / (double) 4, 1.0e-5, 100));        assertFraction(3, 4, new BigFraction((double) 3 / (double) 4, 1.0e-5, 100));        assertFraction(1, 5, new BigFraction((double) 1 / (double) 5, 1.0e-5, 100));        assertFraction(2, 5, new BigFraction((double) 2 / (double) 5, 1.0e-5, 100));        assertFraction(3, 5, new BigFraction((double) 3 / (double) 5, 1.0e-5, 100));        assertFraction(4, 5, new BigFraction((double) 4 / (double) 5, 1.0e-5, 100));        assertFraction(1, 6, new BigFraction((double) 1 / (double) 6, 1.0e-5, 100));        assertFraction(5, 6, new BigFraction((double) 5 / (double) 6, 1.0e-5, 100));        assertFraction(1, 7, new BigFraction((double) 1 / (double) 7, 1.0e-5, 100));        assertFraction(2, 7, new BigFraction((double) 2 / (double) 7, 1.0e-5, 100));        assertFraction(3, 7, new BigFraction((double) 3 / (double) 7, 1.0e-5, 100));        assertFraction(4, 7, new BigFraction((double) 4 / (double) 7, 1.0e-5, 100));        assertFraction(5, 7, new BigFraction((double) 5 / (double) 7, 1.0e-5, 100));        assertFraction(6, 7, new BigFraction((double) 6 / (double) 7, 1.0e-5, 100));        assertFraction(1, 8, new BigFraction((double) 1 / (double) 8, 1.0e-5, 100));        assertFraction(3, 8, new BigFraction((double) 3 / (double) 8, 1.0e-5, 100));        assertFraction(5, 8, new BigFraction((double) 5 / (double) 8, 1.0e-5, 100));        assertFraction(7, 8, new BigFraction((double) 7 / (double) 8, 1.0e-5, 100));        assertFraction(1, 9, new BigFraction((double) 1 / (double) 9, 1.0e-5, 100));        assertFraction(2, 9, new BigFraction((double) 2 / (double) 9, 1.0e-5, 100));        assertFraction(4, 9, new BigFraction((double) 4 / (double) 9, 1.0e-5, 100));        assertFraction(5, 9, new BigFraction((double) 5 / (double) 9, 1.0e-5, 100));        assertFraction(7, 9, new BigFraction((double) 7 / (double) 9, 1.0e-5, 100));        assertFraction(8, 9, new BigFraction((double) 8 / (double) 9, 1.0e-5, 100));        assertFraction(1, 10, new BigFraction((double) 1 / (double) 10, 1.0e-5, 100));        assertFraction(3, 10, new BigFraction((double) 3 / (double) 10, 1.0e-5, 100));        assertFraction(7, 10, new BigFraction((double) 7 / (double) 10, 1.0e-5, 100));        assertFraction(9, 10, new BigFraction((double) 9 / (double) 10, 1.0e-5, 100));        assertFraction(1, 11, new BigFraction((double) 1 / (double) 11, 1.0e-5, 100));        assertFraction(2, 11, new BigFraction((double) 2 / (double) 11, 1.0e-5, 100));        assertFraction(3, 11, new BigFraction((double) 3 / (double) 11, 1.0e-5, 100));        assertFraction(4, 11, new BigFraction((double) 4 / (double) 11, 1.0e-5, 100));        assertFraction(5, 11, new BigFraction((double) 5 / (double) 11, 1.0e-5, 100));        assertFraction(6, 11, new BigFraction((double) 6 / (double) 11, 1.0e-5, 100));        assertFraction(7, 11, new BigFraction((double) 7 / (double) 11, 1.0e-5, 100));        assertFraction(8, 11, new BigFraction((double) 8 / (double) 11, 1.0e-5, 100));        assertFraction(9, 11, new BigFraction((double) 9 / (double) 11, 1.0e-5, 100));        assertFraction(10, 11, new BigFraction((double) 10 / (double) 11, 1.0e-5, 100));    }    // MATH-181    @Test    public void testDigitLimitConstructor() throws ConvergenceException {        assertFraction(2, 5, new BigFraction(0.4, 9));        assertFraction(2, 5, new BigFraction(0.4, 99));        assertFraction(2, 5, new BigFraction(0.4, 999));        assertFraction(3, 5, new BigFraction(0.6152, 9));        assertFraction(8, 13, new BigFraction(0.6152, 99));        assertFraction(510, 829, new BigFraction(0.6152, 999));        assertFraction(769, 1250, new BigFraction(0.6152, 9999));    }    @Test    public void testEpsilonLimitConstructor() throws ConvergenceException {        assertFraction(2, 5, new BigFraction(0.4, 1.0e-5, 100));        assertFraction(3, 5, new BigFraction(0.6152, 0.02, 100));        assertFraction(8, 13, new BigFraction(0.6152, 1.0e-3, 100));        assertFraction(251, 408, new BigFraction(0.6152, 1.0e-4, 100));        assertFraction(251, 408, new BigFraction(0.6152, 1.0e-5, 100));        assertFraction(510, 829, new BigFraction(0.6152, 1.0e-6, 100));        assertFraction(769, 1250, new BigFraction(0.6152, 1.0e-7, 100));    }    @Test    public void testCompareTo() {        BigFraction first = new BigFraction(1, 2);        BigFraction second = new BigFraction(1, 3);        BigFraction third = new BigFraction(1, 2);        Assert.assertEquals(0, first.compareTo(first));        Assert.assertEquals(0, first.compareTo(third));        Assert.assertEquals(1, first.compareTo(second));        Assert.assertEquals(-1, second.compareTo(first));        // these two values are different approximations of PI        // the first  one is approximately PI - 3.07e-18        // the second one is approximately PI + 1.936e-17        BigFraction pi1 = new BigFraction(1068966896, 340262731);        BigFraction pi2 = new BigFraction( 411557987, 131002976);        Assert.assertEquals(-1, pi1.compareTo(pi2));        Assert.assertEquals( 1, pi2.compareTo(pi1));        Assert.assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);    }    @Test    public void testDoubleValue() {        BigFraction first = new BigFraction(1, 2);        BigFraction second = new BigFraction(1, 3);        Assert.assertEquals(0.5, first.doubleValue(), 0.0);        Assert.assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);    }    @Test    public void testFloatValue() {        BigFraction first = new BigFraction(1, 2);        BigFraction second = new BigFraction(1, 3);        Assert.assertEquals(0.5f, first.floatValue(), 0.0f);        Assert.assertEquals((float) (1.0 / 3.0), second.floatValue(), 0.0f);    }    @Test    public void testIntValue() {        BigFraction first = new BigFraction(1, 2);        BigFraction second = new BigFraction(3, 2);        Assert.assertEquals(0, first.intValue());        Assert.assertEquals(1, second.intValue());    }    @Test    public void testLongValue() {        BigFraction first = new BigFraction(1, 2);        BigFraction second = new BigFraction(3, 2);        Assert.assertEquals(0L, first.longValue());        Assert.assertEquals(1L, second.longValue());    }    @Test    public void testConstructorDouble() {        assertFraction(1, 2, new BigFraction(0.5));        assertFraction(6004799503160661l, 18014398509481984l, new BigFraction(1.0 / 3.0));        assertFraction(6124895493223875l, 36028797018963968l, new BigFraction(17.0 / 100.0));        assertFraction(1784551352345559l, 562949953421312l, new BigFraction(317.0 / 100.0));        assertFraction(-1, 2, new BigFraction(-0.5));        assertFraction(-6004799503160661l, 18014398509481984l, new BigFraction(-1.0 / 3.0));        assertFraction(-6124895493223875l, 36028797018963968l, new BigFraction(17.0 / -100.0));        assertFraction(-1784551352345559l, 562949953421312l, new BigFraction(-317.0 / 100.0));        for (double v : new double[] { Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY}) {            try {                new BigFraction(v);                Assert.fail("Expecting IllegalArgumentException");            } catch (IllegalArgumentException iae) {                // expected            }        }        Assert.assertEquals(1l, new BigFraction(Double.MAX_VALUE).getDenominatorAsLong());        Assert.assertEquals(1l, new BigFraction(Double.longBitsToDouble(0x0010000000000000L)).getNumeratorAsLong());        Assert.assertEquals(1l, new BigFraction(Double.MIN_VALUE).getNumeratorAsLong());    }    @Test    public void testAbs() {        BigFraction a = new BigFraction(10, 21);        BigFraction b = new BigFraction(-10, 21);        BigFraction c = new BigFraction(10, -21);        assertFraction(10, 21, a.abs());        assertFraction(10, 21, b.abs());        assertFraction(10, 21, c.abs());    }    @Test    public void testReciprocal() {        BigFraction f = null;        f = new BigFraction(50, 75);        f = f.reciprocal();        Assert.assertEquals(3, f.getNumeratorAsInt());        Assert.assertEquals(2, f.getDenominatorAsInt());        f = new BigFraction(4, 3);        f = f.reciprocal();        Assert.assertEquals(3, f.getNumeratorAsInt());        Assert.assertEquals(4, f.getDenominatorAsInt());        f = new BigFraction(-15, 47);        f = f.reciprocal();        Assert.assertEquals(-47, f.getNumeratorAsInt());        Assert.assertEquals(15, f.getDenominatorAsInt());        f = new BigFraction(0, 3);        try {            f = f.reciprocal();            Assert.fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {        }        // large values        f = new BigFraction(Integer.MAX_VALUE, 1);        f = f.reciprocal();        Assert.assertEquals(1, f.getNumeratorAsInt());        Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());    }    @Test    public void testNegate() {        BigFraction f = null;        f = new BigFraction(50, 75);        f = f.negate();        Assert.assertEquals(-2, f.getNumeratorAsInt());        Assert.assertEquals(3, f.getDenominatorAsInt());        f = new BigFraction(-50, 75);        f = f.negate();        Assert.assertEquals(2, f.getNumeratorAsInt());        Assert.assertEquals(3, f.getDenominatorAsInt());        // large values        f = new BigFraction(Integer.MAX_VALUE - 1, Integer.MAX_VALUE);        f = f.negate();        Assert.assertEquals(Integer.MIN_VALUE + 2, f.getNumeratorAsInt());        Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());    }    @Test    public void testAdd() {        BigFraction a = new BigFraction(1, 2);        BigFraction b = new BigFraction(2, 3);        assertFraction(1, 1, a.add(a));        assertFraction(7, 6, a.add(b));        assertFraction(7, 6, b.add(a));        assertFraction(4, 3, b.add(b));        BigFraction f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);        BigFraction f2 = BigFraction.ONE;        BigFraction f = f1.add(f2);        Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        Assert.assertEquals(1, f.getDenominatorAsInt());        f1 = new BigFraction(-1, 13 * 13 * 2 * 2);        f2 = new BigFraction(-2, 13 * 17 * 2);        f = f1.add(f2);        Assert.assertEquals(13 * 13 * 17 * 2 * 2, f.getDenominatorAsInt());        Assert.assertEquals(-17 - 2 * 13 * 2, f.getNumeratorAsInt());        try {            f.add((BigFraction) null);            Assert.fail("expecting NullArgumentException");        } catch (NullArgumentException ex) {        }        // if this fraction is added naively, it will overflow.        // check that it doesn't.        f1 = new BigFraction(1, 32768 * 3);        f2 = new BigFraction(1, 59049);        f = f1.add(f2);        Assert.assertEquals(52451, f.getNumeratorAsInt());        Assert.assertEquals(1934917632, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MIN_VALUE, 3);        f2 = new BigFraction(1, 3);        f = f1.add(f2);        Assert.assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt());        Assert.assertEquals(3, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);        f = f1.add(BigInteger.ONE);        Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        Assert.assertEquals(1, f.getDenominatorAsInt());        f = f.add(BigInteger.ZERO);        Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        Assert.assertEquals(1, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);        f = f1.add(1);        Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        Assert.assertEquals(1, f.getDenominatorAsInt());        f = f.add(0);        Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        Assert.assertEquals(1, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);        f = f1.add(1l);        Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        Assert.assertEquals(1, f.getDenominatorAsInt());        f = f.add(0l);        Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        Assert.assertEquals(1, f.getDenominatorAsInt());    }    @Test    public void testDivide() {        BigFraction a = new BigFraction(1, 2);        BigFraction b = new BigFraction(2, 3);        assertFraction(1, 1, a.divide(a));        assertFraction(3, 4, a.divide(b));        assertFraction(4, 3, b.divide(a));        assertFraction(1, 1, b.divide(b));        BigFraction f1 = new BigFraction(3, 5);        BigFraction f2 = BigFraction.ZERO;        try {            f1.divide(f2);            Assert.fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {        }        f1 = new BigFraction(0, 5);        f2 = new BigFraction(2, 7);        BigFraction f = f1.divide(f2);        Assert.assertSame(BigFraction.ZERO, f);        f1 = new BigFraction(2, 7);        f2 = BigFraction.ONE;        f = f1.divide(f2);        Assert.assertEquals(2, f.getNumeratorAsInt());        Assert.assertEquals(7, f.getDenominatorAsInt());        f1 = new BigFraction(1, Integer.MAX_VALUE);        f = f1.divide(f1);        Assert.assertEquals(1, f.getNumeratorAsInt());        Assert.assertEquals(1, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        f2 = new BigFraction(1, Integer.MAX_VALUE);        f = f1.divide(f2);        Assert.assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());        Assert.assertEquals(1, f.getDenominatorAsInt());        try {            f.divide((BigFraction) null);            Assert.fail("expecting NullArgumentException");        } catch (NullArgumentException ex) {        }        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        f = f1.divide(BigInteger.valueOf(Integer.MIN_VALUE));        Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());        Assert.assertEquals(1, f.getNumeratorAsInt());        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        f = f1.divide(Integer.MIN_VALUE);        Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());        Assert.assertEquals(1, f.getNumeratorAsInt());        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        f = f1.divide((long) Integer.MIN_VALUE);        Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());        Assert.assertEquals(1, f.getNumeratorAsInt());    }    @Test    public void testMultiply() {        BigFraction a = new BigFraction(1, 2);        BigFraction b = new BigFraction(2, 3);        assertFraction(1, 4, a.multiply(a));        assertFraction(1, 3, a.multiply(b));        assertFraction(1, 3, b.multiply(a));        assertFraction(4, 9, b.multiply(b));        BigFraction f1 = new BigFraction(Integer.MAX_VALUE, 1);        BigFraction f2 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        BigFraction f = f1.multiply(f2);        Assert.assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());        Assert.assertEquals(1, f.getDenominatorAsInt());        f = f2.multiply(Integer.MAX_VALUE);        Assert.assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());        Assert.assertEquals(1, f.getDenominatorAsInt());        f = f2.multiply((long) Integer.MAX_VALUE);        Assert.assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());        Assert.assertEquals(1, f.getDenominatorAsInt());        try {            f.multiply((BigFraction) null);            Assert.fail("expecting NullArgumentException");        } catch (NullArgumentException ex) {        }    }    @Test    public void testSubtract() {        BigFraction a = new BigFraction(1, 2);        BigFraction b = new BigFraction(2, 3);        assertFraction(0, 1, a.subtract(a));        assertFraction(-1, 6, a.subtract(b));        assertFraction(1, 6, b.subtract(a));        assertFraction(0, 1, b.subtract(b));        BigFraction f = new BigFraction(1, 1);        try {            f.subtract((BigFraction) null);            Assert.fail("expecting NullArgumentException");        } catch (NullArgumentException ex) {        }        // if this fraction is subtracted naively, it will overflow.        // check that it doesn't.        BigFraction f1 = new BigFraction(1, 32768 * 3);        BigFraction f2 = new BigFraction(1, 59049);        f = f1.subtract(f2);        Assert.assertEquals(-13085, f.getNumeratorAsInt());        Assert.assertEquals(1934917632, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MIN_VALUE, 3);        f2 = new BigFraction(1, 3).negate();        f = f1.subtract(f2);        Assert.assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt());        Assert.assertEquals(3, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MAX_VALUE, 1);        f2 = BigFraction.ONE;        f = f1.subtract(f2);        Assert.assertEquals(Integer.MAX_VALUE - 1, f.getNumeratorAsInt());        Assert.assertEquals(1, f.getDenominatorAsInt());    }    @Test    public void testBigDecimalValue() {        Assert.assertEquals(new BigDecimal(0.5), new BigFraction(1, 2).bigDecimalValue());        Assert.assertEquals(new BigDecimal("0.0003"), new BigFraction(3, 10000).bigDecimalValue());        Assert.assertEquals(new BigDecimal("0"), new BigFraction(1, 3).bigDecimalValue(BigDecimal.ROUND_DOWN));        Assert.assertEquals(new BigDecimal("0.333"), new BigFraction(1, 3).bigDecimalValue(3, BigDecimal.ROUND_DOWN));    }    @Test    public void testEqualsAndHashCode() {        BigFraction zero = new BigFraction(0, 1);        BigFraction nullFraction = null;        Assert.assertTrue(zero.equals(zero));        Assert.assertFalse(zero.equals(nullFraction));        Assert.assertFalse(zero.equals(Double.valueOf(0)));        BigFraction zero2 = new BigFraction(0, 2);        Assert.assertTrue(zero.equals(zero2));        Assert.assertEquals(zero.hashCode(), zero2.hashCode());        BigFraction one = new BigFraction(1, 1);        Assert.assertFalse((one.equals(zero) || zero.equals(one)));        Assert.assertTrue(one.equals(BigFraction.ONE));    }    @Test    public void testGetReducedFraction() {        BigFraction threeFourths = new BigFraction(3, 4);        Assert.assertTrue(threeFourths.equals(BigFraction.getReducedFraction(6, 8)));        Assert.assertTrue(BigFraction.ZERO.equals(BigFraction.getReducedFraction(0, -1)));        try {            BigFraction.getReducedFraction(1, 0);            Assert.fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected        }        Assert.assertEquals(BigFraction.getReducedFraction(2, Integer.MIN_VALUE).getNumeratorAsInt(), -1);        Assert.assertEquals(BigFraction.getReducedFraction(1, -1).getNumeratorAsInt(), -1);    }    @Test    public void testPow() {        Assert.assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(13));        Assert.assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(13l));        Assert.assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(BigInteger.valueOf(13l)));        Assert.assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(0));        Assert.assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(0l));        Assert.assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(BigInteger.valueOf(0l)));        Assert.assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(-13));        Assert.assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(-13l));        Assert.assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(BigInteger.valueOf(-13l)));    }    @Test    public void testMath340() {        BigFraction fractionA = new BigFraction(0.00131);        BigFraction fractionB = new BigFraction(.37).reciprocal();        BigFraction errorResult = fractionA.multiply(fractionB);        BigFraction correctResult = new BigFraction(fractionA.getNumerator().multiply(fractionB.getNumerator()),                                                    fractionA.getDenominator().multiply(fractionB.getDenominator()));        Assert.assertEquals(correctResult, errorResult);    }    @Test    public void testSerial() throws FractionConversionException {        BigFraction[] fractions = {            new BigFraction(3, 4), BigFraction.ONE, BigFraction.ZERO,            new BigFraction(17), new BigFraction(FastMath.PI, 1000),            new BigFraction(-5, 2)        };        for (BigFraction fraction : fractions) {            Assert.assertEquals(fraction, TestUtils.serializeAndRecover(fraction));        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import org.apache.commons.math.TestUtils;import org.junit.Assert;import org.junit.Test;public class BigFractionFieldTest {    @Test    public void testZero() {        Assert.assertEquals(BigFraction.ZERO, BigFractionField.getInstance().getZero());    }    @Test    public void testOne() {        Assert.assertEquals(BigFraction.ONE, BigFractionField.getInstance().getOne());    }    @Test    public void testSerial() {        // deserializing the singleton should give the singleton itself back        BigFractionField field = BigFractionField.getInstance();        Assert.assertTrue(field == TestUtils.serializeAndRecover(field));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import java.text.NumberFormat;import java.text.ParseException;import java.util.Locale;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public class FractionFormatTest {    FractionFormat properFormat = null;    FractionFormat improperFormat = null;    protected Locale getLocale() {        return Locale.getDefault();    }    @Before    public void setUp() throws Exception {        properFormat = FractionFormat.getProperInstance(getLocale());        improperFormat = FractionFormat.getImproperInstance(getLocale());    }    @Test    public void testFormat() {        Fraction c = new Fraction(1, 2);        String expected = "1 / 2";        String actual = properFormat.format(c);        Assert.assertEquals(expected, actual);        actual = improperFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testFormatNegative() {        Fraction c = new Fraction(-1, 2);        String expected = "-1 / 2";        String actual = properFormat.format(c);        Assert.assertEquals(expected, actual);        actual = improperFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testFormatZero() {        Fraction c = new Fraction(0, 1);        String expected = "0 / 1";        String actual = properFormat.format(c);        Assert.assertEquals(expected, actual);        actual = improperFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testFormatImproper() {        Fraction c = new Fraction(5, 3);        String actual = properFormat.format(c);        Assert.assertEquals("1 2 / 3", actual);        actual = improperFormat.format(c);        Assert.assertEquals("5 / 3", actual);    }    @Test    public void testFormatImproperNegative() {        Fraction c = new Fraction(-5, 3);        String actual = properFormat.format(c);        Assert.assertEquals("-1 2 / 3", actual);        actual = improperFormat.format(c);        Assert.assertEquals("-5 / 3", actual);    }    @Test    public void testParse() {        String source = "1 / 2";        try {            Fraction c = properFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(1, c.getNumerator());            Assert.assertEquals(2, c.getDenominator());            c = improperFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(1, c.getNumerator());            Assert.assertEquals(2, c.getDenominator());        } catch (ParseException ex) {            Assert.fail(ex.getMessage());        }    }    @Test    public void testParseInteger() {        String source = "10";        try {            Fraction c = properFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(10, c.getNumerator());            Assert.assertEquals(1, c.getDenominator());        } catch (ParseException ex) {            Assert.fail(ex.getMessage());        }        try {            Fraction c = improperFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(10, c.getNumerator());            Assert.assertEquals(1, c.getDenominator());        } catch (ParseException ex) {            Assert.fail(ex.getMessage());        }    }    @Test    public void testParseInvalid() {        String source = "a";        String msg = "should not be able to parse '10 / a'.";        try {            properFormat.parse(source);            Assert.fail(msg);        } catch (ParseException ex) {            // success        }        try {            improperFormat.parse(source);            Assert.fail(msg);        } catch (ParseException ex) {            // success        }    }    @Test    public void testParseInvalidDenominator() {        String source = "10 / a";        String msg = "should not be able to parse '10 / a'.";        try {            properFormat.parse(source);            Assert.fail(msg);        } catch (ParseException ex) {            // success        }        try {            improperFormat.parse(source);            Assert.fail(msg);        } catch (ParseException ex) {            // success        }    }    @Test    public void testParseNegative() {        try {            String source = "-1 / 2";            Fraction c = properFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(-1, c.getNumerator());            Assert.assertEquals(2, c.getDenominator());            c = improperFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(-1, c.getNumerator());            Assert.assertEquals(2, c.getDenominator());            source = "1 / -2";            c = properFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(-1, c.getNumerator());            Assert.assertEquals(2, c.getDenominator());            c = improperFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(-1, c.getNumerator());            Assert.assertEquals(2, c.getDenominator());        } catch (ParseException ex) {            Assert.fail(ex.getMessage());        }    }    @Test    public void testParseProper() {        String source = "1 2 / 3";        try {            Fraction c = properFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(5, c.getNumerator());            Assert.assertEquals(3, c.getDenominator());        } catch (ParseException ex) {            Assert.fail(ex.getMessage());        }        try {            improperFormat.parse(source);            Assert.fail("invalid improper fraction.");        } catch (ParseException ex) {            // success        }    }    @Test    public void testParseProperNegative() {        String source = "-1 2 / 3";        try {            Fraction c = properFormat.parse(source);            Assert.assertNotNull(c);            Assert.assertEquals(-5, c.getNumerator());            Assert.assertEquals(3, c.getDenominator());        } catch (ParseException ex) {            Assert.fail(ex.getMessage());        }        try {            improperFormat.parse(source);            Assert.fail("invalid improper fraction.");        } catch (ParseException ex) {            // success        }    }    @Test    public void testParseProperInvalidMinus() {        String source = "2 -2 / 3";        try {            properFormat.parse(source);            Assert.fail("invalid minus in improper fraction.");        } catch (ParseException ex) {            // expected        }        source = "2 2 / -3";        try {            properFormat.parse(source);            Assert.fail("invalid minus in improper fraction.");        } catch (ParseException ex) {            // expected        }    }    @Test    public void testNumeratorFormat() {        NumberFormat old = properFormat.getNumeratorFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        properFormat.setNumeratorFormat(nf);        Assert.assertEquals(nf, properFormat.getNumeratorFormat());        properFormat.setNumeratorFormat(old);        old = improperFormat.getNumeratorFormat();        nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        improperFormat.setNumeratorFormat(nf);        Assert.assertEquals(nf, improperFormat.getNumeratorFormat());        improperFormat.setNumeratorFormat(old);    }    @Test    public void testDenominatorFormat() {        NumberFormat old = properFormat.getDenominatorFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        properFormat.setDenominatorFormat(nf);        Assert.assertEquals(nf, properFormat.getDenominatorFormat());        properFormat.setDenominatorFormat(old);        old = improperFormat.getDenominatorFormat();        nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        improperFormat.setDenominatorFormat(nf);        Assert.assertEquals(nf, improperFormat.getDenominatorFormat());        improperFormat.setDenominatorFormat(old);    }    @Test    public void testWholeFormat() {        ProperFractionFormat format = (ProperFractionFormat)properFormat;        NumberFormat old = format.getWholeFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        format.setWholeFormat(nf);        Assert.assertEquals(nf, format.getWholeFormat());        format.setWholeFormat(old);    }    @Test    public void testLongFormat() {        Assert.assertEquals("10 / 1", improperFormat.format(10l));    }    @Test    public void testDoubleFormat() {        Assert.assertEquals("355 / 113", improperFormat.format(FastMath.PI));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import org.apache.commons.math.TestUtils;import org.junit.Assert;import org.junit.Test;public class FractionFieldTest {    @Test    public void testZero() {        Assert.assertEquals(Fraction.ZERO, FractionField.getInstance().getZero());    }    @Test    public void testOne() {        Assert.assertEquals(Fraction.ONE, FractionField.getInstance().getOne());    }    @Test    public void testSerial() {        // deserializing the singleton should give the singleton itself back        FractionField field = FractionField.getInstance();        Assert.assertTrue(field == TestUtils.serializeAndRecover(field));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.special.Gamma;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.NotStrictlyPositiveException;import org.junit.Assert;import org.junit.Test;/** * Test cases for WeibullDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Id$ */public class WeibullDistributionTest extends ContinuousDistributionAbstractTest  {    //-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public WeibullDistribution makeDistribution() {        return new WeibullDistributionImpl(1.2, 2.1);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 2.9.2        return new double[] {0.00664355180993, 0.0454328283309, 0.0981162737374, 0.176713524579, 0.321946865392,                10.5115496887, 7.4976304671, 6.23205600701, 5.23968436955, 4.2079028257};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0.180535929306, 0.262801138133, 0.301905425199, 0.330899152971,          0.353441418887, 0.000788590320203, 0.00737060094841, 0.0177576041516, 0.0343043442574, 0.065664589369};    }    //---------------------------- Additional test cases -------------------------    @Test    public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0.0, 1.0});        setInverseCumulativeTestValues(                new double[] {0.0, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }    @Test    public void testAlpha() {        WeibullDistribution dist = new WeibullDistributionImpl(1, 2);        Assert.assertEquals(1, dist.getShape(), 0);        try {            dist = new WeibullDistributionImpl(0, 2);            Assert.fail("NotStrictlyPositiveException expected");        } catch (NotStrictlyPositiveException e) {            // Expected.        }    }    @Test    public void testBeta() {        WeibullDistribution dist = new WeibullDistributionImpl(1, 2);        Assert.assertEquals(2, dist.getScale(), 0);        try {            dist = new WeibullDistributionImpl(1, 0);            Assert.fail("NotStrictlyPositiveException expected");        } catch (NotStrictlyPositiveException e) {            // Expected.        }    }    @Test    public void testMomonts() {        final double tol = 1e-9;        WeibullDistribution dist;                dist = new WeibullDistributionImpl(2.5, 3.5);        // In R: 3.5*gamma(1+(1/2.5)) (or emperically: mean(rweibull(10000, 2.5, 3.5)))        Assert.assertEquals(dist.getNumericalMean(), 3.5 * FastMath.exp(Gamma.logGamma(1 + (1 / 2.5))), tol);        Assert.assertEquals(dist.getNumericalVariance(), (3.5 * 3.5) *                 FastMath.exp(Gamma.logGamma(1 + (2 / 2.5))) -                (dist.getNumericalMean() * dist.getNumericalMean()), tol);                 dist = new WeibullDistributionImpl(10.4, 2.222);        Assert.assertEquals(dist.getNumericalMean(), 2.222 * FastMath.exp(Gamma.logGamma(1 + (1 / 10.4))), tol);        Assert.assertEquals(dist.getNumericalVariance(), (2.222 * 2.222) *                 FastMath.exp(Gamma.logGamma(1 + (2 / 10.4))) -                (dist.getNumericalMean() * dist.getNumericalMean()), tol);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.junit.Assert;import org.junit.Test;/** * Test cases for {@link KolmogorovSmirnovDistributionImpl}. * * @version $Id$ */public class KolmogorovSmirnovDistributionTest {        private static final double TOLERANCE = 10e-10;    @Test    public void testCumulativeDensityFunction() throws Exception {                KolmogorovSmirnovDistributionImpl dist;                /* The code below is generated using the R-script located in         * /src/test/R/KolmogorovSmirnovDistributionTestCases.R         */                /* R version 2.11.1 (2010-05-31) */        /* formatC(.C("pkolmogorov2x", p = as.double(0.005), n = as.integer(200), PACKAGE = "stats")$p, 40) gives         * 4.907829957616471622388047046469198862537e-86         */        dist = new KolmogorovSmirnovDistributionImpl(200);        Assert.assertEquals(4.907829957616471622388047046469198862537e-86, dist.cdf(0.005, false), TOLERANCE);        /* formatC(.C("pkolmogorov2x", p = as.double(0.02), n = as.integer(200), PACKAGE = "stats")$p, 40) gives         * 5.151982014280041957199687829849210629618e-06         */        dist = new KolmogorovSmirnovDistributionImpl(200);        Assert.assertEquals(5.151982014280041957199687829849210629618e-06, dist.cdf(0.02, false), TOLERANCE);        /* formatC(.C("pkolmogorov2x", p = as.double(0.031111), n = as.integer(200), PACKAGE = "stats")$p, 40) gives         * 0.01291614648162886340443389343590752105229         */        dist = new KolmogorovSmirnovDistributionImpl(200);        Assert.assertEquals(0.01291614648162886340443389343590752105229, dist.cdf(0.031111, false), TOLERANCE);        /* formatC(.C("pkolmogorov2x", p = as.double(0.04), n = as.integer(200), PACKAGE = "stats")$p, 40) gives         * 0.1067137011362679355208626930107129737735         */        dist = new KolmogorovSmirnovDistributionImpl(200);        Assert.assertEquals(0.1067137011362679355208626930107129737735, dist.cdf(0.04, false), TOLERANCE);        /* formatC(.C("pkolmogorov2x", p = as.double(0.005), n = as.integer(341), PACKAGE = "stats")$p, 40) gives         * 1.914734701559404553985102395145063418825e-53         */        dist = new KolmogorovSmirnovDistributionImpl(341);        Assert.assertEquals(1.914734701559404553985102395145063418825e-53, dist.cdf(0.005, false), TOLERANCE);        /* formatC(.C("pkolmogorov2x", p = as.double(0.02), n = as.integer(341), PACKAGE = "stats")$p, 40) gives         * 0.001171328985781981343872182321774744195864         */        dist = new KolmogorovSmirnovDistributionImpl(341);        Assert.assertEquals(0.001171328985781981343872182321774744195864, dist.cdf(0.02, false), TOLERANCE);        /* formatC(.C("pkolmogorov2x", p = as.double(0.031111), n = as.integer(341), PACKAGE = "stats")$p, 40) gives         * 0.1142955196267499418105728636874118819833         */        dist = new KolmogorovSmirnovDistributionImpl(341);        Assert.assertEquals(0.1142955196267499418105728636874118819833, dist.cdf(0.031111, false), TOLERANCE);        /* formatC(.C("pkolmogorov2x", p = as.double(0.04), n = as.integer(341), PACKAGE = "stats")$p, 40) gives         * 0.3685529520496805266915885113121476024389         */        dist = new KolmogorovSmirnovDistributionImpl(341);        Assert.assertEquals(0.3685529520496805266915885113121476024389, dist.cdf(0.04, false), TOLERANCE);        /* formatC(.C("pkolmogorov2x", p = as.double(0.005), n = as.integer(389), PACKAGE = "stats")$p, 40) gives         * 1.810657144595055888918455512707637574637e-47         */        dist = new KolmogorovSmirnovDistributionImpl(389);        Assert.assertEquals(1.810657144595055888918455512707637574637e-47, dist.cdf(0.005, false), TOLERANCE);        /* formatC(.C("pkolmogorov2x", p = as.double(0.02), n = as.integer(389), PACKAGE = "stats")$p, 40) gives         * 0.003068542559702356568168690742481885536108         */        dist = new KolmogorovSmirnovDistributionImpl(389);        Assert.assertEquals(0.003068542559702356568168690742481885536108, dist.cdf(0.02, false), TOLERANCE);        /* formatC(.C("pkolmogorov2x", p = as.double(0.031111), n = as.integer(389), PACKAGE = "stats")$p, 40) gives         * 0.1658291700122746237244797384846606291831         */        dist = new KolmogorovSmirnovDistributionImpl(389);        Assert.assertEquals(0.1658291700122746237244797384846606291831, dist.cdf(0.031111, false), TOLERANCE);        /* formatC(.C("pkolmogorov2x", p = as.double(0.04), n = as.integer(389), PACKAGE = "stats")$p, 40) gives         * 0.4513143712128902529379104180407011881471         */        dist = new KolmogorovSmirnovDistributionImpl(389);        Assert.assertEquals(0.4513143712128902529379104180407011881471, dist.cdf(0.04, false), TOLERANCE);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.junit.Assert;import org.junit.Test;/** * Test cases for PascalDistribution. * Extends IntegerDistributionAbstractTest.  See class javadoc for * IntegerDistributionAbstractTest for details. * * @version $Id$ */public class PascalDistributionTest extends IntegerDistributionAbstractTest {    // --------------------- Override tolerance  --------------    protected double defaultTolerance = NormalDistributionImpl.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;    @Override    public void setUp() {        super.setUp();        setTolerance(defaultTolerance);    }    //-------------- Implementations for abstract methods -----------------------    /** Creates the default discrete distribution instance to use in tests. */    @Override    public IntegerDistribution makeDistribution() {        return new PascalDistributionImpl(10,0.70);    }    /** Creates the default probability density test input values */    @Override    public int[] makeDensityTestPoints() {      return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {      return new double[] {0, 0.0282475249, 0.0847425747, 0.139825248255, 0.167790297906, 0.163595540458,              0.137420253985, 0.103065190489, 0.070673273478, 0.0450542118422, 0.0270325271053,              0.0154085404500, 0.0084046584273};    }    /** Creates the default cumulative probability density test input values */    @Override    public int[] makeCumulativeTestPoints() {      return makeDensityTestPoints();    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {      return new double[] {0, 0.0282475249, 0.1129900996, 0.252815347855, 0.420605645761, 0.584201186219,              0.721621440204, 0.824686630693, 0.895359904171, 0.940414116013, 0.967446643119,              0.982855183569, 0.991259841996};        }    /** Creates the default inverse cumulative probability test input values */    @Override    public double[] makeInverseCumulativeTestPoints() {      return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,          0.990d, 0.975d, 0.950d, 0.900d, 1};        }    /** Creates the default inverse cumulative probability density test expected values */    @Override    public int[] makeInverseCumulativeTestValues() {      return new int[] {-1, -1, -1, -1, 0, 0, 13, 10, 9, 8, 7, Integer.MAX_VALUE};    }    //----------------- Additional test cases ---------------------------------    /** Test degenerate case p = 0   */    @Test    public void testDegenerate0() throws Exception {        setDistribution(new PascalDistributionImpl(5,0.0d));        setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });        setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 0d});        setDensityTestPoints(new int[] {-1, 0, 1, 10, 11});        setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 1});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }    /** Test degenerate case p = 1   */    @Test    public void testDegenerate1() throws Exception {        setDistribution(new PascalDistributionImpl(5,1.0d));        setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });        setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10});        setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {-1, -1});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }    @Test    public void testMomonts() {        final double tol = 1e-9;        PascalDistribution dist;                dist = new PascalDistributionImpl(10, 0.5);        Assert.assertEquals(dist.getNumericalMean(), ( 10d * 0.5d ) / 0.5d, tol);        Assert.assertEquals(dist.getNumericalVariance(), ( 10d * 0.5d ) / (0.5d * 0.5d), tol);                 dist = new PascalDistributionImpl(25, 0.3);        Assert.assertEquals(dist.getNumericalMean(), ( 25d * 0.3d ) / 0.7d, tol);        Assert.assertEquals(dist.getNumericalVariance(), ( 25d * 0.3d ) / (0.7d * 0.7d), tol);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.TestUtils;import org.apache.commons.math.exception.NotPositiveException;import org.apache.commons.math.exception.NotStrictlyPositiveException;import org.apache.commons.math.exception.NumberIsTooLargeException;import org.junit.Assert;import org.junit.Test;/** * Test cases for HyperGeometriclDistribution. * Extends IntegerDistributionAbstractTest.  See class javadoc for * IntegerDistributionAbstractTest for details. * * @version $Id$ */public class HypergeometricDistributionTest extends IntegerDistributionAbstractTest {//-------------- Implementations for abstract methods -----------------------    /** Creates the default discrete distribution instance to use in tests. */    @Override    public IntegerDistribution makeDistribution() {        return new HypergeometricDistributionImpl(10,5, 5);    }    /** Creates the default probability density test input values */    @Override    public int[] makeDensityTestPoints() {        return new int[] {-1, 0, 1, 2, 3, 4, 5, 10};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0d, 0.003968d, 0.099206d, 0.396825d, 0.396825d,                0.099206d, 0.003968d, 0d};    }    /** Creates the default cumulative probability density test input values */    @Override    public int[] makeCumulativeTestPoints() {        return makeDensityTestPoints();    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0d, .003968d, .103175d, .50000d, .896825d, .996032d,                1.00000d, 1d};    }    /** Creates the default inverse cumulative probability test input values */    @Override    public double[] makeInverseCumulativeTestPoints() {        return new double[] {0d, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d, 1d};    }    /** Creates the default inverse cumulative probability density test expected values */    @Override    public int[] makeInverseCumulativeTestValues() {        return new int[] {-1, -1, 0, 0, 0, 0, 4, 3, 3, 3, 3, 5};    }    //-------------------- Additional test cases ------------------------------    /** Verify that if there are no failures, mass is concentrated on sampleSize */    @Test    public void testDegenerateNoFailures() throws Exception {        setDistribution(new HypergeometricDistributionImpl(5,5,3));        setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });        setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});        setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {2, 2});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }    /** Verify that if there are no successes, mass is concentrated on 0 */    @Test    public void testDegenerateNoSuccesses() throws Exception {        setDistribution(new HypergeometricDistributionImpl(5,0,3));        setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });        setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});        setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {-1, -1});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }    /** Verify that if sampleSize = populationSize, mass is concentrated on numberOfSuccesses */    @Test    public void testDegenerateFullSample() throws Exception {        setDistribution(new HypergeometricDistributionImpl(5,3,5));        setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });        setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});        setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {2, 2});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }    @Test    public void testPreconditions() {        try {            new HypergeometricDistributionImpl(0, 3, 5);            Assert.fail("negative population size. NotStrictlyPositiveException expected");        } catch(NotStrictlyPositiveException ex) {            // Expected.        }        try {            new HypergeometricDistributionImpl(5, -1, 5);            Assert.fail("negative number of successes. NotPositiveException expected");        } catch(NotPositiveException ex) {            // Expected.        }        try {            new HypergeometricDistributionImpl(5, 3, -1);            Assert.fail("negative sample size. NotPositiveException expected");        } catch(NotPositiveException ex) {            // Expected.        }        try {            new HypergeometricDistributionImpl(5, 6, 5);            Assert.fail("numberOfSuccesses > populationSize. NumberIsTooLargeException expected");        } catch(NumberIsTooLargeException ex) {            // Expected.        }        try {            new HypergeometricDistributionImpl(5, 3, 6);            Assert.fail("sampleSize > populationSize. NumberIsTooLargeException expected");        } catch(NumberIsTooLargeException ex) {            // Expected.        }    }    @Test    public void testAccessors() {        HypergeometricDistribution dist = new HypergeometricDistributionImpl(5, 3, 4);        Assert.assertEquals(5, dist.getPopulationSize());        Assert.assertEquals(3, dist.getNumberOfSuccesses());        Assert.assertEquals(4, dist.getSampleSize());    }    @Test    public void testLargeValues() {        int populationSize = 3456;        int sampleSize = 789;        int numberOfSucceses = 101;        double[][] data = {            {0.0, 2.75646034603961e-12, 2.75646034603961e-12, 1.0},            {1.0, 8.55705370142386e-11, 8.83269973602783e-11, 0.999999999997244},            {2.0, 1.31288129219665e-9, 1.40120828955693e-9, 0.999999999911673},            {3.0, 1.32724172984193e-8, 1.46736255879763e-8, 0.999999998598792},            {4.0, 9.94501711734089e-8, 1.14123796761385e-7, 0.999999985326375},            {5.0, 5.89080768883643e-7, 7.03204565645028e-7, 0.999999885876203},            {20.0, 0.0760051397707708, 0.27349758476299, 0.802507555007781},            {21.0, 0.087144222047629, 0.360641806810619, 0.72650241523701},            {22.0, 0.0940378846881819, 0.454679691498801, 0.639358193189381},            {23.0, 0.0956897500614809, 0.550369441560282, 0.545320308501199},            {24.0, 0.0919766921922999, 0.642346133752582, 0.449630558439718},            {25.0, 0.083641637261095, 0.725987771013677, 0.357653866247418},            {96.0, 5.93849188852098e-57, 1.0, 6.01900244560712e-57},            {97.0, 7.96593036832547e-59, 1.0, 8.05105570861321e-59},            {98.0, 8.44582921934367e-61, 1.0, 8.5125340287733e-61},            {99.0, 6.63604297068222e-63, 1.0, 6.670480942963e-63},            {100.0, 3.43501099007557e-65, 1.0, 3.4437972280786e-65},            {101.0, 8.78623800302957e-68, 1.0, 8.78623800302957e-68},        };        testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);    }    private void testHypergeometricDistributionProbabilities(int populationSize, int sampleSize, int numberOfSucceses, double[][] data) {        HypergeometricDistributionImpl dist = new HypergeometricDistributionImpl(populationSize, numberOfSucceses, sampleSize);        for (int i = 0; i < data.length; ++i) {            int x = (int)data[i][0];            double pdf = data[i][1];            double actualPdf = dist.probability(x);            TestUtils.assertRelativelyEquals("Expected equals for <"+x+"> pdf",pdf, actualPdf, 1.0e-9);            double cdf = data[i][2];            double actualCdf = dist.cumulativeProbability(x);            TestUtils.assertRelativelyEquals("Expected equals for <"+x+"> cdf",cdf, actualCdf, 1.0e-9);            double cdf1 = data[i][3];            double actualCdf1 = dist.upperCumulativeProbability(x);            TestUtils.assertRelativelyEquals("Expected equals for <"+x+"> cdf1",cdf1, actualCdf1, 1.0e-9);        }    }    @Test    public void testMoreLargeValues() {        int populationSize = 26896;        int sampleSize = 895;        int numberOfSucceses = 55;        double[][] data = {            {0.0, 0.155168304750504, 0.155168304750504, 1.0},            {1.0, 0.29437545000746, 0.449543754757964, 0.844831695249496},            {2.0, 0.273841321577003, 0.723385076334967, 0.550456245242036},            {3.0, 0.166488572570786, 0.889873648905753, 0.276614923665033},            {4.0, 0.0743969744713231, 0.964270623377076, 0.110126351094247},            {5.0, 0.0260542785784855, 0.990324901955562, 0.0357293766229237},            {20.0, 3.57101101678792e-16, 1.0, 3.78252101622096e-16},            {21.0, 2.00551638598312e-17, 1.0, 2.11509999433041e-17},            {22.0, 1.04317070180562e-18, 1.0, 1.09583608347287e-18},            {23.0, 5.03153504903308e-20, 1.0, 5.266538166725e-20},            {24.0, 2.2525984149695e-21, 1.0, 2.35003117691919e-21},            {25.0, 9.3677424515947e-23, 1.0, 9.74327619496943e-23},            {50.0, 9.83633962945521e-69, 1.0, 9.8677629437617e-69},            {51.0, 3.13448949497553e-71, 1.0, 3.14233143064882e-71},            {52.0, 7.82755221928122e-74, 1.0, 7.84193567329055e-74},            {53.0, 1.43662126065532e-76, 1.0, 1.43834540093295e-76},            {54.0, 1.72312692517348e-79, 1.0, 1.7241402776278e-79},            {55.0, 1.01335245432581e-82, 1.0, 1.01335245432581e-82},        };        testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);    }    @Test    public void testMomonts() {        final double tol = 1e-9;        HypergeometricDistribution dist;                dist = new HypergeometricDistributionImpl(1500, 40, 100);        Assert.assertEquals(dist.getNumericalMean(), 40d * 100d / 1500d, tol);        Assert.assertEquals(dist.getNumericalVariance(), ( 100d * 40d * (1500d - 100d) * (1500d - 40d) ) / ( (1500d * 1500d * 1499d) ), tol);                 dist = new HypergeometricDistributionImpl(3000, 55, 200);        Assert.assertEquals(dist.getNumericalMean(), 55d * 200d / 3000d, tol);        Assert.assertEquals(dist.getNumericalVariance(), ( 200d * 55d * (3000d - 200d) * (3000d - 55d) ) / ( (3000d * 3000d * 2999d) ), tol);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;/** * Abstract base class for {@link IntegerDistribution} tests. * <p> * To create a concrete test class for an integer distribution implementation, *  implement makeDistribution() to return a distribution instance to use in *  tests and each of the test data generation methods below.  In each case, the *  test points and test values arrays returned represent parallel arrays of *  inputs and expected values for the distribution returned by makeDistribution(). *  <p> *  makeDensityTestPoints() -- arguments used to test probability density calculation *  makeDensityTestValues() -- expected probability densities *  makeCumulativeTestPoints() -- arguments used to test cumulative probabilities *  makeCumulativeTestValues() -- expected cumulative probabilites *  makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf evaluation *  makeInverseCumulativeTestValues() -- expected inverse cdf values * <p> *  To implement additional test cases with different distribution instances and test data, *  use the setXxx methods for the instance data in test cases and call the verifyXxx methods *  to verify results. * * @version $Id$ */public abstract class IntegerDistributionAbstractTest {//-------------------- Private test instance data -------------------------    /** Discrete distribution instance used to perform tests */    private IntegerDistribution distribution;    /** Tolerance used in comparing expected and returned values */    private double tolerance = 1E-4;    /** Arguments used to test probability density calculations */    private int[] densityTestPoints;    /** Values used to test probability density calculations */    private double[] densityTestValues;    /** Arguments used to test cumulative probability density calculations */    private int[] cumulativeTestPoints;    /** Values used to test cumulative probability density calculations */    private double[] cumulativeTestValues;    /** Arguments used to test inverse cumulative probability density calculations */    private double[] inverseCumulativeTestPoints;    /** Values used to test inverse cumulative probability density calculations */    private int[] inverseCumulativeTestValues;    //-------------------- Abstract methods -----------------------------------    /** Creates the default discrete distribution instance to use in tests. */    public abstract IntegerDistribution makeDistribution();    /** Creates the default probability density test input values */    public abstract int[] makeDensityTestPoints();    /** Creates the default probability density test expected values */    public abstract double[] makeDensityTestValues();    /** Creates the default cumulative probability density test input values */    public abstract int[] makeCumulativeTestPoints();    /** Creates the default cumulative probability density test expected values */    public abstract double[] makeCumulativeTestValues();    /** Creates the default inverse cumulative probability test input values */    public abstract double[] makeInverseCumulativeTestPoints();    /** Creates the default inverse cumulative probability density test expected values */    public abstract int[] makeInverseCumulativeTestValues();    //-------------------- Setup / tear down ----------------------------------    /**     * Setup sets all test instance data to default values     */    @Before    public void setUp() {        distribution = makeDistribution();        densityTestPoints = makeDensityTestPoints();        densityTestValues = makeDensityTestValues();        cumulativeTestPoints = makeCumulativeTestPoints();        cumulativeTestValues = makeCumulativeTestValues();        inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();        inverseCumulativeTestValues = makeInverseCumulativeTestValues();    }    /**     * Cleans up test instance data     */    @After    public void tearDown() {        distribution = null;        densityTestPoints = null;        densityTestValues = null;        cumulativeTestPoints = null;        cumulativeTestValues = null;        inverseCumulativeTestPoints = null;        inverseCumulativeTestValues = null;    }    //-------------------- Verification methods -------------------------------    /**     * Verifies that probability density calculations match expected values     * using current test instance data     */    protected void verifyDensities() throws Exception {        for (int i = 0; i < densityTestPoints.length; i++) {            Assert.assertEquals("Incorrect density value returned for " + densityTestPoints[i],                    densityTestValues[i],                    distribution.probability(densityTestPoints[i]), tolerance);        }    }    /**     * Verifies that cumulative probability density calculations match expected values     * using current test instance data     */    protected void verifyCumulativeProbabilities() throws Exception {        for (int i = 0; i < cumulativeTestPoints.length; i++) {            Assert.assertEquals("Incorrect cumulative probability value returned for " + cumulativeTestPoints[i],                    cumulativeTestValues[i],                    distribution.cumulativeProbability(cumulativeTestPoints[i]), tolerance);        }    }    /**     * Verifies that inverse cumulative probability density calculations match expected values     * using current test instance data     */    protected void verifyInverseCumulativeProbabilities() throws Exception {        for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {            Assert.assertEquals("Incorrect inverse cumulative probability value returned for "                    + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i],                    distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]));        }    }    //------------------------ Default test cases -----------------------------    /**     * Verifies that probability density calculations match expected values     * using default test instance data     */    @Test    public void testDensities() throws Exception {        verifyDensities();    }    /**     * Verifies that cumulative probability density calculations match expected values     * using default test instance data     */    @Test    public void testCumulativeProbabilities() throws Exception {        verifyCumulativeProbabilities();    }    /**     * Verifies that floating point arguments are correctly handled by     * cumulativeProbablility(-,-)     * JIRA: MATH-184     */    @Test    public void testFloatingPointArguments() throws Exception {        for (int i = 0; i < cumulativeTestPoints.length; i++) {            double arg = cumulativeTestPoints[i];            Assert.assertEquals(                    "Incorrect cumulative probability value returned for " +                    cumulativeTestPoints[i],                    cumulativeTestValues[i],                    distribution.cumulativeProbability(arg), tolerance);            if (i < cumulativeTestPoints.length - 1) {                double arg2 = cumulativeTestPoints[i + 1];                Assert.assertEquals("Inconsistent probability for discrete range " +                        "[ " + arg + "," + arg2 + " ]",                   distribution.cumulativeProbability(                           cumulativeTestPoints[i],                           cumulativeTestPoints[i + 1]),                   distribution.cumulativeProbability(arg, arg2), tolerance);                arg = arg - FastMath.random();                arg2 = arg2 + FastMath.random();                Assert.assertEquals("Inconsistent probability for discrete range " +                        "[ " + arg + "," + arg2 + " ]",                   distribution.cumulativeProbability(                           cumulativeTestPoints[i],                           cumulativeTestPoints[i + 1]),                   distribution.cumulativeProbability(arg, arg2), tolerance);            }        }        int one = 1;        int ten = 10;        int two = 2;        double oned = one;        double twod = two;        double tend = ten;        Assert.assertEquals(distribution.cumulativeProbability(one, two),                distribution.cumulativeProbability(oned, twod), tolerance);        Assert.assertEquals(distribution.cumulativeProbability(one, two),                distribution.cumulativeProbability(oned - tolerance,                        twod + 0.9), tolerance);        Assert.assertEquals(distribution.cumulativeProbability(two, ten),                distribution.cumulativeProbability(twod, tend), tolerance);        Assert.assertEquals(distribution.cumulativeProbability(two, ten),                distribution.cumulativeProbability(twod - tolerance,                        tend + 0.9), tolerance);    }    /**     * Verifies that inverse cumulative probability density calculations match expected values     * using default test instance data     */    @Test    public void testInverseCumulativeProbabilities() throws Exception {        verifyInverseCumulativeProbabilities();    }    /**     * Verifies that illegal arguments are correctly handled     */    @Test    public void testIllegalArguments() throws Exception {        try {            distribution.cumulativeProbability(1, 0);            Assert.fail("Expecting MathIllegalArgumentException for bad cumulativeProbability interval");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            distribution.inverseCumulativeProbability(-1);            Assert.fail("Expecting MathIllegalArgumentException for p = -1");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            distribution.inverseCumulativeProbability(2);            Assert.fail("Expecting MathIllegalArgumentException for p = 2");        } catch (MathIllegalArgumentException ex) {            // expected        }    }        /**     * Test sampling     */    @Test    public void testSampling() throws Exception {        int[] densityPoints = makeDensityTestPoints();        double[] densityValues = makeDensityTestValues();        int sampleSize = 1000;        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);        AbstractIntegerDistribution distribution = (AbstractIntegerDistribution) makeDistribution();        double[] expectedCounts = new double[length];        long[] observedCounts = new long[length];        for (int i = 0; i < length; i++) {            expectedCounts[i] = sampleSize * densityValues[i];        }        distribution.reseedRandomGenerator(1000); // Use fixed seed        int[] sample = distribution.sample(sampleSize);        for (int i = 0; i < sampleSize; i++) {          for (int j = 0; j < length; j++) {              if (sample[i] == densityPoints[j]) {                  observedCounts[j]++;              }          }        }        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);    }    //------------------ Getters / Setters for test instance data -----------    /**     * @return Returns the cumulativeTestPoints.     */    protected int[] getCumulativeTestPoints() {        return cumulativeTestPoints;    }    /**     * @param cumulativeTestPoints The cumulativeTestPoints to set.     */    protected void setCumulativeTestPoints(int[] cumulativeTestPoints) {        this.cumulativeTestPoints = cumulativeTestPoints;    }    /**     * @return Returns the cumulativeTestValues.     */    protected double[] getCumulativeTestValues() {        return cumulativeTestValues;    }    /**     * @param cumulativeTestValues The cumulativeTestValues to set.     */    protected void setCumulativeTestValues(double[] cumulativeTestValues) {        this.cumulativeTestValues = cumulativeTestValues;    }    /**     * @return Returns the densityTestPoints.     */    protected int[] getDensityTestPoints() {        return densityTestPoints;    }    /**     * @param densityTestPoints The densityTestPoints to set.     */    protected void setDensityTestPoints(int[] densityTestPoints) {        this.densityTestPoints = densityTestPoints;    }    /**     * @return Returns the densityTestValues.     */    protected double[] getDensityTestValues() {        return densityTestValues;    }    /**     * @param densityTestValues The densityTestValues to set.     */    protected void setDensityTestValues(double[] densityTestValues) {        this.densityTestValues = densityTestValues;    }    /**     * @return Returns the distribution.     */    protected IntegerDistribution getDistribution() {        return distribution;    }    /**     * @param distribution The distribution to set.     */    protected void setDistribution(IntegerDistribution distribution) {        this.distribution = distribution;    }    /**     * @return Returns the inverseCumulativeTestPoints.     */    protected double[] getInverseCumulativeTestPoints() {        return inverseCumulativeTestPoints;    }    /**     * @param inverseCumulativeTestPoints The inverseCumulativeTestPoints to set.     */    protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) {        this.inverseCumulativeTestPoints = inverseCumulativeTestPoints;    }    /**     * @return Returns the inverseCumulativeTestValues.     */    protected int[] getInverseCumulativeTestValues() {        return inverseCumulativeTestValues;    }    /**     * @param inverseCumulativeTestValues The inverseCumulativeTestValues to set.     */    protected void setInverseCumulativeTestValues(int[] inverseCumulativeTestValues) {        this.inverseCumulativeTestValues = inverseCumulativeTestValues;    }    /**     * @return Returns the tolerance.     */    protected double getTolerance() {        return tolerance;    }    /**     * @param tolerance The tolerance to set.     */    protected void setTolerance(double tolerance) {        this.tolerance = tolerance;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.exception.NotStrictlyPositiveException;import org.junit.Assert;import org.junit.Test;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;/** * Test cases for TDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Id$ */public class TDistributionTest extends ContinuousDistributionAbstractTest {//-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public TDistribution makeDistribution() {        return new TDistributionImpl(5.0);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 2.9.2        return new double[] {-5.89342953136, -3.36492999891, -2.57058183564, -2.01504837333, -1.47588404882,                5.89342953136, 3.36492999891, 2.57058183564, 2.01504837333, 1.47588404882};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999,                0.990, 0.975, 0.950, 0.900};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0.000756494565517, 0.0109109752919, 0.0303377878006, 0.0637967988952, 0.128289492005,                0.000756494565517, 0.0109109752919, 0.0303377878006, 0.0637967988952, 0.128289492005};    }    // --------------------- Override tolerance  --------------    @Override    public void setUp() throws Exception {        super.setUp();        setTolerance(1E-9);    }    //---------------------------- Additional test cases -------------------------    /**     * @see <a href="http://issues.apache.org/bugzilla/show_bug.cgi?id=27243">     *      Bug report that prompted this unit test.</a>     */    @Test    public void testCumulativeProbabilityAgaintStackOverflow() throws Exception {        TDistributionImpl td = new TDistributionImpl(5.);        td.cumulativeProbability(.1);        td.cumulativeProbability(.01);    }    @Test    public void testSmallDf() throws Exception {        setDistribution(new TDistributionImpl(1d));        // quantiles computed using R version 2.9.2        setCumulativeTestPoints(new double[] {-318.308838986, -31.8205159538, -12.7062047362,                -6.31375151468, -3.07768353718, 318.308838986, 31.8205159538, 12.7062047362,                 6.31375151468, 3.07768353718});        setDensityTestValues(new double[] {3.14158231817e-06, 0.000314055924703, 0.00195946145194,                0.00778959736375, 0.0303958893917, 3.14158231817e-06, 0.000314055924703,                0.00195946145194, 0.00778959736375, 0.0303958893917});        setInverseCumulativeTestValues(getCumulativeTestPoints());        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();        verifyDensities();    }    @Test    public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0, 1});        setInverseCumulativeTestValues(                new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }    @Test    public void testDfAccessors() {        TDistribution dist = (TDistribution) getDistribution();        Assert.assertEquals(5d, dist.getDegreesOfFreedom(), Double.MIN_VALUE);    }    @Test    public void testPreconditions() {        try {            new TDistributionImpl(0);            Assert.fail("Expecting NotStrictlyPositiveException for df = 0");        } catch (NotStrictlyPositiveException ex) {            // expected        }    }        @Test    public void testMomonts() {        final double tol = 1e-9;        TDistribution dist;                dist = new TDistributionImpl(1);        Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));        Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));                dist = new TDistributionImpl(1.5);        Assert.assertEquals(dist.getNumericalMean(), 0, tol);        Assert.assertTrue(Double.isInfinite(dist.getNumericalVariance()));                dist = new TDistributionImpl(5);        Assert.assertEquals(dist.getNumericalMean(), 0, tol);        Assert.assertEquals(dist.getNumericalVariance(), 5d / (5d - 2d), tol);            }    /*     * Adding this test to benchmark against tables published by NIST     * http://itl.nist.gov/div898/handbook/eda/section3/eda3672.htm     * Have chosen tabulated results for degrees of freedom 2,10,30,100     * Have chosen problevels from 0.10 to 0.001     */    @Test    public void nistData() throws MathException{        double[] prob = new double[]{ 0.10,0.05,0.025,0.01,0.005,0.001};        double[] args2 = new double[]{1.886,2.920,4.303,6.965,9.925,22.327};        double[] args10 = new double[]{1.372,1.812,2.228,2.764,3.169,4.143};        double[] args30 = new double[]{1.310,1.697,2.042,2.457,2.750,3.385};        double[] args100= new double[]{1.290,1.660,1.984,2.364,2.626,3.174};        TestUtils.assertEquals(prob, makeNistResults(args2, 2), 1.0e-4);        TestUtils.assertEquals(prob, makeNistResults(args10, 10), 1.0e-4);        TestUtils.assertEquals(prob, makeNistResults(args30, 30), 1.0e-4);        TestUtils.assertEquals(prob, makeNistResults(args100, 100), 1.0e-4);        return;    }    private double[] makeNistResults(double[] args, int df) throws MathException{        TDistribution td =  new TDistributionImpl(df);        double[] res  = new double[ args.length ];        for( int i = 0 ; i < res.length ; i++){            res[i] = 1.0 - td.cumulativeProbability(args[i]);        }        return res;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.exception.NotStrictlyPositiveException;import org.junit.Assert;import org.junit.Test;/** * Test cases for CauchyDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Id$ */public class CauchyDistributionTest extends ContinuousDistributionAbstractTest  {    // --------------------- Override tolerance  --------------    protected double defaultTolerance = NormalDistributionImpl.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;    @Override    public void setUp() throws Exception {        super.setUp();        setTolerance(defaultTolerance);    }    //-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public CauchyDistribution makeDistribution() {        return new CauchyDistributionImpl(1.2, 2.1);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R 2.9.2        return new double[] {-667.24856187, -65.6230835029, -25.4830299460, -12.0588781808,                -5.26313542807, 669.64856187, 68.0230835029, 27.8830299460, 14.4588781808, 7.66313542807};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999,                0.990, 0.975, 0.950, 0.900};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {1.49599158008e-06, 0.000149550440335, 0.000933076881878, 0.00370933207799, 0.0144742330437,                1.49599158008e-06, 0.000149550440335, 0.000933076881878, 0.00370933207799, 0.0144742330437};    }    //---------------------------- Additional test cases -------------------------    @Test    public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0.0, 1.0});        setInverseCumulativeTestValues(                new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }    @Test    public void testMedian() {        CauchyDistribution distribution = (CauchyDistribution) getDistribution();        Assert.assertEquals(1.2, distribution.getMedian(), 0.0);    }    @Test    public void testScale() {        CauchyDistribution distribution = (CauchyDistribution) getDistribution();        Assert.assertEquals(2.1, distribution.getScale(), 0.0);    }    @Test    public void testPreconditions() {        try {            new CauchyDistributionImpl(0, 0);            Assert.fail("Cannot have zero scale");        } catch (NotStrictlyPositiveException ex) {            // Expected.        }        try {            new CauchyDistributionImpl(0, -1);            Assert.fail("Cannot have negative scale");        } catch (NotStrictlyPositiveException ex) {            // Expected.        }    }    @Test    public void testMomonts() {        CauchyDistribution dist;                dist = new CauchyDistributionImpl(10.2, 0.15);                Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));        Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));                dist = new CauchyDistributionImpl(23.12, 2.12);        Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));        Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.exception.NotStrictlyPositiveException;import org.junit.Assert;import org.junit.Test;/** * Test cases for FDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Id$ */public class FDistributionTest extends ContinuousDistributionAbstractTest {    //-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public FDistribution makeDistribution() {        return new FDistributionImpl(5.0, 6.0);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 2.9.2        return new double[] {0.0346808448626, 0.0937009113303, 0.143313661184, 0.202008445998, 0.293728320107,                20.8026639595, 8.74589525602, 5.98756512605, 4.38737418741, 3.10751166664};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0.0689156576706, 0.236735653193, 0.364074131941, 0.481570789649, 0.595880479994,                0.000133443915657, 0.00286681303403, 0.00969192007502, 0.0242883861471, 0.0605491314658};    }    // --------------------- Override tolerance  --------------    @Override    public void setUp() throws Exception {        super.setUp();        setTolerance(1e-9);    }    //---------------------------- Additional test cases -------------------------    @Test    public void testCumulativeProbabilityExtremes() throws Exception {        setCumulativeTestPoints(new double[] {-2, 0});        setCumulativeTestValues(new double[] {0, 0});        verifyCumulativeProbabilities();    }    @Test    public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0, 1});        setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }    @Test    public void testDfAccessors() {        FDistribution dist = (FDistribution) getDistribution();        Assert.assertEquals(5d, dist.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);        Assert.assertEquals(6d, dist.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);    }    @Test    public void testPreconditions() {        try {            new FDistributionImpl(0, 1);            Assert.fail("Expecting NotStrictlyPositiveException for df = 0");        } catch (NotStrictlyPositiveException ex) {            // Expected.        }        try {            new FDistributionImpl(1, 0);            Assert.fail("Expecting NotStrictlyPositiveException for df = 0");        } catch (NotStrictlyPositiveException ex) {            // Expected.        }    }    @Test    public void testLargeDegreesOfFreedom() throws Exception {        FDistributionImpl fd = new FDistributionImpl(100000, 100000);        double p = fd.cumulativeProbability(.999);        double x = fd.inverseCumulativeProbability(p);        Assert.assertEquals(.999, x, 1.0e-5);    }    @Test    public void testSmallDegreesOfFreedom() throws Exception {        FDistributionImpl fd = new FDistributionImpl(1, 1);        double p = fd.cumulativeProbability(0.975);        double x = fd.inverseCumulativeProbability(p);        Assert.assertEquals(0.975, x, 1.0e-5);        fd = new FDistributionImpl(1, 2);        p = fd.cumulativeProbability(0.975);        x = fd.inverseCumulativeProbability(p);        Assert.assertEquals(0.975, x, 1.0e-5);    }    @Test    public void testMomonts() {        final double tol = 1e-9;        FDistribution dist;                dist = new FDistributionImpl(1, 2);        Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));        Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));                dist = new FDistributionImpl(1, 3);        Assert.assertEquals(dist.getNumericalMean(), 3d / (3d - 2d), tol);        Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));                dist = new FDistributionImpl(1, 5);        Assert.assertEquals(dist.getNumericalMean(), 5d / (5d - 2d), tol);        Assert.assertEquals(dist.getNumericalVariance(), (2d * 5d * 5d * 4d) / 9d, tol);            }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.exception.NotStrictlyPositiveException;import org.junit.Assert;import org.junit.Test;/** * Test cases for GammaDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Id$ */public class GammaDistributionTest extends ContinuousDistributionAbstractTest {    //-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public GammaDistribution makeDistribution() {        return new GammaDistributionImpl(4d, 2d);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 2.9.2        return new double[] {0.857104827257, 1.64649737269, 2.17973074725, 2.7326367935, 3.48953912565,                26.1244815584, 20.0902350297, 17.5345461395, 15.5073130559, 13.3615661365};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0.00427280075546, 0.0204117166709, 0.0362756163658, 0.0542113174239, 0.0773195272491,                0.000394468852816, 0.00366559696761, 0.00874649473311, 0.0166712508128, 0.0311798227954};    }    // --------------------- Override tolerance  --------------    @Override    public void setUp() throws Exception {        super.setUp();        setTolerance(1e-9);    }    //---------------------------- Additional test cases -------------------------    @Test    public void testParameterAccessors() {        GammaDistribution distribution = (GammaDistribution) getDistribution();        Assert.assertEquals(4d, distribution.getAlpha(), 0);        Assert.assertEquals(2d, distribution.getBeta(), 0);    }    @Test    public void testPreconditions() {        try {            new GammaDistributionImpl(0, 1);            Assert.fail("Expecting NotStrictlyPositiveException for alpha = 0");        } catch (NotStrictlyPositiveException ex) {            // Expected.        }        try {            new GammaDistributionImpl(1, 0);            Assert.fail("Expecting NotStrictlyPositiveException for alpha = 0");        } catch (NotStrictlyPositiveException ex) {            // Expected.        }    }    @Test    public void testProbabilities() throws Exception {        testProbability(-1.000, 4.0, 2.0, .0000);        testProbability(15.501, 4.0, 2.0, .9499);        testProbability(0.504, 4.0, 1.0, .0018);        testProbability(10.011, 1.0, 2.0, .9933);        testProbability(5.000, 2.0, 2.0, .7127);    }    @Test    public void testValues() throws Exception {        testValue(15.501, 4.0, 2.0, .9499);        testValue(0.504, 4.0, 1.0, .0018);        testValue(10.011, 1.0, 2.0, .9933);        testValue(5.000, 2.0, 2.0, .7127);    }    private void testProbability(double x, double a, double b, double expected) throws Exception {        GammaDistribution distribution = new GammaDistributionImpl( a, b );        double actual = distribution.cumulativeProbability(x);        Assert.assertEquals("probability for " + x, expected, actual, 10e-4);    }    private void testValue(double expected, double a, double b, double p) throws Exception {        GammaDistribution distribution = new GammaDistributionImpl( a, b );        double actual = distribution.inverseCumulativeProbability(p);        Assert.assertEquals("critical value for " + p, expected, actual, 10e-4);    }    @Test    public void testDensity() {        double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};        // R2.5: print(dgamma(x, shape=1, rate=1), digits=10)        checkDensity(1, 1, x, new double[]{0.000000000000, 0.999999000001, 0.606530659713, 0.367879441171, 0.135335283237, 0.006737946999});        // R2.5: print(dgamma(x, shape=2, rate=1), digits=10)        checkDensity(2, 1, x, new double[]{0.000000000000, 0.000000999999, 0.303265329856, 0.367879441171, 0.270670566473, 0.033689734995});        // R2.5: print(dgamma(x, shape=4, rate=1), digits=10)        checkDensity(4, 1, x, new double[]{0.000000000e+00, 1.666665000e-19, 1.263605541e-02, 6.131324020e-02, 1.804470443e-01, 1.403738958e-01});        // R2.5: print(dgamma(x, shape=4, rate=10), digits=10)        checkDensity(4, 10, x, new double[]{0.000000000e+00, 1.666650000e-15, 1.403738958e+00, 7.566654960e-02, 2.748204830e-05, 4.018228850e-17});        // R2.5: print(dgamma(x, shape=.1, rate=10), digits=10)        checkDensity(0.1, 10, x, new double[]{0.000000000e+00, 3.323953832e+04, 1.663849010e-03, 6.007786726e-06, 1.461647647e-10, 5.996008322e-24});        // R2.5: print(dgamma(x, shape=.1, rate=20), digits=10)        checkDensity(0.1, 20, x, new double[]{0.000000000e+00, 3.562489883e+04, 1.201557345e-05, 2.923295295e-10, 3.228910843e-19, 1.239484589e-45});        // R2.5: print(dgamma(x, shape=.1, rate=4), digits=10)        checkDensity(0.1, 4, x, new double[]{0.000000000e+00, 3.032938388e+04, 3.049322494e-02, 2.211502311e-03, 2.170613371e-05, 5.846590589e-11});        // R2.5: print(dgamma(x, shape=.1, rate=1), digits=10)        checkDensity(0.1, 1, x, new double[]{0.000000000e+00, 2.640334143e+04, 1.189704437e-01, 3.866916944e-02, 7.623306235e-03, 1.663849010e-04});    }    private void checkDensity(double alpha, double rate, double[] x, double[] expected) {        GammaDistribution d = new GammaDistributionImpl(alpha, 1 / rate);        for (int i = 0; i < x.length; i++) {            Assert.assertEquals(expected[i], d.density(x[i]), 1e-5);        }    }    @Test    public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0, 1});        setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }    @Test    public void testMomonts() {        final double tol = 1e-9;        GammaDistribution dist;                dist = new GammaDistributionImpl(1, 2);        Assert.assertEquals(dist.getNumericalMean(), 2, tol);        Assert.assertEquals(dist.getNumericalVariance(), 4, tol);                 dist = new GammaDistributionImpl(1.1, 4.2);        Assert.assertEquals(dist.getNumericalMean(), 1.1d * 4.2d, tol);        Assert.assertEquals(dist.getNumericalVariance(), 1.1d * 4.2d * 4.2d, tol);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.MathException;import org.junit.Assert;import org.junit.Test;/** * Test cases for AbstractIntegerDistribution default implementations. * * @version $Id$ */public class AbtractIntegerDistributionTest {    protected final DiceDistribution diceDistribution = new DiceDistribution();    protected final double p = diceDistribution.probability(1);        @Test    public void testCumulativeProbabilitiesSingleIntegerArguments() throws Exception {        int lower = 1;        for (int i = 1; i < 7; i++) {            Assert.assertEquals(p * i,                    diceDistribution.cumulativeProbability(lower), Double.MIN_VALUE);            lower++;        }        Assert.assertEquals(0,                diceDistribution.cumulativeProbability(-1), Double.MIN_VALUE);        Assert.assertEquals(1,                diceDistribution.cumulativeProbability(7), Double.MIN_VALUE);    }        @Test    public void testCumulativeProbabilitiesSingleDoubleArguments() throws Exception {        int lower = 1;        double arg = 0;        for (int i = 1; i < 7; i++) {            // Exact integer            arg = lower;            Assert.assertEquals(p * i,                    diceDistribution.cumulativeProbability(arg), Double.MIN_VALUE);                        // Add a fraction            arg = lower + Math.random();            Assert.assertEquals(p * i,                    diceDistribution.cumulativeProbability(arg), Double.MIN_VALUE);            lower++;        }    }        @Test    public void testCumulativeProbabilitiesRangeIntegerArguments() throws Exception {        int lower = 1;        int upper = 6;        for (int i = 0; i < 2; i++) {            // cum(1,6) = p(1 <= X <= 6) = 1, cum(2,5) = 4/6, cum(3,4) = 2/6             Assert.assertEquals(1 - p * 2 * i,                     diceDistribution.cumulativeProbability(lower, upper), 1E-12);            lower++;            upper--;        }        for (int i = 1; i < 7; i++) {            Assert.assertEquals(p, diceDistribution.cumulativeProbability(i, i), 1E-12);        }    }        @Test    public void testCumulativeProbabilitiesRangeDoubleArguments() throws Exception {        int lower = 1;        int upper = 6;        double dlower = lower;        double dupper = upper;        for (int i = 0; i < 2; i++) {            // cum(1,6) = p(1 <= X <= 6) = 1, cum(2,5) = 4/6, cum(3,4) = 2/6             // Exact integers            Assert.assertEquals(1 - p * 2 * i,                     diceDistribution.cumulativeProbability(dlower, dupper), 1E-12);            // Subtract a fraction from lower, add to upper.  Should be no change.            dlower -= Math.random();            dupper += Math.random();            Assert.assertEquals(1 - p * 2 * i,                     diceDistribution.cumulativeProbability(dlower, dupper), 1E-12);            lower++;            upper--;            dlower = lower;            dupper = upper;        }        for (int i = 1; i < 7; i++) {            lower = i;            Assert.assertEquals(p, diceDistribution.cumulativeProbability(                    lower, lower), 1E-12);            Assert.assertEquals(p, diceDistribution.cumulativeProbability(                    lower, lower + Math.random()), 1E-12);            Assert.assertEquals(p, diceDistribution.cumulativeProbability(                    lower - Math.random(), lower), 1E-12);            Assert.assertEquals(p, diceDistribution.cumulativeProbability(                    lower - Math.random(), lower + Math.random()), 1E-12);        }    }    /**     * Simple distribution modeling a 6-sided die     */    class DiceDistribution extends AbstractIntegerDistribution {        public static final long serialVersionUID = 23734213;        private final double p = 1d/6d;        public double probability(int x) {            if (x < 1 || x > 6) {                return 0;            } else {                return p;            }        }        @Override        public double cumulativeProbability(int x) throws MathException {            if (x < 1) {                return 0;            } else if (x >= 6) {                return 1;            } else {                return p * x;            }        }        @Override        protected int getDomainLowerBound(double p) {            return 1;        }        @Override        protected int getDomainUpperBound(double p) {            return 6;        }        @Override        public int getSupportLowerBound() {            return 1;        }        @Override        public int getSupportUpperBound() {            return 6;        }        @Override        protected double calculateNumericalMean() {            return 3.5;        }        @Override        protected double calculateNumericalVariance() {            return 12.5 - 3.5 * 3.5;  // E(X^2) - E(X)^2        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.MathException;import org.junit.Assert;import org.junit.Test;public class BetaDistributionTest {    @Test    public void testCumulative() throws MathException {        double[] x = new double[]{-0.1, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1};        // all test data computed using R 2.5        checkCumulative(0.1, 0.1,                x, new double[]{                0.0000000000, 0.0000000000, 0.4063850939, 0.4397091902, 0.4628041861,                0.4821200456, 0.5000000000, 0.5178799544, 0.5371958139, 0.5602908098,                0.5936149061, 1.0000000000, 1.0000000000});        checkCumulative(0.1, 0.5,                x, new double[]{                0.0000000000, 0.0000000000, 0.7048336221, 0.7593042194, 0.7951765304,                0.8234948385, 0.8480017124, 0.8706034370, 0.8926585878, 0.9156406404,                0.9423662883, 1.0000000000, 1.0000000000});        checkCumulative(0.1, 1.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.7943282347, 0.8513399225, 0.8865681506,                0.9124435366, 0.9330329915, 0.9502002165, 0.9649610951, 0.9779327685,                0.9895192582, 1.0000000000, 1.0000000000});        checkCumulative(0.1, 2.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.8658177758, 0.9194471163, 0.9486279211,                0.9671901487, 0.9796846411, 0.9882082252, 0.9939099280, 0.9974914239,                0.9994144508, 1.0000000000, 1.0000000000});        checkCumulative(0.1, 4.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.9234991121, 0.9661958941, 0.9842285085,                0.9928444112, 0.9970040660, 0.9989112804, 0.9996895625, 0.9999440793,                0.9999967829, 1.0000000000, 1.0000000000});        checkCumulative(0.5, 0.1,                x, new double[]{                0.00000000000, 0.00000000000, 0.05763371168, 0.08435935962,                0.10734141216, 0.12939656302, 0.15199828760, 0.17650516146,                0.20482346963, 0.24069578055, 0.29516637795, 1.00000000000, 1.00000000000});        checkCumulative(0.5, 0.5,                x, new double[]{                0.0000000000, 0.0000000000, 0.2048327647, 0.2951672353, 0.3690101196,                0.4359057832, 0.5000000000, 0.5640942168, 0.6309898804, 0.7048327647,                0.7951672353, 1.0000000000, 1.0000000000});        checkCumulative(0.5, 1.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.3162277660, 0.4472135955, 0.5477225575,                0.6324555320, 0.7071067812, 0.7745966692, 0.8366600265, 0.8944271910,                0.9486832981, 1.0000000000, 1.0000000000});        checkCumulative(0.5, 2.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.4585302607, 0.6260990337, 0.7394254526,                0.8221921916, 0.8838834765, 0.9295160031, 0.9621590305, 0.9838699101,                0.9961174630, 1.0000000000, 1.0000000000});        checkCumulative(0.5, 4.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.6266250826, 0.8049844719, 0.8987784842,                0.9502644369, 0.9777960959, 0.9914837366, 0.9974556254, 0.9995223859,                0.9999714889, 1.0000000000, 1.0000000000});        checkCumulative(1.0, 0.1,                x, new double[]{                0.00000000000, 0.00000000000, 0.01048074179, 0.02206723146,                0.03503890488, 0.04979978349, 0.06696700846, 0.08755646344,                0.11343184943, 0.14866007748, 0.20567176528, 1.00000000000, 1.00000000000});        checkCumulative(1.0, 0.5,                x, new double[]{                0.00000000000, 0.00000000000, 0.05131670195, 0.10557280900,                0.16333997347, 0.22540333076, 0.29289321881, 0.36754446797,                0.45227744249, 0.55278640450, 0.68377223398, 1.00000000000, 1.00000000000});        checkCumulative(1, 1,                x, new double[]{                0.0, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0});        checkCumulative(1, 2,                x, new double[]{                0.00, 0.00, 0.19, 0.36, 0.51, 0.64, 0.75, 0.84, 0.91, 0.96, 0.99, 1.00, 1.00});        checkCumulative(1, 4,                x, new double[]{                0.0000, 0.0000, 0.3439, 0.5904, 0.7599, 0.8704, 0.9375, 0.9744, 0.9919,                0.9984, 0.9999, 1.0000, 1.0000});        checkCumulative(2.0, 0.1,                x, new double[]{                0.0000000000000, 0.0000000000000, 0.0005855492117, 0.0025085760862,                0.0060900720266, 0.0117917748341, 0.0203153588864, 0.0328098512512,                0.0513720788952, 0.0805528836776, 0.1341822241505, 1.0000000000000, 1.0000000000000});        checkCumulative(2, 1,                x, new double[]{                0.00, 0.00, 0.01, 0.04, 0.09, 0.16, 0.25, 0.36, 0.49, 0.64, 0.81, 1.00, 1.00});        checkCumulative(2.0, 0.5,                x, new double[]{                0.000000000000, 0.000000000000, 0.003882537047, 0.016130089900,                0.037840969486, 0.070483996910, 0.116116523517, 0.177807808356,                0.260574547368, 0.373900966300, 0.541469739276, 1.000000000000, 1.000000000000});        checkCumulative(2, 2,                x, new double[]{                0.000, 0.000, 0.028, 0.104, 0.216, 0.352, 0.500, 0.648, 0.784, 0.896, 0.972, 1.000, 1.000});        checkCumulative(2, 4,                x, new double[]{                0.00000, 0.00000, 0.08146, 0.26272, 0.47178, 0.66304, 0.81250, 0.91296,                0.96922, 0.99328, 0.99954, 1.00000, 1.00000});        checkCumulative(4.0, 0.1,                x, new double[]{                0.000000000e+00, 0.000000000e+00, 3.217128269e-06, 5.592070271e-05,                3.104375474e-04, 1.088719595e-03, 2.995933981e-03, 7.155588777e-03,                1.577149153e-02, 3.380410585e-02, 7.650088789e-02, 1.000000000e+00, 1.000000000e+00});        checkCumulative(4.0, 0.5,                x, new double[]{                0.000000000e+00, 0.000000000e+00, 2.851114863e-05, 4.776140576e-04,                2.544374616e-03, 8.516263371e-03, 2.220390414e-02, 4.973556312e-02,                1.012215158e-01, 1.950155281e-01, 3.733749174e-01, 1.000000000e+00, 1.000000000e+00});        checkCumulative(4, 1,                x, new double[]{                0.0000, 0.0000, 0.0001, 0.0016, 0.0081, 0.0256, 0.0625, 0.1296, 0.2401,                0.4096, 0.6561, 1.0000, 1.0000});        checkCumulative(4, 2,                x, new double[]{                0.00000, 0.00000, 0.00046, 0.00672, 0.03078, 0.08704, 0.18750, 0.33696,                0.52822, 0.73728, 0.91854, 1.00000, 1.00000});        checkCumulative(4, 4,                x, new double[]{                0.000000, 0.000000, 0.002728, 0.033344, 0.126036, 0.289792, 0.500000,                0.710208, 0.873964, 0.966656, 0.997272, 1.000000, 1.000000});    }    private void checkCumulative(double alpha, double beta, double[] x, double[] cumes) throws MathException {        BetaDistribution d = new BetaDistributionImpl(alpha, beta);        for (int i = 0; i < x.length; i++) {            Assert.assertEquals(cumes[i], d.cumulativeProbability(x[i]), 1e-8);        }        for (int i = 1; i < x.length - 1; i++) {            Assert.assertEquals(x[i], d.inverseCumulativeProbability(cumes[i]), 1e-5);        }    }    @Test    public void testDensity() {        double[] x = new double[]{1e-6, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9};        checkDensity(0.1, 0.1,                x, new double[]{                12741.2357380649, 0.4429889586665234, 2.639378715e-01, 2.066393611e-01,                1.832401831e-01, 1.766302780e-01, 1.832404579e-01, 2.066400696e-01,                2.639396531e-01, 4.429925026e-01});        checkDensity(0.1, 0.5,                x, new double[]{                2.218377102e+04, 7.394524202e-01, 4.203020268e-01, 3.119435533e-01,                2.600787829e-01, 2.330648626e-01, 2.211408259e-01, 2.222728708e-01,                2.414013907e-01, 3.070567405e-01});        checkDensity(0.1, 1.0,                x, new double[]{                2.511886432e+04, 7.943210858e-01, 4.256680458e-01, 2.955218303e-01,                2.281103709e-01, 1.866062624e-01, 1.583664652e-01, 1.378514078e-01,                1.222414585e-01, 1.099464743e-01});        checkDensity(0.1, 2.0,                x, new double[]{                2.763072312e+04, 7.863770012e-01, 3.745874120e-01, 2.275514842e-01,                1.505525939e-01, 1.026332391e-01, 6.968107049e-02, 4.549081293e-02,                2.689298641e-02, 1.209399123e-02});        checkDensity(0.1, 4.0,                x, new double[]{                2.997927462e+04, 6.911058917e-01, 2.601128486e-01, 1.209774010e-01,                5.880564714e-02, 2.783915474e-02, 1.209657335e-02, 4.442148268e-03,                1.167143939e-03, 1.312171805e-04});        checkDensity(0.5, 0.1,                x, new double[]{                88.3152184726, 0.3070542841, 0.2414007269, 0.2222727015,                0.2211409364, 0.2330652355, 0.2600795198, 0.3119449793,                0.4203052841, 0.7394649088});        checkDensity(0.5, 0.5,                x, new double[]{                318.3100453389, 1.0610282383, 0.7957732234, 0.6946084565,                0.6497470636, 0.6366197724, 0.6497476051, 0.6946097796,                0.7957762075, 1.0610376697});        checkDensity(0.5, 1.0,                x, new double[]{                500.0000000000, 1.5811309244, 1.1180311937, 0.9128694077,                0.7905684268, 0.7071060741, 0.6454966865, 0.5976138778,                0.5590166450, 0.5270459839});        checkDensity(0.5, 2.0,                x, new double[]{                749.99925000000, 2.134537420613655, 1.34163575536, 0.95851150881,                0.71151039830, 0.53032849490, 0.38729704363, 0.26892534859,                0.16770415497, 0.07905610701});        checkDensity(0.5, 4.0,                x, new double[]{                1.093746719e+03, 2.52142232809988, 1.252190241e+00, 6.849343920e-01,                3.735417140e-01, 1.933481570e-01, 9.036885833e-02, 3.529621669e-02,                9.782644546e-03, 1.152878503e-03});        checkDensity(1.0, 0.1,                x, new double[]{                0.1000000900, 0.1099466942, 0.1222417336, 0.1378517623, 0.1583669403,                0.1866069342, 0.2281113974, 0.2955236034, 0.4256718768,                0.7943353837});        checkDensity(1.0, 0.5,                x, new double[]{                0.5000002500, 0.5270465695, 0.5590173438, 0.5976147315, 0.6454977623,                0.7071074883, 0.7905704033, 0.9128724506,                1.1180367838, 1.5811467358});        checkDensity(1, 1,                x, new double[]{                1, 1, 1,                1, 1, 1, 1,                1, 1, 1});        checkDensity(1, 2,                x, new double[]{                1.999998, 1.799998, 1.599998, 1.399998, 1.199998, 0.999998, 0.799998,                0.599998, 0.399998,                0.199998});        checkDensity(1, 4,                x, new double[]{                3.999988000012, 2.915990280011, 2.047992320010, 1.371994120008,                0.863995680007, 0.499997000006, 0.255998080005, 0.107998920004,                0.031999520002, 0.003999880001});        checkDensity(2.0, 0.1,                x, new double[]{                1.100000990e-07, 1.209425730e-02, 2.689331586e-02, 4.549123318e-02,                6.968162794e-02, 1.026340191e-01, 1.505537732e-01, 2.275534997e-01,                3.745917198e-01, 7.863929037e-01});        checkDensity(2.0, 0.5,                x, new double[]{                7.500003750e-07, 7.905777599e-02, 1.677060417e-01, 2.689275256e-01,                3.872996256e-01, 5.303316769e-01, 7.115145488e-01, 9.585174425e-01,                1.341645818e+00, 2.134537420613655});        checkDensity(2, 1,                x, new double[]{                0.000002, 0.200002, 0.400002, 0.600002, 0.800002, 1.000002, 1.200002,                1.400002, 1.600002,                1.800002});        checkDensity(2, 2,                x, new double[]{                5.9999940e-06, 5.4000480e-01, 9.6000360e-01, 1.2600024e+00,                1.4400012e+00, 1.5000000e+00, 1.4399988e+00, 1.2599976e+00,                9.5999640e-01, 5.3999520e-01});        checkDensity(2, 4,                x, new double[]{                0.00001999994, 1.45800971996, 2.04800255997, 2.05799803998,                1.72799567999, 1.24999500000, 0.76799552000, 0.37799676001,                0.12799824001, 0.01799948000});        checkDensity(4.0, 0.1,                x, new double[]{                1.193501074e-19, 1.312253162e-04, 1.167181580e-03, 4.442248535e-03,                1.209679109e-02, 2.783958903e-02, 5.880649983e-02, 1.209791638e-01,                2.601171405e-01, 6.911229392e-01});        checkDensity(4.0, 0.5,                x, new double[]{                1.093750547e-18, 1.152948959e-03, 9.782950259e-03, 3.529697305e-02,                9.037036449e-02, 1.933508639e-01, 3.735463833e-01, 6.849425461e-01,                1.252205894e+00, 2.52142232809988});        checkDensity(4, 1,                x, new double[]{                4.000000000e-18, 4.000120001e-03, 3.200048000e-02, 1.080010800e-01,                2.560019200e-01, 5.000030000e-01, 8.640043200e-01, 1.372005880e+00,                2.048007680e+00, 2.916009720e+00});        checkDensity(4, 2,                x, new double[]{                1.999998000e-17, 1.800052000e-02, 1.280017600e-01, 3.780032400e-01,                7.680044800e-01, 1.250005000e+00, 1.728004320e+00, 2.058001960e+00,                2.047997440e+00, 1.457990280e+00});        checkDensity(4, 4,                x, new double[]{                1.399995800e-16, 1.020627216e-01, 5.734464512e-01, 1.296547409e+00,                1.935364838e+00, 2.187500000e+00, 1.935355162e+00, 1.296532591e+00,                5.734335488e-01, 1.020572784e-01});    }    private void checkDensity(double alpha, double beta, double[] x, double[] expected) {        BetaDistribution d = new BetaDistributionImpl(alpha, beta);        for (int i = 0; i < x.length; i++) {            Assert.assertEquals(String.format("density at x=%.1f for alpha=%.1f, beta=%.1f", x[i], alpha, beta), expected[i], d.density(x[i]), 1e-5);        }    }    @Test    public void testMomonts() {        final double tol = 1e-9;        BetaDistribution dist;                dist = new BetaDistributionImpl(1, 1);        Assert.assertEquals(dist.getNumericalMean(), 0.5, tol);        Assert.assertEquals(dist.getNumericalVariance(), 1.0 / 12.0, tol);                 dist = new BetaDistributionImpl(2, 5);        Assert.assertEquals(dist.getNumericalMean(), 2.0 / 7.0, tol);        Assert.assertEquals(dist.getNumericalVariance(), 10.0 / (49.0 * 8.0), tol);     }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.exception.NotStrictlyPositiveException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test cases for {@link ZipfDistribution}. * Extends IntegerDistributionAbstractTest.  See class javadoc for * IntegerDistributionAbstractTest for details. * * @version $Id$ */public class ZipfDistributionTest extends IntegerDistributionAbstractTest {    @Test    public void testPreconditions() {        try {            new ZipfDistributionImpl(0, 1);            Assert.fail("NotStrictlyPositiveException expected");        } catch (NotStrictlyPositiveException e) {            // Expected.        }        try {            new ZipfDistributionImpl(1, 0);            Assert.fail("NotStrictlyPositiveException expected");        } catch (NotStrictlyPositiveException e) {            // Expected.        }    }    //-------------- Implementations for abstract methods -----------------------    /** Creates the default discrete distribution instance to use in tests. */    @Override    public IntegerDistribution makeDistribution() {        return new ZipfDistributionImpl(10, 1);    }    /** Creates the default probability density test input values */    @Override    public int[] makeDensityTestPoints() {        return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0d, 0d, 0.3414d, 0.1707d, 0.1138d, 0.0854d, 0.0683d,                0.0569d, 0.0488d, 0.0427d, 0.0379d, 0.0341d, 0d};    }    /** Creates the default cumulative probability density test input values */    @Override    public int[] makeCumulativeTestPoints() {        return makeDensityTestPoints();    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0d, 0.0000d, 0.3414d, 0.5121d, 0.6259d, 0.7113d,                0.7796d, 0.8365d, 0.8852d, 0.9279d, 0.9659d, 1d, 1d};        }    /** Creates the default inverse cumulative probability test input values */    @Override    public double[] makeInverseCumulativeTestPoints() {        return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.3414d, 0.3415d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d, 1};        }    /** Creates the default inverse cumulative probability density test expected values */    @Override    public int[] makeInverseCumulativeTestValues() {        return new int[] {0, 0, 0, 0, 0, 0, 1, 9, 9, 9, 8, 7, 10};    }    @Test    public void testMomonts() {        final double tol = 1e-9;        ZipfDistribution dist;                dist = new ZipfDistributionImpl(2, 0.5);        Assert.assertEquals(dist.getNumericalMean(), FastMath.sqrt(2), tol);        Assert.assertEquals(dist.getNumericalVariance(), 0.24264068711928521, tol);     }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.MathException;import org.apache.commons.math.exception.NotStrictlyPositiveException;import org.junit.Assert;import org.junit.Test;/** * Test cases for NormalDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Id$ */public class NormalDistributionTest extends ContinuousDistributionAbstractTest  {    //-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public NormalDistribution makeDistribution() {        return new NormalDistributionImpl(2.1, 1.4);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R        return new double[] {-2.226325228634938d, -1.156887023657177d, -0.643949578356075d, -0.2027950777320613d, 0.305827808237559d,                6.42632522863494d, 5.35688702365718d, 4.843949578356074d, 4.40279507773206d, 3.89417219176244d};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0.00240506434076, 0.0190372444310, 0.0417464784322, 0.0736683145538, 0.125355951380,                0.00240506434076, 0.0190372444310, 0.0417464784322, 0.0736683145538, 0.125355951380};    }    // --------------------- Override tolerance  --------------    protected double defaultTolerance = NormalDistributionImpl.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;    @Override    public void setUp() throws Exception {        super.setUp();        setTolerance(defaultTolerance);    }    //---------------------------- Additional test cases -------------------------    private void verifyQuantiles() throws Exception {        NormalDistribution distribution = (NormalDistribution) getDistribution();        double mu = distribution.getMean();        double sigma = distribution.getStandardDeviation();        setCumulativeTestPoints( new double[] {mu - 2 *sigma, mu - sigma,                mu, mu + sigma, mu + 2 * sigma,  mu + 3 * sigma, mu + 4 * sigma,                mu + 5 * sigma});        // Quantiles computed using R (same as Mathematica)        setCumulativeTestValues(new double[] {0.02275013194817921, 0.158655253931457, 0.5, 0.841344746068543,                0.977249868051821, 0.99865010196837, 0.999968328758167,  0.999999713348428});        verifyCumulativeProbabilities();    }    @Test    public void testQuantiles() throws Exception {        setDensityTestValues(new double[] {0.0385649760808, 0.172836231799, 0.284958771715, 0.172836231799, 0.0385649760808,                0.00316560600853, 9.55930184035e-05, 1.06194251052e-06});        verifyQuantiles();        verifyDensities();        setDistribution(new NormalDistributionImpl(0, 1));        setDensityTestValues(new double[] {0.0539909665132, 0.241970724519, 0.398942280401, 0.241970724519, 0.0539909665132,                0.00443184841194, 0.000133830225765, 1.48671951473e-06});        verifyQuantiles();        verifyDensities();        setDistribution(new NormalDistributionImpl(0, 0.1));        setDensityTestValues(new double[] {0.539909665132, 2.41970724519, 3.98942280401, 2.41970724519,                0.539909665132, 0.0443184841194, 0.00133830225765, 1.48671951473e-05});        verifyQuantiles();        verifyDensities();    }    @Test    public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0, 1});        setInverseCumulativeTestValues(                new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }    @Test    public void testGetMean() {        NormalDistribution distribution = (NormalDistribution) getDistribution();        Assert.assertEquals(2.1, distribution.getMean(), 0);    }    @Test    public void testGetStandardDeviation() {        NormalDistribution distribution = (NormalDistribution) getDistribution();        Assert.assertEquals(1.4, distribution.getStandardDeviation(), 0);    }    @Test    public void testPreconditions() {        try {            new NormalDistributionImpl(1, 0);            Assert.fail("Should have generated NotStrictlyPositiveException");        } catch (NotStrictlyPositiveException e) {            // Expected.        }    }    @Test    public void testDensity() {        double [] x = new double[]{-2, -1, 0, 1, 2};        // R 2.5: print(dnorm(c(-2,-1,0,1,2)), digits=10)        checkDensity(0, 1, x, new double[]{0.05399096651, 0.24197072452, 0.39894228040, 0.24197072452, 0.05399096651});        // R 2.5: print(dnorm(c(-2,-1,0,1,2), mean=1.1), digits=10)        checkDensity(1.1, 1, x, new double[]{0.003266819056,0.043983595980,0.217852177033,0.396952547477,0.266085249899});    }    private void checkDensity(double mean, double sd, double[] x, double[] expected) {        NormalDistribution d = new NormalDistributionImpl(mean, sd);        for (int i = 0; i < x.length; i++) {            Assert.assertEquals(expected[i], d.density(x[i]), 1e-9);        }    }    /**     * Check to make sure top-coding of extreme values works correctly.     * Verifies fixes for JIRA MATH-167, MATH-414     */    @Test    public void testExtremeValues() throws Exception {        NormalDistribution distribution = new NormalDistributionImpl(0, 1);        for (int i = 0; i < 100; i++) { // make sure no convergence exception            double lowerTail = distribution.cumulativeProbability(-i);            double upperTail = distribution.cumulativeProbability(i);            if (i < 9) { // make sure not top-coded                 // For i = 10, due to bad tail precision in erf (MATH-364), 1 is returned                // TODO: once MATH-364 is resolved, replace 9 with 30                Assert.assertTrue(lowerTail > 0.0d);                Assert.assertTrue(upperTail < 1.0d);            }            else { // make sure top coding not reversed                Assert.assertTrue(lowerTail < 0.00001);                Assert.assertTrue(upperTail > 0.99999);            }        }                Assert.assertEquals(distribution.cumulativeProbability(Double.MAX_VALUE), 1, 0);        Assert.assertEquals(distribution.cumulativeProbability(-Double.MAX_VALUE), 0, 0);        Assert.assertEquals(distribution.cumulativeProbability(Double.POSITIVE_INFINITY), 1, 0);        Assert.assertEquals(distribution.cumulativeProbability(Double.NEGATIVE_INFINITY), 0, 0);           }    @Test    public void testMath280() throws MathException {        NormalDistribution normal = new NormalDistributionImpl(0,1);        double result = normal.inverseCumulativeProbability(0.9986501019683698);        Assert.assertEquals(3.0, result, defaultTolerance);        result = normal.inverseCumulativeProbability(0.841344746068543);        Assert.assertEquals(1.0, result, defaultTolerance);        result = normal.inverseCumulativeProbability(0.9999683287581673);        Assert.assertEquals(4.0, result, defaultTolerance);        result = normal.inverseCumulativeProbability(0.9772498680518209);        Assert.assertEquals(2.0, result, defaultTolerance);    }    @Test    public void testMomonts() {        final double tol = 1e-9;        NormalDistribution dist;                dist = new NormalDistributionImpl(0, 1);                Assert.assertEquals(dist.getNumericalMean(), 0, tol);        Assert.assertEquals(dist.getNumericalVariance(), 1, tol);                 dist = new NormalDistributionImpl(2.2, 1.4);        Assert.assertEquals(dist.getNumericalMean(), 2.2, tol);        Assert.assertEquals(dist.getNumericalVariance(), 1.4 * 1.4, tol);                dist = new NormalDistributionImpl(-2000.9, 10.4);        Assert.assertEquals(dist.getNumericalMean(), -2000.9, tol);        Assert.assertEquals(dist.getNumericalVariance(), 10.4 * 10.4, tol);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.util.MathUtils;import org.apache.commons.math.exception.NotStrictlyPositiveException;import org.junit.Assert;import org.junit.Test;/** * Test cases for ExponentialDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Id$ */public class ExponentialDistributionTest extends ContinuousDistributionAbstractTest {    // --------------------- Override tolerance  --------------    @Override    public void setUp() throws Exception {        super.setUp();        setTolerance(1E-9);    }    //-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public ExponentialDistribution makeDistribution() {        return new ExponentialDistributionImpl(5.0);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 2.9.2        return new double[] {0.00500250166792, 0.0502516792675, 0.126589039921, 0.256466471938,                0.526802578289, 34.5387763949, 23.0258509299, 18.4443972706, 14.9786613678, 11.5129254650};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999,                0.990, 0.975, 0.950, 0.900};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0.1998, 0.198, 0.195, 0.19, 0.18, 0.000200000000000,                0.00200000000002, 0.00499999999997, 0.00999999999994, 0.0199999999999};    }    //------------ Additional tests -------------------------------------------    @Test    public void testCumulativeProbabilityExtremes() throws Exception {        setCumulativeTestPoints(new double[] {-2, 0});        setCumulativeTestValues(new double[] {0, 0});        verifyCumulativeProbabilities();    }    @Test    public void testInverseCumulativeProbabilityExtremes() throws Exception {         setInverseCumulativeTestPoints(new double[] {0, 1});         setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});         verifyInverseCumulativeProbabilities();    }    @Test    public void testCumulativeProbability2() throws Exception {        double actual = getDistribution().cumulativeProbability(0.25, 0.75);        Assert.assertEquals(0.0905214, actual, 10e-4);    }    @Test    public void testDensity() {        ExponentialDistribution d1 = new ExponentialDistributionImpl(1);        Assert.assertTrue(MathUtils.equals(0.0, d1.density(-1e-9), 1));        Assert.assertTrue(MathUtils.equals(1.0, d1.density(0.0), 1));        Assert.assertTrue(MathUtils.equals(0.0, d1.density(1000.0), 1));        Assert.assertTrue(MathUtils.equals(FastMath.exp(-1), d1.density(1.0), 1));        Assert.assertTrue(MathUtils.equals(FastMath.exp(-2), d1.density(2.0), 1));        ExponentialDistribution d2 = new ExponentialDistributionImpl(3);        Assert.assertTrue(MathUtils.equals(1/3.0, d2.density(0.0), 1));        // computed using  print(dexp(1, rate=1/3), digits=10) in R 2.5        Assert.assertEquals(0.2388437702, d2.density(1.0), 1e-8);        // computed using  print(dexp(2, rate=1/3), digits=10) in R 2.5        Assert.assertEquals(0.1711390397, d2.density(2.0), 1e-8);    }    @Test    public void testMeanAccessors() {        ExponentialDistribution distribution = (ExponentialDistribution) getDistribution();        Assert.assertEquals(5d, distribution.getMean(), Double.MIN_VALUE);    }    @Test    public void testPreconditions() {        try {            new ExponentialDistributionImpl(0);            Assert.fail("Should have generated NotStrictlyPositiveException");        } catch (NotStrictlyPositiveException e) {            // Expected.        }    }    @Test    public void testMomonts() {        final double tol = 1e-9;        ExponentialDistribution dist;                dist = new ExponentialDistributionImpl(11d);        Assert.assertEquals(dist.getNumericalMean(), 11d, tol);        Assert.assertEquals(dist.getNumericalVariance(), 11d * 11d, tol);                dist = new ExponentialDistributionImpl(10.5d);        Assert.assertEquals(dist.getNumericalMean(), 10.5d, tol);        Assert.assertEquals(dist.getNumericalVariance(), 10.5d * 10.5d, tol);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.distribution;import org.junit.Assert;import org.junit.Test;/** * Test cases for BinomialDistribution. Extends IntegerDistributionAbstractTest. * See class javadoc for IntegerDistributionAbstractTest for details. * * @version $Id$ *          2009) $ */public class BinomialDistributionTest extends IntegerDistributionAbstractTest {    // -------------- Implementations for abstract methods    // -----------------------    /** Creates the default discrete distribution instance to use in tests. */    @Override    public IntegerDistribution makeDistribution() {        return new BinomialDistributionImpl(10, 0.70);    }    /** Creates the default probability density test input values */    @Override    public int[] makeDensityTestPoints() {        return new int[] { -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] { 0d, 0.0000059049d, 0.000137781d, 0.0014467d,                0.00900169d, 0.0367569d, 0.102919d, 0.200121d, 0.266828d,                0.233474d, 0.121061d, 0.0282475d, 0d };    }    /** Creates the default cumulative probability density test input values */    @Override    public int[] makeCumulativeTestPoints() {        return makeDensityTestPoints();    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] { 0d, 0.0000d, 0.0001d, 0.0016d, 0.0106d, 0.0473d,                0.1503d, 0.3504d, 0.6172d, 0.8507d, 0.9718d, 1d, 1d };    }    /** Creates the default inverse cumulative probability test input values */    @Override    public double[] makeInverseCumulativeTestPoints() {        return new double[] { 0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d,                0.999d, 0.990d, 0.975d, 0.950d, 0.900d, 1 };    }    /**     * Creates the default inverse cumulative probability density test expected     * values     */    @Override    public int[] makeInverseCumulativeTestValues() {        return new int[] { -1, 1, 2, 3, 4, 4, 9, 9, 9, 8, 8, Integer.MAX_VALUE };    }    // ----------------- Additional test cases ---------------------------------    /** Test degenerate case p = 0 */    @Test    public void testDegenerate0() throws Exception {        setDistribution(new BinomialDistributionImpl(5, 0.0d));        setCumulativeTestPoints(new int[] { -1, 0, 1, 5, 10 });        setCumulativeTestValues(new double[] { 0d, 1d, 1d, 1d, 1d });        setDensityTestPoints(new int[] { -1, 0, 1, 10, 11 });        setDensityTestValues(new double[] { 0d, 1d, 0d, 0d, 0d });        setInverseCumulativeTestPoints(new double[] { 0.1d, 0.5d });        setInverseCumulativeTestValues(new int[] { -1, -1 });        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }    /** Test degenerate case p = 1 */    @Test    public void testDegenerate1() throws Exception {        setDistribution(new BinomialDistributionImpl(5, 1.0d));        setCumulativeTestPoints(new int[] { -1, 0, 1, 2, 5, 10 });        setCumulativeTestValues(new double[] { 0d, 0d, 0d, 0d, 1d, 1d });        setDensityTestPoints(new int[] { -1, 0, 1, 2, 5, 10 });        setDensityTestValues(new double[] { 0d, 0d, 0d, 0d, 1d, 0d });        setInverseCumulativeTestPoints(new double[] { 0.1d, 0.5d });        setInverseCumulativeTestValues(new int[] { 4, 4 });        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }    @Test    public void testMomonts() {        final double tol = 1e-9;        BinomialDistribution dist;                dist = new BinomialDistributionImpl(10, 0.5);        Assert.assertEquals(dist.getNumericalMean(), 10d * 0.5d, tol);        Assert.assertEquals(dist.getNumericalVariance(), 10d * 0.5d * 0.5d, tol);                 dist = new BinomialDistributionImpl(30, 0.3);        Assert.assertEquals(dist.getNumericalMean(), 30d * 0.3d, tol);        Assert.assertEquals(dist.getNumericalVariance(), 30d * 0.3d * (1d - 0.3d), tol);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.MathException;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.NotStrictlyPositiveException;import org.junit.Assert;import org.junit.Test;/** * <code>PoissonDistributionTest</code> * * @version $Id$ */public class PoissonDistributionTest extends IntegerDistributionAbstractTest {    /**     * Poisson parameter value for the test distribution.     */    private static final double DEFAULT_TEST_POISSON_PARAMETER = 4.0;    /**     * Constructor.     */    public PoissonDistributionTest() {        setTolerance(1e-12);    }    /**     * Creates the default discrete distribution instance to use in tests.     */    @Override    public IntegerDistribution makeDistribution() {        return new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);    }    /**     * Creates the default probability density test input values.     */    @Override    public int[] makeDensityTestPoints() {        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};    }    /**     * Creates the default probability density test expected values.     * These and all other test values are generated by R, version 1.8.1     */    @Override    public double[] makeDensityTestValues() {        return new double[] { 0d, 0.0183156388887d,  0.073262555555d,                0.14652511111d, 0.195366814813d, 0.195366814813,                0.156293451851d, 0.00529247667642d, 8.27746364655e-09};    }    /**     * Creates the default cumulative probability density test input values.     */    @Override    public int[] makeCumulativeTestPoints() {        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20 };    }    /**     * Creates the default cumulative probability density test expected values.     */    @Override    public double[] makeCumulativeTestValues() {        return new double[] { 0d,  0.0183156388887d, 0.0915781944437d,                0.238103305554d, 0.433470120367d, 0.62883693518,                0.78513038703d,  0.99716023388d, 0.999999998077 };    }    /**     * Creates the default inverse cumulative probability test input values.     * Increased 3rd and 7th values slightly as computed cumulative     * probabilities for corresponding values exceeds the target value (still     * within tolerance).     */    @Override    public double[] makeInverseCumulativeTestPoints() {        return new double[] { 0d,  0.018315638889d, 0.0915781944437d,                0.238103305554d, 0.433470120367d, 0.62883693518,                0.78513038704d,  0.99716023388d, 0.999999998077 };    }    /**     * Creates the default inverse cumulative probability density test expected values.     */    @Override    public int[] makeInverseCumulativeTestValues() {        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};    }    /**     * Test the normal approximation of the Poisson distribution by     * calculating P(90 &le; X &le; 110) for X = Po(100) and     * P(9900 &le; X &le; 10200) for X  = Po(10000)     */    @Test    public void testNormalApproximateProbability() throws Exception {        PoissonDistribution dist = new PoissonDistributionImpl(100);        double result = dist.normalApproximateProbability(110)                - dist.normalApproximateProbability(89);        Assert.assertEquals(0.706281887248, result, 1E-10);        dist = new PoissonDistributionImpl(10000);        result = dist.normalApproximateProbability(10200)        - dist.normalApproximateProbability(9899);        Assert.assertEquals(0.820070051552, result, 1E-10);    }    /**     * Test the degenerate cases of a 0.0 and 1.0 inverse cumulative probability.     * @throws Exception     */    @Test    public void testDegenerateInverseCumulativeProbability() throws Exception {        PoissonDistribution dist = new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);        Assert.assertEquals(Integer.MAX_VALUE, dist.inverseCumulativeProbability(1.0d));        Assert.assertEquals(-1, dist.inverseCumulativeProbability(0d));    }    @Test    public void testMean() {        PoissonDistribution dist;        try {            dist = new PoissonDistributionImpl(-1);            Assert.fail("negative mean: NotStrictlyPositiveException expected");        } catch(NotStrictlyPositiveException ex) {            // Expected.        }        dist = new PoissonDistributionImpl(10.0);        Assert.assertEquals(10.0, dist.getMean(), 0.0);    }    @Test    public void testLargeMeanCumulativeProbability() {        double mean = 1.0;        while (mean <= 10000000.0) {            PoissonDistribution dist = new PoissonDistributionImpl(mean);            double x = mean * 2.0;            double dx = x / 10.0;            double p = Double.NaN;            double sigma = FastMath.sqrt(mean);            while (x >= 0) {                try {                    p = dist.cumulativeProbability(x);                    Assert.assertFalse("NaN cumulative probability returned for mean = " +                            mean + " x = " + x,Double.isNaN(p));                    if (x > mean - 2 * sigma) {                        Assert.assertTrue("Zero cum probaility returned for mean = " +                                mean + " x = " + x, p > 0);                    }                } catch (MathException ex) {                    Assert.fail("mean of " + mean + " and x of " + x + " caused " + ex.getMessage());                }                x -= dx;            }            mean *= 10.0;        }    }    /**     * JIRA: MATH-282     */    @Test    public void testCumulativeProbabilitySpecial() throws Exception {        PoissonDistribution dist;        dist = new PoissonDistributionImpl(9120);        checkProbability(dist, 9075);        checkProbability(dist, 9102);        dist = new PoissonDistributionImpl(5058);        checkProbability(dist, 5044);        dist = new PoissonDistributionImpl(6986);        checkProbability(dist, 6950);    }    private void checkProbability(PoissonDistribution dist, double x) throws Exception {        double p = dist.cumulativeProbability(x);        Assert.assertFalse("NaN cumulative probability returned for mean = " +                dist.getMean() + " x = " + x, Double.isNaN(p));        Assert.assertTrue("Zero cum probability returned for mean = " +                dist.getMean() + " x = " + x, p > 0);    }    @Test    public void testLargeMeanInverseCumulativeProbability() throws Exception {        double mean = 1.0;        while (mean <= 100000.0) { // Extended test value: 1E7.  Reduced to limit run time.            PoissonDistribution dist = new PoissonDistributionImpl(mean);            double p = 0.1;            double dp = p;            while (p < .99) {                double ret = Double.NaN;                try {                    ret = dist.inverseCumulativeProbability(p);                    // Verify that returned value satisties definition                    Assert.assertTrue(p >= dist.cumulativeProbability(ret));                    Assert.assertTrue(p < dist.cumulativeProbability(ret + 1));                } catch (MathException ex) {                    Assert.fail("mean of " + mean + " and p of " + p + " caused " + ex.getMessage());                }                p += dp;            }            mean *= 10.0;        }    }    @Test    public void testMomonts() {        final double tol = 1e-9;        PoissonDistribution dist;                dist = new PoissonDistributionImpl(1);        Assert.assertEquals(dist.getNumericalMean(), 1, tol);        Assert.assertEquals(dist.getNumericalVariance(), 1, tol);                 dist = new PoissonDistributionImpl(11.23);        Assert.assertEquals(dist.getNumericalMean(), 11.23, tol);        Assert.assertEquals(dist.getNumericalVariance(), 11.23, tol);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.junit.Assert;import org.junit.Test;/** * Test cases for ChiSquareDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Id$ */public class ChiSquareDistributionTest extends ContinuousDistributionAbstractTest {    //-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public ChiSquaredDistribution makeDistribution() {        return new ChiSquaredDistributionImpl(5.0);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 2.9.2        return new double[] {0.210212602629, 0.554298076728, 0.831211613487, 1.14547622606, 1.61030798696,                20.5150056524, 15.0862724694, 12.8325019940, 11.0704976935, 9.23635689978};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900};    }    /** Creates the default inverse cumulative probability test input values */    @Override    public double[] makeInverseCumulativeTestPoints() {        return new double[] {0, 0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d, 1};    }    /** Creates the default inverse cumulative probability density test expected values */    @Override    public double[] makeInverseCumulativeTestValues() {        return new double[] {0, 0.210212602629, 0.554298076728, 0.831211613487, 1.14547622606, 1.61030798696,                20.5150056524, 15.0862724694, 12.8325019940, 11.0704976935, 9.23635689978,                Double.POSITIVE_INFINITY};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0.0115379817652, 0.0415948507811, 0.0665060119842, 0.0919455953114, 0.121472591024,                0.000433630076361, 0.00412780610309, 0.00999340341045, 0.0193246438937, 0.0368460089216};    } // --------------------- Override tolerance  --------------    @Override    public void setUp() throws Exception {        super.setUp();        setTolerance(1e-9);    } //---------------------------- Additional test cases -------------------------    @Test    public void testSmallDf() throws Exception {        setDistribution(new ChiSquaredDistributionImpl(0.1d));        setTolerance(1E-4);        // quantiles computed using R version 1.8.1 (linux version)        setCumulativeTestPoints(new double[] {1.168926E-60, 1.168926E-40, 1.063132E-32,                1.144775E-26, 1.168926E-20, 5.472917, 2.175255, 1.13438,                0.5318646, 0.1526342});        setInverseCumulativeTestValues(getCumulativeTestPoints());        setInverseCumulativeTestPoints(getCumulativeTestValues());        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }    @Test    public void testDfAccessors() {        ChiSquaredDistribution distribution = (ChiSquaredDistribution) getDistribution();        Assert.assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);    }    @Test    public void testDensity() {        double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};        //R 2.5: print(dchisq(x, df=1), digits=10)        checkDensity(1, x, new double[]{0.00000000000, 398.94208093034, 0.43939128947, 0.24197072452, 0.10377687436, 0.01464498256});        //R 2.5: print(dchisq(x, df=0.1), digits=10)        checkDensity(0.1, x, new double[]{0.000000000e+00, 2.486453997e+04, 7.464238732e-02, 3.009077718e-02, 9.447299159e-03, 8.827199396e-04});        //R 2.5: print(dchisq(x, df=2), digits=10)        checkDensity(2, x, new double[]{0.00000000000, 0.49999975000, 0.38940039154, 0.30326532986, 0.18393972059, 0.04104249931});        //R 2.5: print(dchisq(x, df=10), digits=10)        checkDensity(10, x, new double[]{0.000000000e+00, 1.302082682e-27, 6.337896998e-05, 7.897534632e-04, 7.664155024e-03, 6.680094289e-02});    }    private void checkDensity(double df, double[] x, double[] expected) {        ChiSquaredDistribution d = new ChiSquaredDistributionImpl(df);        for (int i = 0; i < x.length; i++) {            Assert.assertEquals(expected[i], d.density(x[i]), 1e-5);        }    }    @Test    public void testMomonts() {        final double tol = 1e-9;        ChiSquaredDistribution dist;                dist = new ChiSquaredDistributionImpl(1500);        Assert.assertEquals(dist.getNumericalMean(), 1500, tol);        Assert.assertEquals(dist.getNumericalVariance(), 3000, tol);                 dist = new ChiSquaredDistributionImpl(1.12);        Assert.assertEquals(dist.getNumericalMean(), 1.12, tol);        Assert.assertEquals(dist.getNumericalVariance(), 2.24, tol);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;/** * Abstract base class for {@link ContinuousDistribution} tests. * <p> * To create a concrete test class for a continuous distribution * implementation, first implement makeDistribution() to return a distribution * instance to use in tests. Then implement each of the test data generation * methods below.  In each case, the test points and test values arrays * returned represent parallel arrays of inputs and expected values for the * distribution returned by makeDistribution().  Default implementations * are provided for the makeInverseXxx methods that just invert the mapping * defined by the arrays returned by the makeCumulativeXxx methods. * <p> * makeCumulativeTestPoints() -- arguments used to test cumulative probabilities * makeCumulativeTestValues() -- expected cumulative probabilites * makeDensityTestValues() -- expected density values at cumulativeTestPoints * makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf * makeInverseCumulativeTestValues() -- expected inverse cdf values * <p> * To implement additional test cases with different distribution instances and * test data, use the setXxx methods for the instance data in test cases and * call the verifyXxx methods to verify results. * <p> * Error tolerance can be overriden by implementing getTolerance(). * <p> * Test data should be validated against reference tables or other packages * where possible, and the source of the reference data and/or validation * should be documented in the test cases.  A framework for validating * distribution data against R is included in the /src/test/R source tree. * <p> * See {@link NormalDistributionTest} and {@link ChiSquareDistributionTest} * for examples. * * @version $Id$ */public abstract class ContinuousDistributionAbstractTest {//-------------------- Private test instance data -------------------------    /**  Distribution instance used to perform tests */    private ContinuousDistribution distribution;    /** Tolerance used in comparing expected and returned values */    private double tolerance = 1E-4;    /** Arguments used to test cumulative probability density calculations */    private double[] cumulativeTestPoints;    /** Values used to test cumulative probability density calculations */    private double[] cumulativeTestValues;    /** Arguments used to test inverse cumulative probability density calculations */    private double[] inverseCumulativeTestPoints;    /** Values used to test inverse cumulative probability density calculations */    private double[] inverseCumulativeTestValues;    /** Values used to test density calculations */    private double[] densityTestValues;    //-------------------- Abstract methods -----------------------------------    /** Creates the default continuous distribution instance to use in tests. */    public abstract ContinuousDistribution makeDistribution();    /** Creates the default cumulative probability test input values */    public abstract double[] makeCumulativeTestPoints();    /** Creates the default cumulative probability test expected values */    public abstract double[] makeCumulativeTestValues();    /** Creates the default density test expected values */    public abstract double[] makeDensityTestValues();    //---- Default implementations of inverse test data generation methods ----    /** Creates the default inverse cumulative probability test input values */    public double[] makeInverseCumulativeTestPoints() {        return makeCumulativeTestValues();    }    /** Creates the default inverse cumulative probability density test expected values */    public double[] makeInverseCumulativeTestValues() {        return makeCumulativeTestPoints();    }    //-------------------- Setup / tear down ----------------------------------    /**     * Setup sets all test instance data to default values     */    @Before    public void setUp() throws Exception {        distribution = makeDistribution();        cumulativeTestPoints = makeCumulativeTestPoints();        cumulativeTestValues = makeCumulativeTestValues();        inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();        inverseCumulativeTestValues = makeInverseCumulativeTestValues();        densityTestValues = makeDensityTestValues();    }    /**     * Cleans up test instance data     */    @After    public void tearDown() throws Exception {        distribution = null;        cumulativeTestPoints = null;        cumulativeTestValues = null;        inverseCumulativeTestPoints = null;        inverseCumulativeTestValues = null;        densityTestValues = null;    }    //-------------------- Verification methods -------------------------------    /**     * Verifies that cumulative probability density calculations match expected values     * using current test instance data     */    protected void verifyCumulativeProbabilities() throws Exception {        for (int i = 0; i < cumulativeTestPoints.length; i++) {            TestUtils.assertEquals("Incorrect cumulative probability value returned for "                + cumulativeTestPoints[i], cumulativeTestValues[i],                distribution.cumulativeProbability(cumulativeTestPoints[i]),                getTolerance());        }    }    /**     * Verifies that inverse cumulative probability density calculations match expected values     * using current test instance data     */    protected void verifyInverseCumulativeProbabilities() throws Exception {        for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {            TestUtils.assertEquals("Incorrect inverse cumulative probability value returned for "                + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i],                 distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]),                 getTolerance());        }    }    /**     * Verifies that density calculations match expected values     */    protected void verifyDensities() throws Exception {        for (int i = 0; i < cumulativeTestPoints.length; i++) {            TestUtils.assertEquals("Incorrect probability density value returned for "                + cumulativeTestPoints[i], densityTestValues[i],                 //TODO: remove cast when density(double) is added to ContinuousDistribution                 ((AbstractContinuousDistribution) distribution).density(cumulativeTestPoints[i]),                 getTolerance());        }    }    //------------------------ Default test cases -----------------------------    /**     * Verifies that cumulative probability density calculations match expected values     * using default test instance data     */    @Test    public void testCumulativeProbabilities() throws Exception {        verifyCumulativeProbabilities();    }    /**     * Verifies that inverse cumulative probability density calculations match expected values     * using default test instance data     */    @Test    public void testInverseCumulativeProbabilities() throws Exception {        verifyInverseCumulativeProbabilities();    }    /**     * Verifies that density calculations return expected values     * for default test instance data     */    @Test    public void testDensities() throws Exception {        verifyDensities();    }    /**     * Verifies that probability computations are consistent     */    @Test    public void testConsistency() throws Exception {        for (int i=1; i < cumulativeTestPoints.length; i++) {            // check that cdf(x, x) = 0            TestUtils.assertEquals(0d,               distribution.cumulativeProbability                 (cumulativeTestPoints[i], cumulativeTestPoints[i]), tolerance);            // check that P(a < X < b) = P(X < b) - P(X < a)            double upper = FastMath.max(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);            double lower = FastMath.min(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);            double diff = distribution.cumulativeProbability(upper) -                distribution.cumulativeProbability(lower);            double direct = distribution.cumulativeProbability(lower, upper);            TestUtils.assertEquals("Inconsistent cumulative probabilities for ("                    + lower + "," + upper + ")", diff, direct, tolerance);        }    }    /**     * Verifies that illegal arguments are correctly handled     */    @Test    public void testIllegalArguments() throws Exception {        try {            distribution.cumulativeProbability(1, 0);            Assert.fail("Expecting MathIllegalArgumentException for bad cumulativeProbability interval");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            distribution.inverseCumulativeProbability(-1);            Assert.fail("Expecting MathIllegalArgumentException for p = -1");        } catch (MathIllegalArgumentException ex) {            // expected        }        try {            distribution.inverseCumulativeProbability(2);            Assert.fail("Expecting MathIllegalArgumentException for p = 2");        } catch (MathIllegalArgumentException ex) {            // expected        }    }        /**     * Test sampling     */    @Test    public void testSampling() throws Exception {        AbstractContinuousDistribution dist = (AbstractContinuousDistribution) makeDistribution();        final int sampleSize = 1000;        dist.reseedRandomGenerator(1000);  // Use fixed seed        double[] sample = dist.sample(sampleSize);        double[] quartiles = TestUtils.getDistributionQuartiles(dist);        double[] expected = {250, 250, 250, 250};        long[] counts = new long[4];        for (int i = 0; i < sampleSize; i++) {            TestUtils.updateCounts(sample[i], counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);    }    //------------------ Getters / Setters for test instance data -----------    /**     * @return Returns the cumulativeTestPoints.     */    protected double[] getCumulativeTestPoints() {        return cumulativeTestPoints;    }    /**     * @param cumulativeTestPoints The cumulativeTestPoints to set.     */    protected void setCumulativeTestPoints(double[] cumulativeTestPoints) {        this.cumulativeTestPoints = cumulativeTestPoints;    }    /**     * @return Returns the cumulativeTestValues.     */    protected double[] getCumulativeTestValues() {        return cumulativeTestValues;    }    /**     * @param cumulativeTestValues The cumulativeTestValues to set.     */    protected void setCumulativeTestValues(double[] cumulativeTestValues) {        this.cumulativeTestValues = cumulativeTestValues;    }    protected double[] getDensityTestValues() {        return densityTestValues;    }    protected void setDensityTestValues(double[] densityTestValues) {        this.densityTestValues = densityTestValues;    }    /**     * @return Returns the distribution.     */    protected ContinuousDistribution getDistribution() {        return distribution;    }    /**     * @param distribution The distribution to set.     */    protected void setDistribution(AbstractContinuousDistribution distribution) {        this.distribution = distribution;    }    /**     * @return Returns the inverseCumulativeTestPoints.     */    protected double[] getInverseCumulativeTestPoints() {        return inverseCumulativeTestPoints;    }    /**     * @param inverseCumulativeTestPoints The inverseCumulativeTestPoints to set.     */    protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) {        this.inverseCumulativeTestPoints = inverseCumulativeTestPoints;    }    /**     * @return Returns the inverseCumulativeTestValues.     */    protected double[] getInverseCumulativeTestValues() {        return inverseCumulativeTestValues;    }    /**     * @param inverseCumulativeTestValues The inverseCumulativeTestValues to set.     */    protected void setInverseCumulativeTestValues(double[] inverseCumulativeTestValues) {        this.inverseCumulativeTestValues = inverseCumulativeTestValues;    }    /**     * @return Returns the tolerance.     */    protected double getTolerance() {        return tolerance;    }    /**     * @param tolerance The tolerance to set.     */    protected void setTolerance(double tolerance) {        this.tolerance = tolerance;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.events;import org.apache.commons.math.analysis.solvers.BrentSolver;import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;import org.apache.commons.math.ode.sampling.DummyStepInterpolator;import org.junit.Assert;import org.junit.Test;public class EventStateTest {    // JIRA: MATH-322    @Test    public void closeEvents() {        final double r1  = 90.0;        final double r2  = 135.0;        final double gap = r2 - r1;        EventHandler closeEventsGenerator = new EventHandler() {            public void resetState(double t, double[] y) {            }            public double g(double t, double[] y) {                return (t - r1) * (r2 - t);            }            public int eventOccurred(double t, double[] y, boolean increasing) {                return CONTINUE;            }        };        final double tolerance = 0.1;        EventState es = new EventState(closeEventsGenerator, 1.5 * gap,                                       tolerance, 100,                                       new BrentSolver(tolerance));        AbstractStepInterpolator interpolator =            new DummyStepInterpolator(new double[0], new double[0], true);        interpolator.storeTime(r1 - 2.5 * gap);        interpolator.shift();        interpolator.storeTime(r1 - 1.5 * gap);        es.reinitializeBegin(interpolator);        interpolator.shift();        interpolator.storeTime(r1 - 0.5 * gap);        Assert.assertFalse(es.evaluateStep(interpolator));        interpolator.shift();        interpolator.storeTime(0.5 * (r1 + r2));        Assert.assertTrue(es.evaluateStep(interpolator));        Assert.assertEquals(r1, es.getEventTime(), tolerance);        es.stepAccepted(es.getEventTime(), new double[0]);        interpolator.shift();        interpolator.storeTime(r2 + 0.4 * gap);        Assert.assertTrue(es.evaluateStep(interpolator));        Assert.assertEquals(r2, es.getEventTime(), tolerance);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.events;import java.util.ArrayList;import java.util.List;import org.apache.commons.math.analysis.solvers.BaseSecantSolver;import org.apache.commons.math.analysis.solvers.PegasusSolver;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;import org.junit.Assert;import org.junit.Test;/** Tests for overlapping state events. Also tests an event function that does * not converge to zero, but does have values of opposite sign around its root. */public class OverlappingEventsTest implements FirstOrderDifferentialEquations {    /** Expected event times for first event. */    private static final double[] EVENT_TIMES1 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0,                                                  7.0, 8.0, 9.0};    /** Expected event times for second event. */    private static final double[] EVENT_TIMES2 = {0.5, 1.0, 1.5, 2.0, 2.5, 3.0,                                                  3.5, 4.0, 4.5, 5.0, 5.5, 6.0,                                                  6.5, 7.0, 7.5, 8.0, 8.5, 9.0,                                                  9.5};    /** Test for events that occur at the exact same time, but due to numerical     * calculations occur very close together instead. Uses event type 0. See     * {@link org.apache.commons.math.ode.events.EventHandler#g(double, double[])     * EventHandler.g(double, double[])}.     */    @Test    public void testOverlappingEvents0() {        test(0);    }    /** Test for events that occur at the exact same time, but due to numerical     * calculations occur very close together instead. Uses event type 1. See     * {@link org.apache.commons.math.ode.events.EventHandler#g(double, double[])     * EventHandler.g(double, double[])}.     */    @Test    public void testOverlappingEvents1() {        test(1);    }    /** Test for events that occur at the exact same time, but due to numerical     * calculations occur very close together instead.     * @param eventType the type of events to use. See     * {@link org.apache.commons.math.ode.events.EventHandler#g(double, double[])     * EventHandler.g(double, double[])}.     */    public void test(int eventType) {        double e = 1e-15;        FirstOrderIntegrator integrator = new DormandPrince853Integrator(e, 100.0, 1e-7, 1e-7);        BaseSecantSolver rootSolver = new PegasusSolver(e, e);        EventHandler evt1 = new Event(0, eventType);        EventHandler evt2 = new Event(1, eventType);        integrator.addEventHandler(evt1, 0.1, e, 999, rootSolver);        integrator.addEventHandler(evt2, 0.1, e, 999, rootSolver);        double t = 0.0;        double tEnd = 10.0;        double[] y = {0.0, 0.0};        List<Double> events1 = new ArrayList<Double>();        List<Double> events2 = new ArrayList<Double>();        while (t < tEnd) {            t = integrator.integrate(this, t, y, tEnd, y);            //System.out.println("t=" + t + ",\t\ty=[" + y[0] + "," + y[1] + "]");            if (y[0] >= 1.0) {                y[0] = 0.0;                events1.add(t);                //System.out.println("Event 1 @ t=" + t);            }            if (y[1] >= 1.0) {                y[1] = 0.0;                events2.add(t);                //System.out.println("Event 2 @ t=" + t);            }        }        Assert.assertEquals(EVENT_TIMES1.length, events1.size());        Assert.assertEquals(EVENT_TIMES2.length, events2.size());        for(int i = 0; i < EVENT_TIMES1.length; i++) {            Assert.assertEquals(EVENT_TIMES1[i], events1.get(i), 1e-7);        }        for(int i = 0; i < EVENT_TIMES2.length; i++) {            Assert.assertEquals(EVENT_TIMES2[i], events2.get(i), 1e-7);        }        //System.out.println();    }    /** {@inheritDoc} */    public int getDimension() {        return 2;    }    /** {@inheritDoc} */    public void computeDerivatives(double t, double[] y, double[] yDot) throws MathUserException {        yDot[0] = 1.0;        yDot[1] = 2.0;    }    /** State events for this unit test. */    private class Event implements EventHandler {        /** The index of the continuous variable to use. */        private final int idx;        /** The event type to use. See {@link #g}. */        private final int eventType;        /** Constructor for the {@link Event} class.         * @param idx the index of the continuous variable to use         * @param eventType the type of event to use. See {@link #g}         */        public Event(int idx, int eventType) {            this.idx = idx;            this.eventType = eventType;        }        /** {@inheritDoc} */        public double g(double t, double[] y) {            return (eventType == 0) ? y[idx] >= 1.0 ? 1.0 : -1.0                                    : y[idx] - 1.0;        }        /** {@inheritDoc} */        public int eventOccurred(double t, double[] y, boolean increasing) {            return STOP;        }        /** {@inheritDoc} */        public void resetState(double t, double[] y) {            // Never called.        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.exception.TooManyEvaluationsException;import org.apache.commons.math.exception.util.LocalizedFormats;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.TestProblem4;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class HighamHall54IntegratorTest {  @Test  public void testWrongDerivative() throws Exception {      HighamHall54Integrator integrator =          new HighamHall54Integrator(0.0, 1.0, 1.0e-10, 1.0e-10);      FirstOrderDifferentialEquations equations =          new FirstOrderDifferentialEquations() {            public void computeDerivatives(double t, double[] y, double[] dot)            throws MathUserException {            if (t < -0.5) {                throw new MathUserException(LocalizedFormats.SIMPLE_MESSAGE, "oops");            } else {                throw new MathUserException(new RuntimeException("oops"));           }          }          public int getDimension() {              return 1;          }      };      try  {        integrator.integrate(equations, -1.0, new double[1], 0.0, new double[1]);        Assert.fail("an exception should have been thrown");      } catch(MathUserException de) {        // expected behavior      }      try  {        integrator.integrate(equations, 0.0, new double[1], 1.0, new double[1]);        Assert.fail("an exception should have been thrown");      } catch(MathUserException de) {        // expected behavior      }  }  @Test(expected=NumberIsTooSmallException.class)  public void testMinStep() {      TestProblem1 pb = new TestProblem1();      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              vecAbsoluteTolerance,                                                              vecRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      Assert.fail("an exception should have been thrown");  }  @Test  public void testIncreasingTolerance()    {    int previousCalls = Integer.MAX_VALUE;    for (int i = -12; i < -2; ++i) {      TestProblem1 pb = new TestProblem1();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = FastMath.pow(10.0, i);      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      // the 1.3 factor is only valid for this test      // and has been obtained from trial and error      // there is no general relation between local and global errors      Assert.assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      int calls = pb.getCalls();      Assert.assertEquals(integ.getEvaluations(), calls);      Assert.assertTrue(calls <= previousCalls);      previousCalls = calls;    }  }  @Test  public void testBackward()      {      TestProblem5 pb = new TestProblem5();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() < 5.0e-7);      Assert.assertTrue(handler.getMaximalValueError() < 5.0e-7);      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      Assert.assertEquals("Higham-Hall 5(4)", integ.getName());  }  @Test  public void testEvents()    {    TestProblem4 pb = new TestProblem4();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                            scalAbsoluteTolerance,                                                            scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    EventHandler[] functions = pb.getEventsHandlers();    double convergence = 1.0e-8 * maxStep;    for (int l = 0; l < functions.length; ++l) {      integ.addEventHandler(functions[l],                                 Double.POSITIVE_INFINITY, convergence, 1000);    }    Assert.assertEquals(functions.length, integ.getEventHandlers().size());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertTrue(handler.getMaximalValueError() < 1.0e-7);    Assert.assertEquals(0, handler.getMaximalTimeError(), convergence);    Assert.assertEquals(12.0, handler.getLastTime(), convergence);    integ.clearEventHandlers();    Assert.assertEquals(0, integ.getEventHandlers().size());  }  @Test  public void testEventsErrors() throws Exception {      final TestProblem1 pb = new TestProblem1();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ =          new HighamHall54Integrator(minStep, maxStep,                                     scalAbsoluteTolerance, scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.addEventHandler(new EventHandler() {        public int eventOccurred(double t, double[] y, boolean increasing) {          return EventHandler.CONTINUE;        }        public double g(double t, double[] y) {          double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;          double offset = t - middle;          if (offset > 0) {            throw new MathUserException(LocalizedFormats.EVALUATION_FAILED, t);          }          return offset;        }        public void resetState(double t, double[] y) {        }      }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);      try {        integ.integrate(pb,                        pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        Assert.fail("an exception should have been thrown");      } catch (MathUserException ie) {        // expected behavior      }  }  @Test  public void testEventsNoConvergence() throws Exception {    final TestProblem1 pb = new TestProblem1();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ =        new HighamHall54Integrator(minStep, maxStep,                                   scalAbsoluteTolerance, scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.addEventHandler(new EventHandler() {      public int eventOccurred(double t, double[] y, boolean increasing) {        return EventHandler.CONTINUE;      }      public double g(double t, double[] y) {        double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;        double offset = t - middle;        return (offset > 0) ? (offset + 0.5) : (offset - 0.5);      }      public void resetState(double t, double[] y) {      }    }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 3);    try {      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      Assert.fail("an exception should have been thrown");    } catch (TooManyEvaluationsException tmee) {        // Expected.    }}  @Test  public void testSanityChecks() throws Exception {      final TestProblem3 pb  = new TestProblem3(0.9);      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      try {        FirstOrderIntegrator integ =            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);        integ.integrate(pb, pb.getInitialTime(), new double[6],                        pb.getFinalTime(), new double[pb.getDimension()]);        Assert.fail("an exception should have been thrown");      } catch (DimensionMismatchException ie) {        // expected behavior      }      try {        FirstOrderIntegrator integ =            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[6]);        Assert.fail("an exception should have been thrown");      } catch (DimensionMismatchException ie) {        // expected behavior      }      try {        FirstOrderIntegrator integ =            new HighamHall54Integrator(minStep, maxStep, new double[2], new double[4]);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        Assert.fail("an exception should have been thrown");      } catch (DimensionMismatchException ie) {        // expected behavior      }      try {        FirstOrderIntegrator integ =            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[2]);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        Assert.fail("an exception should have been thrown");      } catch (DimensionMismatchException ie) {        // expected behavior      }      try {        FirstOrderIntegrator integ =            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getInitialTime(), new double[pb.getDimension()]);        Assert.fail("an exception should have been thrown");      } catch (NumberIsTooSmallException ie) {        // expected behavior      }  }  @Test  public void testKepler()    {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double[] vecAbsoluteTolerance = { 1.0e-8, 1.0e-8, 1.0e-10, 1.0e-10 };    double[] vecRelativeTolerance = { 1.0e-10, 1.0e-10, 1.0e-8, 1.0e-8 };    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                            vecAbsoluteTolerance,                                                            vecRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb, integ);     integ.addStepHandler(handler);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertEquals(0.0, handler.getMaximalValueError(), 1.5e-4);    Assert.assertEquals("Higham-Hall 5(4)", integ.getName());  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.TestProblem4;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class DormandPrince853IntegratorTest {  @Test  public void testMissedEndEvent() {      final double   t0     = 1878250320.0000029;      final double   tEvent = 1878250379.9999986;      final double[] k  = { 1.0e-4, 1.0e-5, 1.0e-6 };      FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {          public int getDimension() {              return k.length;          }          public void computeDerivatives(double t, double[] y, double[] yDot) {              for (int i = 0; i < y.length; ++i) {                  yDot[i] = k[i] * y[i];              }          }      };      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 100.0,                                                                             1.0e-10, 1.0e-10);      double[] y0   = new double[k.length];      for (int i = 0; i < y0.length; ++i) {          y0[i] = i + 1;      }      double[] y    = new double[k.length];      integrator.setInitialStepSize(60.0);      double finalT = integrator.integrate(ode, t0, y0, tEvent, y);      Assert.assertEquals(tEvent, finalT, 5.0e-6);      for (int i = 0; i < y.length; ++i) {          Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);      }      integrator.setInitialStepSize(60.0);      integrator.addEventHandler(new EventHandler() {          public void resetState(double t, double[] y) {          }          public double g(double t, double[] y) {              return t - tEvent;          }          public int eventOccurred(double t, double[] y, boolean increasing) {              Assert.assertEquals(tEvent, t, 5.0e-6);              return CONTINUE;          }      }, Double.POSITIVE_INFINITY, 1.0e-20, 100);      finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);      Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);      for (int i = 0; i < y.length; ++i) {          Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);      }  }  @Test(expected=DimensionMismatchException.class)  public void testDimensionCheck() {      TestProblem1 pb = new TestProblem1();      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,                                                                             1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()+10],                           1.0, new double[pb.getDimension()+10]);      Assert.fail("an exception should have been thrown");  }  @Test(expected=NumberIsTooSmallException.class)  public void testNullIntervalCheck() {      TestProblem1 pb = new TestProblem1();      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,                                                                             1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()],                           0.0, new double[pb.getDimension()]);      Assert.fail("an exception should have been thrown");  }  @Test(expected=NumberIsTooSmallException.class)  public void testMinStep() {      TestProblem1 pb = new TestProblem1();      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                  vecAbsoluteTolerance,                                                                  vecRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      Assert.fail("an exception should have been thrown");  }  @Test  public void testIncreasingTolerance()    {    int previousCalls = Integer.MAX_VALUE;    AdaptiveStepsizeIntegrator integ =        new DormandPrince853Integrator(0, Double.POSITIVE_INFINITY,                                       Double.NaN, Double.NaN);    for (int i = -12; i < -2; ++i) {      TestProblem1 pb = new TestProblem1();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = FastMath.pow(10.0, i);      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      integ.setStepSizeControl(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      // the 1.3 factor is only valid for this test      // and has been obtained from trial and error      // there is no general relation between local and global errors      Assert.assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      int calls = pb.getCalls();      Assert.assertEquals(integ.getEvaluations(), calls);      Assert.assertTrue(calls <= previousCalls);      previousCalls = calls;    }  }  @Test  public void testBackward()      {      TestProblem5 pb = new TestProblem5();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                  scalAbsoluteTolerance,                                                                  scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() < 1.1e-7);      Assert.assertTrue(handler.getMaximalValueError() < 1.1e-7);      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      Assert.assertEquals("Dormand-Prince 8 (5, 3)", integ.getName());  }  @Test  public void testEvents()    {    TestProblem4 pb = new TestProblem4();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-9;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                scalAbsoluteTolerance,                                                                scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    EventHandler[] functions = pb.getEventsHandlers();    double convergence = 1.0e-8 * maxStep;    for (int l = 0; l < functions.length; ++l) {      integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, convergence, 1000);    }    Assert.assertEquals(functions.length, integ.getEventHandlers().size());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertEquals(0, handler.getMaximalValueError(), 2.1e-7);    Assert.assertEquals(0, handler.getMaximalTimeError(), convergence);    Assert.assertEquals(12.0, handler.getLastTime(), convergence);    integ.clearEventHandlers();    Assert.assertEquals(0, integ.getEventHandlers().size());  }  @Test  public void testKepler()    {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                scalAbsoluteTolerance,                                                                scalRelativeTolerance);    integ.addStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertEquals(integ.getEvaluations(), pb.getCalls());    Assert.assertTrue(pb.getCalls() < 3300);  }  @Test  public void testVariableSteps()    {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);    integ.addStepHandler(new VariableHandler());    double stopTime = integ.integrate(pb,                                      pb.getInitialTime(), pb.getInitialState(),                                      pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);    Assert.assertEquals("Dormand-Prince 8 (5, 3)", integ.getName());  }  @Test  public void testUnstableDerivative()  {    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);    FirstOrderIntegrator integ =      new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0);    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);    double[] y = { Double.NaN };    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);    Assert.assertEquals(8.0, y[0], 1.0e-12);  }  private static class KeplerHandler implements StepHandler {    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public void reset() {      nbSteps = 0;      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast)    throws MathUserException {      ++nbSteps;      for (int a = 1; a < 10; ++a) {        double prev   = interpolator.getPreviousTime();        double curr   = interpolator.getCurrentTime();        double interp = ((10 - a) * prev + a * curr) / 10;        interpolator.setInterpolatedTime(interp);        double[] interpolatedY = interpolator.getInterpolatedState ();        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());        double dx = interpolatedY[0] - theoreticalY[0];        double dy = interpolatedY[1] - theoreticalY[1];        double error = dx * dx + dy * dy;        if (error > maxError) {          maxError = error;        }      }      if (isLast) {        Assert.assertTrue(maxError < 2.4e-10);        Assert.assertTrue(nbSteps < 150);      }    }    private int nbSteps;    private double maxError;    private TestProblem3 pb;  }  private static class VariableHandler implements StepHandler {    public VariableHandler() {      reset();    }    public void reset() {      firstTime = true;      minStep = 0;      maxStep = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) {      double step = FastMath.abs(interpolator.getCurrentTime()                             - interpolator.getPreviousTime());      if (firstTime) {        minStep   = FastMath.abs(step);        maxStep   = minStep;        firstTime = false;      } else {        if (step < minStep) {          minStep = step;        }        if (step > maxStep) {          maxStep = step;        }      }      if (isLast) {        Assert.assertTrue(minStep < (1.0 / 100.0));        Assert.assertTrue(maxStep > (1.0 / 2.0));      }    }    private boolean firstTime = true;    private double  minStep = 0;    private double  maxStep = 0;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemAbstract;import org.apache.commons.math.ode.TestProblemFactory;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class MidpointIntegratorTest {  @Test(expected=DimensionMismatchException.class)  public void testDimensionCheck() {      TestProblem1 pb = new TestProblem1();      new MidpointIntegrator(0.01).integrate(pb,                                             0.0, new double[pb.getDimension()+10],                                             1.0, new double[pb.getDimension()+10]);        Assert.fail("an exception should have been thrown");  }  @Test  public void testDecreasingSteps()     {    TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousValueError = Double.NaN;      double previousTimeError = Double.NaN;      for (int i = 4; i < 10; ++i) {        TestProblemAbstract pb = problems[k].copy();        double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i);        FirstOrderIntegrator integ = new MidpointIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        EventHandler[] functions = pb.getEventsHandlers();        for (int l = 0; l < functions.length; ++l) {          integ.addEventHandler(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);        }        double stopTime = integ.integrate(pb,                                          pb.getInitialTime(), pb.getInitialState(),                                          pb.getFinalTime(), new double[pb.getDimension()]);        if (functions.length == 0) {            Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);        }        double valueError = handler.getMaximalValueError();        if (i > 4) {          Assert.assertTrue(valueError < FastMath.abs(previousValueError));        }        previousValueError = valueError;        double timeError = handler.getMaximalTimeError();        if (i > 4) {          Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));        }        previousTimeError = timeError;      }    }  }  @Test  public void testSmallStep()    {    TestProblem1 pb  = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new MidpointIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertTrue(handler.getLastError() < 2.0e-7);    Assert.assertTrue(handler.getMaximalValueError() < 1.0e-6);    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    Assert.assertEquals("midpoint", integ.getName());  }  @Test  public void testBigStep()    {    TestProblem1 pb  = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new MidpointIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertTrue(handler.getLastError() > 0.01);    Assert.assertTrue(handler.getMaximalValueError() > 0.05);    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);  }  @Test  public void testBackward()      {      TestProblem5 pb = new TestProblem5();      double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new MidpointIntegrator(step);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() < 6.0e-4);      Assert.assertTrue(handler.getMaximalValueError() < 6.0e-4);      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      Assert.assertEquals("midpoint", integ.getName());  }  @Test  public void testStepSize()    {      final double step = 1.23456;      FirstOrderIntegrator integ = new MidpointIntegrator(step);      integ.addStepHandler(new StepHandler() {          public void handleStep(StepInterpolator interpolator, boolean isLast) {              if (! isLast) {                  Assert.assertEquals(step,                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),                               1.0e-12);              }          }          public void reset() {          }      });      integ.integrate(new FirstOrderDifferentialEquations() {          public void computeDerivatives(double t, double[] y, double[] dot) {              dot[0] = 1.0;          }          public int getDimension() {              return 1;          }      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.TestProblem4;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemAbstract;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class DormandPrince54IntegratorTest {  @Test(expected=DimensionMismatchException.class)  public void testDimensionCheck() {      TestProblem1 pb = new TestProblem1();      DormandPrince54Integrator integrator = new DormandPrince54Integrator(0.0, 1.0,                                                                           1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()+10],                           1.0, new double[pb.getDimension()+10]);  }  @Test(expected=NumberIsTooSmallException.class)  public void testMinStep() {      TestProblem1 pb = new TestProblem1();      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                 vecAbsoluteTolerance,                                                                 vecRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      Assert.fail("an exception should have been thrown");  }  @Test  public void testSmallLastStep()    {    TestProblemAbstract pb = new TestProblem5();    double minStep = 1.25;    double maxStep = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());    double scalAbsoluteTolerance = 6.0e-4;    double scalRelativeTolerance = 6.0e-4;    AdaptiveStepsizeIntegrator integ =      new DormandPrince54Integrator(minStep, maxStep,                                    scalAbsoluteTolerance,                                    scalRelativeTolerance);    DP54SmallLastHandler handler = new DP54SmallLastHandler(minStep);    integ.addStepHandler(handler);    integ.setInitialStepSize(1.7);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertTrue(handler.wasLastSeen());    Assert.assertEquals("Dormand-Prince 5(4)", integ.getName());  }  @Test  public void testBackward()      {      TestProblem5 pb = new TestProblem5();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                 scalAbsoluteTolerance,                                                                 scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() < 2.0e-7);      Assert.assertTrue(handler.getMaximalValueError() < 2.0e-7);      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      Assert.assertEquals("Dormand-Prince 5(4)", integ.getName());  }  private static class DP54SmallLastHandler implements StepHandler {    public DP54SmallLastHandler(double minStep) {      lastSeen = false;      this.minStep = minStep;    }    public void reset() {    }    public void handleStep(StepInterpolator interpolator, boolean isLast) {      if (isLast) {        lastSeen = true;        double h = interpolator.getCurrentTime() - interpolator.getPreviousTime();        Assert.assertTrue(FastMath.abs(h) < minStep);      }    }    public boolean wasLastSeen() {      return lastSeen;    }    private boolean lastSeen;    private double  minStep;  }  @Test  public void testIncreasingTolerance()    {    int previousCalls = Integer.MAX_VALUE;    for (int i = -12; i < -2; ++i) {      TestProblem1 pb = new TestProblem1();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = FastMath.pow(10.0, i);      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      EmbeddedRungeKuttaIntegrator integ =          new DormandPrince54Integrator(minStep, maxStep,                                        scalAbsoluteTolerance, scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.setSafety(0.8);      integ.setMaxGrowth(5.0);      integ.setMinReduction(0.3);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertEquals(0.8, integ.getSafety(), 1.0e-12);      Assert.assertEquals(5.0, integ.getMaxGrowth(), 1.0e-12);      Assert.assertEquals(0.3, integ.getMinReduction(), 1.0e-12);      // the 0.7 factor is only valid for this test      // and has been obtained from trial and error      // there is no general relation between local and global errors      Assert.assertTrue(handler.getMaximalValueError() < (0.7 * scalAbsoluteTolerance));      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      int calls = pb.getCalls();      Assert.assertEquals(integ.getEvaluations(), calls);      Assert.assertTrue(calls <= previousCalls);      previousCalls = calls;    }  }  @Test  public void testEvents()    {    TestProblem4 pb = new TestProblem4();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    EventHandler[] functions = pb.getEventsHandlers();    double convergence = 1.0e-8 * maxStep;    for (int l = 0; l < functions.length; ++l) {      integ.addEventHandler(functions[l],                                 Double.POSITIVE_INFINITY, convergence, 1000);    }    Assert.assertEquals(functions.length, integ.getEventHandlers().size());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertTrue(handler.getMaximalValueError() < 5.0e-6);    Assert.assertEquals(0, handler.getMaximalTimeError(), convergence);    Assert.assertEquals(12.0, handler.getLastTime(), convergence);    integ.clearEventHandlers();    Assert.assertEquals(0, integ.getEventHandlers().size());  }  @Test  public void testKepler()    {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);    integ.addStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertEquals(integ.getEvaluations(), pb.getCalls());    Assert.assertTrue(pb.getCalls() < 2800);  }  @Test  public void testVariableSteps()    {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);    integ.addStepHandler(new VariableHandler());    double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                      pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);  }  private static class KeplerHandler implements StepHandler {    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public void reset() {      nbSteps = 0;      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast)    throws MathUserException {      ++nbSteps;      for (int a = 1; a < 10; ++a) {        double prev   = interpolator.getPreviousTime();        double curr   = interpolator.getCurrentTime();        double interp = ((10 - a) * prev + a * curr) / 10;        interpolator.setInterpolatedTime(interp);        double[] interpolatedY = interpolator.getInterpolatedState ();        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());        double dx = interpolatedY[0] - theoreticalY[0];        double dy = interpolatedY[1] - theoreticalY[1];        double error = dx * dx + dy * dy;        if (error > maxError) {          maxError = error;        }      }      if (isLast) {        Assert.assertTrue(maxError < 7.0e-10);        Assert.assertTrue(nbSteps < 400);      }    }    private int nbSteps;    private double maxError;    private TestProblem3 pb;  }  private static class VariableHandler implements StepHandler {    public VariableHandler() {      firstTime = true;      minStep = 0;      maxStep = 0;    }    public void reset() {      firstTime = true;      minStep = 0;      maxStep = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) {      double step = FastMath.abs(interpolator.getCurrentTime()                             - interpolator.getPreviousTime());      if (firstTime) {        minStep   = FastMath.abs(step);        maxStep   = minStep;        firstTime = false;      } else {        if (step < minStep) {          minStep = step;        }        if (step > maxStep) {          maxStep = step;        }      }      if (isLast) {        Assert.assertTrue(minStep < (1.0 / 450.0));        Assert.assertTrue(maxStep > (1.0 / 4.2));      }    }    private boolean firstTime;    private double  minStep;    private double  maxStep;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.junit.Assert;import org.junit.Test;public class ClassicalRungeKuttaStepInterpolatorTest {  @Test  public void derivativesConsistency()  {    TestProblem3 pb = new TestProblem3();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    Assert.assertTrue(bos.size () > 753000);    Assert.assertTrue(bos.size () < 754000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    Assert.assertTrue(maxError > 0.005);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class DormandPrince54StepInterpolatorTest {  @Test  public void derivativesConsistency()  {    TestProblem3 pb = new TestProblem3(0.1);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                    scalAbsoluteTolerance,                                                                    scalRelativeTolerance);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                    scalAbsoluteTolerance,                                                                    scalRelativeTolerance);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    Assert.assertTrue(bos.size () > 126000);    Assert.assertTrue(bos.size () < 127000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    Assert.assertTrue(maxError < 7.0e-10);  }  @Test  public void checkClone()    {      TestProblem3 pb = new TestProblem3(0.9);      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = scalAbsoluteTolerance;      DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                      scalAbsoluteTolerance,                                                                      scalRelativeTolerance);      integ.addStepHandler(new StepHandler() {        public void handleStep(StepInterpolator interpolator, boolean isLast)          throws MathUserException {              StepInterpolator cloned = interpolator.copy();              double tA = cloned.getPreviousTime();              double tB = cloned.getCurrentTime();              double halfStep = FastMath.abs(tB - tA) / 2;              Assert.assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);              Assert.assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);              for (int i = 0; i < 10; ++i) {                  double t = (i * tB + (9 - i) * tA) / 9;                  interpolator.setInterpolatedTime(t);                  Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));                  cloned.setInterpolatedTime(t);                  Assert.assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);                  double[] referenceState = interpolator.getInterpolatedState();                  double[] cloneState     = cloned.getInterpolatedState();                  for (int j = 0; j < referenceState.length; ++j) {                      Assert.assertEquals(referenceState[j], cloneState[j], 1.0e-12);                  }              }          }          public void reset() {          }      });      integ.integrate(pb,              pb.getInitialTime(), pb.getInitialState(),              pb.getFinalTime(), new double[pb.getDimension()]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblem6;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class AdamsBashforthIntegratorTest {    @Test(expected=DimensionMismatchException.class)    public void dimensionCheck() {        TestProblem1 pb = new TestProblem1();        FirstOrderIntegrator integ =            new AdamsBashforthIntegrator(2, 0.0, 1.0, 1.0e-10, 1.0e-10);        integ.integrate(pb,                        0.0, new double[pb.getDimension()+10],                        1.0, new double[pb.getDimension()+10]);    }    @Test(expected=NumberIsTooSmallException.class)    public void testMinStep() {          TestProblem1 pb = new TestProblem1();          double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());          double maxStep = pb.getFinalTime() - pb.getInitialTime();          double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };          double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };          FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, minStep, maxStep,                                                                    vecAbsoluteTolerance,                                                                    vecRelativeTolerance);          TestProblemHandler handler = new TestProblemHandler(pb, integ);          integ.addStepHandler(handler);          integ.integrate(pb,                          pb.getInitialTime(), pb.getInitialState(),                          pb.getFinalTime(), new double[pb.getDimension()]);    }    @Test    public void testIncreasingTolerance()        {        int previousCalls = Integer.MAX_VALUE;        for (int i = -12; i < -5; ++i) {            TestProblem1 pb = new TestProblem1();            double minStep = 0;            double maxStep = pb.getFinalTime() - pb.getInitialTime();            double scalAbsoluteTolerance = FastMath.pow(10.0, i);            double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;            FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, minStep, maxStep,                                                                      scalAbsoluteTolerance,                                                                      scalRelativeTolerance);            TestProblemHandler handler = new TestProblemHandler(pb, integ);            integ.addStepHandler(handler);            integ.integrate(pb,                            pb.getInitialTime(), pb.getInitialState(),                            pb.getFinalTime(), new double[pb.getDimension()]);            // the 50 and 300 factors are only valid for this test            // and has been obtained from trial and error            // there is no general relation between local and global errors            Assert.assertTrue(handler.getMaximalValueError() > (50.0 * scalAbsoluteTolerance));            Assert.assertTrue(handler.getMaximalValueError() < (300.0 * scalAbsoluteTolerance));            Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);            int calls = pb.getCalls();            Assert.assertEquals(integ.getEvaluations(), calls);            Assert.assertTrue(calls <= previousCalls);            previousCalls = calls;        }    }    @Test(expected = MathUserException.class)    public void exceedMaxEvaluations() {        TestProblem1 pb  = new TestProblem1();        double range = pb.getFinalTime() - pb.getInitialTime();        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(2, 0, range, 1.0e-12, 1.0e-12);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        integ.setMaxEvaluations(650);        integ.integrate(pb,                        pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);    }    @Test    public void backward() {        TestProblem5 pb = new TestProblem5();        double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());        FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, 0, range, 1.0e-12, 1.0e-12);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        Assert.assertTrue(handler.getLastError() < 1.5e-8);        Assert.assertTrue(handler.getMaximalValueError() < 1.5e-8);        Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);        Assert.assertEquals("Adams-Bashforth", integ.getName());    }    @Test    public void polynomial() {        TestProblem6 pb = new TestProblem6();        double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());        for (int nSteps = 2; nSteps < 8; ++nSteps) {            AdamsBashforthIntegrator integ =                new AdamsBashforthIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-5, 1.0e-5);            TestProblemHandler handler = new TestProblemHandler(pb, integ);            integ.addStepHandler(handler);            integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                            pb.getFinalTime(), new double[pb.getDimension()]);            if (nSteps < 4) {                Assert.assertTrue(handler.getMaximalValueError() > 1.0e-03);            } else {                Assert.assertTrue(handler.getMaximalValueError() < 4.0e-12);            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class EulerStepInterpolatorTest {  @Test  public void noReset() {    double[]   y    =   { 0.0, 1.0, -2.0 };    double[][] yDot = { { 1.0, 2.0, -2.0 } };    EulerStepInterpolator interpolator = new EulerStepInterpolator();    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    double[] result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {      Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);    }  }  @Test  public void interpolationAtBounds()    throws MathUserException {    double   t0 = 0;    double[] y0 = {0.0, 1.0, -2.0};    double[] y = y0.clone();    double[][] yDot = { new double[y0.length] };    EulerStepInterpolator interpolator = new EulerStepInterpolator();    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);    interpolator.storeTime(t0);    double dt = 1.0;    y[0] =  1.0;    y[1] =  3.0;    y[2] = -4.0;    yDot[0][0] = (y[0] - y0[0]) / dt;    yDot[0][1] = (y[1] - y0[1]) / dt;    yDot[0][2] = (y[2] - y0[2]) / dt;    interpolator.shift();    interpolator.storeTime(t0 + dt);    interpolator.setInterpolatedTime(interpolator.getPreviousTime());    double[] result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {      Assert.assertTrue(FastMath.abs(result[i] - y0[i]) < 1.0e-10);    }    interpolator.setInterpolatedTime(interpolator.getCurrentTime());    result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {      Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);    }  }  @Test  public void interpolationInside()  throws MathUserException {    double[]   y    =   { 1.0, 3.0, -4.0 };    double[][] yDot = { { 1.0, 2.0, -2.0 } };    EulerStepInterpolator interpolator = new EulerStepInterpolator();    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    interpolator.setInterpolatedTime(0.1);    double[] result = interpolator.getInterpolatedState();    Assert.assertTrue(FastMath.abs(result[0] - 0.1) < 1.0e-10);    Assert.assertTrue(FastMath.abs(result[1] - 1.2) < 1.0e-10);    Assert.assertTrue(FastMath.abs(result[2] + 2.2) < 1.0e-10);    interpolator.setInterpolatedTime(0.5);    result = interpolator.getInterpolatedState();    Assert.assertTrue(FastMath.abs(result[0] - 0.5) < 1.0e-10);    Assert.assertTrue(FastMath.abs(result[1] - 2.0) < 1.0e-10);    Assert.assertTrue(FastMath.abs(result[2] + 3.0) < 1.0e-10);  }  @Test  public void derivativesConsistency()  {    TestProblem3 pb = new TestProblem3();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    EulerIntegrator integ = new EulerIntegrator(step);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws IOException, ClassNotFoundException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    EulerIntegrator integ = new EulerIntegrator(step);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    Assert.assertTrue(maxError < 0.001);  }  private static class DummyIntegrator extends RungeKuttaIntegrator {      protected DummyIntegrator(RungeKuttaStepInterpolator prototype) {          super("dummy", new double[0], new double[0][0], new double[0], prototype, Double.NaN);      }  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemAbstract;import org.apache.commons.math.ode.TestProblemFactory;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class ClassicalRungeKuttaIntegratorTest {  @Test  public void testMissedEndEvent() {      final double   t0     = 1878250320.0000029;      final double   tEvent = 1878250379.9999986;      final double[] k      = { 1.0e-4, 1.0e-5, 1.0e-6 };      FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {          public int getDimension() {              return k.length;          }          public void computeDerivatives(double t, double[] y, double[] yDot) {              for (int i = 0; i < y.length; ++i) {                  yDot[i] = k[i] * y[i];              }          }      };      ClassicalRungeKuttaIntegrator integrator = new ClassicalRungeKuttaIntegrator(60.0);      double[] y0   = new double[k.length];      for (int i = 0; i < y0.length; ++i) {          y0[i] = i + 1;      }      double[] y    = new double[k.length];      double finalT = integrator.integrate(ode, t0, y0, tEvent, y);      Assert.assertEquals(tEvent, finalT, 5.0e-6);      for (int i = 0; i < y.length; ++i) {          Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);      }      integrator.addEventHandler(new EventHandler() {          public void resetState(double t, double[] y) {          }          public double g(double t, double[] y) {              return t - tEvent;          }          public int eventOccurred(double t, double[] y, boolean increasing) {              Assert.assertEquals(tEvent, t, 5.0e-6);              return CONTINUE;          }      }, Double.POSITIVE_INFINITY, 1.0e-20, 100);      finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);      Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);      for (int i = 0; i < y.length; ++i) {          Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);      }  }  @Test  public void testSanityChecks() {    try  {      TestProblem1 pb = new TestProblem1();      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,                                                        0.0, new double[pb.getDimension()+10],                                                        1.0, new double[pb.getDimension()]);        Assert.fail("an exception should have been thrown");    } catch(DimensionMismatchException ie) {    }    try  {        TestProblem1 pb = new TestProblem1();        new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,                                                          0.0, new double[pb.getDimension()],                                                          1.0, new double[pb.getDimension()+10]);          Assert.fail("an exception should have been thrown");      } catch(DimensionMismatchException ie) {      }    try  {      TestProblem1 pb = new TestProblem1();      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,                                                        0.0, new double[pb.getDimension()],                                                        0.0, new double[pb.getDimension()]);        Assert.fail("an exception should have been thrown");    } catch(NumberIsTooSmallException ie) {    }  }  @Test  public void testDecreasingSteps()     {    TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousValueError = Double.NaN;      double previousTimeError = Double.NaN;      for (int i = 4; i < 10; ++i) {        TestProblemAbstract pb = problems[k].copy();        double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i);        FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        EventHandler[] functions = pb.getEventsHandlers();        for (int l = 0; l < functions.length; ++l) {          integ.addEventHandler(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);        }        Assert.assertEquals(functions.length, integ.getEventHandlers().size());        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                          pb.getFinalTime(), new double[pb.getDimension()]);        if (functions.length == 0) {            Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);        }        double error = handler.getMaximalValueError();        if (i > 4) {          Assert.assertTrue(error < FastMath.abs(previousValueError));        }        previousValueError = error;        double timeError = handler.getMaximalTimeError();        if (i > 4) {          Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));        }        previousTimeError = timeError;        integ.clearEventHandlers();        Assert.assertEquals(0, integ.getEventHandlers().size());      }    }  }  @Test  public void testSmallStep()    {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertTrue(handler.getLastError() < 2.0e-13);    Assert.assertTrue(handler.getMaximalValueError() < 4.0e-12);    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    Assert.assertEquals("classical Runge-Kutta", integ.getName());  }  @Test  public void testBigStep()    {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertTrue(handler.getLastError() > 0.0004);    Assert.assertTrue(handler.getMaximalValueError() > 0.005);    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);  }  @Test  public void testBackward()    {    TestProblem5 pb = new TestProblem5();    double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertTrue(handler.getLastError() < 5.0e-10);    Assert.assertTrue(handler.getMaximalValueError() < 7.0e-10);    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    Assert.assertEquals("classical Runge-Kutta", integ.getName());  }  @Test  public void testKepler()    {    final TestProblem3 pb  = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    integ.addStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);  }  private static class KeplerHandler implements StepHandler {    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public void reset() {      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) throws MathUserException {      double[] interpolatedY = interpolator.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }      if (isLast) {        // even with more than 1000 evaluations per period,        // RK4 is not able to integrate such an eccentric        // orbit with a good accuracy        Assert.assertTrue(maxError > 0.005);      }    }    private double maxError = 0;    private TestProblem3 pb;  }  @Test  public void testStepSize()    {      final double step = 1.23456;      FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);      integ.addStepHandler(new StepHandler() {          public void handleStep(StepInterpolator interpolator, boolean isLast) {              if (! isLast) {                  Assert.assertEquals(step,                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),                               1.0e-12);              }          }          public void reset() {          }      });      integ.integrate(new FirstOrderDifferentialEquations() {          public void computeDerivatives(double t, double[] y, double[] dot) {              dot[0] = 1.0;          }          public int getDimension() {              return 1;          }      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.junit.Assert;import org.junit.Test;public class MidpointStepInterpolatorTest {  @Test  public void testDerivativesConsistency()  {    TestProblem3 pb = new TestProblem3();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    MidpointIntegrator integ = new MidpointIntegrator(step);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws IOException, ClassNotFoundException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    MidpointIntegrator integ = new MidpointIntegrator(step);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    Assert.assertTrue(bos.size () > 114000);    Assert.assertTrue(bos.size () < 115000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    Assert.assertTrue(maxError < 1.0e-6);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.TestProblem4;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemAbstract;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class GraggBulirschStoerIntegratorTest {  @Test(expected=DimensionMismatchException.class)  public void testDimensionCheck() {      TestProblem1 pb = new TestProblem1();      AdaptiveStepsizeIntegrator integrator =        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()+10],                           1.0, new double[pb.getDimension()+10]);  }  @Test(expected=NumberIsTooSmallException.class)  public void testNullIntervalCheck() {      TestProblem1 pb = new TestProblem1();      GraggBulirschStoerIntegrator integrator =        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()],                           0.0, new double[pb.getDimension()]);  }  @Test(expected=NumberIsTooSmallException.class)  public void testMinStep() {      TestProblem5 pb  = new TestProblem5();      double minStep   = 0.1 * FastMath.abs(pb.getFinalTime() - pb.getInitialTime());      double maxStep   = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());      double[] vecAbsoluteTolerance = { 1.0e-20, 1.0e-21 };      double[] vecRelativeTolerance = { 1.0e-20, 1.0e-21 };      FirstOrderIntegrator integ =        new GraggBulirschStoerIntegrator(minStep, maxStep,                                         vecAbsoluteTolerance, vecRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);  }  @Test  public void testBackward()      {      TestProblem5 pb = new TestProblem5();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,                                                                    scalAbsoluteTolerance,                                                                    scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() < 7.5e-9);      Assert.assertTrue(handler.getMaximalValueError() < 8.1e-9);      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      Assert.assertEquals("Gragg-Bulirsch-Stoer", integ.getName());  }  @Test  public void testIncreasingTolerance()    {    int previousCalls = Integer.MAX_VALUE;    for (int i = -12; i < -4; ++i) {      TestProblem1 pb     = new TestProblem1();      double minStep      = 0;      double maxStep      = pb.getFinalTime() - pb.getInitialTime();      double absTolerance = FastMath.pow(10.0, i);      double relTolerance = absTolerance;      FirstOrderIntegrator integ =        new GraggBulirschStoerIntegrator(minStep, maxStep,                                         absTolerance, relTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      // the coefficients are only valid for this test      // and have been obtained from trial and error      // there is no general relation between local and global errors      double ratio =  handler.getMaximalValueError() / absTolerance;      Assert.assertTrue(ratio < 2.4);      Assert.assertTrue(ratio > 0.02);      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      int calls = pb.getCalls();      Assert.assertEquals(integ.getEvaluations(), calls);      Assert.assertTrue(calls <= previousCalls);      previousCalls = calls;    }  }  @Test  public void testIntegratorControls()  {    TestProblem3 pb = new TestProblem3(0.999);    GraggBulirschStoerIntegrator integ =        new GraggBulirschStoerIntegrator(0, pb.getFinalTime() - pb.getInitialTime(),                1.0e-8, 1.0e-10);    double errorWithDefaultSettings = getMaxError(integ, pb);    // stability control    integ.setStabilityCheck(true, 2, 1, 0.99);    Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));    integ.setStabilityCheck(true, -1, -1, -1);    integ.setStepsizeControl(0.5, 0.99, 0.1, 2.5);    Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));    integ.setStepsizeControl(-1, -1, -1, -1);    integ.setOrderControl(10, 0.7, 0.95);    Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));    integ.setOrderControl(-1, -1, -1);    integ.setInterpolationControl(true, 3);    Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));    integ.setInterpolationControl(true, -1);  }  private double getMaxError(FirstOrderIntegrator integrator, TestProblemAbstract pb)    {      TestProblemHandler handler = new TestProblemHandler(pb, integrator);      integrator.addStepHandler(handler);      integrator.integrate(pb,                           pb.getInitialTime(), pb.getInitialState(),                           pb.getFinalTime(), new double[pb.getDimension()]);      return handler.getMaximalValueError();  }  @Test  public void testEvents()    {    TestProblem4 pb = new TestProblem4();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-10;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,                                                                  scalAbsoluteTolerance,                                                                  scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    EventHandler[] functions = pb.getEventsHandlers();    double convergence = 1.0e-8 * maxStep;    for (int l = 0; l < functions.length; ++l) {      integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, convergence, 1000);    }    Assert.assertEquals(functions.length, integ.getEventHandlers().size());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertTrue(handler.getMaximalValueError() < 4.0e-7);    Assert.assertEquals(0, handler.getMaximalTimeError(), convergence);    Assert.assertEquals(12.0, handler.getLastTime(), convergence);    integ.clearEventHandlers();    Assert.assertEquals(0, integ.getEventHandlers().size());  }  @Test  public void testKepler()    {    final TestProblem3 pb = new TestProblem3(0.9);    double minStep        = 0;    double maxStep        = pb.getFinalTime() - pb.getInitialTime();    double absTolerance   = 1.0e-6;    double relTolerance   = 1.0e-6;    FirstOrderIntegrator integ =      new GraggBulirschStoerIntegrator(minStep, maxStep,                                       absTolerance, relTolerance);    integ.addStepHandler(new KeplerStepHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertEquals(integ.getEvaluations(), pb.getCalls());    Assert.assertTrue(pb.getCalls() < 2150);  }  @Test  public void testVariableSteps()    {    final TestProblem3 pb = new TestProblem3(0.9);    double minStep        = 0;    double maxStep        = pb.getFinalTime() - pb.getInitialTime();    double absTolerance   = 1.0e-8;    double relTolerance   = 1.0e-8;    FirstOrderIntegrator integ =      new GraggBulirschStoerIntegrator(minStep, maxStep,                                       absTolerance, relTolerance);    integ.addStepHandler(new VariableStepHandler());    double stopTime = integ.integrate(pb,                                      pb.getInitialTime(), pb.getInitialState(),                                      pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);    Assert.assertEquals("Gragg-Bulirsch-Stoer", integ.getName());  }  @Test  public void testUnstableDerivative()    {    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);    FirstOrderIntegrator integ =      new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0);    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);    double[] y = { Double.NaN };    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);    Assert.assertEquals(8.0, y[0], 1.0e-12);  }  @Test  public void testIssue596() {    FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(1e-10, 100.0, 1e-7, 1e-7);      integ.addStepHandler(new StepHandler() {          public void reset() {}          public void handleStep(StepInterpolator interpolator, boolean isLast) throws MathUserException {              double t = interpolator.getCurrentTime();              interpolator.setInterpolatedTime(t);              double[] y = interpolator.getInterpolatedState();              double[] yDot = interpolator.getInterpolatedDerivatives();              Assert.assertEquals(3.0 * t - 5.0, y[0], 1.0e-14);              Assert.assertEquals(3.0, yDot[0], 1.0e-14);          }      });      double[] y = {4.0};      double t0 = 3.0;      double tend = 10.0;      integ.integrate(new FirstOrderDifferentialEquations() {          public int getDimension() {              return 1;          }          public void computeDerivatives(double t, double[] y, double[] yDot) {              yDot[0] = 3.0;          }      }, t0, y, tend, y);  }  private static class KeplerStepHandler implements StepHandler {    public KeplerStepHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public void reset() {      nbSteps = 0;      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast)    throws MathUserException {      ++nbSteps;      for (int a = 1; a < 100; ++a) {        double prev   = interpolator.getPreviousTime();        double curr   = interpolator.getCurrentTime();        double interp = ((100 - a) * prev + a * curr) / 100;        interpolator.setInterpolatedTime(interp);        double[] interpolatedY = interpolator.getInterpolatedState ();        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());        double dx = interpolatedY[0] - theoreticalY[0];        double dy = interpolatedY[1] - theoreticalY[1];        double error = dx * dx + dy * dy;        if (error > maxError) {          maxError = error;        }      }      if (isLast) {        Assert.assertTrue(maxError < 2.7e-6);        Assert.assertTrue(nbSteps < 80);      }    }    private int nbSteps;    private double maxError;    private TestProblem3 pb;  }  public static class VariableStepHandler implements StepHandler {    public VariableStepHandler() {      reset();    }    public void reset() {      firstTime = true;      minStep = 0;      maxStep = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) {      double step = FastMath.abs(interpolator.getCurrentTime()                             - interpolator.getPreviousTime());      if (firstTime) {        minStep   = FastMath.abs(step);        maxStep   = minStep;        firstTime = false;      } else {        if (step < minStep) {          minStep = step;        }        if (step > maxStep) {          maxStep = step;        }      }      if (isLast) {        Assert.assertTrue(minStep < 8.2e-3);        Assert.assertTrue(maxStep > 1.5);      }    }    private boolean firstTime;    private double  minStep;    private double  maxStep;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class GraggBulirschStoerStepInterpolatorTest {  @Test  public void derivativesConsistency()  {    TestProblem3 pb = new TestProblem3(0.9);    double minStep   = 0;    double maxStep   = pb.getFinalTime() - pb.getInitialTime();    double absTolerance = 1.0e-8;    double relTolerance = 1.0e-8;    GraggBulirschStoerIntegrator integ =      new GraggBulirschStoerIntegrator(minStep, maxStep,                                       absTolerance, relTolerance);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-8);  }  @Test  public void serialization()    throws IOException, ClassNotFoundException {    TestProblem3 pb  = new TestProblem3(0.9);    double minStep   = 0;    double maxStep   = pb.getFinalTime() - pb.getInitialTime();    double absTolerance = 1.0e-8;    double relTolerance = 1.0e-8;    GraggBulirschStoerIntegrator integ =      new GraggBulirschStoerIntegrator(minStep, maxStep,                                       absTolerance, relTolerance);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    Assert.assertTrue(bos.size () > 34000);    Assert.assertTrue(bos.size () < 35000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    Assert.assertTrue(maxError < 5.0e-10);  }  @Test  public void checklone()  {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,                                                                          scalAbsoluteTolerance,                                                                          scalRelativeTolerance);    integ.addStepHandler(new StepHandler() {        public void handleStep(StepInterpolator interpolator, boolean isLast)        throws MathUserException {            StepInterpolator cloned = interpolator.copy();            double tA = cloned.getPreviousTime();            double tB = cloned.getCurrentTime();            double halfStep = FastMath.abs(tB - tA) / 2;            Assert.assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);            Assert.assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);            for (int i = 0; i < 10; ++i) {                double t = (i * tB + (9 - i) * tA) / 9;                interpolator.setInterpolatedTime(t);                Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));                cloned.setInterpolatedTime(t);                Assert.assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);                double[] referenceState = interpolator.getInterpolatedState();                double[] cloneState     = cloned.getInterpolatedState();                for (int j = 0; j < referenceState.length; ++j) {                    Assert.assertEquals(referenceState[j], cloneState[j], 1.0e-12);                }            }        }        public void reset() {        }    });    integ.integrate(pb,            pb.getInitialTime(), pb.getInitialState(),            pb.getFinalTime(), new double[pb.getDimension()]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.junit.Assert;import org.junit.Test;public class GillStepInterpolatorTest {  @Test  public void testDerivativesConsistency()  {    TestProblem3 pb = new TestProblem3();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    GillIntegrator integ = new GillIntegrator(step);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    GillIntegrator integ = new GillIntegrator(step);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    Assert.assertTrue(bos.size () > 753000);    Assert.assertTrue(bos.size () < 754000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    Assert.assertTrue(maxError < 0.003);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.junit.Assert;import org.junit.Test;public class ThreeEighthesStepInterpolatorTest {  @Test  public void derivativesConsistency()  {    TestProblem3 pb = new TestProblem3();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    Assert.assertTrue(bos.size () > 753000);    Assert.assertTrue(bos.size () < 754000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    Assert.assertTrue(maxError > 0.005);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemAbstract;import org.apache.commons.math.ode.TestProblemFactory;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class ThreeEighthesIntegratorTest {  @Test(expected=DimensionMismatchException.class)  public void testDimensionCheck() {      TestProblem1 pb = new TestProblem1();      new ThreeEighthesIntegrator(0.01).integrate(pb,                                                  0.0, new double[pb.getDimension()+10],                                                  1.0, new double[pb.getDimension()+10]);        Assert.fail("an exception should have been thrown");  }  @Test  public void testDecreasingSteps()     {    TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousValueError = Double.NaN;      double previousTimeError = Double.NaN;      for (int i = 4; i < 10; ++i) {        TestProblemAbstract pb = problems[k].copy();        double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i);        FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        EventHandler[] functions = pb.getEventsHandlers();        for (int l = 0; l < functions.length; ++l) {          integ.addEventHandler(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);        }        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                          pb.getFinalTime(), new double[pb.getDimension()]);        if (functions.length == 0) {            Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);        }        double error = handler.getMaximalValueError();        if (i > 4) {          Assert.assertTrue(error < FastMath.abs(previousValueError));        }        previousValueError = error;        double timeError = handler.getMaximalTimeError();        if (i > 4) {          Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));        }        previousTimeError = timeError;      }    }  } @Test public void testSmallStep()    {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertTrue(handler.getLastError() < 2.0e-13);    Assert.assertTrue(handler.getMaximalValueError() < 4.0e-12);    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    Assert.assertEquals("3/8", integ.getName());  }  @Test  public void testBigStep()    {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertTrue(handler.getLastError() > 0.0004);    Assert.assertTrue(handler.getMaximalValueError() > 0.005);    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);  }  @Test  public void testBackward()      {      TestProblem5 pb = new TestProblem5();      double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() < 5.0e-10);      Assert.assertTrue(handler.getMaximalValueError() < 7.0e-10);      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      Assert.assertEquals("3/8", integ.getName());  }  @Test  public void testKepler()    {    final TestProblem3 pb  = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);    integ.addStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);  }  private static class KeplerHandler implements StepHandler {    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      maxError = 0;    }    public void reset() {      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) throws MathUserException {      double[] interpolatedY = interpolator.getInterpolatedState();      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }      if (isLast) {        // even with more than 1000 evaluations per period,        // RK4 is not able to integrate such an eccentric        // orbit with a good accuracy        Assert.assertTrue(maxError > 0.005);      }    }    private TestProblem3 pb;    private double maxError = 0;  }  @Test  public void testStepSize()    {      final double step = 1.23456;      FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);      integ.addStepHandler(new StepHandler() {          public void handleStep(StepInterpolator interpolator, boolean isLast) {              if (! isLast) {                  Assert.assertEquals(step,                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),                               1.0e-12);              }          }          public void reset() {          }      });      integ.integrate(new FirstOrderDifferentialEquations() {          public void computeDerivatives(double t, double[] y, double[] dot) {              dot[0] = 1.0;          }          public int getDimension() {              return 1;          }      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class DormandPrince853StepInterpolatorTest {  @Test  public void derivativesConsistency()  {    TestProblem3 pb = new TestProblem3(0.1);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                      scalAbsoluteTolerance,                                                                      scalRelativeTolerance);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                      scalAbsoluteTolerance,                                                                      scalRelativeTolerance);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    Assert.assertTrue(bos.size () > 88000);    Assert.assertTrue(bos.size () < 89000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    Assert.assertTrue(maxError < 2.4e-10);  }  @Test  public void checklone()  {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                      scalAbsoluteTolerance,                                                                      scalRelativeTolerance);    integ.addStepHandler(new StepHandler() {        public void handleStep(StepInterpolator interpolator, boolean isLast)        throws MathUserException {            StepInterpolator cloned = interpolator.copy();            double tA = cloned.getPreviousTime();            double tB = cloned.getCurrentTime();            double halfStep = FastMath.abs(tB - tA) / 2;            Assert.assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);            Assert.assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);            for (int i = 0; i < 10; ++i) {                double t = (i * tB + (9 - i) * tA) / 9;                interpolator.setInterpolatedTime(t);                Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));                cloned.setInterpolatedTime(t);                Assert.assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);                double[] referenceState = interpolator.getInterpolatedState();                double[] cloneState     = cloned.getInterpolatedState();                for (int j = 0; j < referenceState.length; ++j) {                    Assert.assertEquals(referenceState[j], cloneState[j], 1.0e-12);                }            }        }        public void reset() {        }    });    integ.integrate(pb,            pb.getInitialTime(), pb.getInitialState(),            pb.getFinalTime(), new double[pb.getDimension()]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemAbstract;import org.apache.commons.math.ode.TestProblemFactory;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class EulerIntegratorTest {  @Test(expected=DimensionMismatchException.class)  public void testDimensionCheck() {      TestProblem1 pb = new TestProblem1();      new EulerIntegrator(0.01).integrate(pb,                                          0.0, new double[pb.getDimension()+10],                                          1.0, new double[pb.getDimension()+10]);        Assert.fail("an exception should have been thrown");  }  @Test  public void testDecreasingSteps()    {    TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousValueError = Double.NaN;      double previousTimeError = Double.NaN;      for (int i = 4; i < 8; ++i) {        TestProblemAbstract pb  = problems[k].copy();        double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i);        FirstOrderIntegrator integ = new EulerIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        EventHandler[] functions = pb.getEventsHandlers();        for (int l = 0; l < functions.length; ++l) {          integ.addEventHandler(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);        }        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                          pb.getFinalTime(), new double[pb.getDimension()]);        if (functions.length == 0) {            Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);        }        double valueError = handler.getMaximalValueError();        if (i > 4) {          Assert.assertTrue(valueError < FastMath.abs(previousValueError));        }        previousValueError = valueError;        double timeError = handler.getMaximalTimeError();        if (i > 4) {          Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));        }        previousTimeError = timeError;      }    }  }  @Test  public void testSmallStep()    {    TestProblem1 pb  = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new EulerIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);   Assert.assertTrue(handler.getLastError() < 2.0e-4);   Assert.assertTrue(handler.getMaximalValueError() < 1.0e-3);   Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);   Assert.assertEquals("Euler", integ.getName());  }  @Test  public void testBigStep()    {    TestProblem1 pb  = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new EulerIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertTrue(handler.getLastError() > 0.01);    Assert.assertTrue(handler.getMaximalValueError() > 0.2);    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);  }  @Test  public void testBackward()      {      TestProblem5 pb = new TestProblem5();      double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new EulerIntegrator(step);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() < 0.45);      Assert.assertTrue(handler.getMaximalValueError() < 0.45);      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      Assert.assertEquals("Euler", integ.getName());  }  @Test  public void testStepSize()    {      final double step = 1.23456;      FirstOrderIntegrator integ = new EulerIntegrator(step);      integ.addStepHandler(new StepHandler() {        public void handleStep(StepInterpolator interpolator, boolean isLast) {            if (! isLast) {                Assert.assertEquals(step,                             interpolator.getCurrentTime() - interpolator.getPreviousTime(),                             1.0e-12);            }        }        public void reset() {        }      });      integ.integrate(new FirstOrderDifferentialEquations() {                          public void computeDerivatives(double t, double[] y, double[] dot) {                              dot[0] = 1.0;                          }                          public int getDimension() {                              return 1;                          }                      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemAbstract;import org.apache.commons.math.ode.TestProblemFactory;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class GillIntegratorTest {  @Test(expected=DimensionMismatchException.class)  public void testDimensionCheck() {      TestProblem1 pb = new TestProblem1();      new GillIntegrator(0.01).integrate(pb,                                         0.0, new double[pb.getDimension()+10],                                         1.0, new double[pb.getDimension()+10]);        Assert.fail("an exception should have been thrown");  }  @Test  public void testDecreasingSteps()     {    TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousValueError = Double.NaN;      double previousTimeError = Double.NaN;      for (int i = 5; i < 10; ++i) {        TestProblemAbstract pb = problems[k].copy();        double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i);        FirstOrderIntegrator integ = new GillIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        EventHandler[] functions = pb.getEventsHandlers();        for (int l = 0; l < functions.length; ++l) {          integ.addEventHandler(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);        }        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                          pb.getFinalTime(), new double[pb.getDimension()]);        if (functions.length == 0) {            Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);        }        double valueError = handler.getMaximalValueError();        if (i > 5) {          Assert.assertTrue(valueError < FastMath.abs(previousValueError));        }        previousValueError = valueError;        double timeError = handler.getMaximalTimeError();        if (i > 5) {          Assert.assertTrue(timeError <= FastMath.abs(previousTimeError));        }        previousTimeError = timeError;      }    }  }  @Test  public void testSmallStep()    {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new GillIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertTrue(handler.getLastError() < 2.0e-13);    Assert.assertTrue(handler.getMaximalValueError() < 4.0e-12);    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    Assert.assertEquals("Gill", integ.getName());  }  @Test  public void testBigStep()    {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new GillIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertTrue(handler.getLastError() > 0.0004);    Assert.assertTrue(handler.getMaximalValueError() > 0.005);    Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);  }  @Test  public void testBackward()      {      TestProblem5 pb = new TestProblem5();      double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new GillIntegrator(step);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      Assert.assertTrue(handler.getLastError() < 5.0e-10);      Assert.assertTrue(handler.getMaximalValueError() < 7.0e-10);      Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      Assert.assertEquals("Gill", integ.getName());  }  @Test  public void testKepler()    {    final TestProblem3 pb  = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    FirstOrderIntegrator integ = new GillIntegrator(step);    integ.addStepHandler(new KeplerStepHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);  }  @Test  public void testUnstableDerivative()  {    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);    FirstOrderIntegrator integ = new GillIntegrator(0.3);    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);    double[] y = { Double.NaN };    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);    Assert.assertEquals(8.0, y[0], 1.0e-12);  }  private static class KeplerStepHandler implements StepHandler {    public KeplerStepHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public void reset() {      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) throws MathUserException {      double[] interpolatedY = interpolator.getInterpolatedState();      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }      if (isLast) {        // even with more than 1000 evaluations per period,        // RK4 is not able to integrate such an eccentric        // orbit with a good accuracy        Assert.assertTrue(maxError > 0.001);      }    }    private double maxError;    private TestProblem3 pb;  }  @Test  public void testStepSize()    {      final double step = 1.23456;      FirstOrderIntegrator integ = new GillIntegrator(step);      integ.addStepHandler(new StepHandler() {          public void handleStep(StepInterpolator interpolator, boolean isLast) {              if (! isLast) {                  Assert.assertEquals(step,                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),                               1.0e-12);              }          }          public void reset() {          }      });      integ.integrate(new FirstOrderDifferentialEquations() {          public void computeDerivatives(double t, double[] y, double[] dot) {              dot[0] = 1.0;          }          public int getDimension() {              return 1;          }      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblem6;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class AdamsMoultonIntegratorTest {    @Test(expected=DimensionMismatchException.class)    public void dimensionCheck() {        TestProblem1 pb = new TestProblem1();        FirstOrderIntegrator integ =            new AdamsMoultonIntegrator(2, 0.0, 1.0, 1.0e-10, 1.0e-10);        integ.integrate(pb,                        0.0, new double[pb.getDimension()+10],                        1.0, new double[pb.getDimension()+10]);    }    @Test(expected=NumberIsTooSmallException.class)    public void testMinStep() {          TestProblem1 pb = new TestProblem1();          double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());          double maxStep = pb.getFinalTime() - pb.getInitialTime();          double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };          double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };          FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, minStep, maxStep,                                                                  vecAbsoluteTolerance,                                                                  vecRelativeTolerance);          TestProblemHandler handler = new TestProblemHandler(pb, integ);          integ.addStepHandler(handler);          integ.integrate(pb,                          pb.getInitialTime(), pb.getInitialState(),                          pb.getFinalTime(), new double[pb.getDimension()]);    }    @Test    public void testIncreasingTolerance()        {        int previousCalls = Integer.MAX_VALUE;        for (int i = -12; i < -2; ++i) {            TestProblem1 pb = new TestProblem1();            double minStep = 0;            double maxStep = pb.getFinalTime() - pb.getInitialTime();            double scalAbsoluteTolerance = FastMath.pow(10.0, i);            double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;            FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, minStep, maxStep,                                                                    scalAbsoluteTolerance,                                                                    scalRelativeTolerance);            TestProblemHandler handler = new TestProblemHandler(pb, integ);            integ.addStepHandler(handler);            integ.integrate(pb,                            pb.getInitialTime(), pb.getInitialState(),                            pb.getFinalTime(), new double[pb.getDimension()]);            // the 0.5 and 11.0 factors are only valid for this test            // and has been obtained from trial and error            // there is no general relation between local and global errors            Assert.assertTrue(handler.getMaximalValueError() > ( 0.5 * scalAbsoluteTolerance));            Assert.assertTrue(handler.getMaximalValueError() < (11.0 * scalAbsoluteTolerance));            Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);            int calls = pb.getCalls();            Assert.assertEquals(integ.getEvaluations(), calls);            Assert.assertTrue(calls <= previousCalls);            previousCalls = calls;        }    }    @Test(expected = MathUserException.class)    public void exceedMaxEvaluations() {        TestProblem1 pb  = new TestProblem1();        double range = pb.getFinalTime() - pb.getInitialTime();        AdamsMoultonIntegrator integ = new AdamsMoultonIntegrator(2, 0, range, 1.0e-12, 1.0e-12);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        integ.setMaxEvaluations(650);        integ.integrate(pb,                        pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);    }    @Test    public void backward() {        TestProblem5 pb = new TestProblem5();        double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());        FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, 0, range, 1.0e-12, 1.0e-12);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        Assert.assertTrue(handler.getLastError() < 1.0e-9);        Assert.assertTrue(handler.getMaximalValueError() < 1.0e-9);        Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);        Assert.assertEquals("Adams-Moulton", integ.getName());    }    @Test    public void polynomial() {        TestProblem6 pb = new TestProblem6();        double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());        for (int nSteps = 2; nSteps < 8; ++nSteps) {            AdamsMoultonIntegrator integ =                new AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-5, 1.0e-5);            TestProblemHandler handler = new TestProblemHandler(pb, integ);            integ.addStepHandler(handler);            integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                            pb.getFinalTime(), new double[pb.getDimension()]);            if (nSteps < 4) {                Assert.assertTrue(handler.getMaximalValueError() > 7.0e-04);            } else {                Assert.assertTrue(handler.getMaximalValueError() < 3.0e-13);            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class HighamHall54StepInterpolatorTest {  @Test  public void derivativesConsistency()  {    TestProblem3 pb = new TestProblem3(0.1);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.1e-10);  }  @Test  public void serialization()    throws IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    Assert.assertTrue(bos.size () > 167000);    Assert.assertTrue(bos.size () < 168000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    Assert.assertTrue(maxError < 1.6e-10);  }  @Test  public void checkClone()  {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);    integ.addStepHandler(new StepHandler() {        public void handleStep(StepInterpolator interpolator, boolean isLast)        throws MathUserException {            StepInterpolator cloned = interpolator.copy();            double tA = cloned.getPreviousTime();            double tB = cloned.getCurrentTime();            double halfStep = FastMath.abs(tB - tA) / 2;            Assert.assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);            Assert.assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);            for (int i = 0; i < 10; ++i) {                double t = (i * tB + (9 - i) * tA) / 9;                interpolator.setInterpolatedTime(t);                Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));                cloned.setInterpolatedTime(t);                Assert.assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);                double[] referenceState = interpolator.getInterpolatedState();                double[] cloneState     = cloned.getInterpolatedState();                for (int j = 0; j < referenceState.length; ++j) {                    Assert.assertEquals(referenceState[j], cloneState[j], 1.0e-12);                }            }        }        public void reset() {        }    });    integ.integrate(pb,            pb.getInitialTime(), pb.getInitialState(),            pb.getFinalTime(), new double[pb.getDimension()]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.sampling;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator;import org.junit.Assert;import org.junit.Test;public class NordsieckStepInterpolatorTest {    @Test    public void derivativesConsistency() {        TestProblem3 pb = new TestProblem3();        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(4, 0.0, 1.0, 1.0e-10, 1.0e-10);        StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 5e-9);    }    @Test    public void serialization()    throws IOException, ClassNotFoundException {        TestProblem1 pb = new TestProblem1();        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(4, 0.0, 1.0, 1.0e-10, 1.0e-10);        integ.addStepHandler(new ContinuousOutputModel());        integ.integrate(pb,                        pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        ByteArrayOutputStream bos = new ByteArrayOutputStream();        ObjectOutputStream    oos = new ObjectOutputStream(bos);        for (StepHandler handler : integ.getStepHandlers()) {            oos.writeObject(handler);        }        Assert.assertTrue(bos.size () >  25500);        Assert.assertTrue(bos.size () <  26500);        ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());        ObjectInputStream     ois = new ObjectInputStream(bis);        ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();        Random random = new Random(347588535632l);        double maxError = 0.0;        for (int i = 0; i < 1000; ++i) {            double r = random.nextDouble();            double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();            cm.setInterpolatedTime(time);            double[] interpolatedY = cm.getInterpolatedState ();            double[] theoreticalY  = pb.computeTheoreticalState(time);            double dx = interpolatedY[0] - theoreticalY[0];            double dy = interpolatedY[1] - theoreticalY[1];            double error = dx * dx + dy * dy;            if (error > maxError) {                maxError = error;            }        }        Assert.assertTrue(maxError < 1.0e-6);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.sampling;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;import org.apache.commons.math.util.FastMath;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public class StepNormalizerTest {  public StepNormalizerTest() {    pb    = null;    integ = null;  }  @Test  public void testBoundaries()    {    double range = pb.getFinalTime() - pb.getInitialTime();    setLastSeen(false);    integ.addStepHandler(new StepNormalizer(range / 10.0,                                       new FixedStepHandler() {                                        private boolean firstCall = true;                                         public void handleStep(double t,                                                                double[] y,                                                                double[] yDot,                                                                boolean isLast) {                                           if (firstCall) {                                             checkValue(t, pb.getInitialTime());                                             firstCall = false;                                           }                                           if (isLast) {                                             setLastSeen(true);                                             checkValue(t, pb.getFinalTime());                                           }                                         }                                       }));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertTrue(lastSeen);  }  @Test  public void testBeforeEnd()    {    final double range = pb.getFinalTime() - pb.getInitialTime();    setLastSeen(false);    integ.addStepHandler(new StepNormalizer(range / 10.5,                                       new FixedStepHandler() {                                        public void handleStep(double t,                                                                double[] y,                                                                double[] yDot,                                                                boolean isLast) {                                           if (isLast) {                                             setLastSeen(true);                                             checkValue(t,                                                        pb.getFinalTime() - range / 21.0);                                           }                                         }                                       }));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Assert.assertTrue(lastSeen);  }  public void checkValue(double value, double reference) {    Assert.assertTrue(FastMath.abs(value - reference) < 1.0e-10);  }  public void setLastSeen(boolean lastSeen) {    this.lastSeen = lastSeen;  }  @Before  public void setUp() {    pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    integ = new DormandPrince54Integrator(minStep, maxStep, 10.e-8, 1.0e-8);    lastSeen = false;  }  @After  public void tearDown() {    pb    = null;    integ = null;  }  TestProblem3 pb;  FirstOrderIntegrator integ;  boolean lastSeen;}
package org.apache.commons.math.ode.sampling;/** Step normalizer output tests, for problems where the first and last points * are overlap fixed points. */public class StepNormalizerOutputOverlapTest extends StepNormalizerOutputTestBase {    @Override    protected double getStart() {        return 0.0;    }    @Override    protected double getEnd() {        return 10.0;    }    @Override    protected double[] getExpInc() {        return new double[] { 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0,                              4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5,                              9.0, 9.5, 10.0 };    }    @Override    protected double[] getExpIncRev() {        return new double[] { 10.0, 9.5, 9.0, 8.5, 8.0, 7.5, 7.0, 6.5,                              6.0, 5.5, 5.0, 4.5, 4.0, 3.5, 3.0, 2.5,                              2.0, 1.5, 1.0, 0.5, 0.0 };    }    @Override    protected double[] getExpMul() {        return new double[] { 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0,                              4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5,                              9.0, 9.5, 10.0 };    }    @Override    protected double[] getExpMulRev() {        return new double[] { 10.0, 9.5, 9.0, 8.5, 8.0, 7.5, 7.0, 6.5,                              6.0, 5.5, 5.0, 4.5, 4.0, 3.5, 3.0, 2.5,                              2.0, 1.5, 1.0, 0.5, 0.0 };    }    @Override    protected int[][] getO() {        return new int[][] {{1, 0}, {1, 0}, {0, 0}, {0, 0},                            {1, 0}, {1, 0}, {0, 0}, {0, 0},                            {1, 0}, {1, 0}, {0, 0}, {0, 0},                            {1, 0}, {1, 0}, {0, 0}, {0, 0}};    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.sampling;import java.io.ByteArrayOutputStream;import java.io.ByteArrayInputStream;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.IOException;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.exception.util.LocalizedFormats;import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;import org.apache.commons.math.ode.sampling.DummyStepInterpolator;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class DummyStepInterpolatorTest {  @Test  public void testNoReset() throws MathUserException {    double[]   y    =   { 0.0, 1.0, -2.0 };    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    double[] result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {      Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);    }  }  @Test  public void testFixedState()    throws MathUserException {    double[]   y    =   { 1.0, 3.0, -4.0 };    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    interpolator.setInterpolatedTime(0.1);    double[] result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {        Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);    }    interpolator.setInterpolatedTime(0.5);    result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {        Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);    }  }  @Test  public void testSerialization()  throws MathUserException, IOException, ClassNotFoundException {    double[]   y    =   { 0.0, 1.0, -2.0 };    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    oos.writeObject(interpolator);    Assert.assertTrue(bos.size () > 200);    Assert.assertTrue(bos.size () < 300);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    DummyStepInterpolator dsi = (DummyStepInterpolator) ois.readObject();    dsi.setInterpolatedTime(0.5);    double[] result = dsi.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {        Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);    }  }  @Test  public void testImpossibleSerialization()  throws IOException {    double[] y = { 0.0, 1.0, -2.0 };    AbstractStepInterpolator interpolator = new BadStepInterpolator(y, true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    try {        oos.writeObject(interpolator);        Assert.fail("an exception should have been thrown");    } catch (IOException ioe) {        // expected behavior        Assert.assertEquals(0, ioe.getMessage().length());    }  }  private static class BadStepInterpolator extends DummyStepInterpolator {      @SuppressWarnings("unused")      public BadStepInterpolator() {      }      public BadStepInterpolator(double[] y, boolean forward) {          super(y, new double[y.length], forward);      }      @Override      protected void doFinalize() throws MathUserException {          throw new MathUserException(LocalizedFormats.SIMPLE_MESSAGE, "");      }  }}
package org.apache.commons.math.ode.sampling;/** Step normalizer output tests, for problems where the first and last points * are not fixed points. */public class StepNormalizerOutputTest extends StepNormalizerOutputTestBase {    @Override    protected double getStart() {        return 0.3;    }    @Override    protected double getEnd() {        return 10.1;    }    @Override    protected double[] getExpInc() {        return new double[] { 0.3, 0.8, 1.3, 1.8, 2.3, 2.8, 3.3, 3.8, 4.3,                              4.8, 5.3, 5.8, 6.3, 6.8, 7.3, 7.8, 8.3, 8.8,                              9.3, 9.8, 10.1 };    }    @Override    protected double[] getExpIncRev() {        return new double[] { 10.1, 9.6, 9.1, 8.6, 8.1, 7.6, 7.1, 6.6,                              6.1, 5.6, 5.1, 4.6, 4.1, 3.6, 3.1, 2.6,                              2.1, 1.6, 1.1, 0.6, 0.3 };    }    @Override    protected double[] getExpMul() {        return new double[] { 0.3, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0,                              4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5,                              9.0, 9.5, 10.0, 10.1 };    }    @Override    protected double[] getExpMulRev() {        return new double[] { 10.1, 10.0, 9.5, 9.0, 8.5, 8.0, 7.5, 7.0,                              6.5, 6.0, 5.5, 5.0, 4.5, 4.0, 3.5, 3.0, 2.5,                              2.0, 1.5, 1.0, 0.5, 0.3 };    }    @Override    protected int[][] getO() {        return new int[][] {{1, 1}, {1, 1}, {0, 1}, {0, 1},                            {1, 0}, {1, 0}, {0, 0}, {0, 0},                            {1, 1}, {1, 1}, {0, 1}, {0, 1},                            {1, 0}, {1, 0}, {0, 0}, {0, 0}};    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import org.apache.commons.math.util.FastMath;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    y' = -y * </pre> * the solution of this equation is a simple exponential function : * <pre> *   y (t) = y (t0) exp (t0-t) * </pre> * </p> */public class TestProblem1  extends TestProblemAbstract {  /** theoretical state */  private double[] y;  /**   * Simple constructor.   */  public TestProblem1() {    super();    double[] y0 = { 1.0, 0.1 };    setInitialConditions(0.0, y0);    setFinalConditions(4.0);    double[] errorScale = { 1.0, 1.0 };    setErrorScale(errorScale);    y = new double[y0.length];  }  /**   * Copy constructor.   * @param problem problem to copy   */  public TestProblem1(TestProblem1 problem) {    super(problem);    y = problem.y.clone();  }  /** {@inheritDoc} */  @Overridepublic TestProblem1 copy() {    return new TestProblem1(this);  }  @Override  public void doComputeDerivatives(double t, double[] y, double[] yDot) {    // compute the derivatives    for (int i = 0; i < n; ++i)      yDot[i] = -y[i];  }  @Override  public double[] computeTheoreticalState(double t) {    double c = FastMath.exp (t0 - t);    for (int i = 0; i < n; ++i) {      y[i] = c * y0[i];    }    return y;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.ode.ODEIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;/** * This class is used to handle steps for the test problems * integrated during the junit tests for the ODE integrators. */public class TestProblemHandler  implements StepHandler {  /** Associated problem. */  private TestProblemAbstract problem;  /** Maximal errors encountered during the integration. */  private double maxValueError;  private double maxTimeError;  /** Error at the end of the integration. */  private double lastError;  /** Time at the end of integration. */  private double lastTime;  /** ODE solver used. */  private ODEIntegrator integrator;  /** Expected start for step. */  private double expectedStepStart;  /**   * Simple constructor.   * @param problem problem for which steps should be handled   * @param integrator ODE solver used   */  public TestProblemHandler(TestProblemAbstract problem, ODEIntegrator integrator) {    this.problem = problem;    this.integrator = integrator;    reset();  }  public void reset() {    maxValueError = 0;    maxTimeError  = 0;    lastError     = 0;    expectedStepStart = Double.NaN;  }  public void handleStep(StepInterpolator interpolator,                         boolean isLast)    throws MathUserException {    double start = integrator.getCurrentStepStart();    if (FastMath.abs((start - problem.getInitialTime()) / integrator.getCurrentSignedStepsize()) > 0.001) {        // multistep integrators do not handle the first steps themselves        // so we have to make sure the integrator we look at has really started its work        if (!Double.isNaN(expectedStepStart)) {            // the step should either start at the end of the integrator step            // or at an event if the step is split into several substeps            double stepError = FastMath.max(maxTimeError, FastMath.abs(start - expectedStepStart));            for (double eventTime : problem.getTheoreticalEventsTimes()) {                stepError = FastMath.min(stepError, FastMath.abs(start - eventTime));            }            maxTimeError = FastMath.max(maxTimeError, stepError);        }        expectedStepStart = start + integrator.getCurrentSignedStepsize();    }    double pT = interpolator.getPreviousTime();    double cT = interpolator.getCurrentTime();    double[] errorScale = problem.getErrorScale();    // store the error at the last step    if (isLast) {      double[] interpolatedY = interpolator.getInterpolatedState();      double[] theoreticalY  = problem.computeTheoreticalState(cT);      for (int i = 0; i < interpolatedY.length; ++i) {        double error = FastMath.abs(interpolatedY[i] - theoreticalY[i]);        lastError = FastMath.max(error, lastError);      }      lastTime = cT;    }    // walk through the step    for (int k = 0; k <= 20; ++k) {      double time = pT + (k * (cT - pT)) / 20;      interpolator.setInterpolatedTime(time);      double[] interpolatedY = interpolator.getInterpolatedState();      double[] theoreticalY  = problem.computeTheoreticalState(interpolator.getInterpolatedTime());      // update the errors      for (int i = 0; i < interpolatedY.length; ++i) {        double error = errorScale[i] * FastMath.abs(interpolatedY[i] - theoreticalY[i]);        maxValueError = FastMath.max(error, maxValueError);      }    }  }  /**   * Get the maximal value error encountered during integration.   * @return maximal value error   */  public double getMaximalValueError() {    return maxValueError;  }  /**   * Get the maximal time error encountered during integration.   * @return maximal time error   */  public double getMaximalTimeError() {    return maxTimeError;  }  /**   * Get the error at the end of the integration.   * @return error at the end of the integration   */  public double getLastError() {    return lastError;  }  /**   * Get the time at the end of the integration.   * @return time at the end of the integration.   */  public double getLastTime() {    return lastTime;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;/** * This class is used in the junit tests for the ODE integrators. * <p>This is the same as problem 1 except integration is done * backward in time</p> */public class TestProblem5  extends TestProblem1 {  /**   * Simple constructor.   */  public TestProblem5() {    super();    setFinalConditions(2 * t0 - t1);  }  /** {@inheritDoc} */  @Override  public TestProblem5 copy() {    return new TestProblem5();  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.events.EventHandler;/** * This class is used as the base class of the problems that are * integrated during the junit tests for the ODE integrators. */public abstract class TestProblemAbstract  implements FirstOrderDifferentialEquations {  /** Dimension of the problem. */  protected int n;  /** Number of functions calls. */  protected int calls;  /** Initial time */  protected double t0;  /** Initial state */  protected double[] y0;  /** Final time */  protected double t1;  /** Error scale */  protected double[] errorScale;  /**   * Simple constructor.   */  protected TestProblemAbstract() {    n          = 0;    calls      = 0;    t0         = 0;    y0         = null;    t1         = 0;    errorScale = null;  }  /**   * Copy constructor.   * @param problem problem to copy   */  protected TestProblemAbstract(TestProblemAbstract problem) {    n     = problem.n;    calls = problem.calls;    t0    = problem.t0;    if (problem.y0 == null) {      y0 = null;    } else {      y0 = problem.y0.clone();    }    if (problem.errorScale == null) {      errorScale = null;    } else {      errorScale = problem.errorScale.clone();    }    t1 = problem.t1;  }  /**   * Copy operation.   * @return a copy of the instance   */  public abstract TestProblemAbstract copy();  /**   * Set the initial conditions   * @param t0 initial time   * @param y0 initial state vector   */  protected void setInitialConditions(double t0, double[] y0) {    calls     = 0;    n         = y0.length;    this.t0   = t0;    this.y0   = y0.clone();   }  /**   * Set the final conditions.   * @param t1 final time   */  protected void setFinalConditions(double t1) {    this.t1 = t1;  }  /**   * Set the error scale   * @param errorScale error scale   */  protected void setErrorScale(double[] errorScale) {    this.errorScale = errorScale.clone();  }  public int getDimension() {    return n;  }  /**   * Get the initial time.   * @return initial time   */  public double getInitialTime() {    return t0;  }  /**   * Get the initial state vector.   * @return initial state vector   */  public double[] getInitialState() {    return y0;  }  /**   * Get the final time.   * @return final time   */  public double getFinalTime() {    return t1;  }  /**   * Get the error scale.   * @return error scale   */  public double[] getErrorScale() {    return errorScale;  }  /**   * Get the events handlers.   * @return events handlers   */  public EventHandler[] getEventsHandlers() {    return new EventHandler[0];  }  /**   * Get the theoretical events times.   * @return theoretical events times   */  public double[] getTheoreticalEventsTimes() {      return new double[0];  }  /**   * Get the number of calls.   * @return nuber of calls   */  public int getCalls() {    return calls;  }  public void computeDerivatives(double t, double[] y, double[] yDot) {    ++calls;    doComputeDerivatives(t, y, yDot);  }  abstract public void doComputeDerivatives(double t, double[] y, double[] yDot);  /**   * Compute the theoretical state at the specified time.   * @param t time at which the state is required   * @return state vector at time t   */  abstract public double[] computeTheoreticalState(double t);}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import java.util.Random;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;import org.apache.commons.math.ode.sampling.DummyStepInterpolator;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public class ContinuousOutputModelTest {  public ContinuousOutputModelTest() {    pb    = null;    integ = null;  }  @Test  public void testBoundaries() {    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandlers().iterator().next();    cm.setInterpolatedTime(2.0 * pb.getInitialTime() - pb.getFinalTime());    cm.setInterpolatedTime(2.0 * pb.getFinalTime() - pb.getInitialTime());    cm.setInterpolatedTime(0.5 * (pb.getFinalTime() + pb.getInitialTime()));  }  @Test  public void testRandomAccess() {    ContinuousOutputModel cm = new ContinuousOutputModel();    integ.addStepHandler(cm);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    Assert.assertTrue(maxError < 1.0e-9);  }  @Test  public void testModelsMerging() {      // theoretical solution: y[0] = cos(t), y[1] = sin(t)      FirstOrderDifferentialEquations problem =          new FirstOrderDifferentialEquations() {              public void computeDerivatives(double t, double[] y, double[] dot)                  throws MathUserException {                  dot[0] = -y[1];                  dot[1] =  y[0];              }              public int getDimension() {                  return 2;              }          };      // integrate backward from &pi; to 0;      ContinuousOutputModel cm1 = new ContinuousOutputModel();      FirstOrderIntegrator integ1 =          new DormandPrince853Integrator(0, 1.0, 1.0e-8, 1.0e-8);      integ1.addStepHandler(cm1);      integ1.integrate(problem, FastMath.PI, new double[] { -1.0, 0.0 },                       0, new double[2]);      // integrate backward from 2&pi; to &pi;      ContinuousOutputModel cm2 = new ContinuousOutputModel();      FirstOrderIntegrator integ2 =          new DormandPrince853Integrator(0, 0.1, 1.0e-12, 1.0e-12);      integ2.addStepHandler(cm2);      integ2.integrate(problem, 2.0 * FastMath.PI, new double[] { 1.0, 0.0 },                       FastMath.PI, new double[2]);      // merge the two half circles      ContinuousOutputModel cm = new ContinuousOutputModel();      cm.append(cm2);      cm.append(new ContinuousOutputModel());      cm.append(cm1);      // check circle      Assert.assertEquals(2.0 * FastMath.PI, cm.getInitialTime(), 1.0e-12);      Assert.assertEquals(0, cm.getFinalTime(), 1.0e-12);      Assert.assertEquals(cm.getFinalTime(), cm.getInterpolatedTime(), 1.0e-12);      for (double t = 0; t < 2.0 * FastMath.PI; t += 0.1) {          cm.setInterpolatedTime(t);          double[] y = cm.getInterpolatedState();          Assert.assertEquals(FastMath.cos(t), y[0], 1.0e-7);          Assert.assertEquals(FastMath.sin(t), y[1], 1.0e-7);      }  }  @Test  public void testErrorConditions()    throws MathUserException {      ContinuousOutputModel cm = new ContinuousOutputModel();      cm.handleStep(buildInterpolator(0, new double[] { 0.0, 1.0, -2.0 }, 1), true);      // dimension mismatch      Assert.assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0 }, 2.0));      // hole between time ranges      Assert.assertTrue(checkAppendError(cm, 10.0, new double[] { 0.0, 1.0, -2.0 }, 20.0));      // propagation direction mismatch      Assert.assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 0.0));      // no errors      Assert.assertFalse(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 2.0));  }  private boolean checkAppendError(ContinuousOutputModel cm,                                   double t0, double[] y0, double t1)  throws MathUserException {      try {          ContinuousOutputModel otherCm = new ContinuousOutputModel();          otherCm.handleStep(buildInterpolator(t0, y0, t1), true);          cm.append(otherCm);      } catch(IllegalArgumentException iae) {          return true; // there was an allowable error      }      return false; // no allowable error  }  private StepInterpolator buildInterpolator(double t0, double[] y0, double t1) {      DummyStepInterpolator interpolator  = new DummyStepInterpolator(y0, new double[y0.length], t1 >= t0);      interpolator.storeTime(t0);      interpolator.shift();      interpolator.storeTime(t1);      return interpolator;  }  public void checkValue(double value, double reference) {    Assert.assertTrue(FastMath.abs(value - reference) < 1.0e-10);  }  @Before  public void setUp() {    pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    integ = new DormandPrince54Integrator(minStep, maxStep, 1.0e-8, 1.0e-8);  }  @After  public void tearDown() {    pb    = null;    integ = null;  }  TestProblem3 pb;  FirstOrderIntegrator integ;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import org.apache.commons.math.util.FastMath;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    y' = t^3 - t y * </pre> * with the initial condition y (0) = 0. The solution of this equation * is the following function : * <pre> *   y (t) = t^2 + 2 (exp (- t^2 / 2) - 1) * </pre> * </p> */public class TestProblem2  extends TestProblemAbstract {  /** theoretical state */  private double[] y;  /**   * Simple constructor.   */  public TestProblem2() {    super();    double[] y0 = { 0.0 };    setInitialConditions(0.0, y0);    setFinalConditions(1.0);    double[] errorScale = { 1.0 };    setErrorScale(errorScale);    y = new double[y0.length];  }  /**   * Copy constructor.   * @param problem problem to copy   */  public TestProblem2(TestProblem2 problem) {    super(problem);    y = problem.y.clone();  }  /** {@inheritDoc} */  @Overridepublic TestProblem2 copy() {    return new TestProblem2(this);  }  @Override  public void doComputeDerivatives(double t, double[] y, double[] yDot) {    // compute the derivatives    for (int i = 0; i < n; ++i)      yDot[i] = t * (t * t - y[i]);  }  @Override  public double[] computeTheoreticalState(double t) {    double t2 = t * t;    double c = t2 + 2 * (FastMath.exp (-0.5 * t2) - 1);    for (int i = 0; i < n; ++i) {      y[i] = c;    }    return y;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    y' = 3x^5 - y * </pre> * when the initial condition is y(0) = -360, the solution of this * equation degenerates to a simple quintic polynomial function : * <pre> *   y (t) = 3x^5 - 15x^4 + 60x^3 - 180x^2 + 360x - 360 * </pre> * </p> */public class TestProblem6  extends TestProblemAbstract {    /** theoretical state */    private double[] y;    /**     * Simple constructor.     */    public TestProblem6() {        super();        double[] y0 = { -360.0 };        setInitialConditions(0.0, y0);        setFinalConditions(1.0);        double[] errorScale = { 1.0 };        setErrorScale(errorScale);        y = new double[y0.length];    }    /**     * Copy constructor.     * @param problem problem to copy     */    public TestProblem6(TestProblem6 problem) {        super(problem);        y = problem.y.clone();    }    /** {@inheritDoc} */    @Override    public TestProblem6 copy() {      return new TestProblem6(this);    }    @Override    public void doComputeDerivatives(double t, double[] y, double[] yDot) {        // compute the derivatives        double t2 = t  * t;        double t4 = t2 * t2;        double t5 = t4 * t;        for (int i = 0; i < n; ++i) {            yDot[i] = 3 * t5 - y[i];        }    }    @Override    public double[] computeTheoreticalState(double t) {        for (int i = 0; i < n; ++i) {            y[i] = ((((3 * t - 15) * t + 60) * t - 180) * t + 360) * t - 360;        }        return y;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.exception.MathIllegalStateException;import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class FirstOrderConverterTest {  @Test  public void testDoubleDimension() {    for (int i = 1; i < 10; ++i) {      SecondOrderDifferentialEquations eqn2 = new Equations(i, 0.2);      FirstOrderConverter eqn1 = new FirstOrderConverter(eqn2);      Assert.assertTrue(eqn1.getDimension() == (2 * eqn2.getDimension()));    }  }  @Test  public void testDecreasingSteps() {    double previousError = Double.NaN;    for (int i = 0; i < 10; ++i) {      double step  = FastMath.pow(2.0, -(i + 1));      double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, step)                   - FastMath.sin(4.0);      if (i > 0) {        Assert.assertTrue(FastMath.abs(error) < FastMath.abs(previousError));      }      previousError = error;    }  }  @Test  public void testSmallStep() {    double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 1.0e-4)                   - FastMath.sin(4.0);    Assert.assertTrue(FastMath.abs(error) < 1.0e-10);  }  @Test  public void testBigStep() {    double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 0.5)                   - FastMath.sin(4.0);    Assert.assertTrue(FastMath.abs(error) > 0.1);  }  private static class Equations    implements SecondOrderDifferentialEquations {     private int n;      private double omega2;      public Equations(int n, double omega) {        this.n = n;        omega2 = omega * omega;      }      public int getDimension() {        return n;      }      public void computeSecondDerivatives(double t, double[] y, double[] yDot,                                           double[] yDDot) {        for (int i = 0; i < n; ++i) {          yDDot[i] = -omega2 * y[i];        }    }  }  private double integrateWithSpecifiedStep(double omega,                                            double t0, double t,                                            double step)  throws MathIllegalStateException, MathIllegalArgumentException {    double[] y0 = new double[2];    y0[0] = FastMath.sin(omega * t0);    y0[1] = omega * FastMath.cos(omega * t0);    ClassicalRungeKuttaIntegrator i = new ClassicalRungeKuttaIntegrator(step);    double[] y = new double[2];    i.integrate(new FirstOrderConverter(new Equations(1, omega)), t0, y0, t, y);    return y[0];  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.util.FastMath;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    x'' = -x * </pre> * And when x decreases down to 0, the state should be changed as follows : * <pre> *   x' -> -x' * </pre> * The theoretical solution of this problem is x = |sin(t+a)| * </p> */public class TestProblem4  extends TestProblemAbstract {  /** Time offset. */  private double a;  /** theoretical state */  private double[] y;  /** Simple constructor. */  public TestProblem4() {    super();    a = 1.2;    double[] y0 = { FastMath.sin(a), FastMath.cos(a) };    setInitialConditions(0.0, y0);    setFinalConditions(15);    double[] errorScale = { 1.0, 0.0 };    setErrorScale(errorScale);    y = new double[y0.length];  }  /**   * Copy constructor.   * @param problem problem to copy   */  public TestProblem4(TestProblem4 problem) {    super(problem);    a = problem.a;    y = problem.y.clone();  }  /** {@inheritDoc} */  @Overridepublic TestProblem4 copy() {    return new TestProblem4(this);  }  @Override  public EventHandler[] getEventsHandlers() {    return new EventHandler[] { new Bounce(), new Stop() };  }  /**   * Get the theoretical events times.   * @return theoretical events times   */  @Override  public double[] getTheoreticalEventsTimes() {      return new double[] {          1 * FastMath.PI - a,          2 * FastMath.PI - a,          3 * FastMath.PI - a,          4 * FastMath.PI - a,          12.0      };  }  @Override  public void doComputeDerivatives(double t, double[] y, double[] yDot) {    yDot[0] =  y[1];    yDot[1] = -y[0];  }  @Override  public double[] computeTheoreticalState(double t) {    double sin = FastMath.sin(t + a);    double cos = FastMath.cos(t + a);    y[0] = FastMath.abs(sin);    y[1] = (sin >= 0) ? cos : -cos;    return y;  }  private static class Bounce implements EventHandler {    private int sign;    public Bounce() {      sign = +1;    }    public double g(double t, double[] y) {      return sign * y[0];    }    public int eventOccurred(double t, double[] y, boolean increasing) {      // this sign change is needed because the state will be reset soon      sign = -sign;      return EventHandler.RESET_STATE;    }    public void resetState(double t, double[] y) {      y[0] = -y[0];      y[1] = -y[1];    }  }  private static class Stop implements EventHandler {    public Stop() {    }    public double g(double t, double[] y) {      return t - 12.0;    }    public int eventOccurred(double t, double[] y, boolean increasing) {      return EventHandler.STOP;    }    public void resetState(double t, double[] y) {    }  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import org.apache.commons.math.util.FastMath;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    y1'' = -y1/r^3  y1 (0) = 1-e  y1' (0) = 0 *    y2'' = -y2/r^3  y2 (0) = 0    y2' (0) =sqrt((1+e)/(1-e)) *    r = sqrt (y1^2 + y2^2), e = 0.9 * </pre> * This is a two-body problem in the plane which can be solved by * Kepler's equation * <pre> *   y1 (t) = ... * </pre> * </p> */public class TestProblem3  extends TestProblemAbstract {  /** Eccentricity */  double e;  /** theoretical state */  private double[] y;  /**   * Simple constructor.   * @param e eccentricity   */  public TestProblem3(double e) {    super();    this.e = e;    double[] y0 = { 1 - e, 0, 0, FastMath.sqrt((1+e)/(1-e)) };    setInitialConditions(0.0, y0);    setFinalConditions(20.0);    double[] errorScale = { 1.0, 1.0, 1.0, 1.0 };    setErrorScale(errorScale);    y = new double[y0.length];  }  /**   * Simple constructor.   */  public TestProblem3() {    this(0.1);  }  /**   * Copy constructor.   * @param problem problem to copy   */  public TestProblem3(TestProblem3 problem) {    super(problem);    e = problem.e;    y = problem.y.clone();  }  /** {@inheritDoc} */  @Overridepublic TestProblem3 copy() {    return new TestProblem3(this);  }  @Override  public void doComputeDerivatives(double t, double[] y, double[] yDot) {    // current radius    double r2 = y[0] * y[0] + y[1] * y[1];    double invR3 = 1 / (r2 * FastMath.sqrt(r2));    // compute the derivatives    yDot[0] = y[2];    yDot[1] = y[3];    yDot[2] = -invR3  * y[0];    yDot[3] = -invR3  * y[1];  }  @Override  public double[] computeTheoreticalState(double t) {    // solve Kepler's equation    double E = t;    double d = 0;    double corr = 999.0;    for (int i = 0; (i < 50) && (FastMath.abs(corr) > 1.0e-12); ++i) {      double f2  = e * FastMath.sin(E);      double f0  = d - f2;      double f1  = 1 - e * FastMath.cos(E);      double f12 = f1 + f1;      corr  = f0 * f12 / (f1 * f12 - f0 * f2);      d -= corr;      E = t + d;    }    double cosE = FastMath.cos(E);    double sinE = FastMath.sin(E);    y[0] = cosE - e;    y[1] = FastMath.sqrt(1 - e * e) * sinE;    y[2] = -sinE / (1 - e * cosE);    y[3] = FastMath.sqrt(1 - e * e) * cosE / (1 - e * cosE);    return y;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;/** * This class is used in the junit tests for the ODE integrators. */public class TestProblemFactory {  /** Problems pool. */  private static final TestProblemAbstract[] pool = {    new TestProblem1(),    new TestProblem2(),    new TestProblem3(),    new TestProblem4(),    new TestProblem5(),    new TestProblem6()  };  /**   * Private constructor.   * This is a utility class, so there are no instance at all.   */  private TestProblemFactory() {  }  /**   * Get the problems.   * @return array of problems to solve   */  public static TestProblemAbstract[] getProblems() {    return pool;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import org.junit.Assert;import org.junit.Test;public class Well1024aTest extends RandomGeneratorAbstractTest {    @Override    protected RandomGenerator makeGenerator() {        return new Well1024a(100);    }        @Test    public void testReferenceCode() {        Well1024a mt = new Well1024a(new int[] {            740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,          -1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000,           -595495729,  1047766204,  1875773301, -1637793284,  1379017098,   262792705,   191880010,  -251000180,          -1753047622,  -972355720,    90626881,  1644693418,  1503365577,   439653419,  1806361562,  1268823869       });        int[] refInt = {           -1478749726,  -1645579484,  -2075363835,  -2063444174,  -1834148336,  -1769045872,    -40711346,   1717441026,            2130656771,    783441285,    570433609,   1560023451,    653233971,   1368672434,    -72036215,   1071111800,             933776492,     26114960,     49888778,   1808107515,   1092989296,    754848337,   1336994364,  -1987450448,            -691190146,  -1803870839,   1110716866,   1173269113,   -391000050,   2014216908,    180756301,   -382891013,           -1908154585,   1580737629,   1080267957,   -125532248,   2094530239,   2132964485,   -438596348,   -760299445,            1058181869,   2050816800,  -1534429037,    -62552782,    824524142,   -818590371,  -1857695907,   -684762866,            -156556543,   -902759995,   -880795194,  -1387351132,  -1263017515,    448006597,    201038266,   1929826313,            -455367306,    672963027,   2000073013,  -1546842042,    446341090,   1001696686,   -779919012,   -347722602,           -1342821677,   1639571150,   -835315755,   1505585376,    367004975,  -2035864404,  -1786623553,   1249724913,             182435312,   1444514513,   1815333708,   1333772382,    299664001,   -284691169,   2034403374,   1423310887,           -1319051884,   1557286441,   -445198266,   -251809030,   1602786123,    944036382,  -1020529634,    258344235,             685254367,   1838964943,   -156674528,   -979736602,   -538312836,    234643178,    211152102,   -635498640,           -1036733933,  -1347589147,   -565609042,  -1358714165,    508618483,   -786364693,   2071450261,   1206956772,            -678931458,    167690617,    144698821,   1719720781,   1575869280,  -1343221123,  -1766469944,    284991647,            -717305514,    892653651,  -1368347075,   -615701972,   -730369849,   1360396003,  -1869287623,   1778269052,            -586061545,   -699517114,     61530249,  -1860611767,   -519660852,   1841085925,   1555610093,   -399979337,            -790345742,    422355947,   2007965433,   2044952550,  -1712164595,   -102915702,   -693865324,  -1894042487,           -1285020072,   -215883074,     95833252,   1625818040,  -1055951680,    513067085,   1825246558,   -553461652,           -1923361799,  -1869480206,    567232636,  -1751727150,  -1832301399,   -108136455,  -1312244126,     14006795,             850221366,   -382389732,  -1741556188,  -1317464467,   1948314870,    753994471,   1028235947,    342494132,           -1862256693,    723808794,   -234257642,   1609928369,   -802733456,   1315831915,   1436072885,   1224767136,            2144557791,  -1839965886,    224821018,  -1461697757,  -1080386760,   1638573498,  -1188173812,   -325181523,           -1750676219,  -1780415850,    698793362,   -908352052,    299746482,   -161660934,   1938166833,    800297005,              56640033,  -1214932666,  -1248124842,   1822796868,   1777615881,   -718517774,   1908159957,   1733053281,            1851844331,   1283519375,  -1771494956,   2060179999,   1666129209,   1919453531,   -498145770,    697567008,            1855487148,  -1587163491,    565216434,  -1477877933,   -925662919,   -806492585,  -1201439047,  -1424534232,            1788616523,     69414717,    655893636,  -1175978556,     24787512,   -861550001,    439525754,   -190433174,            -383811606,   -508589783,   1441608687,    608181366,   1539467064,    925903122,    697209654,   1878283393,           -1967567432,  -1659677763,   -249658183,    847096354,    397741956,   -125334541,  -1286840731,   1016461908,            -997968592,   1795331475,   1856856501,  -1716726445,   -582181331,   -887091847,    426964855,   -609219941,           -1456232632,   -483467616,   1069260754,    972242064,  -1406786247,   1954194029,     52627891,   1212755081,            2117436668,    281073392,    741537353,   -483063506,   1850906286,   -244876135,   -270818140,   1817568823        };        for (int i = 0; i < refInt.length; ++i) {            Assert.assertEquals(refInt[i], mt.nextInt());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import org.junit.Assert;import org.junit.Test;public class MersenneTwisterTest extends RandomGeneratorAbstractTest {    @Override    protected RandomGenerator makeGenerator() {        return new MersenneTwister(100);    }        // TODO: Some of the tests moved up to RandomGeneratorAbstractTest tested alternative seeding / constructors    // Tests exercising these features directly should be added to this class.        @Test    public void testMakotoNishimura() {        MersenneTwister mt = new MersenneTwister(new int[] {0x123, 0x234, 0x345, 0x456});        long[] refInt = {            1067595299l,  955945823l,  477289528l, 4107218783l, 4228976476l, 3344332714l, 3355579695l,  227628506l,            810200273l, 2591290167l, 2560260675l, 3242736208l,  646746669l, 1479517882l, 4245472273l, 1143372638l,            3863670494l, 3221021970l, 1773610557l, 1138697238l, 1421897700l, 1269916527l, 2859934041l, 1764463362l,            3874892047l, 3965319921l,   72549643l, 2383988930l, 2600218693l, 3237492380l, 2792901476l,  725331109l,            605841842l,  271258942l,  715137098l, 3297999536l, 1322965544l, 4229579109l, 1395091102l, 3735697720l,            2101727825l, 3730287744l, 2950434330l, 1661921839l, 2895579582l, 2370511479l, 1004092106l, 2247096681l,            2111242379l, 3237345263l, 4082424759l,  219785033l, 2454039889l, 3709582971l,  835606218l, 2411949883l,            2735205030l,  756421180l, 2175209704l, 1873865952l, 2762534237l, 4161807854l, 3351099340l,  181129879l,            3269891896l,  776029799l, 2218161979l, 3001745796l, 1866825872l, 2133627728l,   34862734l, 1191934573l,            3102311354l, 2916517763l, 1012402762l, 2184831317l, 4257399449l, 2899497138l, 3818095062l, 3030756734l,            1282161629l,  420003642l, 2326421477l, 2741455717l, 1278020671l, 3744179621l,  271777016l, 2626330018l,            2560563991l, 3055977700l, 4233527566l, 1228397661l, 3595579322l, 1077915006l, 2395931898l, 1851927286l,            3013683506l, 1999971931l, 3006888962l, 1049781534l, 1488758959l, 3491776230l,  104418065l, 2448267297l,            3075614115l, 3872332600l,  891912190l, 3936547759l, 2269180963l, 2633455084l, 1047636807l, 2604612377l,            2709305729l, 1952216715l,  207593580l, 2849898034l,  670771757l, 2210471108l,  467711165l,  263046873l,            3569667915l, 1042291111l, 3863517079l, 1464270005l, 2758321352l, 3790799816l, 2301278724l, 3106281430l,            7974801l, 2792461636l,  555991332l,  621766759l, 1322453093l,  853629228l,  686962251l, 1455120532l,            957753161l, 1802033300l, 1021534190l, 3486047311l, 1902128914l, 3701138056l, 4176424663l, 1795608698l,            560858864l, 3737752754l, 3141170998l, 1553553385l, 3367807274l,  711546358l, 2475125503l,  262969859l,            251416325l, 2980076994l, 1806565895l,  969527843l, 3529327173l, 2736343040l, 2987196734l, 1649016367l,            2206175811l, 3048174801l, 3662503553l, 3138851612l, 2660143804l, 1663017612l, 1816683231l,  411916003l,            3887461314l, 2347044079l, 1015311755l, 1203592432l, 2170947766l, 2569420716l,  813872093l, 1105387678l,            1431142475l,  220570551l, 4243632715l, 4179591855l, 2607469131l, 3090613241l,  282341803l, 1734241730l,            1391822177l, 1001254810l,  827927915l, 1886687171l, 3935097347l, 2631788714l, 3905163266l,  110554195l,            2447955646l, 3717202975l, 3304793075l, 3739614479l, 3059127468l,  953919171l, 2590123714l, 1132511021l,            3795593679l, 2788030429l,  982155079l, 3472349556l,  859942552l, 2681007391l, 2299624053l,  647443547l,            233600422l,  608168955l, 3689327453l, 1849778220l, 1608438222l, 3968158357l, 2692977776l, 2851872572l,            246750393l, 3582818628l, 3329652309l, 4036366910l, 1012970930l,  950780808l, 3959768744l, 2538550045l,            191422718l, 2658142375l, 3276369011l, 2927737484l, 1234200027l, 1920815603l, 3536074689l, 1535612501l,            2184142071l, 3276955054l,  428488088l, 2378411984l, 4059769550l, 3913744741l, 2732139246l,   64369859l,            3755670074l,  842839565l, 2819894466l, 2414718973l, 1010060670l, 1839715346l, 2410311136l,  152774329l,            3485009480l, 4102101512l, 2852724304l,  879944024l, 1785007662l, 2748284463l, 1354768064l, 3267784736l,            2269127717l, 3001240761l, 3179796763l,  895723219l,  865924942l, 4291570937l,   89355264l, 1471026971l,            4114180745l, 3201939751l, 2867476999l, 2460866060l, 3603874571l, 2238880432l, 3308416168l, 2072246611l,            2755653839l, 3773737248l, 1709066580l, 4282731467l, 2746170170l, 2832568330l,  433439009l, 3175778732l,            26248366l, 2551382801l,  183214346l, 3893339516l, 1928168445l, 1337157619l, 3429096554l, 3275170900l,            1782047316l, 4264403756l, 1876594403l, 4289659572l, 3223834894l, 1728705513l, 4068244734l, 2867840287l,            1147798696l,  302879820l, 1730407747l, 1923824407l, 1180597908l, 1569786639l,  198796327l,  560793173l,            2107345620l, 2705990316l, 3448772106l, 3678374155l,  758635715l,  884524671l,  486356516l, 1774865603l,            3881226226l, 2635213607l, 1181121587l, 1508809820l, 3178988241l, 1594193633l, 1235154121l,  326117244l,            2304031425l,  937054774l, 2687415945l, 3192389340l, 2003740439l, 1823766188l, 2759543402l,   10067710l,            1533252662l, 4132494984l,   82378136l,  420615890l, 3467563163l,  541562091l, 3535949864l, 2277319197l,            3330822853l, 3215654174l, 4113831979l, 4204996991l, 2162248333l, 3255093522l, 2219088909l, 2978279037l,            255818579l, 2859348628l, 3097280311l, 2569721123l, 1861951120l, 2907080079l, 2719467166l,  998319094l,            2521935127l, 2404125338l,  259456032l, 2086860995l, 1839848496l, 1893547357l, 2527997525l, 1489393124l,            2860855349l,   76448234l, 2264934035l,  744914583l, 2586791259l, 1385380501l,   66529922l, 1819103258l,            1899300332l, 2098173828l, 1793831094l,  276463159l,  360132945l, 4178212058l,  595015228l,  177071838l,            2800080290l, 1573557746l, 1548998935l,  378454223l, 1460534296l, 1116274283l, 3112385063l, 3709761796l,            827999348l, 3580042847l, 1913901014l,  614021289l, 4278528023l, 1905177404l,   45407939l, 3298183234l,            1184848810l, 3644926330l, 3923635459l, 1627046213l, 3677876759l,  969772772l, 1160524753l, 1522441192l,            452369933l, 1527502551l,  832490847l, 1003299676l, 1071381111l, 2891255476l,  973747308l, 4086897108l,            1847554542l, 3895651598l, 2227820339l, 1621250941l, 2881344691l, 3583565821l, 3510404498l,  849362119l,            862871471l,  797858058l, 2867774932l, 2821282612l, 3272403146l, 3997979905l,  209178708l, 1805135652l,            6783381l, 2823361423l,  792580494l, 4263749770l,  776439581l, 3798193823l, 2853444094l, 2729507474l,            1071873341l, 1329010206l, 1289336450l, 3327680758l, 2011491779l,   80157208l,  922428856l, 1158943220l,            1667230961l, 2461022820l, 2608845159l,  387516115l, 3345351910l, 1495629111l, 4098154157l, 3156649613l,            3525698599l, 4134908037l,  446713264l, 2137537399l, 3617403512l,  813966752l, 1157943946l, 3734692965l,            1680301658l, 3180398473l, 3509854711l, 2228114612l, 1008102291l,  486805123l,  863791847l, 3189125290l,            1050308116l, 3777341526l, 4291726501l,  844061465l, 1347461791l, 2826481581l,  745465012l, 2055805750l,            4260209475l, 2386693097l, 2980646741l,  447229436l, 2077782664l, 1232942813l, 4023002732l, 1399011509l,            3140569849l, 2579909222l, 3794857471l,  900758066l, 2887199683l, 1720257997l, 3367494931l, 2668921229l,            955539029l, 3818726432l, 1105704962l, 3889207255l, 2277369307l, 2746484505l, 1761846513l, 2413916784l,            2685127085l, 4240257943l, 1166726899l, 4215215715l, 3082092067l, 3960461946l, 1663304043l, 2087473241l,            4162589986l, 2507310778l, 1579665506l,  767234210l,  970676017l,  492207530l, 1441679602l, 1314785090l,            3262202570l, 3417091742l, 1561989210l, 3011406780l, 1146609202l, 3262321040l, 1374872171l, 1634688712l,            1280458888l, 2230023982l,  419323804l, 3262899800l,   39783310l, 1641619040l, 1700368658l, 2207946628l,            2571300939l, 2424079766l,  780290914l, 2715195096l, 3390957695l,  163151474l, 2309534542l, 1860018424l,            555755123l,  280320104l, 1604831083l, 2713022383l, 1728987441l, 3639955502l,  623065489l, 3828630947l,            4275479050l, 3516347383l, 2343951195l, 2430677756l,  635534992l, 3868699749l,  808442435l, 3070644069l,            4282166003l, 2093181383l, 2023555632l, 1568662086l, 3422372620l, 4134522350l, 3016979543l, 3259320234l,            2888030729l, 3185253876l, 4258779643l, 1267304371l, 1022517473l,  815943045l,  929020012l, 2995251018l,            3371283296l, 3608029049l, 2018485115l,  122123397l, 2810669150l, 1411365618l, 1238391329l, 1186786476l,            3155969091l, 2242941310l, 1765554882l,  279121160l, 4279838515l, 1641578514l, 3796324015l,   13351065l,            103516986l, 1609694427l,  551411743l, 2493771609l, 1316337047l, 3932650856l, 4189700203l,  463397996l,            2937735066l, 1855616529l, 2626847990l,   55091862l, 3823351211l,  753448970l, 4045045500l, 1274127772l,            1124182256l,   92039808l, 2126345552l,  425973257l,  386287896l, 2589870191l, 1987762798l, 4084826973l,            2172456685l, 3366583455l, 3602966653l, 2378803535l, 2901764433l, 3716929006l, 3710159000l, 2653449155l,            3469742630l, 3096444476l, 3932564653l, 2595257433l,  318974657l, 3146202484l,  853571438l,  144400272l,            3768408841l,  782634401l, 2161109003l,  570039522l, 1886241521l,   14249488l, 2230804228l, 1604941699l,            3928713335l, 3921942509l, 2155806892l,  134366254l,  430507376l, 1924011722l,  276713377l,  196481886l,            3614810992l, 1610021185l, 1785757066l,  851346168l, 3761148643l, 2918835642l, 3364422385l, 3012284466l,            3735958851l, 2643153892l, 3778608231l, 1164289832l,  205853021l, 2876112231l, 3503398282l, 3078397001l,            3472037921l, 1748894853l, 2740861475l,  316056182l, 1660426908l,  168885906l,  956005527l, 3984354789l,            566521563l, 1001109523l, 1216710575l, 2952284757l, 3834433081l, 3842608301l, 2467352408l, 3974441264l,            3256601745l, 1409353924l, 1329904859l, 2307560293l, 3125217879l, 3622920184l, 3832785684l, 3882365951l,            2308537115l, 2659155028l, 1450441945l, 3532257603l, 3186324194l, 1225603425l, 1124246549l,  175808705l,            3009142319l, 2796710159l, 3651990107l,  160762750l, 1902254979l, 1698648476l, 1134980669l,  497144426l,            3302689335l, 4057485630l, 3603530763l, 4087252587l,  427812652l,  286876201l,  823134128l, 1627554964l,            3745564327l, 2589226092l, 4202024494l,   62878473l, 3275585894l, 3987124064l, 2791777159l, 1916869511l,            2585861905l, 1375038919l, 1403421920l,   60249114l, 3811870450l, 3021498009l, 2612993202l,  528933105l,            2757361321l, 3341402964l, 2621861700l,  273128190l, 4015252178l, 3094781002l, 1621621288l, 2337611177l,            1796718448l, 1258965619l, 4241913140l, 2138560392l, 3022190223l, 4174180924l,  450094611l, 3274724580l,            617150026l, 2704660665l, 1469700689l, 1341616587l,  356715071l, 1188789960l, 2278869135l, 1766569160l,            2795896635l,   57824704l, 2893496380l, 1235723989l, 1630694347l, 3927960522l,  428891364l, 1814070806l,            2287999787l, 4125941184l, 3968103889l, 3548724050l, 1025597707l, 1404281500l, 2002212197l,   92429143l,            2313943944l, 2403086080l, 3006180634l, 3561981764l, 1671860914l, 1768520622l, 1803542985l,  844848113l,            3006139921l, 1410888995l, 1157749833l, 2125704913l, 1789979528l, 1799263423l,  741157179l, 2405862309l,            767040434l, 2655241390l, 3663420179l, 2172009096l, 2511931187l, 1680542666l,  231857466l, 1154981000l,            157168255l, 1454112128l, 3505872099l, 1929775046l, 2309422350l, 2143329496l, 2960716902l,  407610648l,            2938108129l, 2581749599l,  538837155l, 2342628867l,  430543915l,  740188568l, 1937713272l, 3315215132l,            2085587024l, 4030765687l,  766054429l, 3517641839l,  689721775l, 1294158986l, 1753287754l, 4202601348l,            1974852792l,   33459103l, 3568087535l, 3144677435l, 1686130825l, 4134943013l, 3005738435l, 3599293386l,            426570142l,  754104406l, 3660892564l, 1964545167l,  829466833l,  821587464l, 1746693036l, 1006492428l,            1595312919l, 1256599985l, 1024482560l, 1897312280l, 2902903201l,  691790057l, 1037515867l, 3176831208l,            1968401055l, 2173506824l, 1089055278l, 1748401123l, 2941380082l,  968412354l, 1818753861l, 2973200866l,            3875951774l, 1119354008l, 3988604139l, 1647155589l, 2232450826l, 3486058011l, 3655784043l, 3759258462l,            847163678l, 1082052057l,  989516446l, 2871541755l, 3196311070l, 3929963078l,  658187585l, 3664944641l,            2175149170l, 2203709147l, 2756014689l, 2456473919l, 3890267390l, 1293787864l, 2830347984l, 3059280931l,            4158802520l, 1561677400l, 2586570938l,  783570352l, 1355506163l,   31495586l, 3789437343l, 3340549429l,            2092501630l,  896419368l,  671715824l, 3530450081l, 3603554138l, 1055991716l, 3442308219l, 1499434728l,            3130288473l, 3639507000l,   17769680l, 2259741420l,  487032199l, 4227143402l, 3693771256l, 1880482820l,            3924810796l,  381462353l, 4017855991l, 2452034943l, 2736680833l, 2209866385l, 2128986379l,  437874044l,            595759426l,  641721026l, 1636065708l, 3899136933l,  629879088l, 3591174506l,  351984326l, 2638783544l,            2348444281l, 2341604660l, 2123933692l,  143443325l, 1525942256l,  364660499l,  599149312l,  939093251l,            1523003209l,  106601097l,  376589484l, 1346282236l, 1297387043l,  764598052l, 3741218111l,  933457002l,            1886424424l, 3219631016l,  525405256l, 3014235619l,  323149677l, 2038881721l, 4100129043l, 2851715101l,            2984028078l, 1888574695l, 2014194741l, 3515193880l, 4180573530l, 3461824363l, 2641995497l, 3179230245l,            2902294983l, 2217320456l, 4040852155l, 1784656905l, 3311906931l,   87498458l, 2752971818l, 2635474297l,            2831215366l, 3682231106l, 2920043893l, 3772929704l, 2816374944l,  309949752l, 2383758854l,  154870719l,            385111597l, 1191604312l, 1840700563l,  872191186l, 2925548701l, 1310412747l, 2102066999l, 1504727249l,            3574298750l, 1191230036l, 3330575266l, 3180292097l, 3539347721l,  681369118l, 3305125752l, 3648233597l,            950049240l, 4173257693l, 1760124957l,  512151405l,  681175196l,  580563018l, 1169662867l, 4015033554l,            2687781101l,  699691603l, 2673494188l, 1137221356l,  123599888l,  472658308l, 1053598179l, 1012713758l,            3481064843l, 3759461013l, 3981457956l, 3830587662l, 1877191791l, 3650996736l,  988064871l, 3515461600l,            4089077232l, 2225147448l, 1249609188l, 2643151863l, 3896204135l, 2416995901l, 1397735321l, 3460025646l        };        double[] refDouble = {            0.76275443, 0.99000644, 0.98670464, 0.10143112, 0.27933125, 0.69867227, 0.94218740, 0.03427201,            0.78842173, 0.28180608, 0.92179002, 0.20785655, 0.54534773, 0.69644020, 0.38107718, 0.23978165,            0.65286910, 0.07514568, 0.22765211, 0.94872929, 0.74557914, 0.62664415, 0.54708246, 0.90959343,            0.42043116, 0.86334511, 0.19189126, 0.14718544, 0.70259889, 0.63426346, 0.77408121, 0.04531601,            0.04605807, 0.88595519, 0.69398270, 0.05377184, 0.61711170, 0.05565708, 0.10133577, 0.41500776,            0.91810699, 0.22320679, 0.23353705, 0.92871862, 0.98897234, 0.19786706, 0.80558809, 0.06961067,            0.55840445, 0.90479405, 0.63288060, 0.95009721, 0.54948447, 0.20645042, 0.45000959, 0.87050869,            0.70806991, 0.19406895, 0.79286390, 0.49332866, 0.78483914, 0.75145146, 0.12341941, 0.42030252,            0.16728160, 0.59906494, 0.37575460, 0.97815160, 0.39815952, 0.43595080, 0.04952478, 0.33917805,            0.76509902, 0.61034321, 0.90654701, 0.92915732, 0.85365931, 0.18812377, 0.65913428, 0.28814566,            0.59476081, 0.27835931, 0.60722542, 0.68310435, 0.69387186, 0.03699800, 0.65897714, 0.17527003,            0.02889304, 0.86777366, 0.12352068, 0.91439461, 0.32022990, 0.44445731, 0.34903686, 0.74639273,            0.65918367, 0.92492794, 0.31872642, 0.77749724, 0.85413832, 0.76385624, 0.32744211, 0.91326300,            0.27458185, 0.22190155, 0.19865383, 0.31227402, 0.85321225, 0.84243342, 0.78544200, 0.71854080,            0.92503892, 0.82703064, 0.88306297, 0.47284073, 0.70059042, 0.48003761, 0.38671694, 0.60465770,            0.41747204, 0.47163243, 0.72750808, 0.65830223, 0.10955369, 0.64215401, 0.23456345, 0.95944940,            0.72822249, 0.40888451, 0.69980355, 0.26677428, 0.57333635, 0.39791582, 0.85377858, 0.76962816,            0.72004885, 0.90903087, 0.51376506, 0.37732665, 0.12691640, 0.71249738, 0.81217908, 0.37037313,            0.32772374, 0.14238259, 0.05614811, 0.74363008, 0.39773267, 0.94859135, 0.31452454, 0.11730313,            0.62962618, 0.33334237, 0.45547255, 0.10089665, 0.56550662, 0.60539371, 0.16027624, 0.13245301,            0.60959939, 0.04671662, 0.99356286, 0.57660859, 0.40269560, 0.45274629, 0.06699735, 0.85064246,            0.87742744, 0.54508392, 0.87242982, 0.29321385, 0.67660627, 0.68230715, 0.79052073, 0.48592054,            0.25186266, 0.93769755, 0.28565487, 0.47219067, 0.99054882, 0.13155240, 0.47110470, 0.98556600,            0.84397623, 0.12875246, 0.90953202, 0.49129015, 0.23792727, 0.79481194, 0.44337770, 0.96564297,            0.67749118, 0.55684872, 0.27286897, 0.79538393, 0.61965356, 0.22487929, 0.02226018, 0.49248200,            0.42247006, 0.91797788, 0.99250134, 0.23449967, 0.52531508, 0.10246337, 0.78685622, 0.34310922,            0.89892996, 0.40454552, 0.68608407, 0.30752487, 0.83601319, 0.54956031, 0.63777550, 0.82199797,            0.24890696, 0.48801123, 0.48661910, 0.51223987, 0.32969635, 0.31075073, 0.21393155, 0.73453207,            0.15565705, 0.58584522, 0.28976728, 0.97621478, 0.61498701, 0.23891470, 0.28518540, 0.46809591,            0.18371914, 0.37597910, 0.13492176, 0.66849449, 0.82811466, 0.56240330, 0.37548956, 0.27562998,            0.27521910, 0.74096121, 0.77176757, 0.13748143, 0.99747138, 0.92504502, 0.09175241, 0.21389176,            0.21766512, 0.31183245, 0.23271221, 0.21207367, 0.57903312, 0.77523344, 0.13242613, 0.31037988,            0.01204835, 0.71652949, 0.84487594, 0.14982178, 0.57423142, 0.45677888, 0.48420169, 0.53465428,            0.52667473, 0.46880526, 0.49849733, 0.05670710, 0.79022476, 0.03872047, 0.21697212, 0.20443086,            0.28949326, 0.81678186, 0.87629474, 0.92297064, 0.27373097, 0.84625273, 0.51505586, 0.00582792,            0.33295971, 0.91848412, 0.92537226, 0.91760033, 0.07541125, 0.71745848, 0.61158698, 0.00941650,            0.03135554, 0.71527471, 0.24821915, 0.63636652, 0.86159918, 0.26450229, 0.60160194, 0.35557725,            0.24477500, 0.07186456, 0.51757096, 0.62120362, 0.97981062, 0.69954667, 0.21065616, 0.13382753,            0.27693186, 0.59644095, 0.71500764, 0.04110751, 0.95730081, 0.91600724, 0.47704678, 0.26183479,            0.34706971, 0.07545431, 0.29398385, 0.93236070, 0.60486023, 0.48015011, 0.08870451, 0.45548581,            0.91872718, 0.38142712, 0.10668643, 0.01397541, 0.04520355, 0.93822273, 0.18011940, 0.57577277,            0.91427606, 0.30911399, 0.95853475, 0.23611214, 0.69619891, 0.69601980, 0.76765372, 0.58515930,            0.49479057, 0.11288752, 0.97187699, 0.32095365, 0.57563608, 0.40760618, 0.78703383, 0.43261152,            0.90877651, 0.84686346, 0.10599030, 0.72872803, 0.19315490, 0.66152912, 0.10210518, 0.06257876,            0.47950688, 0.47062066, 0.72701157, 0.48915116, 0.66110261, 0.60170685, 0.24516994, 0.12726050,            0.03451185, 0.90864994, 0.83494878, 0.94800035, 0.91035206, 0.14480751, 0.88458997, 0.53498312,            0.15963215, 0.55378627, 0.35171349, 0.28719791, 0.09097957, 0.00667896, 0.32309622, 0.87561479,            0.42534520, 0.91748977, 0.73908457, 0.41793223, 0.99279792, 0.87908370, 0.28458072, 0.59132853,            0.98672190, 0.28547393, 0.09452165, 0.89910674, 0.53681109, 0.37931425, 0.62683489, 0.56609740,            0.24801549, 0.52948179, 0.98328855, 0.66403523, 0.55523786, 0.75886666, 0.84784685, 0.86829981,            0.71448906, 0.84670080, 0.43922919, 0.20771016, 0.64157936, 0.25664246, 0.73055695, 0.86395782,            0.65852932, 0.99061803, 0.40280575, 0.39146298, 0.07291005, 0.97200603, 0.20555729, 0.59616495,            0.08138254, 0.45796388, 0.33681125, 0.33989127, 0.18717090, 0.53545811, 0.60550838, 0.86520709,            0.34290701, 0.72743276, 0.73023855, 0.34195926, 0.65019733, 0.02765254, 0.72575740, 0.32709576,            0.03420866, 0.26061893, 0.56997511, 0.28439072, 0.84422744, 0.77637570, 0.55982168, 0.06720327,            0.58449067, 0.71657369, 0.15819609, 0.58042821, 0.07947911, 0.40193792, 0.11376012, 0.88762938,            0.67532159, 0.71223735, 0.27829114, 0.04806073, 0.21144026, 0.58830274, 0.04140071, 0.43215628,            0.12952729, 0.94668759, 0.87391019, 0.98382450, 0.27750768, 0.90849647, 0.90962737, 0.59269720,            0.96102026, 0.49544979, 0.32007095, 0.62585546, 0.03119821, 0.85953001, 0.22017528, 0.05834068,            0.80731217, 0.53799961, 0.74166948, 0.77426600, 0.43938444, 0.54862081, 0.58575513, 0.15886492,            0.73214332, 0.11649057, 0.77463977, 0.85788827, 0.17061997, 0.66838056, 0.96076133, 0.07949296,            0.68521946, 0.89986254, 0.05667410, 0.12741385, 0.83470977, 0.63969104, 0.46612929, 0.10200126,            0.01194925, 0.10476340, 0.90285217, 0.31221221, 0.32980614, 0.46041971, 0.52024973, 0.05425470,            0.28330912, 0.60426543, 0.00598243, 0.97244013, 0.21135841, 0.78561597, 0.78428734, 0.63422849,            0.32909934, 0.44771136, 0.27380750, 0.14966697, 0.18156268, 0.65686758, 0.28726350, 0.97074787,            0.63676171, 0.96649494, 0.24526295, 0.08297372, 0.54257548, 0.03166785, 0.33735355, 0.15946671,            0.02102971, 0.46228045, 0.11892296, 0.33408336, 0.29875681, 0.29847692, 0.73767569, 0.02080745,            0.62980060, 0.08082293, 0.22993106, 0.25031439, 0.87787525, 0.45150053, 0.13673441, 0.63407612,            0.97907688, 0.52241942, 0.50580158, 0.06273902, 0.05270283, 0.77031811, 0.05113352, 0.24393329,            0.75036441, 0.37436336, 0.22877652, 0.59975358, 0.85707591, 0.88691457, 0.85547165, 0.36641027,            0.58720133, 0.45462835, 0.09243817, 0.32981586, 0.07820411, 0.25421519, 0.36004706, 0.60092307,            0.46192412, 0.36758683, 0.98424170, 0.08019934, 0.68594024, 0.45826386, 0.29962317, 0.79365413,            0.89231296, 0.49478547, 0.87645944, 0.23590734, 0.28106737, 0.75026285, 0.08136314, 0.79582424,            0.76010628, 0.82792971, 0.27947652, 0.72482861, 0.82191216, 0.46171689, 0.79189752, 0.96043686,            0.51609668, 0.88995725, 0.28998963, 0.55191845, 0.03934737, 0.83033700, 0.49553013, 0.98009549,            0.19017594, 0.98347750, 0.33452066, 0.87144372, 0.72106301, 0.71272114, 0.71465963, 0.88361677,            0.85571283, 0.73782329, 0.20920458, 0.34855153, 0.46766817, 0.02780062, 0.74898344, 0.03680650,            0.44866557, 0.77426312, 0.91025891, 0.25195236, 0.87319953, 0.63265037, 0.25552148, 0.27422476,            0.95217406, 0.39281839, 0.66441573, 0.09158900, 0.94515992, 0.07800798, 0.02507888, 0.39901462,            0.17382573, 0.12141278, 0.85502334, 0.19902911, 0.02160210, 0.44460522, 0.14688742, 0.68020336,            0.71323733, 0.60922473, 0.95400380, 0.99611159, 0.90897777, 0.41073520, 0.66206647, 0.32064685,            0.62805003, 0.50677209, 0.52690101, 0.87473387, 0.73918362, 0.39826974, 0.43683919, 0.80459118,            0.32422684, 0.01958019, 0.95319576, 0.98326137, 0.83931735, 0.69060863, 0.33671416, 0.68062550,            0.65152380, 0.33392969, 0.03451730, 0.95227244, 0.68200635, 0.85074171, 0.64721009, 0.51234433,            0.73402047, 0.00969637, 0.93835057, 0.80803854, 0.31485260, 0.20089527, 0.01323282, 0.59933780,            0.31584602, 0.20209563, 0.33754800, 0.68604181, 0.24443049, 0.19952227, 0.78162632, 0.10336988,            0.11360736, 0.23536740, 0.23262256, 0.67803776, 0.48749791, 0.74658435, 0.92156640, 0.56706407,            0.36683221, 0.99157136, 0.23421374, 0.45183767, 0.91609720, 0.85573315, 0.37706276, 0.77042618,            0.30891908, 0.40709595, 0.06944866, 0.61342849, 0.88817388, 0.58734506, 0.98711323, 0.14744128,            0.63242656, 0.87704136, 0.68347125, 0.84446569, 0.43265239, 0.25146321, 0.04130111, 0.34259839,            0.92697368, 0.40878778, 0.56990338, 0.76204273, 0.19820348, 0.66314909, 0.02482844, 0.06669207,            0.50205581, 0.26084093, 0.65139159, 0.41650223, 0.09733904, 0.56344203, 0.62651696, 0.67332139,            0.58037374, 0.47258086, 0.21010758, 0.05713135, 0.89390629, 0.10781246, 0.32037450, 0.07628388,            0.34227964, 0.42190597, 0.58201860, 0.77363549, 0.49595133, 0.86031236, 0.83906769, 0.81098161,            0.26694195, 0.14215941, 0.88210306, 0.53634237, 0.12090720, 0.82480459, 0.75930318, 0.31847147,            0.92768077, 0.01037616, 0.56201727, 0.88107122, 0.35925856, 0.85860762, 0.61109408, 0.70408301,            0.58434977, 0.92192494, 0.62667915, 0.75988365, 0.06858761, 0.36156496, 0.58057195, 0.13636150,            0.57719713, 0.59340255, 0.63530602, 0.22976282, 0.71915530, 0.41162531, 0.63979565, 0.09931342,            0.79344045, 0.10893790, 0.84450224, 0.23122236, 0.99485593, 0.73637397, 0.17276368, 0.13357764,            0.74965804, 0.64991737, 0.61990341, 0.41523170, 0.05878239, 0.05687301, 0.05497131, 0.42868366,            0.42571090, 0.25810502, 0.89642955, 0.30439758, 0.39310223, 0.11357431, 0.04288255, 0.23397550,            0.11200634, 0.85621396, 0.89733974, 0.37508865, 0.42077265, 0.68597384, 0.72781399, 0.19296476,            0.61699087, 0.31667128, 0.67756410, 0.00177323, 0.05725176, 0.79474693, 0.18885238, 0.06724856,            0.68193156, 0.42202167, 0.22082041, 0.28554673, 0.64995708, 0.87851940, 0.29124547, 0.61009521,            0.87374537, 0.05743712, 0.69902994, 0.81925115, 0.45653873, 0.37236821, 0.31118709, 0.52734307,            0.39672836, 0.38185294, 0.30163915, 0.17374510, 0.04913278, 0.90404879, 0.25742801, 0.58266467,            0.97663209, 0.79823377, 0.36437958, 0.15206043, 0.26529938, 0.22690047, 0.05839021, 0.84721160,            0.18622435, 0.37809403, 0.55706977, 0.49828704, 0.47659049, 0.24289680, 0.88477595, 0.07807463,            0.56245739, 0.73490635, 0.21099431, 0.13164942, 0.75840044, 0.66877037, 0.28988183, 0.44046090,            0.24967434, 0.80048356, 0.26029740, 0.30416821, 0.64151867, 0.52067892, 0.12880774, 0.85465381,            0.02690525, 0.19149288, 0.49630295, 0.79682619, 0.43566145, 0.00288078, 0.81484193, 0.03763639,            0.68529083, 0.01339574, 0.38405386, 0.30537067, 0.22994703, 0.44000045, 0.27217985, 0.53831243,            0.02870435, 0.86282045, 0.61831306, 0.09164956, 0.25609707, 0.07445781, 0.72185784, 0.90058883,            0.30070608, 0.94476583, 0.56822213, 0.21933909, 0.96772793, 0.80063440, 0.26307906, 0.31183306,            0.16501252, 0.55436179, 0.68562285, 0.23829083, 0.86511559, 0.57868991, 0.81888344, 0.20126869,            0.93172350, 0.66028129, 0.21786948, 0.78515828, 0.10262106, 0.35390326, 0.79303876, 0.63427924,            0.90479631, 0.31024934, 0.60635447, 0.56198079, 0.63573813, 0.91854197, 0.99701497, 0.83085849,            0.31692291, 0.01925964, 0.97446405, 0.98751283, 0.60944293, 0.13751018, 0.69519957, 0.68956636,            0.56969015, 0.46440193, 0.88341765, 0.36754434, 0.89223647, 0.39786427, 0.85055280, 0.12749961,            0.79452122, 0.89449784, 0.14567830, 0.45716830, 0.74822309, 0.28200437, 0.42546044, 0.17464886,            0.68308746, 0.65496587, 0.52935411, 0.12736159, 0.61523955, 0.81590528, 0.63107864, 0.39786553,            0.20102294, 0.53292914, 0.75485590, 0.59847044, 0.32861691, 0.12125866, 0.58917183, 0.07638293,            0.86845380, 0.29192617, 0.03989733, 0.52180460, 0.32503407, 0.64071852, 0.69516575, 0.74254998,            0.54587026, 0.48713246, 0.32920155, 0.08719954, 0.63497059, 0.54328459, 0.64178757, 0.45583809,            0.70694291, 0.85212760, 0.86074305, 0.33163422, 0.85739792, 0.59908488, 0.74566046, 0.72157152        };        for (int i = 0; i < refInt.length; ++i) {            int r = mt.nextInt();            Assert.assertEquals(refInt[i], (r & 0x7fffffffl) | ((r < 0) ? 0x80000000l : 0x0l));        }        for (int i = 0; i < refDouble.length; ++i) {            int r = mt.nextInt();            Assert.assertEquals(refDouble[i],                         ((r & 0x7fffffffl) | ((r < 0) ? 0x80000000l : 0x0l)) / 4294967296.0,                         1.0e-8);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import org.junit.Assert;import org.junit.Test;public class Well512aTest extends RandomGeneratorAbstractTest {        @Override    public RandomGenerator makeGenerator() {        return new Well512a(100);    }    @Test    public void testReferenceCode() {        Well512a mt = new Well512a(new int[] {            740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,          -1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000       });        int[] refInt = {            1634813289,   1876773016,   -973836208,  -2130023652,  -1045460084,  -1834384857,   1691032973,    609714289,            2033920362,    555915483,      6680992,   1958127415,   1866469645,  -1471336965,   2049178762,   -192324811,           -2056050066,    810879705,   1405046309,   -781317118,   1012782311,  -1045081032,    728377508,   1473511660,             290489070,    326666761,   2018299979,  -1876688058,   1239968501,   1464625040,   2025151042,   -101397407,            1387902041,    210959839,   1366359326,   -476473433,    153180037,  -1607631523,   -506743495,     17888738,             313865008,   -340504498,    586684079,   1243699375,    753162229,   -646761694,   -739189655,   -210120185,           -1856358726,   -628255542,  -1812798197,   1416288088,   1077967722,   -846846208,   1379850409,   -580183344,              -1858959,    210859778,    295841424,   1492774865,  -1415543680,   -344870570,  -1942779197,   1549510646,            -389544849,    314254218,     11784988,  -1311757368,   1719514841,   -764610517,   1296788970,   -994707050,             783854563,    422654144,    387639079,   1219688425,   2144352572,   -834212874,  -1036550358,    935909479,            -568610842,   1327498837,   -588933178,   1910065754,    -40851599,   -182063170,   1302731458,    541311559,           -1647345522,    805224371,  -1721196679,   1518507830,   -952689880,   -433276260,    509675254,   -777259954,            1277810106,    284054896,    936042202,   2036836351,   1956412426,  -1186403024,    287795400,   2135311211,             720485927,   1500695024,   -281656583,  -1277937322,  -1628968482,   1242814831,  -2030700974,   1473867890,             440813549,  -1357033971,     28384076,   1602731216,   -641465746,   -609054347,    635938444,   1472898176,            1476894555,   -747974186,  -1590337055,   -884242108,   -389736197,  -2066984505,   1087103272,  -1236446290,              31657463,   1835715432,   -468439078,  -2132633204,   -434609235,    258308151,   1851926761,  -1630139159,           -1344617241,   1969204215,    619463174,   -174392624,    207475487,  -1619828078,   1327980298,    -83968178,             445951782,  -1786230541,      6279288,   -580982231,   1550645552,   2006533941,    275746007,    455676647,            2019637349,   1115547704,  -1313120106,   -516213449,     73752461,  -1382448112,    398589620,   1319888048,           -1595572334,   1566934536,  -1735685764,  -1509545339,   1458173912,   -549395819,   -618827040,   1516624531,            1900757187,  -1454200688,    965524719,    488355065,  -1869294316,   -810641680,  -2059428251,   1454656431,            1329120541,   -232185900,   -994996943,   1855980910,   -452077812,   1565630611,    759842266,   1241435187,           -1390456063,   1946400597,  -2032319771,    683667881,    905911106,   1983310786,    120010546,    526018017,           -1946881912,    205004987,  -1307250612,   2130980818,   2052864161,    189839787,   1789478047,    406168885,           -1145186347,      8507675,   1277188815,   1492619042,   2009819675,  -1627411598,   -851016743,  -1828234956,            1962622506,   2140398255,    236935165,   -337237772,   1263419111,    516775236,   -335741025,   1391328225,             455979249,  -1457534664,   -657606241,    485648133,   1762116343,   1194889600,    817834937,    321150162,             131159182,    290277758,  -1876924740,  -1770401129,   1291602973,  -1003642974,  -1580211929,   1520422021,            -399171579,    -24315308,    453805396,   -659197747,   -205656847,    466526550,   1444397201,   1178091401,           -1157268826,   -602394028,  -1370668795,   1614896435,   1699071659,   1864753793,   1888518358,  -1721244514,            1812776767,    668822227,   -297283057,   2130183333,  -1169618692,    912860240,  -2028253096,   1244694278        };        for (int i = 0; i < refInt.length; ++i) {            Assert.assertEquals(refInt[i], mt.nextInt());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import org.junit.Assert;import org.junit.Test;public class Well19937cTest extends RandomGeneratorAbstractTest {        @Override    public RandomGenerator makeGenerator() {        return new Well19937c(100);    }    @Test    public void testReferenceCode() {        int[] base = {              740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,            -1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000,             -595495729,  1047766204,  1875773301, -1637793284,  1379017098,   262792705,   191880010,  -251000180,            -1753047622,  -972355720,    90626881,  1644693418,  1503365577,   439653419,  1806361562,  1268823869         };        int[] init = new int[624];        for (int i = 0; i < init.length; ++i) {            init[i] = base[i % base.length] + i;        }        Well19937c mt = new Well19937c(init);        int[] refInt = {            2128528153,    327121884,    935445371,    -83026433,  -1041143083,   2084595880,  -1073535198,  -1678863790,   -523636021,  -1514837782,   -736786810,   1527711112,  -1051227939,    978703380,    410322163,   1727815703,            -648426354,    636056441,   1954420292,     17754810,   -958628705,  -1091307602,   1793078738,  -1680336346,   1792171272,    941973796,  -2066152330,  -1248758068,  -1061211586,    262020189,   1276960217,   -233886784,            1767509252,  -1811939255,   -406116097,   -742435920,  -1349799525,    240329556,   -332161345,   1488943143,   -332244280,   2093328957,    674753300,  -1930135556,    257111467,     63793650,  -1964335223,   1315849133,            -797349146,   1372022250,  -1451892049,  -1325138957,   -870401239,  -1294317369,     91490879,    386205044,   -704074702,  -1230679067,   1513674392,   -262996240,   1196007314,   1398903796,    803719762,  -1750926831,           -1268814180,   1233515404,   1498313934,   -970591257,    611113671,   -261632474,   1834097325,   1709440492,   -150396854,   2120561003,    -62645660,    479080234,   1535125050,   1823378695,  -1129289329,  -1095198399,            2092564733,     78836308,   -692015409,   1647147229,  -1847922219,   1838279320,   -848333841,  -1375151778,    920238861,   1512628290,   -749439404,    288851918,   -427218675,    679640964,    425700808,  -2077624511,           -1929434455,   -647176419,    650437190,  -1926749131,  -1564744729,    734494454,    108193743,    246246679,    810042628,   1952337771,   1089253730,  -1874275331,   1428419392,   -492969232,   1945270770,   -201265602,            -755490251,   -624426214,   -699605715,   -113446478,    809091299,  -1521531511,   1136505389,   -523660964,    132928433,   1926559713,  -1485314325,   -508322506,     46307756,  -1627479740,   -589386406,  -1855555892,             584299545,   1272841066,   -597242658,    925134545,   1102566453,   -753335037,     -9523218,  -1778632375,    568963646,    764338254,   1259944540,  -2000124642,   1307414525,   -151384482,    807294400,   1993749511,             -15503094,   -709471492,   2104830082,   1387684315,  -1929056119,    224254668,   -733550950,   -889466978,  -1987783335,   -437144026,    995905753,  -1021386158,  -1096313388,  -1014152835,  -1303258241,   1201884788,           -1845042397,   1421462511,    980805867,   2143771251,    481226968,   1790544569,    328448328,   1995857639,    -66668269,  -1411421267,   -222586606,    866950765,   -308713926,  -1048350893,    993222402,  -1139265642,            -871837948,   1145571913,    381928580,     35386691,   1640961123,  -1192981020,    775971009,    594246635,   1603197812,   -575106766,   2023682000,  -1636301903,   -718093720,  -1666421635,  -2146115988,    320593570,             287355418,    454400027,   1112753817,   1751196267,    782077910,  -1478447368,  -1007557264,   -862315517,  -2035355952,   2123515250,   -557641502,  -1789932035,    879640129,     44167603,    791148984,   1382939723,           -2135684233,   1825489580,    937345485,  -1839983359,  -1536880111,  -1472578359,   1548052748,  -1471535862,    -14508727,   1509621398,  -2134967452,   -787485401,    815341660,   -327905128,   1028096737,    866906991,           -1585990806,    859229080,    234806270,    998518056,  -1897890815,   -900923587,   1179856752,   1529572451,    620486106,   1119836556,   1661285564,   2097404633,  -1437490790,    265306115,   -984880135,   1326751968,            1280043536,    680210701,    155786166,   1550973250,   -325781949,   -597789777,     -1939780,   1345275487,   1930450001,    941449704,    669301309,    693651713,   -990721514,    582968326,    976132553,  -1892942099,           -1065070157,   -711990993,   -688974833,  -1026091683,   1115346827,  -1305730749,  -1733626381,   -364566696,    -21761572,    -37152746,   -262011730,   1302722752,  -1806313409,   -767072509,    764112137,   1671157377,            1837645038,  -1021606421,  -1781898911,   -232127459,   -310742675,  -1818095744,  -1128320656,   -705565953,   -354445532,   -523172807,   -433877202,    131904485,    -64292316,    381829280,    229820263,   1797992622,            1359665678,    978481451,   -885267130,  -1415988446,   -356533788,   -961419072,   1938703090,    708344111,    679299953,    744615129,   1328811158,   1257588574,    569216282,   -753296151,  -1519838713,   2016884452,            1062684606,   1561736790,   2028643511,  -1353001615,    886376832,   1466953172,   1664783899,   1290079981,    -57483993,  -1176112430,   1634916316,   1976304475,   1374136869,   -648738039,   1058175869,   -909000745,           -1526439218,    726626991,   2066596202,     64980943,    -26166577,   -885900005,  -1821546816,  -1103727665,    730606315,  -1324948459,   -696956940,  -1300869403,   1171578314,    797249074,  -1600611618,   1928247682,             307164165,  -1482476232,  -1886179640,   1306433392,   1945271359,  -1272113751,  -1285984081,  -2057145549,    795047465,   1262569087,  -1239828121,   1426641636,   -786371495,   2120199316,   1273690652,     74457589,           -1033394229,    338952565,     46122958,   1225741533,   2115308090,    678200841,  -1618264885,   -101162569,  -1628976330,  -1232839500,    468709044,   1876019116,     92723122,    233398255,   -554960844,     38494196,            -406437278,   2083528643,  -1106878615,   -340722557,  -2123964932,    223183343,    108918116,  -1014629054,   -901344544,   -838896840,  -1908460517,  -1763508731,   -926890833,   1703791049,   -667755577,   1694418389,             791641263,   1095689677,   1119202039,  -1419111438,  -2012259010,    188017439,  -1775110395,  -1971099661,  -1688113734,    131472813,   -776304959,   1511388884,   2080864872,  -1733824651,   1992147495,   1119828320,            1065336924,  -1357606762,    462963503,   1180719494,   -202678962,   -892646595,    605869323,   1144255663,    878462678,  -1051371303,    872374876,    631322271,   -172600544,  -1552071375,  -1939570033,    151973117,            1640861022,    310682640,     34192866,   2057773671,  -2004476027,  -1879238973,    582736114,    900581664,   -427390545,  -1232348528,   -535115984,   1321853054,     69386780,  -1729375922,   1418473715,   1022091451,             496799289,    -80757405,  -1903543310,  -1128846846,      1703964,   1984450945,    856753858,   -812919184,    775486323,  -1376056193,    638628840,    314243536,   1030626207,    644050997,     73923896,    362270613,             236584904,   1463240891,   -223614432,    435371594,   -751940030,   -124274553,  -1991092884,   1579624267,   1249632649,    157589625,   -345229739,   -366245207,  -1399995986,   1651729983,   1965074340,  -1108970305,            1163690769,   1732013523,  -1461252895,    669755552,   -476503675,   -264578685,    -32813949,    288222188,    -25734262,    106040916,   1654395626,   -365148479,   2014455846,  -2040447994,   1351639280,   -919975757,           -1970412139,    -47306532,    222377665,   -363434917,  -1091717516,   2090685531,  -1221091649,  -1729649190,  -1239406708,   1064945398,   -105437479,   -419675255,     74701669,    -12862899,   -498269844,   1566898997,           -1872838355,   1596887574,    485902962,    469225597,   -881763553,   1307841032,  -1642872487,   1388543045,    379792876,   1095683384,    840780732,   1934378038,   1851278350,  -1359389423,    130868458,   -313448799,            -663624816,   1031714153,   -608443411,   -205137499,  -1849464427,   1973593637,   1068741808,  -1420655961,   1188762305,    954044841,   -995454462,  -1818101092,  -1937201943,   -324541290,  -1520603933,    572873173,            -554764496,   1051557081,  -1245136076,   -985349536,    329320398,   1787901464,    -37803304,  -1759310177,  -1463492617,  -1861729663,   1251768782,    256937091,   -779036948,  -2049893864,   1256022877,   1228075657,           -1550195255,   -611319853,   1190797155,   2047604112,   -576077160,  -1532843331,  -1324899394,   -159729560,   -622525946,  -1080302767,   -236033484,   1895243903,   -410123689,  -1944154157,   -681781021,   1208453003,             579595878,   1303914051,   -145607082,   -131567277,  -1917288455,    894217359,   -175688726,  -1585480723,    663691440,  -1140068263,   -641711178,   1596080008,    629197693,    976422358,  -1570451095,    525923776,             895046136,   -504151767,   1602553020,  -1233054923,  -1798474837,  -1488857895,   1055782627,    261863143,   1879276655,    488240679,   1910982611,  -1919441259,    370435945,   1265230086,  -1293284428,  -1503576227,            2076963035,  -1379628250,   1157098875,   1984461153,  -1947837397,   1705880124,   1453607404,  -1233649748,   1479943773,   -863878721,   -862415630,   -736723275,    940306358,  -1596000684,  -1174889953,   -615723892,            -885006597,  -1796723178,   1844159055,   -188942309,   2107251811,  -1675486996,  -1009475178,   -859263556,   -431866963,     -9593673,  -1878920923,   -104853791,  -1535224994,    -69315537,    586690130,  -1292234796,            1378749456,   -301873019,   -319297563,   1677205851,    292450579,  -1289441171,   1788113680,   1907606333,   1464711611,  -1372023606,  -1978832445,  -1772259768,   1949124464,   1818322887,  -1138036603,   1249727628,           -1474866449,  -1868013169,  -1384567593,    717007936,    954189997,  -1900561040,    738470389,   -158973180,   1732860784,   1936031206,  -1133354740,  -1173166665,   1432976712,    852636081,   1732064691,  -1831788120,            1273933579,    455403217,   1988395890,    106493468,    506092152,   -610530423,   1698053512,   1311747476,   1969503012,  -1887461759,   1613543073,    903200334,   -737865837,    325656800,  -1234001200,   1492148864,            2009861533,   -368262605,   1091338541,   2076108119,   -961392337,   1835877112,    316250307,   -853333391,  -2125443777,    815363504,   -798707803,   -158146540,    690786114,   -530775684,   1203556940,   1611485582,           -1661412270,    -53184506,   2126287444,   -232222229,   1559486057,    283532250,   1202760418,    932144172,   1082594656,   -570104011,    413509167,   -995027177,   -996477516,      -540544,   -745537167,   -712135469,            -996294983,   -592787198,   1889840948,   1314628747,   -394266926,   -682316577,    456447239,   1728806063,   -396279614,    -43387643,   1915717013,   -861574144,  -1078710588,   -561401249,   1111464540,     63643984,           -1693870413,   -968369980,  -1053148188,    708799038,   1883537988,    373371671,   -156410415,  -1596483236,  -1846890431,    888692915,  -1025632583,  -1666477591,   -343066267,  -2059058792,    641501628,  -1744347292,            1648632991,   1743540146,   2020952406,    164014499,    990508262,   1706408228,  -1236471842,   -347116260,   1843634523,    827255665,    300519853,  -1265974830,   -547247177,   -583064554,  -1995437077,    689210107,             -93151393,    835365056,   1706367315,  -1605902756,    200954895,    431093688,   -277573364,   -928486713,   -552221973,    145432789,   1128919795,   1675095586,   1930359882,   1215849501,  -1447770583,    657776490,            1885869860,  -1629237204,   -868897479,  -1258169760,   1828140195,   -883850439,    463933909,   -347361158,   1478116648,    801176896,  -1501915899,   1017335748,  -1654508882,    123994786,   1588785290,    791166651,           -1523108535,    340411166,   -496474762,  -1189711141,     -7392628,   2045171250,  -1245366209,    834787230,  -1346883181,   2034209454,    737043362,    898803323,   1983089087,  -1845404320,      9585188,  -1180608323,            1665100606,   1949474222,   -211115008,   1151308295,  -2132174259,    913126312,  -2085061672,   1419864120,  -1134542954,    -53833957,   -246913211,    468382370,  -1759479323,   1136686211,   1307012488,  -2036299559,           -1346099736,    314743106,  -1683101865,   -947151948,   -234529696,  -2103334293,   -279256894,     -1484257,  -1053953017,   1801205399,    941594454,   -874119215,   -672865187,    762284205,  -1494975451,    486607927,            -898264389,  -1711861093,   -212572760,   2106484281,  -1610786470,   1352525590,   -837779586,   1568282001,   -593019125,  -1146260782,  -1595879979,   -640781858,   1107692311,   1547132709,  -1928385535,  -2057772805,             634887038,    329772618,    942136006,   -864405576,    501883884,   1537141484,  -1180626836,   1123055420,   1090885851,    421662750,   2033111605,   1710917425,  -1118058244,     74321279,    257328195,  -1199940697,             208625996,   -442341447,    808119183,   1166827075,   1177417517,  -1856155370,  -1464837036,    -60624923,  -1306220638,    -91104698,  -1434621430,    548899241,     37351476,   1478278431,  -1255061434,    248470035,            -104642597,  -1865169521,   1418373655,  -1660810523,  -2129015436,    154612798,    276575732,   1930338442,    179503250,   -929294855,    -39452027,  -1377657544,   1442322193,   1137511318,   -432158653,   -984801987,             743099148,  -1118893528,   -904123623,  -1273146363,  -1884800406,   -803169061,   1254123158,   -484252077,    317646844,    404246525,  -1230293916,   1121445742,    -19657507,    652967153,  -1055406692,   -468950719,           -1493532921,  -1447624258,  -1369679689,  -1517000228,   -145853307,   1518006526,   1591195514,  -1475557146,   -909722097,   2103182976,   -406830579,  -2124025254,  -1804819507,  -1357512858,    567321869,    409048156,             567805180,   1749009386,   1762759722,  -1770324077,   1271140844,    468219092,    955792405,   1911965665,   1876314424,   -718200715,  -1278883927,   1392281730,   -120519585,    851473793,    245054754,    -33369039,            -284877584,   -479534880,   -212346563,   -122017521,  -1461429983,   1331007370,   1788621721,   1739036536,   1446350953,  -1985448033,    685528610,  -1386434659,   1368233993,   2021786790,   1596478397,  -1716635278,           -2011083017,    171876097,   -311529197,    687812052,    377000657,  -1055547517,  -1499047842,  -1818434951,   -120863666,     33888043,  -1387509273,   -541540700,   1162597745,  -1331415338,   1931708792,   -850270000,             663845594,   1536495943,   -322924971,  -1380272203,    261190298,   -204874428,  -2104974031,    883819928,    155808204,  -1454446035,   1323388464,  -1696505728,   1549800285,   1018150463,  -1327715703,  -1582480640,            1013659809,  -1820360082,   1666498787,   1406120540,   -196541482,   1248470531,  -1250433281,    836375878,    177646854,  -1927020253,   2145878321,    689712096,   -596605921,    348283199,   1916993096,    481356808,            -339687826,   1219340319,    718895887,  -2007521340,  -1859185806,   2042164737,    -58146784,    742449142,   1930754708,    780832111,    715056441,  -1393886151,     -8150527,   -599607443,   -537300865,  -1212516084        };        for (int i = 0; i < refInt.length; ++i) {            Assert.assertEquals(refInt[i], mt.nextInt());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import java.util.Random;import org.junit.Assert;import org.junit.Test;/** * Test cases for the RandomAdaptor class * * @version $Id$ */public class RandomAdaptorTest {    @Test    public void testAdaptor() {        ConstantGenerator generator = new ConstantGenerator();        Random random = RandomAdaptor.createAdaptor(generator);        checkConstant(random);        RandomAdaptor randomAdaptor = new RandomAdaptor(generator);        checkConstant(randomAdaptor);    }    private void checkConstant(Random random) {        byte[] bytes = new byte[] {0};        random.nextBytes(bytes);        Assert.assertEquals(0, bytes[0]);        Assert.assertEquals(false, random.nextBoolean());        Assert.assertEquals(0, random.nextDouble(), 0);        Assert.assertEquals(0, random.nextFloat(), 0);        Assert.assertEquals(0, random.nextGaussian(), 0);        Assert.assertEquals(0, random.nextInt());        Assert.assertEquals(0, random.nextInt(1));        Assert.assertEquals(0, random.nextLong());        random.setSeed(100);        Assert.assertEquals(0, random.nextDouble(), 0);    }    /*     * "Constant" generator to test Adaptor delegation.     * "Powered by Eclipse ;-)"     *     */    public static class ConstantGenerator implements RandomGenerator {                private final double value;                public ConstantGenerator() {            value = 0;        }                public ConstantGenerator(double value) {            this.value = value;        }        public boolean nextBoolean() {            return false;        }        public void nextBytes(byte[] bytes) {        }        public double nextDouble() {            return value;        }        public float nextFloat() {            return (float) value;        }        public double nextGaussian() {            return value;        }        public int nextInt() {            return (int) value;        }        public int nextInt(int n) {            return (int) value;        }        public long nextLong() {            return (int) value;        }        public void setSeed(int seed) {        }        public void setSeed(int[] seed) {        }        public void setSeed(long seed) {        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import java.util.Random;/** * Test cases for the BitStreamGenerator class * * @version $Id$ */public class BitsStreamGeneratorTest extends RandomGeneratorAbstractTest {    public BitsStreamGeneratorTest() {        super();    }        protected RandomGenerator makeGenerator() {        RandomGenerator generator = new TestBitStreamGenerator();        generator.setSeed(1000);        return generator;    }        /**     * Test BitStreamGenerator using a Random as bit source.     */    static class TestBitStreamGenerator extends BitsStreamGenerator {        private BitRandom ran = new BitRandom();                @Override        public void setSeed(int seed) {           ran.setSeed(seed);           }        @Override        public void setSeed(int[] seed) {            ran.setSeed(seed[0]);        }        @Override        public void setSeed(long seed) {            ran.setSeed((int) seed);                    }                @Override        protected int next(int bits) {            return ran.nextBits(bits);        }      }        /**     * Extend Random to expose next(bits)     */    @SuppressWarnings("serial")    static class BitRandom extends Random {        public BitRandom() {            super();        }        public int nextBits(int bits) {            return next(bits);        }    }    }
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.random;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;import org.apache.commons.math.stat.descriptive.moment.VectorialMean;import org.junit.Test;import org.junit.Assert;public class UncorrelatedRandomVectorGeneratorTest {    private double[] mean;    private double[] standardDeviation;    private UncorrelatedRandomVectorGenerator generator;    public UncorrelatedRandomVectorGeneratorTest() {        mean              = new double[] {0.0, 1.0, -3.0, 2.3};        standardDeviation = new double[] {1.0, 2.0, 10.0, 0.1};        RandomGenerator rg = new JDKRandomGenerator();        rg.setSeed(17399225432l);        generator =            new UncorrelatedRandomVectorGenerator(mean, standardDeviation,                    new GaussianRandomGenerator(rg));    }    @Test    public void testMeanAndCorrelation() {        VectorialMean meanStat = new VectorialMean(mean.length);        VectorialCovariance covStat = new VectorialCovariance(mean.length, true);        for (int i = 0; i < 10000; ++i) {            double[] v = generator.nextVector();            meanStat.increment(v);            covStat.increment(v);        }        double[] estimatedMean = meanStat.getResult();        double scale;        RealMatrix estimatedCorrelation = covStat.getResult();        for (int i = 0; i < estimatedMean.length; ++i) {            Assert.assertEquals(mean[i], estimatedMean[i], 0.07);            for (int j = 0; j < i; ++j) {                scale = standardDeviation[i] * standardDeviation[j];                Assert.assertEquals(0, estimatedCorrelation.getEntry(i, j) / scale, 0.03);            }            scale = standardDeviation[i] * standardDeviation[i];            Assert.assertEquals(1, estimatedCorrelation.getEntry(i, i) / scale, 0.025);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import org.junit.Assert;import org.junit.Test;public class Well44497aTest extends RandomGeneratorAbstractTest {        @Override    public RandomGenerator makeGenerator() {        return new Well44497a(100);    }        @Test    public void testReferenceCode() {        int[] base = {              740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,            -1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000,             -595495729,  1047766204,  1875773301, -1637793284,  1379017098,   262792705,   191880010,  -251000180,            -1753047622,  -972355720,    90626881,  1644693418,  1503365577,   439653419,  1806361562,  1268823869         };        int[] init = new int[1391];        for (int i = 0; i < init.length; ++i) {            init[i] = base[i % base.length] + i;        }        Well44497a mt = new Well44497a(init);        int[] refInt = {          -1464956854,  -1524360321,    986845646,   -182050548,   -818943186,  -1744848370,   1392434650,   -182648505,  -2026593838,   1254866610,   -410459761,  -1392048371,   -968730026,   1485793687,   -728749746,   -112685463,            275126404,  -1101838984,   1193096287,    443511615,   -510869213,    549869992,   1974458428,  -1217587840,   -335835016,  -2048974745,   1066947099,   -611611187,   1978925459,    688164478,   -463344808,     56995910,            699288809,    606392470,    117418673,   1948706703,   -485598135,    385841705,   1725261146,   -919553921,     70643668,   2128611684,   1720197347,    738706713,   1162026860,   -611442152,   1469145601,   2051653750,            609067755,  -1971782890,   -971114565,    776260144,   1619791127,  -1547233838,   1502505722,    913168193,   1761269649,     81782996,     62251540,   1519079156,   1239007000,    489633356,   -800433470,  -2107278046,            495320431,    269446836,  -2013306553,   1074614697,   1645125348,    584369930,   -405429577,   1211134012,  -2060113546,     -2047824,   -443978800,    271218497,  -1002185964,   1519315874,   -695096464,    -79101601,          -1521653608,    192426133,   1159511202,  -1354494985,   -477280535,    583522228,   -661741458,  -1251175621,   -369487281,  -2015449518,  -2102058930,   -645264919,   -925270025,  -1674575999,   1363844609,   -831732660,          -1668989157,  -1861246633,     83763283,  -1056074975,   -519054258,  -1546386261,   1691674654,   -885968657,  -1189571815,   2095154843,   1686743191,  -1859471265,   -261593938,   1721982136,   -491120252,   -949699153,            642525852,  -2005306625,  -1004765905,    742736856,   1653443876,    788423835,   1536155740,    879514143,  -1510757104,    115238646,     28600662,   1485490803,   1272460710,    523153480,   -766782926,   1332478031,            528775440,    302965264,  -2046891123,   1108139271,   1611601128,    550846467,   -439082190,   1244786747,    941120547,    -35568474,   1756370964,    304870369,   1902684028,   -408710726,   1673189520,   1180987663,          -1488131864,    158973303,    154514890,  -1387953397,   1453732833,  -1342263302,   -628153633,      4710424,    619931109,    721411332,  -2135645486,   1688696681,   -891749588,  -1641122924,   1397432310,   -865254619,          -1635468227,  -1827787970,  -1311416657,  -1022618057,   1411688086,  -1579840139,   -637954674,   2115653281,  -1155985079,  -1043532593,   -374286955,  -1825883832,   -227940643,   1688394137,   -524577925,   -983222470,          -1955769926,    626525757,  -2009760930,  -1855453635,   -676923169,    754966926,   -291202391,  -2126042921,  -1477304277,  -1409345382,  -1264640578,   -441993991,    -17611930,  -1576809974,   2137694350,   1299022733,           -762509116,  -1087399293,    819303572,    -14571174,   -719035481,  -1644675278,   1492736905,    -15038081,    974773023,   1087127339,   1790024863,  -1493135734,   1936273291,   -442361741,   1639666948,   1147532756,            174955156,  -1537685747,    187972574,    275303083,   1420277149,  -1375787574,   1873043153,     38164241,    653451946,    687758113,    899667071,   1722219976,   2146668333,    587401069,    -26582672,   2034645447,           1401801794,   1043291001,  -1277898614,   2116116828,   1445274301,    150534325,    469242183,   -937704471,    171074779,   -204638071,   1269913689,   -771734064,    -12280461,  -1182158859,   1704390140,   -263303749,           -848503723,  -1822849148,   -634064465,   1130988864,  -1515750310,   -908815400,   1487214333,    994482967,    853103628,   1711185413,   1520342001,   1067859186,   1693632130,   -603831333,    292236742,   -800655385,          -1467184928,    221125007,  -1697377800,   1293953144,   1730537111,   1073329737,    519625212,    689636032,   1127394154,  -1496469136,  -1214585810,    822152197,  -1572579275,   -527866383,   -996792678,  -2058452887,          -1133767559,    576275042,   1579109209,   -295089371,   1502267384,   -724281876,   -911879875,   1131096177,    333026744,   1238706603,   1067340063,   -745697708,   -973992204,   1560446744,   -664017057,   -616056490,           1099714049,    674159948,    383625825,   1411443110,   1862818263,  -1896254899,   1322476914,   -719144734,  -1540101945,    988154902,    781856577,   2013381051,  -2059071359,   -142073207,     60252832,   2052050421,           -666391497,    376633738,   1663011481,  -1706886481,  -1870003191,   1003819645,    898131216,    778824906,   -656875645,  -1730811011,  -1751653787,   2056079904,    231977636,   1831419220,   -465545074,  -1505266471,           1034419975,   -133864043,   1876779821,   1879792902,   -100100435,   -959264741,   -472668436,    203584096,    -46980157,  -1478047098,   -979669209,    809008494,   1279644171,   2055793632,   1385672419,  -1756428826,          -1790481031,  -2089665073,  -1608595011,    457322987,   1267418945,    -19541848,   -796352273,  -1049973752,     30940894,   -539710199,  -1097391703,   -779353550,  -1328320498,   -735447662,   -918513196,   1516945649,           1218919237,   -251287485,   1826366637,    353082340,    889839220,    399638904,  -1462573609,   -618450466,   1429903706,   2095548034,   1486594475,  -1053248922,     74346322,   -357998703,   1790710495,   -146359619,           1581657509,   -797737661,   -920778913,    608399665,    646679359,   1861775150,  -1014371223,    476735306,  -1577737028,    383018939,   1234592859,    344770283,   -472763155,    187217985,   1245828866,   1936329359,             61243025,  -1979390025,    903671173,    302699505,  -1677126111,  -1194113496,    835857595,    706998946,     70931462,   1374113464,  -1464459699,   -231081598,   1366205112,    396990527,  -1615015619,   -968458597,            457632575,     24361353,  -1120685182,   2101590608,   1654666456,  -1208442054,    579414359,   1078056578,    217408674,  -1560683025,    815178420,   1219326466,    450032327,    774403237,     54597342,   -664057229,            447132403,     50603973,    435640301,  -1224073863,  -1339908037,   1775470944,  -1378119263,  -1375189988,  -1287971162,     29816317,  -1313418882,  -1824967031,    443540716,     11064217,  -1463969487,   1967601549,            124474667,   1230898256,  -1741455555,    561643750,    933295231,   -923145874,    245538199,    289478386,    200552280,   -268887021,  -1598221376,   1236123270,    318325803,    773964550,    191670680,    158043961,           -762639146,   -416703928,   -721969492,   1664330785,   -584949010,   1509045840,  -2066001147,   1728613092,  -1103375821,  -1262079070,  -2034789427,   -418216342,   -546365126,   1235751589,   1639799329,   2085089663,           -697590049,  -2007054256,   -147701903,    209371702,  -1868450893,   1241065116,   1537364837,  -1035970557,    318040217,    150492098,   1841159805,   -491979749,  -1275490577,  -1759443566,   -697538216,  -1589624976,           -678703557,   -189067001,   1539472677,  -1396089831,    271512148,    180483983,    483714313,    703861378,   2122114992,   -600097045,    522009268,    160429181,   -744428886,   1541223403,  -1211039718,  -1167643980,           1551471162,   -816207368,  -1429258613,   1350901561,   1934120609,   -961643277,   -214772286,  -2128270227,  -1561239720,   1493926966,   1376671007,     94966082,    221846150,   -164351411,    -51309876,    497148497,           1233668542,    266257753,   -773473851,    953946385,    420815294,  -1390653175,   1834391782,      4704447,   -891751440,   -744104272,  -1082756642,   1431640408,  -1912055536,   -159789461,   -704946016,   1956368139,            642279822,   -374415338,   1562655802,   -272964020,   1071498305,    667364168,  -1546405154,    341389690,   1360662999,    377696332,   -437020076,  -1668574556,   1242655350,   -756555890,    645954261,   1914624235,           2134904445,   -247737098,    143667521,    -17668806,   1804148531,    414247300,   1030053929,  -1595215075,    887532426,    553113691,   1173830167,   -303724353,   -280418143,  -1143962122,  -1898518451,     36464746,           1189572700,  -1549967582,   1093341440,   -452303819,   -731023001,   1111173883,   1678013973,   -836458212,   -842956392,    212774049,   -845621791,    966282353,   -823130040,    700410571,    619075141,   -304785045,          -1816233676,  -1789653997,   -166914694,    690663021,   -669570330,   1098624444,   -987380984,    452844935,  -1089825546,   1221160503,   1217375341,    512281644,  -1106887134,   1665404458,  -1462594714,   -207498587,           -789271490,   -723469709,    512055365,   1445951882,   1692473633,   -996873493,   1445046730,    993087194,  -1666188562,   -897427329,   1008869698,   1236029718,   1499207233,   1704947182,  -1815799281,    686399988,           -475436580,   1588892458,    884859588,   -471913926,   -487416631,   1323960741,  -1257612174,   -468909314,  -1866654496,  -1417895838,   1707647971,    997140465,  -1358794225,   1929422460,   -605622778,  -1587468566,            469149623,   1121515927,    748484204,   1201983830,  -1906623591,     76398473,    261109068,   -796025669,  -1964466661,   1739898262,   -756850622,   1581369453,   1484675811,    484136467,   -705983890,  -1357931714,            548520423,    741992908,   1017931838,  -2078503520,   2097871343,    569233897,    -91903627,   1864053450,   -876129714,    336670307,  -1950420274,   -872316480,   -662220291,    275724295,    703565412,   1334248646,           -217559198,   1044090753,    743502488,  -1518545318,     20614180,   -768582053,    976522354,    -25129962,   -983639284,     71722595,   -119236393,    368844119,   -795808244,    696073964,   1379765302,    235083623,            666280330,  -1313689346,   -643870520,    534522699,   -250414377,  -1239276164,    159264592,  -1119503518,   1168161619,  -1366518946,  -1335653301,    248092140,   1390152547,   2051602724,  -1023547981,  -1479782621,          -1785785862,   1609789158,   -919124123,   1703200068,   -852553456,   1573706142,   -376011685,    305068766,  -1231775451,  -1536883494,   -125122369,   -896696968,    852651567,   -458154391,    747781704,   1173040469,          -1569200836,    312506093,  -1680530410,    117086271,    794587661,  -1231003908,  -1048955503,   2119305423,   1636729108,   -522378372,   1627421730,    545077470,  -1683264872,   1486496559,  -1793064672,   1908368749,          -1226052295,   1399248776,   -588193954,  -1289386125,    534647065,   2126245059,   -238362987,  -1244573058,  -1571832269,  -2052693379,   1494767731,   -528668449,   -980826491,   -151282847,  -1468523556,   1876349941,           -301654558,   1467960576,   -741720848,   -612158589,     92376910,    987915105,   1037689578,    793773489,  -1387669541,    349490139,    564784004,  -1161242130,    619703053,   2063233129,    190888106,     81845991,          -1482466066,    283234313,    114355492,  -1879406787,  -1283370924,  -1378903370,   -730141747,   1570738286,   -281348873,   2131743196,    795654462,   -497365688,    437612465,   1928618254,   1433118279,  -1801292119,          -2059248836,   -221673230,    163637697,   -411319468,    244353317,    786753178,    489172932,    464627154,   1258915212,   -229028334,   -994675463,   1931657329,   1784181437,    -97111947,   1728952452,  -1329133577,          -1606156362,   1341196121,   1679632329,   -796545286,  -1021125869,   1427825468,   -214986389,    250791528,   1029777000,     90661677,    602529506,   2068040879,   1483801763,      2332097,   -457467017,    672399614,           1542769193,   1781253216,  -1967165705,  -2052227925,  -1248173215,  -1676554121,    292413596,    209649573,   1750689340,   1946874730,   -832845570,   1774178655,   -450175610,   -431901779,    613330756,   1969434259,           1251099237,  -1320908513,    -50659188,    273178515,   -296290724,   1195998469,   1329813722,    759419114,   1003396150,   -274557619,   -548886303,  -2055397788,   -766678640,   -464045978,  -1835907569,   -169406709,            820751456,   1778613303,  -1582073956,  -1728391771,  -2075389498,  -1606584632,  -1702107251,    -15724560,     45610235,  -1967510298,   -671487775,  -1841110041,   -913365944,    869680052,   -798103472,  -1564096927,           -918899909,   -810066882,    428829752,  -1413487973,   -844240890,   1343914280,   -689285374,   1827745702,   -799686631,   1696465705,   -726159000,  -1381157526,   1649221296,   1791106481,  -1872852642,   -485685063,           1534949133,  -1611901907,   -581776031,    242740701,   -382394666,    668419384,    388297992,    748818886,    713804061,  -1783774172,  -1823401590,  -1009098384,   2071462929,   1154475522,   1309810666,  -1734475040,           1212095416,    988288210,  -1457428115,   1699730041,  -1804729443,  -1922824494,   1000076038,   -226555981,    131425181,  -1071582828,    357680377,   1574190179,    996651958,    965704429,    -47651768,    243931978,            808955117,   -652323633,    544967309,  -1199510217,    702795379,    997685748,   1593927308,   2119371055,   1451401230,    -41992913,   2033816081,  -1030495962,   1764010175,    457470691,  -2001190141,   -373358035,          -1950331268,  -1291674220,    642934467,  -1825725718,  -1555687487,   1664472129,    -24722338,   1899539596,     78519318,   1662555805,   1744711308,  -2142888582,  -1597853572,    118030659,   1596713428,    404304267,          -1350880388,    648702031,   1185458591,   1798138033,    819516445,  -1466759682,   -751277607,   -879817426,  -1931050435,   1465603177,  -1402344216,    768491239,  -1404853657,  -1915685264,  -1845859847,    313163207,           1239598382,   1988767047,   -555152530,  -1925665864,   -182399255,  -1392390808,     64861291,   -511875035,   1879964459,    918905020,   -840773616,    459610189,  -1522352470,  -1821396360,    977274705,    -60616465,          -1846727880,   1208592937,   -515359427,   1127607806,   -395032287,    491869604,   2053794084,    568321750,   1597027438,   1355613070,  -2069482724,   1899252555,    844726247,   -625112193,   1146099491,  -1037855139,           1203928737,   1875686061,    994108281,   1471873396,   2026801570,      4941446,  -1066074241,   -983738686,   2037429697,   -836521112,   -633388883,   1221918725,   2137035208,   -369891832,    372509548,   -110916409,             80517712,   -658056946,    727893428,  -1353651002,   -475459562,   -291323023,   1059377566,    591801919,   1018232602,   -348255729,   1863827426,    246032476,  -1026132864,  -1356383176,  -1224690998,    262442981,           1257773681,  -1738604660,     77131430,  -1320261233,     -2342727,  -1817187590,  -1883997191,   1367221809,  -1863623746,  -1132606249,    149024763,  -1228275128,   -578030399,    356914163,   2109691820,   -880313621        };        for (int i = 0; i < refInt.length; ++i) {            Assert.assertEquals(refInt[i], mt.nextInt());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import org.junit.Assert;import org.junit.Test;public class Well19937aTest extends RandomGeneratorAbstractTest {        @Override    public RandomGenerator makeGenerator() {        return new Well19937a(100);    }    @Test    public void testReferenceCode() {        int[] base = {              740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,            -1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000,             -595495729,  1047766204,  1875773301, -1637793284,  1379017098,   262792705,   191880010,  -251000180,            -1753047622,  -972355720,    90626881,  1644693418,  1503365577,   439653419,  1806361562,  1268823869         };        int[] init = new int[624];        for (int i = 0; i < init.length; ++i) {            init[i] = base[i % base.length] + i;        }        Well19937a mt = new Well19937a(init);        int[] refInt = {            -612874471,   -354976292,  -1838197125,  -1781560577,    278390997,   1214938280,  -1752615390,   -760835246,  -1712883765,   -241205782,   -145390202,    495649160,   -514388259,  -1271015916,  -1640000013,    849273623,            -549729394,  -1206917255,   -545909692,    811925434,  -1665729633,  -1525292882,   1416246482,   -153220826,   1148868872,   -326143196,   1724979062,   1790931148,  -1648679618,   -439051683,    112482777,  -1484051520,           -1881272572,  -1270447031,  -1216102401,   1579107248,  -1224395621,   2144411988,   -416216641,  -1529222361,   1628987080,    164445245,   1506928916,    928145916,   1436000427,    862025970,    560077705,  -1887251027,            -514360858,   1735094506,    475624879,   1755802355,    295448361,   -155399225,      3972415,   1368201076,   -465126094,  -1622687259,   -246099304,   1798631152,  -1937269102,  -1700560396,   -293352622,   -896632303,           -2088933220,   -194382452,   -480218162,  -1618517785,  -1925031481,   -150217434,   1678937261,   2130832364,   -485546678,  -1499224981,   1430390884,  -1895417302,    210514746,   1781140999,  -1940853105,  -1238099647,             485922557,   -103223212,    633481679,   -632946979,    695235541,  -1661735272,    277603567,   -958341538,    256982285,   1850270018,   -327388076,   -219053874,   1380560653,  -1221689980,   1335863752,   -545032383,            -575291735,  -1295623907,   -140058298,   1063302709,  -1290702617,   -790401546,   -170630961,  -1203114473,   1458063108,  -1212753301,   1546428514,   2112636413,  -1463028928,  -1812598032,   -883529486,   1131084094,              62042165,   2135819802,  -1192342739,     98361522,  -1341042205,   -475283063,  -1632033747,   1745196892,    168608689,   -914987039,    274428907,   -881357258,    167940012,  -1975737532,   -903960486,  -1370984244,            -589352935,   1783633514,   -570111010,     71495377,    194463285,  -1243905021,  -1398490898,    221691209,    -55728834,   -638916786,   -770622372,  -1911651810,   -295233027,    301467998,   2058638784,    681490183,           -1547865078,  -1668135684,   1299261826,   1649468635,    287995017,  -2076844852,   1193468826,   -853948258,    120082777,   1051829542,  -1288514343,   -159456430,    275748820,   -480127107,   -604943233,  -2138088332,            1202614819,   1427201263,  -1906344469,  -1230779533,   1690367192,    733159097,    794410312,  -1114452505,  -1601554413,    976747949,   1517787154,   2091780205,   1052078906,   1919282771,   -191013374,   1805397142,             736939268,  -1056272823,   -727464316,   -659459005,    797803875,  -1104633884,   1042342081,    -24514837,   1919469940,   1903722546,   -814157872,   1605407665,   -262351256,   -288949635,    729204844,  -1132605534,             745453338,    387915035,   1094173337,   2100279147,    156863702,   -257377544,   -719587984,  -1496015613,   1908993744,   2016957554,    918749666,   -135963651,  -1356808639,  -1711185741,   1472589240,   -398100149,             628791415,  -1381837652,  -1820702771,   -593586943,  -1456631279,  -1837975351,  -1394249972,   -556916726,    833231177,     43449750,   1029237092,  -2086437337,   -459463076,   -533031784,  -1739648287,  -1374722961,            2024908394,   1389678488,      2018558,  -1391707864,   -795935743,    904816957,    836583280,   1766194531,  -1374431014,   -904437876,   2030248636,   -265724199,   2056758426,   -810499837,    887193593,    -77811488,            1496312336,  -1874348275,   -456193866,  -2137130942,    868120387,     29025455,  -1999867716,   2001322335,   -579152815,   -390892056,   1592011837,   -306394879,     93636886,   -190879994,   1923358153,    269052141,            -396050253,   -987531729,    480350991,   1276744541,  -1445571957,   -957571005,  -2046270221,  -1715395752,   1113585628,  -1782113514,   -697560146,    835320000,   1014320959,  -2119834109,    460056841,  -1464772991,           -1282790418,  -2120806165,     86176097,   -731086307,    832497517,  -1876684928,    541008240,    551124479,   -450919132,    647860281,  -2115397586,    979247589,   1095559204,   1927958688,    169497703,   1999579054,            2019745038,   1656022059,  -1109662138,    375237154,   1450814436,    919988416,    849761266,   1457057327,   1771166577,  -1639880487,   -852488298,   1767063646,    657295386,   -585561879,    740792583,   1664558308,            -654749506,   1109275990,    182597559,   1106789745,  -1806628480,     25948116,   1748374299,    196057325,   -164213209,   1687024594,    782029276,   1879737947,  -1528219611,    412585737,   1190325629,   1985821911,           -1272945202,  -1238637137,    465818730,  -1537670961,   1131953615,    905623579,    609183424,   1138422991,   1522974699,    589719061,  -1310894604,    890952933,   -885204790,   -393535694,   1238408670,   1780660354,             677803525,  -1121509064,   1553148616,   1109165936,  -1450120385,   1525252521,  -1354897489,   -595402189,  -1274551767,   -869281409,   1788815975,   2020262116,   1124100185,   -400839020,    310574108,   1354413045,           -1310514485,   1895732085,    626639054,   1667355357,   2065637178,  -1889009143,   -440157749,   1762849463,  -1693853642,    -56602956,   -930874188,   -398470740,    778356402,  -2113156881,     42854964,   1844399604,           -2098310302,  -1812029757,   1441188713,    899579267,   1266994172,   1841370863,   -660740252,    -43254718,   1124500192,   1884907320,    879997211,   1775139845,  -1360112721,   1630490057,    362567879,   1113475029,             290319279,  -1209506867,    398146039,   -957742350,   1185761854,   1519676447,   -912689915,  -1117128973,   -305563462,  -1928033363,  -1766324543,   1702753492,   1696951912,  -1895072395,    932663591,   -566548128,             991675996,     56529814,    980735023,    718166662,   -650028466,   -886842051,   1857048587,   -569023569,  -1820572202,   -851452711,   -958700452,   -621825633,    -65649888,   -510143183,    761267599,  -1692108035,            1729071710,   1623630864,    -53498654,    267235687,    659201413,   1152882627,   -824194574,    356636960,   -502391121,   -538453360,     66115376,  -1633290370,  -1522088932,    268949070,    684499443,   -859474501,            1586764345,  -1515639709,    319695602,   -307025150,     69076508,   1050726785,  -1340930110,    552191600,   -207852941,   -273572993,   -539580440,    710343120,   1957076127,  -1107172811,   -561518280,  -1775022699,            1978792904,   1935531451,  -2084046304,   -419742902,   -737652926,    614022023,   1676952428,    769892939,  -1092786807,  -1117113223,   -266029995,   -350150999,    207738542,   1964896575,     48805284,   1736500159,             551289617,  -1847923501,   1856609505,   2007480480,   -681860219,  -1198106493,   1483591043,   -523895316,  -1814473078,  -1521087404,  -1348859926,   1298056897,   1813789478,    946683654,     79196400,   1766250931,             472737685,   1764634332,  -1844726079,   -130619045,   -508713868,  -1762537125,   1010108863,    170107098,   1705386380,  -1139681802,    183739097,   1662699401,   1842694501,   1714633805,     46208876,    616720693,            -252553427,   1986302230,   -103130254,   1943225981,    110746655,    553260552,   1588938073,  -1934623163,  -2144781332,  -2086217416,   1941265852,   -781953226,   1216234254,    605543697,   -710872598,   2048636577,           -1986927728,  -1007017623,   1243051501,   -614249563,  -2128221291,    581579813,   1173464240,  -1906830937,    261329601,  -1805974103,    769823490,   1858731164,   -561762071,    516417430,  -1221329437,   -825500715,            1091364656,   -993658663,  -1475434188,  -1070804384,  -1876492082,    899494424,    683486936,    878807455,     56642807,  -1268202879,   1379172046,  -1386869373,  -1158233876,   1759190552,   1597629789,   1411151497,           -1254268471,   1075936979,   -918778269,  -2132675184,    953140888,   1906982077,   1154200766,   -365384600,  -1142488826,    708535121,  -2134869964,  -1531201665,  -2100526761,   1268256467,   2071480803,    193135243,            1374158182,    989505347,   -933612202,  -2134839213,  -1302795271,  -2092029041,   1812014826,   2090855917,   2005348528,    606434393,    -60141386,     11156360,    539516285,   -122485034,   -893237911,   -978127424,            1509901816,   -451029719,    428544700,  -1622965963,  -1993611605,  -1989324583,   1104111587,   -795138585,   -899552401,  -2110167769,   -234502445,   1586963605,   -503778455,    529261062,    325327284,   -106186403,              65369563,  -1475700698,   -228624261,    715975009,   1099352363,  -1796883396,   1376542700,   -308942420,   -344940451,   -395389249,  -1562737166,   1869802677,   1273494710,   2075587668,   -789570273,   1563347596,            1142901755,   1676422422,  -1729157809,  -1399423717,  -1814262429,  -1809707284,   1393992342,   -570246212,   1065528749,   -781643849,   1218667301,  -1097949471,   1305629790,    901301039,   -704762030,    360582612,            1411910672,   1848068741,   -614500891,   -146889637,   -913903597,    723527277,   -147033328,   -199273155,    734997691,  -2072735286,   2129258691,  -1385074104,    931616624,   1065477319,  -1543474555,   -531410292,           -2123119121,  -1538464113,  -1153585193,   1559931968,   -654877011,    879865200,   1489681397,   1998864644,  -1964160144,    163671782,   -858364148,   -323324233,    801208648,    705864113,    436184243,    643773864,            2087594507,    134637265,   -749956494,  -1657343972,  -1828172168,    -27357303,  -1145161336,  -1192513644,    216148260,    611393153,    -13752671,   -358631090,  -1211920749,    593572064,    657629904,  -1445961088,            -250704995,   1797542707,  -2122311891,   -316774825,   -296303057,   -868002056,    -86697533,   2020588145,   1203427903,  -1371839056,    669531557,  -2031033836,   1323994690,     13703036,    785437772,  -1465821554,            -694756014,  -2131068154,  -1745448876,  -1095891733,    936594025,  -1119068454,    855423970,   1705079340,   -905640608,    162297141,   1336619311,   -344353769,    -92608588,  -1080573824,   2002293105,  -2088030765,           -1684198727,   -129054718,   -949437132,   -127983221,   -216664110,   1700146143,   -711174649,   1500113839,   1212236226,  -2017364219,  -1263597675,    511929344,   -323998524,  -2021313185,   1803000924,    927670608,             336267187,   1244256964,  -1665390108,    991395134,   -251232188,   1267445783,   1547951569,    740269916,   1776431169,   1687220659,    228229817,    271386089,   -682906779,   -438090344,   1190436796,   -744272540,            1879221151,   1145200306,  -1730983338,  -1119209309,     90826726,   1567861540,   1638852830,  -1645384932,   1566909531,   1088584561,   1030555565,  -1872052014,    720320695,   -885053674,   -321216789,    739907579,             368580703,   -443635520,   1232705619,  -1355949988,  -1047211249,  -1571429448,    599299852,   1036970439,   1513838571,    -51797291,    -26647565,  -1262878942,   -916262582,   1579082269,   -292007383,   1289013866,           -1612184284,   1451738668,    448608569,    476432992,  -1229609565,    786372409,    929928149,   -150100614,    448155944,  -1322320576,   -856549627,   1057443268,  -1536809554,    577508258,    584906122,    275295163,            -604262071,   -236043234,  -1866434954,  -2072447013,    646132876,    847562546,   -310005953,  -1104162658,    393261203,   -730102354,    440824482,   1654535035,  -1296359745,   1487359328,   -977776604,   -775827779,           -1298695106,    519080622,   1697162240,    227873031,   -371123123,   1273702312,  -1710063656,  -2138342344,   1139555478,   1531578907,  -1498880699,   1183507362,   1875307493,  -1649740413,   2135386504,   -962458407,             424161768,    504272962,    202204247,   1783466420,   2015579232,   -676642965,   2067456450,    914480415,   -620398841,   1880405399,   1406637142,   1951104977,    633496157,    224861869,    -58659291,    994942775,            -479000645,   1421449115,    100168104,    249754169,  -1219011494,   1736303638,    364013694,  -1750035055,   -479217141,   1652913106,  -2109452331,   1633842910,  -1547663337,    936627493,  -1152799743,    896955899,           -1407742850,   -523769014,    357161414,    872293304,    744895980,    720829676,   -240843156,   -111779524,   1292836315,  -1792141538,   1946959925,   1181751089,  -1120674052,   1185192575,  -1387002557,   1973209255,            -120887476,   -766577735,   -443913073,    786620227,    428564781,   -101232106,   -425959852,    198082021,   1173272226,  -1744840378,  -1621135606,  -1539498583,  -1101274572,     43399711,  -1256764602,   1201920787,            2049426139,    846545551,  -2121520873,  -1202939675,   -470425740,    321987390,   1862019060,   -951540342,   -894238318,   -430407175,  -1662746491,    656574776,   1580373777,   -431290218,   1645824323,  -1953526979,            -374682356,    474291752,   1071558425,    511038981,   -760598678,   -567797285,  -1176476266,   -268409005,  -2130644484,    -67970563,   1756046948,   1429860462,  -1130984739,   -124916495,  -1544436836,  -1863524031,            1024916487,  -1388636482,  -1573205065,    892628956,   1831270021,   1176430590,   1158914682,  -2006787098,  -1228130033,   1516111488,  -1499151347,    470546266,   1642603981,   1425140838,  -1823071475,  -1775267236,           -1009380612,    164746986,   1129677098,   1842642579,   -482342932,   -507480364,   1656012309,   1981601761,   -881042120,   -511987083,    342447017,    381192578,    983008095,    741012865,  -1877136350,   -199211983,            -452784912,   1929572576,  -1678291139,   -864375281,  -1610561247,  -1936356726,   -749553767,   -865893512,   -567081879,  -1303973729,   -939636958,   -622974563,    428284937,   1049237414,    852280765,     86648946,           -1353851401,  -1045422335,    898035731,  -1636093996,  -1083174191,    245046915,   -359768226,  -1028491655,   1051575118,   1774289451,   1839389415,  -1594053468,    736707953,   1873556950,    401186168,   -583669552,             -88375334,   2002752071,    264506453,  -1304812107,   -759203942,   -114958524,  -1878903503,    841613720,   1910863820,  -1738114003,    701455920,   1791058048,  -1850960547,   1672292671,   1172188809,    604848896,           -1607489375,    305370478,   -948153885,  -1971080100,  -1848966954,   -584538365,     39416319,  -1689119162,    944942598,   1777111075,   1534005553,   2022718432,    -25820385,      3077695,   -315950520,   1859184648,           -1397829266,  -1666371809,    858913807,   -610818620,   1554973298,    580023809,  -1662988256,   -408630026,   1316681876,    738204271,    942829881,   -758486983,    780345857,    667165037,  -2086803585,    789741324        };        for (int i = 0; i < refInt.length; ++i) {            Assert.assertEquals(refInt[i], mt.nextInt());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import java.util.Arrays;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.Frequency;import org.apache.commons.math.stat.descriptive.SummaryStatistics;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.MathIllegalArgumentException; import org.junit.Assert;import org.junit.Before;import org.junit.Test;/** * Base class for RandomGenerator tests. *  * Tests RandomGenerator methods directly and also executes RandomDataTest  * test cases against a RandomDataImpl created using the provided generator. *  * RandomGenerator test classes should extend this class, implementing * makeGenerator() to provide a concrete generator to test. The generator * returned by makeGenerator should be seeded with a fixed seed. * * @version $Id$ */public abstract class RandomGeneratorAbstractTest extends RandomDataTest {    /** RandomGenerator under test */    protected RandomGenerator generator;        /**      * Override this method in subclasses to provide a concrete generator to test.       * Return a generator seeded with a fixed seed.     */    protected abstract RandomGenerator makeGenerator();    /**     * Initialize generator and randomData instance in superclass.     */    public RandomGeneratorAbstractTest() {        generator = makeGenerator();        randomData = new RandomDataImpl(generator);    }        /**     * Set a fixed seed for the tests     */    @Before    public void setUp() {        generator = makeGenerator();    }        // Omit secureXxx tests, since they do not use the provided generator    @Override    public void testNextSecureLong() {}        @Override    public void testNextSecureInt() {}        @Override    public void testNextSecureHex() {}    @Test    /**     * Tests uniformity of nextInt(int) distribution by generating 1000     * samples for each of 10 test values and for each sample performing     * a chi-square test of homogeneity of the observed distribution with     * the expected uniform distribution.  Tests are performed at the .01     * level and an average failure rate higher than 2% (i.e. more than 20     * null hypothesis rejections) causes the test case to fail.     *      * All random values are generated using the generator instance used by     * other tests and the generator is not reseeded, so this is a fixed seed     * test.     */    public void testNextIntDirect() throws Exception {        // Set up test values - end of the array filled randomly        int[] testValues = new int[] {4, 10, 12, 32, 100, 10000, 0, 0, 0, 0};        for (int i = 6; i < 10; i++) {            final int val = generator.nextInt();            testValues[i] = val < 0 ? -val : val + 1;        }                final int numTests = 1000;        for (int i = 0; i < testValues.length; i++) {            final int n = testValues[i];            // Set up bins            int[] binUpperBounds;            if (n < 32) {                binUpperBounds = new int[n];                for (int k = 0; k < n; k++) {                    binUpperBounds[k] = k;                }            } else {                binUpperBounds = new int[10];                final int step = n / 10;                for (int k = 0; k < 9; k++) {                    binUpperBounds[k] = (k + 1) * step;                }                binUpperBounds[9] = n - 1;            }              // Run the tests            int numFailures = 0;            final int binCount = binUpperBounds.length;            final long[] observed = new long[binCount];            final double[] expected = new double[binCount];            expected[0] = binUpperBounds[0] == 0 ? (double) smallSampleSize / (double) n :                (double) ((binUpperBounds[0] + 1) * smallSampleSize) / (double) n;            for (int k = 1; k < binCount; k++) {                expected[k] = (double) smallSampleSize *                 (double) (binUpperBounds[k] - binUpperBounds[k - 1]) / (double) n;            }            for (int j = 0; j < numTests; j++) {                Arrays.fill(observed, 0);                for (int k = 0; k < smallSampleSize; k++) {                    final int value = generator.nextInt(n);                    Assert.assertTrue("nextInt range",(value >= 0) && (value < n));                    for (int l = 0; l < binCount; l++) {                        if (binUpperBounds[l] >= value) {                            observed[l]++;                            break;                        }                    }                }                if (testStatistic.chiSquareTest(expected, observed) < 0.01) {                    numFailures++;                }              }            if ((double) numFailures / (double) numTests > 0.02) {                Assert.fail("Too many failures for n = " + n +                " " + numFailures + " out of " + numTests + " tests failed.");            }        }    }        @Test(expected=MathIllegalArgumentException.class)    public void testNextIntIAE() {        try {            generator.nextInt(-1);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }        generator.nextInt(0);    }    @Test    public void testNextLongDirect() {        long q1 = Long.MAX_VALUE/4;        long q2 = 2 *  q1;        long q3 = 3 * q1;        Frequency freq = new Frequency();        long val = 0;        int value = 0;        for (int i=0; i<smallSampleSize; i++) {            val = generator.nextLong();            val = val < 0 ? -val : val;            if (val < q1) {                value = 0;            } else if (val < q2) {                value = 1;            } else if (val < q3) {                value = 2;            } else {                value = 3;            }            freq.addValue(value);        }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected,observed) < 16.27);    }    @Test    public void testNextBooleanDirect() {        long halfSampleSize = smallSampleSize / 2;        double[] expected = {halfSampleSize, halfSampleSize};        long[] observed = new long[2];        for (int i=0; i<smallSampleSize; i++) {            if (generator.nextBoolean()) {                observed[0]++;            } else {                observed[1]++;            }        }        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001         * Change to 6.635 for alpha = .01         */        Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected,observed) < 10.828);    }    @Test    public void testNextFloatDirect() {        Frequency freq = new Frequency();        float val = 0;        int value = 0;        for (int i=0; i<smallSampleSize; i++) {            val = generator.nextFloat();            if (val < 0.25) {                value = 0;            } else if (val < 0.5) {                value = 1;            } else if (val < 0.75) {                value = 2;            } else {                value = 3;            }            freq.addValue(value);        }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected,observed) < 16.27);    }    @Test    public void testDoubleDirect() {        SummaryStatistics sample = new SummaryStatistics();        for (int i = 0; i < 10000; ++i) {            sample.addValue(generator.nextDouble());        }        Assert.assertEquals(0.5, sample.getMean(), 0.02);        Assert.assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),                     sample.getStandardDeviation(),                     0.01);    }    @Test    public void testFloatDirect() {        SummaryStatistics sample = new SummaryStatistics();        for (int i = 0; i < 1000; ++i) {            sample.addValue(generator.nextFloat());        }        Assert.assertEquals(0.5, sample.getMean(), 0.01);        Assert.assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),                     sample.getStandardDeviation(),                     0.01);    }    @Test(expected=MathIllegalArgumentException.class)    public void testNextIntNeg() {        generator.nextInt(-1);    }    @Test    public void testNextInt2() {        int walk = 0;        for (int k = 0; k < 10000; ++k) {           if (generator.nextInt() >= 0) {               ++walk;           } else {               --walk;           }        }        Assert.assertTrue("Walked too far astray: " + walk, FastMath.abs(walk) < 120);    }    @Test    public void testNextLong2() {        int walk = 0;        for (int k = 0; k < 1000; ++k) {           if (generator.nextLong() >= 0) {               ++walk;           } else {               --walk;           }        }        Assert.assertTrue("Walked too far astray: " + walk, FastMath.abs(walk) < 100);    }    @Test    public void testNexBoolean2() {        int walk = 0;        for (int k = 0; k < 10000; ++k) {           if (generator.nextBoolean()) {               ++walk;           } else {               --walk;           }        }        Assert.assertTrue(FastMath.abs(walk) < 250);    }    @Test    public void testNexBytes() throws Exception {        long[] count = new long[256];        byte[] bytes = new byte[10];        double[] expected = new double[256];        final int sampleSize = 100000;                for (int i = 0; i < 256; i++) {            expected[i] = (double) sampleSize / 265f;        }                for (int k = 0; k < sampleSize; ++k) {           generator.nextBytes(bytes);           for (byte b : bytes) {               ++count[b + 128];           }        }                TestUtils.assertChiSquareAccept(expected, count, 0.001);            }}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.random;import org.apache.commons.math.stat.StatUtils;import org.junit.Assert;import org.junit.Test;public class GaussianRandomGeneratorTest {    @Test    public void testMeanAndStandardDeviation() {        RandomGenerator rg = new JDKRandomGenerator();        rg.setSeed(17399225432l);        GaussianRandomGenerator generator = new GaussianRandomGenerator(rg);        double[] sample = new double[10000];        for (int i = 0; i < sample.length; ++i) {            sample[i] = generator.nextNormalizedDouble();        }        Assert.assertEquals(0.0, StatUtils.mean(sample), 0.012);        Assert.assertEquals(1.0, StatUtils.variance(sample), 0.01);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import java.text.DecimalFormat;import java.util.ArrayList;import java.util.HashSet;import java.util.List;import org.apache.commons.math.Retry;import org.apache.commons.math.RetryRunner;import org.apache.commons.math.TestUtils;import org.apache.commons.math.distribution.BetaDistributionImpl;import org.apache.commons.math.distribution.BinomialDistributionImpl;import org.apache.commons.math.distribution.BinomialDistributionTest;import org.apache.commons.math.distribution.CauchyDistributionImpl;import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;import org.apache.commons.math.distribution.ExponentialDistributionImpl;import org.apache.commons.math.distribution.FDistributionImpl;import org.apache.commons.math.distribution.GammaDistributionImpl;import org.apache.commons.math.distribution.HypergeometricDistributionImpl;import org.apache.commons.math.distribution.HypergeometricDistributionTest;import org.apache.commons.math.distribution.PascalDistributionImpl;import org.apache.commons.math.distribution.PascalDistributionTest;import org.apache.commons.math.distribution.PoissonDistribution;import org.apache.commons.math.distribution.PoissonDistributionImpl;import org.apache.commons.math.distribution.TDistributionImpl;import org.apache.commons.math.distribution.WeibullDistributionImpl;import org.apache.commons.math.distribution.ZipfDistributionImpl;import org.apache.commons.math.distribution.ZipfDistributionTest;import org.apache.commons.math.stat.Frequency;import org.apache.commons.math.stat.descriptive.SummaryStatistics;import org.apache.commons.math.stat.inference.ChiSquareTest;import org.apache.commons.math.stat.inference.ChiSquareTestImpl;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;/** * Test cases for the RandomData class. * * @version $Id$ *          2009) $ */@RunWith(RetryRunner.class)public class RandomDataTest {    public RandomDataTest() {        randomData = new RandomDataImpl();        randomData.reSeed(1000);    }    protected final long smallSampleSize = 1000;    protected final double[] expected = { 250, 250, 250, 250 };    protected final int largeSampleSize = 10000;    private final String[] hex = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",            "a", "b", "c", "d", "e", "f" };    protected RandomDataImpl randomData = null;    protected final ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();    @Test    public void testNextIntExtremeValues() {        int x = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);        int y = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);        Assert.assertFalse(x == y);    }    @Test    public void testNextLongExtremeValues() {        long x = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);        long y = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);        Assert.assertFalse(x == y);    }    /** test dispersion and failure modes for nextInt() */    @Test    public void testNextInt() {        try {            randomData.nextInt(4, 3);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }        Frequency freq = new Frequency();        int value = 0;        for (int i = 0; i < smallSampleSize; i++) {            value = randomData.nextInt(0, 3);            Assert.assertTrue("nextInt range", (value >= 0) && (value <= 3));            freq.addValue(value);        }        long[] observed = new long[4];        for (int i = 0; i < 4; i++) {            observed[i] = freq.getCount(i);        }        /*         * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34         * for alpha = .01         */        Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 16.27);    }    /** test dispersion and failure modes for nextLong() */    @Test    public void testNextLong() {        try {            randomData.nextLong(4, 3);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }        Frequency freq = new Frequency();        long value = 0;        for (int i = 0; i < smallSampleSize; i++) {            value = randomData.nextLong(0, 3);            Assert.assertTrue("nextInt range", (value >= 0) && (value <= 3));            freq.addValue(value);        }        long[] observed = new long[4];        for (int i = 0; i < 4; i++) {            observed[i] = freq.getCount(i);        }        /*         * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34         * for alpha = .01         */        Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 16.27);    }    /** test dispersion and failure modes for nextSecureLong() */    @Test    public void testNextSecureLong() {        try {            randomData.nextSecureLong(4, 3);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }        Frequency freq = new Frequency();        long value = 0;        for (int i = 0; i < smallSampleSize; i++) {            value = randomData.nextSecureLong(0, 3);            Assert.assertTrue("nextInt range", (value >= 0) && (value <= 3));            freq.addValue(value);        }        long[] observed = new long[4];        for (int i = 0; i < 4; i++) {            observed[i] = freq.getCount(i);        }        /*         * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34         * for alpha = .01         */        Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 16.27);    }    /** test dispersion and failure modes for nextSecureInt() */    @Test    public void testNextSecureInt() {        try {            randomData.nextSecureInt(4, 3);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }        Frequency freq = new Frequency();        int value = 0;        for (int i = 0; i < smallSampleSize; i++) {            value = randomData.nextSecureInt(0, 3);            Assert.assertTrue("nextInt range", (value >= 0) && (value <= 3));            freq.addValue(value);        }        long[] observed = new long[4];        for (int i = 0; i < 4; i++) {            observed[i] = freq.getCount(i);        }        /*         * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34         * for alpha = .01         */        Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 16.27);    }    /**     * Make sure that empirical distribution of random Poisson(4)'s has P(X <=     * 5) close to actual cumulative Poisson probability and that nextPoisson     * fails when mean is non-positive TODO: replace with statistical test,     * adding test stat to TestStatistic     */    @Test    public void testNextPoisson() {        try {            randomData.nextPoisson(0);            Assert.fail("zero mean -- expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }        Frequency f = new Frequency();        for (int i = 0; i < largeSampleSize; i++) {            f.addValue(randomData.nextPoisson(4.0d));        }        long cumFreq = f.getCount(0) + f.getCount(1) + f.getCount(2)                + f.getCount(3) + f.getCount(4) + f.getCount(5);        long sumFreq = f.getSumFreq();        double cumPct = Double.valueOf(cumFreq).doubleValue()                / Double.valueOf(sumFreq).doubleValue();        Assert.assertEquals("cum Poisson(4)", cumPct, 0.7851, 0.2);        try {            randomData.nextPoisson(-1);            Assert.fail("negative mean supplied -- MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }        try {            randomData.nextPoisson(0);            Assert.fail("0 mean supplied -- MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    @Test    public void testNextPoissonConsistency() throws Exception {        // Small integral means        for (int i = 1; i < 100; i++) {            checkNextPoissonConsistency(i);        }        // non-integer means        for (int i = 1; i < 10; i++) {            checkNextPoissonConsistency(randomData.nextUniform(1, 1000));        }        // large means        // TODO: When MATH-282 is resolved, s/3000/10000 below        for (int i = 1; i < 10; i++) {            checkNextPoissonConsistency(randomData.nextUniform(1000, 3000));        }    }    /**     * Verifies that nextPoisson(mean) generates an empirical distribution of values     * consistent with PoissonDistributionImpl by generating 1000 values, computing a     * grouped frequency distribution of the observed values and comparing this distribution     * to the corresponding expected distribution computed using PoissonDistributionImpl.     * Uses ChiSquare test of goodness of fit to evaluate the null hypothesis that the     * distributions are the same. If the null hypothesis can be rejected with confidence     * 1 - alpha, the check fails.     */    public void checkNextPoissonConsistency(double mean) throws Exception {        // Generate sample values        final int sampleSize = 1000;        // Number of deviates to generate        final int minExpectedCount = 7;     // Minimum size of expected bin count        long maxObservedValue = 0;        final double alpha = 0.001;         // Probability of false failure        Frequency frequency = new Frequency();        for (int i = 0; i < sampleSize; i++) {            long value = randomData.nextPoisson(mean);            if (value > maxObservedValue) {                maxObservedValue = value;            }            frequency.addValue(value);        }        /*         *  Set up bins for chi-square test.         *  Ensure expected counts are all at least minExpectedCount.         *  Start with upper and lower tail bins.         *  Lower bin = [0, lower); Upper bin = [upper, +inf).         */        PoissonDistribution poissonDistribution = new PoissonDistributionImpl(mean);        int lower = 1;        while (poissonDistribution.cumulativeProbability(lower - 1) * sampleSize < minExpectedCount) {            lower++;        }        int upper = (int) (5 * mean);  // Even for mean = 1, not much mass beyond 5        while ((1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize < minExpectedCount) {            upper--;        }        // Set bin width for interior bins.  For poisson, only need to look at end bins.        int binWidth = 1;        boolean widthSufficient = false;        double lowerBinMass = 0;        double upperBinMass = 0;        while (!widthSufficient) {            lowerBinMass = poissonDistribution.cumulativeProbability(lower, lower + binWidth - 1);            upperBinMass = poissonDistribution.cumulativeProbability(upper - binWidth + 1, upper);            widthSufficient = FastMath.min(lowerBinMass, upperBinMass) * sampleSize >= minExpectedCount;            binWidth++;        }        /*         *  Determine interior bin bounds.  Bins are         *  [1, lower = binBounds[0]), [lower, binBounds[1]), [binBounds[1], binBounds[2]), ... ,         *    [binBounds[binCount - 2], upper = binBounds[binCount - 1]), [upper, +inf)         *         */        List<Integer> binBounds = new ArrayList<Integer>();        binBounds.add(lower);        int bound = lower + binWidth;        while (bound < upper - binWidth) {            binBounds.add(bound);            bound += binWidth;        }        binBounds.add(bound);        binBounds.add(upper);        // Compute observed and expected bin counts        final int binCount = binBounds.size() + 1;        long[] observed = new long[binCount];        double[] expected = new double[binCount];        // Bottom bin        observed[0] = 0;        for (int i = 0; i < lower; i++) {            observed[0] += frequency.getCount(i);        }        expected[0] = poissonDistribution.cumulativeProbability(lower - 1) * sampleSize;        // Top bin        observed[binCount - 1] = 0;        for (int i = upper; i <= maxObservedValue; i++) {            observed[binCount - 1] += frequency.getCount(i);        }        expected[binCount - 1] = (1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize;        // Interior bins        for (int i = 1; i < binCount - 1; i++) {            observed[i] = 0;            for (int j = binBounds.get(i - 1); j < binBounds.get(i); j++) {                observed[i] += frequency.getCount(j);            } // Expected count is (mass in [binBounds[i], binBounds[i+1])) * sampleSize            expected[i] = (poissonDistribution.cumulativeProbability(binBounds.get(i) - 1) -                poissonDistribution.cumulativeProbability(binBounds.get(i - 1) -1)) * sampleSize;        }        // Use chisquare test to verify that generated values are poisson(mean)-distributed        ChiSquareTest chiSquareTest = new ChiSquareTestImpl();            // Fail if we can reject null hypothesis that distributions are the same        if (chiSquareTest.chiSquareTest(expected, observed, alpha)) {            StringBuilder msgBuffer = new StringBuilder();            DecimalFormat df = new DecimalFormat("#.##");            msgBuffer.append("Chisquare test failed for mean = ");            msgBuffer.append(mean);            msgBuffer.append(" p-value = ");            msgBuffer.append(chiSquareTest.chiSquareTest(expected, observed));            msgBuffer.append(" chisquare statistic = ");            msgBuffer.append(chiSquareTest.chiSquare(expected, observed));            msgBuffer.append(". \n");            msgBuffer.append("bin\t\texpected\tobserved\n");            for (int i = 0; i < expected.length; i++) {                msgBuffer.append("[");                msgBuffer.append(i == 0 ? 1: binBounds.get(i - 1));                msgBuffer.append(",");                msgBuffer.append(i == binBounds.size() ? "inf": binBounds.get(i));                msgBuffer.append(")");                msgBuffer.append("\t\t");                msgBuffer.append(df.format(expected[i]));                msgBuffer.append("\t\t");                msgBuffer.append(observed[i]);                msgBuffer.append("\n");            }            msgBuffer.append("This test can fail randomly due to sampling error with probability ");            msgBuffer.append(alpha);            msgBuffer.append(".");            Assert.fail(msgBuffer.toString());        }    }    /** test dispersion and failure modes for nextHex() */    @Test    @Retry(3)    public void testNextHex() {        try {            randomData.nextHexString(-1);            Assert.fail("negative length supplied -- MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }        try {            randomData.nextHexString(0);            Assert.fail("zero length supplied -- MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }        String hexString = randomData.nextHexString(3);        if (hexString.length() != 3) {            Assert.fail("incorrect length for generated string");        }        hexString = randomData.nextHexString(1);        if (hexString.length() != 1) {            Assert.fail("incorrect length for generated string");        }        try {            hexString = randomData.nextHexString(0);            Assert.fail("zero length requested -- expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }        if (hexString.length() != 1) {            Assert.fail("incorrect length for generated string");        }        Frequency f = new Frequency();        for (int i = 0; i < smallSampleSize; i++) {            hexString = randomData.nextHexString(100);            if (hexString.length() != 100) {                Assert.fail("incorrect length for generated string");            }            for (int j = 0; j < hexString.length(); j++) {                f.addValue(hexString.substring(j, j + 1));            }        }        double[] expected = new double[16];        long[] observed = new long[16];        for (int i = 0; i < 16; i++) {            expected[i] = (double) smallSampleSize * 100 / 16;            observed[i] = f.getCount(hex[i]);        }        /*         * Use ChiSquare dist with df = 16-1 = 15, alpha = .001 Change to 30.58         * for alpha = .01         */        Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 37.70);    }    /** test dispersion and failure modes for nextHex() */    @Test    public void testNextSecureHex() {        try {            randomData.nextSecureHexString(-1);            Assert.fail("negative length -- MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }        try {            randomData.nextSecureHexString(0);            Assert.fail("zero length -- MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }        String hexString = randomData.nextSecureHexString(3);        if (hexString.length() != 3) {            Assert.fail("incorrect length for generated string");        }        hexString = randomData.nextSecureHexString(1);        if (hexString.length() != 1) {            Assert.fail("incorrect length for generated string");        }        try {            hexString = randomData.nextSecureHexString(0);            Assert.fail("zero length requested -- expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }        if (hexString.length() != 1) {            Assert.fail("incorrect length for generated string");        }        Frequency f = new Frequency();        for (int i = 0; i < smallSampleSize; i++) {            hexString = randomData.nextSecureHexString(100);            if (hexString.length() != 100) {                Assert.fail("incorrect length for generated string");            }            for (int j = 0; j < hexString.length(); j++) {                f.addValue(hexString.substring(j, j + 1));            }        }        double[] expected = new double[16];        long[] observed = new long[16];        for (int i = 0; i < 16; i++) {            expected[i] = (double) smallSampleSize * 100 / 16;            observed[i] = f.getCount(hex[i]);        }        /*         * Use ChiSquare dist with df = 16-1 = 15, alpha = .001 Change to 30.58         * for alpha = .01         */        Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 37.70);    }    /** test failure modes and dispersion of nextUniform() */    @Test    public void testNextUniform() {        try {            randomData.nextUniform(4, 3);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }        try {            randomData.nextUniform(3, 3);            Assert.fail("MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }        double[] expected = { 500, 500 };        long[] observed = { 0, 0 };        double lower = -1d;        double upper = 20d;        double midpoint = (lower + upper) / 2d;        double result = 0;        for (int i = 0; i < 1000; i++) {            result = randomData.nextUniform(lower, upper);            if ((result == lower) || (result == upper)) {                Assert.fail("generated value equal to an endpoint: " + result);            }            if (result < midpoint) {                observed[0]++;            } else {                observed[1]++;            }        }        /*         * Use ChiSquare dist with df = 2-1 = 1, alpha = .001 Change to 6.64 for         * alpha = .01         */        Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 10.83);    }    /** test exclusive endpoints of nextUniform **/    @Test    public void testNextUniformExclusiveEndpoints() {        for (int i = 0; i < 1000; i++) {            double u = randomData.nextUniform(0.99, 1);            Assert.assertTrue(u > 0.99 && u < 1);        }    }    /** test failure modes and distribution of nextGaussian() */    @Test    public void testNextGaussian() {        try {            randomData.nextGaussian(0, 0);            Assert.fail("zero sigma -- MathIllegalArgumentException expected");        } catch (MathIllegalArgumentException ex) {            // ignored        }        SummaryStatistics u = new SummaryStatistics();        for (int i = 0; i < largeSampleSize; i++) {            u.addValue(randomData.nextGaussian(0, 1));        }        double xbar = u.getMean();        double s = u.getStandardDeviation();        double n = u.getN();        /*         * t-test at .001-level TODO: replace with externalized t-test, with         * test statistic defined in TestStatistic         */        Assert.assertTrue(FastMath.abs(xbar) / (s / FastMath.sqrt(n)) < 3.29);    }    /** test failure modes and distribution of nextExponential() */    @Test    public void testNextExponential() throws Exception {        try {            randomData.nextExponential(-1);            Assert.fail("negative mean -- expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }        try {            randomData.nextExponential(0);            Assert.fail("zero mean -- expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }        long cumFreq = 0;        double v = 0;        for (int i = 0; i < largeSampleSize; i++) {            v = randomData.nextExponential(1);            Assert.assertTrue("exponential deviate postive", v > 0);            if (v < 2)                cumFreq++;        }        /*         * TODO: Replace with a statistical test, with statistic added to         * TestStatistic. Check below compares observed cumulative distribution         * evaluated at 2 with exponential CDF         */        Assert.assertEquals("exponential cumulative distribution", (double) cumFreq                / (double) largeSampleSize, 0.8646647167633873, .2);        /**         * Proposal on improving the test of generating exponentials         */        double[] quartiles;        long[] counts;        // Mean 1        quartiles = TestUtils.getDistributionQuartiles(new ExponentialDistributionImpl(1));        counts = new long[4];        randomData.reSeed(1000);        for (int i = 0; i < 1000; i++) {            double value = randomData.nextExponential(1);            TestUtils.updateCounts(value, counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);        // Mean 5        quartiles = TestUtils.getDistributionQuartiles(new ExponentialDistributionImpl(5));        counts = new long[4];        randomData.reSeed(1000);        for (int i = 0; i < 1000; i++) {            double value = randomData.nextExponential(5);            TestUtils.updateCounts(value, counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);    }    /** test reseeding, algorithm/provider games */    @Test    public void testConfig() {        randomData.reSeed(1000);        double v = randomData.nextUniform(0, 1);        randomData.reSeed();        Assert.assertTrue("different seeds", Math                .abs(v - randomData.nextUniform(0, 1)) > 10E-12);        randomData.reSeed(1000);        Assert.assertEquals("same seeds", v, randomData.nextUniform(0, 1), 10E-12);        randomData.reSeedSecure(1000);        String hex = randomData.nextSecureHexString(40);        randomData.reSeedSecure();        Assert.assertTrue("different seeds", !hex.equals(randomData                .nextSecureHexString(40)));        randomData.reSeedSecure(1000);        Assert.assertTrue("same seeds", !hex                .equals(randomData.nextSecureHexString(40)));        /*         * remove this test back soon, since it takes about 4 seconds         *         * try { randomData.setSecureAlgorithm("SHA1PRNG","SUN"); } catch         * (NoSuchProviderException ex) { ; } Assert.assertTrue("different seeds",         * !hex.equals(randomData.nextSecureHexString(40))); try {         * randomData.setSecureAlgorithm("NOSUCHTHING","SUN");         * Assert.fail("expecting NoSuchAlgorithmException"); } catch         * (NoSuchProviderException ex) { ; } catch (NoSuchAlgorithmException         * ex) { ; }         *         * try { randomData.setSecureAlgorithm("SHA1PRNG","NOSUCHPROVIDER");         * Assert.fail("expecting NoSuchProviderException"); } catch         * (NoSuchProviderException ex) { ; }         */        // test reseeding without first using the generators        RandomDataImpl rd = new RandomDataImpl();        rd.reSeed(100);        rd.nextLong(1, 2);        RandomDataImpl rd2 = new RandomDataImpl();        rd2.reSeedSecure(2000);        rd2.nextSecureLong(1, 2);        rd = new RandomDataImpl();        rd.reSeed();        rd.nextLong(1, 2);        rd2 = new RandomDataImpl();        rd2.reSeedSecure();        rd2.nextSecureLong(1, 2);    }    /** tests for nextSample() sampling from Collection */    @Test    public void testNextSample() {        Object[][] c = { { "0", "1" }, { "0", "2" }, { "0", "3" },                { "0", "4" }, { "1", "2" }, { "1", "3" }, { "1", "4" },                { "2", "3" }, { "2", "4" }, { "3", "4" } };        long[] observed = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };        double[] expected = { 100, 100, 100, 100, 100, 100, 100, 100, 100, 100 };        HashSet<Object> cPop = new HashSet<Object>(); // {0,1,2,3,4}        for (int i = 0; i < 5; i++) {            cPop.add(Integer.toString(i));        }        Object[] sets = new Object[10]; // 2-sets from 5        for (int i = 0; i < 10; i++) {            HashSet<Object> hs = new HashSet<Object>();            hs.add(c[i][0]);            hs.add(c[i][1]);            sets[i] = hs;        }        for (int i = 0; i < 1000; i++) {            Object[] cSamp = randomData.nextSample(cPop, 2);            observed[findSample(sets, cSamp)]++;        }        /*         * Use ChiSquare dist with df = 10-1 = 9, alpha = .001 Change to 21.67         * for alpha = .01         */        Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 27.88);        // Make sure sample of size = size of collection returns same collection        HashSet<Object> hs = new HashSet<Object>();        hs.add("one");        Object[] one = randomData.nextSample(hs, 1);        String oneString = (String) one[0];        if ((one.length != 1) || !oneString.equals("one")) {            Assert.fail("bad sample for set size = 1, sample size = 1");        }        // Make sure we fail for sample size > collection size        try {            one = randomData.nextSample(hs, 2);            Assert.fail("sample size > set size, expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }        // Make sure we fail for empty collection        try {            hs = new HashSet<Object>();            one = randomData.nextSample(hs, 0);            Assert.fail("n = k = 0, expecting MathIllegalArgumentException");        } catch (MathIllegalArgumentException ex) {            // ignored        }    }    @SuppressWarnings("unchecked")    private int findSample(Object[] u, Object[] samp) {        for (int i = 0; i < u.length; i++) {            HashSet<Object> set = (HashSet<Object>) u[i];            HashSet<Object> sampSet = new HashSet<Object>();            for (int j = 0; j < samp.length; j++) {                sampSet.add(samp[j]);            }            if (set.equals(sampSet)) {                return i;            }        }        Assert.fail("sample not found:{" + samp[0] + "," + samp[1] + "}");        return -1;    }    /** tests for nextPermutation */    @Test    public void testNextPermutation() {        int[][] p = { { 0, 1, 2 }, { 0, 2, 1 }, { 1, 0, 2 }, { 1, 2, 0 },                { 2, 0, 1 }, { 2, 1, 0 } };        long[] observed = { 0, 0, 0, 0, 0, 0 };        double[] expected = { 100, 100, 100, 100, 100, 100 };        for (int i = 0; i < 600; i++) {            int[] perm = randomData.nextPermutation(3, 3);            observed[findPerm(p, perm)]++;        }        /*         * Use ChiSquare dist with df = 6-1 = 5, alpha = .001 Change to 15.09         * for alpha = .01         */        Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 20.52);        // Check size = 1 boundary case        int[] perm = randomData.nextPermutation(1, 1);        if ((perm.length != 1) || (perm[0] != 0)) {            Assert.fail("bad permutation for n = 1, sample k = 1");            // Make sure we fail for k size > n            try {                perm = randomData.nextPermutation(2, 3);                Assert.fail("permutation k > n, expecting MathIllegalArgumentException");            } catch (MathIllegalArgumentException ex) {                // ignored            }            // Make sure we fail for n = 0            try {                perm = randomData.nextPermutation(0, 0);                Assert.fail("permutation k = n = 0, expecting MathIllegalArgumentException");            } catch (MathIllegalArgumentException ex) {                // ignored            }            // Make sure we fail for k < n < 0            try {                perm = randomData.nextPermutation(-1, -3);                Assert.fail("permutation k < n < 0, expecting MathIllegalArgumentException");            } catch (MathIllegalArgumentException ex) {                // ignored            }        }    }    // Disable until we have equals    //public void testSerial() {    //    Assert.assertEquals(randomData, TestUtils.serializeAndRecover(randomData));    //}    private int findPerm(int[][] p, int[] samp) {        for (int i = 0; i < p.length; i++) {            boolean good = true;            for (int j = 0; j < samp.length; j++) {                if (samp[j] != p[i][j]) {                    good = false;                }            }            if (good) {                return i;            }        }        Assert.fail("permutation not found");        return -1;    }    @Test    public void testNextInversionDeviate() throws Exception {        // Set the seed for the default random generator        randomData.reSeed(100);        double[] quantiles = new double[10];        for (int i = 0; i < 10; i++) {            quantiles[i] = randomData.nextUniform(0, 1);        }        // Reseed again so the inversion generator gets the same sequence        randomData.reSeed(100);        BetaDistributionImpl betaDistribution = new BetaDistributionImpl(2, 4);        /*         *  Generate a sequence of deviates using inversion - the distribution function         *  evaluated at the random value from the distribution should match the uniform         *  random value used to generate it, which is stored in the quantiles[] array.         */        for (int i = 0; i < 10; i++) {            double value = randomData.nextInversionDeviate(betaDistribution);            Assert.assertEquals(betaDistribution.cumulativeProbability(value), quantiles[i], 10E-9);        }    }    @Test    public void testNextBeta() throws Exception {        double[] quartiles = TestUtils.getDistributionQuartiles(new BetaDistributionImpl(2,5));        long[] counts = new long[4];        randomData.reSeed(1000);        for (int i = 0; i < 1000; i++) {            double value = randomData.nextBeta(2, 5);            TestUtils.updateCounts(value, counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);    }    @Test    public void testNextCauchy() throws Exception {        double[] quartiles = TestUtils.getDistributionQuartiles(new CauchyDistributionImpl(1.2, 2.1));        long[] counts = new long[4];        randomData.reSeed(1000);        for (int i = 0; i < 1000; i++) {            double value = randomData.nextCauchy(1.2, 2.1);            TestUtils.updateCounts(value, counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);    }    @Test    public void testNextChiSquare() throws Exception {        double[] quartiles = TestUtils.getDistributionQuartiles(new ChiSquaredDistributionImpl(12));        long[] counts = new long[4];        randomData.reSeed(1000);        for (int i = 0; i < 1000; i++) {            double value = randomData.nextChiSquare(12);            TestUtils.updateCounts(value, counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);    }    @Test    public void testNextF() throws Exception {        double[] quartiles = TestUtils.getDistributionQuartiles(new FDistributionImpl(12, 5));        long[] counts = new long[4];        randomData.reSeed(1000);        for (int i = 0; i < 1000; i++) {            double value = randomData.nextF(12, 5);            TestUtils.updateCounts(value, counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);    }    @Test    public void testNextGamma() throws Exception {        double[] quartiles;        long[] counts;                // Tests shape > 1, one case in the rejection sampling        quartiles = TestUtils.getDistributionQuartiles(new GammaDistributionImpl(4, 2));        counts = new long[4];        randomData.reSeed(1000);        for (int i = 0; i < 1000; i++) {            double value = randomData.nextGamma(4, 2);            TestUtils.updateCounts(value, counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);                // Tests shape <= 1, another case in the rejection sampling                quartiles = TestUtils.getDistributionQuartiles(new GammaDistributionImpl(0.3, 3));        counts = new long[4];        randomData.reSeed(1000);        for (int i = 0; i < 1000; i++) {            double value = randomData.nextGamma(0.3, 3);            TestUtils.updateCounts(value, counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);    }    @Test    public void testNextT() throws Exception {        double[] quartiles = TestUtils.getDistributionQuartiles(new TDistributionImpl(10));        long[] counts = new long[4];        randomData.reSeed(1000);        for (int i = 0; i < 1000; i++) {            double value = randomData.nextT(10);            TestUtils.updateCounts(value, counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);    }    @Test    public void testNextWeibull() throws Exception {        double[] quartiles = TestUtils.getDistributionQuartiles(new WeibullDistributionImpl(1.2, 2.1));        long[] counts = new long[4];        randomData.reSeed(1000);        for (int i = 0; i < 1000; i++) {            double value = randomData.nextWeibull(1.2, 2.1);            TestUtils.updateCounts(value, counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);    }    @Test    public void testNextBinomial() throws Exception {        BinomialDistributionTest testInstance = new BinomialDistributionTest();        int[] densityPoints = testInstance.makeDensityTestPoints();        double[] densityValues = testInstance.makeDensityTestValues();        int sampleSize = 1000;        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);        BinomialDistributionImpl distribution = (BinomialDistributionImpl) testInstance.makeDistribution();        double[] expectedCounts = new double[length];        long[] observedCounts = new long[length];        for (int i = 0; i < length; i++) {            expectedCounts[i] = sampleSize * densityValues[i];        }        randomData.reSeed(1000);        for (int i = 0; i < sampleSize; i++) {          int value = randomData.nextBinomial(distribution.getNumberOfTrials(),                  distribution.getProbabilityOfSuccess());          for (int j = 0; j < length; j++) {              if (value == densityPoints[j]) {                  observedCounts[j]++;              }          }        }        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);    }    @Test    public void testNextHypergeometric() throws Exception {        HypergeometricDistributionTest testInstance = new HypergeometricDistributionTest();        int[] densityPoints = testInstance.makeDensityTestPoints();        double[] densityValues = testInstance.makeDensityTestValues();        int sampleSize = 1000;        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);        HypergeometricDistributionImpl distribution = (HypergeometricDistributionImpl) testInstance.makeDistribution();        double[] expectedCounts = new double[length];        long[] observedCounts = new long[length];        for (int i = 0; i < length; i++) {            expectedCounts[i] = sampleSize * densityValues[i];        }        randomData.reSeed(1000);        for (int i = 0; i < sampleSize; i++) {          int value = randomData.nextHypergeometric(distribution.getPopulationSize(),                  distribution.getNumberOfSuccesses(), distribution.getSampleSize());          for (int j = 0; j < length; j++) {              if (value == densityPoints[j]) {                  observedCounts[j]++;              }          }        }        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);    }    @Test    public void testNextPascal() throws Exception {        PascalDistributionTest testInstance = new PascalDistributionTest();        int[] densityPoints = testInstance.makeDensityTestPoints();        double[] densityValues = testInstance.makeDensityTestValues();        int sampleSize = 1000;        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);        PascalDistributionImpl distribution = (PascalDistributionImpl) testInstance.makeDistribution();        double[] expectedCounts = new double[length];        long[] observedCounts = new long[length];        for (int i = 0; i < length; i++) {            expectedCounts[i] = sampleSize * densityValues[i];        }        randomData.reSeed(1000);        for (int i = 0; i < sampleSize; i++) {          int value = randomData.nextPascal(distribution.getNumberOfSuccesses(), distribution.getProbabilityOfSuccess());          for (int j = 0; j < length; j++) {              if (value == densityPoints[j]) {                  observedCounts[j]++;              }          }        }        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);    }    @Test    public void testNextZipf() throws Exception {        ZipfDistributionTest testInstance = new ZipfDistributionTest();        int[] densityPoints = testInstance.makeDensityTestPoints();        double[] densityValues = testInstance.makeDensityTestValues();        int sampleSize = 1000;        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);        ZipfDistributionImpl distribution = (ZipfDistributionImpl) testInstance.makeDistribution();        double[] expectedCounts = new double[length];        long[] observedCounts = new long[length];        for (int i = 0; i < length; i++) {            expectedCounts[i] = sampleSize * densityValues[i];        }        randomData.reSeed(1000);        for (int i = 0; i < sampleSize; i++) {          int value = randomData.nextZipf(distribution.getNumberOfElements(), distribution.getExponent());          for (int j = 0; j < length; j++) {              if (value == densityPoints[j]) {                  observedCounts[j]++;              }          }        }        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import java.util.Random;/** * Dummy AbstractRandomGenerator concrete subclass that just wraps a * java.util.Random instance.  Used by AbstractRandomGeneratorTest to test * default implementations in AbstractRandomGenerator. * * @version $Id$ */public class TestRandomGenerator extends AbstractRandomGenerator {    private Random random = new Random();    @Override    public void setSeed(long seed) {       clear();       random.setSeed(seed);    }    @Override    public double nextDouble() {        return random.nextDouble();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;/** * Test cases for the AbstractRandomGenerator class. * * @version $Id$ */public class AbstractRandomGeneratorTest extends RandomGeneratorAbstractTest {    public AbstractRandomGeneratorTest() {        super();    }        protected RandomGenerator makeGenerator() {        RandomGenerator generator = new TestRandomGenerator();        generator.setSeed(1001);        return generator;    }    }
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.random;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;import org.apache.commons.math.stat.descriptive.moment.VectorialMean;import org.apache.commons.math.util.FastMath;import org.junit.Test;import org.junit.Assert;public class CorrelatedRandomVectorGeneratorTest {    private double[] mean;    private RealMatrix covariance;    private CorrelatedRandomVectorGenerator generator;    public CorrelatedRandomVectorGeneratorTest() {        mean = new double[] { 0.0, 1.0, -3.0, 2.3 };        RealMatrix b = MatrixUtils.createRealMatrix(4, 3);        int counter = 0;        for (int i = 0; i < b.getRowDimension(); ++i) {            for (int j = 0; j < b.getColumnDimension(); ++j) {                b.setEntry(i, j, 1.0 + 0.1 * ++counter);            }        }        RealMatrix bbt = b.multiply(b.transpose());        covariance = MatrixUtils.createRealMatrix(mean.length, mean.length);        for (int i = 0; i < covariance.getRowDimension(); ++i) {            covariance.setEntry(i, i, bbt.getEntry(i, i));            for (int j = 0; j < covariance.getColumnDimension(); ++j) {                double s = bbt.getEntry(i, j);                covariance.setEntry(i, j, s);                covariance.setEntry(j, i, s);            }        }        RandomGenerator rg = new JDKRandomGenerator();        rg.setSeed(17399225432l);        GaussianRandomGenerator rawGenerator = new GaussianRandomGenerator(rg);        generator = new CorrelatedRandomVectorGenerator(mean,                                                        covariance,                                                        1.0e-12 * covariance.getNorm(),                                                        rawGenerator);    }    @Test    public void testRank() {        Assert.assertEquals(3, generator.getRank());    }    @Test    public void testMath226() {        double[] mean = { 1, 1, 10, 1 };        double[][] cov = {                { 1, 3, 2, 6 },                { 3, 13, 16, 2 },                { 2, 16, 38, -1 },                { 6, 2, -1, 197 }        };        RealMatrix covRM = MatrixUtils.createRealMatrix(cov);        JDKRandomGenerator jg = new JDKRandomGenerator();        jg.setSeed(5322145245211l);        NormalizedRandomGenerator rg = new GaussianRandomGenerator(jg);        CorrelatedRandomVectorGenerator sg =            new CorrelatedRandomVectorGenerator(mean, covRM, 0.00001, rg);        for (int i = 0; i < 10; i++) {            double[] generated = sg.nextVector();            Assert.assertTrue(FastMath.abs(generated[0] - 1) > 0.1);        }    }    @Test    public void testRootMatrix() {        RealMatrix b = generator.getRootMatrix();        RealMatrix bbt = b.multiply(b.transpose());        for (int i = 0; i < covariance.getRowDimension(); ++i) {            for (int j = 0; j < covariance.getColumnDimension(); ++j) {                Assert.assertEquals(covariance.getEntry(i, j), bbt.getEntry(i, j), 1.0e-12);            }        }    }    @Test    public void testMeanAndCovariance() {        VectorialMean meanStat = new VectorialMean(mean.length);        VectorialCovariance covStat = new VectorialCovariance(mean.length, true);        for (int i = 0; i < 5000; ++i) {            double[] v = generator.nextVector();            meanStat.increment(v);            covStat.increment(v);        }        double[] estimatedMean = meanStat.getResult();        RealMatrix estimatedCovariance = covStat.getResult();        for (int i = 0; i < estimatedMean.length; ++i) {            Assert.assertEquals(mean[i], estimatedMean[i], 0.07);            for (int j = 0; j <= i; ++j) {                Assert.assertEquals(covariance.getEntry(i, j),                                    estimatedCovariance.getEntry(i, j),                                    0.1 * (1.0 + FastMath.abs(mean[i])) * (1.0 + FastMath.abs(mean[j])));            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import java.io.EOFException;import java.net.URL;import java.util.Arrays;import org.apache.commons.math.RetryRunner;import org.apache.commons.math.stat.descriptive.SummaryStatistics;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;/** * Test cases for the ValueServer class. * * @version $Id$ */@RunWith(RetryRunner.class)public final class ValueServerTest {    private ValueServer vs = new ValueServer();    @Before    public void setUp() {        vs.setMode(ValueServer.DIGEST_MODE);        URL url = getClass().getResource("testData.txt");        vs.setValuesFileURL(url);    }    /**      * Generate 1000 random values and make sure they look OK.<br>      * Note that there is a non-zero (but very small) probability that      * these tests will fail even if the code is working as designed.      */    @Test    public void testNextDigest() throws Exception {        double next = 0.0;        double tolerance = 0.1;        vs.computeDistribution();        Assert.assertTrue("empirical distribution property",            vs.getEmpiricalDistribution() != null);        SummaryStatistics stats = new SummaryStatistics();        for (int i = 1; i < 1000; i++) {            next = vs.getNext();            stats.addValue(next);        }        Assert.assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);        Assert.assertEquals("std dev", 1.0173699343977738, stats.getStandardDeviation(),            tolerance);        vs.computeDistribution(500);        stats = new SummaryStatistics();        for (int i = 1; i < 1000; i++) {            next = vs.getNext();            stats.addValue(next);        }        Assert.assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);        Assert.assertEquals("std dev", 1.0173699343977738, stats.getStandardDeviation(),            tolerance);    }        /**     * Verify that when provided with fixed seeds, stochastic modes     * generate fixed sequences.  Verifies the fix for MATH-654.     */    @Test     public void testFixedSeed() throws Exception {        ValueServer valueServer = new ValueServer();        URL url = getClass().getResource("testData.txt");        valueServer.setValuesFileURL(url);        valueServer.computeDistribution();        checkFixedSeed(valueServer, ValueServer.DIGEST_MODE);        checkFixedSeed(valueServer, ValueServer.EXPONENTIAL_MODE);        checkFixedSeed(valueServer, ValueServer.GAUSSIAN_MODE);        checkFixedSeed(valueServer, ValueServer.UNIFORM_MODE);    }        /**     * Do the check for {@link #testFixedSeed()}     * @param mode ValueServer mode     */    private void checkFixedSeed(ValueServer valueServer, int mode) throws Exception {        valueServer.reSeed(1000);        valueServer.setMode(mode);        double[][] values = new double[2][100];        for (int i = 0; i < 100; i++) {            values[0][i] = valueServer.getNext();        }        valueServer.reSeed(1000);        for (int i = 0; i < 100; i++) {            values[1][i] = valueServer.getNext();        }        Assert.assertTrue(Arrays.equals(values[0], values[1]));     }    /**      * Make sure exception thrown if digest getNext is attempted      * before loading empiricalDistribution.      */    @Test    public void testNextDigestFail() throws Exception {        try {            vs.getNext();            Assert.fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {}    }    @Test    public void testEmptyReplayFile() throws Exception {        try {            URL url = getClass().getResource("emptyFile.txt");            vs.setMode(ValueServer.REPLAY_MODE);            vs.setValuesFileURL(url);            vs.getNext();            Assert.fail("an exception should have been thrown");        } catch (EOFException eof) {            // expected behavior        }    }    @Test    public void testEmptyDigestFile() throws Exception {        try {            URL url = getClass().getResource("emptyFile.txt");            vs.setMode(ValueServer.DIGEST_MODE);            vs.setValuesFileURL(url);            vs.computeDistribution();            Assert.fail("an exception should have been thrown");        } catch (EOFException eof) {            // expected behavior        }    }    /**     * Test ValueServer REPLAY_MODE using values in testData file.<br>     * Check that the values 1,2,1001,1002 match data file values 1 and 2.     * the sample data file.     */    @Test    public void testReplay() throws Exception {        double firstDataValue = 4.038625496201205;        double secondDataValue = 3.6485326248346936;        double tolerance = 10E-15;        double compareValue = 0.0d;        vs.setMode(ValueServer.REPLAY_MODE);        vs.resetReplayFile();        compareValue = vs.getNext();        Assert.assertEquals(compareValue,firstDataValue,tolerance);        compareValue = vs.getNext();        Assert.assertEquals(compareValue,secondDataValue,tolerance);        for (int i = 3; i < 1001; i++) {           compareValue = vs.getNext();        }        compareValue = vs.getNext();        Assert.assertEquals(compareValue,firstDataValue,tolerance);        compareValue = vs.getNext();        Assert.assertEquals(compareValue,secondDataValue,tolerance);        vs.closeReplayFile();        // make sure no NPE        vs.closeReplayFile();    }    /**     * Test other ValueServer modes     */    @Test    public void testModes() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        vs.setMu(0);        Assert.assertEquals("constant mode test",vs.getMu(),vs.getNext(),Double.MIN_VALUE);        vs.setMode(ValueServer.UNIFORM_MODE);        vs.setMu(2);        double val = vs.getNext();        Assert.assertTrue(val > 0 && val < 4);        vs.setSigma(1);        vs.setMode(ValueServer.GAUSSIAN_MODE);        val = vs.getNext();        Assert.assertTrue("gaussian value close enough to mean",            val < vs.getMu() + 100*vs.getSigma());        vs.setMode(ValueServer.EXPONENTIAL_MODE);        val = vs.getNext();        Assert.assertTrue(val > 0);        try {            vs.setMode(1000);            vs.getNext();            Assert.fail("bad mode, expecting IllegalStateException");        } catch (IllegalStateException ex) {            // ignored        }    }    /**     * Test fill     */    @Test    public void testFill() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        vs.setMu(2);        double[] val = new double[5];        vs.fill(val);        for (int i = 0; i < 5; i++) {            Assert.assertEquals("fill test in place",2,val[i],Double.MIN_VALUE);        }        double v2[] = vs.fill(3);        for (int i = 0; i < 3; i++) {            Assert.assertEquals("fill test in place",2,v2[i],Double.MIN_VALUE);        }    }    /**     * Test getters to make Clover happy     */    @Test    public void testProperties() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        Assert.assertEquals("mode test",ValueServer.CONSTANT_MODE,vs.getMode());        vs.setValuesFileURL("http://www.apache.org");        URL url = vs.getValuesFileURL();        Assert.assertEquals("valuesFileURL test","http://www.apache.org",url.toString());    }}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.random;import org.apache.commons.math.stat.StatUtils;import org.junit.Assert;import org.junit.Test;public class UniformRandomGeneratorTest {    @Test    public void testMeanAndStandardDeviation() {        RandomGenerator rg = new JDKRandomGenerator();        rg.setSeed(17399225432l);        UniformRandomGenerator generator = new UniformRandomGenerator(rg);        double[] sample = new double[10000];        for (int i = 0; i < sample.length; ++i) {            sample[i] = generator.nextNormalizedDouble();        }        Assert.assertEquals(0.0, StatUtils.mean(sample), 0.07);        Assert.assertEquals(1.0, StatUtils.variance(sample), 0.02);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import java.io.BufferedReader;import java.io.File;import java.io.IOException;import java.io.InputStreamReader;import java.net.URL;import java.util.ArrayList;import org.apache.commons.math.TestUtils;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.stat.descriptive.SummaryStatistics;import org.junit.Assert;import org.junit.Before;import org.junit.Test;/** * Test cases for the EmpiricalDistribution class * * @version $Id$ */public final class EmpiricalDistributionTest {    protected EmpiricalDistributionImpl empiricalDistribution = null;    protected EmpiricalDistributionImpl empiricalDistribution2 = null;    protected File file = null;    protected URL url = null;    protected double[] dataArray = null;    @Before    public void setUp() throws IOException {        empiricalDistribution = new EmpiricalDistributionImpl(100);        url = getClass().getResource("testData.txt");        empiricalDistribution2 = new EmpiricalDistributionImpl(100);        BufferedReader in =                new BufferedReader(new InputStreamReader(                        url.openStream()));        String str = null;        ArrayList<Double> list = new ArrayList<Double>();        while ((str = in.readLine()) != null) {            list.add(Double.valueOf(str));        }        in.close();        in = null;        dataArray = new double[list.size()];        int i = 0;        for (Double data : list) {            dataArray[i] = data.doubleValue();            i++;        }    }    /**     * Test EmpiricalDistrbution.load() using sample data file.<br>     * Check that the sampleCount, mu and sigma match data in     * the sample data file.     */    @Test    public void testLoad() throws Exception {        empiricalDistribution.load(url);        // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1        // Make sure that loaded distribution matches this        Assert.assertEquals(empiricalDistribution.getSampleStats().getN(),1000,10E-7);        //TODO: replace with statistical tests        Assert.assertEquals(empiricalDistribution.getSampleStats().getMean(),                5.069831575018909,10E-7);        Assert.assertEquals(empiricalDistribution.getSampleStats().getStandardDeviation(),                1.0173699343977738,10E-7);    }    /**     * Test EmpiricalDistrbution.load(double[]) using data taken from     * sample data file.<br>     * Check that the sampleCount, mu and sigma match data in     * the sample data file.     */    @Test    public void testDoubleLoad() throws Exception {        empiricalDistribution2.load(dataArray);        // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1        // Make sure that loaded distribution matches this        Assert.assertEquals(empiricalDistribution2.getSampleStats().getN(),1000,10E-7);        //TODO: replace with statistical tests        Assert.assertEquals(empiricalDistribution2.getSampleStats().getMean(),                5.069831575018909,10E-7);        Assert.assertEquals(empiricalDistribution2.getSampleStats().getStandardDeviation(),                1.0173699343977738,10E-7);        double[] bounds = ((EmpiricalDistributionImpl) empiricalDistribution2).getGeneratorUpperBounds();        Assert.assertEquals(bounds.length, 100);        Assert.assertEquals(bounds[99], 1.0, 10e-12);    }    /**      * Generate 1000 random values and make sure they look OK.<br>      * Note that there is a non-zero (but very small) probability that      * these tests will fail even if the code is working as designed.      */    @Test    public void testNext() throws Exception {        tstGen(0.1);        tstDoubleGen(0.1);    }    /**      * Make sure exception thrown if digest getNext is attempted      * before loading empiricalDistribution.     */    @Test    public void testNexFail() {        try {            empiricalDistribution.getNextValue();            empiricalDistribution2.getNextValue();            Assert.fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {            // expected        }    }    /**     * Make sure we can handle a grid size that is too fine     */    @Test    public void testGridTooFine() throws Exception {        empiricalDistribution = new EmpiricalDistributionImpl(1001);        tstGen(0.1);        empiricalDistribution2 = new EmpiricalDistributionImpl(1001);        tstDoubleGen(0.1);    }    /**     * How about too fat?     */    @Test    public void testGridTooFat() throws Exception {        empiricalDistribution = new EmpiricalDistributionImpl(1);        tstGen(5); // ridiculous tolerance; but ridiculous grid size                   // really just checking to make sure we do not bomb        empiricalDistribution2 = new EmpiricalDistributionImpl(1);        tstDoubleGen(5);    }    /**     * Test bin index overflow problem (BZ 36450)     */    @Test    public void testBinIndexOverflow() throws Exception {        double[] x = new double[] {9474.94326071674, 2080107.8865462579};        new EmpiricalDistributionImpl().load(x);    }    @Test    public void testSerialization() {        // Empty        EmpiricalDistribution dist = new EmpiricalDistributionImpl();        EmpiricalDistribution dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(dist);        verifySame(dist, dist2);        // Loaded        empiricalDistribution2.load(dataArray);        dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(empiricalDistribution2);        verifySame(empiricalDistribution2, dist2);    }    @Test(expected=NullArgumentException.class)    public void testLoadNullDoubleArray() {       new EmpiricalDistributionImpl().load((double[]) null);    }    @Test(expected=NullArgumentException.class)    public void testLoadNullURL() throws Exception {        new EmpiricalDistributionImpl().load((URL) null);    }    @Test(expected=NullArgumentException.class)    public void testLoadNullFile() throws Exception {        new EmpiricalDistributionImpl().load((File) null);    }    /**     * MATH-298     */    @Test    public void testGetBinUpperBounds() {        double[] testData = {0, 1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10};        EmpiricalDistributionImpl dist = new EmpiricalDistributionImpl(5);        dist.load(testData);        double[] expectedBinUpperBounds = {2, 4, 6, 8, 10};        double[] expectedGeneratorUpperBounds = {4d/13d, 7d/13d, 9d/13d, 11d/13d, 1};        double tol = 10E-12;        TestUtils.assertEquals(expectedBinUpperBounds, dist.getUpperBounds(), tol);        TestUtils.assertEquals(expectedGeneratorUpperBounds, dist.getGeneratorUpperBounds(), tol);    }        @Test    public void testGeneratorConfig() {        double[] testData = {0, 1, 2, 3, 4};        RandomGenerator generator = new RandomAdaptorTest.ConstantGenerator(0.5);                EmpiricalDistribution dist = new EmpiricalDistributionImpl(5, generator);        dist.load(testData);        for (int i = 0; i < 5; i++) {            Assert.assertEquals(2.0, dist.getNextValue(), 0d);        }                // Verify no NPE with null generator argument        dist = new EmpiricalDistributionImpl(5, (RandomGenerator) null);        dist.load(testData);        dist.getNextValue();    }        @Test    public void testReSeed() throws Exception {        empiricalDistribution.load(url);        empiricalDistribution.reSeed(100);        final double [] values = new double[10];        for (int i = 0; i < 10; i++) {            values[i] = empiricalDistribution.getNextValue();        }        empiricalDistribution.reSeed(100);        for (int i = 0; i < 10; i++) {            Assert.assertEquals(values[i],empiricalDistribution.getNextValue(), 0d);        }    }    private void verifySame(EmpiricalDistribution d1, EmpiricalDistribution d2) {        Assert.assertEquals(d1.isLoaded(), d2.isLoaded());        Assert.assertEquals(d1.getBinCount(), d2.getBinCount());        Assert.assertEquals(d1.getSampleStats(), d2.getSampleStats());        if (d1.isLoaded()) {            for (int i = 0;  i < d1.getUpperBounds().length; i++) {                Assert.assertEquals(d1.getUpperBounds()[i], d2.getUpperBounds()[i], 0);            }            Assert.assertEquals(d1.getBinStats(), d2.getBinStats());        }    }    private void tstGen(double tolerance)throws Exception {        empiricalDistribution.load(url);        empiricalDistribution.reSeed(1000);        SummaryStatistics stats = new SummaryStatistics();        for (int i = 1; i < 1000; i++) {            stats.addValue(empiricalDistribution.getNextValue());        }        Assert.assertEquals("mean", 5.069831575018909, stats.getMean(),tolerance);        Assert.assertEquals("std dev", 1.0173699343977738, stats.getStandardDeviation(),tolerance);    }    private void tstDoubleGen(double tolerance)throws Exception {        empiricalDistribution2.load(dataArray);        empiricalDistribution2.reSeed(1000);        SummaryStatistics stats = new SummaryStatistics();        for (int i = 1; i < 1000; i++) {            stats.addValue(empiricalDistribution2.getNextValue());        }        Assert.assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);        Assert.assertEquals("std dev", 1.0173699343977738, stats.getStandardDeviation(), tolerance);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import org.junit.Assert;import org.junit.Test;public class Well44497bTest extends RandomGeneratorAbstractTest {        @Override    public RandomGenerator makeGenerator() {        return new Well44497b(100);    }            @Test    public void testReferenceCode() {        int[] base = {              740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,            -1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000,             -595495729,  1047766204,  1875773301, -1637793284,  1379017098,   262792705,   191880010,  -251000180,            -1753047622,  -972355720,    90626881,  1644693418,  1503365577,   439653419,  1806361562,  1268823869         };        int[] init = new int[1391];        for (int i = 0; i < init.length; ++i) {            init[i] = base[i % base.length] + i;        }        Well44497b mt = new Well44497b(init);        int[] refInt = {           -102003638,  -1254584449,    836441550,   1949705484,    653000494,   1579400718,    699652570,   -140738233,   1164288466,    419933874,    366568847,    780567309,   1867405910,   -350557801,   -964350642,  -1323492759,            191502468,    398676344,   1568976991,   1005053759,    199053603,     31083944,     74697788,  -1343941248,  -1205631880,  -1637961625,    361813531,  -1706096179,   -403340909,   1666226814,  -2034962600,   1237102662,          -1833248535,   1584255126,   1295661745,  -1753848945,   1208145993,    930278953,   -733716134,    192752767,   1692463060,   1727273316,   2122952931,   -809025255,   -992081044,   -895539688,   -419372543,  -1835478922,           2089629419,   1646590742,  -1261083717,  -1005462992,   1619627287,  -1437723182,   1619689210,   1319393089,  -1816963183,   -150214444,   -513482220,   1897815796,  -1861960936,  -1766444468,   2034653890,    585657634,           1867016559,    696942260,  -1536237241,   -527055447,  -1554805020,  -1063992566,   1024799415,   1782080572,  -1884276362,    129028272,   1427925968,  -1154222271,  -1383146732,  -1580532830,  -1907049616,   -104299169,          -1780913000,  -2090815339,  -1789809502,  -1521443849,   1226625769,   1126090676,  -2117094290,   -449575109,   -218982833,   -695554478,     35923022,   1386126825,    -95031305,   -168657023,    436674049,  -1137917876,          -2045134053,  -1025629865,    133144659,     64226081,  -1966942130,    700813483,    344058910,   -910646033,   -212789479,    740360859,  -1269028713,   1517763679,   -664178514,   -683718472,    -71951996,     86583727,          -1235669348,  -1426987265,   -166598353,    214190040,  -1436967644,    233824411,    710927452,  -1939548641,   -433607408,  -1075939594,  -1549702826,  -1310827917,   -640604762,   -696863672,  -1282162126,   -546470833,          -1516734192,   -513809904,   -458526835,    708926727,   -476643096,  -2108375037,     -2870478,  -1460116421,    436587555,   -948939610,   1891375124,   1944216545,    959034236,  -1267038790,  -1695098736,   1853748495,           1594424552,   1270099319,   1139585482,   1837434635,   -709909535,   -457524230,   -887118113,   -241703912,  -1888225819,   -751575804,   1122280146,   1194255209,    949350188,    892826516,   -791212042,   -151203035,           -859297731,  -1979039938,    323603119,  -1022065097,  -1804294506,   -385802891,  -2127523442,   -720380255,  -1315859127,    999649487,    335041941,  -1732821688,  -1833409827,    535715225,  -1285355653,   1206723386,          -1141619270,    759796285,  -1599504546,  -1988521411,   1056668895,   -852564594,   1056509609,  -1831687977,    754168875,  -1301144422,    922880446,  -1502666503,   -949791898,  -1043870198,  -1136941938,  -1649670259,           1342769348,   1692605059,   -132279148,  -1108038310,    -14355545,  -1611387086,   1651826569,    877600127,   1356160799,   -759125205,  -1300490081,   -414938486,   -201479285,   1958709363,   1513313540,  -1396836908,           1352702612,   1142506253,     52969438,   -365142357,  -1619054179,  -1368514102,   1470750417,  -1420830959,   -843909462,  -1679570143,   1447444607,    234551752,  -1507452115,  -1433234579,   -680890000,   -497305145,            860408898,    263376761,   1537070218,   -592353956,   1587852989,   1756653749,  -2081320633,  -1547020311,    723771611,   -883819383,   1899879513,   -268417584,   1058606451,   1665941493,  -1630340612,   -614737477,            891313237,   1368950660,  -1166187089,    296322368,  -1908770726,  -2120378408,   1245479677,   1879710487,  -1705947124,   1018371589,  -1715010575,  -1096078094,  -1749891454,   2130888667,    318647750,    554592231,           -489121568,  -1809605233,  -1697905160,   -953926536,  -2013960553,   -148884919,   1822739964,  -1466301760,    141999978,   1946526064,   1323036718,    864390149,  -2141665227,   1510602225,   1468408474,   1277039721,          -1368096647,    180965986,   2140852057,   -688071899,    819713016,   -154385940,  -1182972611,   1257224305,   1392607672,   1364245931,  -1768434401,    323522132,   -555278604,    474186520,  -1178901665,  -2137343658,           1636421121,   1398987084,   1276656225,   1013316006,   -955917865,  -1537149363,   -179145358,    342862050,   1172728007,    736300054,  -1114656959,  -1831840325,  -1882353535,   -442915191,  -1206488416,  -1818534411,             25312311,   2100297098,  -1562767719,   1762553519,  -1853194231,  -1152612739,  -2020055792,   -809572150,    848584579,   -535789699,   1817604709,   1343773216,   -602234204,   1739930964,   -833790834,    501215449,           -730104057,   1217783189,   -681773267,   -611951354,    978387629,  -1516811237,    974303980,  -1389665696,   2091099075,   -727528826,   2116026151,    271935854,    613242379,  -2100429856,    190004963,  -1629612570,          -1362888327,    175094223,   -917873219,  -2008308245,   -401946815,    504218792,  -1966525201,      4106248,    164895454,    226502921,    655865257,   -610528718,    189428750,   1055978898,     17603028,    591024369,           1127922501,  -1546639293,   1994174637,   -724136988,   -673919372,  -1665002120,   -612145705,   -793102882,  -1904763558,    757565058,  -2091240021,  -2123324826,  -1518702766,   -802889839,   -223045921,  -1509216579,           1195556261,   2079259971,   -903969953,  -1781800655,   1834950463,   -956531922,  -1152550807,  -1116052662,   -348802884,  -1395330117,    -91758501,    -19115285,   1926930669,  -1015793599,    545904386,   1617858191,            716963473,   1917089719,   -980914811,   -212646927,  -1634695647,  -1857924568,  -1462257477,   1273750178,   1060328454,   -361604424,    867932749,    451213698,    405780152,   1165233215,   1877230909,   2103114395,           1644330815,   1252998537,   1961603970,  -1533101488,   1790456024,    -38226118,  -1306744489,    713676418,  -1535871838,   1378109935,   -338185548,   1647669762,   -477465913,    203482277,  -1949756706,   -503326093,           -638704909,    320186309,  -1435581459,    907446649,    -77384645,    537368928,   -335347295,  -1912061924,    547819174,   -225549827,   1089455486,    463516297,   -240127764,    -85895271,   2053179697,   -287394931,            921878827,   -933362608,  -1178670275,  -1200942874,   -672571265,    574422382,   1441734039,  -1814493454,    165751640,   -176907245,  -1170992192,  -2123252090,  -1435971541,   1591853830,   -885477992,   -792847559,           1359875286,   1038392904,  -2027255124,    687291425,   -165513490,   1391146576,  -1387080955,    794663652,   -807189965,    667820962,   -545384499,  -1371368854,   -689031878,   1504805541,   -752825823,  -1920047745,          -1884874017,   -350566320,   -197152911,   -181743050,   -798415949,   -915922276,   1790690149,   -363997181,   1923116185,  -1326427198,  -1621079427,  -1997440997,   1798118127,  -2053110382,   -159879848,  -1286787216,           1046436411,   1832030471,   -389092059,     71686169,    -76025260,   1914270607,   1854169353,    872157826,  -1774323792,   -575165717,  -1919931724,   2051498109,  -1176174934,   -883578901,  -1253047270,  -1310573900,            245466682,  -1784824328,  -1319912821,   1377340217,   1364313761,   -408687373,    142333378,  -1952335763,  -1703126184,    316314678,   2030555423,    488640834,  -1783293306,   2116925005,   -428337460,    -42966447,           -476226114,   -325172903,  -1690748475,    852791569,     26490302,     85251337,  -1374975770,   -376283969,    982639600,    595119792,    376403422,   1574509912,  -1509664496,  -1901241749,    -59019104,    358566667,            341667214,    184541206,   -550950854,  -1897143732,   1595753537,  -1236127928,   2014297822,  -2033179270,   -669806121,  -1927596980,   1010735700,   -581795164,   1922398838,  -1456743538,  -1633813803,    323177707,           2002098813,  -2099067658,    277393729,   -671911622,   -384463053,   2028267908,    367391785,   1270052637,   -172839030,   -650486693,   -831800809,  -1255138113,   -137512799,   1904317942,     -8229811,    707361898,           -276859812,     50417442,   1487081728,   1577776181,   1994451303,   1237303035,   -602016235,  -1905218276,  -1895725672,   1172978849,    801129953,  -1819485071,   -587985848,  -2010386741,  -1645226427,   -850866837,            816998708,    357665811,   1955856762,   1617902189,  -1013761306,    146782652,    904185608,   -500146809,   2085848310,   1917713975,  -1823786899,   1994184748,    789196322,   1766857258,   1770685286,     58213029,          -1699628994,    346827379,  -1274423227,     -5079670,   -193099487,   1020296939,  -1795904054,  -1951053094,    -43782418,   -375403393,   1026761026,   -207269610,   1364563521,   1578793454,    457809423,   -534138380,          -1052938788,  -1897101526,   1449976516,   2052800058,  -1145169719,   1476303269,    370625650,   -325249282,      2165984,   1631432802,   1032336355,  -1292978191,  -1810172401,    725725820,  -1162678778,    702624490,           1387673527,    981825943,   -556408212,  -1108487850,  -1782136935,   1582316425,  -1752682164,    307235003,   1386486299,  -1343636074,   1936875586,  -1265279891,   -345847069,    928241171,    239050350,   1859358526,           -664776217,   -823267892,    346651710,   -867656288,  -1907921425,   1362445801,    541145461,   -192727350,   1649366606,    244694627,   -488180018,    214008256,   2032125437,  -1678591993,   -264593820,   1309017286,           -652451998,   1845366657,   -703990120,   -550186406,   -630285276,   1782372955,   1650564210,  -1127904234,  -1407983860,  -1119422877,  -1565976361,  -1913545385,    549841420,  -1410323732,  -1964467146,    228296551,           -421026422,   1929094398,   -266906424,    264810315,  -2008122665,  -1088278148,    141242192,   1871293282,    234634067,   1724159838,   1638271051,   -837713428,   -657941661,    168093988,    708605363,  -1881612509,          -1810496006,   -193495322,   1889982309,  -2050702012,   -693694192,  -1249780322,    718733403,    -76349730,   -188217051,    920912090,  -1814078273,   2013358456,  -1948845521,   -198407575,  -1248904632,   1182772565,           1236791612,  -1297489171,  -1958468586,   1437011007,    390460941,    113068796,   1247982993,   2102889679,  -1563524844,   -128174212,   -754095070,  -1461699362,    943615640,  -1013270737,    221253920,   1514140013,           1596946745,    674222984,    616356702,   1811224435,  -1764322023,  -1653707581,  -1702404459,    390678142,   -209506765,  -1398278531,   -117061517,   1625861343,    659048069,  -1490678943,    846536668,    210715637,           1855458786,   1727745280,   1086729456,   1109111683,   -985298098,  -1813777567,   -954599702,  -1522494031,   1166103515,   -191868965,  -1048777852,   -661271058,   1161457421,   1509090409,   -919753558,   -155431193,          -1774302994,   -366390263,   2090138916,   -693431491,  -1693888428,   1846774454,    925855693,    474383470,    208889079,    382195164,   -283005634,  -2095134392,    579927985,   1390765326,  -1766119865,    900457129,          -1503703236,    974952690,   -107714111,    381338452,   1187256613,   -860560742,    524103620,   1499506130,    197755276,   -790802926,   -406920967,  -1972219791,   -665721155,   -113336203,   1037154436,  -1185441801,           -745541706,   -546274471,   1988928457,  -1975403782,  -1167172845,    777779004,  -1560935061,   -140258712,  -1243598232,  -1394149587,   -785002782,    311842991,  -1025469277,   -605350463,  -1251538057,    537203966,            597777961,  -1845767072,  -1556349193,  -1491015509,  -1935936671,   2093498487,   1908270236,   -315396187,   1356362300,  -2025658518,    630119678,    276190559,    510123398,  -1266145363,   -170152124,   -151540077,           -477900187,   1895894303,   1870333068,  -1169891437,    353366620,   2111175941,   1691245786,   1318765802,    -90993610,    921309517,    118241505,    367005284,   1624861072,   2010785894,    865255951,   1717799691,            -80757664,   -644944841,    136999836,   -341686875,  -1908076090,  -1968934200,   -346397811,   -184213520,   -511811333,  -2118173466,  -1086490399,   1795322855,   -635494328,    415716276,    851044432,   -904636831,          -1972230341,    -64337858,    571177016,   1248814747,  -1351030778,    457872680,   1843549954,   1718960038,    815088665,   1812961065,    360686952,  -1356586646,   1657802416,   1776192945,   -786723490,   -342254407,           -236653811,    771014701,    906386785,   -308057635,   1907957462,    206000440,    -42143480,    900403654,   -917549795,   -310520796,  -1713627766,   2061136240,   -377977839,    891282946,   -821163030,    328143584,           1503793080,    551621842,  -2086273683,  -2070526343,     91195293,  -1654389038,  -1035734266,   -336619597,  -1220221027,  -1468468844,   2105626873,   -841372573,   -122707018,  -2013073683,    494461000,  -2054807734,            -67946259,   1914163407,   1941835405,  -1027244745,   -768123277,    419129844,   -275750260,   -171533009,     97756174,    -17651409,  -1578102255,    995291430,  -1587462977,    692904675,    951632643,   1882101293,          -1546298756,   2018418068,  -1790777661,   1542305514,  -1437624383,    469587009,  -1647853474,  -1318279028,    497228822,    726733469,   1693133452,  -2091185798,   -209017732,    126386499,   1056958932,  -2105494133,            754067324,     96463951,     83701151,   1101658289,   1485852701,    553783806,   1898769881,  -1072031442,   1438062141,   1992540265,   1152252136,   1019391719,   -175951257,     -6691216,    989789689,    968359367,          -1330392786,   1704963399,   -998432914,   -948060232,  -1921688855,   -975840920,   1360273515,   -872810459,     12676907,  -1908050756,    883609616,     65641549,   -200365398,   1386653304,  -1203665071,   1878689007,            426262328,    315375145,   1900325181,    703658494,   -765404895,   1070155172,   1399748900,   -804264234,  -1619419026,   1347225486,    230635292,   1093717835,     14020583,  -2107039873,   -968325341,  -1679158691,           1959784097,   1065690797,   1090615161,   1311445364,    865835426,    870016646,    574122879,   1842697922,  -1289210431,  -1914001560,   1672467629,   -900366331,  -1524066872,    136503816,  -1910431892,  -1431958329,           -830367152,  -1316233970,   -801974860,   1560669382,    -81784810,    401822577,   -949103202,    943897151,   -722666726,    -96825841,  -1092898846,    230567004,    -70355840,  -1398069192,   -312953142,   1475420133,           -622491023,   1661205388,    -19071322,      6024591,   1473041593,   2053897978,  -1346768903,   1484764721,  -1552461890,   1287146711,   1613069307,    902497864,  -1504480063,    375292915,   -836353108,   2047602411        };        for (int i = 0; i < refInt.length; ++i) {            Assert.assertEquals(refInt[i], mt.nextInt());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.general;import java.awt.geom.Point2D;import java.io.Serializable;import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.analysis.MultivariateVectorialFunction;import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;import org.apache.commons.math.analysis.solvers.BrentSolver;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.optimization.RealPointValuePair;import org.apache.commons.math.optimization.SimpleScalarValueChecker;import org.junit.Assert;import org.junit.Test;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */public class NonLinearConjugateGradientOptimizerTest {    @Test    public void testTrivial() {        LinearProblem problem =            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,                                                    new SimpleScalarValueChecker(1e-6, 1e-6));        RealPointValuePair optimum =            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0 });        Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);        Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10);    }    @Test    public void testColumnsPermutation() {        LinearProblem problem =            new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },                              new double[] { 4.0, 6.0, 1.0 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,                                                    new SimpleScalarValueChecker(1e-6, 1e-6));        RealPointValuePair optimum =            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0 });        Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);        Assert.assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);        Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10);    }    @Test    public void testNoDependency() {        LinearProblem problem = new LinearProblem(new double[][] {                { 2, 0, 0, 0, 0, 0 },                { 0, 2, 0, 0, 0, 0 },                { 0, 0, 2, 0, 0, 0 },                { 0, 0, 0, 2, 0, 0 },                { 0, 0, 0, 0, 2, 0 },                { 0, 0, 0, 0, 0, 2 }        }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,                                                    new SimpleScalarValueChecker(1e-6, 1e-6));        RealPointValuePair optimum =            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });        for (int i = 0; i < problem.target.length; ++i) {            Assert.assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);        }    }    @Test    public void testOneSet() {        LinearProblem problem = new LinearProblem(new double[][] {                {  1,  0, 0 },                { -1,  1, 0 },                {  0, -1, 1 }        }, new double[] { 1, 1, 1});        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,                                                    new SimpleScalarValueChecker(1e-6, 1e-6));        RealPointValuePair optimum =            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });        Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);        Assert.assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);        Assert.assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);    }    @Test    public void testTwoSets() {        final double epsilon = 1.0e-7;        LinearProblem problem = new LinearProblem(new double[][] {                {  2,  1,   0,  4,       0, 0 },                { -4, -2,   3, -7,       0, 0 },                {  4,  1,  -2,  8,       0, 0 },                {  0, -3, -12, -1,       0, 0 },                {  0,  0,   0,  0, epsilon, 1 },                {  0,  0,   0,  0,       1, 1 }        }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});        final Preconditioner preconditioner            = new Preconditioner() {                    public double[] precondition(double[] point, double[] r) {                        double[] d = r.clone();                        d[0] /=  72.0;                        d[1] /=  30.0;                        d[2] /= 314.0;                        d[3] /= 260.0;                        d[4] /= 2 * (1 + epsilon * epsilon);                        d[5] /= 4.0;                        return d;                    }                };        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,                                                    new SimpleScalarValueChecker(1e-13, 1e-13),                                                    new BrentSolver(),                                                    preconditioner);                                                            RealPointValuePair optimum =            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });        Assert.assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);        Assert.assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);        Assert.assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);        Assert.assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);        Assert.assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);        Assert.assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);    }    @Test    public void testNonInversible() {        LinearProblem problem = new LinearProblem(new double[][] {                {  1, 2, -3 },                {  2, 1,  3 },                { -3, 0, -9 }        }, new double[] { 1, 1, 1 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,                                                    new SimpleScalarValueChecker(1e-6, 1e-6));        RealPointValuePair optimum =                optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });        Assert.assertTrue(optimum.getValue() > 0.5);    }    @Test    public void testIllConditioned() {        LinearProblem problem1 = new LinearProblem(new double[][] {                { 10.0, 7.0,  8.0,  7.0 },                {  7.0, 5.0,  6.0,  5.0 },                {  8.0, 6.0, 10.0,  9.0 },                {  7.0, 5.0,  9.0, 10.0 }        }, new double[] { 32, 23, 33, 31 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,                                                    new SimpleScalarValueChecker(1e-13, 1e-13),                                                    new BrentSolver(1e-15, 1e-15));        RealPointValuePair optimum1 =            optimizer.optimize(200, problem1, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });        Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-4);        Assert.assertEquals(1.0, optimum1.getPoint()[1], 1.0e-4);        Assert.assertEquals(1.0, optimum1.getPoint()[2], 1.0e-4);        Assert.assertEquals(1.0, optimum1.getPoint()[3], 1.0e-4);        LinearProblem problem2 = new LinearProblem(new double[][] {                { 10.00, 7.00, 8.10, 7.20 },                {  7.08, 5.04, 6.00, 5.00 },                {  8.00, 5.98, 9.89, 9.00 },                {  6.99, 4.99, 9.00, 9.98 }        }, new double[] { 32, 23, 33, 31 });        RealPointValuePair optimum2 =            optimizer.optimize(200, problem2, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });        Assert.assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-1);        Assert.assertEquals(137.0, optimum2.getPoint()[1], 1.0e-1);        Assert.assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-1);        Assert.assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-1);    }    @Test    public void testMoreEstimatedParametersSimple() {        LinearProblem problem = new LinearProblem(new double[][] {                { 3.0, 2.0,  0.0, 0.0 },                { 0.0, 1.0, -1.0, 1.0 },                { 2.0, 0.0,  1.0, 0.0 }        }, new double[] { 7.0, 3.0, 5.0 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,                                                    new SimpleScalarValueChecker(1e-6, 1e-6));        RealPointValuePair optimum =            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 7, 6, 5, 4 });        Assert.assertEquals(0, optimum.getValue(), 1.0e-10);    }    @Test    public void testMoreEstimatedParametersUnsorted() {        LinearProblem problem = new LinearProblem(new double[][] {                 { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },                 { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },                 { 0.0, 0.0,  0.0,  0.0, 1.0, -1.0 },                 { 0.0, 0.0, -1.0,  1.0, 0.0,  1.0 },                 { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }        }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,                                                    new SimpleScalarValueChecker(1e-6, 1e-6));        RealPointValuePair optimum =            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 2, 2, 2, 2, 2, 2 });        Assert.assertEquals(0, optimum.getValue(), 1.0e-10);    }    @Test    public void testRedundantEquations() {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 5.0 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,                                                    new SimpleScalarValueChecker(1e-6, 1e-6));        RealPointValuePair optimum =            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 1, 1 });        Assert.assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);        Assert.assertEquals(1.0, optimum.getPoint()[1], 1.0e-8);    }    @Test    public void testInconsistentEquations() {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 4.0 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,                                                    new SimpleScalarValueChecker(1e-6, 1e-6));        RealPointValuePair optimum =            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 1, 1 });        Assert.assertTrue(optimum.getValue() > 0.1);    }    @Test    public void testCircleFitting() {        CircleScalar circle = new CircleScalar();        circle.addPoint( 30.0,  68.0);        circle.addPoint( 50.0,  -6.0);        circle.addPoint(110.0, -20.0);        circle.addPoint( 35.0,  15.0);        circle.addPoint( 45.0,  97.0);        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,                                                    new SimpleScalarValueChecker(1e-30, 1e-30),                                                    new BrentSolver(1e-15, 1e-13));        RealPointValuePair optimum =            optimizer.optimize(100, circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);        Assert.assertEquals(69.960161753, circle.getRadius(center), 1.0e-8);        Assert.assertEquals(96.075902096, center.x, 1.0e-8);        Assert.assertEquals(48.135167894, center.y, 1.0e-8);    }    private static class LinearProblem implements DifferentiableMultivariateRealFunction, Serializable {        private static final long serialVersionUID = 703247177355019415L;        final RealMatrix factors;        final double[] target;        public LinearProblem(double[][] factors, double[] target) {            this.factors = new BlockRealMatrix(factors);            this.target  = target;        }        private double[] gradient(double[] point) {            double[] r = factors.operate(point);            for (int i = 0; i < r.length; ++i) {                r[i] -= target[i];            }            double[] p = factors.transpose().operate(r);            for (int i = 0; i < p.length; ++i) {                p[i] *= 2;            }            return p;        }        public double value(double[] variables) {            double[] y = factors.operate(variables);            double sum = 0;            for (int i = 0; i < y.length; ++i) {                double ri = y[i] - target[i];                sum += ri * ri;            }            return sum;        }        public MultivariateVectorialFunction gradient() {            return new MultivariateVectorialFunction() {                public double[] value(double[] point) {                    return gradient(point);                }            };        }        public MultivariateRealFunction partialDerivative(final int k) {            return new MultivariateRealFunction() {                public double value(double[] point) {                    return gradient(point)[k];                }            };        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.general;import java.awt.geom.Point2D;import java.io.Serializable;import java.util.Arrays;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.exception.ConvergenceException;import org.apache.commons.math.exception.TooManyEvaluationsException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;import org.apache.commons.math.analysis.MultivariateMatrixFunction;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.optimization.SimpleVectorialPointChecker;import org.apache.commons.math.optimization.SimpleVectorialValueChecker;import org.apache.commons.math.optimization.VectorialPointValuePair;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */public class GaussNewtonOptimizerTest {    @Test    public void testTrivial() throws MathUserException {        LinearProblem problem =            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });        GaussNewtonOptimizer optimizer            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);        Assert.assertEquals(3.0, optimum.getValue()[0], 1.0e-10);    }    @Test    public void testColumnsPermutation() throws MathUserException {        LinearProblem problem =            new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },                              new double[] { 4.0, 6.0, 1.0 });        GaussNewtonOptimizer optimizer            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);        Assert.assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);        Assert.assertEquals(4.0, optimum.getValue()[0], 1.0e-10);        Assert.assertEquals(6.0, optimum.getValue()[1], 1.0e-10);        Assert.assertEquals(1.0, optimum.getValue()[2], 1.0e-10);    }    @Test    public void testNoDependency() throws MathUserException {        LinearProblem problem = new LinearProblem(new double[][] {                { 2, 0, 0, 0, 0, 0 },                { 0, 2, 0, 0, 0, 0 },                { 0, 0, 2, 0, 0, 0 },                { 0, 0, 0, 2, 0, 0 },                { 0, 0, 0, 0, 2, 0 },                { 0, 0, 0, 0, 0, 2 }        }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });        GaussNewtonOptimizer optimizer            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },                               new double[] { 0, 0, 0, 0, 0, 0 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        for (int i = 0; i < problem.target.length; ++i) {            Assert.assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);        }    }    @Test    public void testOneSet() throws MathUserException {        LinearProblem problem = new LinearProblem(new double[][] {                {  1,  0, 0 },                { -1,  1, 0 },                {  0, -1, 1 }        }, new double[] { 1, 1, 1});        GaussNewtonOptimizer optimizer            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);        Assert.assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);        Assert.assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);    }    @Test    public void testTwoSets() throws MathUserException {        double epsilon = 1.0e-7;        LinearProblem problem = new LinearProblem(new double[][] {                {  2,  1,   0,  4,       0, 0 },                { -4, -2,   3, -7,       0, 0 },                {  4,  1,  -2,  8,       0, 0 },                {  0, -3, -12, -1,       0, 0 },                {  0,  0,   0,  0, epsilon, 1 },                {  0,  0,   0,  0,       1, 1 }        }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});        GaussNewtonOptimizer optimizer            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },                               new double[] { 0, 0, 0, 0, 0, 0 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        Assert.assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);        Assert.assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);        Assert.assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);        Assert.assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);        Assert.assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);        Assert.assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);    }    @Test(expected=ConvergenceException.class)    public void testNonInversible() throws Exception {        LinearProblem problem = new LinearProblem(new double[][] {                {  1, 2, -3 },                {  2, 1,  3 },                { -3, 0, -9 }        }, new double[] { 1, 1, 1 });        GaussNewtonOptimizer optimizer            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });    }    @Test    public void testIllConditioned() throws MathUserException {        LinearProblem problem1 = new LinearProblem(new double[][] {                { 10.0, 7.0,  8.0,  7.0 },                {  7.0, 5.0,  6.0,  5.0 },                {  8.0, 6.0, 10.0,  9.0 },                {  7.0, 5.0,  9.0, 10.0 }        }, new double[] { 32, 23, 33, 31 });        GaussNewtonOptimizer optimizer            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum1 =            optimizer.optimize(100, problem1, problem1.target, new double[] { 1, 1, 1, 1 },                               new double[] { 0, 1, 2, 3 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);        Assert.assertEquals(1.0, optimum1.getPoint()[1], 1.0e-10);        Assert.assertEquals(1.0, optimum1.getPoint()[2], 1.0e-10);        Assert.assertEquals(1.0, optimum1.getPoint()[3], 1.0e-10);        LinearProblem problem2 = new LinearProblem(new double[][] {                { 10.00, 7.00, 8.10, 7.20 },                {  7.08, 5.04, 6.00, 5.00 },                {  8.00, 5.98, 9.89, 9.00 },                {  6.99, 4.99, 9.00, 9.98 }        }, new double[] { 32, 23, 33, 31 });        VectorialPointValuePair optimum2 =            optimizer.optimize(100, problem2, problem2.target, new double[] { 1, 1, 1, 1 },                               new double[] { 0, 1, 2, 3 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        Assert.assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);        Assert.assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8);        Assert.assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8);        Assert.assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);    }    @Test(expected=ConvergenceException.class)    public void testMoreEstimatedParametersSimple() throws Exception {        LinearProblem problem = new LinearProblem(new double[][] {                { 3.0, 2.0,  0.0, 0.0 },                { 0.0, 1.0, -1.0, 1.0 },                { 2.0, 0.0,  1.0, 0.0 }        }, new double[] { 7.0, 3.0, 5.0 });        GaussNewtonOptimizer optimizer            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },                           new double[] { 7, 6, 5, 4 });    }    @Test(expected=ConvergenceException.class)    public void testMoreEstimatedParametersUnsorted() throws Exception {        LinearProblem problem = new LinearProblem(new double[][] {                 { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },                 { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },                 { 0.0, 0.0,  0.0,  0.0, 1.0, -1.0 },                 { 0.0, 0.0, -1.0,  1.0, 0.0,  1.0 },                 { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }        }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });        GaussNewtonOptimizer optimizer            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1 },                           new double[] { 2, 2, 2, 2, 2, 2 });    }    @Test    public void testRedundantEquations() throws MathUserException {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 5.0 });        GaussNewtonOptimizer optimizer            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },                               new double[] { 1, 1 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        Assert.assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);        Assert.assertEquals(1.0, optimum.getPoint()[1], 1.0e-8);    }    @Test    public void testInconsistentEquations() throws MathUserException {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 4.0 });        GaussNewtonOptimizer optimizer            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });        Assert.assertTrue(optimizer.getRMS() > 0.1);    }    @Test(expected=DimensionMismatchException.class)    public void testInconsistentSizes1() throws MathUserException {        LinearProblem problem =            new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });        GaussNewtonOptimizer optimizer            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        Assert.assertEquals(-1, optimum.getPoint()[0], 1.0e-10);        Assert.assertEquals(+1, optimum.getPoint()[1], 1.0e-10);        optimizer.optimize(100, problem, problem.target,                           new double[] { 1 },                           new double[] { 0, 0 });    }    @Test(expected=DimensionMismatchException.class)    public void testInconsistentSizes2() throws MathUserException {        LinearProblem problem =            new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });        GaussNewtonOptimizer optimizer            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        Assert.assertEquals(-1, optimum.getPoint()[0], 1.0e-10);        Assert.assertEquals(+1, optimum.getPoint()[1], 1.0e-10);        optimizer.optimize(100, problem, new double[] { 1 },                           new double[] { 1 },                           new double[] { 0, 0 });    }    @Test(expected=TooManyEvaluationsException.class)    public void testMaxEvaluations() throws Exception {        CircleVectorial circle = new CircleVectorial();        circle.addPoint( 30.0,  68.0);        circle.addPoint( 50.0,  -6.0);        circle.addPoint(110.0, -20.0);        circle.addPoint( 35.0,  15.0);        circle.addPoint( 45.0,  97.0);        GaussNewtonOptimizer optimizer            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-30, 1.0e-30));        optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 },                           new double[] { 1, 1, 1, 1, 1 },                           new double[] { 98.680, 47.345 });    }    @Test    public void testCircleFitting() throws MathUserException {        CircleVectorial circle = new CircleVectorial();        circle.addPoint( 30.0,  68.0);        circle.addPoint( 50.0,  -6.0);        circle.addPoint(110.0, -20.0);        circle.addPoint( 35.0,  15.0);        circle.addPoint( 45.0,  97.0);        GaussNewtonOptimizer optimizer            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-13, 1.0e-13));        VectorialPointValuePair optimum =            optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 },                               new double[] { 1, 1, 1, 1, 1 },                               new double[] { 98.680, 47.345 });        Assert.assertEquals(1.768262623567235,  FastMath.sqrt(circle.getN()) * optimizer.getRMS(),  1.0e-10);        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);        Assert.assertEquals(69.96016175359975, circle.getRadius(center), 1.0e-10);        Assert.assertEquals(96.07590209601095, center.x, 1.0e-10);        Assert.assertEquals(48.135167894714,   center.y, 1.0e-10);    }    @Test(expected=ConvergenceException.class)    public void testCircleFittingBadInit() throws MathUserException {        CircleVectorial circle = new CircleVectorial();        double[][] points = circlePoints;        double[] target = new double[points.length];        Arrays.fill(target, 0.0);        double[] weights = new double[points.length];        Arrays.fill(weights, 2.0);        for (int i = 0; i < points.length; ++i) {            circle.addPoint(points[i][0], points[i][1]);        }        GaussNewtonOptimizer optimizer            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        optimizer.optimize(100, circle, target, weights, new double[] { -12, -12 });    }    @Test    public void testCircleFittingGoodInit() throws MathUserException {        CircleVectorial circle = new CircleVectorial();        double[][] points = circlePoints;        double[] target = new double[points.length];        Arrays.fill(target, 0.0);        double[] weights = new double[points.length];        Arrays.fill(weights, 2.0);        for (int i = 0; i < points.length; ++i) {            circle.addPoint(points[i][0], points[i][1]);        }        GaussNewtonOptimizer optimizer            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(100, circle, target, weights, new double[] { 0, 0 });        Assert.assertEquals(-0.1517383071957963, optimum.getPointRef()[0], 1.0e-6);        Assert.assertEquals(0.2074999736353867,  optimum.getPointRef()[1], 1.0e-6);        Assert.assertEquals(0.04268731682389561, optimizer.getRMS(),       1.0e-8);    }    private static class LinearProblem implements DifferentiableMultivariateVectorialFunction, Serializable {        private static final long serialVersionUID = -8804268799379350190L;        final RealMatrix factors;        final double[] target;        public LinearProblem(double[][] factors, double[] target) {            this.factors = new BlockRealMatrix(factors);            this.target  = target;        }        public double[] value(double[] variables) {            return factors.operate(variables);        }        public MultivariateMatrixFunction jacobian() {            return new MultivariateMatrixFunction() {                public double[][] value(double[] point) {                    return factors.getData();                }            };        }    }    private final double[][] circlePoints = new double[][] {        {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},        {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},        {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},        {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},        { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},        { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},        {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},        {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},        {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},        {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},        {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},        { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},        { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},        {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},        {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},        {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},        {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},        {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},        { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},        { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},        { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},        {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},        {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},        {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},        {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},        {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},        { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},        { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},        {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}    };}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.general;import java.awt.geom.Point2D;import java.io.Serializable;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import org.apache.commons.math.exception.ConvergenceException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.TooManyEvaluationsException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;import org.apache.commons.math.analysis.MultivariateMatrixFunction;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.SingularMatrixException;import org.apache.commons.math.optimization.SimpleVectorialValueChecker;import org.apache.commons.math.optimization.VectorialPointValuePair;import org.apache.commons.math.util.MathUtils;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */public class LevenbergMarquardtOptimizerTest {    @Test    public void testTrivial() {        LinearProblem problem =            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        try {            optimizer.guessParametersErrors();            Assert.fail("an exception should have been thrown");        } catch (NumberIsTooSmallException ee) {            // expected behavior        }        Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);        Assert.assertEquals(3.0, optimum.getValue()[0], 1.0e-10);    }    @Test    public void testQRColumnsPermutation() {        LinearProblem problem =            new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },                              new double[] { 4.0, 6.0, 1.0 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);        Assert.assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);        Assert.assertEquals(4.0, optimum.getValue()[0], 1.0e-10);        Assert.assertEquals(6.0, optimum.getValue()[1], 1.0e-10);        Assert.assertEquals(1.0, optimum.getValue()[2], 1.0e-10);    }    @Test    public void testNoDependency() {        LinearProblem problem = new LinearProblem(new double[][] {                { 2, 0, 0, 0, 0, 0 },                { 0, 2, 0, 0, 0, 0 },                { 0, 0, 2, 0, 0, 0 },                { 0, 0, 0, 2, 0, 0 },                { 0, 0, 0, 0, 2, 0 },                { 0, 0, 0, 0, 0, 2 }        }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },                               new double[] { 0, 0, 0, 0, 0, 0 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        for (int i = 0; i < problem.target.length; ++i) {            Assert.assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);        }    }    @Test    public void testOneSet() {        LinearProblem problem = new LinearProblem(new double[][] {                {  1,  0, 0 },                { -1,  1, 0 },                {  0, -1, 1 }        }, new double[] { 1, 1, 1});        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);        Assert.assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);        Assert.assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);    }    @Test    public void testTwoSets() {        double epsilon = 1.0e-7;        LinearProblem problem = new LinearProblem(new double[][] {                {  2,  1,   0,  4,       0, 0 },                { -4, -2,   3, -7,       0, 0 },                {  4,  1,  -2,  8,       0, 0 },                {  0, -3, -12, -1,       0, 0 },                {  0,  0,   0,  0, epsilon, 1 },                {  0,  0,   0,  0,       1, 1 }        }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },                               new double[] { 0, 0, 0, 0, 0, 0 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        Assert.assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);        Assert.assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);        Assert.assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);        Assert.assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);        Assert.assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);        Assert.assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);    }    @Test    public void testNonInvertible() {        LinearProblem problem = new LinearProblem(new double[][] {                {  1, 2, -3 },                {  2, 1,  3 },                { -3, 0, -9 }        }, new double[] { 1, 1, 1 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });        Assert.assertTrue(FastMath.sqrt(problem.target.length) * optimizer.getRMS() > 0.6);        try {            optimizer.getCovariances();            Assert.fail("an exception should have been thrown");        } catch (SingularMatrixException ee) {            // expected behavior        }    }    @Test    public void testIllConditioned() {        LinearProblem problem1 = new LinearProblem(new double[][] {                { 10.0, 7.0,  8.0,  7.0 },                {  7.0, 5.0,  6.0,  5.0 },                {  8.0, 6.0, 10.0,  9.0 },                {  7.0, 5.0,  9.0, 10.0 }        }, new double[] { 32, 23, 33, 31 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum1 =            optimizer.optimize(100, problem1, problem1.target, new double[] { 1, 1, 1, 1 },                               new double[] { 0, 1, 2, 3 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);        Assert.assertEquals(1.0, optimum1.getPoint()[1], 1.0e-10);        Assert.assertEquals(1.0, optimum1.getPoint()[2], 1.0e-10);        Assert.assertEquals(1.0, optimum1.getPoint()[3], 1.0e-10);        LinearProblem problem2 = new LinearProblem(new double[][] {                { 10.00, 7.00, 8.10, 7.20 },                {  7.08, 5.04, 6.00, 5.00 },                {  8.00, 5.98, 9.89, 9.00 },                {  6.99, 4.99, 9.00, 9.98 }        }, new double[] { 32, 23, 33, 31 });        VectorialPointValuePair optimum2 =            optimizer.optimize(100, problem2, problem2.target, new double[] { 1, 1, 1, 1 },                               new double[] { 0, 1, 2, 3 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        Assert.assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);        Assert.assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8);        Assert.assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8);        Assert.assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);    }    @Test    public void testMoreEstimatedParametersSimple() {        LinearProblem problem = new LinearProblem(new double[][] {                { 3.0, 2.0,  0.0, 0.0 },                { 0.0, 1.0, -1.0, 1.0 },                { 2.0, 0.0,  1.0, 0.0 }        }, new double[] { 7.0, 3.0, 5.0 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },                new double[] { 7, 6, 5, 4 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);    }    @Test    public void testMoreEstimatedParametersUnsorted() {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },                { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },                { 0.0, 0.0,  0.0,  0.0, 1.0, -1.0 },                { 0.0, 0.0, -1.0,  1.0, 0.0,  1.0 },                { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }       }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1 },                               new double[] { 2, 2, 2, 2, 2, 2 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        Assert.assertEquals(3.0, optimum.getPointRef()[2], 1.0e-10);        Assert.assertEquals(4.0, optimum.getPointRef()[3], 1.0e-10);        Assert.assertEquals(5.0, optimum.getPointRef()[4], 1.0e-10);        Assert.assertEquals(6.0, optimum.getPointRef()[5], 1.0e-10);    }    @Test    public void testRedundantEquations() {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 5.0 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },                               new double[] { 1, 1 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        Assert.assertEquals(2.0, optimum.getPointRef()[0], 1.0e-10);        Assert.assertEquals(1.0, optimum.getPointRef()[1], 1.0e-10);    }    @Test    public void testInconsistentEquations() {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 4.0 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });        Assert.assertTrue(optimizer.getRMS() > 0.1);    }    @Test    public void testInconsistentSizes() {        LinearProblem problem =            new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });        Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10);        Assert.assertEquals(-1, optimum.getPoint()[0], 1.0e-10);        Assert.assertEquals(+1, optimum.getPoint()[1], 1.0e-10);        try {            optimizer.optimize(100, problem, problem.target,                               new double[] { 1 },                               new double[] { 0, 0 });            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException oe) {            // expected behavior        }        try {            optimizer.optimize(100, problem, new double[] { 1 },                               new double[] { 1 },                               new double[] { 0, 0 });            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException oe) {            // expected behavior        }    }    @Test    public void testControlParameters() {        CircleVectorial circle = new CircleVectorial();        circle.addPoint( 30.0,  68.0);        circle.addPoint( 50.0,  -6.0);        circle.addPoint(110.0, -20.0);        circle.addPoint( 35.0,  15.0);        circle.addPoint( 45.0,  97.0);        checkEstimate(circle, 0.1, 10, 1.0e-14, 1.0e-16, 1.0e-10, false);        checkEstimate(circle, 0.1, 10, 1.0e-15, 1.0e-17, 1.0e-10, true);        checkEstimate(circle, 0.1,  5, 1.0e-15, 1.0e-16, 1.0e-10, true);        circle.addPoint(300, -300);        checkEstimate(circle, 0.1, 20, 1.0e-18, 1.0e-16, 1.0e-10, true);    }    private void checkEstimate(DifferentiableMultivariateVectorialFunction problem,                               double initialStepBoundFactor, int maxCostEval,                               double costRelativeTolerance, double parRelativeTolerance,                               double orthoTolerance, boolean shouldFail) {        try {            LevenbergMarquardtOptimizer optimizer                = new LevenbergMarquardtOptimizer(initialStepBoundFactor,                                                  costRelativeTolerance,                                                  parRelativeTolerance,                                                  orthoTolerance,                                                  MathUtils.SAFE_MIN);            optimizer.optimize(maxCostEval, problem, new double[] { 0, 0, 0, 0, 0 },                               new double[] { 1, 1, 1, 1, 1 },                               new double[] { 98.680, 47.345 });            Assert.assertTrue(!shouldFail);        } catch (DimensionMismatchException ee) {            Assert.assertTrue(shouldFail);        } catch (TooManyEvaluationsException ee) {            Assert.assertTrue(shouldFail);        }    }    @Test    public void testCircleFitting() {        CircleVectorial circle = new CircleVectorial();        circle.addPoint( 30.0,  68.0);        circle.addPoint( 50.0,  -6.0);        circle.addPoint(110.0, -20.0);        circle.addPoint( 35.0,  15.0);        circle.addPoint( 45.0,  97.0);        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },                               new double[] { 98.680, 47.345 });        Assert.assertTrue(optimizer.getEvaluations() < 10);        Assert.assertTrue(optimizer.getJacobianEvaluations() < 10);        double rms = optimizer.getRMS();        Assert.assertEquals(1.768262623567235,  FastMath.sqrt(circle.getN()) * rms,  1.0e-10);        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);        Assert.assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);        Assert.assertEquals(96.07590211815305, center.x,      1.0e-10);        Assert.assertEquals(48.13516790438953, center.y,      1.0e-10);        double[][] cov = optimizer.getCovariances();        Assert.assertEquals(1.839, cov[0][0], 0.001);        Assert.assertEquals(0.731, cov[0][1], 0.001);        Assert.assertEquals(cov[0][1], cov[1][0], 1.0e-14);        Assert.assertEquals(0.786, cov[1][1], 0.001);        double[] errors = optimizer.guessParametersErrors();        Assert.assertEquals(1.384, errors[0], 0.001);        Assert.assertEquals(0.905, errors[1], 0.001);        // add perfect measurements and check errors are reduced        double  r = circle.getRadius(center);        for (double d= 0; d < 2 * FastMath.PI; d += 0.01) {            circle.addPoint(center.x + r * FastMath.cos(d), center.y + r * FastMath.sin(d));        }        double[] target = new double[circle.getN()];        Arrays.fill(target, 0.0);        double[] weights = new double[circle.getN()];        Arrays.fill(weights, 2.0);        optimizer.optimize(100, circle, target, weights, new double[] { 98.680, 47.345 });        cov = optimizer.getCovariances();        Assert.assertEquals(0.0016, cov[0][0], 0.001);        Assert.assertEquals(3.2e-7, cov[0][1], 1.0e-9);        Assert.assertEquals(cov[0][1], cov[1][0], 1.0e-14);        Assert.assertEquals(0.0016, cov[1][1], 0.001);        errors = optimizer.guessParametersErrors();        Assert.assertEquals(0.004, errors[0], 0.001);        Assert.assertEquals(0.004, errors[1], 0.001);    }    @Test    public void testCircleFittingBadInit() {        CircleVectorial circle = new CircleVectorial();        double[][] points = new double[][] {                {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},                {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},                {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},                {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},                { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},                { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},                {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},                {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},                {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},                {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},                {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},                { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},                { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},                {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},                {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},                {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},                {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},                {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},                { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},                { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},                { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},                {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},                {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},                {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},                {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},                {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},                { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},                { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},                {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}        };        double[] target = new double[points.length];        Arrays.fill(target, 0.0);        double[] weights = new double[points.length];        Arrays.fill(weights, 2.0);        for (int i = 0; i < points.length; ++i) {            circle.addPoint(points[i][0], points[i][1]);        }        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-8, 1.0e-8));        VectorialPointValuePair optimum =            optimizer.optimize(100, circle, target, weights, new double[] { -12, -12 });        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);        Assert.assertTrue(optimizer.getEvaluations() < 25);        Assert.assertTrue(optimizer.getJacobianEvaluations() < 20);        Assert.assertEquals( 0.043, optimizer.getRMS(), 1.0e-3);        Assert.assertEquals( 0.292235,  circle.getRadius(center), 1.0e-6);        Assert.assertEquals(-0.151738,  center.x,      1.0e-6);        Assert.assertEquals( 0.2075001, center.y,      1.0e-6);    }    @Test    public void testMath199() {        try {            QuadraticProblem problem = new QuadraticProblem();            problem.addPoint (0, -3.182591015485607);            problem.addPoint (1, -2.5581184967730577);            problem.addPoint (2, -2.1488478161387325);            problem.addPoint (3, -1.9122489313410047);            problem.addPoint (4, 1.7785661310051026);            LevenbergMarquardtOptimizer optimizer                = new LevenbergMarquardtOptimizer(100, 1e-10, 1e-10, 1e-10, 0);            optimizer.optimize(100, problem,                               new double[] { 0, 0, 0, 0, 0 },                               new double[] { 0.0, 4.4e-323, 1.0, 4.4e-323, 0.0 },                               new double[] { 0, 0, 0 });            Assert.fail("an exception should have been thrown");        } catch (ConvergenceException ee) {            // expected behavior        }    }    private static class LinearProblem implements DifferentiableMultivariateVectorialFunction, Serializable {        private static final long serialVersionUID = 703247177355019415L;        final RealMatrix factors;        final double[] target;        public LinearProblem(double[][] factors, double[] target) {            this.factors = new BlockRealMatrix(factors);            this.target  = target;        }        public double[] value(double[] variables) {            return factors.operate(variables);        }        public MultivariateMatrixFunction jacobian() {            return new MultivariateMatrixFunction() {                public double[][] value(double[] point) {                    return factors.getData();                }            };        }    }    private static class QuadraticProblem implements DifferentiableMultivariateVectorialFunction, Serializable {        private static final long serialVersionUID = 7072187082052755854L;        private List<Double> x;        private List<Double> y;        public QuadraticProblem() {            x = new ArrayList<Double>();            y = new ArrayList<Double>();        }        public void addPoint(double x, double y) {            this.x.add(x);            this.y.add(y);        }        private double[][] jacobian(double[] variables) {            double[][] jacobian = new double[x.size()][3];            for (int i = 0; i < jacobian.length; ++i) {                jacobian[i][0] = x.get(i) * x.get(i);                jacobian[i][1] = x.get(i);                jacobian[i][2] = 1.0;            }            return jacobian;        }        public double[] value(double[] variables) {            double[] values = new double[x.size()];            for (int i = 0; i < values.length; ++i) {                values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];            }            return values;        }        public MultivariateMatrixFunction jacobian() {            return new MultivariateMatrixFunction() {                public double[][] value(double[] point) {                    return jacobian(point);                }            };        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.general;import java.io.Serializable;import java.util.Arrays;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.exception.TooManyEvaluationsException;import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;import org.apache.commons.math.analysis.MultivariateMatrixFunction;import org.apache.commons.math.optimization.VectorialPointValuePair;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */public class MinpackTest {  @Test  public void testMinpackLinearFullRank() {    minpackTest(new LinearFullRankFunction(10, 5, 1.0,                                           5.0, 2.23606797749979), false);    minpackTest(new LinearFullRankFunction(50, 5, 1.0,                                           8.06225774829855, 6.70820393249937), false);  }  @Test  public void testMinpackLinearRank1() {    minpackTest(new LinearRank1Function(10, 5, 1.0,                                        291.521868819476, 1.4638501094228), false);    minpackTest(new LinearRank1Function(50, 5, 1.0,                                        3101.60039334535, 3.48263016573496), false);  }  @Test  public void testMinpackLinearRank1ZeroColsAndRows() {    minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false);    minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false);  }  @Test  public void testMinpackRosenbrok() {    minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },                                       FastMath.sqrt(24.2)), false);    minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 },                                       FastMath.sqrt(1795769.0)), false);    minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 },                                       11.0 * FastMath.sqrt(169000121.0)), false);  }  @Test  public void testMinpackHelicalValley() {    minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 },                                          50.0), false);    minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 },                                          102.95630140987), false);    minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0},                                          991.261822123701), false);  }  @Test  public void testMinpackPowellSingular() {    minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },                                           14.6628782986152), false);    minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 },                                           1270.9838708654), false);    minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 },                                           126887.903284750), false);  }  @Test  public void testMinpackFreudensteinRoth() {    minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },                                             20.0124960961895, 6.99887517584575,                                             new double[] {                                               11.4124844654993,                                               -0.896827913731509                                             }), false);    minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },                                             12432.833948863, 6.9988751744895,                                             new double[] {                                                11.41300466147456,                                                -0.896796038685959                                             }), false);    minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },                                             11426454.595762, 6.99887517242903,                                             new double[] {                                                 11.412781785788564,                                                 -0.8968051074920405                                             }), false);  }  @Test  public void testMinpackBard() {    minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,                                 new double[] {                                   0.0824105765758334,                                   1.1330366534715,                                   2.34369463894115                                 }), false);    minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539,                                 new double[] {                                   0.840666673818329,                                   -158848033.259565,                                   -164378671.653535                                 }), false);    minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969,                                 new double[] {                                   0.840666673867645,                                   -158946167.205518,                                   -164464906.857771                                 }), false);  }  @Test  public void testMinpackKowalikOsborne() {    minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },                                           0.0728915102882945,                                           0.017535837721129,                                           new double[] {                                             0.192807810476249,                                             0.191262653354071,                                             0.123052801046931,                                             0.136053221150517                                           }), false);    minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 },                                           2.97937007555202,                                           0.032052192917937,                                           new double[] {                                             728675.473768287,                                             -14.0758803129393,                                             -32977797.7841797,                                             -20571594.1977912                                           }), false);    minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 },                                           29.9590617016037,                                           0.0175364017658228,                                           new double[] {                                             0.192948328597594,                                             0.188053165007911,                                             0.122430604321144,                                             0.134575665392506                                           }), false);  }  @Test  public void testMinpackMeyer() {    minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },                                  41153.4665543031, 9.37794514651874,                                  new double[] {                                    0.00560963647102661,                                    6181.34634628659,                                    345.223634624144                                  }), false);    minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 },                                  4168216.89130846, 792.917871779501,                                  new double[] {                                    1.42367074157994e-11,                                    33695.7133432541,                                    901.268527953801                                  }), true);  }  @Test  public void testMinpackWatson() {    minpackTest(new WatsonFunction(6, 0.0,                                   5.47722557505166, 0.0478295939097601,                                   new double[] {                                     -0.0157249615083782, 1.01243488232965,                                     -0.232991722387673,  1.26043101102818,                                     -1.51373031394421,   0.99299727291842                                   }), false);    minpackTest(new WatsonFunction(6, 10.0,                                   6433.12578950026, 0.0478295939096951,                                   new double[] {                                     -0.0157251901386677, 1.01243485860105,                                     -0.232991545843829,  1.26042932089163,                                     -1.51372776706575,   0.99299573426328                                   }), false);    minpackTest(new WatsonFunction(6, 100.0,                                   674256.040605213, 0.047829593911544,                                   new double[] {                                    -0.0157247019712586, 1.01243490925658,                                    -0.232991922761641,  1.26043292929555,                                    -1.51373320452707,   0.99299901922322                                   }), false);    minpackTest(new WatsonFunction(9, 0.0,                                   5.47722557505166, 0.00118311459212420,                                   new double[] {                                    -0.153070644166722e-4, 0.999789703934597,                                     0.0147639634910978,   0.146342330145992,                                     1.00082109454817,    -2.61773112070507,                                     4.10440313943354,    -3.14361226236241,                                     1.05262640378759                                   }), false);    minpackTest(new WatsonFunction(9, 10.0,                                   12088.127069307, 0.00118311459212513,                                   new double[] {                                   -0.153071334849279e-4, 0.999789703941234,                                    0.0147639629786217,   0.146342334818836,                                    1.00082107321386,    -2.61773107084722,                                    4.10440307655564,    -3.14361222178686,                                    1.05262639322589                                   }), false);    minpackTest(new WatsonFunction(9, 100.0,                                   1269109.29043834, 0.00118311459212384,                                   new double[] {                                    -0.153069523352176e-4, 0.999789703958371,                                     0.0147639625185392,   0.146342341096326,                                     1.00082104729164,    -2.61773101573645,                                     4.10440301427286,    -3.14361218602503,                                     1.05262638516774                                   }), false);    minpackTest(new WatsonFunction(12, 0.0,                                   5.47722557505166, 0.217310402535861e-4,                                   new double[] {                                    -0.660266001396382e-8, 1.00000164411833,                                    -0.000563932146980154, 0.347820540050756,                                    -0.156731500244233,    1.05281515825593,                                    -3.24727109519451,     7.2884347837505,                                   -10.271848098614,       9.07411353715783,                                    -4.54137541918194,     1.01201187975044                                   }), false);    minpackTest(new WatsonFunction(12, 10.0,                                   19220.7589790951, 0.217310402518509e-4,                                   new double[] {                                    -0.663710223017410e-8, 1.00000164411787,                                    -0.000563932208347327, 0.347820540486998,                                    -0.156731503955652,    1.05281517654573,                                    -3.2472711515214,      7.28843489430665,                                   -10.2718482369638,      9.07411364383733,                                    -4.54137546533666,     1.01201188830857                                   }), false);    minpackTest(new WatsonFunction(12, 100.0,                                   2018918.04462367, 0.217310402539845e-4,                                   new double[] {                                    -0.663806046485249e-8, 1.00000164411786,                                    -0.000563932210324959, 0.347820540503588,                                    -0.156731504091375,    1.05281517718031,                                    -3.24727115337025,     7.28843489775302,                                   -10.2718482410813,      9.07411364688464,                                    -4.54137546660822,     1.0120118885369                                   }), false);  }  @Test  public void testMinpackBox3Dimensional() {    minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },                                            32.1115837449572), false);  }  @Test  public void testMinpackJennrichSampson() {    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },                                            64.5856498144943, 11.1517793413499,                                            new double[] { //                                            0.2578330049, 0.257829976764542                                               0.2578199266368004, 0.25782997676455244                                            }), false);  }  @Test  public void testMinpackBrownDennis() {    minpackTest(new BrownDennisFunction(20,                                        new double[] { 25.0, 5.0, -5.0, -1.0 },                                        2815.43839161816, 292.954288244866,                                        new double[] {                                         -11.59125141003, 13.2024883984741,                                         -0.403574643314272, 0.236736269844604                                        }), false);    minpackTest(new BrownDennisFunction(20,                                        new double[] { 250.0, 50.0, -50.0, -10.0 },                                        555073.354173069, 292.954270581415,                                        new double[] {                                         -11.5959274272203, 13.2041866926242,                                         -0.403417362841545, 0.236771143410386                                       }), false);    minpackTest(new BrownDennisFunction(20,                                        new double[] { 2500.0, 500.0, -500.0, -100.0 },                                        61211252.2338581, 292.954306151134,                                        new double[] {                                         -11.5902596937374, 13.2020628854665,                                         -0.403688070279258, 0.236665033746463                                        }), false);  }  @Test  public void testMinpackChebyquad() {    minpackTest(new ChebyquadFunction(1, 8, 1.0,                                      1.88623796907732, 1.88623796907732,                                      new double[] { 0.5 }), false);    minpackTest(new ChebyquadFunction(1, 8, 10.0,                                      5383344372.34005, 1.88424820499951,                                      new double[] { 0.9817314924684 }), false);    minpackTest(new ChebyquadFunction(1, 8, 100.0,                                      0.118088726698392e19, 1.88424820499347,                                      new double[] { 0.9817314852934 }), false);    minpackTest(new ChebyquadFunction(8, 8, 1.0,                                      0.196513862833975, 0.0593032355046727,                                      new double[] {                                        0.0431536648587336, 0.193091637843267,                                        0.266328593812698,  0.499999334628884,                                        0.500000665371116,  0.733671406187302,                                        0.806908362156733,  0.956846335141266                                      }), false);    minpackTest(new ChebyquadFunction(9, 9, 1.0,                                      0.16994993465202, 0.0,                                      new double[] {                                        0.0442053461357828, 0.199490672309881,                                        0.23561910847106,   0.416046907892598,                                        0.5,                0.583953092107402,                                        0.764380891528940,  0.800509327690119,                                        0.955794653864217                                      }), false);    minpackTest(new ChebyquadFunction(10, 10, 1.0,                                      0.183747831178711, 0.0806471004038253,                                      new double[] {                                        0.0596202671753563, 0.166708783805937,                                        0.239171018813509,  0.398885290346268,                                        0.398883667870681,  0.601116332129320,                                        0.60111470965373,   0.760828981186491,                                        0.833291216194063,  0.940379732824644                                      }), false);  }  @Test  public void testMinpackBrownAlmostLinear() {    minpackTest(new BrownAlmostLinearFunction(10, 0.5,                                              16.5302162063499, 0.0,                                              new double[] {                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 1.20569696650138                                              }), false);    minpackTest(new BrownAlmostLinearFunction(10, 5.0,                                              9765624.00089211, 0.0,                                              new double[] {                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 1.20569696650135                                              }), false);    minpackTest(new BrownAlmostLinearFunction(10, 50.0,                                              0.9765625e17, 0.0,                                              new double[] {                                                1.0, 1.0, 1.0, 1.0, 1.0,                                                1.0, 1.0, 1.0, 1.0, 1.0                                              }), false);    minpackTest(new BrownAlmostLinearFunction(30, 0.5,                                              83.476044467848, 0.0,                                              new double[] {                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 1.06737350671578                                              }), false);    minpackTest(new BrownAlmostLinearFunction(40, 0.5,                                              128.026364472323, 0.0,                                              new double[] {                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                0.999999999999121                                              }), false);    }  @Test  public void testMinpackOsborne1() {      minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },                                       0.937564021037838, 0.00739249260904843,                                       new double[] {                                         0.375410049244025, 1.93584654543108,                                        -1.46468676748716, 0.0128675339110439,                                         0.0221227011813076                                       }), false);    }  @Test  public void testMinpackOsborne2() {    minpackTest(new Osborne2Function(new double[] {                                       1.3, 0.65, 0.65, 0.7, 0.6,                                       3.0, 5.0, 7.0, 2.0, 4.5, 5.5                                     },                                     1.44686540984712, 0.20034404483314,                                     new double[] {                                       1.30997663810096,  0.43155248076,                                       0.633661261602859, 0.599428560991695,                                       0.754179768272449, 0.904300082378518,                                       1.36579949521007, 4.82373199748107,                                       2.39868475104871, 4.56887554791452,                                       5.67534206273052                                     }), false);  }  private void minpackTest(MinpackFunction function, boolean exceptionExpected) {      LevenbergMarquardtOptimizer optimizer          = new LevenbergMarquardtOptimizer(FastMath.sqrt(2.22044604926e-16),                                            FastMath.sqrt(2.22044604926e-16),                                            2.22044604926e-16);//      Assert.assertTrue(function.checkTheoreticalStartCost(optimizer.getRMS()));      try {          VectorialPointValuePair optimum =              optimizer.optimize(400 * (function.getN() + 1), function,                                 function.getTarget(), function.getWeight(),                                 function.getStartPoint());          Assert.assertFalse(exceptionExpected);          function.checkTheoreticalMinCost(optimizer.getRMS());          function.checkTheoreticalMinParams(optimum);      } catch (TooManyEvaluationsException e) {          Assert.assertTrue(exceptionExpected);      } catch (MathUserException fe) {          Assert.assertTrue(exceptionExpected);      }  }  private static abstract class MinpackFunction      implements DifferentiableMultivariateVectorialFunction, Serializable {      private static final long serialVersionUID = -6209760235478794233L;      protected int      n;      protected int      m;      protected double[] startParams;      protected double   theoreticalMinCost;      protected double[] theoreticalMinParams;      protected double   costAccuracy;      protected double   paramsAccuracy;      protected MinpackFunction(int m, double[] startParams,                                double theoreticalMinCost, double[] theoreticalMinParams) {          this.m = m;          this.n = startParams.length;          this.startParams          = startParams.clone();          this.theoreticalMinCost   = theoreticalMinCost;          this.theoreticalMinParams = theoreticalMinParams;          this.costAccuracy         = 1.0e-8;          this.paramsAccuracy       = 1.0e-5;      }      protected static double[] buildArray(int n, double x) {          double[] array = new double[n];          Arrays.fill(array, x);          return array;      }      public double[] getTarget() {          return buildArray(m, 0.0);      }      public double[] getWeight() {          return buildArray(m, 1.0);      }      public double[] getStartPoint() {          return startParams.clone();      }      protected void setCostAccuracy(double costAccuracy) {          this.costAccuracy = costAccuracy;      }      protected void setParamsAccuracy(double paramsAccuracy) {          this.paramsAccuracy = paramsAccuracy;      }      public int getN() {          return startParams.length;      }      public void checkTheoreticalMinCost(double rms) {          double threshold = costAccuracy * (1.0 + theoreticalMinCost);          Assert.assertEquals(theoreticalMinCost, FastMath.sqrt(m) * rms, threshold);      }      public void checkTheoreticalMinParams(VectorialPointValuePair optimum) {          double[] params = optimum.getPointRef();          if (theoreticalMinParams != null) {              for (int i = 0; i < theoreticalMinParams.length; ++i) {                  double mi = theoreticalMinParams[i];                  double vi = params[i];                  Assert.assertEquals(mi, vi, paramsAccuracy * (1.0 + FastMath.abs(mi)));              }          }      }      public MultivariateMatrixFunction jacobian() {          return new MultivariateMatrixFunction() {            public double[][] value(double[] point) {                  return jacobian(point);              }          };      }      public abstract double[][] jacobian(double[] variables);      public abstract double[] value(double[] variables);  }  private static class LinearFullRankFunction extends MinpackFunction {    private static final long serialVersionUID = -9030323226268039536L;    public LinearFullRankFunction(int m, int n, double x0,                                  double theoreticalStartCost,                                  double theoreticalMinCost) {      super(m, buildArray(n, x0), theoreticalMinCost,            buildArray(n, -1.0));    }    @Override    public double[][] jacobian(double[] variables) {      double t = 2.0 / m;      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = (i == j) ? (1 - t) : -t;        }      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double sum = 0;      for (int i = 0; i < n; ++i) {        sum += variables[i];      }      double t  = 1 + 2 * sum / m;      double[] f = new double[m];      for (int i = 0; i < n; ++i) {        f[i] = variables[i] - t;      }      Arrays.fill(f, n, m, -t);      return f;    }  }  private static class LinearRank1Function extends MinpackFunction {    private static final long serialVersionUID = 8494863245104608300L;    public LinearRank1Function(int m, int n, double x0,                                  double theoreticalStartCost,                                  double theoreticalMinCost) {      super(m, buildArray(n, x0), theoreticalMinCost, null);    }    @Override    public double[][] jacobian(double[] variables) {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = (i + 1) * (j + 1);        }      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double[] f = new double[m];      double sum = 0;      for (int i = 0; i < n; ++i) {        sum += (i + 1) * variables[i];      }      for (int i = 0; i < m; ++i) {        f[i] = (i + 1) * sum - 1;      }      return f;    }  }  private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction {    private static final long serialVersionUID = -3316653043091995018L;    public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {      super(m, buildArray(n, x0),            FastMath.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),            null);    }    @Override    public double[][] jacobian(double[] variables) {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        jacobian[i][0] = 0;        for (int j = 1; j < (n - 1); ++j) {          if (i == 0) {            jacobian[i][j] = 0;          } else if (i != (m - 1)) {            jacobian[i][j] = i * (j + 1);          } else {            jacobian[i][j] = 0;          }        }        jacobian[i][n - 1] = 0;      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double[] f = new double[m];      double sum = 0;      for (int i = 1; i < (n - 1); ++i) {        sum += (i + 1) * variables[i];      }      for (int i = 0; i < (m - 1); ++i) {        f[i] = i * sum - 1;      }      f[m - 1] = -1;      return f;    }  }  private static class RosenbrockFunction extends MinpackFunction {    private static final long serialVersionUID = 2893438180956569134L;    public RosenbrockFunction(double[] startParams, double theoreticalStartCost) {      super(2, startParams, 0.0, buildArray(2, 1.0));    }    @Override    public double[][] jacobian(double[] variables) {      double x1 = variables[0];      return new double[][] { { -20 * x1, 10 }, { -1, 0 } };    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      return new double[] { 10 * (x2 - x1 * x1), 1 - x1 };    }  }  private static class HelicalValleyFunction extends MinpackFunction {    private static final long serialVersionUID = 220613787843200102L;    public HelicalValleyFunction(double[] startParams,                                 double theoreticalStartCost) {      super(3, startParams, 0.0, new double[] { 1.0, 0.0, 0.0 });    }    @Override    public double[][] jacobian(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double tmpSquare = x1 * x1 + x2 * x2;      double tmp1 = twoPi * tmpSquare;      double tmp2 = FastMath.sqrt(tmpSquare);      return new double[][] {        {  100 * x2 / tmp1, -100 * x1 / tmp1, 10 },        { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 },        { 0, 0, 1 }      };    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double tmp1;      if (x1 == 0) {        tmp1 = (x2 >= 0) ? 0.25 : -0.25;      } else {        tmp1 = FastMath.atan(x2 / x1) / twoPi;        if (x1 < 0) {          tmp1 += 0.5;        }      }      double tmp2 = FastMath.sqrt(x1 * x1 + x2 * x2);      return new double[] {        10.0 * (x3 - 10 * tmp1),        10.0 * (tmp2 - 1),        x3      };    }    private static final double twoPi = 2.0 * FastMath.PI;  }  private static class PowellSingularFunction extends MinpackFunction {    private static final long serialVersionUID = 7298364171208142405L;    public PowellSingularFunction(double[] startParams,                                  double theoreticalStartCost) {      super(4, startParams, 0.0, buildArray(4, 0.0));    }    @Override    public double[][] jacobian(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double x4 = variables[3];      return new double[][] {        { 1, 10, 0, 0 },        { 0, 0, sqrt5, -sqrt5 },        { 0, 2 * (x2 - 2 * x3), -4 * (x2 - 2 * x3), 0 },        { 2 * sqrt10 * (x1 - x4), 0, 0, -2 * sqrt10 * (x1 - x4) }      };    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double x4 = variables[3];      return new double[] {        x1 + 10 * x2,        sqrt5 * (x3 - x4),        (x2 - 2 * x3) * (x2 - 2 * x3),        sqrt10 * (x1 - x4) * (x1 - x4)      };    }    private static final double sqrt5  = FastMath.sqrt( 5.0);    private static final double sqrt10 = FastMath.sqrt(10.0);  }  private static class FreudensteinRothFunction extends MinpackFunction {    private static final long serialVersionUID = 2892404999344244214L;    public FreudensteinRothFunction(double[] startParams,                                    double theoreticalStartCost,                                    double theoreticalMinCost,                                    double[] theoreticalMinParams) {      super(2, startParams, theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double x2 = variables[1];      return new double[][] {        { 1, x2 * (10 - 3 * x2) -  2 },        { 1, x2 * ( 2 + 3 * x2) - 14, }      };    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      return new double[] {       -13.0 + x1 + ((5.0 - x2) * x2 -  2.0) * x2,       -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2      };    }  }  private static class BardFunction extends MinpackFunction {    private static final long serialVersionUID = 5990442612572087668L;    public BardFunction(double x0,                        double theoreticalStartCost,                        double theoreticalMinCost,                        double[] theoreticalMinParams) {      super(15, buildArray(3, x0), theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double   x2 = variables[1];      double   x3 = variables[2];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp1 = i  + 1;        double tmp2 = 15 - i;        double tmp3 = (i <= 7) ? tmp1 : tmp2;        double tmp4 = x2 * tmp2 + x3 * tmp3;        tmp4 *= tmp4;        jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double   x3 = variables[2];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double tmp1 = i + 1;        double tmp2 = 15 - i;        double tmp3 = (i <= 7) ? tmp1 : tmp2;        f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3));      }      return f;    }    private static final double[] y = {      0.14, 0.18, 0.22, 0.25, 0.29,      0.32, 0.35, 0.39, 0.37, 0.58,      0.73, 0.96, 1.34, 2.10, 4.39    };  }  private static class KowalikOsborneFunction extends MinpackFunction {    private static final long serialVersionUID = -4867445739880495801L;    public KowalikOsborneFunction(double[] startParams,                                  double theoreticalStartCost,                                  double theoreticalMinCost,                                  double[] theoreticalMinParams) {      super(11, startParams, theoreticalMinCost,            theoreticalMinParams);      if (theoreticalStartCost > 20.0) {        setCostAccuracy(2.0e-4);        setParamsAccuracy(5.0e-3);      }    }    @Override    public double[][] jacobian(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double   x3 = variables[2];      double   x4 = variables[3];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp = v[i] * (v[i] + x3) + x4;        double j1  = -v[i] * (v[i] + x2) / tmp;        double j2  = -v[i] * x1 / tmp;        double j3  = j1 * j2;        double j4  = j3 / v[i];        jacobian[i] = new double[] { j1, j2, j3, j4 };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double x4 = variables[3];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4);      }      return f;    }    private static final double[] v = {      4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625    };    private static final double[] y = {      0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627,      0.0456, 0.0342, 0.0323, 0.0235, 0.0246    };  }  private static class MeyerFunction extends MinpackFunction {    private static final long serialVersionUID = -838060619150131027L;    public MeyerFunction(double[] startParams,                         double theoreticalStartCost,                         double theoreticalMinCost,                         double[] theoreticalMinParams) {      super(16, startParams, theoreticalMinCost,            theoreticalMinParams);      if (theoreticalStartCost > 1.0e6) {        setCostAccuracy(7.0e-3);        setParamsAccuracy(2.0e-2);      }    }    @Override    public double[][] jacobian(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double   x3 = variables[2];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = 5.0 * (i + 1) + 45.0 + x3;        double tmp1 = x2 / temp;        double tmp2 = FastMath.exp(tmp1);        double tmp3 = x1 * tmp2 / temp;        jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        f[i] = x1 * FastMath.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];      }     return f;    }    private static final double[] y = {      34780.0, 28610.0, 23650.0, 19630.0,      16370.0, 13720.0, 11540.0,  9744.0,       8261.0,  7030.0,  6005.0,  5147.0,       4427.0,  3820.0,  3307.0,  2872.0    };  }  private static class WatsonFunction extends MinpackFunction {    private static final long serialVersionUID = -9034759294980218927L;    public WatsonFunction(int n, double x0,                          double theoreticalStartCost,                          double theoreticalMinCost,                          double[] theoreticalMinParams) {      super(31, buildArray(n, x0), theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double[][] jacobian = new double[m][];      for (int i = 0; i < (m - 2); ++i) {        double div = (i + 1) / 29.0;        double s2  = 0.0;        double dx  = 1.0;        for (int j = 0; j < n; ++j) {          s2 += dx * variables[j];          dx *= div;        }        double temp= 2 * div * s2;        dx = 1.0 / div;        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = dx * (j - temp);          dx *= div;        }      }      jacobian[m - 2]    = new double[n];      jacobian[m - 2][0] = 1;      jacobian[m - 1]   = new double[n];      jacobian[m - 1][0]= -2 * variables[0];      jacobian[m - 1][1]= 1;      return jacobian;    }    @Override    public double[] value(double[] variables) {     double[] f = new double[m];     for (int i = 0; i < (m - 2); ++i) {       double div = (i + 1) / 29.0;       double s1 = 0;       double dx = 1;       for (int j = 1; j < n; ++j) {         s1 += j * dx * variables[j];         dx *= div;       }       double s2 =0;       dx =1;       for (int j = 0; j < n; ++j) {         s2 += dx * variables[j];         dx *= div;       }       f[i] = s1 - s2 * s2 - 1;     }     double x1 = variables[0];     double x2 = variables[1];     f[m - 2] = x1;     f[m - 1] = x2 - x1 * x1 - 1;     return f;    }  }  private static class Box3DimensionalFunction extends MinpackFunction {    private static final long serialVersionUID = 5511403858142574493L;    public Box3DimensionalFunction(int m, double[] startParams,                                   double theoreticalStartCost) {      super(m, startParams, 0.0,            new double[] { 1.0, 10.0, 1.0 });   }    @Override    public double[][] jacobian(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp = (i + 1) / 10.0;        jacobian[i] = new double[] {          -tmp * FastMath.exp(-tmp * x1),           tmp * FastMath.exp(-tmp * x2),          FastMath.exp(-i - 1) - FastMath.exp(-tmp)        };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double tmp = (i + 1) / 10.0;        f[i] = FastMath.exp(-tmp * x1) - FastMath.exp(-tmp * x2)             + (FastMath.exp(-i - 1) - FastMath.exp(-tmp)) * x3;      }      return f;    }  }  private static class JennrichSampsonFunction extends MinpackFunction {    private static final long serialVersionUID = -2489165190443352947L;    public JennrichSampsonFunction(int m, double[] startParams,                                   double theoreticalStartCost,                                   double theoreticalMinCost,                                   double[] theoreticalMinParams) {      super(m, startParams, theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double t = i + 1;        jacobian[i] = new double[] { -t * FastMath.exp(t * x1), -t * FastMath.exp(t * x2) };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = i + 1;        f[i] = 2 + 2 * temp - FastMath.exp(temp * x1) - FastMath.exp(temp * x2);      }      return f;    }  }  private static class BrownDennisFunction extends MinpackFunction {    private static final long serialVersionUID = 8340018645694243910L;    public BrownDennisFunction(int m, double[] startParams,                               double theoreticalStartCost,                               double theoreticalMinCost,                               double[] theoreticalMinParams) {      super(m, startParams, theoreticalMinCost,            theoreticalMinParams);      setCostAccuracy(2.5e-8);    }    @Override    public double[][] jacobian(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double   x3 = variables[2];      double   x4 = variables[3];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = (i + 1) / 5.0;        double ti   = FastMath.sin(temp);        double tmp1 = x1 + temp * x2 - FastMath.exp(temp);        double tmp2 = x3 + ti   * x4 - FastMath.cos(temp);        jacobian[i] = new double[] {          2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2        };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double x4 = variables[3];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = (i + 1) / 5.0;        double tmp1 = x1 + temp * x2 - FastMath.exp(temp);        double tmp2 = x3 + FastMath.sin(temp) * x4 - FastMath.cos(temp);        f[i] = tmp1 * tmp1 + tmp2 * tmp2;      }      return f;    }  }  private static class ChebyquadFunction extends MinpackFunction {    private static final long serialVersionUID = -2394877275028008594L;    private static double[] buildChebyquadArray(int n, double factor) {      double[] array = new double[n];      double inv = factor / (n + 1);      for (int i = 0; i < n; ++i) {        array[i] = (i + 1) * inv;      }      return array;    }    public ChebyquadFunction(int n, int m, double factor,                             double theoreticalStartCost,                             double theoreticalMinCost,                             double[] theoreticalMinParams) {      super(m, buildChebyquadArray(n, factor), theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];      }      double dx = 1.0 / n;      for (int j = 0; j < n; ++j) {        double tmp1 = 1;        double tmp2 = 2 * variables[j] - 1;        double temp = 2 * tmp2;        double tmp3 = 0;        double tmp4 = 2;        for (int i = 0; i < m; ++i) {          jacobian[i][j] = dx * tmp4;          double ti = 4 * tmp2 + temp * tmp4 - tmp3;          tmp3 = tmp4;          tmp4 = ti;          ti   = temp * tmp2 - tmp1;          tmp1 = tmp2;          tmp2 = ti;        }      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double[] f = new double[m];      for (int j = 0; j < n; ++j) {        double tmp1 = 1;        double tmp2 = 2 * variables[j] - 1;        double temp = 2 * tmp2;        for (int i = 0; i < m; ++i) {          f[i] += tmp2;          double ti = temp * tmp2 - tmp1;          tmp1 = tmp2;          tmp2 = ti;        }      }      double dx = 1.0 / n;      boolean iev = false;      for (int i = 0; i < m; ++i) {        f[i] *= dx;        if (iev) {          f[i] += 1.0 / (i * (i + 2));        }        iev = ! iev;      }      return f;    }  }  private static class BrownAlmostLinearFunction extends MinpackFunction {    private static final long serialVersionUID = 8239594490466964725L;    public BrownAlmostLinearFunction(int m, double factor,                                     double theoreticalStartCost,                                     double theoreticalMinCost,                                     double[] theoreticalMinParams) {      super(m, buildArray(m, factor), theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];      }      double prod = 1;      for (int j = 0; j < n; ++j) {        prod *= variables[j];        for (int i = 0; i < n; ++i) {          jacobian[i][j] = 1;        }        jacobian[j][j] = 2;      }      for (int j = 0; j < n; ++j) {        double temp = variables[j];        if (temp == 0) {          temp = 1;          prod = 1;          for (int k = 0; k < n; ++k) {            if (k != j) {              prod *= variables[k];            }          }        }        jacobian[n - 1][j] = prod / temp;      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double[] f = new double[m];      double sum  = -(n + 1);      double prod = 1;      for (int j = 0; j < n; ++j) {        sum  += variables[j];        prod *= variables[j];      }      for (int i = 0; i < n; ++i) {        f[i] = variables[i] + sum;      }      f[n - 1] = prod - 1;      return f;    }  }  private static class Osborne1Function extends MinpackFunction {    private static final long serialVersionUID = 4006743521149849494L;    public Osborne1Function(double[] startParams,                            double theoreticalStartCost,                            double theoreticalMinCost,                            double[] theoreticalMinParams) {      super(33, startParams, theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double   x2 = variables[1];      double   x3 = variables[2];      double   x4 = variables[3];      double   x5 = variables[4];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = 10.0 * i;        double tmp1 = FastMath.exp(-temp * x4);        double tmp2 = FastMath.exp(-temp * x5);        jacobian[i] = new double[] {          -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2        };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double x4 = variables[3];      double x5 = variables[4];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = 10.0 * i;        double tmp1 = FastMath.exp(-temp * x4);        double tmp2 = FastMath.exp(-temp * x5);        f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2);      }      return f;    }    private static final double[] y = {      0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751,      0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490,      0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406    };  }  private static class Osborne2Function extends MinpackFunction {    private static final long serialVersionUID = -8418268780389858746L;    public Osborne2Function(double[] startParams,                            double theoreticalStartCost,                            double theoreticalMinCost,                            double[] theoreticalMinParams) {      super(65, startParams, theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double   x01 = variables[0];      double   x02 = variables[1];      double   x03 = variables[2];      double   x04 = variables[3];      double   x05 = variables[4];      double   x06 = variables[5];      double   x07 = variables[6];      double   x08 = variables[7];      double   x09 = variables[8];      double   x10 = variables[9];      double   x11 = variables[10];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = i / 10.0;        double tmp1 = FastMath.exp(-x05 * temp);        double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09));        double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10));        double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11));        jacobian[i] = new double[] {          -tmp1,          -tmp2,          -tmp3,          -tmp4,          temp * x01 * tmp1,          x02 * (temp - x09) * (temp - x09) * tmp2,          x03 * (temp - x10) * (temp - x10) * tmp3,          x04 * (temp - x11) * (temp - x11) * tmp4,          -2 * x02 * x06 * (temp - x09) * tmp2,          -2 * x03 * x07 * (temp - x10) * tmp3,          -2 * x04 * x08 * (temp - x11) * tmp4        };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x01 = variables[0];      double x02 = variables[1];      double x03 = variables[2];      double x04 = variables[3];      double x05 = variables[4];      double x06 = variables[5];      double x07 = variables[6];      double x08 = variables[7];      double x09 = variables[8];      double x10 = variables[9];      double x11 = variables[10];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = i / 10.0;        double tmp1 = FastMath.exp(-x05 * temp);        double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09));        double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10));        double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11));        f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4);      }      return f;    }    private static final double[] y = {      1.366, 1.191, 1.112, 1.013, 0.991,      0.885, 0.831, 0.847, 0.786, 0.725,      0.746, 0.679, 0.608, 0.655, 0.616,      0.606, 0.602, 0.626, 0.651, 0.724,      0.649, 0.649, 0.694, 0.644, 0.624,      0.661, 0.612, 0.558, 0.533, 0.495,      0.500, 0.423, 0.395, 0.375, 0.372,      0.391, 0.396, 0.405, 0.428, 0.429,      0.523, 0.562, 0.607, 0.653, 0.672,      0.708, 0.633, 0.668, 0.645, 0.632,      0.591, 0.559, 0.597, 0.625, 0.739,      0.710, 0.729, 0.720, 0.636, 0.581,      0.428, 0.292, 0.162, 0.098, 0.054    };  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.univariate;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.optimization.univariate.BrentOptimizer;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.random.JDKRandomGenerator;import org.apache.commons.math.util.FastMath;import org.junit.Test;import org.junit.Assert;public class MultiStartUnivariateRealOptimizerTest {    @Test    public void testSinMin() {        UnivariateRealFunction f = new SinFunction();        UnivariateRealOptimizer underlying = new BrentOptimizer(1e-10, 1e-14);        JDKRandomGenerator g = new JDKRandomGenerator();        g.setSeed(44428400075l);        MultiStartUnivariateRealOptimizer<UnivariateRealFunction> optimizer =            new MultiStartUnivariateRealOptimizer<UnivariateRealFunction>(underlying, 10, g);        optimizer.optimize(300, f, GoalType.MINIMIZE, -100.0, 100.0);        UnivariateRealPointValuePair[] optima = optimizer.getOptima();        for (int i = 1; i < optima.length; ++i) {            double d = (optima[i].getPoint() - optima[i-1].getPoint()) / (2 * FastMath.PI);            Assert.assertTrue(FastMath.abs(d - FastMath.rint(d)) < 1.0e-8);            Assert.assertEquals(-1.0, f.value(optima[i].getPoint()), 1.0e-10);            Assert.assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1.0e-10);        }        Assert.assertTrue(optimizer.getEvaluations() > 200);        Assert.assertTrue(optimizer.getEvaluations() < 300);    }    @Test    public void testQuinticMin() {        // The quintic function has zeros at 0, +-0.5 and +-1.        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14);        JDKRandomGenerator g = new JDKRandomGenerator();        g.setSeed(4312000053L);        MultiStartUnivariateRealOptimizer<UnivariateRealFunction> optimizer =            new MultiStartUnivariateRealOptimizer<UnivariateRealFunction>(underlying, 5, g);        UnivariateRealPointValuePair optimum            = optimizer.optimize(300, f, GoalType.MINIMIZE, -0.3, -0.2);        Assert.assertEquals(-0.2719561293, optimum.getPoint(), 1e-9);        Assert.assertEquals(-0.0443342695, optimum.getValue(), 1e-9);        UnivariateRealPointValuePair[] optima = optimizer.getOptima();        for (int i = 0; i < optima.length; ++i) {            Assert.assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1e-9);        }        Assert.assertTrue(optimizer.getEvaluations() >= 50);        Assert.assertTrue(optimizer.getEvaluations() <= 100);    }    @Test    public void testBadFunction() {        UnivariateRealFunction f = new UnivariateRealFunction() {                public double value(double x) {                    if (x < 0) {                        throw new MathUserException();                    }                    return 0;                }            };        UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14);        JDKRandomGenerator g = new JDKRandomGenerator();        g.setSeed(4312000053L);        MultiStartUnivariateRealOptimizer<UnivariateRealFunction> optimizer =            new MultiStartUnivariateRealOptimizer<UnivariateRealFunction>(underlying, 5, g);         try {            optimizer.optimize(300, f, GoalType.MINIMIZE, -0.3, -0.2);            Assert.fail();        } catch (MathUserException e) {            // Expected.        }        // Ensure that the exception was thrown because no optimum was found.        Assert.assertTrue(optimizer.getOptima()[0] == null);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.univariate;import org.apache.commons.math.exception.TooManyEvaluationsException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;import org.junit.Assert;import org.junit.Test;/** * @version $Id$ */public final class BrentOptimizerTest {    @Test    public void testSinMin() {        UnivariateRealFunction f = new SinFunction();        UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);        Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(200, f, GoalType.MINIMIZE, 4, 5).getPoint(),1e-8);        Assert.assertTrue(optimizer.getEvaluations() <= 50);        Assert.assertEquals(200, optimizer.getMaxEvaluations());        Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(200, f, GoalType.MINIMIZE, 1, 5).getPoint(), 1e-8);        Assert.assertTrue(optimizer.getEvaluations() <= 100);        Assert.assertTrue(optimizer.getEvaluations() >= 15);        try {            optimizer.optimize(10, f, GoalType.MINIMIZE, 4, 5);            Assert.fail("an exception should have been thrown");        } catch (TooManyEvaluationsException fee) {            // expected        }    }    @Test    public void testQuinticMin() {        // The function has local minima at -0.27195613 and 0.82221643.        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);        Assert.assertEquals(-0.27195613, optimizer.optimize(200, f, GoalType.MINIMIZE, -0.3, -0.2).getPoint(), 1.0e-8);        Assert.assertEquals( 0.82221643, optimizer.optimize(200, f, GoalType.MINIMIZE,  0.3,  0.9).getPoint(), 1.0e-8);        Assert.assertTrue(optimizer.getEvaluations() <= 50);        // search in a large interval        Assert.assertEquals(-0.27195613, optimizer.optimize(200, f, GoalType.MINIMIZE, -1.0, 0.2).getPoint(), 1.0e-8);        Assert.assertTrue(optimizer.getEvaluations() <= 50);    }    @Test    public void testQuinticMinStatistics() {        // The function has local minima at -0.27195613 and 0.82221643.        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-11, 1e-14);        final DescriptiveStatistics[] stat = new DescriptiveStatistics[2];        for (int i = 0; i < stat.length; i++) {            stat[i] = new DescriptiveStatistics();        }        final double min = -0.75;        final double max = 0.25;        final int nSamples = 200;        final double delta = (max - min) / nSamples;        for (int i = 0; i < nSamples; i++) {            final double start = min + i * delta;            stat[0].addValue(optimizer.optimize(40, f, GoalType.MINIMIZE, min, max, start).getPoint());            stat[1].addValue(optimizer.getEvaluations());        }        final double meanOptValue = stat[0].getMean();        final double medianEval = stat[1].getPercentile(50);        Assert.assertTrue(meanOptValue > -0.2719561281);        Assert.assertTrue(meanOptValue < -0.2719561280);        Assert.assertEquals(23, (int) medianEval);    }    @Test    public void testQuinticMax() {        // The quintic function has zeros at 0, +-0.5 and +-1.        // The function has a local maximum at 0.27195613.        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-12, 1e-14);        Assert.assertEquals(0.27195613, optimizer.optimize(100, f, GoalType.MAXIMIZE, 0.2, 0.3).getPoint(), 1e-8);        try {            optimizer.optimize(5, f, GoalType.MAXIMIZE, 0.2, 0.3);            Assert.fail("an exception should have been thrown");        } catch (TooManyEvaluationsException miee) {            // expected        }    }    @Test    public void testMinEndpoints() {        UnivariateRealFunction f = new SinFunction();        UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-8, 1e-14);        // endpoint is minimum        double result = optimizer.optimize(50, f, GoalType.MINIMIZE, 3 * Math.PI / 2, 5).getPoint();        Assert.assertEquals(3 * Math.PI / 2, result, 1e-6);        result = optimizer.optimize(50, f, GoalType.MINIMIZE, 4, 3 * Math.PI / 2).getPoint();        Assert.assertEquals(3 * Math.PI / 2, result, 1e-6);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.univariate;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.optimization.GoalType;import org.junit.Assert;import org.junit.Test;/** * Test for {@link BracketFinder}. */public class BracketFinderTest {    @Test    public void testCubicMin() {        final BracketFinder bFind = new BracketFinder();        final UnivariateRealFunction func = new UnivariateRealFunction() {                public double value(double x) {                    if (x < -2) {                        return value(-2);                    }                    else  {                        return (x - 1) * (x + 2) * (x + 3);                    }                }            };        bFind.search(func, GoalType.MINIMIZE, -2 , -1);        final double tol = 1e-15;        // Comparing with results computed in Python.        Assert.assertEquals(-2, bFind.getLo(), tol);        Assert.assertEquals(-1, bFind.getMid(), tol);        Assert.assertEquals(0.61803399999999997, bFind.getHi(), tol);    }    @Test    public void testCubicMax() {        final BracketFinder bFind = new BracketFinder();        final UnivariateRealFunction func = new UnivariateRealFunction() {                public double value(double x) {                    if (x < -2) {                        return value(-2);                    }                    else  {                        return -(x - 1) * (x + 2) * (x + 3);                    }                }            };        bFind.search(func, GoalType.MAXIMIZE, -2 , -1);        final double tol = 1e-15;        Assert.assertEquals(-2, bFind.getLo(), tol);        Assert.assertEquals(-1, bFind.getMid(), tol);        Assert.assertEquals(0.61803399999999997, bFind.getHi(), tol);    }    @Test    public void testMinimumIsOnIntervalBoundary() {        final UnivariateRealFunction func = new UnivariateRealFunction() {                public double value(double x) {                    return x * x;                }            };        final BracketFinder bFind = new BracketFinder();        bFind.search(func, GoalType.MINIMIZE, 0, 1);        Assert.assertTrue(bFind.getLo() <= 0);        Assert.assertTrue(0 <= bFind.getHi());        bFind.search(func, GoalType.MINIMIZE, -1, 0);        Assert.assertTrue(bFind.getLo() <= 0);        Assert.assertTrue(0 <= bFind.getHi());    }    @Test    public void testIntervalBoundsOrdering() {        final UnivariateRealFunction func = new UnivariateRealFunction() {                public double value(double x) {                    return x * x;                }            };        final BracketFinder bFind = new BracketFinder();        bFind.search(func, GoalType.MINIMIZE, -1, 1);        Assert.assertTrue(bFind.getLo() <= 0);        Assert.assertTrue(0 <= bFind.getHi());        bFind.search(func, GoalType.MINIMIZE, 1, -1);        Assert.assertTrue(bFind.getLo() <= 0);        Assert.assertTrue(0 <= bFind.getHi());        bFind.search(func, GoalType.MINIMIZE, 1, 2);        Assert.assertTrue(bFind.getLo() <= 0);        Assert.assertTrue(0 <= bFind.getHi());        bFind.search(func, GoalType.MINIMIZE, 2, 1);        Assert.assertTrue(bFind.getLo() <= 0);        Assert.assertTrue(0 <= bFind.getHi());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.direct;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.optimization.RealPointValuePair;import org.apache.commons.math.optimization.SimpleScalarValueChecker;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class SimplexOptimizerMultiDirectionalTest {    @Test    public void testMinimize1() {        SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);        optimizer.setSimplex(new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));        final FourExtrema fourExtrema = new FourExtrema();        final RealPointValuePair optimum            = optimizer.optimize(200, fourExtrema, GoalType.MINIMIZE, new double[] { -3, 0 });        Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 4e-6);        Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6);        Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 8e-13);        Assert.assertTrue(optimizer.getEvaluations() > 120);        Assert.assertTrue(optimizer.getEvaluations() < 150);    }    @Test    public void testMinimize2() {        SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);        optimizer.setSimplex(new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));        final FourExtrema fourExtrema = new FourExtrema();        final RealPointValuePair optimum            =  optimizer.optimize(200, fourExtrema, GoalType.MINIMIZE, new double[] { 1, 0 });        Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8);        Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-6);        Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 2e-12);        Assert.assertTrue(optimizer.getEvaluations() > 120);        Assert.assertTrue(optimizer.getEvaluations() < 150);    }    @Test    public void testMaximize1() {        SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);        optimizer.setSimplex(new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));        final FourExtrema fourExtrema = new FourExtrema();        final RealPointValuePair optimum            = optimizer.optimize(200, fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });        Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 7e-7);        Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-7);        Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 2e-14);        Assert.assertTrue(optimizer.getEvaluations() > 120);        Assert.assertTrue(optimizer.getEvaluations() < 150);    }    @Test    public void testMaximize2() {        SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleScalarValueChecker(1e-15, 1e-30));        optimizer.setSimplex(new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));        final FourExtrema fourExtrema = new FourExtrema();        final RealPointValuePair optimum            = optimizer.optimize(200, fourExtrema, GoalType.MAXIMIZE, new double[] { 1, 0 });        Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8);        Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6);        Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 2e-12);        Assert.assertTrue(optimizer.getEvaluations() > 180);        Assert.assertTrue(optimizer.getEvaluations() < 220);    }    @Test    public void testRosenbrock() {        MultivariateRealFunction rosenbrock =            new MultivariateRealFunction() {                public double value(double[] x) {                    ++count;                    double a = x[1] - x[0] * x[0];                    double b = 1.0 - x[0];                    return 100 * a * a + b * b;                }            };        count = 0;        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);        optimizer.setSimplex(new MultiDirectionalSimplex(new double[][] {                    { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }                }));        RealPointValuePair optimum =            optimizer.optimize(100, rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1 });        Assert.assertEquals(count, optimizer.getEvaluations());        Assert.assertTrue(optimizer.getEvaluations() > 50);        Assert.assertTrue(optimizer.getEvaluations() < 100);        Assert.assertTrue(optimum.getValue() > 1e-2);    }    @Test    public void testPowell() {        MultivariateRealFunction powell =            new MultivariateRealFunction() {                public double value(double[] x) {                    ++count;                    double a = x[0] + 10 * x[1];                    double b = x[2] - x[3];                    double c = x[1] - 2 * x[2];                    double d = x[0] - x[3];                    return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;                }            };        count = 0;        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);        optimizer.setSimplex(new MultiDirectionalSimplex(4));        RealPointValuePair optimum =            optimizer.optimize(1000, powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 });        Assert.assertEquals(count, optimizer.getEvaluations());        Assert.assertTrue(optimizer.getEvaluations() > 800);        Assert.assertTrue(optimizer.getEvaluations() < 900);        Assert.assertTrue(optimum.getValue() > 1e-2);    }    @Test    public void testMath283() {        // fails because MultiDirectional.iterateSimplex is looping forever        // the while(true) should be replaced with a convergence check        SimplexOptimizer optimizer = new SimplexOptimizer();        optimizer.setSimplex(new MultiDirectionalSimplex(2));        final Gaussian2D function = new Gaussian2D(0, 0, 1);        RealPointValuePair estimate = optimizer.optimize(1000, function,                                                         GoalType.MAXIMIZE, function.getMaximumPosition());        final double EPSILON = 1e-5;        final double expectedMaximum = function.getMaximum();        final double actualMaximum = estimate.getValue();        Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);        final double[] expectedPosition = function.getMaximumPosition();        final double[] actualPosition = estimate.getPoint();        Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );        Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );    }    private static class FourExtrema implements MultivariateRealFunction {        // The following function has 4 local extrema.        final double xM = -3.841947088256863675365;        final double yM = -1.391745200270734924416;        final double xP =  0.2286682237349059125691;        final double yP = -yM;        final double valueXmYm = 0.2373295333134216789769; // Local maximum.        final double valueXmYp = -valueXmYm; // Local minimum.        final double valueXpYm = -0.7290400707055187115322; // Global minimum.        final double valueXpYp = -valueXpYm; // Global maximum.        public double value(double[] variables) {            final double x = variables[0];            final double y = variables[1];            return (x == 0 || y == 0) ? 0 :                FastMath.atan(x) * FastMath.atan(x + 2) * FastMath.atan(y) * FastMath.atan(y) / (x * y);        }    }    private static class Gaussian2D implements MultivariateRealFunction {        private final double[] maximumPosition;        private final double std;        public Gaussian2D(double xOpt, double yOpt, double std) {            maximumPosition = new double[] { xOpt, yOpt };            this.std = std;        }        public double getMaximum() {            return value(maximumPosition);        }        public double[] getMaximumPosition() {            return maximumPosition.clone();        }        public double value(double[] point) {            final double x = point[0], y = point[1];            final double twoS2 = 2.0 * std * std;            return 1.0 / (twoS2 * FastMath.PI) * FastMath.exp(-(x * x + y * y) / twoS2);        }    }    private int count;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.direct;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.analysis.SumSincFunction;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.optimization.MultivariateRealOptimizer;import org.apache.commons.math.optimization.RealPointValuePair;import org.junit.Assert;import org.junit.Test;/** * Test for {@link PowellOptimizer}. */public class PowellOptimizerTest {    @Test    public void testSumSinc() {        final MultivariateRealFunction func = new SumSincFunction(-1);        int dim = 2;        final double[] minPoint = new double[dim];        for (int i = 0; i < dim; i++) {            minPoint[i] = 0;        }        double[] init = new double[dim];        // Initial is minimum.        for (int i = 0; i < dim; i++) {            init[i] = minPoint[i];        }        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-9, 1e-7);        // Initial is far from minimum.        for (int i = 0; i < dim; i++) {            init[i] = minPoint[i] + 3;        }        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-9, 1e-7);    }    @Test    public void testQuadratic() {        final MultivariateRealFunction func = new MultivariateRealFunction() {                public double value(double[] x) {                    final double a = x[0] - 1;                    final double b = x[1] - 1;                    return a * a + b * b + 1;                }            };        int dim = 2;        final double[] minPoint = new double[dim];        for (int i = 0; i < dim; i++) {            minPoint[i] = 1;        }        double[] init = new double[dim];        // Initial is minimum.        for (int i = 0; i < dim; i++) {            init[i] = minPoint[i];        }        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-8);        // Initial is far from minimum.        for (int i = 0; i < dim; i++) {            init[i] = minPoint[i] - 20;        }        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-8);    }    @Test    public void testMaximizeQuadratic() {        final MultivariateRealFunction func = new MultivariateRealFunction() {                public double value(double[] x) {                    final double a = x[0] - 1;                    final double b = x[1] - 1;                    return -a * a - b * b + 1;                }            };        int dim = 2;        final double[] maxPoint = new double[dim];        for (int i = 0; i < dim; i++) {            maxPoint[i] = 1;        }        double[] init = new double[dim];        // Initial is minimum.        for (int i = 0; i < dim; i++) {            init[i] = maxPoint[i];        }        doTest(func, maxPoint, init,  GoalType.MAXIMIZE, 1e-9, 1e-8);        // Initial is far from minimum.        for (int i = 0; i < dim; i++) {            init[i] = maxPoint[i] - 20;        }        doTest(func, maxPoint, init, GoalType.MAXIMIZE, 1e-9, 1e-8);    }    /**     * @param func Function to optimize.     * @param optimum Expected optimum.     * @param init Starting point.     * @param goal Minimization or maximization.     * @param fTol Tolerance (relative error on the objective function) for     * "Powell" algorithm.     * @param pointTol Tolerance for checking that the optimum is correct.     */    private void doTest(MultivariateRealFunction func,                        double[] optimum,                        double[] init,                        GoalType goal,                        double fTol,                        double pointTol) {        final MultivariateRealOptimizer optim = new PowellOptimizer(fTol, Math.ulp(1d));        final RealPointValuePair result = optim.optimize(1000, func, goal, init);        final double[] found = result.getPoint();        for (int i = 0, dim = optimum.length; i < dim; i++) {            Assert.assertEquals(optimum[i], found[i], pointTol);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.direct;import java.util.Arrays;import java.util.Random;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.TooManyEvaluationsException;import org.apache.commons.math.exception.NoDataException;import org.apache.commons.math.exception.OutOfRangeException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.optimization.MultivariateRealOptimizer;import org.apache.commons.math.optimization.RealPointValuePair;import org.junit.Assert;import org.junit.Test;/** * Test for {@link BOBYQAOptimizer}. */public class BOBYQAOptimizerTest {    static final int DIM = 13;       @Test(expected=OutOfRangeException.class)    public void testInitOutOfBounds() {        double[] startPoint = point(DIM, 3);        double[][] boundaries = boundaries(DIM, -1, 2);        doTest(new Rosen(), startPoint, boundaries,                GoalType.MINIMIZE,                 1e-13, 1e-6, 2000, null);    }        @Test(expected=DimensionMismatchException.class)    public void testBoundariesDimensionMismatch() {        double[] startPoint = point(DIM, 0.5);        double[][] boundaries = boundaries(DIM + 1, -1, 2);        doTest(new Rosen(), startPoint, boundaries,               GoalType.MINIMIZE,                1e-13, 1e-6, 2000, null);    }    @Test(expected=NumberIsTooSmallException.class)    public void testProblemDimensionTooSmall() {        double[] startPoint = point(1, 0.5);        double[][] boundaries = null;        doTest(new Rosen(), startPoint, null,               GoalType.MINIMIZE,               1e-13, 1e-6, 2000, null);    }    @Test(expected=TooManyEvaluationsException.class)    public void testMaxEvaluations() {        final int lowMaxEval = 2;        double[] startPoint = point(DIM, 0.1);        double[][] boundaries = null;        doTest(new Rosen(), startPoint, boundaries,               GoalType.MINIMIZE,                1e-13, 1e-6, lowMaxEval, null);     }    @Test    public void testRosen() {        double[] startPoint = point(DIM,0.1);        double[][] boundaries = null;        RealPointValuePair expected = new RealPointValuePair(point(DIM,1.0),0.0);        doTest(new Rosen(), startPoint, boundaries,                GoalType.MINIMIZE,                 1e-13, 1e-6, 2000, expected);     }    @Test    public void testMaximize() {        double[] startPoint = point(DIM,1.0);        double[][] boundaries = null;        RealPointValuePair expected = new RealPointValuePair(point(DIM,0.0),1.0);        doTest(new MinusElli(), startPoint, boundaries,                GoalType.MAXIMIZE,                 2e-10, 5e-6, 1000, expected);        boundaries = boundaries(DIM,-0.3,0.3);         startPoint = point(DIM,0.1);        doTest(new MinusElli(), startPoint, boundaries,                GoalType.MAXIMIZE,                 2e-10, 5e-6, 1000, expected);    }    @Test    public void testEllipse() {        double[] startPoint = point(DIM,1.0);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new Elli(), startPoint, boundaries,                GoalType.MINIMIZE,                 1e-13, 1e-6, 1000, expected);     }    @Test    public void testElliRotated() {        double[] startPoint = point(DIM,1.0);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new ElliRotated(), startPoint, boundaries,                GoalType.MINIMIZE,                 1e-12, 1e-6, 10000, expected);    }    @Test    public void testCigar() {        double[] startPoint = point(DIM,1.0);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new Cigar(), startPoint, boundaries,                GoalType.MINIMIZE,                 1e-13, 1e-6, 100, expected);    }    @Test    public void testTwoAxes() {        double[] startPoint = point(DIM,1.0);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new TwoAxes(), startPoint, boundaries,                GoalType.MINIMIZE, 2*                1e-13, 1e-6, 100, expected);     }    @Test    public void testCigTab() {        double[] startPoint = point(DIM,1.0);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new CigTab(), startPoint, boundaries,                GoalType.MINIMIZE,                 1e-13, 5e-5, 100, expected);     }    @Test    public void testSphere() {        double[] startPoint = point(DIM,1.0);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new Sphere(), startPoint, boundaries,                GoalType.MINIMIZE,                 1e-13, 1e-6, 100, expected);    }    @Test    public void testTablet() {        double[] startPoint = point(DIM,1.0);         double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new Tablet(), startPoint, boundaries,                GoalType.MINIMIZE,                 1e-13, 1e-6, 100, expected);    }    @Test    public void testDiffPow() {        double[] startPoint = point(DIM/2,1.0);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM/2,0.0),0.0);        doTest(new DiffPow(), startPoint, boundaries,                GoalType.MINIMIZE,                 1e-8, 1e-1, 12000, expected);    }    @Test    public void testSsDiffPow() {        double[] startPoint = point(DIM/2,1.0);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM/2,0.0),0.0);        doTest(new SsDiffPow(), startPoint, boundaries,                GoalType.MINIMIZE,                 1e-2, 1.3e-1, 50000, expected);    }    @Test    public void testAckley() {        double[] startPoint = point(DIM,0.1);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new Ackley(), startPoint, boundaries,                GoalType.MINIMIZE,                1e-8, 1e-5, 1000, expected);    }    @Test    public void testRastrigin() {        double[] startPoint = point(DIM,1.0);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new Rastrigin(), startPoint, boundaries,                GoalType.MINIMIZE,                 1e-13, 1e-6, 1000, expected);    }    @Test    public void testConstrainedRosen() {        double[] startPoint = point(DIM,0.1);        double[][] boundaries = boundaries(DIM,-1,2);        RealPointValuePair expected =            new RealPointValuePair(point(DIM,1.0),0.0);        doTest(new Rosen(), startPoint, boundaries,                GoalType.MINIMIZE,                1e-13, 1e-6, 2000, expected);    }    /**     * @param func Function to optimize.     * @param startPoint Starting point.     * @param boundaries Upper / lower point limit.     * @param goal Minimization or maximization.     * @param fTol Tolerance relative error on the objective function.     * @param pointTol Tolerance for checking that the optimum is correct.     * @param maxEvaluations Maximum number of evaluations.     * @param expected Expected point / value.     */    private void doTest(MultivariateRealFunction func,            double[] startPoint,            double[][] boundaries,            GoalType goal,            double fTol,            double pointTol,            int maxEvaluations,            RealPointValuePair expected) {        System.out.println(func.getClass().getName() + " BEGIN"); // XXX        int dim = startPoint.length;//        MultivariateRealOptimizer optim =//            new PowellOptimizer(1e-13, Math.ulp(1d));//        RealPointValuePair result = optim.optimize(100000, func, goal, startPoint);        final double[] lB = boundaries == null ? null : boundaries[0];        final double[] uB = boundaries == null ? null : boundaries[1];        MultivariateRealOptimizer optim =            new BOBYQAOptimizer(2 * dim + 1, lB, uB);        RealPointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint);        //        System.out.println(func.getClass().getName() + " = " //        + optim.getEvaluations() + " f(");//        for (double x: result.getPoint())  System.out.print(x + " ");//        System.out.println(") = " +  result.getValue());        Assert.assertEquals(expected.getValue(),                result.getValue(), fTol);        for (int i = 0; i < dim; i++) {            Assert.assertEquals(expected.getPoint()[i],                    result.getPoint()[i], pointTol);        }        System.out.println(func.getClass().getName() + " END"); // XXX    }    private static double[] point(int n, double value) {        double[] ds = new double[n];        Arrays.fill(ds, value);        return ds;    }    private static double[][] boundaries(int dim,            double lower, double upper) {        double[][] boundaries = new double[2][dim];        for (int i = 0; i < dim; i++)            boundaries[0][i] = lower;        for (int i = 0; i < dim; i++)            boundaries[1][i] = upper;        return boundaries;    }    private static class Sphere implements MultivariateRealFunction {        public double value(double[] x) {            double f = 0;            for (int i = 0; i < x.length; ++i)                f += x[i] * x[i];            return f;        }    }    private static class Cigar implements MultivariateRealFunction {        private double factor;        Cigar() {            this(1e3);        }        Cigar(double axisratio) {            factor = axisratio * axisratio;        }        public double value(double[] x) {            double f = x[0] * x[0];            for (int i = 1; i < x.length; ++i)                f += factor * x[i] * x[i];            return f;        }    }    private static class Tablet implements MultivariateRealFunction {        private double factor;        Tablet() {            this(1e3);        }        Tablet(double axisratio) {            factor = axisratio * axisratio;        }        public double value(double[] x) {            double f = factor * x[0] * x[0];            for (int i = 1; i < x.length; ++i)                f += x[i] * x[i];            return f;        }    }    private static class CigTab implements MultivariateRealFunction {        private double factor;        CigTab() {            this(1e4);        }        CigTab(double axisratio) {            factor = axisratio;        }        public double value(double[] x) {            int end = x.length - 1;            double f = x[0] * x[0] / factor + factor * x[end] * x[end];            for (int i = 1; i < end; ++i)                f += x[i] * x[i];            return f;        }    }    private static class TwoAxes implements MultivariateRealFunction {        private double factor;        TwoAxes() {            this(1e6);        }        TwoAxes(double axisratio) {            factor = axisratio * axisratio;        }        public double value(double[] x) {            double f = 0;            for (int i = 0; i < x.length; ++i)                f += (i < x.length / 2 ? factor : 1) * x[i] * x[i];            return f;        }    }    private static class ElliRotated implements MultivariateRealFunction {        private Basis B = new Basis();        private double factor;        ElliRotated() {            this(1e3);        }        ElliRotated(double axisratio) {            factor = axisratio * axisratio;        }        public double value(double[] x) {            double f = 0;            x = B.Rotate(x);            for (int i = 0; i < x.length; ++i)                f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i];            return f;        }    }    private static class Elli implements MultivariateRealFunction {        private double factor;        Elli() {            this(1e3);        }        Elli(double axisratio) {            factor = axisratio * axisratio;        }        public double value(double[] x) {            double f = 0;            for (int i = 0; i < x.length; ++i)                f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i];            return f;        }    }    private static class MinusElli implements MultivariateRealFunction {        private final Elli elli = new Elli();        public double value(double[] x) {            return 1.0 - elli.value(x);        }    }    private static class DiffPow implements MultivariateRealFunction {        private int fcount = 0;        public double value(double[] x) {            double f = 0;            for (int i = 0; i < x.length; ++i)                f += Math.pow(Math.abs(x[i]), 2. + 10 * (double) i                        / (x.length - 1.));//            System.out.print("" + (fcount++) + ") ");//            for (int i = 0; i < x.length; i++)//                System.out.print(x[i] +  " ");//            System.out.println(" = " + f);            return f;        }    }    private static class SsDiffPow implements MultivariateRealFunction {        public double value(double[] x) {            double f = Math.pow(new DiffPow().value(x), 0.25);            return f;        }    }    private static class Rosen implements MultivariateRealFunction {        public double value(double[] x) {            double f = 0;            for (int i = 0; i < x.length - 1; ++i)                f += 1e2 * (x[i] * x[i] - x[i + 1]) * (x[i] * x[i] - x[i + 1])                + (x[i] - 1.) * (x[i] - 1.);            return f;        }    }    private static class Ackley implements MultivariateRealFunction {        private double axisratio;        Ackley(double axra) {            axisratio = axra;        }        public Ackley() {            this(1);        }        public double value(double[] x) {            double f = 0;            double res2 = 0;            double fac = 0;            for (int i = 0; i < x.length; ++i) {                fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.));                f += fac * fac * x[i] * x[i];                res2 += Math.cos(2. * Math.PI * fac * x[i]);            }            f = (20. - 20. * Math.exp(-0.2 * Math.sqrt(f / x.length))                    + Math.exp(1.) - Math.exp(res2 / x.length));            return f;        }    }    private static class Rastrigin implements MultivariateRealFunction {        private double axisratio;        private double amplitude;        Rastrigin() {            this(1, 10);        }        Rastrigin(double axisratio, double amplitude) {            this.axisratio = axisratio;            this.amplitude = amplitude;        }        public double value(double[] x) {            double f = 0;            double fac;            for (int i = 0; i < x.length; ++i) {                fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.));                if (i == 0 && x[i] < 0)                    fac *= 1.;                f += fac * fac * x[i] * x[i] + amplitude                * (1. - Math.cos(2. * Math.PI * fac * x[i]));            }            return f;        }    }    private static class Basis {        double[][] basis;        Random rand = new Random(2); // use not always the same basis        double[] Rotate(double[] x) {            GenBasis(x.length);            double[] y = new double[x.length];            for (int i = 0; i < x.length; ++i) {                y[i] = 0;                for (int j = 0; j < x.length; ++j)                    y[i] += basis[i][j] * x[j];            }            return y;        }        void GenBasis(int DIM) {            if (basis != null ? basis.length == DIM : false)                return;            double sp;            int i, j, k;            /* generate orthogonal basis */            basis = new double[DIM][DIM];            for (i = 0; i < DIM; ++i) {                /* sample components gaussian */                for (j = 0; j < DIM; ++j)                    basis[i][j] = rand.nextGaussian();                /* substract projection of previous vectors */                for (j = i - 1; j >= 0; --j) {                    for (sp = 0., k = 0; k < DIM; ++k)                        sp += basis[i][k] * basis[j][k]; /* scalar product */                    for (k = 0; k < DIM; ++k)                        basis[i][k] -= sp * basis[j][k]; /* substract */                }                /* normalize */                for (sp = 0., k = 0; k < DIM; ++k)                    sp += basis[i][k] * basis[i][k]; /* squared norm */                for (k = 0; k < DIM; ++k)                    basis[i][k] /= Math.sqrt(sp);            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.direct;import org.apache.commons.math.exception.TooManyEvaluationsException;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.analysis.MultivariateVectorialFunction;import org.apache.commons.math.linear.Array2DRowRealMatrix;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.optimization.LeastSquaresConverter;import org.apache.commons.math.optimization.RealPointValuePair;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class SimplexOptimizerNelderMeadTest {    @Test    public void testMinimize1() {        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);        optimizer.setSimplex(new NelderMeadSimplex(new double[] { 0.2, 0.2 }));        final FourExtrema fourExtrema = new FourExtrema();        final RealPointValuePair optimum            = optimizer.optimize(100, fourExtrema, GoalType.MINIMIZE, new double[] { -3, 0 });        Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 2e-7);        Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 2e-5);        Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 6e-12);        Assert.assertTrue(optimizer.getEvaluations() > 60);        Assert.assertTrue(optimizer.getEvaluations() < 90);    }    @Test    public void testMinimize2() {        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);        optimizer.setSimplex(new NelderMeadSimplex(new double[] { 0.2, 0.2 }));        final FourExtrema fourExtrema = new FourExtrema();        final RealPointValuePair optimum            = optimizer.optimize(100, fourExtrema, GoalType.MINIMIZE, new double[] { 1, 0 });        Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 5e-6);        Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 6e-6);        Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 1e-11);        Assert.assertTrue(optimizer.getEvaluations() > 60);        Assert.assertTrue(optimizer.getEvaluations() < 90);    }    @Test    public void testMaximize1() {        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);        optimizer.setSimplex(new NelderMeadSimplex(new double[] { 0.2, 0.2 }));        final FourExtrema fourExtrema = new FourExtrema();        final RealPointValuePair optimum            = optimizer.optimize(100, fourExtrema, GoalType.MAXIMIZE, new double[] { -3, 0 });        Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 1e-5);        Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-6);        Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 3e-12);        Assert.assertTrue(optimizer.getEvaluations() > 60);        Assert.assertTrue(optimizer.getEvaluations() < 90);    }    @Test    public void testMaximize2() {        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);        optimizer.setSimplex(new NelderMeadSimplex(new double[] { 0.2, 0.2 }));        final FourExtrema fourExtrema = new FourExtrema();        final RealPointValuePair optimum            = optimizer.optimize(100, fourExtrema, GoalType.MAXIMIZE, new double[] { 1, 0 });        Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 4e-6);        Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 5e-6);        Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 7e-12);        Assert.assertTrue(optimizer.getEvaluations() > 60);        Assert.assertTrue(optimizer.getEvaluations() < 90);    }    @Test    public void testRosenbrock() {        Rosenbrock rosenbrock = new Rosenbrock();        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);        optimizer.setSimplex(new NelderMeadSimplex(new double[][] {                    { -1.2,  1 }, { 0.9, 1.2 } , {  3.5, -2.3 }                }));        RealPointValuePair optimum =            optimizer.optimize(100, rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1 });        Assert.assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());        Assert.assertTrue(optimizer.getEvaluations() > 40);        Assert.assertTrue(optimizer.getEvaluations() < 50);        Assert.assertTrue(optimum.getValue() < 8e-4);    }    @Test    public void testPowell() {        Powell powell = new Powell();        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);        optimizer.setSimplex(new NelderMeadSimplex(4));        RealPointValuePair optimum =            optimizer.optimize(200, powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 });        Assert.assertEquals(powell.getCount(), optimizer.getEvaluations());        Assert.assertTrue(optimizer.getEvaluations() > 110);        Assert.assertTrue(optimizer.getEvaluations() < 130);        Assert.assertTrue(optimum.getValue() < 2e-3);    }    @Test    public void testLeastSquares1() {        final RealMatrix factors =            new Array2DRowRealMatrix(new double[][] {                    { 1, 0 },                    { 0, 1 }                }, false);        LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {                public double[] value(double[] variables) {                    return factors.operate(variables);                }            }, new double[] { 2.0, -3.0 });        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6);        optimizer.setSimplex(new NelderMeadSimplex(2));        RealPointValuePair optimum =            optimizer.optimize(200, ls, GoalType.MINIMIZE, new double[] { 10, 10 });        Assert.assertEquals( 2, optimum.getPointRef()[0], 3e-5);        Assert.assertEquals(-3, optimum.getPointRef()[1], 4e-4);        Assert.assertTrue(optimizer.getEvaluations() > 60);        Assert.assertTrue(optimizer.getEvaluations() < 80);        Assert.assertTrue(optimum.getValue() < 1.0e-6);    }    @Test    public void testLeastSquares2() {        final RealMatrix factors =            new Array2DRowRealMatrix(new double[][] {                    { 1, 0 },                    { 0, 1 }                }, false);        LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {                public double[] value(double[] variables) {                    return factors.operate(variables);                }            }, new double[] { 2, -3 }, new double[] { 10, 0.1 });        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6);        optimizer.setSimplex(new NelderMeadSimplex(2));        RealPointValuePair optimum =            optimizer.optimize(200, ls, GoalType.MINIMIZE, new double[] { 10, 10 });        Assert.assertEquals( 2, optimum.getPointRef()[0], 5e-5);        Assert.assertEquals(-3, optimum.getPointRef()[1], 8e-4);        Assert.assertTrue(optimizer.getEvaluations() > 60);        Assert.assertTrue(optimizer.getEvaluations() < 80);        Assert.assertTrue(optimum.getValue() < 1e-6);    }    @Test    public void testLeastSquares3() {        final RealMatrix factors =            new Array2DRowRealMatrix(new double[][] {                    { 1, 0 },                    { 0, 1 }                }, false);        LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {                public double[] value(double[] variables) {                    return factors.operate(variables);                }            }, new double[] { 2, -3 }, new Array2DRowRealMatrix(new double [][] {                    { 1, 1.2 }, { 1.2, 2 }                }));        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6);        optimizer.setSimplex(new NelderMeadSimplex(2));        RealPointValuePair optimum =            optimizer.optimize(200, ls, GoalType.MINIMIZE, new double[] { 10, 10 });        Assert.assertEquals( 2, optimum.getPointRef()[0], 2e-3);        Assert.assertEquals(-3, optimum.getPointRef()[1], 8e-4);        Assert.assertTrue(optimizer.getEvaluations() > 60);        Assert.assertTrue(optimizer.getEvaluations() < 80);        Assert.assertTrue(optimum.getValue() < 1e-6);    }    @Test(expected = TooManyEvaluationsException.class)    public void testMaxIterations() {        Powell powell = new Powell();        SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);        optimizer.setSimplex(new NelderMeadSimplex(4));        optimizer.optimize(20, powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 });    }    private static class FourExtrema implements MultivariateRealFunction {        // The following function has 4 local extrema.        final double xM = -3.841947088256863675365;        final double yM = -1.391745200270734924416;        final double xP =  0.2286682237349059125691;        final double yP = -yM;        final double valueXmYm = 0.2373295333134216789769; // Local maximum.        final double valueXmYp = -valueXmYm; // Local minimum.        final double valueXpYm = -0.7290400707055187115322; // Global minimum.        final double valueXpYp = -valueXpYm; // Global maximum.        public double value(double[] variables) {            final double x = variables[0];            final double y = variables[1];            return (x == 0 || y == 0) ? 0 :                FastMath.atan(x) * FastMath.atan(x + 2) * FastMath.atan(y) * FastMath.atan(y) / (x * y);        }    }    private static class Rosenbrock implements MultivariateRealFunction {        private int count;        public Rosenbrock() {            count = 0;        }        public double value(double[] x) {            ++count;            double a = x[1] - x[0] * x[0];            double b = 1.0 - x[0];            return 100 * a * a + b * b;        }        public int getCount() {            return count;        }    }    private static class Powell implements MultivariateRealFunction {        private int count;        public Powell() {            count = 0;        }        public double value(double[] x) {            ++count;            double a = x[0] + 10 * x[1];            double b = x[2] - x[3];            double c = x[1] - 2 * x[2];            double d = x[0] - x[3];            return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;        }        public int getCount() {            return count;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.direct;import java.util.Arrays;import java.util.Random;import org.apache.commons.math.Retry;import org.apache.commons.math.RetryRunner;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.exception.MultiDimensionMismatchException;import org.apache.commons.math.exception.NoDataException;import org.apache.commons.math.exception.NotPositiveException;import org.apache.commons.math.exception.OutOfRangeException;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.optimization.MultivariateRealOptimizer;import org.apache.commons.math.optimization.RealPointValuePair;import org.apache.commons.math.random.MersenneTwister;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;/** * Test for {@link CMAESOptimizer}. */@RunWith(RetryRunner.class)public class CMAESOptimizerTest {    static final int DIM = 13;    static final int LAMBDA = 4 + (int)(3.*Math.log(DIM));       @Test(expected = OutOfRangeException.class)    public void testInitOutofbounds() {        double[] startPoint = point(DIM,3);        double[] insigma = null;        double[][] boundaries = boundaries(DIM,-1,2);        RealPointValuePair expected =            new RealPointValuePair(point(DIM,1.0),0.0);        doTest(new Rosen(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                1e-13, 1e-6, 100000, expected);    }        @Test(expected = MultiDimensionMismatchException.class)    public void testBoundariesDimensionMismatch() {        double[] startPoint = point(DIM,0.5);        double[] insigma = null;        double[][] boundaries = boundaries(DIM+1,-1,2);        RealPointValuePair expected =            new RealPointValuePair(point(DIM,1.0),0.0);        doTest(new Rosen(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                1e-13, 1e-6, 100000, expected);    }    @Test(expected = NoDataException.class)    public void testBoundariesNoData() {        double[] startPoint = point(DIM,0.5);        double[] insigma = null;        double[][] boundaries = boundaries(DIM,-1,2);        boundaries[1] = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,1.0),0.0);        doTest(new Rosen(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                1e-13, 1e-6, 100000, expected);    }    @Test(expected = NotPositiveException.class)    public void testInputSigmaNegative() {        double[] startPoint = point(DIM,0.5);        double[] insigma = point(DIM,-0.5);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,1.0),0.0);        doTest(new Rosen(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                1e-13, 1e-6, 100000, expected);    }    @Test(expected = OutOfRangeException.class)    public void testInputSigmaOutOfRange() {        double[] startPoint = point(DIM,0.5);        double[] insigma = point(DIM, 1.1);        double[][] boundaries = boundaries(DIM,-1,2);        RealPointValuePair expected =            new RealPointValuePair(point(DIM,1.0),0.0);        doTest(new Rosen(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                1e-13, 1e-6, 100000, expected);    }    @Test(expected = MultiDimensionMismatchException.class)    public void testInputSigmaDimensionMismatch() {        double[] startPoint = point(DIM,0.5);        double[] insigma = point(DIM+1,-0.5);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,1.0),0.0);        doTest(new Rosen(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                1e-13, 1e-6, 100000, expected);    }        @Test    @Retry(3)    public void testRosen() {        double[] startPoint = point(DIM,0.1);        double[] insigma = point(DIM,0.1);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,1.0),0.0);        doTest(new Rosen(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                1e-13, 1e-6, 100000, expected);        doTest(new Rosen(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,                1e-13, 1e-6, 100000, expected);    }    @Test    @Retry(3)    public void testMaximize() {        double[] startPoint = point(DIM,1.0);        double[] insigma = point(DIM,0.1);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),1.0);        doTest(new MinusElli(), startPoint, insigma, boundaries,                GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13,                2e-10, 5e-6, 100000, expected);        doTest(new MinusElli(), startPoint, insigma, boundaries,                GoalType.MAXIMIZE, LAMBDA, false, 0, 1.0-1e-13,                2e-10, 5e-6, 100000, expected);        boundaries = boundaries(DIM,-0.3,0.3);         startPoint = point(DIM,0.1);        doTest(new MinusElli(), startPoint, insigma, boundaries,                GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13,                2e-10, 5e-6, 100000, expected);    }    @Test    public void testEllipse() {        double[] startPoint = point(DIM,1.0);        double[] insigma = point(DIM,0.1);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new Elli(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                1e-13, 1e-6, 100000, expected);        doTest(new Elli(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,                1e-13, 1e-6, 100000, expected);    }    @Test    public void testElliRotated() {        double[] startPoint = point(DIM,1.0);        double[] insigma = point(DIM,0.1);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new ElliRotated(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                1e-13, 1e-6, 100000, expected);        doTest(new ElliRotated(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,                1e-13, 1e-6, 100000, expected);    }    @Test    public void testCigar() {        double[] startPoint = point(DIM,1.0);        double[] insigma = point(DIM,0.1);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new Cigar(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                1e-13, 1e-6, 200000, expected);        doTest(new Cigar(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,                1e-13, 1e-6, 100000, expected);    }    @Test    public void testTwoAxes() {        double[] startPoint = point(DIM,1.0);        double[] insigma = point(DIM,0.1);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new TwoAxes(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,                1e-13, 1e-6, 200000, expected);        doTest(new TwoAxes(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,                1e-8, 1e-3, 200000, expected);    }    @Test    public void testCigTab() {        double[] startPoint = point(DIM,1.0);        double[] insigma = point(DIM,0.3);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new CigTab(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                1e-13, 5e-5, 100000, expected);        doTest(new CigTab(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,                1e-13, 5e-5, 100000, expected);    }    @Test    public void testSphere() {        double[] startPoint = point(DIM,1.0);        double[] insigma = point(DIM,0.1);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new Sphere(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                1e-13, 1e-6, 100000, expected);        doTest(new Sphere(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,                1e-13, 1e-6, 100000, expected);    }    @Test    public void testTablet() {        double[] startPoint = point(DIM,1.0);        double[] insigma = point(DIM,0.1);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new Tablet(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,                1e-13, 1e-6, 100000, expected);        doTest(new Tablet(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,                1e-13, 1e-6, 100000, expected);    }    @Test    public void testDiffPow() {        double[] startPoint = point(DIM,1.0);        double[] insigma = point(DIM,0.1);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new DiffPow(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, 10, true, 0, 1e-13,                1e-8, 1e-1, 100000, expected);        doTest(new DiffPow(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, 10, false, 0, 1e-13,                1e-8, 2e-1, 100000, expected);    }    @Test    public void testSsDiffPow() {        double[] startPoint = point(DIM,1.0);        double[] insigma = point(DIM,0.1);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new SsDiffPow(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, 10, true, 0, 1e-13,                1e-4, 1e-1, 200000, expected);        doTest(new SsDiffPow(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, 10, false, 0, 1e-13,                1e-4, 1e-1, 200000, expected);    }    @Test    public void testAckley() {        double[] startPoint = point(DIM,1.0);        double[] insigma = point(DIM,1.0);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new Ackley(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,                1e-9, 1e-5, 100000, expected);        doTest(new Ackley(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,                1e-9, 1e-5, 100000, expected);    }    @Test    public void testRastrigin() {        double[] startPoint = point(DIM,0.1);        double[] insigma = point(DIM,0.1);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,0.0),0.0);        doTest(new Rastrigin(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, (int)(200*Math.sqrt(DIM)), true, 0, 1e-13,                1e-13, 1e-6, 200000, expected);        doTest(new Rastrigin(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, (int)(200*Math.sqrt(DIM)), false, 0, 1e-13,                1e-13, 1e-6, 200000, expected);    }    @Test    public void testConstrainedRosen() {        double[] startPoint = point(DIM,0.1);        double[] insigma = point(DIM,0.1);        double[][] boundaries = boundaries(DIM,-1,2);        RealPointValuePair expected =            new RealPointValuePair(point(DIM,1.0),0.0);        doTest(new Rosen(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,                1e-13, 1e-6, 100000, expected);        doTest(new Rosen(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,                1e-13, 1e-6, 100000, expected);    }    @Test    public void testDiagonalRosen() {        double[] startPoint = point(DIM,0.1);        double[] insigma = point(DIM,0.1);        double[][] boundaries = null;        RealPointValuePair expected =            new RealPointValuePair(point(DIM,1.0),0.0);        doTest(new Rosen(), startPoint, insigma, boundaries,                GoalType.MINIMIZE, LAMBDA, false, 1, 1e-13,                1e-10, 1e-4, 1000000, expected);     }    /**     * @param func Function to optimize.     * @param startPoint Starting point.     * @param inSigma Individual input sigma.     * @param boundaries Upper / lower point limit.     * @param goal Minimization or maximization.     * @param lambda Population size used for offspring.     * @param isActive Covariance update mechanism.     * @param diagonalOnly Simplified covariance update.     * @param stopValue Termination criteria for optimization.     * @param fTol Tolerance relative error on the objective function.     * @param pointTol Tolerance for checking that the optimum is correct.     * @param maxEvaluations Maximum number of evaluations.     * @param expected Expected point / value.     */    private void doTest(MultivariateRealFunction func,            double[] startPoint,            double[] inSigma,            double[][] boundaries,            GoalType goal,            int lambda,            boolean isActive,            int diagonalOnly,             double stopValue,            double fTol,            double pointTol,            int maxEvaluations,            RealPointValuePair expected) {        int dim = startPoint.length;        // test diagonalOnly = 0 - slow but normally fewer feval#        MultivariateRealOptimizer optim =            new CMAESOptimizer(                    lambda, inSigma, boundaries, 30000,                    stopValue, isActive, diagonalOnly, 0, new MersenneTwister(),false);        RealPointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint);        Assert.assertEquals(expected.getValue(),                result.getValue(), fTol);        for (int i = 0; i < dim; i++) {            Assert.assertEquals(expected.getPoint()[i],                    result.getPoint()[i], pointTol);        }    }    private static double[] point(int n, double value) {        double[] ds = new double[n];        Arrays.fill(ds, value);        return ds;    }    private static double[][] boundaries(int dim,            double lower, double upper) {        double[][] boundaries = new double[2][dim];        for (int i = 0; i < dim; i++)            boundaries[0][i] = lower;        for (int i = 0; i < dim; i++)            boundaries[1][i] = upper;        return boundaries;    }    private static class Sphere implements MultivariateRealFunction {        public double value(double[] x) {            double f = 0;            for (int i = 0; i < x.length; ++i)                f += x[i] * x[i];            return f;        }    }    private static class Cigar implements MultivariateRealFunction {        private double factor;        Cigar() {            this(1e3);        }        Cigar(double axisratio) {            factor = axisratio * axisratio;        }        public double value(double[] x) {            double f = x[0] * x[0];            for (int i = 1; i < x.length; ++i)                f += factor * x[i] * x[i];            return f;        }    }    private static class Tablet implements MultivariateRealFunction {        private double factor;        Tablet() {            this(1e3);        }        Tablet(double axisratio) {            factor = axisratio * axisratio;        }        public double value(double[] x) {            double f = factor * x[0] * x[0];            for (int i = 1; i < x.length; ++i)                f += x[i] * x[i];            return f;        }    }    private static class CigTab implements MultivariateRealFunction {        private double factor;        CigTab() {            this(1e4);        }        CigTab(double axisratio) {            factor = axisratio;        }        public double value(double[] x) {            int end = x.length - 1;            double f = x[0] * x[0] / factor + factor * x[end] * x[end];            for (int i = 1; i < end; ++i)                f += x[i] * x[i];            return f;        }    }    private static class TwoAxes implements MultivariateRealFunction {        private double factor;        TwoAxes() {            this(1e6);        }        TwoAxes(double axisratio) {            factor = axisratio * axisratio;        }        public double value(double[] x) {            double f = 0;            for (int i = 0; i < x.length; ++i)                f += (i < x.length / 2 ? factor : 1) * x[i] * x[i];            return f;        }    }    private static class ElliRotated implements MultivariateRealFunction {        private Basis B = new Basis();        private double factor;        ElliRotated() {            this(1e3);        }        ElliRotated(double axisratio) {            factor = axisratio * axisratio;        }        public double value(double[] x) {            double f = 0;            x = B.Rotate(x);            for (int i = 0; i < x.length; ++i)                f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i];            return f;        }    }    private static class Elli implements MultivariateRealFunction {        private double factor;        Elli() {            this(1e3);        }        Elli(double axisratio) {            factor = axisratio * axisratio;        }        public double value(double[] x) {            double f = 0;            for (int i = 0; i < x.length; ++i)                f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i];            return f;        }    }    private static class MinusElli implements MultivariateRealFunction {        public double value(double[] x) {            return 1.0-(new Elli().value(x));        }    }    private static class DiffPow implements MultivariateRealFunction {        public double value(double[] x) {            double f = 0;            for (int i = 0; i < x.length; ++i)                f += Math.pow(Math.abs(x[i]), 2. + 10 * (double) i                        / (x.length - 1.));            return f;        }    }    private static class SsDiffPow implements MultivariateRealFunction {        public double value(double[] x) {            double f = Math.pow(new DiffPow().value(x), 0.25);            return f;        }    }    private static class Rosen implements MultivariateRealFunction {        public double value(double[] x) {            double f = 0;            for (int i = 0; i < x.length - 1; ++i)                f += 1e2 * (x[i] * x[i] - x[i + 1]) * (x[i] * x[i] - x[i + 1])                + (x[i] - 1.) * (x[i] - 1.);            return f;        }    }    private static class Ackley implements MultivariateRealFunction {        private double axisratio;        Ackley(double axra) {            axisratio = axra;        }        public Ackley() {            this(1);        }        public double value(double[] x) {            double f = 0;            double res2 = 0;            double fac = 0;            for (int i = 0; i < x.length; ++i) {                fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.));                f += fac * fac * x[i] * x[i];                res2 += Math.cos(2. * Math.PI * fac * x[i]);            }            f = (20. - 20. * Math.exp(-0.2 * Math.sqrt(f / x.length))                    + Math.exp(1.) - Math.exp(res2 / x.length));            return f;        }    }    private static class Rastrigin implements MultivariateRealFunction {        private double axisratio;        private double amplitude;        Rastrigin() {            this(1, 10);        }        Rastrigin(double axisratio, double amplitude) {            this.axisratio = axisratio;            this.amplitude = amplitude;        }        public double value(double[] x) {            double f = 0;            double fac;            for (int i = 0; i < x.length; ++i) {                fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.));                if (i == 0 && x[i] < 0)                    fac *= 1.;                f += fac * fac * x[i] * x[i] + amplitude                * (1. - Math.cos(2. * Math.PI * fac * x[i]));            }            return f;        }    }    private static class Basis {        double[][] basis;        Random rand = new Random(2); // use not always the same basis        double[] Rotate(double[] x) {            GenBasis(x.length);            double[] y = new double[x.length];            for (int i = 0; i < x.length; ++i) {                y[i] = 0;                for (int j = 0; j < x.length; ++j)                    y[i] += basis[i][j] * x[j];            }            return y;        }        void GenBasis(int DIM) {            if (basis != null ? basis.length == DIM : false)                return;            double sp;            int i, j, k;            /* generate orthogonal basis */            basis = new double[DIM][DIM];            for (i = 0; i < DIM; ++i) {                /* sample components gaussian */                for (j = 0; j < DIM; ++j)                    basis[i][j] = rand.nextGaussian();                /* substract projection of previous vectors */                for (j = i - 1; j >= 0; --j) {                    for (sp = 0., k = 0; k < DIM; ++k)                        sp += basis[i][k] * basis[j][k]; /* scalar product */                    for (k = 0; k < DIM; ++k)                        basis[i][k] -= sp * basis[j][k]; /* substract */                }                /* normalize */                for (sp = 0., k = 0; k < DIM; ++k)                    sp += basis[i][k] * basis[i][k]; /* squared norm */                for (k = 0; k < DIM; ++k)                    basis[i][k] /= Math.sqrt(sp);            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.linear;import java.util.ArrayList;import java.util.Collection;import org.apache.commons.math.TestUtils;import org.apache.commons.math.optimization.GoalType;import org.junit.Assert;import org.junit.Test;public class SimplexTableauTest {    @Test    public void testInitialization() {        LinearObjectiveFunction f = createFunction();        Collection<LinearConstraint> constraints = createConstraints();        SimplexTableau tableau =            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);        double[][] expectedInitialTableau = {                                             {-1, 0,  -1,  -1,  2, 0, 0, 0, -4},                                             { 0, 1, -15, -10, 25, 0, 0, 0,  0},                                             { 0, 0,   1,   0, -1, 1, 0, 0,  2},                                             { 0, 0,   0,   1, -1, 0, 1, 0,  3},                                             { 0, 0,   1,   1, -2, 0, 0, 1,  4}        };        assertMatrixEquals(expectedInitialTableau, tableau.getData());    }    @Test    public void testDropPhase1Objective() {        LinearObjectiveFunction f = createFunction();        Collection<LinearConstraint> constraints = createConstraints();        SimplexTableau tableau =            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);        double[][] expectedTableau = {                                      { 1, -15, -10, 0, 0, 0, 0},                                      { 0,   1,   0, 1, 0, 0, 2},                                      { 0,   0,   1, 0, 1, 0, 3},                                      { 0,   1,   1, 0, 0, 1, 4}        };        tableau.dropPhase1Objective();        assertMatrixEquals(expectedTableau, tableau.getData());    }    @Test    public void testTableauWithNoArtificialVars() {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {15, 10}, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.LEQ, 2));        constraints.add(new LinearConstraint(new double[] {0, 1}, Relationship.LEQ, 3));        constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.LEQ, 4));        SimplexTableau tableau =            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);        double[][] initialTableau = {                                     {1, -15, -10, 25, 0, 0, 0, 0},                                     {0,   1,   0, -1, 1, 0, 0, 2},                                     {0,   0,   1, -1, 0, 1, 0, 3},                                     {0,   1,   1, -2, 0, 0, 1, 4}        };        assertMatrixEquals(initialTableau, tableau.getData());    }    @Test    public void testSerial() {        LinearObjectiveFunction f = createFunction();        Collection<LinearConstraint> constraints = createConstraints();        SimplexTableau tableau =            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);        Assert.assertEquals(tableau, TestUtils.serializeAndRecover(tableau));    }    private LinearObjectiveFunction createFunction() {        return new LinearObjectiveFunction(new double[] {15, 10}, 0);    }    private Collection<LinearConstraint> createConstraints() {        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.LEQ, 2));        constraints.add(new LinearConstraint(new double[] {0, 1}, Relationship.LEQ, 3));        constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.EQ, 4));        return constraints;    }    private void assertMatrixEquals(double[][] expected, double[][] result) {        Assert.assertEquals("Wrong number of rows.", expected.length, result.length);        for (int i = 0; i < expected.length; i++) {            Assert.assertEquals("Wrong number of columns.", expected[i].length, result[i].length);            for (int j = 0; j < expected[i].length; j++) {                Assert.assertEquals("Wrong value at position [" + i + "," + j + "]", expected[i][j], result[i][j], 1.0e-15);            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.linear;import org.junit.Assert;import java.util.ArrayList;import java.util.Collection;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.optimization.OptimizationException;import org.apache.commons.math.optimization.RealPointValuePair;import org.apache.commons.math.util.MathUtils;import org.junit.Test;public class SimplexSolverTest {    @Test    public void testMath434NegativeVariable() throws OptimizationException    {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {0.0, 0.0, 1.0}, 0.0d);        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] {1, 1, 0}, Relationship.EQ, 5));        constraints.add(new LinearConstraint(new double[] {0, 0, 1}, Relationship.GEQ, -10));        double epsilon = 1e-6;        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);        Assert.assertEquals(5.0, solution.getPoint()[0] + solution.getPoint()[1], epsilon);        Assert.assertEquals(-10.0, solution.getPoint()[2], epsilon);        Assert.assertEquals(-10.0, solution.getValue(), epsilon);    }    @Test(expected = NoFeasibleSolutionException.class)    public void testMath434UnfeasibleSolution() throws OptimizationException    {        double epsilon = 1e-6;        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0, 0.0}, 0.0);        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] {epsilon/2, 0.5}, Relationship.EQ, 0));        constraints.add(new LinearConstraint(new double[] {1e-3, 0.1}, Relationship.EQ, 10));        SimplexSolver solver = new SimplexSolver();        // allowing only non-negative values, no feasible solution shall be found        solver.optimize(f, constraints, GoalType.MINIMIZE, true);    }    @Test    public void testMath434PivotRowSelection() throws OptimizationException    {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0}, 0.0);        double epsilon = 1e-6;        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] {200}, Relationship.GEQ, 1));        constraints.add(new LinearConstraint(new double[] {100}, Relationship.GEQ, 0.499900001));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);                Assert.assertTrue(MathUtils.compareTo(solution.getPoint()[0] * 200.d, 1.d, epsilon) >= 0);        Assert.assertEquals(0.0050, solution.getValue(), epsilon);    }    @Test    public void testMath434PivotRowSelection2() throws OptimizationException    {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {0.0d, 1.0d, 1.0d, 0.0d, 0.0d, 0.0d, 0.0d}, 0.0d);        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] {1.0d, -0.1d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.EQ, -0.1d));        constraints.add(new LinearConstraint(new double[] {1.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, -1e-18d));        constraints.add(new LinearConstraint(new double[] {0.0d, 1.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 0.0d, 1.0d, 0.0d, -0.0128588d, 1e-5d}, Relationship.EQ, 0.0d));        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 0.0d, 0.0d, 1.0d, 1e-5d, -0.0128586d}, Relationship.EQ, 1e-10d));        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, -1.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 1.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 0.0d, -1.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));        constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 0.0d, 1.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d));        double epsilon = 1e-7;        SimplexSolver simplex = new SimplexSolver();        RealPointValuePair solution = simplex.optimize(f, constraints, GoalType.MINIMIZE, false);                Assert.assertTrue(MathUtils.compareTo(solution.getPoint()[0], -1e-18d, epsilon) >= 0);        Assert.assertEquals(1.0d, solution.getPoint()[1], epsilon);                Assert.assertEquals(0.0d, solution.getPoint()[2], epsilon);        Assert.assertEquals(1.0d, solution.getValue(), epsilon);    }        @Test    public void testMath272() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 1, 0 }, Relationship.GEQ,  1));        constraints.add(new LinearConstraint(new double[] { 1, 0, 1 }, Relationship.GEQ,  1));        constraints.add(new LinearConstraint(new double[] { 0, 1, 0 }, Relationship.GEQ,  1));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);        Assert.assertEquals(0.0, solution.getPoint()[0], .0000001);        Assert.assertEquals(1.0, solution.getPoint()[1], .0000001);        Assert.assertEquals(1.0, solution.getPoint()[2], .0000001);        Assert.assertEquals(3.0, solution.getValue(), .0000001);    }    @Test    public void testMath286() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.6, 0.4 }, 0 );        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 23.0));        constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 23.0));        constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0, 0, 0 }, Relationship.GEQ, 10.0));        constraints.add(new LinearConstraint(new double[] { 0, 0, 1, 0, 0, 0 }, Relationship.GEQ, 8.0));        constraints.add(new LinearConstraint(new double[] { 0, 0, 0, 0, 1, 0 }, Relationship.GEQ, 5.0));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);        Assert.assertEquals(25.8, solution.getValue(), .0000001);        Assert.assertEquals(23.0, solution.getPoint()[0] + solution.getPoint()[2] + solution.getPoint()[4], 0.0000001);        Assert.assertEquals(23.0, solution.getPoint()[1] + solution.getPoint()[3] + solution.getPoint()[5], 0.0000001);        Assert.assertTrue(solution.getPoint()[0] >= 10.0 - 0.0000001);        Assert.assertTrue(solution.getPoint()[2] >= 8.0 - 0.0000001);        Assert.assertTrue(solution.getPoint()[4] >= 5.0 - 0.0000001);    }    @Test    public void testDegeneracy() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.7 }, 0 );        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.LEQ, 18.0));        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.GEQ, 10.0));        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.GEQ, 8.0));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);        Assert.assertEquals(13.6, solution.getValue(), .0000001);    }    @Test    public void testMath288() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 7, 3, 0, 0 }, 0 );        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 3, 0, -5, 0 }, Relationship.LEQ, 0.0));        constraints.add(new LinearConstraint(new double[] { 2, 0, 0, -5 }, Relationship.LEQ, 0.0));        constraints.add(new LinearConstraint(new double[] { 0, 3, 0, -5 }, Relationship.LEQ, 0.0));        constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0 }, Relationship.LEQ, 1.0));        constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 0 }, Relationship.LEQ, 1.0));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);        Assert.assertEquals(10.0, solution.getValue(), .0000001);    }    @Test    public void testMath290GEQ() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 5 }, 0 );        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 2, 0 }, Relationship.GEQ, -1.0));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);        Assert.assertEquals(0, solution.getValue(), .0000001);        Assert.assertEquals(0, solution.getPoint()[0], .0000001);        Assert.assertEquals(0, solution.getPoint()[1], .0000001);    }    @Test(expected=NoFeasibleSolutionException.class)    public void testMath290LEQ() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 5 }, 0 );        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 2, 0 }, Relationship.LEQ, -1.0));        SimplexSolver solver = new SimplexSolver();        solver.optimize(f, constraints, GoalType.MINIMIZE, true);    }    @Test    public void testMath293() throws OptimizationException {      LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.4, 0.6}, 0 );      Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();      constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 30.0));      constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 30.0));      constraints.add(new LinearConstraint(new double[] { 0.8, 0.2, 0.0, 0.0, 0.0, 0.0 }, Relationship.GEQ, 10.0));      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.7, 0.3, 0.0, 0.0 }, Relationship.GEQ, 10.0));      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, 10.0));      SimplexSolver solver = new SimplexSolver();      RealPointValuePair solution1 = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);      Assert.assertEquals(15.7143, solution1.getPoint()[0], .0001);      Assert.assertEquals(0.0, solution1.getPoint()[1], .0001);      Assert.assertEquals(14.2857, solution1.getPoint()[2], .0001);      Assert.assertEquals(0.0, solution1.getPoint()[3], .0001);      Assert.assertEquals(0.0, solution1.getPoint()[4], .0001);      Assert.assertEquals(30.0, solution1.getPoint()[5], .0001);      Assert.assertEquals(40.57143, solution1.getValue(), .0001);      double valA = 0.8 * solution1.getPoint()[0] + 0.2 * solution1.getPoint()[1];      double valB = 0.7 * solution1.getPoint()[2] + 0.3 * solution1.getPoint()[3];      double valC = 0.4 * solution1.getPoint()[4] + 0.6 * solution1.getPoint()[5];      f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.4, 0.6}, 0 );      constraints = new ArrayList<LinearConstraint>();      constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 30.0));      constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 30.0));      constraints.add(new LinearConstraint(new double[] { 0.8, 0.2, 0.0, 0.0, 0.0, 0.0 }, Relationship.GEQ, valA));      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.7, 0.3, 0.0, 0.0 }, Relationship.GEQ, valB));      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, valC));      RealPointValuePair solution2 = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);      Assert.assertEquals(40.57143, solution2.getValue(), .0001);    }    @Test    public void testSimplexSolver() throws OptimizationException {        LinearObjectiveFunction f =            new LinearObjectiveFunction(new double[] { 15, 10 }, 7);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2));        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.LEQ, 3));        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 4));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);        Assert.assertEquals(2.0, solution.getPoint()[0], 0.0);        Assert.assertEquals(2.0, solution.getPoint()[1], 0.0);        Assert.assertEquals(57.0, solution.getValue(), 0.0);    }    @Test    public void testSingleVariableAndConstraint() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 3 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 10));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);        Assert.assertEquals(10.0, solution.getPoint()[0], 0.0);        Assert.assertEquals(30.0, solution.getValue(), 0.0);    }    /**     * With no artificial variables needed (no equals and no greater than     * constraints) we can go straight to Phase 2.     */    @Test    public void testModelWithNoArtificialVars() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2));        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.LEQ, 3));        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.LEQ, 4));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);        Assert.assertEquals(2.0, solution.getPoint()[0], 0.0);        Assert.assertEquals(2.0, solution.getPoint()[1], 0.0);        Assert.assertEquals(50.0, solution.getValue(), 0.0);    }    @Test    public void testMinimization() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, -5);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 6));        constraints.add(new LinearConstraint(new double[] { 3, 2 }, Relationship.LEQ, 12));        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.GEQ, 0));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);        Assert.assertEquals(4.0, solution.getPoint()[0], 0.0);        Assert.assertEquals(0.0, solution.getPoint()[1], 0.0);        Assert.assertEquals(-13.0, solution.getValue(), 0.0);    }    @Test    public void testSolutionWithNegativeDecisionVariable() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.GEQ, 6));        constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 14));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);        Assert.assertEquals(-2.0, solution.getPoint()[0], 0.0);        Assert.assertEquals(8.0, solution.getPoint()[1], 0.0);        Assert.assertEquals(12.0, solution.getValue(), 0.0);    }    @Test(expected = NoFeasibleSolutionException.class)    public void testInfeasibleSolution() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 1));        constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.GEQ, 3));        SimplexSolver solver = new SimplexSolver();        solver.optimize(f, constraints, GoalType.MAXIMIZE, false);    }    @Test(expected = UnboundedSolutionException.class)    public void testUnboundedSolution() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.EQ, 2));        SimplexSolver solver = new SimplexSolver();        solver.optimize(f, constraints, GoalType.MAXIMIZE, false);    }    @Test    public void testRestrictVariablesToNonNegative() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 409, 523, 70, 204, 339 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] {    43,   56, 345,  56,    5 }, Relationship.LEQ,  4567456));        constraints.add(new LinearConstraint(new double[] {    12,   45,   7,  56,   23 }, Relationship.LEQ,    56454));        constraints.add(new LinearConstraint(new double[] {     8,  768,   0,  34, 7456 }, Relationship.LEQ,  1923421));        constraints.add(new LinearConstraint(new double[] { 12342, 2342,  34, 678, 2342 }, Relationship.GEQ,     4356));        constraints.add(new LinearConstraint(new double[] {    45,  678,  76,  52,   23 }, Relationship.EQ,    456356));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);        Assert.assertEquals(2902.92783505155, solution.getPoint()[0], .0000001);        Assert.assertEquals(480.419243986254, solution.getPoint()[1], .0000001);        Assert.assertEquals(0.0, solution.getPoint()[2], .0000001);        Assert.assertEquals(0.0, solution.getPoint()[3], .0000001);        Assert.assertEquals(0.0, solution.getPoint()[4], .0000001);        Assert.assertEquals(1438556.7491409, solution.getValue(), .0000001);    }    @Test    public void testEpsilon() throws OptimizationException {      LinearObjectiveFunction f =          new LinearObjectiveFunction(new double[] { 10, 5, 1 }, 0);      Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();      constraints.add(new LinearConstraint(new double[] {  9, 8, 0 }, Relationship.EQ,  17));      constraints.add(new LinearConstraint(new double[] {  0, 7, 8 }, Relationship.LEQ,  7));      constraints.add(new LinearConstraint(new double[] { 10, 0, 2 }, Relationship.LEQ, 10));      SimplexSolver solver = new SimplexSolver();      RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);      Assert.assertEquals(1.0, solution.getPoint()[0], 0.0);      Assert.assertEquals(1.0, solution.getPoint()[1], 0.0);      Assert.assertEquals(0.0, solution.getPoint()[2], 0.0);      Assert.assertEquals(15.0, solution.getValue(), 0.0);  }    @Test    public void testTrivialModel() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 1 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ,  0));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);        Assert.assertEquals(0, solution.getValue(), .0000001);    }    @Test    public void testLargeModel() throws OptimizationException {        double[] objective = new double[] {                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 12, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           12, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 12, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 12, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 12, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 12, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1};        LinearObjectiveFunction f = new LinearObjectiveFunction(objective, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(equationFromString(objective.length, "x0 + x1 + x2 + x3 - x12 = 0"));        constraints.add(equationFromString(objective.length, "x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 - x13 = 0"));        constraints.add(equationFromString(objective.length, "x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 >= 49"));        constraints.add(equationFromString(objective.length, "x0 + x1 + x2 + x3 >= 42"));        constraints.add(equationFromString(objective.length, "x14 + x15 + x16 + x17 - x26 = 0"));        constraints.add(equationFromString(objective.length, "x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x27 = 0"));        constraints.add(equationFromString(objective.length, "x14 + x15 + x16 + x17 - x12 = 0"));        constraints.add(equationFromString(objective.length, "x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x13 = 0"));        constraints.add(equationFromString(objective.length, "x28 + x29 + x30 + x31 - x40 = 0"));        constraints.add(equationFromString(objective.length, "x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 - x41 = 0"));        constraints.add(equationFromString(objective.length, "x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 >= 49"));        constraints.add(equationFromString(objective.length, "x28 + x29 + x30 + x31 >= 42"));        constraints.add(equationFromString(objective.length, "x42 + x43 + x44 + x45 - x54 = 0"));        constraints.add(equationFromString(objective.length, "x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x55 = 0"));        constraints.add(equationFromString(objective.length, "x42 + x43 + x44 + x45 - x40 = 0"));        constraints.add(equationFromString(objective.length, "x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x41 = 0"));        constraints.add(equationFromString(objective.length, "x56 + x57 + x58 + x59 - x68 = 0"));        constraints.add(equationFromString(objective.length, "x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 - x69 = 0"));        constraints.add(equationFromString(objective.length, "x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 >= 51"));        constraints.add(equationFromString(objective.length, "x56 + x57 + x58 + x59 >= 44"));        constraints.add(equationFromString(objective.length, "x70 + x71 + x72 + x73 - x82 = 0"));        constraints.add(equationFromString(objective.length, "x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x83 = 0"));        constraints.add(equationFromString(objective.length, "x70 + x71 + x72 + x73 - x68 = 0"));        constraints.add(equationFromString(objective.length, "x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x69 = 0"));        constraints.add(equationFromString(objective.length, "x84 + x85 + x86 + x87 - x96 = 0"));        constraints.add(equationFromString(objective.length, "x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 - x97 = 0"));        constraints.add(equationFromString(objective.length, "x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 >= 51"));        constraints.add(equationFromString(objective.length, "x84 + x85 + x86 + x87 >= 44"));        constraints.add(equationFromString(objective.length, "x98 + x99 + x100 + x101 - x110 = 0"));        constraints.add(equationFromString(objective.length, "x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x111 = 0"));        constraints.add(equationFromString(objective.length, "x98 + x99 + x100 + x101 - x96 = 0"));        constraints.add(equationFromString(objective.length, "x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x97 = 0"));        constraints.add(equationFromString(objective.length, "x112 + x113 + x114 + x115 - x124 = 0"));        constraints.add(equationFromString(objective.length, "x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 - x125 = 0"));        constraints.add(equationFromString(objective.length, "x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 >= 49"));        constraints.add(equationFromString(objective.length, "x112 + x113 + x114 + x115 >= 42"));        constraints.add(equationFromString(objective.length, "x126 + x127 + x128 + x129 - x138 = 0"));        constraints.add(equationFromString(objective.length, "x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x139 = 0"));        constraints.add(equationFromString(objective.length, "x126 + x127 + x128 + x129 - x124 = 0"));        constraints.add(equationFromString(objective.length, "x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x125 = 0"));        constraints.add(equationFromString(objective.length, "x140 + x141 + x142 + x143 - x152 = 0"));        constraints.add(equationFromString(objective.length, "x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 - x153 = 0"));        constraints.add(equationFromString(objective.length, "x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 >= 59"));        constraints.add(equationFromString(objective.length, "x140 + x141 + x142 + x143 >= 42"));        constraints.add(equationFromString(objective.length, "x154 + x155 + x156 + x157 - x166 = 0"));        constraints.add(equationFromString(objective.length, "x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x167 = 0"));        constraints.add(equationFromString(objective.length, "x154 + x155 + x156 + x157 - x152 = 0"));        constraints.add(equationFromString(objective.length, "x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x153 = 0"));        constraints.add(equationFromString(objective.length, "x83 + x82 - x168 = 0"));        constraints.add(equationFromString(objective.length, "x111 + x110 - x169 = 0"));        constraints.add(equationFromString(objective.length, "x170 - x182 = 0"));        constraints.add(equationFromString(objective.length, "x171 - x183 = 0"));        constraints.add(equationFromString(objective.length, "x172 - x184 = 0"));        constraints.add(equationFromString(objective.length, "x173 - x185 = 0"));        constraints.add(equationFromString(objective.length, "x174 - x186 = 0"));        constraints.add(equationFromString(objective.length, "x175 + x176 - x187 = 0"));        constraints.add(equationFromString(objective.length, "x177 - x188 = 0"));        constraints.add(equationFromString(objective.length, "x178 - x189 = 0"));        constraints.add(equationFromString(objective.length, "x179 - x190 = 0"));        constraints.add(equationFromString(objective.length, "x180 - x191 = 0"));        constraints.add(equationFromString(objective.length, "x181 - x192 = 0"));        constraints.add(equationFromString(objective.length, "x170 - x26 = 0"));        constraints.add(equationFromString(objective.length, "x171 - x27 = 0"));        constraints.add(equationFromString(objective.length, "x172 - x54 = 0"));        constraints.add(equationFromString(objective.length, "x173 - x55 = 0"));        constraints.add(equationFromString(objective.length, "x174 - x168 = 0"));        constraints.add(equationFromString(objective.length, "x177 - x169 = 0"));        constraints.add(equationFromString(objective.length, "x178 - x138 = 0"));        constraints.add(equationFromString(objective.length, "x179 - x139 = 0"));        constraints.add(equationFromString(objective.length, "x180 - x166 = 0"));        constraints.add(equationFromString(objective.length, "x181 - x167 = 0"));        constraints.add(equationFromString(objective.length, "x193 - x205 = 0"));        constraints.add(equationFromString(objective.length, "x194 - x206 = 0"));        constraints.add(equationFromString(objective.length, "x195 - x207 = 0"));        constraints.add(equationFromString(objective.length, "x196 - x208 = 0"));        constraints.add(equationFromString(objective.length, "x197 - x209 = 0"));        constraints.add(equationFromString(objective.length, "x198 + x199 - x210 = 0"));        constraints.add(equationFromString(objective.length, "x200 - x211 = 0"));        constraints.add(equationFromString(objective.length, "x201 - x212 = 0"));        constraints.add(equationFromString(objective.length, "x202 - x213 = 0"));        constraints.add(equationFromString(objective.length, "x203 - x214 = 0"));        constraints.add(equationFromString(objective.length, "x204 - x215 = 0"));        constraints.add(equationFromString(objective.length, "x193 - x182 = 0"));        constraints.add(equationFromString(objective.length, "x194 - x183 = 0"));        constraints.add(equationFromString(objective.length, "x195 - x184 = 0"));        constraints.add(equationFromString(objective.length, "x196 - x185 = 0"));        constraints.add(equationFromString(objective.length, "x197 - x186 = 0"));        constraints.add(equationFromString(objective.length, "x198 + x199 - x187 = 0"));        constraints.add(equationFromString(objective.length, "x200 - x188 = 0"));        constraints.add(equationFromString(objective.length, "x201 - x189 = 0"));        constraints.add(equationFromString(objective.length, "x202 - x190 = 0"));        constraints.add(equationFromString(objective.length, "x203 - x191 = 0"));        constraints.add(equationFromString(objective.length, "x204 - x192 = 0"));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);        Assert.assertEquals(7518.0, solution.getValue(), .0000001);    }    /**     * Converts a test string to a {@link LinearConstraint}.     * Ex: x0 + x1 + x2 + x3 - x12 = 0     */    private LinearConstraint equationFromString(int numCoefficients, String s) {        Relationship relationship;        if (s.contains(">=")) {            relationship = Relationship.GEQ;        } else if (s.contains("<=")) {            relationship = Relationship.LEQ;        } else if (s.contains("=")) {            relationship = Relationship.EQ;        } else {            throw new IllegalArgumentException();        }        String[] equationParts = s.split("[>|<]?=");        double rhs = Double.parseDouble(equationParts[1].trim());        double[] lhs = new double[numCoefficients];        String left = equationParts[0].replaceAll(" ?x", "");        String[] coefficients = left.split(" ");        for (String coefficient : coefficients) {            double value = coefficient.charAt(0) == '-' ? -1 : 1;            int index = Integer.parseInt(coefficient.replaceFirst("[+|-]", "").trim());            lhs[index] = value;        }        return new LinearConstraint(lhs, relationship, rhs);    }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at////   http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.apache.commons.math.optimization.fitting;import java.util.Random;import org.apache.commons.math.analysis.polynomials.PolynomialFunction;import org.apache.commons.math.exception.ConvergenceException;import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;import org.apache.commons.math.util.FastMath;import org.junit.Test;import org.junit.Assert;public class PolynomialFitterTest {    @Test    public void testNoError() {        Random randomizer = new Random(64925784252l);        for (int degree = 1; degree < 10; ++degree) {            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);            PolynomialFitter fitter =                new PolynomialFitter(degree, new LevenbergMarquardtOptimizer());            for (int i = 0; i <= degree; ++i) {                fitter.addObservedPoint(1.0, i, p.value(i));            }            PolynomialFunction fitted = new PolynomialFunction(fitter.fit());            for (double x = -1.0; x < 1.0; x += 0.01) {                double error = FastMath.abs(p.value(x) - fitted.value(x)) /                               (1.0 + FastMath.abs(p.value(x)));                Assert.assertEquals(0.0, error, 1.0e-6);            }        }    }    @Test    public void testSmallError() {        Random randomizer = new Random(53882150042l);        double maxError = 0;        for (int degree = 0; degree < 10; ++degree) {            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);            PolynomialFitter fitter =                new PolynomialFitter(degree, new LevenbergMarquardtOptimizer());            for (double x = -1.0; x < 1.0; x += 0.01) {                fitter.addObservedPoint(1.0, x,                                        p.value(x) + 0.1 * randomizer.nextGaussian());            }            PolynomialFunction fitted = new PolynomialFunction(fitter.fit());            for (double x = -1.0; x < 1.0; x += 0.01) {                double error = FastMath.abs(p.value(x) - fitted.value(x)) /                              (1.0 + FastMath.abs(p.value(x)));                maxError = FastMath.max(maxError, error);                Assert.assertTrue(FastMath.abs(error) < 0.1);            }        }        Assert.assertTrue(maxError > 0.01);    }    @Test    public void testRedundantSolvable() {        // Levenberg-Marquardt should handle redundant information gracefully        checkUnsolvableProblem(new LevenbergMarquardtOptimizer(), true);    }    @Test    public void testRedundantUnsolvable() {        // Gauss-Newton should not be able to solve redundant information        DifferentiableMultivariateVectorialOptimizer optimizer =            new GaussNewtonOptimizer(true);        checkUnsolvableProblem(optimizer, false);    }    private void checkUnsolvableProblem(DifferentiableMultivariateVectorialOptimizer optimizer,                                        boolean solvable) {        Random randomizer = new Random(1248788532l);        for (int degree = 0; degree < 10; ++degree) {            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);            PolynomialFitter fitter = new PolynomialFitter(degree, optimizer);            // reusing the same point over and over again does not bring            // information, the problem cannot be solved in this case for            // degrees greater than 1 (but one point is sufficient for            // degree 0)            for (double x = -1.0; x < 1.0; x += 0.01) {                fitter.addObservedPoint(1.0, 0.0, p.value(0.0));            }            try {                fitter.fit();                Assert.assertTrue(solvable || (degree == 0));            } catch(ConvergenceException e) {                Assert.assertTrue((! solvable) && (degree > 0));            }        }    }    private PolynomialFunction buildRandomPolynomial(int degree, Random randomizer) {        final double[] coefficients = new double[degree + 1];        for (int i = 0; i <= degree; ++i) {            coefficients[i] = randomizer.nextGaussian();        }        return new PolynomialFunction(coefficients);    }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at////   http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.apache.commons.math.optimization.fitting;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class CurveFitterTest {    @Test    public void testMath303()        throws MathUserException {        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        CurveFitter fitter = new CurveFitter(optimizer);        fitter.addObservedPoint(2.805d, 0.6934785852953367d);        fitter.addObservedPoint(2.74333333333333d, 0.6306772025518496d);        fitter.addObservedPoint(1.655d, 0.9474675497289684);        fitter.addObservedPoint(1.725d, 0.9013594835804194d);        ParametricUnivariateRealFunction sif = new SimpleInverseFunction();        double[] initialguess1 = new double[1];        initialguess1[0] = 1.0d;        Assert.assertEquals(1, fitter.fit(sif, initialguess1).length);        double[] initialguess2 = new double[2];        initialguess2[0] = 1.0d;        initialguess2[1] = .5d;        Assert.assertEquals(2, fitter.fit(sif, initialguess2).length);    }    @Test    public void testMath304()        throws MathUserException {        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        CurveFitter fitter = new CurveFitter(optimizer);        fitter.addObservedPoint(2.805d, 0.6934785852953367d);        fitter.addObservedPoint(2.74333333333333d, 0.6306772025518496d);        fitter.addObservedPoint(1.655d, 0.9474675497289684);        fitter.addObservedPoint(1.725d, 0.9013594835804194d);        ParametricUnivariateRealFunction sif = new SimpleInverseFunction();        double[] initialguess1 = new double[1];        initialguess1[0] = 1.0d;        Assert.assertEquals(1.6357215104109237, fitter.fit(sif, initialguess1)[0], 1.0e-14);        double[] initialguess2 = new double[1];        initialguess2[0] = 10.0d;        Assert.assertEquals(1.6357215104109237, fitter.fit(sif, initialguess1)[0], 1.0e-14);    }    @Test    public void testMath372()    throws MathUserException {        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        CurveFitter curveFitter = new CurveFitter(optimizer);        curveFitter.addObservedPoint( 15,  4443);        curveFitter.addObservedPoint( 31,  8493);        curveFitter.addObservedPoint( 62, 17586);        curveFitter.addObservedPoint(125, 30582);        curveFitter.addObservedPoint(250, 45087);        curveFitter.addObservedPoint(500, 50683);        ParametricUnivariateRealFunction f = new ParametricUnivariateRealFunction() {            public double value(double x, double ... parameters) {                double a = parameters[0];                double b = parameters[1];                double c = parameters[2];                double d = parameters[3];                return d + ((a - d) / (1 + FastMath.pow(x / c, b)));            }            public double[] gradient(double x, double ... parameters) {                double a = parameters[0];                double b = parameters[1];                double c = parameters[2];                double d = parameters[3];                double[] gradients = new double[4];                double den = 1 + FastMath.pow(x / c, b);                // derivative with respect to a                gradients[0] = 1 / den;                // derivative with respect to b                // in the reported (invalid) issue, there was a sign error here                gradients[1] = -((a - d) * FastMath.pow(x / c, b) * FastMath.log(x / c)) / (den * den);                // derivative with respect to c                gradients[2] = (b * FastMath.pow(x / c, b - 1) * (x / (c * c)) * (a - d)) / (den * den);                // derivative with respect to d                gradients[3] = 1 - (1 / den);                return gradients;            }        };        double[] initialGuess = new double[] { 1500, 0.95, 65, 35000 };        double[] estimatedParameters = curveFitter.fit(f, initialGuess);        Assert.assertEquals( 2411.00, estimatedParameters[0], 500.00);        Assert.assertEquals(    1.62, estimatedParameters[1],   0.04);        Assert.assertEquals(  111.22, estimatedParameters[2],   0.30);        Assert.assertEquals(55347.47, estimatedParameters[3], 300.00);        Assert.assertTrue(optimizer.getRMS() < 600.0);    }    private static class SimpleInverseFunction implements ParametricUnivariateRealFunction {        public double value(double x, double ... parameters) {            return parameters[0] / x + (parameters.length < 2 ? 0 : parameters[1]);        }        public double[] gradient(double x, double ... doubles) {            double[] gradientVector = new double[doubles.length];            gradientVector[0] = 1 / x;            if (doubles.length >= 2) {                gradientVector[1] = 1;            }            return gradientVector;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.fitting;import org.apache.commons.math.exception.MathIllegalArgumentException;import org.apache.commons.math.optimization.OptimizationException;import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;import org.junit.Assert;import org.junit.Test;/** * Tests {@link GaussianFitter}. * * @since 2.2 * @version $Id$ */public class GaussianFitterTest {    /** Good data. */    protected static final double[][] DATASET1 = new double[][] {        {4.0254623,  531026.0},        {4.02804905, 664002.0},        {4.02934242, 787079.0},        {4.03128248, 984167.0},        {4.03386923, 1294546.0},        {4.03580929, 1560230.0},        {4.03839603, 1887233.0},        {4.0396894,  2113240.0},        {4.04162946, 2375211.0},        {4.04421621, 2687152.0},        {4.04550958, 2862644.0},        {4.04744964, 3078898.0},        {4.05003639, 3327238.0},        {4.05132976, 3461228.0},        {4.05326982, 3580526.0},        {4.05585657, 3576946.0},        {4.05779662, 3439750.0},        {4.06038337, 3220296.0},        {4.06167674, 3070073.0},        {4.0636168,  2877648.0},        {4.06620355, 2595848.0},        {4.06749692, 2390157.0},        {4.06943698, 2175960.0},        {4.07202373, 1895104.0},        {4.0733171,  1687576.0},        {4.07525716, 1447024.0},        {4.0778439,  1130879.0},        {4.07978396, 904900.0},        {4.08237071, 717104.0},        {4.08366408, 620014.0}    };    /** Poor data: right of peak not symmetric with left of peak. */    protected static final double[][] DATASET2 = new double[][] {        {-20.15,   1523.0},        {-19.65,   1566.0},        {-19.15,   1592.0},        {-18.65,   1927.0},        {-18.15,   3089.0},        {-17.65,   6068.0},        {-17.15,  14239.0},        {-16.65,  34124.0},        {-16.15,  64097.0},        {-15.65, 110352.0},        {-15.15, 164742.0},        {-14.65, 209499.0},        {-14.15, 267274.0},        {-13.65, 283290.0},        {-13.15, 275363.0},        {-12.65, 258014.0},        {-12.15, 225000.0},        {-11.65, 200000.0},        {-11.15, 190000.0},        {-10.65, 185000.0},        {-10.15, 180000.0},        { -9.65, 179000.0},        { -9.15, 178000.0},        { -8.65, 177000.0},        { -8.15, 176000.0},        { -7.65, 175000.0},        { -7.15, 174000.0},        { -6.65, 173000.0},        { -6.15, 172000.0},        { -5.65, 171000.0},        { -5.15, 170000.0}    };    /** Poor data: long tails. */    protected static final double[][] DATASET3 = new double[][] {        {-90.15,   1513.0},        {-80.15,   1514.0},        {-70.15,   1513.0},        {-60.15,   1514.0},        {-50.15,   1513.0},        {-40.15,   1514.0},        {-30.15,   1513.0},        {-20.15,   1523.0},        {-19.65,   1566.0},        {-19.15,   1592.0},        {-18.65,   1927.0},        {-18.15,   3089.0},        {-17.65,   6068.0},        {-17.15,  14239.0},        {-16.65,  34124.0},        {-16.15,  64097.0},        {-15.65, 110352.0},        {-15.15, 164742.0},        {-14.65, 209499.0},        {-14.15, 267274.0},        {-13.65, 283290.0},        {-13.15, 275363.0},        {-12.65, 258014.0},        {-12.15, 214073.0},        {-11.65, 182244.0},        {-11.15, 136419.0},        {-10.65,  97823.0},        {-10.15,  58930.0},        { -9.65,  35404.0},        { -9.15,  16120.0},        { -8.65,   9823.0},        { -8.15,   5064.0},        { -7.65,   2575.0},        { -7.15,   1642.0},        { -6.65,   1101.0},        { -6.15,    812.0},        { -5.65,    690.0},        { -5.15,    565.0},        {  5.15,    564.0},        { 15.15,    565.0},        { 25.15,    564.0},        { 35.15,    565.0},        { 45.15,    564.0},        { 55.15,    565.0},        { 65.15,    564.0},        { 75.15,    565.0}    };    /** Poor data: right of peak is missing. */    protected static final double[][] DATASET4 = new double[][] {        {-20.15,   1523.0},        {-19.65,   1566.0},        {-19.15,   1592.0},        {-18.65,   1927.0},        {-18.15,   3089.0},        {-17.65,   6068.0},        {-17.15,  14239.0},        {-16.65,  34124.0},        {-16.15,  64097.0},        {-15.65, 110352.0},        {-15.15, 164742.0},        {-14.65, 209499.0},        {-14.15, 267274.0},        {-13.65, 283290.0}    };    /** Good data, but few points. */    protected static final double[][] DATASET5 = new double[][] {        {4.0254623,  531026.0},        {4.03128248, 984167.0},        {4.03839603, 1887233.0},        {4.04421621, 2687152.0},        {4.05132976, 3461228.0},        {4.05326982, 3580526.0},        {4.05779662, 3439750.0},        {4.0636168,  2877648.0},        {4.06943698, 2175960.0},        {4.07525716, 1447024.0},        {4.08237071, 717104.0},        {4.08366408, 620014.0}    };    /**     * Basic.     *     * @throws OptimizationException in the event of a test case error     */    @Test    public void testFit01()    throws OptimizationException {        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());        addDatasetToGaussianFitter(DATASET1, fitter);        double[] parameters = fitter.fit();        Assert.assertEquals(3496978.1837704973, parameters[0], 1e-4);        Assert.assertEquals(4.054933085999146, parameters[1], 1e-4);        Assert.assertEquals(0.015039355620304326, parameters[2], 1e-4);    }    /**     * Zero points is not enough observed points.     *     * @throws OptimizationException in the event of a test case error     */    @Test(expected=MathIllegalArgumentException.class)    public void testFit02()    throws OptimizationException {        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());        fitter.fit();    }        /**     * Two points is not enough observed points.     *     * @throws OptimizationException in the event of a test case error     */    @Test(expected=MathIllegalArgumentException.class)    public void testFit03()    throws OptimizationException {        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());        addDatasetToGaussianFitter(new double[][] {            {4.0254623,  531026.0},            {4.02804905, 664002.0}},            fitter);        fitter.fit();    }        /**     * Poor data: right of peak not symmetric with left of peak.     *     * @throws OptimizationException in the event of a test case error     */    @Test    public void testFit04()    throws OptimizationException     {        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());        addDatasetToGaussianFitter(DATASET2, fitter);        double[] parameters = fitter.fit();        Assert.assertEquals(233003.2967252038, parameters[0], 1e-4);        Assert.assertEquals(-10.654887521095983, parameters[1], 1e-4);        Assert.assertEquals(4.335937353196641, parameters[2], 1e-4);    }          /**     * Poor data: long tails.     *     * @throws OptimizationException in the event of a test case error     */    @Test    public void testFit05()    throws OptimizationException {        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());        addDatasetToGaussianFitter(DATASET3, fitter);        double[] parameters = fitter.fit();        Assert.assertEquals(283863.81929180305, parameters[0], 1e-4);        Assert.assertEquals(-13.29641995105174, parameters[1], 1e-4);        Assert.assertEquals(1.7297330293549908, parameters[2], 1e-4);    }        /**     * Poor data: right of peak is missing.     *     * @throws OptimizationException in the event of a test case error     */    @Test    public void testFit06()    throws OptimizationException {        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());        addDatasetToGaussianFitter(DATASET4, fitter);        double[] parameters = fitter.fit();        Assert.assertEquals(285250.66754309234, parameters[0], 1e-4);        Assert.assertEquals(-13.528375695228455, parameters[1], 1e-4);        Assert.assertEquals(1.5204344894331614, parameters[2], 1e-4);    }        /**     * Basic with smaller dataset.     *     * @throws OptimizationException in the event of a test case error     */    @Test    public void testFit07()    throws OptimizationException {        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());        addDatasetToGaussianFitter(DATASET5, fitter);        double[] parameters = fitter.fit();        Assert.assertEquals(3514384.729342235, parameters[0], 1e-4);        Assert.assertEquals(4.054970307455625, parameters[1], 1e-4);        Assert.assertEquals(0.015029412832160017, parameters[2], 1e-4);    }    @Test    public void testMath519() {        // The optimizer will try negative sigma values but "GaussianFitter"        // will catch the raised exceptions and return NaN values instead.        final double[] data = {             1.1143831578403364E-29,            4.95281403484594E-28,            1.1171347211930288E-26,            1.7044813962636277E-25,            1.9784716574832164E-24,            1.8630236407866774E-23,            1.4820532905097742E-22,            1.0241963854632831E-21,            6.275077366673128E-21,            3.461808994532493E-20,            1.7407124684715706E-19,            8.056687953553974E-19,            3.460193945992071E-18,            1.3883326374011525E-17,            5.233894983671116E-17,            1.8630791465263745E-16,            6.288759227922111E-16,            2.0204433920597856E-15,            6.198768938576155E-15,            1.821419346860626E-14,            5.139176445538471E-14,            1.3956427429045787E-13,            3.655705706448139E-13,            9.253753324779779E-13,            2.267636001476696E-12,            5.3880460095836855E-12,            1.2431632654852931E-11        };        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());        for (int i = 0; i < data.length; i++) {            fitter.addObservedPoint(i, data[i]);        }        final double[] p = fitter.fit();        Assert.assertEquals(53.1572792, p[1], 1e-7);        Assert.assertEquals(5.75214622, p[2], 1e-8);    }        /**     * Adds the specified points to specified <code>GaussianFitter</code>     * instance.     *     * @param points data points where first dimension is a point index and     *        second dimension is an array of length two representing the point     *        with the first value corresponding to X and the second value     *        corresponding to Y     * @param fitter fitter to which the points in <code>points</code> should be     *        added as observed points     */    protected static void addDatasetToGaussianFitter(double[][] points,                                                     GaussianFitter fitter) {        for (int i = 0; i < points.length; i++) {            fitter.addObservedPoint(points[i][0], points[i][1]);        }    }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at////   http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.apache.commons.math.optimization.fitting;import java.util.Random;import org.apache.commons.math.analysis.function.HarmonicOscillator;import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.util.MathUtils;import org.junit.Test;import org.junit.Assert;public class HarmonicFitterTest {    @Test(expected=NumberIsTooSmallException.class)    public void testPreconditions1() {        HarmonicFitter fitter =            new HarmonicFitter(new LevenbergMarquardtOptimizer());        fitter.fit();    }    // This test fails (throwing "ConvergenceException" instead).//     @Test(expected=ZeroException.class)//     public void testPreconditions2() {//         HarmonicFitter fitter =//             new HarmonicFitter(new LevenbergMarquardtOptimizer());//         final double x = 1.2;//         fitter.addObservedPoint(1, x, 1);//         fitter.addObservedPoint(1, x, -1);//         fitter.addObservedPoint(1, x, 0.5);//         fitter.addObservedPoint(1, x, 0);//         final double[] fitted = fitter.fit();//     }    @Test    public void testNoError() {        final double a = 0.2;        final double w = 3.4;        final double p = 4.1;        HarmonicOscillator f = new HarmonicOscillator(a, w, p);        HarmonicFitter fitter =            new HarmonicFitter(new LevenbergMarquardtOptimizer());        for (double x = 0.0; x < 1.3; x += 0.01) {            fitter.addObservedPoint(1, x, f.value(x));        }        final double[] fitted = fitter.fit();        Assert.assertEquals(a, fitted[0], 1.0e-13);        Assert.assertEquals(w, fitted[1], 1.0e-13);        Assert.assertEquals(p, MathUtils.normalizeAngle(fitted[2], p), 1e-13);        HarmonicOscillator ff = new HarmonicOscillator(fitted[0], fitted[1], fitted[2]);        for (double x = -1.0; x < 1.0; x += 0.01) {            Assert.assertTrue(FastMath.abs(f.value(x) - ff.value(x)) < 1e-13);        }    }    @Test    public void test1PercentError() {        Random randomizer = new Random(64925784252l);        final double a = 0.2;        final double w = 3.4;        final double p = 4.1;        HarmonicOscillator f = new HarmonicOscillator(a, w, p);        HarmonicFitter fitter =            new HarmonicFitter(new LevenbergMarquardtOptimizer());        for (double x = 0.0; x < 10.0; x += 0.1) {            fitter.addObservedPoint(1, x,                                    f.value(x) + 0.01 * randomizer.nextGaussian());        }        final double[] fitted = fitter.fit();        Assert.assertEquals(a, fitted[0], 7.6e-4);        Assert.assertEquals(w, fitted[1], 2.7e-3);        Assert.assertEquals(p, MathUtils.normalizeAngle(fitted[2], p), 1.3e-2);    }    @Test    public void testTinyVariationsData() {        Random randomizer = new Random(64925784252l);        HarmonicFitter fitter =            new HarmonicFitter(new LevenbergMarquardtOptimizer());        for (double x = 0.0; x < 10.0; x += 0.1) {            fitter.addObservedPoint(1, x, 1e-7 * randomizer.nextGaussian());        }        fitter.fit();        // This test serves to cover the part of the code of "guessAOmega"        // when the algorithm using integrals fails.    }    @Test    public void testInitialGuess() {        Random randomizer = new Random(45314242l);        final double a = 0.2;        final double w = 3.4;        final double p = 4.1;        HarmonicOscillator f = new HarmonicOscillator(a, w, p);        HarmonicFitter fitter =            new HarmonicFitter(new LevenbergMarquardtOptimizer());        for (double x = 0.0; x < 10.0; x += 0.1) {            fitter.addObservedPoint(1, x,                                    f.value(x) + 0.01 * randomizer.nextGaussian());        }        final double[] fitted = fitter.fit(new double[] { 0.15, 3.6, 4.5 });        Assert.assertEquals(a, fitted[0], 1.2e-3);        Assert.assertEquals(w, fitted[1], 3.3e-3);        Assert.assertEquals(p, MathUtils.normalizeAngle(fitted[2], p), 1.7e-2);    }    @Test    public void testUnsorted() {        Random randomizer = new Random(64925784252l);        final double a = 0.2;        final double w = 3.4;        final double p = 4.1;        HarmonicOscillator f = new HarmonicOscillator(a, w, p);        HarmonicFitter fitter =            new HarmonicFitter(new LevenbergMarquardtOptimizer());        // build a regularly spaced array of measurements        int size = 100;        double[] xTab = new double[size];        double[] yTab = new double[size];        for (int i = 0; i < size; ++i) {            xTab[i] = 0.1 * i;            yTab[i] = f.value(xTab[i]) + 0.01 * randomizer.nextGaussian();        }        // shake it        for (int i = 0; i < size; ++i) {            int i1 = randomizer.nextInt(size);            int i2 = randomizer.nextInt(size);            double xTmp = xTab[i1];            double yTmp = yTab[i1];            xTab[i1] = xTab[i2];            yTab[i1] = yTab[i2];            xTab[i2] = xTmp;            yTab[i2] = yTmp;        }        // pass it to the fitter        for (int i = 0; i < size; ++i) {            fitter.addObservedPoint(1, xTab[i], yTab[i]);        }        final double[] fitted = fitter.fit();        Assert.assertEquals(a, fitted[0], 7.6e-4);        Assert.assertEquals(w, fitted[1], 3.5e-3);        Assert.assertEquals(p, MathUtils.normalizeAngle(fitted[2], p), 1.5e-2);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization;import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;import org.apache.commons.math.analysis.MultivariateMatrixFunction;import org.apache.commons.math.exception.MathIllegalStateException;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;import org.apache.commons.math.random.GaussianRandomGenerator;import org.apache.commons.math.random.JDKRandomGenerator;import org.apache.commons.math.random.RandomVectorGenerator;import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;import org.junit.Assert;import org.junit.Test;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */public class MultiStartDifferentiableMultivariateVectorialOptimizerTest {    @Test    public void testTrivial() {        LinearProblem problem =            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });        DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =            new GaussNewtonOptimizer(true);        JDKRandomGenerator g = new JDKRandomGenerator();        g.setSeed(16069223052l);        RandomVectorGenerator generator =            new UncorrelatedRandomVectorGenerator(1, new GaussianRandomGenerator(g));        MultiStartDifferentiableMultivariateVectorialOptimizer optimizer =            new MultiStartDifferentiableMultivariateVectorialOptimizer(underlyingOptimizer,                                                                       10, generator);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        // no optima before first optimization attempt        try {            optimizer.getOptima();            Assert.fail("an exception should have been thrown");        } catch (MathIllegalStateException ise) {            // expected        }        VectorialPointValuePair optimum =            optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });        Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);        Assert.assertEquals(3.0, optimum.getValue()[0], 1.0e-10);        VectorialPointValuePair[] optima = optimizer.getOptima();        Assert.assertEquals(10, optima.length);        for (int i = 0; i < optima.length; ++i) {            Assert.assertEquals(1.5, optima[i].getPoint()[0], 1.0e-10);            Assert.assertEquals(3.0, optima[i].getValue()[0], 1.0e-10);        }        Assert.assertTrue(optimizer.getEvaluations() > 20);        Assert.assertTrue(optimizer.getEvaluations() < 50);        Assert.assertEquals(100, optimizer.getMaxEvaluations());    }    @Test(expected = MathUserException.class)    public void testNoOptimum() {        DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =            new GaussNewtonOptimizer(true);        JDKRandomGenerator g = new JDKRandomGenerator();        g.setSeed(12373523445l);        RandomVectorGenerator generator =            new UncorrelatedRandomVectorGenerator(1, new GaussianRandomGenerator(g));        MultiStartDifferentiableMultivariateVectorialOptimizer optimizer =            new MultiStartDifferentiableMultivariateVectorialOptimizer(underlyingOptimizer,                                                                       10, generator);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        optimizer.optimize(100, new DifferentiableMultivariateVectorialFunction() {                public MultivariateMatrixFunction jacobian() {                    return null;                }                public double[] value(double[] point) {                    throw new MathUserException();                }            }, new double[] { 2 }, new double[] { 1 }, new double[] { 0 });    }    private static class LinearProblem implements DifferentiableMultivariateVectorialFunction {        final RealMatrix factors;        final double[] target;        public LinearProblem(double[][] factors, double[] target) {            this.factors = new BlockRealMatrix(factors);            this.target  = target;        }        public double[] value(double[] variables) {            return factors.operate(variables);        }        public MultivariateMatrixFunction jacobian() {            return new MultivariateMatrixFunction() {                public double[][] value(double[] point) {                    return factors.getData();                }            };        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.exception.MathUserException;import org.apache.commons.math.optimization.direct.SimplexOptimizer;import org.apache.commons.math.optimization.direct.NelderMeadSimplex;import org.apache.commons.math.random.GaussianRandomGenerator;import org.apache.commons.math.random.JDKRandomGenerator;import org.apache.commons.math.random.RandomVectorGenerator;import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;import org.junit.Assert;import org.junit.Test;public class MultiStartMultivariateRealOptimizerTest {    @Test    public void testRosenbrock() throws MathUserException {        Rosenbrock rosenbrock = new Rosenbrock();        SimplexOptimizer underlying = new SimplexOptimizer();        NelderMeadSimplex simplex = new NelderMeadSimplex(new double[][] {                { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }            });        underlying.setSimplex(simplex);        JDKRandomGenerator g = new JDKRandomGenerator();        g.setSeed(16069223052l);        RandomVectorGenerator generator =            new UncorrelatedRandomVectorGenerator(2, new GaussianRandomGenerator(g));        MultiStartMultivariateRealOptimizer optimizer =            new MultiStartMultivariateRealOptimizer(underlying, 10, generator);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));        RealPointValuePair optimum =            optimizer.optimize(1100, rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });        Assert.assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());        Assert.assertTrue(optimizer.getEvaluations() > 900);        Assert.assertTrue(optimizer.getEvaluations() < 1200);        Assert.assertTrue(optimum.getValue() < 8.0e-4);    }    private static class Rosenbrock implements MultivariateRealFunction {        private int count;        public Rosenbrock() {            count = 0;        }        public double value(double[] x) {            ++count;            double a = x[1] - x[0] * x[0];            double b = 1.0 - x[0];            return 100 * a * a + b * b;        }        public int getCount() {            return count;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization;import java.awt.geom.Point2D;import java.util.ArrayList;import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.analysis.MultivariateVectorialFunction;import org.apache.commons.math.optimization.general.ConjugateGradientFormula;import org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer;import org.apache.commons.math.random.GaussianRandomGenerator;import org.apache.commons.math.random.JDKRandomGenerator;import org.apache.commons.math.random.RandomVectorGenerator;import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;import org.junit.Assert;import org.junit.Test;public class MultiStartDifferentiableMultivariateRealOptimizerTest {    @Test    public void testCircleFitting() {        Circle circle = new Circle();        circle.addPoint( 30.0,  68.0);        circle.addPoint( 50.0,  -6.0);        circle.addPoint(110.0, -20.0);        circle.addPoint( 35.0,  15.0);        circle.addPoint( 45.0,  97.0);        NonLinearConjugateGradientOptimizer underlying =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        JDKRandomGenerator g = new JDKRandomGenerator();        g.setSeed(753289573253l);        RandomVectorGenerator generator =            new UncorrelatedRandomVectorGenerator(new double[] { 50.0, 50.0 }, new double[] { 10.0, 10.0 },                                                  new GaussianRandomGenerator(g));        MultiStartDifferentiableMultivariateRealOptimizer optimizer =            new MultiStartDifferentiableMultivariateRealOptimizer(underlying, 10, generator);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-10));        RealPointValuePair optimum =            optimizer.optimize(200, circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });        Assert.assertEquals(200, optimizer.getMaxEvaluations());        RealPointValuePair[] optima = optimizer.getOptima();        for (RealPointValuePair o : optima) {            Point2D.Double center = new Point2D.Double(o.getPointRef()[0], o.getPointRef()[1]);            Assert.assertEquals(69.960161753, circle.getRadius(center), 1.0e-8);            Assert.assertEquals(96.075902096, center.x, 1.0e-8);            Assert.assertEquals(48.135167894, center.y, 1.0e-8);        }        Assert.assertTrue(optimizer.getEvaluations() > 70);        Assert.assertTrue(optimizer.getEvaluations() < 90);        Assert.assertEquals(3.1267527, optimum.getValue(), 1.0e-8);    }    private static class Circle implements DifferentiableMultivariateRealFunction {        private ArrayList<Point2D.Double> points;        public Circle() {            points  = new ArrayList<Point2D.Double>();        }        public void addPoint(double px, double py) {            points.add(new Point2D.Double(px, py));        }        public double getRadius(Point2D.Double center) {            double r = 0;            for (Point2D.Double point : points) {                r += point.distance(center);            }            return r / points.size();        }        private double[] gradient(double[] point) {            // optimal radius            Point2D.Double center = new Point2D.Double(point[0], point[1]);            double radius = getRadius(center);            // gradient of the sum of squared residuals            double dJdX = 0;            double dJdY = 0;            for (Point2D.Double pk : points) {                double dk = pk.distance(center);                dJdX += (center.x - pk.x) * (dk - radius) / dk;                dJdY += (center.y - pk.y) * (dk - radius) / dk;            }            dJdX *= 2;            dJdY *= 2;            return new double[] { dJdX, dJdY };        }        public double value(double[] variables) {            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);            double radius = getRadius(center);            double sum = 0;            for (Point2D.Double point : points) {                double di = point.distance(center) - radius;                sum += di * di;            }            return sum;        }        public MultivariateVectorialFunction gradient() {            return new MultivariateVectorialFunction() {                public double[] value(double[] point) {                    return gradient(point);                }            };        }        public MultivariateRealFunction partialDerivative(final int k) {            return new MultivariateRealFunction() {                public double value(double[] point) {                    return gradient(point)[k];                }            };        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import org.apache.commons.math.TestUtils;import org.junit.Assert;import org.junit.Test;public class ComplexFieldTest {    @Test    public void testZero() {        Assert.assertEquals(Complex.ZERO, ComplexField.getInstance().getZero());    }    @Test    public void testOne() {        Assert.assertEquals(Complex.ONE, ComplexField.getInstance().getOne());    }    @Test    public void testSerial() {        // deserializing the singleton should give the singleton itself back        ComplexField field = ComplexField.getInstance();        Assert.assertTrue(field == TestUtils.serializeAndRecover(field));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import org.apache.commons.math.TestUtils;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.util.MathUtils;import org.junit.Assert;import org.junit.Test;import java.util.List;/** * @version $Id$ */public class ComplexTest {    private double inf = Double.POSITIVE_INFINITY;    private double neginf = Double.NEGATIVE_INFINITY;    private double nan = Double.NaN;    private double pi = FastMath.PI;    private Complex oneInf = new Complex(1, inf);    private Complex oneNegInf = new Complex(1, neginf);    private Complex infOne = new Complex(inf, 1);    private Complex infZero = new Complex(inf, 0);    private Complex infNaN = new Complex(inf, nan);    private Complex infNegInf = new Complex(inf, neginf);    private Complex infInf = new Complex(inf, inf);    private Complex negInfInf = new Complex(neginf, inf);    private Complex negInfZero = new Complex(neginf, 0);    private Complex negInfOne = new Complex(neginf, 1);    private Complex negInfNaN = new Complex(neginf, nan);    private Complex negInfNegInf = new Complex(neginf, neginf);    private Complex oneNaN = new Complex(1, nan);    private Complex zeroInf = new Complex(0, inf);    private Complex zeroNaN = new Complex(0, nan);    private Complex nanInf = new Complex(nan, inf);    private Complex nanNegInf = new Complex(nan, neginf);    private Complex nanZero = new Complex(nan, 0);    @Test    public void testConstructor() {        Complex z = new Complex(3.0, 4.0);        Assert.assertEquals(3.0, z.getReal(), 1.0e-5);        Assert.assertEquals(4.0, z.getImaginary(), 1.0e-5);    }    @Test    public void testConstructorNaN() {        Complex z = new Complex(3.0, Double.NaN);        Assert.assertTrue(z.isNaN());        z = new Complex(nan, 4.0);        Assert.assertTrue(z.isNaN());        z = new Complex(3.0, 4.0);        Assert.assertFalse(z.isNaN());    }    @Test    public void testAbs() {        Complex z = new Complex(3.0, 4.0);        Assert.assertEquals(5.0, z.abs(), 1.0e-5);    }    @Test    public void testAbsNaN() {        Assert.assertTrue(Double.isNaN(Complex.NaN.abs()));        Complex z = new Complex(inf, nan);        Assert.assertTrue(Double.isNaN(z.abs()));    }    @Test    public void testAbsInfinite() {        Complex z = new Complex(inf, 0);        Assert.assertEquals(inf, z.abs(), 0);        z = new Complex(0, neginf);        Assert.assertEquals(inf, z.abs(), 0);        z = new Complex(inf, neginf);        Assert.assertEquals(inf, z.abs(), 0);    }    @Test    public void testAdd() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.add(y);        Assert.assertEquals(8.0, z.getReal(), 1.0e-5);        Assert.assertEquals(10.0, z.getImaginary(), 1.0e-5);    }    @Test    public void testAddNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.add(Complex.NaN);        Assert.assertSame(Complex.NaN, z);        z = new Complex(1, nan);        Complex w = x.add(z);        Assert.assertSame(Complex.NaN, w);    }    @Test    public void testAddInf() {        Complex x = new Complex(1, 1);        Complex z = new Complex(inf, 0);        Complex w = x.add(z);        Assert.assertEquals(w.getImaginary(), 1, 0);        Assert.assertEquals(inf, w.getReal(), 0);        x = new Complex(neginf, 0);        Assert.assertTrue(Double.isNaN(x.add(z).getReal()));    }        @Test    public void testScalarAdd() {        Complex x = new Complex(3.0, 4.0);        double yDouble = 2.0;        Complex yComplex = new Complex(yDouble);        Assert.assertEquals(x.add(yComplex), x.add(yDouble));    }    @Test    public void testScalarAddNaN() {        Complex x = new Complex(3.0, 4.0);        double yDouble = Double.NaN;        Complex yComplex = new Complex(yDouble);        Assert.assertEquals(x.add(yComplex), x.add(yDouble));    }    @Test    public void testScalarAddInf() {        Complex x = new Complex(1, 1);        double yDouble = Double.POSITIVE_INFINITY;                Complex yComplex = new Complex(yDouble);        Assert.assertEquals(x.add(yComplex), x.add(yDouble));        x = new Complex(neginf, 0);        Assert.assertEquals(x.add(yComplex), x.add(yDouble));    }    @Test    public void testConjugate() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.conjugate();        Assert.assertEquals(3.0, z.getReal(), 1.0e-5);        Assert.assertEquals(-4.0, z.getImaginary(), 1.0e-5);    }    @Test    public void testConjugateNaN() {        Complex z = Complex.NaN.conjugate();        Assert.assertTrue(z.isNaN());    }    @Test    public void testConjugateInfiinite() {        Complex z = new Complex(0, inf);        Assert.assertEquals(neginf, z.conjugate().getImaginary(), 0);        z = new Complex(0, neginf);        Assert.assertEquals(inf, z.conjugate().getImaginary(), 0);    }    @Test    public void testDivide() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.divide(y);        Assert.assertEquals(39.0 / 61.0, z.getReal(), 1.0e-5);        Assert.assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5);    }    @Test    public void testDivideReal() {        Complex x = new Complex(2d, 3d);        Complex y = new Complex(2d, 0d);        Assert.assertEquals(new Complex(1d, 1.5), x.divide(y));    }    @Test    public void testDivideImaginary() {        Complex x = new Complex(2d, 3d);        Complex y = new Complex(0d, 2d);        Assert.assertEquals(new Complex(1.5d, -1d), x.divide(y));    }    @Test    public void testDivideInf() {        Complex x = new Complex(3, 4);        Complex w = new Complex(neginf, inf);        Assert.assertTrue(x.divide(w).equals(Complex.ZERO));        Complex z = w.divide(x);        Assert.assertTrue(Double.isNaN(z.getReal()));        Assert.assertEquals(inf, z.getImaginary(), 0);        w = new Complex(inf, inf);        z = w.divide(x);        Assert.assertTrue(Double.isNaN(z.getImaginary()));        Assert.assertEquals(inf, z.getReal(), 0);        w = new Complex(1, inf);        z = w.divide(w);        Assert.assertTrue(Double.isNaN(z.getReal()));        Assert.assertTrue(Double.isNaN(z.getImaginary()));    }    @Test    public void testDivideZero() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.divide(Complex.ZERO);        // Assert.assertEquals(z, Complex.INF); // See MATH-657        Assert.assertEquals(z, Complex.NaN);    }    @Test    public void testDivideZeroZero() {        Complex x = new Complex(0.0, 0.0);        Complex z = x.divide(Complex.ZERO);        Assert.assertEquals(z, Complex.NaN);    }    @Test    public void testDivideNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.divide(Complex.NaN);        Assert.assertTrue(z.isNaN());    }    @Test    public void testDivideNaNInf() {       Complex z = oneInf.divide(Complex.ONE);       Assert.assertTrue(Double.isNaN(z.getReal()));       Assert.assertEquals(inf, z.getImaginary(), 0);       z = negInfNegInf.divide(oneNaN);       Assert.assertTrue(Double.isNaN(z.getReal()));       Assert.assertTrue(Double.isNaN(z.getImaginary()));       z = negInfInf.divide(Complex.ONE);       Assert.assertTrue(Double.isNaN(z.getReal()));       Assert.assertTrue(Double.isNaN(z.getImaginary()));    }    @Test    public void testScalarDivide() {        Complex x = new Complex(3.0, 4.0);        double yDouble = 2.0;        Complex yComplex = new Complex(yDouble);        Assert.assertEquals(x.divide(yComplex), x.divide(yDouble));    }    @Test    public void testScalarDivideNaN() {        Complex x = new Complex(3.0, 4.0);        double yDouble = Double.NaN;        Complex yComplex = new Complex(yDouble);        Assert.assertEquals(x.divide(yComplex), x.divide(yDouble));    }    @Test    public void testScalarDivideInf() {        Complex x = new Complex(1,1);        double yDouble = Double.POSITIVE_INFINITY;        Complex yComplex = new Complex(yDouble);        TestUtils.assertEquals(x.divide(yComplex), x.divide(yDouble), 0);        yDouble = Double.NEGATIVE_INFINITY;        yComplex = new Complex(yDouble);        TestUtils.assertEquals(x.divide(yComplex), x.divide(yDouble), 0);                x = new Complex(1, Double.NEGATIVE_INFINITY);        TestUtils.assertEquals(x.divide(yComplex), x.divide(yDouble), 0);    }        @Test    public void testScalarDivideZero() {        Complex x = new Complex(1,1);        TestUtils.assertEquals(x.divide(Complex.ZERO), x.divide(0), 0);    }    @Test    public void testMultiply() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.multiply(y);        Assert.assertEquals(-9.0, z.getReal(), 1.0e-5);        Assert.assertEquals(38.0, z.getImaginary(), 1.0e-5);    }    @Test    public void testMultiplyNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.multiply(Complex.NaN);        Assert.assertSame(Complex.NaN, z);    }    @Test    public void testMultiplyNaNInf() {        Complex z = new Complex(1,1);        Complex w = z.multiply(infOne);        Assert.assertEquals(w.getReal(), inf, 0);        Assert.assertEquals(w.getImaginary(), inf, 0);        // [MATH-164]        Assert.assertTrue(new Complex( 1,0).multiply(infInf).equals(Complex.INF));        Assert.assertTrue(new Complex(-1,0).multiply(infInf).equals(Complex.INF));        Assert.assertTrue(new Complex( 1,0).multiply(negInfZero).equals(Complex.INF));        w = oneInf.multiply(oneNegInf);        Assert.assertEquals(w.getReal(), inf, 0);        Assert.assertEquals(w.getImaginary(), inf, 0);        w = negInfNegInf.multiply(oneNaN);        Assert.assertTrue(Double.isNaN(w.getReal()));        Assert.assertTrue(Double.isNaN(w.getImaginary()));                z = new Complex(1, neginf);        Assert.assertSame(Complex.INF, z.multiply(z));    }    @Test    public void testScalarMultiply() {        Complex x = new Complex(3.0, 4.0);        double yDouble = 2.0;        Complex yComplex = new Complex(yDouble);        Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble));    }    @Test    public void testScalarMultiplyNaN() {        Complex x = new Complex(3.0, 4.0);        double yDouble = Double.NaN;        Complex yComplex = new Complex(yDouble);        Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble));    }    @Test    public void testScalarMultiplyInf() {        Complex x = new Complex(1, 1);        double yDouble = Double.POSITIVE_INFINITY;        Complex yComplex = new Complex(yDouble);        Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble));                yDouble = Double.NEGATIVE_INFINITY;        yComplex = new Complex(yDouble);        Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble));    }    @Test    public void testNegate() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.negate();        Assert.assertEquals(-3.0, z.getReal(), 1.0e-5);        Assert.assertEquals(-4.0, z.getImaginary(), 1.0e-5);    }    @Test    public void testNegateNaN() {        Complex z = Complex.NaN.negate();        Assert.assertTrue(z.isNaN());    }    @Test    public void testSubtract() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.subtract(y);        Assert.assertEquals(-2.0, z.getReal(), 1.0e-5);        Assert.assertEquals(-2.0, z.getImaginary(), 1.0e-5);    }    @Test    public void testSubtractNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.subtract(Complex.NaN);        Assert.assertSame(Complex.NaN, z);        z = new Complex(1, nan);        Complex w = x.subtract(z);        Assert.assertSame(Complex.NaN, w);    }    @Test    public void testSubtractInf() {        Complex x = new Complex(1, 1);        Complex z = new Complex(neginf, 0);        Complex w = x.subtract(z);        Assert.assertEquals(w.getImaginary(), 1, 0);        Assert.assertEquals(inf, w.getReal(), 0);        x = new Complex(neginf, 0);        Assert.assertTrue(Double.isNaN(x.subtract(z).getReal()));    }        @Test    public void testScalarSubtract() {        Complex x = new Complex(3.0, 4.0);        double yDouble = 2.0;        Complex yComplex = new Complex(yDouble);        Assert.assertEquals(x.subtract(yComplex), x.subtract(yDouble));    }    @Test    public void testScalarSubtractNaN() {        Complex x = new Complex(3.0, 4.0);        double yDouble = Double.NaN;        Complex yComplex = new Complex(yDouble);        Assert.assertEquals(x.subtract(yComplex), x.subtract(yDouble));    }    @Test    public void testScalarSubtractInf() {        Complex x = new Complex(1, 1);        double yDouble = Double.POSITIVE_INFINITY;        Complex yComplex = new Complex(yDouble);        Assert.assertEquals(x.subtract(yComplex), x.subtract(yDouble));        x = new Complex(neginf, 0);        Assert.assertEquals(x.subtract(yComplex), x.subtract(yDouble));    }        @Test    public void testEqualsNull() {        Complex x = new Complex(3.0, 4.0);        Assert.assertFalse(x.equals(null));    }    @Test    public void testEqualsClass() {        Complex x = new Complex(3.0, 4.0);        Assert.assertFalse(x.equals(this));    }    @Test    public void testEqualsSame() {        Complex x = new Complex(3.0, 4.0);        Assert.assertTrue(x.equals(x));    }    @Test    public void testEqualsTrue() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(3.0, 4.0);        Assert.assertTrue(x.equals(y));    }    @Test    public void testEqualsRealDifference() {        Complex x = new Complex(0.0, 0.0);        Complex y = new Complex(0.0 + Double.MIN_VALUE, 0.0);        Assert.assertFalse(x.equals(y));    }    @Test    public void testEqualsImaginaryDifference() {        Complex x = new Complex(0.0, 0.0);        Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);        Assert.assertFalse(x.equals(y));    }    @Test    public void testEqualsNaN() {        Complex realNaN = new Complex(Double.NaN, 0.0);        Complex imaginaryNaN = new Complex(0.0, Double.NaN);        Complex complexNaN = Complex.NaN;        Assert.assertTrue(realNaN.equals(imaginaryNaN));        Assert.assertTrue(imaginaryNaN.equals(complexNaN));        Assert.assertTrue(realNaN.equals(complexNaN));    }    @Test    public void testHashCode() {        Complex x = new Complex(0.0, 0.0);        Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);        Assert.assertFalse(x.hashCode()==y.hashCode());        y = new Complex(0.0 + Double.MIN_VALUE, 0.0);        Assert.assertFalse(x.hashCode()==y.hashCode());        Complex realNaN = new Complex(Double.NaN, 0.0);        Complex imaginaryNaN = new Complex(0.0, Double.NaN);        Assert.assertEquals(realNaN.hashCode(), imaginaryNaN.hashCode());        Assert.assertEquals(imaginaryNaN.hashCode(), Complex.NaN.hashCode());    }        @Test    public void testAcos() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(0.936812, -2.30551);        TestUtils.assertEquals(expected, z.acos(), 1.0e-5);        TestUtils.assertEquals(new Complex(FastMath.acos(0), 0),                Complex.ZERO.acos(), 1.0e-12);    }    @Test    public void testAcosInf() {        TestUtils.assertSame(Complex.NaN, oneInf.acos());        TestUtils.assertSame(Complex.NaN, oneNegInf.acos());        TestUtils.assertSame(Complex.NaN, infOne.acos());        TestUtils.assertSame(Complex.NaN, negInfOne.acos());        TestUtils.assertSame(Complex.NaN, infInf.acos());        TestUtils.assertSame(Complex.NaN, infNegInf.acos());        TestUtils.assertSame(Complex.NaN, negInfInf.acos());        TestUtils.assertSame(Complex.NaN, negInfNegInf.acos());    }    @Test    public void testAcosNaN() {        Assert.assertTrue(Complex.NaN.acos().isNaN());    }    @Test    public void testAsin() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(0.633984, 2.30551);        TestUtils.assertEquals(expected, z.asin(), 1.0e-5);    }    @Test    public void testAsinNaN() {        Assert.assertTrue(Complex.NaN.asin().isNaN());    }    @Test    public void testAsinInf() {        TestUtils.assertSame(Complex.NaN, oneInf.asin());        TestUtils.assertSame(Complex.NaN, oneNegInf.asin());        TestUtils.assertSame(Complex.NaN, infOne.asin());        TestUtils.assertSame(Complex.NaN, negInfOne.asin());        TestUtils.assertSame(Complex.NaN, infInf.asin());        TestUtils.assertSame(Complex.NaN, infNegInf.asin());        TestUtils.assertSame(Complex.NaN, negInfInf.asin());        TestUtils.assertSame(Complex.NaN, negInfNegInf.asin());    }    @Test    public void testAtan() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(1.44831, 0.158997);        TestUtils.assertEquals(expected, z.atan(), 1.0e-5);    }    @Test    public void testAtanInf() {        TestUtils.assertSame(Complex.NaN, oneInf.atan());        TestUtils.assertSame(Complex.NaN, oneNegInf.atan());        TestUtils.assertSame(Complex.NaN, infOne.atan());        TestUtils.assertSame(Complex.NaN, negInfOne.atan());        TestUtils.assertSame(Complex.NaN, infInf.atan());        TestUtils.assertSame(Complex.NaN, infNegInf.atan());        TestUtils.assertSame(Complex.NaN, negInfInf.atan());        TestUtils.assertSame(Complex.NaN, negInfNegInf.atan());    }    @Test    public void testAtanI() {        Assert.assertTrue(Complex.I.atan().isNaN());    }    @Test    public void testAtanNaN() {        Assert.assertTrue(Complex.NaN.atan().isNaN());    }    @Test    public void testCos() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-27.03495, -3.851153);        TestUtils.assertEquals(expected, z.cos(), 1.0e-5);    }    @Test    public void testCosNaN() {        Assert.assertTrue(Complex.NaN.cos().isNaN());    }    @Test    public void testCosInf() {        TestUtils.assertSame(infNegInf, oneInf.cos());        TestUtils.assertSame(infInf, oneNegInf.cos());        TestUtils.assertSame(Complex.NaN, infOne.cos());        TestUtils.assertSame(Complex.NaN, negInfOne.cos());        TestUtils.assertSame(Complex.NaN, infInf.cos());        TestUtils.assertSame(Complex.NaN, infNegInf.cos());        TestUtils.assertSame(Complex.NaN, negInfInf.cos());        TestUtils.assertSame(Complex.NaN, negInfNegInf.cos());    }    @Test    public void testCosh() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-6.58066, -7.58155);        TestUtils.assertEquals(expected, z.cosh(), 1.0e-5);    }    @Test    public void testCoshNaN() {        Assert.assertTrue(Complex.NaN.cosh().isNaN());    }    @Test    public void testCoshInf() {        TestUtils.assertSame(Complex.NaN, oneInf.cosh());        TestUtils.assertSame(Complex.NaN, oneNegInf.cosh());        TestUtils.assertSame(infInf, infOne.cosh());        TestUtils.assertSame(infNegInf, negInfOne.cosh());        TestUtils.assertSame(Complex.NaN, infInf.cosh());        TestUtils.assertSame(Complex.NaN, infNegInf.cosh());        TestUtils.assertSame(Complex.NaN, negInfInf.cosh());        TestUtils.assertSame(Complex.NaN, negInfNegInf.cosh());    }    @Test    public void testExp() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-13.12878, -15.20078);        TestUtils.assertEquals(expected, z.exp(), 1.0e-5);        TestUtils.assertEquals(Complex.ONE,                Complex.ZERO.exp(), 10e-12);        Complex iPi = Complex.I.multiply(new Complex(pi,0));        TestUtils.assertEquals(Complex.ONE.negate(),                iPi.exp(), 10e-12);    }    @Test    public void testExpNaN() {        Assert.assertTrue(Complex.NaN.exp().isNaN());    }    @Test    public void testExpInf() {        TestUtils.assertSame(Complex.NaN, oneInf.exp());        TestUtils.assertSame(Complex.NaN, oneNegInf.exp());        TestUtils.assertSame(infInf, infOne.exp());        TestUtils.assertSame(Complex.ZERO, negInfOne.exp());        TestUtils.assertSame(Complex.NaN, infInf.exp());        TestUtils.assertSame(Complex.NaN, infNegInf.exp());        TestUtils.assertSame(Complex.NaN, negInfInf.exp());        TestUtils.assertSame(Complex.NaN, negInfNegInf.exp());    }    @Test    public void testLog() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(1.60944, 0.927295);        TestUtils.assertEquals(expected, z.log(), 1.0e-5);    }    @Test    public void testLogNaN() {        Assert.assertTrue(Complex.NaN.log().isNaN());    }    @Test    public void testLogInf() {        TestUtils.assertEquals(new Complex(inf, pi / 2),                oneInf.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, -pi / 2),                oneNegInf.log(), 10e-12);        TestUtils.assertEquals(infZero, infOne.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, pi),                negInfOne.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, pi / 4),                infInf.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, -pi / 4),                infNegInf.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, 3d * pi / 4),                negInfInf.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),                negInfNegInf.log(), 10e-12);    }    @Test    public void testLogZero() {        TestUtils.assertSame(negInfZero, Complex.ZERO.log());    }    @Test    public void testPow() {        Complex x = new Complex(3, 4);        Complex y = new Complex(5, 6);        Complex expected = new Complex(-1.860893, 11.83677);        TestUtils.assertEquals(expected, x.pow(y), 1.0e-5);    }    @Test    public void testPowNaNBase() {        Complex x = new Complex(3, 4);        Assert.assertTrue(Complex.NaN.pow(x).isNaN());    }    @Test    public void testPowNaNExponent() {        Complex x = new Complex(3, 4);        Assert.assertTrue(x.pow(Complex.NaN).isNaN());    }   @Test   public void testPowInf() {       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneInf));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneNegInf));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infOne));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infInf));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infNegInf));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfInf));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfNegInf));       TestUtils.assertSame(Complex.NaN,infOne.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,negInfOne.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,infInf.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,infNegInf.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,negInfInf.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infNegInf));       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(negInfNegInf));       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infInf));       TestUtils.assertSame(Complex.NaN,infInf.pow(infNegInf));       TestUtils.assertSame(Complex.NaN,infInf.pow(negInfNegInf));       TestUtils.assertSame(Complex.NaN,infInf.pow(infInf));       TestUtils.assertSame(Complex.NaN,infNegInf.pow(infNegInf));       TestUtils.assertSame(Complex.NaN,infNegInf.pow(negInfNegInf));       TestUtils.assertSame(Complex.NaN,infNegInf.pow(infInf));   }   @Test   public void testPowZero() {       TestUtils.assertSame(Complex.NaN,               Complex.ZERO.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,               Complex.ZERO.pow(Complex.ZERO));       TestUtils.assertSame(Complex.NaN,               Complex.ZERO.pow(Complex.I));       TestUtils.assertEquals(Complex.ONE,               Complex.ONE.pow(Complex.ZERO), 10e-12);       TestUtils.assertEquals(Complex.ONE,               Complex.I.pow(Complex.ZERO), 10e-12);       TestUtils.assertEquals(Complex.ONE,               new Complex(-1, 3).pow(Complex.ZERO), 10e-12);   }    @Test    public void testScalarPow() {        Complex x = new Complex(3, 4);        double yDouble = 5.0;        Complex yComplex = new Complex(yDouble);        Assert.assertEquals(x.pow(yComplex), x.pow(yDouble));    }    @Test    public void testScalarPowNaNBase() {        Complex x = Complex.NaN;        double yDouble = 5.0;        Complex yComplex = new Complex(yDouble);        Assert.assertEquals(x.pow(yComplex), x.pow(yDouble));    }    @Test    public void testScalarPowNaNExponent() {        Complex x = new Complex(3, 4);        double yDouble = Double.NaN;        Complex yComplex = new Complex(yDouble);        Assert.assertEquals(x.pow(yComplex), x.pow(yDouble));    }   @Test   public void testScalarPowInf() {       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(Double.POSITIVE_INFINITY));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(Double.NEGATIVE_INFINITY));       TestUtils.assertSame(Complex.NaN,infOne.pow(1.0));       TestUtils.assertSame(Complex.NaN,negInfOne.pow(1.0));       TestUtils.assertSame(Complex.NaN,infInf.pow(1.0));       TestUtils.assertSame(Complex.NaN,infNegInf.pow(1.0));       TestUtils.assertSame(Complex.NaN,negInfInf.pow(10));       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(1.0));       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Double.POSITIVE_INFINITY));       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Double.POSITIVE_INFINITY));       TestUtils.assertSame(Complex.NaN,infInf.pow(Double.POSITIVE_INFINITY));       TestUtils.assertSame(Complex.NaN,infInf.pow(Double.NEGATIVE_INFINITY));       TestUtils.assertSame(Complex.NaN,infNegInf.pow(Double.NEGATIVE_INFINITY));       TestUtils.assertSame(Complex.NaN,infNegInf.pow(Double.POSITIVE_INFINITY));   }   @Test   public void testScalarPowZero() {       TestUtils.assertSame(Complex.NaN, Complex.ZERO.pow(1.0));       TestUtils.assertSame(Complex.NaN, Complex.ZERO.pow(0.0));       TestUtils.assertEquals(Complex.ONE, Complex.ONE.pow(0.0), 10e-12);       TestUtils.assertEquals(Complex.ONE, Complex.I.pow(0.0), 10e-12);       TestUtils.assertEquals(Complex.ONE, new Complex(-1, 3).pow(0.0), 10e-12);   }    @Test(expected=NullArgumentException.class)    public void testpowNull() {        Complex.ONE.pow(null);    }    @Test    public void testSin() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(3.853738, -27.01681);        TestUtils.assertEquals(expected, z.sin(), 1.0e-5);    }    @Test    public void testSinInf() {        TestUtils.assertSame(infInf, oneInf.sin());        TestUtils.assertSame(infNegInf, oneNegInf.sin());        TestUtils.assertSame(Complex.NaN, infOne.sin());        TestUtils.assertSame(Complex.NaN, negInfOne.sin());        TestUtils.assertSame(Complex.NaN, infInf.sin());        TestUtils.assertSame(Complex.NaN, infNegInf.sin());        TestUtils.assertSame(Complex.NaN, negInfInf.sin());        TestUtils.assertSame(Complex.NaN, negInfNegInf.sin());    }    @Test    public void testSinNaN() {        Assert.assertTrue(Complex.NaN.sin().isNaN());    }    @Test    public void testSinh() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-6.54812, -7.61923);        TestUtils.assertEquals(expected, z.sinh(), 1.0e-5);    }    @Test    public void testSinhNaN() {        Assert.assertTrue(Complex.NaN.sinh().isNaN());    }    @Test    public void testSinhInf() {        TestUtils.assertSame(Complex.NaN, oneInf.sinh());        TestUtils.assertSame(Complex.NaN, oneNegInf.sinh());        TestUtils.assertSame(infInf, infOne.sinh());        TestUtils.assertSame(negInfInf, negInfOne.sinh());        TestUtils.assertSame(Complex.NaN, infInf.sinh());        TestUtils.assertSame(Complex.NaN, infNegInf.sinh());        TestUtils.assertSame(Complex.NaN, negInfInf.sinh());        TestUtils.assertSame(Complex.NaN, negInfNegInf.sinh());    }    @Test    public void testSqrtRealPositive() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(2, 1);        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);    }    @Test    public void testSqrtRealZero() {        Complex z = new Complex(0.0, 4);        Complex expected = new Complex(1.41421, 1.41421);        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);    }    @Test    public void testSqrtRealNegative() {        Complex z = new Complex(-3.0, 4);        Complex expected = new Complex(1, 2);        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);    }    @Test    public void testSqrtImaginaryZero() {        Complex z = new Complex(-3.0, 0.0);        Complex expected = new Complex(0.0, 1.73205);        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);    }    @Test    public void testSqrtImaginaryNegative() {        Complex z = new Complex(-3.0, -4.0);        Complex expected = new Complex(1.0, -2.0);        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);    }    @Test    public void testSqrtPolar() {        double r = 1;        for (int i = 0; i < 5; i++) {            r += i;            double theta = 0;            for (int j =0; j < 11; j++) {                theta += pi /12;                Complex z = ComplexUtils.polar2Complex(r, theta);                Complex sqrtz = ComplexUtils.polar2Complex(FastMath.sqrt(r), theta / 2);                TestUtils.assertEquals(sqrtz, z.sqrt(), 10e-12);            }        }    }    @Test    public void testSqrtNaN() {        Assert.assertTrue(Complex.NaN.sqrt().isNaN());    }    @Test    public void testSqrtInf() {        TestUtils.assertSame(infNaN, oneInf.sqrt());        TestUtils.assertSame(infNaN, oneNegInf.sqrt());        TestUtils.assertSame(infZero, infOne.sqrt());        TestUtils.assertSame(zeroInf, negInfOne.sqrt());        TestUtils.assertSame(infNaN, infInf.sqrt());        TestUtils.assertSame(infNaN, infNegInf.sqrt());        TestUtils.assertSame(nanInf, negInfInf.sqrt());        TestUtils.assertSame(nanNegInf, negInfNegInf.sqrt());    }    @Test    public void testSqrt1z() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(4.08033, -2.94094);        TestUtils.assertEquals(expected, z.sqrt1z(), 1.0e-5);    }    @Test    public void testSqrt1zNaN() {        Assert.assertTrue(Complex.NaN.sqrt1z().isNaN());    }    @Test    public void testTan() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-0.000187346, 0.999356);        TestUtils.assertEquals(expected, z.tan(), 1.0e-5);    }    @Test    public void testTanNaN() {        Assert.assertTrue(Complex.NaN.tan().isNaN());    }    @Test    public void testTanInf() {        TestUtils.assertSame(zeroNaN, oneInf.tan());        TestUtils.assertSame(zeroNaN, oneNegInf.tan());        TestUtils.assertSame(Complex.NaN, infOne.tan());        TestUtils.assertSame(Complex.NaN, negInfOne.tan());        TestUtils.assertSame(Complex.NaN, infInf.tan());        TestUtils.assertSame(Complex.NaN, infNegInf.tan());        TestUtils.assertSame(Complex.NaN, negInfInf.tan());        TestUtils.assertSame(Complex.NaN, negInfNegInf.tan());    }   @Test   public void testTanCritical() {        TestUtils.assertSame(infNaN, new Complex(pi/2, 0).tan());        TestUtils.assertSame(negInfNaN, new Complex(-pi/2, 0).tan());    }    @Test    public void testTanh() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(1.00071, 0.00490826);        TestUtils.assertEquals(expected, z.tanh(), 1.0e-5);    }    @Test    public void testTanhNaN() {        Assert.assertTrue(Complex.NaN.tanh().isNaN());    }    @Test    public void testTanhInf() {        TestUtils.assertSame(Complex.NaN, oneInf.tanh());        TestUtils.assertSame(Complex.NaN, oneNegInf.tanh());        TestUtils.assertSame(nanZero, infOne.tanh());        TestUtils.assertSame(nanZero, negInfOne.tanh());        TestUtils.assertSame(Complex.NaN, infInf.tanh());        TestUtils.assertSame(Complex.NaN, infNegInf.tanh());        TestUtils.assertSame(Complex.NaN, negInfInf.tanh());        TestUtils.assertSame(Complex.NaN, negInfNegInf.tanh());    }    @Test    public void testTanhCritical() {        TestUtils.assertSame(nanInf, new Complex(0, pi/2).tanh());    }    /** test issue MATH-221 */    @Test    public void testMath221() {        Assert.assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0)));    }    /**     * Test: computing <b>third roots</b> of z.     * <pre>     * <code>     * <b>z = -2 + 2 * i</b>     *   => z_0 =  1      +          i     *   => z_1 = -1.3660 + 0.3660 * i     *   => z_2 =  0.3660 - 1.3660 * i     * </code>     * </pre>     */    @Test    public void testNthRoot_normal_thirdRoot() {        // The complex number we want to compute all third-roots for.        Complex z = new Complex(-2,2);        // The List holding all third roots        Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);        // Returned Collection must not be empty!        Assert.assertEquals(3, thirdRootsOfZ.length);        // test z_0        Assert.assertEquals(1.0,                  thirdRootsOfZ[0].getReal(),      1.0e-5);        Assert.assertEquals(1.0,                  thirdRootsOfZ[0].getImaginary(), 1.0e-5);        // test z_1        Assert.assertEquals(-1.3660254037844386,  thirdRootsOfZ[1].getReal(),      1.0e-5);        Assert.assertEquals(0.36602540378443843,  thirdRootsOfZ[1].getImaginary(), 1.0e-5);        // test z_2        Assert.assertEquals(0.366025403784439,    thirdRootsOfZ[2].getReal(),      1.0e-5);        Assert.assertEquals(-1.3660254037844384,  thirdRootsOfZ[2].getImaginary(), 1.0e-5);    }    /**     * Test: computing <b>fourth roots</b> of z.     * <pre>     * <code>     * <b>z = 5 - 2 * i</b>     *   => z_0 =  1.5164 - 0.1446 * i     *   => z_1 =  0.1446 + 1.5164 * i     *   => z_2 = -1.5164 + 0.1446 * i     *   => z_3 = -1.5164 - 0.1446 * i     * </code>     * </pre>     */    @Test    public void testNthRoot_normal_fourthRoot() {        // The complex number we want to compute all third-roots for.        Complex z = new Complex(5,-2);        // The List holding all fourth roots        Complex[] fourthRootsOfZ = z.nthRoot(4).toArray(new Complex[0]);        // Returned Collection must not be empty!        Assert.assertEquals(4, fourthRootsOfZ.length);        // test z_0        Assert.assertEquals(1.5164629308487783,     fourthRootsOfZ[0].getReal(),      1.0e-5);        Assert.assertEquals(-0.14469266210702247,   fourthRootsOfZ[0].getImaginary(), 1.0e-5);        // test z_1        Assert.assertEquals(0.14469266210702256,    fourthRootsOfZ[1].getReal(),      1.0e-5);        Assert.assertEquals(1.5164629308487783,     fourthRootsOfZ[1].getImaginary(), 1.0e-5);        // test z_2        Assert.assertEquals(-1.5164629308487783,    fourthRootsOfZ[2].getReal(),      1.0e-5);        Assert.assertEquals(0.14469266210702267,    fourthRootsOfZ[2].getImaginary(), 1.0e-5);        // test z_3        Assert.assertEquals(-0.14469266210702275,   fourthRootsOfZ[3].getReal(),      1.0e-5);        Assert.assertEquals(-1.5164629308487783,    fourthRootsOfZ[3].getImaginary(), 1.0e-5);    }    /**     * Test: computing <b>third roots</b> of z.     * <pre>     * <code>     * <b>z = 8</b>     *   => z_0 =  2     *   => z_1 = -1 + 1.73205 * i     *   => z_2 = -1 - 1.73205 * i     * </code>     * </pre>     */    @Test    public void testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty() {        // The number 8 has three third roots. One we all already know is the number 2.        // But there are two more complex roots.        Complex z = new Complex(8,0);        // The List holding all third roots        Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);        // Returned Collection must not be empty!        Assert.assertEquals(3, thirdRootsOfZ.length);        // test z_0        Assert.assertEquals(2.0,                thirdRootsOfZ[0].getReal(),      1.0e-5);        Assert.assertEquals(0.0,                thirdRootsOfZ[0].getImaginary(), 1.0e-5);        // test z_1        Assert.assertEquals(-1.0,               thirdRootsOfZ[1].getReal(),      1.0e-5);        Assert.assertEquals(1.7320508075688774, thirdRootsOfZ[1].getImaginary(), 1.0e-5);        // test z_2        Assert.assertEquals(-1.0,               thirdRootsOfZ[2].getReal(),      1.0e-5);        Assert.assertEquals(-1.732050807568877, thirdRootsOfZ[2].getImaginary(), 1.0e-5);    }    /**     * Test: computing <b>third roots</b> of z with real part 0.     * <pre>     * <code>     * <b>z = 2 * i</b>     *   => z_0 =  1.0911 + 0.6299 * i     *   => z_1 = -1.0911 + 0.6299 * i     *   => z_2 = -2.3144 - 1.2599 * i     * </code>     * </pre>     */    @Test    public void testNthRoot_cornercase_thirdRoot_realPartZero() {        // complex number with only imaginary part        Complex z = new Complex(0,2);        // The List holding all third roots        Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);        // Returned Collection must not be empty!        Assert.assertEquals(3, thirdRootsOfZ.length);        // test z_0        Assert.assertEquals(1.0911236359717216,      thirdRootsOfZ[0].getReal(),      1.0e-5);        Assert.assertEquals(0.6299605249474365,      thirdRootsOfZ[0].getImaginary(), 1.0e-5);        // test z_1        Assert.assertEquals(-1.0911236359717216,     thirdRootsOfZ[1].getReal(),      1.0e-5);        Assert.assertEquals(0.6299605249474365,      thirdRootsOfZ[1].getImaginary(), 1.0e-5);        // test z_2        Assert.assertEquals(-2.3144374213981936E-16, thirdRootsOfZ[2].getReal(),      1.0e-5);        Assert.assertEquals(-1.2599210498948732,     thirdRootsOfZ[2].getImaginary(), 1.0e-5);    }    /**     * Test cornercases with NaN and Infinity.     */    @Test    public void testNthRoot_cornercase_NAN_Inf() {        // NaN + finite -> NaN        List<Complex> roots = oneNaN.nthRoot(3);        Assert.assertEquals(1,roots.size());        Assert.assertEquals(Complex.NaN, roots.get(0));        roots = nanZero.nthRoot(3);        Assert.assertEquals(1,roots.size());        Assert.assertEquals(Complex.NaN, roots.get(0));        // NaN + infinite -> NaN        roots = nanInf.nthRoot(3);        Assert.assertEquals(1,roots.size());        Assert.assertEquals(Complex.NaN, roots.get(0));        // finite + infinite -> Inf        roots = oneInf.nthRoot(3);        Assert.assertEquals(1,roots.size());        Assert.assertEquals(Complex.INF, roots.get(0));        // infinite + infinite -> Inf        roots = negInfInf.nthRoot(3);        Assert.assertEquals(1,roots.size());        Assert.assertEquals(Complex.INF, roots.get(0));    }    /**     * Test standard values     */    @Test    public void testGetArgument() {        Complex z = new Complex(1, 0);        Assert.assertEquals(0.0, z.getArgument(), 1.0e-12);        z = new Complex(1, 1);        Assert.assertEquals(FastMath.PI/4, z.getArgument(), 1.0e-12);        z = new Complex(0, 1);        Assert.assertEquals(FastMath.PI/2, z.getArgument(), 1.0e-12);        z = new Complex(-1, 1);        Assert.assertEquals(3 * FastMath.PI/4, z.getArgument(), 1.0e-12);        z = new Complex(-1, 0);        Assert.assertEquals(FastMath.PI, z.getArgument(), 1.0e-12);        z = new Complex(-1, -1);        Assert.assertEquals(-3 * FastMath.PI/4, z.getArgument(), 1.0e-12);        z = new Complex(0, -1);        Assert.assertEquals(-FastMath.PI/2, z.getArgument(), 1.0e-12);        z = new Complex(1, -1);        Assert.assertEquals(-FastMath.PI/4, z.getArgument(), 1.0e-12);    }    /**     * Verify atan2-style handling of infinite parts     */    @Test    public void testGetArgumentInf() {        Assert.assertEquals(FastMath.PI/4, infInf.getArgument(), 1.0e-12);        Assert.assertEquals(FastMath.PI/2, oneInf.getArgument(), 1.0e-12);        Assert.assertEquals(0.0, infOne.getArgument(), 1.0e-12);        Assert.assertEquals(FastMath.PI/2, zeroInf.getArgument(), 1.0e-12);        Assert.assertEquals(0.0, infZero.getArgument(), 1.0e-12);        Assert.assertEquals(FastMath.PI, negInfOne.getArgument(), 1.0e-12);        Assert.assertEquals(-3.0*FastMath.PI/4, negInfNegInf.getArgument(), 1.0e-12);        Assert.assertEquals(-FastMath.PI/2, oneNegInf.getArgument(), 1.0e-12);    }    /**     * Verify that either part NaN results in NaN     */    @Test    public void testGetArgumentNaN() {        Assert.assertTrue(Double.isNaN(nanZero.getArgument()));        Assert.assertTrue(Double.isNaN(zeroNaN.getArgument()));        Assert.assertTrue(Double.isNaN(Complex.NaN.getArgument()));    }    @Test    public void testSerial() {        Complex z = new Complex(3.0, 4.0);        Assert.assertEquals(z, TestUtils.serializeAndRecover(z));        Complex ncmplx = (Complex)TestUtils.serializeAndRecover(oneNaN);        Assert.assertEquals(nanZero, ncmplx);        Assert.assertTrue(ncmplx.isNaN());        Complex infcmplx = (Complex)TestUtils.serializeAndRecover(infInf);        Assert.assertEquals(infInf, infcmplx);        Assert.assertTrue(infcmplx.isInfinite());        TestComplex tz = new TestComplex(3.0, 4.0);        Assert.assertEquals(tz, TestUtils.serializeAndRecover(tz));        TestComplex ntcmplx = (TestComplex)TestUtils.serializeAndRecover(new TestComplex(oneNaN));        Assert.assertEquals(nanZero, ntcmplx);        Assert.assertTrue(ntcmplx.isNaN());        TestComplex inftcmplx = (TestComplex)TestUtils.serializeAndRecover(new TestComplex(infInf));        Assert.assertEquals(infInf, inftcmplx);        Assert.assertTrue(inftcmplx.isInfinite());    }    /**     * Class to test extending Complex     */    public static class TestComplex extends Complex {        /**         * Serialization identifier.         */        private static final long serialVersionUID = 3268726724160389237L;        public TestComplex(double real, double imaginary) {            super(real, imaginary);        }        public TestComplex(Complex other){            this(other.getReal(), other.getImaginary());        }        @Override        protected TestComplex createComplex(double real, double imaginary){            return new TestComplex(real, imaginary);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import java.util.Locale;public class FrenchComplexFormatTest extends ComplexFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return ',';    }    @Override    protected Locale getLocale() {        return Locale.FRENCH;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import java.text.NumberFormat;import java.text.ParsePosition;import java.util.Locale;import org.junit.Test;import org.junit.Assert;import org.apache.commons.math.util.FastMath;public abstract class ComplexFormatAbstractTest {    ComplexFormat complexFormat = null;    ComplexFormat complexFormatJ = null;    protected abstract Locale getLocale();    protected abstract char getDecimalCharacter();    protected ComplexFormatAbstractTest() {        complexFormat = ComplexFormat.getInstance(getLocale());        complexFormatJ = ComplexFormat.getInstance("j", getLocale());    }    @Test    public void testSimpleNoDecimals() {        Complex c = new Complex(1, 2);        String expected = "1 + 2i";        String actual = complexFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testTrimOneImaginary() {        final ComplexFormat fmt = ComplexFormat.getInstance(getLocale());        fmt.getImaginaryFormat().setMaximumFractionDigits(1);        Complex c = new Complex(1, 1.04);        String expected = "1 + i";        String actual = fmt.format(c);        Assert.assertEquals(expected, actual);        c = new Complex(1, 1.09);        expected = "1 + 1" + getDecimalCharacter() + "1i";        actual = fmt.format(c);        Assert.assertEquals(expected, actual);        c = new Complex(1, -1.09);        expected = "1 - 1" + getDecimalCharacter() + "1i";        actual = fmt.format(c);        Assert.assertEquals(expected, actual);        c = new Complex(1, -1.04);        expected = "1 - i";        actual = fmt.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testSimpleWithDecimals() {        Complex c = new Complex(1.23, 1.43);        String expected = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testSimpleWithDecimalsTrunc() {        Complex c = new Complex(1.2323, 1.4343);        String expected = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testNegativeReal() {        Complex c = new Complex(-1.2323, 1.4343);        String expected = "-1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testNegativeImaginary() {        Complex c = new Complex(1.2323, -1.4343);        String expected = "1" + getDecimalCharacter() + "23 - 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testNegativeBoth() {        Complex c = new Complex(-1.2323, -1.4343);        String expected = "-1" + getDecimalCharacter() + "23 - 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testZeroReal() {        Complex c = new Complex(0.0, -1.4343);        String expected = "0 - 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testZeroImaginary() {        Complex c = new Complex(30.233, 0);        String expected = "30" + getDecimalCharacter() + "23";        String actual = complexFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testDifferentImaginaryChar() {        Complex c = new Complex(1, 1);        String expected = "1 + j";        String actual = complexFormatJ.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testDefaultFormatComplex() {        Locale defaultLocal = Locale.getDefault();        Locale.setDefault(getLocale());        Complex c = new Complex(232.222, -342.33);        String expected = "232" + getDecimalCharacter() + "22 - 342" + getDecimalCharacter() + "33i";        String actual = (new ComplexFormat()).format(c);        Assert.assertEquals(expected, actual);        Locale.setDefault(defaultLocal);    }    @Test    public void testNan() {        Complex c = new Complex(Double.NaN, Double.NaN);        String expected = "(NaN) + (NaN)i";        String actual = complexFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testPositiveInfinity() {        Complex c = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);        String expected = "(Infinity) + (Infinity)i";        String actual = complexFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testNegativeInfinity() {        Complex c = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);        String expected = "(-Infinity) - (Infinity)i";        String actual = complexFormat.format(c);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseSimpleNoDecimals() {        String source = "1 + 1i";        Complex expected = new Complex(1, 1);        Complex actual = complexFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseSimpleWithDecimals() {        String source = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";        Complex expected = new Complex(1.23, 1.43);        Complex actual = complexFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseSimpleWithDecimalsTrunc() {        String source = "1" + getDecimalCharacter() + "2323 + 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(1.2323, 1.4343);        Complex actual = complexFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseNegativeReal() {        String source = "-1" + getDecimalCharacter() + "2323 + 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(-1.2323, 1.4343);        Complex actual = complexFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseNegativeImaginary() {        String source = "1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(1.2323, -1.4343);        Complex actual = complexFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseNegativeBoth() {        String source = "-1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(-1.2323, -1.4343);        Complex actual = complexFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseZeroReal() {        String source = "0" + getDecimalCharacter() + "0 - 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(0.0, -1.4343);        Complex actual = complexFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseZeroImaginary() {        String source = "-1" + getDecimalCharacter() + "2323";        Complex expected = new Complex(-1.2323, 0);        Complex actual = complexFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseDifferentImaginaryChar() {        String source = "-1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343j";        Complex expected = new Complex(-1.2323, -1.4343);        Complex actual = complexFormatJ.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParseNan() {        String source = "(NaN) + (NaN)i";        Complex expected = new Complex(Double.NaN, Double.NaN);        Complex actual = complexFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testParsePositiveInfinity() {        String source = "(Infinity) + (Infinity)i";        Complex expected = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);        Complex actual = complexFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testPaseNegativeInfinity() {        String source = "(-Infinity) - (Infinity)i";        Complex expected = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);        Complex actual = complexFormat.parse(source);        Assert.assertEquals(expected, actual);    }    @Test    public void testConstructorSingleFormat() {        NumberFormat nf = NumberFormat.getInstance();        ComplexFormat cf = new ComplexFormat(nf);        Assert.assertNotNull(cf);        Assert.assertEquals(nf, cf.getRealFormat());    }    @Test    public void testGetImaginaryFormat() {        NumberFormat nf = NumberFormat.getInstance();        ComplexFormat cf = new ComplexFormat(nf);        Assert.assertSame(nf, cf.getImaginaryFormat());    }    @Test    public void testGetRealFormat() {        NumberFormat nf = NumberFormat.getInstance();        ComplexFormat cf = new ComplexFormat(nf);        Assert.assertSame(nf, cf.getRealFormat());    }    @Test    public void testFormatNumber() {        ComplexFormat cf = ComplexFormat.getInstance(getLocale());        Double pi = Double.valueOf(FastMath.PI);        String text = cf.format(pi);        Assert.assertEquals("3" + getDecimalCharacter() + "14", text);    }    @Test    public void testForgottenImaginaryCharacter() {        ParsePosition pos = new ParsePosition(0);        Assert.assertNull(new ComplexFormat().parse("1 + 1", pos));        Assert.assertEquals(5, pos.getErrorIndex());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * @version $Id$ */public class ComplexUtilsTest {    private double inf = Double.POSITIVE_INFINITY;    private double negInf = Double.NEGATIVE_INFINITY;    private double nan = Double.NaN;    private double pi = FastMath.PI;    private Complex negInfInf = new Complex(negInf, inf);    private Complex infNegInf = new Complex(inf, negInf);    private Complex infInf = new Complex(inf, inf);    private Complex negInfNegInf = new Complex(negInf, negInf);    private Complex infNaN = new Complex(inf, nan);    @Test    public void testPolar2Complex() {        TestUtils.assertEquals(Complex.ONE,                ComplexUtils.polar2Complex(1, 0), 10e-12);        TestUtils.assertEquals(Complex.ZERO,                ComplexUtils.polar2Complex(0, 1), 10e-12);        TestUtils.assertEquals(Complex.ZERO,                ComplexUtils.polar2Complex(0, -1), 10e-12);        TestUtils.assertEquals(Complex.I,                ComplexUtils.polar2Complex(1, pi/2), 10e-12);        TestUtils.assertEquals(Complex.I.negate(),                ComplexUtils.polar2Complex(1, -pi/2), 10e-12);        double r = 0;        for (int i = 0; i < 5; i++) {          r += i;          double theta = 0;          for (int j =0; j < 20; j++) {              theta += pi / 6;              TestUtils.assertEquals(altPolar(r, theta),                      ComplexUtils.polar2Complex(r, theta), 10e-12);          }          theta = -2 * pi;          for (int j =0; j < 20; j++) {              theta -= pi / 6;              TestUtils.assertEquals(altPolar(r, theta),                      ComplexUtils.polar2Complex(r, theta), 10e-12);          }        }    }    protected Complex altPolar(double r, double theta) {        return Complex.I.multiply(new Complex(theta, 0)).exp().multiply(new Complex(r, 0));    }    @Test    public void testPolar2ComplexIllegalModulus() {        try {            ComplexUtils.polar2Complex(-1, 0);            Assert.fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }    @Test    public void testPolar2ComplexNaN() {        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(nan, 1));        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, nan));        TestUtils.assertSame(Complex.NaN,                ComplexUtils.polar2Complex(nan, nan));    }    @Test    public void testPolar2ComplexInf() {        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, inf));        TestUtils.assertSame(Complex.NaN,                ComplexUtils.polar2Complex(1, negInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(inf, inf));        TestUtils.assertSame(Complex.NaN,                ComplexUtils.polar2Complex(inf, negInf));        TestUtils.assertSame(infInf, ComplexUtils.polar2Complex(inf, pi/4));        TestUtils.assertSame(infNaN, ComplexUtils.polar2Complex(inf, 0));        TestUtils.assertSame(infNegInf, ComplexUtils.polar2Complex(inf, -pi/4));        TestUtils.assertSame(negInfInf, ComplexUtils.polar2Complex(inf, 3*pi/4));        TestUtils.assertSame(negInfNegInf, ComplexUtils.polar2Complex(inf, 5*pi/4));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import java.util.Locale;public class ComplexFormatTest extends ComplexFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return '.';    }    @Override    protected Locale getLocale() {        return Locale.US;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.io.ByteArrayOutputStream;import java.io.PrintStream;import java.io.PrintWriter;import java.util.Locale;import org.apache.commons.math.exception.util.DummyLocalizable;import org.apache.commons.math.exception.util.Localizable;import org.junit.Assert;import org.junit.Test;/** * @version $Id$ */public class MathExceptionTest {    @Test    public void testConstructor(){        MathException ex = new MathException();        Assert.assertNull(ex.getCause());        Assert.assertEquals("", ex.getMessage());        Assert.assertEquals("", ex.getMessage(Locale.FRENCH));    }    @Test    public void testConstructorCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathException ex = new MathException(cause);        Assert.assertEquals(cause, ex.getCause());    }    /**     * Tests the printStackTrace() operation.     */    @Test    public void testPrintStackTrace() {        Localizable outMsg = new DummyLocalizable("outer message");        Localizable inMsg = new DummyLocalizable("inner message");        MathException cause = new MathConfigurationException(inMsg);        MathException ex = new MathException(cause, outMsg);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        PrintStream ps = new PrintStream(baos);        ex.printStackTrace(ps);        String stack = baos.toString();        String outerMsg = "org.apache.commons.math.MathException: outer message";        String innerMsg = "Caused by: " +        "org.apache.commons.math.MathConfigurationException: inner message";        Assert.assertTrue(stack.startsWith(outerMsg));        Assert.assertTrue(stack.indexOf(innerMsg) > 0);        PrintWriter pw = new PrintWriter(ps, true);        ex.printStackTrace(pw);        stack = baos.toString();        Assert.assertTrue(stack.startsWith(outerMsg));        Assert.assertTrue(stack.indexOf(innerMsg) > 0);    }    /**     * Test serialization     */    @Test    public void testSerialization() {        Localizable outMsg = new DummyLocalizable("outer message");        Localizable inMsg = new DummyLocalizable("inner message");        MathException cause = new MathConfigurationException(inMsg);        MathException ex = new MathException(cause, outMsg);        MathException image = (MathException) TestUtils.serializeAndRecover(ex);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        PrintStream ps = new PrintStream(baos);        ex.printStackTrace(ps);        String stack = baos.toString();        ByteArrayOutputStream baos2 = new ByteArrayOutputStream();        PrintStream ps2 = new PrintStream(baos2);        image.printStackTrace(ps2);        String stack2 = baos2.toString();        // See if JDK supports nested exceptions.  If not, stack trace of        // inner exception will not be serialized        boolean jdkSupportsNesting = false;        try {            Throwable.class.getDeclaredMethod("getCause", new Class[0]);            jdkSupportsNesting = true;        } catch (NoSuchMethodException e) {            jdkSupportsNesting = false;        }        if (jdkSupportsNesting) {            Assert.assertEquals(stack, stack2);        } else {            Assert.assertTrue(stack2.indexOf(inMsg.getSourceString()) != -1);            Assert.assertTrue(stack2.indexOf("MathConfigurationException") != -1);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.util.Locale;import org.junit.Assert;import org.junit.Test;/** * @version $Id$ */public class MathConfigurationExceptionTest {    @Test    public void testConstructor(){        MathConfigurationException ex = new MathConfigurationException();        Assert.assertNull(ex.getCause());        Assert.assertEquals("", ex.getMessage());        Assert.assertEquals("", ex.getMessage(Locale.FRENCH));    }    @Test    public void testConstructorCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathConfigurationException ex = new MathConfigurationException(cause);        Assert.assertEquals(cause, ex.getCause());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.text.DecimalFormat;import org.apache.commons.math.complex.Complex;import org.apache.commons.math.complex.ComplexFormat;import org.apache.commons.math.distribution.ContinuousDistribution;import org.apache.commons.math.linear.FieldMatrix;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.stat.inference.ChiSquareTest;import org.apache.commons.math.stat.inference.ChiSquareTestImpl;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.util.MathUtils;import org.junit.Assert;/** * @version $Id$ */public class TestUtils {    /**     * Collection of static methods used in math unit tests.     */    private TestUtils() {        super();    }    /**     * Verifies that expected and actual are within delta, or are both NaN or     * infinities of the same sign.     */    public static void assertEquals(double expected, double actual, double delta) {        Assert.assertEquals(null, expected, actual, delta);    }    /**     * Verifies that expected and actual are within delta, or are both NaN or     * infinities of the same sign.     */    public static void assertEquals(String msg, double expected, double actual, double delta) {        // check for NaN        if(Double.isNaN(expected)){            Assert.assertTrue("" + actual + " is not NaN.",                Double.isNaN(actual));        } else {            Assert.assertEquals(msg, expected, actual, delta);        }    }    /**     * Verifies that the two arguments are exactly the same, either     * both NaN or infinities of same sign, or identical floating point values.     */    public static void assertSame(double expected, double actual) {     Assert.assertEquals(expected, actual, 0);    }    /**     * Verifies that real and imaginary parts of the two complex arguments     * are exactly the same.  Also ensures that NaN / infinite components match.     */    public static void assertSame(Complex expected, Complex actual) {        assertSame(expected.getReal(), actual.getReal());        assertSame(expected.getImaginary(), actual.getImaginary());    }    /**     * Verifies that real and imaginary parts of the two complex arguments     * differ by at most delta.  Also ensures that NaN / infinite components match.     */    public static void assertEquals(Complex expected, Complex actual, double delta) {        Assert.assertEquals(expected.getReal(), actual.getReal(), delta);        Assert.assertEquals(expected.getImaginary(), actual.getImaginary(), delta);    }    /**     * Verifies that two double arrays have equal entries, up to tolerance     */    public static void assertEquals(double expected[], double observed[], double tolerance) {        assertEquals("Array comparison failure", expected, observed, tolerance);    }    /**     * Serializes an object to a bytes array and then recovers the object from the bytes array.     * Returns the deserialized object.     *     * @param o  object to serialize and recover     * @return  the recovered, deserialized object     */    public static Object serializeAndRecover(Object o) {        try {            // serialize the Object            ByteArrayOutputStream bos = new ByteArrayOutputStream();            ObjectOutputStream so = new ObjectOutputStream(bos);            so.writeObject(o);            // deserialize the Object            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());            ObjectInputStream si = new ObjectInputStream(bis);            return si.readObject();        } catch (IOException ioe) {            return null;        } catch (ClassNotFoundException cnfe) {            return null;        }    }    /**     * Verifies that serialization preserves equals and hashCode.     * Serializes the object, then recovers it and checks equals and hash code.     *     * @param object  the object to serialize and recover     */    public static void checkSerializedEquality(Object object) {        Object object2 = serializeAndRecover(object);        Assert.assertEquals("Equals check", object, object2);        Assert.assertEquals("HashCode check", object.hashCode(), object2.hashCode());    }    /**     * Verifies that the relative error in actual vs. expected is less than or     * equal to relativeError.  If expected is infinite or NaN, actual must be     * the same (NaN or infinity of the same sign).     *     * @param expected expected value     * @param actual  observed value     * @param relativeError  maximum allowable relative error     */    public static void assertRelativelyEquals(double expected, double actual,            double relativeError) {        assertRelativelyEquals(null, expected, actual, relativeError);    }    /**     * Verifies that the relative error in actual vs. expected is less than or     * equal to relativeError.  If expected is infinite or NaN, actual must be     * the same (NaN or infinity of the same sign).     *     * @param msg  message to return with failure     * @param expected expected value     * @param actual  observed value     * @param relativeError  maximum allowable relative error     */    public static void assertRelativelyEquals(String msg, double expected,            double actual, double relativeError) {        if (Double.isNaN(expected)) {            Assert.assertTrue(msg, Double.isNaN(actual));        } else if (Double.isNaN(actual)) {            Assert.assertTrue(msg, Double.isNaN(expected));        } else if (Double.isInfinite(actual) || Double.isInfinite(expected)) {            Assert.assertEquals(expected, actual, relativeError);        } else if (expected == 0.0) {            Assert.assertEquals(msg, actual, expected, relativeError);        } else {            double absError = FastMath.abs(expected) * relativeError;            Assert.assertEquals(msg, expected, actual, absError);        }    }    /**     * Fails iff values does not contain a number within epsilon of z.     *     * @param msg  message to return with failure     * @param values complex array to search     * @param z  value sought     * @param epsilon  tolerance     */    public static void assertContains(String msg, Complex[] values,                                      Complex z, double epsilon) {        for (Complex value : values) {            if (MathUtils.equals(value.getReal(), z.getReal(), epsilon) &&                MathUtils.equals(value.getImaginary(), z.getImaginary(), epsilon)) {                return;            }        }        Assert.fail(msg + " Unable to find " + (new ComplexFormat()).format(z));    }    /**     * Fails iff values does not contain a number within epsilon of z.     *     * @param values complex array to search     * @param z  value sought     * @param epsilon  tolerance     */    public static void assertContains(Complex[] values,            Complex z, double epsilon) {        assertContains(null, values, z, epsilon);    }    /**     * Fails iff values does not contain a number within epsilon of x.     *     * @param msg  message to return with failure     * @param values double array to search     * @param x value sought     * @param epsilon  tolerance     */    public static void assertContains(String msg, double[] values,            double x, double epsilon) {        for (double value : values) {            if (MathUtils.equals(value, x, epsilon)) {                return;            }        }        Assert.fail(msg + " Unable to find " + x);    }    /**     * Fails iff values does not contain a number within epsilon of x.     *     * @param values double array to search     * @param x value sought     * @param epsilon  tolerance     */    public static void assertContains(double[] values, double x,            double epsilon) {       assertContains(null, values, x, epsilon);    }    /** verifies that two matrices are close (1-norm) */    public static void assertEquals(String msg, RealMatrix expected, RealMatrix observed, double tolerance) {        Assert.assertNotNull(msg + "\nObserved should not be null",observed);        if (expected.getColumnDimension() != observed.getColumnDimension() ||                expected.getRowDimension() != observed.getRowDimension()) {            StringBuilder messageBuffer = new StringBuilder(msg);            messageBuffer.append("\nObserved has incorrect dimensions.");            messageBuffer.append("\nobserved is " + observed.getRowDimension() +                    " x " + observed.getColumnDimension());            messageBuffer.append("\nexpected " + expected.getRowDimension() +                    " x " + expected.getColumnDimension());            Assert.fail(messageBuffer.toString());        }        RealMatrix delta = expected.subtract(observed);        if (delta.getNorm() >= tolerance) {            StringBuilder messageBuffer = new StringBuilder(msg);            messageBuffer.append("\nExpected: " + expected);            messageBuffer.append("\nObserved: " + observed);            messageBuffer.append("\nexpected - observed: " + delta);            Assert.fail(messageBuffer.toString());        }    }    /** verifies that two matrices are equal */    public static void assertEquals(FieldMatrix<? extends FieldElement<?>> expected,                                    FieldMatrix<? extends FieldElement<?>> observed) {        Assert.assertNotNull("Observed should not be null",observed);        if (expected.getColumnDimension() != observed.getColumnDimension() ||                expected.getRowDimension() != observed.getRowDimension()) {            StringBuilder messageBuffer = new StringBuilder();            messageBuffer.append("Observed has incorrect dimensions.");            messageBuffer.append("\nobserved is " + observed.getRowDimension() +                    " x " + observed.getColumnDimension());            messageBuffer.append("\nexpected " + expected.getRowDimension() +                    " x " + expected.getColumnDimension());            Assert.fail(messageBuffer.toString());        }        for (int i = 0; i < expected.getRowDimension(); ++i) {            for (int j = 0; j < expected.getColumnDimension(); ++j) {                FieldElement<?> eij = expected.getEntry(i, j);                FieldElement<?> oij = observed.getEntry(i, j);                Assert.assertEquals(eij, oij);            }        }    }    /** verifies that two arrays are close (sup norm) */    public static void assertEquals(String msg, double[] expected, double[] observed, double tolerance) {        StringBuilder out = new StringBuilder(msg);        if (expected.length != observed.length) {            out.append("\n Arrays not same length. \n");            out.append("expected has length ");            out.append(expected.length);            out.append(" observed length = ");            out.append(observed.length);            Assert.fail(out.toString());        }        boolean failure = false;        for (int i=0; i < expected.length; i++) {            if (!MathUtils.equalsIncludingNaN(expected[i], observed[i], tolerance)) {                failure = true;                out.append("\n Elements at index ");                out.append(i);                out.append(" differ. ");                out.append(" expected = ");                out.append(expected[i]);                out.append(" observed = ");                out.append(observed[i]);            }        }        if (failure) {            Assert.fail(out.toString());        }    }    /** verifies that two arrays are equal */    public static <T extends FieldElement<T>> void assertEquals(T[] m, T[] n) {        if (m.length != n.length) {            Assert.fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            Assert.assertEquals(m[i],n[i]);        }    }    /**     * Computes the sum of squared deviations of <values> from <target>     * @param values array of deviates     * @param target value to compute deviations from     *     * @return sum of squared deviations     */    public static double sumSquareDev(double[] values, double target) {        double sumsq = 0d;        for (int i = 0; i < values.length; i++) {            final double dev = values[i] - target;            sumsq += (dev * dev);        }        return sumsq;    }        /**     * Asserts the null hypothesis for a ChiSquare test.  Fails and dumps arguments and test     * statistics if the null hypothesis can be rejected with confidence 100 * (1 - alpha)%     *      * @param valueLabels     * @param expected expected counts     * @param observed observed counts     * @param alpha significance level of the test     */    public static void assertChiSquareAccept(String[] valueLabels, double[] expected, long[] observed, double alpha) throws Exception {        ChiSquareTest chiSquareTest = new ChiSquareTestImpl();        // Fail if we can reject null hypothesis that distributions are the same        if (chiSquareTest.chiSquareTest(expected, observed, alpha)) {            StringBuilder msgBuffer = new StringBuilder();            DecimalFormat df = new DecimalFormat("#.##");            msgBuffer.append("Chisquare test failed");            msgBuffer.append(" p-value = ");            msgBuffer.append(chiSquareTest.chiSquareTest(expected, observed));            msgBuffer.append(" chisquare statistic = ");            msgBuffer.append(chiSquareTest.chiSquare(expected, observed));            msgBuffer.append(". \n");            msgBuffer.append("value\texpected\tobserved\n");            for (int i = 0; i < expected.length; i++) {                msgBuffer.append(valueLabels[i]);                msgBuffer.append("\t");                msgBuffer.append(df.format(expected[i]));                msgBuffer.append("\t\t");                msgBuffer.append(observed[i]);                msgBuffer.append("\n");            }            msgBuffer.append("This test can fail randomly due to sampling error with probability ");            msgBuffer.append(alpha);            msgBuffer.append(".");            Assert.fail(msgBuffer.toString());        }       }        /**     * Asserts the null hypothesis for a ChiSquare test.  Fails and dumps arguments and test     * statistics if the null hypothesis can be rejected with confidence 100 * (1 - alpha)%     *      * @param values     * @param expected expected counts     * @param observed observed counts     * @param alpha significance level of the test     */    public static void assertChiSquareAccept(int[] values, double[] expected, long[] observed, double alpha) throws Exception {        String[] labels = new String[values.length];        for (int i = 0; i < values.length; i++) {            labels[i] = Integer.toString(values[i]);        }        assertChiSquareAccept(labels, expected, observed, alpha);    }        /**     * Asserts the null hypothesis for a ChiSquare test.  Fails and dumps arguments and test     * statistics if the null hypothesis can be rejected with confidence 100 * (1 - alpha)%     *      * @param values     * @param expected expected counts     * @param observed observed counts     * @param alpha significance level of the test     */    public static void assertChiSquareAccept(double[] values, double[] expected, long[] observed, double alpha) throws Exception {        String[] labels = new String[values.length];        for (int i = 0; i < values.length; i++) {            labels[i] = Double.toString(values[i]);        }        assertChiSquareAccept(labels, expected, observed, alpha);    }        /**     * Asserts the null hypothesis for a ChiSquare test.  Fails and dumps arguments and test     * statistics if the null hypothesis can be rejected with confidence 100 * (1 - alpha)%     *      * @param expected expected counts     * @param observed observed counts     * @param alpha significance level of the test     */    public static void assertChiSquareAccept(double[] expected, long[] observed, double alpha) throws Exception {        String[] labels = new String[expected.length];        for (int i = 0; i < labels.length; i++) {            labels[i] = Integer.toString(i + 1);        }        assertChiSquareAccept(labels, expected, observed, alpha);    }        /**     * Computes the 25th, 50th and 75th percentiles of the given distribution and returns     * these values in an array.     */    public static double[] getDistributionQuartiles(ContinuousDistribution distribution) throws Exception {        double[] quantiles = new double[3];        quantiles[0] = distribution.inverseCumulativeProbability(0.25d);        quantiles[1] = distribution.inverseCumulativeProbability(0.5d);        quantiles[2] = distribution.inverseCumulativeProbability(0.75d);        return quantiles;    }        /**     * Updates observed counts of values in quartiles.     * counts[0] <-> 1st quartile ... counts[3] <-> top quartile     */    public static void updateCounts(double value, long[] counts, double[] quartiles) {        if (value < quartiles[0]) {            counts[0]++;        } else if (value > quartiles[2]) {            counts[3]++;        } else if (value > quartiles[1]) {            counts[2]++;        } else {            counts[1]++;        }      }        /**     * Eliminates points with zero mass from densityPoints and densityValues parallel     * arrays.  Returns the number of positive mass points and collapses the arrays so     * that the first <returned value> elements of the input arrays represent the positive     * mass points.     */    public static int eliminateZeroMassPoints(int[] densityPoints, double[] densityValues) {        int positiveMassCount = 0;        for (int i = 0; i < densityValues.length; i++) {            if (densityValues[i] > 0) {                positiveMassCount++;            }        }        if (positiveMassCount < densityValues.length) {            int[] newPoints = new int[positiveMassCount];            double[] newValues = new double[positiveMassCount];            int j = 0;            for (int i = 0; i < densityValues.length; i++) {                if (densityValues[i] > 0) {                    newPoints[j] = densityPoints[i];                    newValues[j] = densityValues[i];                    j++;                }            }            System.arraycopy(newPoints,0,densityPoints,0,positiveMassCount);            System.arraycopy(newValues,0,densityValues,0,positiveMassCount);        }        return positiveMassCount;    } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.util.Random;import org.apache.commons.math.exception.MathIllegalStateException;import org.junit.Test;import org.junit.runner.RunWith;/** * Test for the "Retry" functionality (retrying Junit test methods). */@RunWith(RetryRunner.class)public class RetryRunnerTest {    final Random rng = new Random();    /**     * Shows that an always failing test will fail even if it is retried.     */    @Test(expected=MathIllegalStateException.class)    @Retry    public void testRetryFailAlways() {        throw new MathIllegalStateException();    }    /**     * Shows that a test that sometimes fail might succeed if it is retried.     * In this case the high number of retries makes it quite unlikely that     * the exception will be thrown by all of the calls.     */    @Test    @Retry(100)    public void testRetryFailSometimes() {        if (rng.nextBoolean()) {            throw new MathIllegalStateException();        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.util.Locale;import org.junit.Assert;import org.junit.Test;/** * @version $Id$ */public class ConvergenceExceptionTest {    @Test    public void testConstructor(){        ConvergenceException ex = new ConvergenceException();        Assert.assertNull(ex.getCause());        Assert.assertNotNull(ex.getMessage());        Assert.assertNotNull(ex.getMessage(Locale.FRENCH));        Assert.assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    @Test    public void testConstructorCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        ConvergenceException ex = new ConvergenceException(cause);        Assert.assertEquals(cause, ex.getCause());    }}