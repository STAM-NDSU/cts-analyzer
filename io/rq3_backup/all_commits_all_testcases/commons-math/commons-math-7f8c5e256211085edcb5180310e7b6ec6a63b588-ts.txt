// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.geometry;import junit.framework.*;public class RotationTest  extends TestCase {  public RotationTest(String name) {    super(name);  }  public void testIdentity() {    Rotation r = new Rotation();    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);    checkAngle(r.getAngle(), 0);    r = new Rotation(-1, 0, 0, 0, false);    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);    checkAngle(r.getAngle(), 0);    r = new Rotation(42, 0, 0, 0, true);    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);    checkAngle(r.getAngle(), 0);  }  public void testAxisAngle() {    Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * Math.PI / 3);    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusJ);    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusK);    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusI);    double s = 1 / Math.sqrt(3);    checkVector(r.getAxis(), new Vector3D(s, s, s));    checkAngle(r.getAngle(), 2 * Math.PI / 3);    try {      new Rotation(new Vector3D(0, 0, 0), 2 * Math.PI / 3);      fail("an exception should have been thrown");    } catch (ArithmeticException e) {    } catch (Exception e) {      fail("unexpected exception");    }    r = new Rotation(Vector3D.plusK, 1.5 * Math.PI);    checkVector(r.getAxis(), new Vector3D(0, 0, -1));    checkAngle(r.getAngle(), 0.5 * Math.PI);    r = new Rotation(Vector3D.plusJ, Math.PI);    checkVector(r.getAxis(), Vector3D.plusJ);    checkAngle(r.getAngle(), Math.PI);  }  public void testVectorOnePair() {    Vector3D u = new Vector3D(3, 2, 1);    Vector3D v = new Vector3D(-4, 2, 2);    Rotation r = new Rotation(u, v);    checkVector(r.applyTo(u.multiply(v.getNorm())), v.multiply(u.getNorm()));    checkAngle(new Rotation(u, u.negate()).getAngle(), Math.PI);  }  public void testVectorTwoPairs() {    Vector3D u1 = new Vector3D(3, 0, 0);    Vector3D u2 = new Vector3D(0, 5, 0);    Vector3D v1 = new Vector3D(0, 0, 2);    Vector3D v2 = new Vector3D(-2, 0, 2);    Rotation r = new Rotation(u1, u2, v1, v2);    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.minusI);    r = new Rotation(u1, u2, u1.negate(), u2.negate());    Vector3D axis = r.getAxis();    if (Vector3D.dotProduct(axis, Vector3D.plusK) > 0) {      checkVector(axis, Vector3D.plusK);    } else {      checkVector(axis, Vector3D.minusK);    }    checkAngle(r.getAngle(), Math.PI);  }  public void testMatrix()    throws NotARotationMatrixException {    double[][] m1 = { { 0.0, 1.0, 0.0 },                      { 0.0, 0.0, 1.0 },                      { 1.0, 0.0, 0.0 } };    Rotation r = new Rotation(m1, 1.0e-7);    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusI);    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusJ);    double[][] m2 = { { 0.83203, -0.55012, -0.07139 },                      { 0.48293,  0.78164, -0.39474 },                      { 0.27296,  0.29396,  0.91602 } };    r = new Rotation(m2, 1.0e-12);    double[][] m3 = r.getMatrix();    double d00 = m2[0][0] - m3[0][0];    double d01 = m2[0][1] - m3[0][1];    double d02 = m2[0][2] - m3[0][2];    double d10 = m2[1][0] - m3[1][0];    double d11 = m2[1][1] - m3[1][1];    double d12 = m2[1][2] - m3[1][2];    double d20 = m2[2][0] - m3[2][0];    double d21 = m2[2][1] - m3[2][1];    double d22 = m2[2][2] - m3[2][2];    assertTrue(Math.abs(d00) < 6.0e-6);    assertTrue(Math.abs(d01) < 6.0e-6);    assertTrue(Math.abs(d02) < 6.0e-6);    assertTrue(Math.abs(d10) < 6.0e-6);    assertTrue(Math.abs(d11) < 6.0e-6);    assertTrue(Math.abs(d12) < 6.0e-6);    assertTrue(Math.abs(d20) < 6.0e-6);    assertTrue(Math.abs(d21) < 6.0e-6);    assertTrue(Math.abs(d22) < 6.0e-6);    assertTrue(Math.abs(d00) > 4.0e-7);    assertTrue(Math.abs(d01) > 4.0e-7);    assertTrue(Math.abs(d02) > 4.0e-7);    assertTrue(Math.abs(d10) > 4.0e-7);    assertTrue(Math.abs(d11) > 4.0e-7);    assertTrue(Math.abs(d12) > 4.0e-7);    assertTrue(Math.abs(d20) > 4.0e-7);    assertTrue(Math.abs(d21) > 4.0e-7);    assertTrue(Math.abs(d22) > 4.0e-7);    for (int i = 0; i < 3; ++i) {      for (int j = 0; j < 3; ++j) {        double m3tm3 = m3[i][0] * m3[j][0]                     + m3[i][1] * m3[j][1]                     + m3[i][2] * m3[j][2];        if (i == j) {          assertTrue(Math.abs(m3tm3 - 1.0) < 1.0e-10);        } else {          assertTrue(Math.abs(m3tm3) < 1.0e-10);        }      }    }    checkVector(r.applyTo(Vector3D.plusI),                new Vector3D(m3[0][0], m3[1][0], m3[2][0]));    checkVector(r.applyTo(Vector3D.plusJ),                new Vector3D(m3[0][1], m3[1][1], m3[2][1]));    checkVector(r.applyTo(Vector3D.plusK),                new Vector3D(m3[0][2], m3[1][2], m3[2][2]));    double[][] m4 = { { 1.0,  0.0,  0.0 },                      { 0.0, -1.0,  0.0 },                      { 0.0,  0.0, -1.0 } };    r = new Rotation(m4, 1.0e-7);    checkAngle(r.getAngle(), Math.PI);    try {      double[][] m5 = { { 0.0, 0.0, 1.0 },                        { 0.0, 1.0, 0.0 },                        { 1.0, 0.0, 0.0 } };      r = new Rotation(m5, 1.0e-7);      fail("got " + r + ", should have caught an exception");    } catch (NotARotationMatrixException e) {      // expected    } catch (Exception e) {      fail("wrong exception caught");    }  }  public void testAngles()    throws CardanEulerSingularityException {    RotationOrder[] CardanOrders = {      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX    };    RotationOrder[] EulerOrders = {      RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,      RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ    };    for (int i = 0; i < CardanOrders.length; ++i) {      for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {        for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) {          for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {            Rotation r = new Rotation(CardanOrders[i],                                      alpha1, alpha2, alpha3);            double[] angles = r.getAngles(CardanOrders[i]);            checkAngle(angles[0], alpha1);            checkAngle(angles[1], alpha2);            checkAngle(angles[2], alpha3);          }        }      }    }    for (int i = 0; i < EulerOrders.length; ++i) {      for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {        for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.3) {          for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {            Rotation r = new Rotation(EulerOrders[i],                                      alpha1, alpha2, alpha3);            double[] angles = r.getAngles(EulerOrders[i]);            checkAngle(angles[0], alpha1);            checkAngle(angles[1], alpha2);            checkAngle(angles[2], alpha3);          }        }      }    }  }  public void testQuaternion() {    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);    double n = 23.5;    Rotation r2 = new Rotation(n * r1.getQ0(), n * r1.getQ1(),                               n * r1.getQ2(), n * r1.getQ3(),                               true);    for (double x = -0.9; x < 0.9; x += 0.2) {      for (double y = -0.9; y < 0.9; y += 0.2) {        for (double z = -0.9; z < 0.9; z += 0.2) {          Vector3D u = new Vector3D(x, y, z);          checkVector(r2.applyTo(u), r1.applyTo(u));        }      }    }  }  public void testCompose() {    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);    Rotation r3 = r2.applyTo(r1);    for (double x = -0.9; x < 0.9; x += 0.2) {      for (double y = -0.9; y < 0.9; y += 0.2) {        for (double z = -0.9; z < 0.9; z += 0.2) {          Vector3D u = new Vector3D(x, y, z);          checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));        }      }    }  }  public void testComposeInverse() {    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);    Rotation r3 = r2.applyInverseTo(r1);    for (double x = -0.9; x < 0.9; x += 0.2) {      for (double y = -0.9; y < 0.9; y += 0.2) {        for (double z = -0.9; z < 0.9; z += 0.2) {          Vector3D u = new Vector3D(x, y, z);          checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));        }      }    }  }  public void testApplyInverseTo() {    Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7);    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {      for (double phi = -1.55; phi < 1.55; phi += 0.2) {          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),                                    Math.sin(lambda) * Math.cos(phi),                                    Math.sin(phi));          r.applyInverseTo(r.applyTo(u));          checkVector(u, r.applyInverseTo(r.applyTo(u)));          checkVector(u, r.applyTo(r.applyInverseTo(u)));      }    }    r = new Rotation();    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {      for (double phi = -1.55; phi < 1.55; phi += 0.2) {          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),                                    Math.sin(lambda) * Math.cos(phi),                                    Math.sin(phi));          checkVector(u, r.applyInverseTo(r.applyTo(u)));          checkVector(u, r.applyTo(r.applyInverseTo(u)));      }    }    r = new Rotation(Vector3D.plusK, Math.PI);    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {      for (double phi = -1.55; phi < 1.55; phi += 0.2) {          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),                                    Math.sin(lambda) * Math.cos(phi),                                    Math.sin(phi));          checkVector(u, r.applyInverseTo(r.applyTo(u)));          checkVector(u, r.applyTo(r.applyInverseTo(u)));      }    }  }  private void checkVector(Vector3D v1, Vector3D v2) {    assertTrue(v1.subtract(v2).getNorm() < 1.0e-10);  }  private void checkAngle(double a1, double a2) {    a2 -= 2 * Math.PI * Math.floor((a2 + Math.PI - a1) / (2 * Math.PI));    assertTrue(Math.abs(a1 - a2) < 1.0e-10);  }  public static Test suite() {    return new TestSuite(RotationTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.geometry;import junit.framework.*;public class Vector3DTest  extends TestCase {  public Vector3DTest(String name) {    super(name);  }  public void testCoordinates() {    Vector3D v = new Vector3D(1, 2, 3);    assertTrue(Math.abs(v.getX() - 1) < 1.0e-12);    assertTrue(Math.abs(v.getY() - 2) < 1.0e-12);    assertTrue(Math.abs(v.getZ() - 3) < 1.0e-12);  }    public void testNorm() {    assertTrue(Math.abs(new Vector3D().getNorm()) < 1.0e-12);    assertTrue(Math.abs(new Vector3D(1, 2, 3).getNorm() - Math.sqrt(14))               < 1.0e-12);  }  public void testSubtract() {    Vector3D v1 = new Vector3D(1, 2, 3);    Vector3D v2 = new Vector3D(-3, -2, -1);    v1 = v1.subtract(v2);    checkVector(v1, new Vector3D(4, 4, 4));    checkVector(v2.subtract(v1), new Vector3D(-7, -6, -5));  }  public void testAdd() {    Vector3D v1 = new Vector3D(1, 2, 3);    Vector3D v2 = new Vector3D(-3, -2, -1);    v1 = v1.add(v2);    checkVector(v1, new Vector3D(-2, 0, 2));    checkVector(v2.add(v1), new Vector3D(-5, -2, 1));  }  public void testScalarProduct() {    Vector3D v = new Vector3D(1, 2, 3);    v = v.multiply(3);    checkVector(v, new Vector3D(3, 6, 9));    checkVector(v.multiply(0.5), new Vector3D(1.5, 3, 4.5));  }  public void testVectorialProducts() {    Vector3D v1 = new Vector3D(2, 1, -4);    Vector3D v2 = new Vector3D(3, 1, -1);    assertTrue(Math.abs(Vector3D.dotProduct(v1, v2) - 11) < 1.0e-12);    Vector3D v3 = Vector3D.crossProduct(v1, v2);    checkVector(v3, new Vector3D(3, -10, -1));    assertTrue(Math.abs(Vector3D.dotProduct(v1, v3)) < 1.0e-12);    assertTrue(Math.abs(Vector3D.dotProduct(v2, v3)) < 1.0e-12);  }  public void testAngular() {    assertEquals(0,           Vector3D.plusI.getAlpha(), 1.0e-10);    assertEquals(0,           Vector3D.plusI.getDelta(), 1.0e-10);    assertEquals(Math.PI / 2, Vector3D.plusJ.getAlpha(), 1.0e-10);    assertEquals(0,           Vector3D.plusJ.getDelta(), 1.0e-10);    assertEquals(0,           Vector3D.plusK.getAlpha(), 1.0e-10);    assertEquals(Math.PI / 2, Vector3D.plusK.getDelta(), 1.0e-10);    Vector3D u = new Vector3D(-1, 1, -1);    assertEquals(3 * Math.PI /4, u.getAlpha(), 1.0e-10);    assertEquals(-1.0 / Math.sqrt(3), Math.sin(u.getDelta()), 1.0e-10);  }  public void testAngularSeparation() {    Vector3D v1 = new Vector3D(2, -1, 4);    Vector3D  k = v1.normalize();    Vector3D  i = k.orthogonal();    Vector3D v2 = k.multiply(Math.cos(1.2)).add(i.multiply(Math.sin(1.2)));    assertTrue(Math.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12);  }  private void checkVector(Vector3D v1, Vector3D v2) {    assertTrue(v1.subtract(v2).getNorm() < 1.0e-12);  }    public static Test suite() {    return new TestSuite(Vector3DTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.estimation;import junit.framework.*;public class EstimatedParameterTest  extends TestCase {  public EstimatedParameterTest(String name) {    super(name);  }  public void testConstruction() {    EstimatedParameter p1 = new EstimatedParameter("p1", 1.0);    assertTrue(p1.getName().equals("p1"));    checkValue(p1.getEstimate(), 1.0);    assertTrue(! p1.isBound());    EstimatedParameter p2 = new EstimatedParameter("p2", 2.0, true);    assertTrue(p2.getName().equals("p2"));    checkValue(p2.getEstimate(), 2.0);    assertTrue(p2.isBound());  }  public void testBound() {    EstimatedParameter p = new EstimatedParameter("p", 0.0);    assertTrue(! p.isBound());    p.setBound(true);    assertTrue(p.isBound());    p.setBound(false);    assertTrue(! p.isBound());  }  public void testEstimate() {    EstimatedParameter p = new EstimatedParameter("p", 0.0);    checkValue(p.getEstimate(), 0.0);    for (double e = 0.0; e < 10.0; e += 0.5) {      p.setEstimate(e);      checkValue(p.getEstimate(), e);    }  }  public static Test suite() {    return new TestSuite(EstimatedParameterTest.class);  }  private void checkValue(double value, double expected) {    assertTrue(Math.abs(value - expected) < 1.0e-10);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.estimation;import java.util.Random;import junit.framework.*;public class GaussNewtonEstimatorTest  extends TestCase  implements EstimationProblem {  public GaussNewtonEstimatorTest(String name) {    super(name);  }  public void testNoMeasurementError()    throws EstimationException {    initRandomizedGrid(2.3);    initProblem(0.0);    GaussNewtonEstimator estimator =      new GaussNewtonEstimator(100, 1.0e-7, 1.0e-10, 1.0e-10);    estimator.estimate(this);    checkGrid(0.01);  }  public void testSmallMeasurementError()    throws EstimationException {    initRandomizedGrid(2.3);    initProblem(0.02);    GaussNewtonEstimator estimator =      new GaussNewtonEstimator(100, 1.0e-7, 1.0e-10, 1.0e-10);    estimator.estimate(this);    checkGrid(0.1);  }  public void testNoError()    throws EstimationException {    initRandomizedGrid(0.0);    initProblem(0.0);    GaussNewtonEstimator estimator =      new GaussNewtonEstimator(100, 1.0e-7, 1.0e-10, 1.0e-10);    estimator.estimate(this);    checkGrid(1.0e-10);  }  public void testUnsolvableProblem() {    initRandomizedGrid(2.3);    initProblem(0.0);    // reduce the number of measurements below the limit threshold    int unknowns = unboundPars.length;    WeightedMeasurement[] reducedSet = new WeightedMeasurement[unknowns - 1];    for (int i = 0; i < reducedSet.length; ++i) {      reducedSet[i] = measurements[i];    }    measurements = reducedSet;    boolean gotIt = false;    try {      GaussNewtonEstimator estimator =        new GaussNewtonEstimator(100, 1.0e-7, 1.0e-10, 1.0e-10);      estimator.estimate(this);    } catch(EstimationException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public static Test suite() {    return new TestSuite(GaussNewtonEstimatorTest.class);  }  public void setUp() {    initPerfectGrid(5);  }  public void tearDown() {    perfectPars    = null;    randomizedPars = null;    unboundPars    = null;    measurements   = null;  }  private void initPerfectGrid(int gridSize) {    perfectPars = new EstimatedParameter[gridSize * gridSize * 2];    int k = 0;    for (int i = 0; i < gridSize; ++i) {      for (int j = 0; j < gridSize; ++j) {        String name            = Integer.toString(k);        perfectPars[2 * k]     = new EstimatedParameter("x" + name, i);        perfectPars[2 * k + 1] = new EstimatedParameter("y" + name, j);        ++k;      }    }  }  private void initRandomizedGrid(double initialGuessError) {    Random randomizer = new Random(2353995334l);    randomizedPars    = new EstimatedParameter[perfectPars.length];    // add an error to every point coordinate    for (int k = 0; k < randomizedPars.length; ++k) {      String name  = perfectPars[k].getName();      double value = perfectPars[k].getEstimate();      double error = randomizer.nextGaussian() * initialGuessError;      randomizedPars[k] = new EstimatedParameter(name, value + error);    }  }  private void initProblem(double measurementError) {    int pointsNumber       = randomizedPars.length / 2;    int measurementsNumber = pointsNumber * (pointsNumber - 1) / 2;    measurements           = new WeightedMeasurement[measurementsNumber];    Random randomizer = new Random(5785631926l);    // for the test, we consider that the perfect grid is the reality    // and that the randomized grid is the first (wrong) estimate.    int i = 0;    for (int l = 0; l < (pointsNumber - 1); ++l) {      for (int m = l + 1; m < pointsNumber; ++m) {        // perfect measurements on the real data        double dx = perfectPars[2 * l].getEstimate()          - perfectPars[2 * m].getEstimate();        double dy = perfectPars[2 * l + 1].getEstimate()          - perfectPars[2 * m + 1].getEstimate();        double d = Math.sqrt(dx * dx + dy * dy);        // adding a noise to the measurements        d += randomizer.nextGaussian() * measurementError;        // add the measurement to the current problem        measurements[i++] = new Distance(1.0, d,                                         randomizedPars[2 * l],                                         randomizedPars[2 * l + 1],                                         randomizedPars[2 * m],                                         randomizedPars[2 * m + 1]);      }    }    // fix three values in the randomized grid and bind them (there    // are two abscissas and one ordinate, so if there were no error    // at all, the estimated grid should be correctly centered on the    // perfect grid)    int oddNumber = 2 * (randomizedPars.length / 4) - 1;    for (int k = 0; k < 2 * oddNumber + 1; k += oddNumber) {      randomizedPars[k].setEstimate(perfectPars[k].getEstimate());      randomizedPars[k].setBound(true);    }    // store the unbound parameters in a specific table    unboundPars = new EstimatedParameter[randomizedPars.length - 3];    for (int src = 0, dst = 0; src < randomizedPars.length; ++src) {      if (! randomizedPars[src].isBound()) {        unboundPars[dst++] = randomizedPars[src];      }    }  }  private void checkGrid(double threshold) {    double rms = 0;    for (int i = 0; i < perfectPars.length; ++i) {      rms += perfectPars[i].getEstimate() - randomizedPars[i].getEstimate();    }    rms = Math.sqrt(rms / perfectPars.length);    assertTrue(rms <= threshold);  }  private static class Distance extends WeightedMeasurement {    public Distance(double weight, double measuredValue,                    EstimatedParameter x1, EstimatedParameter y1,                    EstimatedParameter x2, EstimatedParameter y2) {      super(weight, measuredValue);      this.x1 = x1;      this.y1 = y1;      this.x2 = x2;      this.y2 = y2;    }    public double getTheoreticalValue() {      double dx = x2.getEstimate() - x1.getEstimate();      double dy = y2.getEstimate() - y1.getEstimate();      return Math.sqrt(dx * dx + dy * dy);    }    public double getPartial(EstimatedParameter p) {      // first quick answer for most parameters      if ((p != x1) && (p != y1) && (p != x2) && (p != y2)) {        return 0.0;      }      // compute the value now as we know we depend on the specified parameter      double distance = getTheoreticalValue();      if (p == x1) {        return (x1.getEstimate() - x2.getEstimate()) / distance;      } else if (p == x2) {        return (x2.getEstimate() - x1.getEstimate()) / distance;      } else if (p == y1) {        return (y1.getEstimate() - y2.getEstimate()) / distance;      } else {        return (y2.getEstimate() - y1.getEstimate()) / distance;      }    }    private EstimatedParameter x1;    private EstimatedParameter y1;    private EstimatedParameter x2;    private EstimatedParameter y2;    private static final long serialVersionUID = 4090004243280980746L;  }  public WeightedMeasurement[] getMeasurements() {    return (WeightedMeasurement[]) measurements.clone();  }  public EstimatedParameter[] getUnboundParameters() {    return (EstimatedParameter[]) unboundPars.clone();  }  public EstimatedParameter[] getAllParameters() {    return (EstimatedParameter[]) randomizedPars.clone();  }  private EstimatedParameter[]  perfectPars;  private EstimatedParameter[]  randomizedPars;  private EstimatedParameter[]  unboundPars;  private WeightedMeasurement[] measurements;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.spaceroots.mantissa.estimation;import java.util.ArrayList;import java.util.IdentityHashMap;import java.util.Iterator;import java.util.Set;import junit.framework.*;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files.  * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */public class LevenbergMarquardtEstimatorTest  extends TestCase {  public LevenbergMarquardtEstimatorTest(String name) {    super(name);  }  public void testTrivial() throws EstimationException {    LinearProblem problem =      new LinearProblem(new LinearMeasurement[] {        new LinearMeasurement(new double[] {2},                              new EstimatedParameter[] {                                 new EstimatedParameter("p0", 0)                              }, 3.0)      });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(1.5,                 problem.getUnboundParameters()[0].getEstimate(),                 1.0e-10);   }  public void testQRColumnsPermutation() throws EstimationException {    EstimatedParameter[] x = {       new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 0)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, -1.0 },                            new EstimatedParameter[] { x[0], x[1] },                            4.0),      new LinearMeasurement(new double[] { 2.0 },                            new EstimatedParameter[] { x[1] },                            6.0),      new LinearMeasurement(new double[] { 1.0, -2.0 },                            new EstimatedParameter[] { x[0], x[1] },                            1.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(7.0, x[0].getEstimate(), 1.0e-10);    assertEquals(3.0, x[1].getEstimate(), 1.0e-10);  }  public void testNoDependency() throws EstimationException {    EstimatedParameter[] p = new EstimatedParameter[] {      new EstimatedParameter("p0", 0),      new EstimatedParameter("p1", 0),      new EstimatedParameter("p2", 0),      new EstimatedParameter("p3", 0),      new EstimatedParameter("p4", 0),      new EstimatedParameter("p5", 0)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[0] }, 0.0),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[1] }, 1.1),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[2] }, 2.2),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[3] }, 3.3),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[4] }, 4.4),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[5] }, 5.5)    });  LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();  estimator.estimate(problem);  assertEquals(0, estimator.getRMS(problem), 1.0e-10);  for (int i = 0; i < p.length; ++i) {    assertEquals(0.55 * i, p[i].getEstimate(), 1.0e-10);  }}  public void testOneSet() throws EstimationException {    EstimatedParameter[] p = {       new EstimatedParameter("p0", 0),       new EstimatedParameter("p1", 0),       new EstimatedParameter("p2", 0)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0 },                            new EstimatedParameter[] { p[0] },                            1.0),      new LinearMeasurement(new double[] { -1.0, 1.0 },                            new EstimatedParameter[] { p[0], p[1] },                            1.0),      new LinearMeasurement(new double[] { -1.0, 1.0 },                            new EstimatedParameter[] { p[1], p[2] },                            1.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(1.0, p[0].getEstimate(), 1.0e-10);    assertEquals(2.0, p[1].getEstimate(), 1.0e-10);    assertEquals(3.0, p[2].getEstimate(), 1.0e-10);  }  public void testTwoSets() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 0),      new EstimatedParameter("p1", 1),      new EstimatedParameter("p2", 2),      new EstimatedParameter("p3", 3),      new EstimatedParameter("p4", 4),      new EstimatedParameter("p5", 5)    };    double epsilon = 1.0e-7;    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      // 4 elements sub-problem      new LinearMeasurement(new double[] {  2.0,  1.0,  4.0 },                            new EstimatedParameter[] { p[0], p[1], p[3] },                            2.0),      new LinearMeasurement(new double[] { -4.0, -2.0,   3.0, -7.0 },                           new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                           -9.0),      new LinearMeasurement(new double[] {  4.0,  1.0,  -2.0,  8.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            2.0),      new LinearMeasurement(new double[] { -3.0, -12.0, -1.0 },                           new EstimatedParameter[] { p[1], p[2], p[3] },                           2.0),      // 2 elements sub-problem      new LinearMeasurement(new double[] { epsilon, 1.0 },                            new EstimatedParameter[] { p[4], p[5] },                            1.0 + epsilon * epsilon),      new LinearMeasurement(new double[] {  1.0, 1.0 },                            new EstimatedParameter[] { p[4], p[5] },                            2.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals( 3.0, p[0].getEstimate(), 1.0e-10);    assertEquals( 4.0, p[1].getEstimate(), 1.0e-10);    assertEquals(-1.0, p[2].getEstimate(), 1.0e-10);    assertEquals(-2.0, p[3].getEstimate(), 1.0e-10);    assertEquals( 1.0 + epsilon, p[4].getEstimate(), 1.0e-10);    assertEquals( 1.0 - epsilon, p[5].getEstimate(), 1.0e-10);  }  public void testNonInversible() throws EstimationException {    EstimatedParameter[] p = {       new EstimatedParameter("p0", 0),       new EstimatedParameter("p1", 0),       new EstimatedParameter("p2", 0)    };    LinearMeasurement[] m = new LinearMeasurement[] {      new LinearMeasurement(new double[] {  1.0, 2.0, -3.0 },                            new EstimatedParameter[] { p[0], p[1], p[2] },                            1.0),      new LinearMeasurement(new double[] {  2.0, 1.0,  3.0 },                            new EstimatedParameter[] { p[0], p[1], p[2] },                            1.0),      new LinearMeasurement(new double[] { -3.0, -9.0 },                            new EstimatedParameter[] { p[0], p[2] },                            1.0)    };    LinearProblem problem = new LinearProblem(m);    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    double initialCost = estimator.getRMS(problem);    estimator.estimate(problem);    assertTrue(estimator.getRMS(problem) < initialCost);    assertTrue(Math.sqrt(m.length) * estimator.getRMS(problem) > 0.6);    double dJ0 = 2 * (m[0].getResidual() * m[0].getPartial(p[0])                    + m[1].getResidual() * m[1].getPartial(p[0])                    + m[2].getResidual() * m[2].getPartial(p[0]));    double dJ1 = 2 * (m[0].getResidual() * m[0].getPartial(p[1])                    + m[1].getResidual() * m[1].getPartial(p[1]));    double dJ2 = 2 * (m[0].getResidual() * m[0].getPartial(p[2])                    + m[1].getResidual() * m[1].getPartial(p[2])                    + m[2].getResidual() * m[2].getPartial(p[2]));    assertEquals(0, dJ0, 1.0e-10);    assertEquals(0, dJ1, 1.0e-10);    assertEquals(0, dJ2, 1.0e-10);  }  public void testIllConditioned() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 0),      new EstimatedParameter("p1", 1),      new EstimatedParameter("p2", 2),      new EstimatedParameter("p3", 3)    };    LinearProblem problem1 = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 10.0, 7.0,  8.0,  7.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            32.0),      new LinearMeasurement(new double[] {  7.0, 5.0,  6.0,  5.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            23.0),      new LinearMeasurement(new double[] {  8.0, 6.0, 10.0,  9.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            33.0),      new LinearMeasurement(new double[] {  7.0, 5.0,  9.0, 10.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            31.0)    });    LevenbergMarquardtEstimator estimator1 = new LevenbergMarquardtEstimator();    estimator1.estimate(problem1);    assertEquals(0, estimator1.getRMS(problem1), 1.0e-10);    assertEquals(1.0, p[0].getEstimate(), 1.0e-10);    assertEquals(1.0, p[1].getEstimate(), 1.0e-10);    assertEquals(1.0, p[2].getEstimate(), 1.0e-10);    assertEquals(1.0, p[3].getEstimate(), 1.0e-10);    LinearProblem problem2 = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 10.0, 7.0,  8.1,  7.2 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            32.0),      new LinearMeasurement(new double[] {  7.08, 5.04,  6.0,  5.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            23.0),      new LinearMeasurement(new double[] {  8.0, 5.98, 9.89,  9.0 },                             new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            33.0),      new LinearMeasurement(new double[] {  6.99, 4.99,  9.0, 9.98 },                             new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            31.0)    });    LevenbergMarquardtEstimator estimator2 = new LevenbergMarquardtEstimator();    estimator2.estimate(problem2);    assertEquals(0, estimator2.getRMS(problem2), 1.0e-10);    assertEquals(-81.0, p[0].getEstimate(), 1.0e-8);    assertEquals(137.0, p[1].getEstimate(), 1.0e-8);    assertEquals(-34.0, p[2].getEstimate(), 1.0e-8);    assertEquals( 22.0, p[3].getEstimate(), 1.0e-8);  }  public void testMoreEstimatedParametersSimple() throws EstimationException {    EstimatedParameter[] p = {       new EstimatedParameter("p0", 7),       new EstimatedParameter("p1", 6),       new EstimatedParameter("p2", 5),       new EstimatedParameter("p3", 4)     };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 3.0, 2.0 },                             new EstimatedParameter[] { p[0], p[1] },                             7.0),      new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },                             new EstimatedParameter[] { p[1], p[2], p[3] },                             3.0),      new LinearMeasurement(new double[] { 2.0, 1.0 },                             new EstimatedParameter[] { p[0], p[2] },                             5.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);  }  public void testMoreEstimatedParametersUnsorted() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 2),      new EstimatedParameter("p1", 2),      new EstimatedParameter("p2", 2),      new EstimatedParameter("p3", 2),      new EstimatedParameter("p4", 2),      new EstimatedParameter("p5", 2)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, 1.0 },                           new EstimatedParameter[] { p[0], p[1] },                           3.0),      new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 },                           new EstimatedParameter[] { p[2], p[3], p[4] },                           12.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                           new EstimatedParameter[] { p[4], p[5] },                           -1.0),      new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },                           new EstimatedParameter[] { p[3], p[2], p[5] },                           7.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                           new EstimatedParameter[] { p[4], p[3] },                           1.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(3.0, p[2].getEstimate(), 1.0e-10);    assertEquals(4.0, p[3].getEstimate(), 1.0e-10);    assertEquals(5.0, p[4].getEstimate(), 1.0e-10);    assertEquals(6.0, p[5].getEstimate(), 1.0e-10);  }  public void testRedundantEquations() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 1),      new EstimatedParameter("p1", 1)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, 1.0 },                             new EstimatedParameter[] { p[0], p[1] },                             3.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                             new EstimatedParameter[] { p[0], p[1] },                             1.0),      new LinearMeasurement(new double[] { 1.0, 3.0 },                             new EstimatedParameter[] { p[0], p[1] },                             5.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(2.0, p[0].getEstimate(), 1.0e-10);    assertEquals(1.0, p[1].getEstimate(), 1.0e-10);  }  public void testInconsistentEquations() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 1),      new EstimatedParameter("p1", 1)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, 1.0 },                            new EstimatedParameter[] { p[0], p[1] },                            3.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                            new EstimatedParameter[] { p[0], p[1] },                            1.0),      new LinearMeasurement(new double[] { 1.0, 3.0 },                            new EstimatedParameter[] { p[0], p[1] },                            4.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertTrue(estimator.getRMS(problem) > 0.1);  }  public void testCircleFitting() throws EstimationException {    Circle circle = new Circle(98.680, 47.345);    circle.addPoint( 30.0,  68.0);    circle.addPoint( 50.0,  -6.0);    circle.addPoint(110.0, -20.0);    circle.addPoint( 35.0,  15.0);    circle.addPoint( 45.0,  97.0);    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(circle);    assertTrue(estimator.getCostEvaluations() < 10);    assertTrue(estimator.getJacobianEvaluations() < 10);    double rms = estimator.getRMS(circle);    assertEquals(1.768262623567235,  Math.sqrt(circle.getM()) * rms,  1.0e-10);    assertEquals(69.96016176931406, circle.getRadius(), 1.0e-10);    assertEquals(96.07590211815305, circle.getX(),      1.0e-10);    assertEquals(48.13516790438953, circle.getY(),      1.0e-10);  }  public void testCircleFittingBadInit() throws EstimationException {    Circle circle = new Circle(-12, -12);    double[][] points = new double[][] {      {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},      {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},      {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},      {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},      { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},      { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},      {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},      {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},      {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},      {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},      {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},      { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},      { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},      {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},      {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},      {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},      {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},      {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},      { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},      { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},      { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},      {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},      {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},      {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},      {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},      {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},      { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},      { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},      {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}    };    for (int i = 0; i < points.length; ++i) {      circle.addPoint(points[i][0], points[i][1]);    }    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(circle);    assertTrue(estimator.getCostEvaluations() < 15);    assertTrue(estimator.getJacobianEvaluations() < 10);    assertEquals( 0.030184491196225207, estimator.getRMS(circle), 1.0e-9);    assertEquals( 0.2922350065939634,   circle.getRadius(), 1.0e-9);    assertEquals(-0.15173845023862165,  circle.getX(),      1.0e-8);    assertEquals( 0.20750021499570379,  circle.getY(),      1.0e-8);  }  private static class LinearProblem implements EstimationProblem {    public LinearProblem(LinearMeasurement[] measurements) {      this.measurements = measurements;    }    public WeightedMeasurement[] getMeasurements() {      return measurements;    }    public EstimatedParameter[] getUnboundParameters() {      return getAllParameters();    }    public EstimatedParameter[] getAllParameters() {      IdentityHashMap map = new IdentityHashMap();      for (int i = 0; i < measurements.length; ++i) {        EstimatedParameter[] parameters = measurements[i].getParameters();        for (int j = 0; j < parameters.length; ++j) {          map.put(parameters[j], null);        }      }      Set set = map.keySet();      return (EstimatedParameter[]) set.toArray(new EstimatedParameter[set.size()]);    }      private LinearMeasurement[] measurements;  }  private static class LinearMeasurement extends WeightedMeasurement {    public LinearMeasurement(double[] factors, EstimatedParameter[] parameters,                             double setPoint) {      super(1.0, setPoint);      this.factors = factors;      this.parameters = parameters;    }    public double getTheoreticalValue() {      double v = 0;      for (int i = 0; i < factors.length; ++i) {        v += factors[i] * parameters[i].getEstimate();      }      return v;    }    public double getPartial(EstimatedParameter parameter) {      for (int i = 0; i < parameters.length; ++i) {        if (parameters[i] == parameter) {          return factors[i];        }      }      return 0;    }    public EstimatedParameter[] getParameters() {      return parameters;    }    private double[] factors;    private EstimatedParameter[] parameters;    private static final long serialVersionUID = -3922448707008868580L;  }  private static class Circle implements EstimationProblem {    public Circle(double cx, double cy) {      this.cx = new EstimatedParameter("cx", cx);      this.cy = new EstimatedParameter("cy", cy);      points  = new ArrayList();    }    public void addPoint(double px, double py) {      points.add(new PointModel(px, py));    }    public int getM() {      return points.size();    }    public WeightedMeasurement[] getMeasurements() {      return (WeightedMeasurement[]) points.toArray(new PointModel[points.size()]);    }    public EstimatedParameter[] getAllParameters() {      return new EstimatedParameter[] { cx, cy };    }    public EstimatedParameter[] getUnboundParameters() {      return new EstimatedParameter[] { cx, cy };    }    public double getPartialRadiusX() {      double dRdX = 0;      for (Iterator iterator = points.iterator(); iterator.hasNext();) {        dRdX += ((PointModel) iterator.next()).getPartialDiX();      }      return dRdX / points.size();    }    public double getPartialRadiusY() {      double dRdY = 0;      for (Iterator iterator = points.iterator(); iterator.hasNext();) {        dRdY += ((PointModel) iterator.next()).getPartialDiY();      }      return dRdY / points.size();    }   public double getRadius() {      double r = 0;      for (Iterator iterator = points.iterator(); iterator.hasNext();) {        r += ((PointModel) iterator.next()).getCenterDistance();      }      return r / points.size();    }    public double getX() {      return cx.getEstimate();    }    public double getY() {      return cy.getEstimate();    }    private class PointModel extends WeightedMeasurement {      public PointModel(double px, double py) {        super(1.0, 0.0);        this.px = px;        this.py = py;      }      public double getPartial(EstimatedParameter parameter) {        if (parameter == cx) {          return getPartialDiX() - getPartialRadiusX();        } else if (parameter == cy) {          return getPartialDiY() - getPartialRadiusY();        }        return 0;      }      public double getCenterDistance() {        double dx = px - cx.getEstimate();        double dy = py - cy.getEstimate();        return Math.sqrt(dx * dx + dy * dy);      }      public double getPartialDiX() {        return (cx.getEstimate() - px) / getCenterDistance();      }      public double getPartialDiY() {        return (cy.getEstimate() - py) / getCenterDistance();      }      public double getTheoreticalValue() {        return getCenterDistance() - getRadius();      }      private double px;      private double py;      private static final long serialVersionUID = 1L;    }    private EstimatedParameter cx;    private EstimatedParameter cy;    private ArrayList points;  }  public static Test suite() {    return new TestSuite(LevenbergMarquardtEstimatorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.estimation;import junit.framework.*;public class WeightedMeasurementTest  extends TestCase {  public WeightedMeasurementTest(String name) {    super(name);    p1 = null;    p2 = null;  }  public void testConstruction() {    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);    checkValue(m.getWeight(), 3.0);    checkValue(m.getMeasuredValue(), theoretical() + 0.1);  }  public void testIgnored() {    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);    assertTrue(!m.isIgnored());    m.setIgnored(true);    assertTrue(m.isIgnored());    m.setIgnored(false);    assertTrue(!m.isIgnored());  }  public void testTheory() {    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);    checkValue(m.getTheoreticalValue(), theoretical());    checkValue(m.getResidual(), 0.1);    double oldP1 = p1.getEstimate();    p1.setEstimate(oldP1 + m.getResidual() / m.getPartial(p1));    checkValue(m.getResidual(), 0.0);    p1.setEstimate(oldP1);    checkValue(m.getResidual(), 0.1);    double oldP2 = p2.getEstimate();    p2.setEstimate(oldP2 + m.getResidual() / m.getPartial(p2));    checkValue(m.getResidual(), 0.0);    p2.setEstimate(oldP2);    checkValue(m.getResidual(), 0.1);  }  public static Test suite() {    return new TestSuite(WeightedMeasurementTest.class);  }  public void setUp() {    p1 = new EstimatedParameter("p1", 1.0);    p2 = new EstimatedParameter("p2", 2.0);  }  public void tearDown() {    p1 = null;    p2 = null;  }  private void checkValue(double value, double expected) {   assertTrue(Math.abs(value - expected) < 1.0e-10);  }  private double theoretical() {   return 3 * p1.getEstimate() - p2.getEstimate();  }  private double partial(EstimatedParameter p) {    if (p == p1) {      return 3.0;    } else if (p == p2) {      return -1.0;    } else {      return 0.0;    }  }  private static class MyMeasurement    extends WeightedMeasurement {    public MyMeasurement(double weight, double measuredValue,                         WeightedMeasurementTest testInstance) {      super(weight, measuredValue);      this.testInstance = testInstance;    }    public double getTheoreticalValue() {      return testInstance.theoretical();    }    public double getPartial(EstimatedParameter p) {      return testInstance.partial(p);    }    private transient WeightedMeasurementTest testInstance;    private static final long serialVersionUID = -246712922500792332L;  }  private EstimatedParameter p1;  private EstimatedParameter p2;}
package org.spaceroots.mantissa.estimation;import java.util.Arrays;import junit.framework.*;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files.  * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */public class MinpackTest  extends TestCase {  public MinpackTest(String name) {    super(name);  }  public void testMinpackLinearFullRank()    throws EstimationException {    minpackTest(new LinearFullRankFunction(10, 5, 1.0,                                           5.0, 2.23606797749979), false);    minpackTest(new LinearFullRankFunction(50, 5, 1.0,                                           8.06225774829855, 6.70820393249937), false);  }  public void testMinpackLinearRank1()    throws EstimationException {    minpackTest(new LinearRank1Function(10, 5, 1.0,                                        291.521868819476, 1.4638501094228), false);    minpackTest(new LinearRank1Function(50, 5, 1.0,                                        3101.60039334535, 3.48263016573496), false);  }  public void testMinpackLinearRank1ZeroColsAndRows()    throws EstimationException {    minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false);    minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false);  }  public void testMinpackRosenbrok()    throws EstimationException {    minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },                                       Math.sqrt(24.2)), false);    minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 },                                       Math.sqrt(1795769.0)), false);    minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 },                                       11.0 * Math.sqrt(169000121.0)), false);  }  public void testMinpackHelicalValley()    throws EstimationException {    minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 },                                          50.0), false);    minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 },                                          102.95630140987), false);    minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0},                                          991.261822123701), false);  }      public void testMinpackPowellSingular()    throws EstimationException {    minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },                                           14.6628782986152), false);    minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 },                                           1270.9838708654), false);    minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 },                                           126887.903284750), false);  }      public void testMinpackFreudensteinRoth()    throws EstimationException {    minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },                                             20.0124960961895, 6.99887517584575,                                             new double[] {                                               11.4124844654993,                                               -0.896827913731509                                             }), false);    minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },                                             12432.833948863, 6.9988751744895,                                             new double[] {                                               11.4130046614746,                                               -0.896796038685958                                             }), false);    minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },                                             11426454.595762, 6.99887517242903,                                             new double[] {                                               11.4127817857886,                                               -0.89680510749204                                             }), false);  }      public void testMinpackBard()    throws EstimationException {    minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,                                 new double[] {                                   0.0824105765758334,                                   1.1330366534715,                                   2.34369463894115                                 }), false);    minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539,                                 new double[] {                                   0.840666673818329,                                   -158848033.259565,                                   -164378671.653535                                 }), false);    minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969,                                 new double[] {                                   0.840666673867645,                                   -158946167.205518,                                   -164464906.857771                                 }), false);  }      public void testMinpackKowalikOsborne()    throws EstimationException {    minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },                                           0.0728915102882945,                                           0.017535837721129,                                           new double[] {                                             0.192807810476249,                                             0.191262653354071,                                             0.123052801046931,                                             0.136053221150517                                           }), false);    minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 },                                           2.97937007555202,                                           0.032052192917937,                                           new double[] {                                             728675.473768287,                                             -14.0758803129393,                                             -32977797.7841797,                                             -20571594.1977912                                           }), false);    minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 },                                           29.9590617016037,                                           0.0175364017658228,                                           new double[] {                                             0.192948328597594,                                             0.188053165007911,                                             0.122430604321144,                                             0.134575665392506                                           }), true);  }      public void testMinpackMeyer()    throws EstimationException {    minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },                                  41153.4665543031, 9.37794514651874,                                  new double[] {                                    0.00560963647102661,                                    6181.34634628659,                                    345.223634624144                                  }), false);    minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 },                                  4168216.89130846, 792.917871779501,                                  new double[] {                                    1.42367074157994e-11,                                    33695.7133432541,                                    901.268527953801                                  }), true);  }      public void testMinpackWatson()    throws EstimationException {      minpackTest(new WatsonFunction(6, 0.0,                                   5.47722557505166, 0.0478295939097601,                                   new double[] {                                     -0.0157249615083782, 1.01243488232965,                                     -0.232991722387673,  1.26043101102818,                                     -1.51373031394421,   0.99299727291842                                   }), false);    minpackTest(new WatsonFunction(6, 10.0,                                   6433.12578950026, 0.0478295939096951,                                   new double[] {                                     -0.0157251901386677, 1.01243485860105,                                     -0.232991545843829,  1.26042932089163,                                     -1.51372776706575,   0.99299573426328                                   }), false);    minpackTest(new WatsonFunction(6, 100.0,                                   674256.040605213, 0.047829593911544,                                   new double[] {                                    -0.0157247019712586, 1.01243490925658,                                    -0.232991922761641,  1.26043292929555,                                    -1.51373320452707,   0.99299901922322                                   }), false);    minpackTest(new WatsonFunction(9, 0.0,                                   5.47722557505166, 0.00118311459212420,                                   new double[] {                                    -0.153070644166722e-4, 0.999789703934597,                                     0.0147639634910978,   0.146342330145992,                                     1.00082109454817,    -2.61773112070507,                                     4.10440313943354,    -3.14361226236241,                                     1.05262640378759                                   }), false);    minpackTest(new WatsonFunction(9, 10.0,                                   12088.127069307, 0.00118311459212513,                                   new double[] {                                   -0.153071334849279e-4, 0.999789703941234,                                    0.0147639629786217,   0.146342334818836,                                    1.00082107321386,    -2.61773107084722,                                    4.10440307655564,    -3.14361222178686,                                    1.05262639322589                                   }), false);    minpackTest(new WatsonFunction(9, 100.0,                                   1269109.29043834, 0.00118311459212384,                                   new double[] {                                    -0.153069523352176e-4, 0.999789703958371,                                     0.0147639625185392,   0.146342341096326,                                     1.00082104729164,    -2.61773101573645,                                     4.10440301427286,    -3.14361218602503,                                     1.05262638516774                                   }), false);    minpackTest(new WatsonFunction(12, 0.0,                                   5.47722557505166, 0.217310402535861e-4,                                   new double[] {                                    -0.660266001396382e-8, 1.00000164411833,                                    -0.000563932146980154, 0.347820540050756,                                    -0.156731500244233,    1.05281515825593,                                    -3.24727109519451,     7.2884347837505,                                   -10.271848098614,       9.07411353715783,                                    -4.54137541918194,     1.01201187975044                                   }), false);    minpackTest(new WatsonFunction(12, 10.0,                                   19220.7589790951, 0.217310402518509e-4,                                   new double[] {                                    -0.663710223017410e-8, 1.00000164411787,                                    -0.000563932208347327, 0.347820540486998,                                    -0.156731503955652,    1.05281517654573,                                    -3.2472711515214,      7.28843489430665,                                   -10.2718482369638,      9.07411364383733,                                    -4.54137546533666,     1.01201188830857                                   }), false);    minpackTest(new WatsonFunction(12, 100.0,                                   2018918.04462367, 0.217310402539845e-4,                                   new double[] {                                    -0.663806046485249e-8, 1.00000164411786,                                    -0.000563932210324959, 0.347820540503588,                                    -0.156731504091375,    1.05281517718031,                                    -3.24727115337025,     7.28843489775302,                                   -10.2718482410813,      9.07411364688464,                                    -4.54137546660822,     1.0120118885369                                   }), false);  }      public void testMinpackBox3Dimensional()  throws EstimationException {    minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },                                            32.1115837449572), false);  }      public void testMinpackJennrichSampson()    throws EstimationException {    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },                                            64.5856498144943, 11.1517793413499,                                            new double[] {                                             0.257819926636811, 0.257829976764542                                            }), false);  }  public void testMinpackBrownDennis()    throws EstimationException {    minpackTest(new BrownDennisFunction(20,                                        new double[] { 25.0, 5.0, -5.0, -1.0 },                                        2815.43839161816, 292.954288244866,                                        new double[] {                                         -11.59125141003, 13.2024883984741,                                         -0.403574643314272, 0.236736269844604                                        }), false);    minpackTest(new BrownDennisFunction(20,                                        new double[] { 250.0, 50.0, -50.0, -10.0 },                                        555073.354173069, 292.954270581415,                                        new double[] {                                         -11.5959274272203, 13.2041866926242,                                         -0.403417362841545, 0.236771143410386                                       }), false);    minpackTest(new BrownDennisFunction(20,                                        new double[] { 2500.0, 500.0, -500.0, -100.0 },                                        61211252.2338581, 292.954306151134,                                        new double[] {                                         -11.5902596937374, 13.2020628854665,                                         -0.403688070279258, 0.236665033746463                                        }), false);  }      public void testMinpackChebyquad()    throws EstimationException {    minpackTest(new ChebyquadFunction(1, 8, 1.0,                                      1.88623796907732, 1.88623796907732,                                      new double[] { 0.5 }), false);    minpackTest(new ChebyquadFunction(1, 8, 10.0,                                      5383344372.34005, 1.88424820499951,                                      new double[] { 0.9817314924684 }), false);    minpackTest(new ChebyquadFunction(1, 8, 100.0,                                      0.118088726698392e19, 1.88424820499347,                                      new double[] { 0.9817314852934 }), false);    minpackTest(new ChebyquadFunction(8, 8, 1.0,                                      0.196513862833975, 0.0593032355046727,                                      new double[] {                                        0.0431536648587336, 0.193091637843267,                                        0.266328593812698,  0.499999334628884,                                        0.500000665371116,  0.733671406187302,                                        0.806908362156733,  0.956846335141266                                      }), false);    minpackTest(new ChebyquadFunction(9, 9, 1.0,                                      0.16994993465202, 0.0,                                      new double[] {                                        0.0442053461357828, 0.199490672309881,                                        0.23561910847106,   0.416046907892598,                                        0.5,                0.583953092107402,                                        0.764380891528940,  0.800509327690119,                                        0.955794653864217                                      }), false);    minpackTest(new ChebyquadFunction(10, 10, 1.0,                                      0.183747831178711, 0.0806471004038253,                                      new double[] {                                        0.0596202671753563, 0.166708783805937,                                        0.239171018813509,  0.398885290346268,                                        0.398883667870681,  0.601116332129320,                                        0.60111470965373,   0.760828981186491,                                        0.833291216194063,  0.940379732824644                                      }), false);  }      public void testMinpackBrownAlmostLinear()    throws EstimationException {    minpackTest(new BrownAlmostLinearFunction(10, 0.5,                                              16.5302162063499, 0.0,                                              new double[] {                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 1.20569696650138                                              }), false);    minpackTest(new BrownAlmostLinearFunction(10, 5.0,                                              9765624.00089211, 0.0,                                              new double[] {                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 1.20569696650135                                              }), false);      minpackTest(new BrownAlmostLinearFunction(10, 50.0,                                              0.9765625e17, 0.0,                                              new double[] {                                                1.0, 1.0, 1.0, 1.0, 1.0,                                                1.0, 1.0, 1.0, 1.0, 1.0                                              }), false);    minpackTest(new BrownAlmostLinearFunction(30, 0.5,                                              83.476044467848, 0.0,                                              new double[] {                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 1.06737350671578                                              }), false);    minpackTest(new BrownAlmostLinearFunction(40, 0.5,                                              128.026364472323, 0.0,                                              new double[] {                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                0.999999999999121                                              }), false);    }      public void testMinpackOsborne1()    throws EstimationException {      minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },                                       0.937564021037838, 0.00739249260904843,                                       new double[] {                                         0.375410049244025, 1.93584654543108,                                        -1.46468676748716, 0.0128675339110439,                                         0.0221227011813076                                       }), false);    }      public void testMinpackOsborne2()    throws EstimationException {          minpackTest(new Osborne2Function(new double[] {                                       1.3, 0.65, 0.65, 0.7, 0.6,                                       3.0, 5.0, 7.0, 2.0, 4.5, 5.5                                     },                                     1.44686540984712, 0.20034404483314,                                     new double[] {                                       1.30997663810096,  0.43155248076,                                       0.633661261602859, 0.599428560991695,                                       0.754179768272449, 0.904300082378518,                                       1.36579949521007, 4.82373199748107,                                       2.39868475104871, 4.56887554791452,                                       5.67534206273052                                     }), false);  }  private void minpackTest(MinpackFunction function, boolean exceptionExpected) {    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.setMaxCostEval(100 * (function.getN() + 1));    estimator.setCostRelativeTolerance(Math.sqrt(2.22044604926e-16));    estimator.setParRelativeTolerance(Math.sqrt(2.22044604926e-16));    estimator.setOrthoTolerance(2.22044604926e-16);    assertTrue(function.checkTheoreticalStartCost(estimator.getRMS(function)));    try {      estimator.estimate(function);      assertFalse(exceptionExpected);    } catch (EstimationException lsse) {      assertTrue(exceptionExpected);    }    assertTrue(function.checkTheoreticalMinCost(estimator.getRMS(function)));    assertTrue(function.checkTheoreticalMinParams());  }  private static abstract class MinpackFunction implements EstimationProblem {     protected MinpackFunction(int m,                              double[] startParams,                              double   theoreticalStartCost,                              double   theoreticalMinCost,                              double[] theoreticalMinParams) {      this.m = m;      this.n = startParams.length;      parameters = new EstimatedParameter[n];      for (int i = 0; i < n; ++i) {        parameters[i] = new EstimatedParameter("p" + i, startParams[i]);      }      this.theoreticalStartCost = theoreticalStartCost;      this.theoreticalMinCost   = theoreticalMinCost;      this.theoreticalMinParams = theoreticalMinParams;      this.costAccuracy         = 1.0e-8;      this.paramsAccuracy       = 1.0e-5;    }    protected static double[] buildArray(int n, double x) {      double[] array = new double[n];      Arrays.fill(array, x);      return array;    }    protected void setCostAccuracy(double costAccuracy) {      this.costAccuracy = costAccuracy;    }    protected void setParamsAccuracy(double paramsAccuracy) {      this.paramsAccuracy = paramsAccuracy;    }    public int getN() {      return parameters.length;    }    public boolean checkTheoreticalStartCost(double rms) {      double threshold = costAccuracy * (1.0 + theoreticalStartCost);      return Math.abs(Math.sqrt(m) * rms - theoreticalStartCost) <= threshold;    }    public boolean checkTheoreticalMinCost(double rms) {      double threshold = costAccuracy * (1.0 + theoreticalMinCost);     return Math.abs(Math.sqrt(m) * rms - theoreticalMinCost) <= threshold;    }    public boolean checkTheoreticalMinParams() {      if (theoreticalMinParams != null) {        for (int i = 0; i < theoreticalMinParams.length; ++i) {          double mi = theoreticalMinParams[i];          double vi = parameters[i].getEstimate();          if (Math.abs(mi - vi) > (paramsAccuracy * (1.0 + Math.abs(mi)))) {            return false;          }        }      }      return true;    }     public WeightedMeasurement[] getMeasurements() {      WeightedMeasurement[] measurements = new WeightedMeasurement[m];      for (int i = 0; i < m; ++i) {        measurements[i] = new MinpackMeasurement(i);      }      return measurements;    }    public EstimatedParameter[] getUnboundParameters() {      return parameters;    }    public EstimatedParameter[] getAllParameters() {      return parameters;    }    protected abstract double[][] getJacobian();    protected abstract double[] getResiduals();    private class MinpackMeasurement extends WeightedMeasurement {      public MinpackMeasurement(int index) {        super(1.0, 0.0);        this.index = index;      }      public double getTheoreticalValue() {        // this is obviously NOT efficient as we recompute the whole vector        // each time we need only one element, but it is only for test        // purposes and is simpler to check.        // This implementation should NOT be taken as an example, it is ugly!        return getResiduals()[index];      }      public double getPartial(EstimatedParameter parameter) {        // this is obviously NOT efficient as we recompute the whole jacobian        // each time we need only one element, but it is only for test        // purposes and is simpler to check.        // This implementation should NOT be taken as an example, it is ugly!        for (int j = 0; j < n; ++j) {          if (parameter == parameters[j]) {            return getJacobian()[index][j];          }        }        return 0;      }      private int index;      private static final long serialVersionUID = 1L;    }    protected int                  n;    protected int                  m;    protected EstimatedParameter[] parameters;    protected double               theoreticalStartCost;    protected double               theoreticalMinCost;    protected double[]             theoreticalMinParams;    protected double               costAccuracy;    protected double               paramsAccuracy;  }  private static class LinearFullRankFunction extends MinpackFunction {    public LinearFullRankFunction(int m, int n, double x0,                                  double theoreticalStartCost,                                  double theoreticalMinCost) {      super(m, buildArray(n, x0), theoreticalStartCost,            theoreticalMinCost, buildArray(n, -1.0));    }    protected double[][] getJacobian() {      double t = 2.0 / m;      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = (i == j) ? (1 - t) : -t;        }      }      return jacobian;    }    protected double[] getResiduals() {      double sum = 0;      for (int i = 0; i < n; ++i) {        sum += parameters[i].getEstimate();      }      double t  = 1 + 2 * sum / m;      double[] f = new double[m];      for (int i = 0; i < n; ++i) {        f[i] = parameters[i].getEstimate() - t;      }      Arrays.fill(f, n, m, -t);      return f;    }  }  private static class LinearRank1Function extends MinpackFunction {    public LinearRank1Function(int m, int n, double x0,                                  double theoreticalStartCost,                                  double theoreticalMinCost) {      super(m, buildArray(n, x0), theoreticalStartCost, theoreticalMinCost, null);    }    protected double[][] getJacobian() {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = (i + 1) * (j + 1);        }      }      return jacobian;    }    protected double[] getResiduals() {      double[] f = new double[m];      double sum = 0;      for (int i = 0; i < n; ++i) {        sum += (i + 1) * parameters[i].getEstimate();      }      for (int i = 0; i < m; ++i) {        f[i] = (i + 1) * sum - 1;      }      return f;    }  }  private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction {    public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {      super(m, buildArray(n, x0),            Math.sqrt(m + (n+1)*(n-2)*(m-2)*(m-1) * ((n+1)*(n-2)*(2*m-3) - 12) / 24.0),            Math.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),            null);    }    protected double[][] getJacobian() {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        jacobian[i][0] = 0;        for (int j = 1; j < (n - 1); ++j) {          if (i == 0) {            jacobian[i][j] = 0;          } else if (i != (m - 1)) {            jacobian[i][j] = i * (j + 1);          } else {            jacobian[i][j] = 0;          }        }        jacobian[i][n - 1] = 0;      }      return jacobian;    }    protected double[] getResiduals() {      double[] f = new double[m];      double sum = 0;      for (int i = 1; i < (n - 1); ++i) {        sum += (i + 1) * parameters[i].getEstimate();      }      for (int i = 0; i < (m - 1); ++i) {        f[i] = i * sum - 1;      }      f[m - 1] = -1;      return f;    }  }  private static class RosenbrockFunction extends MinpackFunction {    public RosenbrockFunction(double[] startParams, double theoreticalStartCost) {      super(2, startParams, theoreticalStartCost, 0.0, buildArray(2, 1.0));    }    protected double[][] getJacobian() {      double x1 = parameters[0].getEstimate();      return new double[][] { { -20 * x1, 10 }, { -1, 0 } };    }    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      return new double[] { 10 * (x2 - x1 * x1), 1 - x1 };    }  }  private static class HelicalValleyFunction extends MinpackFunction {    public HelicalValleyFunction(double[] startParams,                                 double theoreticalStartCost) {      super(3, startParams, theoreticalStartCost, 0.0,            new double[] { 1.0, 0.0, 0.0 });    }    protected double[][] getJacobian() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double tmpSquare = x1 * x1 + x2 * x2;      double tmp1 = twoPi * tmpSquare;      double tmp2 = Math.sqrt(tmpSquare);      return new double[][] {        {  100 * x2 / tmp1, -100 * x1 / tmp1, 10 },        { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 },        { 0, 0, 1 }      };    }    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double tmp1;      if (x1 == 0) {        tmp1 = (x2 >= 0) ? 0.25 : -0.25;      } else {        tmp1 = Math.atan(x2 / x1) / twoPi;        if (x1 < 0) {          tmp1 += 0.5;        }      }      double tmp2 = Math.sqrt(x1 * x1 + x2 * x2);      return new double[] {        10.0 * (x3 - 10 * tmp1),        10.0 * (tmp2 - 1),        x3      };    }    private static final double twoPi = 2.0 * Math.PI;  }  private static class PowellSingularFunction extends MinpackFunction {    public PowellSingularFunction(double[] startParams,                                  double theoreticalStartCost) {      super(4, startParams, theoreticalStartCost, 0.0, buildArray(4, 0.0));    }    protected double[][] getJacobian() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double x4 = parameters[3].getEstimate();      return new double[][] {        { 1, 10, 0, 0 },        { 0, 0, sqrt5, -sqrt5 },        { 0, 2 * (x2 - 2 * x3), -4 * (x2 - 2 * x3), 0 },        { 2 * sqrt10 * (x1 - x4), 0, 0, -2 * sqrt10 * (x1 - x4) }      };    }    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double x4 = parameters[3].getEstimate();      return new double[] {        x1 + 10 * x2,        sqrt5 * (x3 - x4),        (x2 - 2 * x3) * (x2 - 2 * x3),        sqrt10 * (x1 - x4) * (x1 - x4)      };    }    private static final double sqrt5  = Math.sqrt( 5.0);    private static final double sqrt10 = Math.sqrt(10.0);  }  private static class FreudensteinRothFunction extends MinpackFunction {    public FreudensteinRothFunction(double[] startParams,                                    double theoreticalStartCost,                                    double theoreticalMinCost,                                    double[] theoreticalMinParams) {      super(2, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    protected double[][] getJacobian() {      double x2 = parameters[1].getEstimate();      return new double[][] {        { 1, x2 * (10 - 3 * x2) -  2 },        { 1, x2 * ( 2 + 3 * x2) - 14, }      };    }    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      return new double[] {       -13.0 + x1 + ((5.0 - x2) * x2 -  2.0) * x2,       -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2      };    }  }  private static class BardFunction extends MinpackFunction {    public BardFunction(double x0,                        double theoreticalStartCost,                        double theoreticalMinCost,                        double[] theoreticalMinParams) {      super(15, buildArray(3, x0), theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    protected double[][] getJacobian() {      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp1 = i  + 1;        double tmp2 = 15 - i;        double tmp3 = (i <= 7) ? tmp1 : tmp2;        double tmp4 = x2 * tmp2 + x3 * tmp3;        tmp4 *= tmp4;        jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 };      }      return jacobian;    }    protected double[] getResiduals() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double tmp1 = i + 1;        double tmp2 = 15 - i;        double tmp3 = (i <= 7) ? tmp1 : tmp2;        f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3));      }      return f;    }    private static final double[] y = {      0.14, 0.18, 0.22, 0.25, 0.29,      0.32, 0.35, 0.39, 0.37, 0.58,      0.73, 0.96, 1.34, 2.10, 4.39    };  }  private static class KowalikOsborneFunction extends MinpackFunction {    public KowalikOsborneFunction(double[] startParams,                                  double theoreticalStartCost,                                  double theoreticalMinCost,                                  double[] theoreticalMinParams) {      super(11, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);      if (theoreticalStartCost > 20.0) {        setCostAccuracy(2.0e-4);        setParamsAccuracy(5.0e-3);      }    }    protected double[][] getJacobian() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double   x4 = parameters[3].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp = v[i] * (v[i] + x3) + x4;        double j1  = -v[i] * (v[i] + x2) / tmp;        double j2  = -v[i] * x1 / tmp;        double j3  = j1 * j2;        double j4  = j3 / v[i];        jacobian[i] = new double[] { j1, j2, j3, j4 };      }      return jacobian;    }    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double x4 = parameters[3].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4);      }      return f;    }    private static final double[] v = {      4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625    };    private static final double[] y = {      0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627,      0.0456, 0.0342, 0.0323, 0.0235, 0.0246    };  }  private static class MeyerFunction extends MinpackFunction {    public MeyerFunction(double[] startParams,                         double theoreticalStartCost,                         double theoreticalMinCost,                         double[] theoreticalMinParams) {      super(16, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);      if (theoreticalStartCost > 1.0e6) {        setCostAccuracy(7.0e-3);        setParamsAccuracy(2.0e-2);      }    }    protected double[][] getJacobian() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = 5.0 * (i + 1) + 45.0 + x3;        double tmp1 = x2 / temp;        double tmp2 = Math.exp(tmp1);        double tmp3 = x1 * tmp2 / temp;        jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 };      }      return jacobian;    }    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        f[i] = x1 * Math.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];      }     return f;    }    private static final double[] y = {      34780.0, 28610.0, 23650.0, 19630.0,      16370.0, 13720.0, 11540.0,  9744.0,       8261.0,  7030.0,  6005.0,  5147.0,       4427.0,  3820.0,  3307.0,  2872.0                      };  }  private static class WatsonFunction extends MinpackFunction {    public WatsonFunction(int n, double x0,                          double theoreticalStartCost,                          double theoreticalMinCost,                          double[] theoreticalMinParams) {      super(31, buildArray(n, x0), theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    protected double[][] getJacobian() {      double[][] jacobian = new double[m][];      for (int i = 0; i < (m - 2); ++i) {        double div = (i + 1) / 29.0;        double s2  = 0.0;        double dx  = 1.0;        for (int j = 0; j < n; ++j) {          s2 += dx * parameters[j].getEstimate();          dx *= div;        }        double temp= 2 * div * s2;        dx = 1.0 / div;        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = dx * (j - temp);          dx *= div;        }      }      jacobian[m - 2]    = new double[n];      jacobian[m - 2][0] = 1;      jacobian[m - 1]   = new double[n];      jacobian[m - 1][0]= -2 * parameters[0].getEstimate();      jacobian[m - 1][1]= 1;      return jacobian;    }    protected double[] getResiduals() {     double[] f = new double[m];     for (int i = 0; i < (m - 2); ++i) {       double div = (i + 1) / 29.0;       double s1 = 0;       double dx = 1;       for (int j = 1; j < n; ++j) {         s1 += j * dx * parameters[j].getEstimate();         dx *= div;       }       double s2 =0;       dx =1;       for (int j = 0; j < n; ++j) {         s2 += dx * parameters[j].getEstimate();         dx *= div;       }       f[i] = s1 - s2 * s2 - 1;     }     double x1 = parameters[0].getEstimate();     double x2 = parameters[1].getEstimate();     f[m - 2] = x1;     f[m - 1] = x2 - x1 * x1 - 1;     return f;    }  }  private static class Box3DimensionalFunction extends MinpackFunction {    public Box3DimensionalFunction(int m, double[] startParams,                                   double theoreticalStartCost) {      super(m, startParams, theoreticalStartCost,            0.0, new double[] { 1.0, 10.0, 1.0 });   }    protected double[][] getJacobian() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp = (i + 1) / 10.0;        jacobian[i] = new double[] {          -tmp * Math.exp(-tmp * x1),           tmp * Math.exp(-tmp * x2),          Math.exp(-i - 1) - Math.exp(-tmp)        };      }      return jacobian;    }    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double tmp = (i + 1) / 10.0;        f[i] = Math.exp(-tmp * x1) - Math.exp(-tmp * x2)             + (Math.exp(-i - 1) - Math.exp(-tmp)) * x3;      }      return f;    }  }  private static class JennrichSampsonFunction extends MinpackFunction {    public JennrichSampsonFunction(int m, double[] startParams,                                   double theoreticalStartCost,                                   double theoreticalMinCost,                                   double[] theoreticalMinParams) {      super(m, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    protected double[][] getJacobian() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double t = i + 1;        jacobian[i] = new double[] { -t * Math.exp(t * x1), -t * Math.exp(t * x2) };      }      return jacobian;    }    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = i + 1;        f[i] = 2 + 2 * temp - Math.exp(temp * x1) - Math.exp(temp * x2);      }      return f;    }  }  private static class BrownDennisFunction extends MinpackFunction {    public BrownDennisFunction(int m, double[] startParams,                               double theoreticalStartCost,                               double theoreticalMinCost,                               double[] theoreticalMinParams) {      super(m, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    protected double[][] getJacobian() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double   x4 = parameters[3].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = (i + 1) / 5.0;        double ti   = Math.sin(temp);        double tmp1 = x1 + temp * x2 - Math.exp(temp);        double tmp2 = x3 + ti   * x4 - Math.cos(temp);        jacobian[i] = new double[] {          2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2        };      }      return jacobian;    }    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double x4 = parameters[3].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = (i + 1) / 5.0;        double tmp1 = x1 + temp * x2 - Math.exp(temp);        double tmp2 = x3 + Math.sin(temp) * x4 - Math.cos(temp);        f[i] = tmp1 * tmp1 + tmp2 * tmp2;      }      return f;    }  }  private static class ChebyquadFunction extends MinpackFunction {    private static double[] buildChebyquadArray(int n, double factor) {      double[] array = new double[n];      double inv = factor / (n + 1);      for (int i = 0; i < n; ++i) {        array[i] = (i + 1) * inv;      }      return array;    }    public ChebyquadFunction(int n, int m, double factor,                             double theoreticalStartCost,                             double theoreticalMinCost,                             double[] theoreticalMinParams) {      super(m, buildChebyquadArray(n, factor), theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    protected double[][] getJacobian() {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];      }      double dx = 1.0 / n;      for (int j = 0; j < n; ++j) {        double tmp1 = 1;        double tmp2 = 2 * parameters[j].getEstimate() - 1;        double temp = 2 * tmp2;        double tmp3 = 0;        double tmp4 = 2;        for (int i = 0; i < m; ++i) {          jacobian[i][j] = dx * tmp4;          double ti = 4 * tmp2 + temp * tmp4 - tmp3;          tmp3 = tmp4;          tmp4 = ti;          ti   = temp * tmp2 - tmp1;          tmp1 = tmp2;          tmp2 = ti;        }      }      return jacobian;    }    protected double[] getResiduals() {      double[] f = new double[m];      for (int j = 0; j < n; ++j) {        double tmp1 = 1;        double tmp2 = 2 * parameters[j].getEstimate() - 1;        double temp = 2 * tmp2;        for (int i = 0; i < m; ++i) {          f[i] += tmp2;          double ti = temp * tmp2 - tmp1;          tmp1 = tmp2;          tmp2 = ti;        }      }      double dx = 1.0 / n;      boolean iev = false;      for (int i = 0; i < m; ++i) {        f[i] *= dx;        if (iev) {          f[i] += 1.0 / (i * (i + 2));        }        iev = ! iev;      }      return f;    }  }  private static class BrownAlmostLinearFunction extends MinpackFunction {    public BrownAlmostLinearFunction(int m, double factor,                                     double theoreticalStartCost,                                     double theoreticalMinCost,                                     double[] theoreticalMinParams) {      super(m, buildArray(m, factor), theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    protected double[][] getJacobian() {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];      }      double prod = 1;      for (int j = 0; j < n; ++j) {        prod *= parameters[j].getEstimate();        for (int i = 0; i < n; ++i) {          jacobian[i][j] = 1;        }        jacobian[j][j] = 2;      }      for (int j = 0; j < n; ++j) {        EstimatedParameter vj = parameters[j];        double temp = vj.getEstimate();        if (temp == 0) {          temp = 1;          prod = 1;          for (int k = 0; k < n; ++k) {            if (k != j) {              prod *= parameters[k].getEstimate();            }          }        }        jacobian[n - 1][j] = prod / temp;      }      return jacobian;    }    protected double[] getResiduals() {      double[] f = new double[m];      double sum  = -(n + 1);      double prod = 1;      for (int j = 0; j < n; ++j) {        sum  += parameters[j].getEstimate();        prod *= parameters[j].getEstimate();      }      for (int i = 0; i < n; ++i) {        f[i] = parameters[i].getEstimate() + sum;      }      f[n - 1] = prod - 1;      return f;    }  }  private static class Osborne1Function extends MinpackFunction {    public Osborne1Function(double[] startParams,                            double theoreticalStartCost,                            double theoreticalMinCost,                            double[] theoreticalMinParams) {      super(33, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    protected double[][] getJacobian() {      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double   x4 = parameters[3].getEstimate();      double   x5 = parameters[4].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = 10.0 * i;        double tmp1 = Math.exp(-temp * x4);        double tmp2 = Math.exp(-temp * x5);        jacobian[i] = new double[] {          -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2        };      }      return jacobian;    }    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double x4 = parameters[3].getEstimate();      double x5 = parameters[4].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = 10.0 * i;        double tmp1 = Math.exp(-temp * x4);        double tmp2 = Math.exp(-temp * x5);        f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2);      }      return f;    }    private static final double[] y = {      0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751,      0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490,      0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406    };  }  private static class Osborne2Function extends MinpackFunction {    public Osborne2Function(double[] startParams,                            double theoreticalStartCost,                            double theoreticalMinCost,                            double[] theoreticalMinParams) {      super(65, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    protected double[][] getJacobian() {      double   x01 = parameters[0].getEstimate();      double   x02 = parameters[1].getEstimate();      double   x03 = parameters[2].getEstimate();      double   x04 = parameters[3].getEstimate();      double   x05 = parameters[4].getEstimate();      double   x06 = parameters[5].getEstimate();      double   x07 = parameters[6].getEstimate();      double   x08 = parameters[7].getEstimate();      double   x09 = parameters[8].getEstimate();      double   x10 = parameters[9].getEstimate();      double   x11 = parameters[10].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = i / 10.0;        double tmp1 = Math.exp(-x05 * temp);        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));        jacobian[i] = new double[] {          -tmp1,          -tmp2,          -tmp3,          -tmp4,          temp * x01 * tmp1,          x02 * (temp - x09) * (temp - x09) * tmp2,          x03 * (temp - x10) * (temp - x10) * tmp3,          x04 * (temp - x11) * (temp - x11) * tmp4,          -2 * x02 * x06 * (temp - x09) * tmp2,          -2 * x03 * x07 * (temp - x10) * tmp3,          -2 * x04 * x08 * (temp - x11) * tmp4        };      }      return jacobian;    }    protected double[] getResiduals() {      double x01 = parameters[0].getEstimate();      double x02 = parameters[1].getEstimate();      double x03 = parameters[2].getEstimate();      double x04 = parameters[3].getEstimate();      double x05 = parameters[4].getEstimate();      double x06 = parameters[5].getEstimate();      double x07 = parameters[6].getEstimate();      double x08 = parameters[7].getEstimate();      double x09 = parameters[8].getEstimate();      double x10 = parameters[9].getEstimate();      double x11 = parameters[10].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = i / 10.0;        double tmp1 = Math.exp(-x05 * temp);        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));        f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4);      }      return f;    }    private static final double[] y = {      1.366, 1.191, 1.112, 1.013, 0.991,      0.885, 0.831, 0.847, 0.786, 0.725,      0.746, 0.679, 0.608, 0.655, 0.616,      0.606, 0.602, 0.626, 0.651, 0.724,      0.649, 0.649, 0.694, 0.644, 0.624,      0.661, 0.612, 0.558, 0.533, 0.495,      0.500, 0.423, 0.395, 0.375, 0.372,      0.391, 0.396, 0.405, 0.428, 0.429,      0.523, 0.562, 0.607, 0.653, 0.672,      0.708, 0.633, 0.668, 0.645, 0.632,      0.591, 0.559, 0.597, 0.625, 0.739,      0.710, 0.729, 0.720, 0.636, 0.581,      0.428, 0.292, 0.162, 0.098, 0.054    };  }  public static Test suite() {    return new TestSuite(MinpackTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.functions.vectorial;import org.spaceroots.mantissa.functions.FunctionException;import org.spaceroots.mantissa.functions.ExhaustedSampleException;import junit.framework.*;public class BasicSampledFunctionIteratorTest  extends TestCase {  public BasicSampledFunctionIteratorTest(String name) {    super(name);  }  public void testIteration()    throws ExhaustedSampleException, FunctionException {    BasicSampledFunctionIterator iter =      new BasicSampledFunctionIterator(new Function(0.0, 0.1, 10));    for (int i = 0; i < 10; ++i) {      assertTrue(iter.hasNext());      VectorialValuedPair pair = iter.nextSamplePoint();      assertTrue(Math.abs(pair.x    - 0.1 * i) < 1.0e-10);      assertTrue(Math.abs(pair.y[0] + 0.1 * i) < 1.0e-10);      assertTrue(Math.abs(pair.y[1] + 0.2 * i) < 1.0e-10);    }  }  public void testExhausted()    throws ExhaustedSampleException, FunctionException {    BasicSampledFunctionIterator iter =      new BasicSampledFunctionIterator(new Function(0.0, 0.1, 10));    for (int i = 0; i < 10; ++i) {      assertTrue(iter.hasNext());      iter.nextSamplePoint();    }    assertTrue(! iter.hasNext());    boolean exceptionOccurred = false;    try {      iter.nextSamplePoint();    } catch(ExhaustedSampleException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);  }  public void testUnderlyingException()    throws ExhaustedSampleException, FunctionException {    BasicSampledFunctionIterator iter =      new BasicSampledFunctionIterator(new ExceptionGeneratingFunction());    boolean exceptionOccurred = false;    try {      iter.nextSamplePoint();    } catch(FunctionException e) {      exceptionOccurred = true;    }    assertTrue(! exceptionOccurred);    exceptionOccurred = false;    try {      iter.nextSamplePoint();    } catch(FunctionException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);  }  public static Test suite() {    return new TestSuite(BasicSampledFunctionIteratorTest.class);  }  private static class Function    implements SampledFunction {    private static final long serialVersionUID = -6049535144225908344L;    private double   begin;    private double   step;    private int      n;    private double[] values;    public Function(double begin, double step, int n) {      this.begin  = begin;      this.step   = step;      this.n      = n;      values      = new double[2];    }    public int size() {      return n;    }    public int getDimension() {      return 2;    }    public VectorialValuedPair samplePointAt(int i)      throws FunctionException {      if (i < 0 || i >= n) {        throw new FunctionException("outside of range");      }      double x = begin + i * step;      values[0] = -x;      values[1] = 2.0 * values[0];      return new VectorialValuedPair(x, values);    }  }  private static class ExceptionGeneratingFunction    implements SampledFunction {    private static final long serialVersionUID = 3750401068561053681L;    private boolean fireException = false;    public int size() {      return 2;    }    public int getDimension() {      return 2;    }    public VectorialValuedPair samplePointAt(int i)      throws FunctionException {      if (fireException) {        throw new FunctionException("boom");      }      fireException = true;      return new VectorialValuedPair(0.0, new double[] { 0, 1 });    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.functions.vectorial;import junit.framework.*;public class VectorialValuedPairTest  extends TestCase {  public VectorialValuedPairTest(String name) {    super(name);  }  public void testConstructor() {    double[] tab = new double[2];    tab[0] = -8.4;    tab[1] = -3.2;    VectorialValuedPair pair = new VectorialValuedPair(1.2, tab);    assertTrue(Math.abs(pair.x    - 1.2) < 1.0e-10);    assertTrue(Math.abs(pair.y[0] + 8.4) < 1.0e-10);    assertTrue(Math.abs(pair.y[1] + 3.2) < 1.0e-10);  }  public void testCopyConstructor() {    double[] tab = new double[2];    tab[0] = -8.4;    tab[1] = -3.2;    VectorialValuedPair pair1 = new VectorialValuedPair(1.2, tab);    VectorialValuedPair pair2 = new VectorialValuedPair(pair1.x,                                                        pair1.y);    assertTrue(Math.abs(pair2.x    - pair1.x)    < 1.0e-10);    assertTrue(Math.abs(pair2.y[0] - pair1.y[0]) < 1.0e-10);    assertTrue(Math.abs(pair2.y[1] - pair1.y[1]) < 1.0e-10);    assertTrue(Math.abs(pair2.x    - 1.2)        < 1.0e-10);    assertTrue(Math.abs(pair2.y[0] + 8.4)        < 1.0e-10);    assertTrue(Math.abs(pair2.y[1] + 3.2)        < 1.0e-10);  }  public static Test suite() {    return new TestSuite(VectorialValuedPairTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.functions.vectorial;import org.spaceroots.mantissa.functions.FunctionException;import junit.framework.*;public class ComputableFunctionSamplerTest  extends TestCase {  public ComputableFunctionSamplerTest(String name) {    super(name);  }  public void testBeginStepNumber()    throws FunctionException {    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0), 0.0, 0.099, 11);    assertTrue(sampler.size() == 11);    assertTrue(sampler.getDimension() == 2);    assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).x     - 0.495) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).y[0]  + 0.495) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).y[1]  + 0.990) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).x    - 0.990) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).y[0] + 0.990) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).y[1] + 1.980) < 1.0e-10);  }  public void testRangeNumber()    throws FunctionException {    double[] range = new double[2];    range[0] = 0.0;    range[1] = 1.0;    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function (0.0, 1.0), range, 11);    assertTrue(sampler.size() == 11);    assertTrue(sampler.getDimension() == 2);    assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).x     - 0.5) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).y[0]  + 0.5) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).y[1]  + 1.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).x    - 1.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).y[0] + 1.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).y[1] + 2.0) < 1.0e-10);  }  public void testRangeStepNoAdjust()    throws FunctionException {    double[] range = new double[2];    range[0] = 0.0;    range[1] = 1.0;    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0),                                     range, 0.083, false);    assertTrue(sampler.size() == 12);    assertTrue(sampler.getDimension() == 2);    assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).x     - 0.415) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).y[0]  + 0.415) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).y[1]  + 0.830) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(11).x    - 0.913) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(11).y[0] + 0.913) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(11).y[1] + 1.826) < 1.0e-10);  }  public void testRangeStepAdjust()    throws FunctionException {    double[] range = new double[2];    range[0] = 0.0;    range[1] = 1.0;    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0),                                    range, 0.083, true);    assertTrue(sampler.size() == 13);    assertTrue(sampler.getDimension() == 2);    assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(6).x     - 0.5) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(6).y[0]  + 0.5) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(6).y[1]  + 1.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(12).x    - 1.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(12).y[0] + 1.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(12).y[1] + 2.0) < 1.0e-10);  }  public void testOutOfRange()    throws FunctionException {    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0), 0.0, 1.0, 10);    boolean exceptionOccurred = false;    try {      sampler.samplePointAt(-1);    } catch(ArrayIndexOutOfBoundsException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);    exceptionOccurred = false;    try {      sampler.samplePointAt(10);    } catch(ArrayIndexOutOfBoundsException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);  }  public void testUnderlyingException() {    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new ExceptionGeneratingFunction(),                                    0.0, 0.1, 11);    boolean exceptionOccurred = false;    try {      sampler.samplePointAt(2);    } catch(FunctionException e) {      exceptionOccurred = true;    }    assertTrue(! exceptionOccurred);    exceptionOccurred = false;    try {      sampler.samplePointAt(8);    } catch(FunctionException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);  }  public static Test suite() {    return new TestSuite(ComputableFunctionSamplerTest.class);  }  private static class Function    implements ComputableFunction {    private double   min;    private double   max;    private double[] values;    public int getDimension() {      return 2;    }    public Function(double min, double max) {      this.min = min;      this.max = max;      values   = new double[2];    }    public double[] valueAt(double x)      throws FunctionException {      if (x < min || x > max) {        throw new FunctionException("outside of range");      }      values[0] = -x;      values[1] = -2.0 * x;      return values;    }    private static final long serialVersionUID = -1859103913610458563L;  }  private static class ExceptionGeneratingFunction    implements ComputableFunction {    public int getDimension() {      return 2;    }    public double[] valueAt(double x)      throws FunctionException {      if (x < 0.5) {        double[] res = new double[2];        res[0] = -x;        res[1] = -2.0 * x;        return res;      }      throw new FunctionException("upper half range exception");     }    private static final long serialVersionUID = 2849780376767626912L;  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.functions.scalar;import org.spaceroots.mantissa.functions.FunctionException;import org.spaceroots.mantissa.functions.ExhaustedSampleException;import junit.framework.*;public class BasicSampledFunctionIteratorTest  extends TestCase {  public BasicSampledFunctionIteratorTest(String name) {    super(name);  }  public void testIteration()    throws ExhaustedSampleException, FunctionException {    BasicSampledFunctionIterator iter =      new BasicSampledFunctionIterator(new Function(0.0, 0.1, 10));    for (int i = 0; i < 10; ++i) {      assertTrue(iter.hasNext());      ScalarValuedPair pair = iter.nextSamplePoint();      assertTrue(Math.abs(pair.getX() - 0.1 * i) < 1.0e-10);      assertTrue(Math.abs(pair.getY() + 0.1 * i) < 1.0e-10);    }  }  public void testExhausted()    throws ExhaustedSampleException, FunctionException {    BasicSampledFunctionIterator iter =      new BasicSampledFunctionIterator(new Function(0.0, 0.1, 10));    for (int i = 0; i < 10; ++i) {      assertTrue(iter.hasNext());      iter.nextSamplePoint();    }    assertTrue(! iter.hasNext());    boolean exceptionOccurred = false;    try {      iter.nextSamplePoint();    } catch(ExhaustedSampleException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);  }  public void testUnderlyingException()    throws ExhaustedSampleException, FunctionException {    BasicSampledFunctionIterator iter =      new BasicSampledFunctionIterator(new ExceptionGeneratingFunction());    boolean exceptionOccurred = false;    try {      iter.nextSamplePoint();    } catch(FunctionException e) {      exceptionOccurred = true;    }    assertTrue(! exceptionOccurred);    exceptionOccurred = false;    try {      iter.nextSamplePoint();    } catch (FunctionException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);  }  public static Test suite() {    return new TestSuite(BasicSampledFunctionIteratorTest.class);  }  private static class Function    implements SampledFunction {    private static final long serialVersionUID = -5071329620086891960L;    private double begin;    private double step;    private int    n;    public Function(double begin, double step, int n) {      this.begin = begin;      this.step  = step;      this.n     = n;    }    public int size() {      return n;    }    public ScalarValuedPair samplePointAt(int i)      throws FunctionException {      if (i < 0 || i >= n) {        throw new FunctionException("outside of range");      }      double x = begin + i * step;      return new ScalarValuedPair(x, -x);    }  }  private static class ExceptionGeneratingFunction    implements SampledFunction {    private static final long serialVersionUID = 1417147976215668305L;    private boolean fireException = false;    public int size() {      return 2;    }    public ScalarValuedPair samplePointAt(int i)      throws FunctionException {      if (fireException) {        throw new FunctionException("boom");      }      fireException = true;      return new ScalarValuedPair(0.0, 0.0);    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.functions.scalar;import junit.framework.*;public class ScalarValuedPairTest  extends TestCase {  public ScalarValuedPairTest(String name) {    super(name);  }  public void testConstructor() {    ScalarValuedPair pair = new ScalarValuedPair(1.2, -8.4);    assertTrue(Math.abs(pair.getX() - 1.2) < 1.0e-10);    assertTrue(Math.abs(pair.getY() + 8.4) < 1.0e-10);  }  public void testCopyConstructor() {    ScalarValuedPair pair1 = new ScalarValuedPair(1.2, -8.4);    ScalarValuedPair pair2 = new ScalarValuedPair(pair1);    assertTrue(Math.abs(pair2.getX() - pair1.getX()) < 1.0e-10);    assertTrue(Math.abs(pair2.getY() - pair1.getY()) < 1.0e-10);    assertTrue(Math.abs(pair2.getX() - 1.2) < 1.0e-10);    assertTrue(Math.abs(pair2.getY() + 8.4) < 1.0e-10);  }  public static Test suite() {    return new TestSuite(ScalarValuedPairTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.functions.scalar;import org.spaceroots.mantissa.functions.FunctionException;import junit.framework.*;public class ComputableFunctionSamplerTest  extends TestCase {  public ComputableFunctionSamplerTest(String name) {    super(name);  }  public void testBeginStepNumber()    throws FunctionException {    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0),                                    0.0, 0.099, 11);    assertTrue(sampler.size() == 11);    assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).getX()  - 0.495) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).getY()  + 0.495) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).getX() - 0.990) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).getY() + 0.990) < 1.0e-10);  }  public void testRangeNumber()    throws FunctionException {    double[] range = new double[2];    range[0] = 0.0;    range[1] = 1.0;    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0), range, 11);    assertTrue(sampler.size() == 11);    assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).getX()  - 0.5) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).getY()  + 0.5) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).getX() - 1.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).getY() + 1.0) < 1.0e-10);  }  public void testRangeStepNoAdjust()    throws FunctionException {    double[] range = new double[2];    range[0] = 0.0;    range[1] = 1.0;    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0),                                    range, 0.083, false);    assertTrue(sampler.size() == 12);    assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).getX()  - 0.415) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).getY()  + 0.415) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(11).getX() - 0.913) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(11).getY() + 0.913) < 1.0e-10);  }  public void testRangeStepAdjust()    throws FunctionException {    double[] range = new double[2];    range[0] = 0.0;    range[1] = 1.0;    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0),                                    range, 0.083, true);    assertTrue(sampler.size() == 13);    assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(6).getX()  - 0.5) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(6).getY()  + 0.5) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(12).getX() - 1.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(12).getY() + 1.0) < 1.0e-10);  }  public void testOutOfRange()    throws FunctionException {    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0), 0.0, 1.0, 10);    boolean exceptionOccurred = false;    try {      sampler.samplePointAt(-1);    } catch(ArrayIndexOutOfBoundsException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);    exceptionOccurred = false;    try {      sampler.samplePointAt(10);    } catch(ArrayIndexOutOfBoundsException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);  }  public void testUnderlyingException() {    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new ExceptionGeneratingFunction(),                                    0.0, 0.1, 11);    boolean exceptionOccurred = false;    try {      sampler.samplePointAt(2);    } catch(FunctionException e) {      exceptionOccurred = true;    }    assertTrue(! exceptionOccurred);    exceptionOccurred = false;    try {      sampler.samplePointAt(8);    } catch(FunctionException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);  }  public static Test suite() {    return new TestSuite(ComputableFunctionSamplerTest.class);  }  private static class Function    implements ComputableFunction {    private static final long serialVersionUID = -7173012970400285826L;    private double min;    private double max;    public Function(double min, double max) {      this.min = min;      this.max = max;    }    public double valueAt(double x)      throws FunctionException {      if (x < min || x > max) {        throw new FunctionException("outside of range");      }      return -x;    }  }  private static class ExceptionGeneratingFunction  implements ComputableFunction {    private static final long serialVersionUID = 7853080602731012102L;    public double valueAt(double x)      throws FunctionException {      if (x < 0.5) {        return -x;      }      throw new FunctionException("upper half range exception");    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.utilities;import junit.framework.*;public class ArrayMapperTest  extends TestCase {  public ArrayMapperTest(String name) {    super(name);    mapper = null;    b1 = null;    b2 = null;    b3 = null;  }  public void testDimensionCheck() {    int size = b1.getStateDimension();    size += b2.getStateDimension();    size += b3.getStateDimension();    assertTrue(mapper.getDataArray().length == size);  }  public void testUpdateObjects() {    double[] data = new double [7];    for (int i = 0; i < 7; ++i) {      data [i] = i * 0.1;    }    mapper.updateObjects(data);    assertTrue(Math.abs(b1.getElement(0) - 0.0) < 1.0e-10);    assertTrue(Math.abs(b2.getElement(0) - 0.4) < 1.0e-10);    assertTrue(Math.abs(b2.getElement(1) - 0.3) < 1.0e-10);    assertTrue(Math.abs(b2.getElement(2) - 0.2) < 1.0e-10);    assertTrue(Math.abs(b2.getElement(3) - 0.1) < 1.0e-10);    assertTrue(Math.abs(b3.getElement(0) - 0.6) < 1.0e-10);    assertTrue(Math.abs(b3.getElement(1) - 0.5) < 1.0e-10);  }    public void testUpdateArray() {    b1.setElement(0,  0.0);    b2.setElement(0, 40.0);    b2.setElement(1, 30.0);    b2.setElement(2, 20.0);    b2.setElement(3, 10.0);    b3.setElement(0, 60.0);    b3.setElement(1, 50.0);    mapper.updateArray();    double[] data = mapper.getDataArray();    for (int i = 0; i < 7; ++i) {      assertTrue(Math.abs(data [i] - i * 10.0) < 1.0e-10);    }  }    public void setUp() {    b1 = new DomainObject(1);    b2 = new DomainObject(4);    b3 = new DomainObject(2);    mapper = new ArrayMapper();    mapper.manageMappable(b1);    mapper.manageMappable(b2);    mapper.manageMappable(b3);  }  public void tearOff() {    b1 = null;    b2 = null;    b3 = null;    mapper = null;  }  public static Test suite() {    return new TestSuite(ArrayMapperTest.class);  }  private static class DomainObject implements ArraySliceMappable {    private double[] data;    public DomainObject(int size) {      data = new double [size];    }    public int getStateDimension() {      return data.length;    }    public void mapStateFromArray(int start, double[] array) {      for (int i = 0; i < data.length; ++i) {        data [data.length - 1 - i] = array [start + i];      }    }        public void mapStateToArray(int start, double[] array) {      for (int i = 0; i < data.length; ++i) {        array [start + i] = data [data.length - 1 - i];      }    }    public double getElement(int i) {      return data [i];    }    public void setElement(int i, double value) {      data [i] = value;    }  }  private DomainObject b1;  private DomainObject b2;  private DomainObject b3;  private ArrayMapper mapper;}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.utilities;import java.util.Iterator;import junit.framework.*;public class IntervalsListTest  extends TestCase {  public IntervalsListTest(String name) {    super(name);  }  public void testAddBetween() {    IntervalsList il =      new IntervalsList (new Interval(10, 20), new Interval(50, 60));    il.addToSelf(new Interval(30, 40));    checkEquals(new Interval[] {                  new Interval(10, 20),                  new Interval(30, 40),                  new Interval(50, 60)                }, il);  }  public void testAddReducingLastHole() {    IntervalsList il =      new IntervalsList (new Interval(10, 20), new Interval(50, 60));    il.addToSelf(new Interval(30, 55));    checkEquals(new Interval[] {                  new Interval(10, 20),                  new Interval(30, 60)                }, il);  }  public void test1() {    IntervalsList list1 = new IntervalsList(-2.0, -1.0);    IntervalsList list2 = new IntervalsList(new Interval(-0.9, -0.8));    check(list1, list2, 2.5,          true, false, 1, true, false, 1, false,          new Interval[] { new Interval(-2.0, -1.0),                           new Interval(-0.9, -0.8) },          new Interval[0]);    list2.addToSelf(new Interval(1.0, 3.0));    check(list1, list2, 2.5,          true, false, 1, false, false, 2, false,          new Interval[] { new Interval(-2.0, -1.0),                           new Interval(-0.9, -0.8),                           new Interval( 1.0,  3.0) },          new Interval[0]);    list1.addToSelf(new Interval(-1.2, 0.0));    check(list1, list2, -1.1,          true, false, 1, false, false, 2, true,          new Interval[] { new Interval(-2.0,  0.0),                           new Interval( 1.0,  3.0) },          new Interval[] { new Interval(-0.9, -0.8) });    IntervalsList list = new IntervalsList(new Interval(-10.0, -8.0));    list.addToSelf(new Interval(-6.0, -4.0));    list.addToSelf(new Interval(-0.85, 1.2));    list1.addToSelf(list);    check(list1, list2, 0,          false, false, 3, false, false, 2, true,          new Interval[] { new Interval(-10.0, -8.0),                           new Interval( -6.0, -4.0),                           new Interval( -2.0,  3.0) },          new Interval[] { new Interval( -0.9, -0.8),                           new Interval(  1.0,  1.2) });  }  private void check(IntervalsList l1, IntervalsList l2, double x,                     boolean b1, boolean b2, int i1,                     boolean b3, boolean b4, int i2,                     boolean b5, Interval[] add, Interval[] inter) {    assertTrue(l1.isConnex()     ^ (!b1));    assertTrue(l1.isEmpty()      ^ (!b2));    assertEquals(i1, l1.getIntervals().size());    assertTrue(l2.isConnex()     ^ (!b3));    assertTrue(l2.isEmpty()      ^ (!b4));    assertEquals(i2, l2.getIntervals().size());    assertTrue(l1.contains(x)    ^ (!b5));    checkEquals(add,   IntervalsList.add(l1, l2));    checkEquals(inter, IntervalsList.intersection(l1, l2));  }  private void checkEquals(Interval[] sa, IntervalsList sb) {    assertEquals(sa.length, sb.getIntervals().size());    Iterator iterB = sb.getIntervals().iterator();    for (int i = 0; i < sa.length; ++i) {      Interval ib = (Interval) iterB.next();      assertEquals(sa[i].getInf(), ib.getInf(), 1.0e-10);      assertEquals(sa[i].getSup(), ib.getSup(), 1.0e-10);    }  }  public static Test suite() {    return new TestSuite(IntervalsListTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.utilities;import junit.framework.*;public class MappableScalarTest  extends TestCase {  public MappableScalarTest(String name) {    super(name);    mapper  = null;    scalar1 = null;    scalar2 = null;    scalar3 = null;  }  public void testDimensionCheck() {    assertTrue(mapper.getDataArray().length == 3);  }  public void testUpdateObjects() {    double[] data = new double [mapper.getDataArray().length];    for (int i = 0; i < data.length; ++i) {      data [i] = i * 0.1;    }    mapper.updateObjects(data);    assertTrue(Math.abs(scalar1.getValue() - 0.0) < 1.0e-10);    assertTrue(Math.abs(scalar2.getValue() - 0.1) < 1.0e-10);    assertTrue(Math.abs(scalar3.getValue() - 0.2) < 1.0e-10);  }    public void testUpdateArray() {    scalar1.setValue(00.0);    scalar2.setValue(10.0);    scalar3.setValue(20.0);    mapper.updateArray();    double[] data = mapper.getDataArray();    for (int i = 0; i < data.length; ++i) {      assertTrue(Math.abs(data [i] - i * 10.0) < 1.0e-10);    }  }    public static Test suite() {    return new TestSuite(MappableScalarTest.class);  }  public void setUp() {    scalar1 = new MappableScalar();    scalar2 = new MappableScalar(2);    scalar3 = new MappableScalar(-3);    mapper = new ArrayMapper();    mapper.manageMappable(scalar1);    mapper.manageMappable(scalar2);    mapper.manageMappable(scalar3);  }  public void tearDown() {    scalar1 = null;    scalar2 = null;    scalar3 = null;    mapper = null;  }  private MappableScalar scalar1;  private MappableScalar scalar2;  private MappableScalar scalar3;  private ArrayMapper mapper;}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.utilities;import junit.framework.*;public class MappableArrayTest  extends TestCase {  public MappableArrayTest(String name) {    super(name);    array1 = null;    array2 = null;    array3 = null;    mapper = null;  }  public void testDimensionCheck() {    assertTrue(mapper.getDataArray().length == 9);  }  public void testUpdateObjects() {    double[] data = new double [mapper.getDataArray().length];    for (int i = 0; i < data.length; ++i) {      data [i] = i * 0.1;    }    mapper.updateObjects(data);    double[] a1 = array1.getArray();    assertTrue(Math.abs(a1[0] - 0.0) < 1.0e-10);    assertTrue(Math.abs(a1[1] - 0.1) < 1.0e-10);    assertTrue(Math.abs(a1[2] - 0.2) < 1.0e-10);    assertTrue(Math.abs(a1[3] - 0.3) < 1.0e-10);    double[] a2 = array2.getArray();    assertTrue(Math.abs(a2[0] - 0.4) < 1.0e-10);    assertTrue(Math.abs(a2[1] - 0.5) < 1.0e-10);    double[] a3 = array3.getArray();    assertTrue(Math.abs(a3[0] - 0.6) < 1.0e-10);    assertTrue(Math.abs(a3[1] - 0.7) < 1.0e-10);    assertTrue(Math.abs(a3[2] - 0.8) < 1.0e-10);  }    public static Test suite() {    return new TestSuite(MappableArrayTest.class);  }  public void setUp() {    array1 = new MappableArray(4);    array2 = new MappableArray(new double[2]);    array3 = new MappableArray(new double[3]);    mapper = new ArrayMapper();    mapper.manageMappable(array1);    mapper.manageMappable(array2);    mapper.manageMappable(array3);  }  public void tearDown() {    array1 = null;    array2 = null;    array3 = null;    mapper = null;  }  private MappableArray array1;  private MappableArray array2;  private MappableArray array3;  private ArrayMapper   mapper;}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.utilities;import junit.framework.*;public class IntervalTest  extends TestCase {  public IntervalTest(String name) {    super(name);  }  public void test1() {    check(new Interval(-10.0, 10.0), new Interval(11.0, 12.0), 2.5,          true, false, false,          new Interval(-10.0, 12.0), new Interval(11.0, 11.0));  }  public void test2() {    check(new Interval(-10.0, 10.0), new Interval(9.0, 12.0), 50.0,          false, false, true,          new Interval(-10.0, 12.0), new Interval(9.0, 10.0));  }  public void test3() {    check(new Interval(-10.0, 10.0), new Interval(-12.0, -11.0), 0.0,          true, false, false,          new Interval(-12.0, 10.0), new Interval(-10.0, -10.0));  }  public void test4() {    check(new Interval(-10.0, 10.0), new Interval(-4.0, 5.0), 0.0,          true, true, true,          new Interval(-10.0, 10.0), new Interval(-4.0, 5.0));  }  public void test5() {    check(new Interval(-10.0, 10.0), new Interval(-10.0, 10.0), 0.0,          true, true, true,          new Interval(-10.0, 10.0), new Interval(-10.0, 10.0));  }  private void check(Interval i1, Interval i2, double x,                     boolean b1, boolean b2, boolean b3,                     Interval add, Interval inter) {    assertTrue(i1.contains(x)    ^ (!b1));    assertTrue(i1.contains(i2)   ^ (!b2));    assertTrue(i1.intersects(i2) ^ (!b3));    assertEquals(add.getInf(), Interval.add(i1, i2).getInf(), 1.0e-10);    assertEquals(add.getSup(), Interval.add(i1, i2).getSup(), 1.0e-10);    assertEquals(inter.getInf(), Interval.intersection(i1, i2).getInf(), 1.0e-10);    assertEquals(inter.getSup(), Interval.intersection(i1, i2).getSup(), 1.0e-10);    Interval ia = new Interval(i1);    ia.addToSelf(i2);    assertEquals(add.getInf(), ia.getInf(), 1.0e-10);    assertEquals(add.getSup(), ia.getSup(), 1.0e-10);    Interval ib = new Interval(i1);    ib.intersectSelf(i2);    assertEquals(inter.getInf(), ib.getInf(), 1.0e-10);    assertEquals(inter.getSup(), ib.getSup(), 1.0e-10);  }  public static Test suite() {    return new TestSuite(IntervalTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.fitting;import java.util.Random;import junit.framework.*;import org.spaceroots.mantissa.estimation.EstimationException;import org.spaceroots.mantissa.estimation.Estimator;import org.spaceroots.mantissa.estimation.GaussNewtonEstimator;import org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator;public class PolynomialFitterTest  extends TestCase {  public PolynomialFitterTest(String name) {    super(name);  }  public void testNoError()    throws EstimationException {    Random randomizer = new Random(64925784252l);    for (int degree = 0; degree < 10; ++degree) {      Polynom p = new Polynom(degree);      for (int i = 0; i <= degree; ++i) {        p.initCoeff (i, randomizer.nextGaussian());      }      PolynomialFitter fitter =        new PolynomialFitter(degree, new LevenbergMarquardtEstimator());      for (int i = 0; i <= degree; ++i) {        fitter.addWeightedPair(1.0, i, p.valueAt(i));      }      Polynom fitted = new Polynom(fitter.fit());      for (double x = -1.0; x < 1.0; x += 0.01) {        double error = Math.abs(p.valueAt(x) - fitted.valueAt(x))          / (1.0 + Math.abs(p.valueAt(x)));        assertTrue(Math.abs(error) < 1.0e-5);      }    }  }  public void testSmallError()    throws EstimationException {    Random randomizer = new Random(53882150042l);    for (int degree = 0; degree < 10; ++degree) {      Polynom p = new Polynom(degree);      for (int i = 0; i <= degree; ++i) {        p.initCoeff(i, randomizer.nextGaussian());      }      PolynomialFitter fitter =        new PolynomialFitter(degree, new LevenbergMarquardtEstimator());      for (double x = -1.0; x < 1.0; x += 0.01) {        fitter.addWeightedPair(1.0, x,                               p.valueAt(x) + 0.1 * randomizer.nextGaussian());      }      Polynom fitted = new Polynom(fitter.fit());      for (double x = -1.0; x < 1.0; x += 0.01) {        double error = Math.abs(p.valueAt(x) - fitted.valueAt(x))          / (1.0 + Math.abs(p.valueAt(x)));        assertTrue(Math.abs(error) < 0.1);      }    }  }  public void testRedundantSolvable() {    // Levenberg-Marquardt should handle redundant information gracefully    checkUnsolvableProblem(new LevenbergMarquardtEstimator(), true);  }  public void testRedundantUnsolvable() {    // Gauss-Newton should not be able to solve redundant information    checkUnsolvableProblem(new GaussNewtonEstimator(10, 1.0e-7, 1.0e-7,                                                    1.0e-10),                           false);  }  private void checkUnsolvableProblem(Estimator estimator,                                      boolean solvable) {    Random randomizer = new Random(1248788532l);    for (int degree = 0; degree < 10; ++degree) {      Polynom p = new Polynom(degree);      for (int i = 0; i <= degree; ++i) {        p.initCoeff(i, randomizer.nextGaussian());      }      PolynomialFitter fitter = new PolynomialFitter(degree, estimator);      // reusing the same point over and over again does not bring      // information, the problem cannot be solved in this case for      // degrees greater than 1 (but one point is sufficient for      // degree 0)      for (double x = -1.0; x < 1.0; x += 0.01) {        fitter.addWeightedPair(1.0, 0.0, p.valueAt(0.0));      }      try {        fitter.fit();        assertTrue(solvable || (degree == 0));      } catch(EstimationException e) {        assertTrue((! solvable) && (degree > 0));      }    }  }  public static Test suite() {    return new TestSuite(PolynomialFitterTest.class);  }  private static class Polynom {    public Polynom(int degree) {      coeffs = new double[degree + 1];      for (int i = 0; i < coeffs.length; ++i) {        coeffs[i] = 0.0;      }    }    public Polynom(double[]coeffs) {      this.coeffs = coeffs;    }    public void initCoeff(int i, double c) {      coeffs[i] = c;    }    public double valueAt(double x) {      double y = coeffs[coeffs.length - 1];      for (int i = coeffs.length - 2; i >= 0; --i) {        y = y * x + coeffs[i];      }      return y;    }    private double[] coeffs;  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.fitting;import java.util.Random;import junit.framework.*;import org.spaceroots.mantissa.estimation.EstimatedParameter;import org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator;import org.spaceroots.mantissa.estimation.WeightedMeasurement;public class AbstractCurveFitterTest  extends TestCase {  public AbstractCurveFitterTest(String name) {    super(name);    fitter = null;  }  public void testAlreadySorted() {    for (double x = 0.0; x < 100.0; x += 1.0) {      fitter.addWeightedPair(1.0, x, 0.0);    }    checkSorted();  }  public void testReversed() {    for (double x = 0.0; x < 100.0; x += 1.0) {      fitter.addWeightedPair(1.0, 100.0 - x, 0.0);    }    checkSorted();  }  public void testRandom() {    Random randomizer = new Random(86757343594l);    for (int i = 0; i < 100; ++i) {      fitter.addWeightedPair(1.0, 10.0 * randomizer.nextDouble(), 0.0);    }    checkSorted();  }  public void checkSorted() {    fitter.doSort();    WeightedMeasurement[] measurements = fitter.getMeasurements();    for (int i = 1; i < measurements.length; ++i) {      AbstractCurveFitter.FitMeasurement m1        = (AbstractCurveFitter.FitMeasurement) measurements[i-1];      AbstractCurveFitter.FitMeasurement m2        = (AbstractCurveFitter.FitMeasurement) measurements[i];      assertTrue(m1.x <= m2.x);    }  }  public static Test suite() {    return new TestSuite(AbstractCurveFitterTest.class);  }  public void setUp() {    fitter = new DummyFitter();  }  public void tearDown() {    fitter = null;  }  private static class DummyFitter    extends AbstractCurveFitter {    public DummyFitter() {      super(10, new LevenbergMarquardtEstimator());    }    public double valueAt(double x) {      return 0.0;    }    public double partial(double x, EstimatedParameter p) {      return 0.0;    }    public void doSort() {      sortMeasurements();    }    private static final long serialVersionUID = 4016396219767783678L;  }  private DummyFitter fitter;}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.fitting;import java.util.Random;import junit.framework.*;import org.spaceroots.mantissa.estimation.EstimationException;import org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator;import org.spaceroots.mantissa.estimation.WeightedMeasurement;public class HarmonicFitterTest  extends TestCase {  public HarmonicFitterTest(String name) {    super(name);  }  public void testNoError()    throws EstimationException {    HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);    HarmonicFitter fitter =      new HarmonicFitter(new LevenbergMarquardtEstimator());    for (double x = 0.0; x < 1.3; x += 0.01) {      fitter.addWeightedPair(1.0, x, f.valueAt(x));    }    double[] coeffs = fitter.fit();    HarmonicFunction fitted = new HarmonicFunction(coeffs[0],                                                   coeffs[1],                                                   coeffs[2]);    assertTrue(Math.abs(coeffs[0] - f.getA()) < 1.0e-13);    assertTrue(Math.abs(coeffs[1] - f.getOmega()) < 1.0e-13);    assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 1.0e-13);    for (double x = -1.0; x < 1.0; x += 0.01) {      assertTrue(Math.abs(f.valueAt(x) - fitted.valueAt(x)) < 1.0e-13);    }  }  public void test1PercentError()    throws EstimationException {    Random randomizer = new Random(64925784252l);    HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);    HarmonicFitter fitter =      new HarmonicFitter(new LevenbergMarquardtEstimator());    for (double x = 0.0; x < 10.0; x += 0.1) {      fitter.addWeightedPair(1.0, x,                             f.valueAt(x) + 0.01 * randomizer.nextGaussian());    }    double[] coeffs = fitter.fit();    new HarmonicFunction(coeffs[0], coeffs[1], coeffs[2]);    assertTrue(Math.abs(coeffs[0] - f.getA()) < 7.6e-4);    assertTrue(Math.abs(coeffs[1] - f.getOmega()) < 2.7e-3);    assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 1.3e-2);    WeightedMeasurement[] measurements = fitter.getMeasurements();    for (int i = 0; i < measurements.length; ++i) {      WeightedMeasurement m = measurements[i];      assertTrue(Math.abs(measurements[i].getMeasuredValue()                          - m.getTheoreticalValue()) < 0.04);    }  }  public void testUnsorted()    throws EstimationException {    Random randomizer = new Random(64925784252l);    HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);    HarmonicFitter fitter =      new HarmonicFitter(new LevenbergMarquardtEstimator());    // build a regularly spaced array of measurements    int size = 100;    double[] xTab = new double[size];    double[] yTab = new double[size];    for (int i = 0; i < size; ++i) {      xTab[i] = 0.1 * i;      yTab[i] = f.valueAt (xTab[i]) + 0.01 * randomizer.nextGaussian();    }    // shake it    for (int i = 0; i < size; ++i) {      int i1 = randomizer.nextInt(size);      int i2 = randomizer.nextInt(size);      double xTmp = xTab[i1];      double yTmp = yTab[i1];      xTab[i1] = xTab[i2];      yTab[i1] = yTab[i2];      xTab[i2] = xTmp;      yTab[i2] = yTmp;    }    // pass it to the fitter    for (int i = 0; i < size; ++i) {      fitter.addWeightedPair(1.0, xTab[i], yTab[i]);    }    double[] coeffs = fitter.fit();    new HarmonicFunction(coeffs[0], coeffs[1], coeffs[2]);    assertTrue(Math.abs(coeffs[0] - f.getA()) < 7.6e-4);    assertTrue(Math.abs(coeffs[1] - f.getOmega()) < 3.5e-3);    assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 1.5e-2);    WeightedMeasurement[] measurements = fitter.getMeasurements();    for (int i = 0; i < measurements.length; ++i) {      WeightedMeasurement m = measurements[i];      assertTrue(Math.abs(m.getMeasuredValue() - m.getTheoreticalValue())                 < 0.04);    }  }  public static Test suite() {    return new TestSuite(HarmonicFitterTest.class);  }  /** Center an angle with respect to another one. */  private static double center(double a, double ref) {    double twoPi = Math.PI + Math.PI;    return a - twoPi * Math.floor((a + Math.PI - ref) / twoPi);  }  private static class HarmonicFunction {    public HarmonicFunction(double a, double omega, double phi) {      this.a     = a;      this.omega = omega;      this.phi   = phi;    }    public double valueAt(double x) {      return a * Math.cos(omega * x + phi);    }    public double getA() {      return a;    }    public double getOmega() {      return omega;    }    public double getPhi() {      return phi;    }    private double a;    private double omega;    private double phi;  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.roots;import org.spaceroots.mantissa.functions.scalar.ComputableFunction;import java.util.ArrayList;/** This class implement a reference problem for junit tests. */public abstract class TestProblem implements ComputableFunction {  private double a;  private double b;  private double expectedRoot;  protected TestProblem(double a, double b, double expectedRoot) {    this.a            = a;    this.b            = b;    this.expectedRoot = expectedRoot;  }  public double getA() {    return a;  }  public double getB() {    return b;  }  public double getExpectedRoot() {    return expectedRoot;  }  public boolean checkResult(double foundRoot, double tol) {    return Math.abs(foundRoot - expectedRoot) <= tol;  }  /** Get the reference problems from G. E. Alefeld, F. A. Potra and Y. Shi. */  public static TestProblem[] getAPSProblems() {    ArrayList problems = new ArrayList();    // problem 1    problems.add(new APSProblem1(Math.PI / 2, Math.PI, 1.8954942670340));    // problems 2 to 11    double[] roots2To11 = {      3.0229153472731,  6.6837535608081, 11.238701655002, 19.676000080623,     29.828227326505,  41.906116195289,  55.953595800143, 71.985665586588,     90.008868539167, 110.02653274833    };    for (int k = 0, n = 1; n <= 10; ++n) {      problems.add(new APSProblems2To11(1.0e-9 + n * n,                                        (n+1) * (n+1) - 1.0e-9,                                        roots2To11[k++]));    }    // problems 12 to 14    problems.add(new APSProblems12To14( -40, -9.0, 31.0, 0.0));    problems.add(new APSProblems12To14(-100, -9.0, 31.0, 0.0));    problems.add(new APSProblems12To14(-200, -9.0, 31.0, 0.0));    // problems 15 to 17    int[] n15 = { 4, 6, 8, 10, 12 };    double[] roots15 = {      0.66874030497642, 0.76472449133173, 0.81776543395794,      0.85133992252078, 0.87448527222117    };    for (int k = 0; k < n15.length; ++k) {      problems.add(new APSProblems15To17(n15[k], 0.2, 0.0, 5.0, roots15[k]));    }    int[] n16 = { 4, 6, 8, 10, 12 };    for (int k = 0; k < n16.length; ++k) {      problems.add(new APSProblems15To17(n16[k], 1.0, 0.0, 5.0, 1.0));    }    int[] n17 = { 8, 10, 12, 14 };    for (int k = 0; k < n17.length; ++k) {      problems.add(new APSProblems15To17(n17[k], 1.0, -0.95, 4.05, 1.0));    }    // problem 18    problems.add(new APSProblem18(0.0, 1.5, 0.52359877559830));    // problem 19    int[] n19 = { 1, 2, 3, 4, 5, 20, 40, 60, 80, 100 };    double[] roots19 = {      0.42247770964124,   0.30669941048320,   0.22370545765466,      0.17171914751951,   0.13825715505682,   3.4657359020854e-2,      1.7328679513999e-2, 1.1552453009332e-2, 8.6643397569993e-3,      6.9314718055995e-3    };    for (int k = 0; k < n19.length; ++k) {      problems.add(new APSProblem19(n19[k], 0.0, 1.0, roots19[k]));    }    // problem 20    int[] n20 = { 5, 10, 20 };    double[] roots20 = {      3.8402551840622e-2, 9.9000099980005e-3, 2.4937500390620e-3    };    for (int k = 0; k < n20.length; ++k) {      problems.add(new APSProblem20(n20[k], 0.0, 1.0, roots20[k]));    }    // problem 21    int[] n21 = { 2, 5, 10, 15, 20 };    double[] roots21 = {      0.5, 0.34595481584824, 0.24512233375331,      0.19554762353657, 0.16492095727644    };    for (int k = 0; k < n21.length; ++k) {      problems.add(new APSProblem21(n21[k], 0.0, 1.0, roots21[k]));    }    // problem 22    int[] n22 = { 1, 2, 4, 5, 8, 15, 20 };    double[] roots22 = {      0.27550804099948,   0.13775402049974,   1.0305283778156e-2,      3.6171081789041e-3, 4.1087291849640e-4, 2.5989575892908e-5,      7.6685951221853e-6    };    for (int k = 0; k < n22.length; ++k) {      problems.add(new APSProblem22(n22[k], 0.0, 1.0, roots22[k]));    }    // problem 23    int[] n23 = { 1, 5, 10, 15, 20 };    double[] roots23 = {      0.40105813754155, 0.51615351875793, 0.53952222690842,      0.54818229434066, 0.55270466667849    };    for (int k = 0; k < n23.length; ++k) {      problems.add(new APSProblem23(n23[k], 0.0, 1.0, roots23[k]));    }    // problem 24    int[] n24 = { 2, 5, 15, 20 };    for (int k = 0; k < n24.length; ++k) {      problems.add(new APSProblem24(n24[k], 0.01, 1, 1.0 / n24[k]));    }    // problem 25    int[] n25 = {       2,  3,  4,  5,  6,       7,  9, 11, 13, 15,      17, 19, 21, 23, 25,      27, 29, 31, 33    };    for (int k = 0; k < n25.length; ++k) {      problems.add(new APSProblem25(n25[k], 1.0, 100.0, n25[k]));    }    // problem 26    problems.add(new APSProblem26(-1.0, 4.0, 0.0));    // problem 27    int[] n27 = {      1,  2,  3,  4,  5,  6,  7,  8,  9,  10,     11, 12, 13, 14, 15, 16, 17, 18, 19,  20,     21, 22, 23, 24, 25, 26, 27, 28, 29,  30,     31, 32, 33, 34, 35, 36, 37, 38, 39,  40    };    for (int k = 0; k < n27.length; ++k) {      problems.add(new APSProblem27(n27[k], -10000.0, Math.PI / 2,                                    0.62380651896161));    }    // problem 28    int[] n28 = {       20,  21,  22,  23,  24,  25,  26,  27,  28,   29,       30,  31,  32,  33,  34,  35,  36,  37,  38,   39, 40,      100, 200, 300, 400, 500, 600, 700, 800, 900, 1000 };    double[] roots28 = {      5.9051305594220e-5, 5.6367155339937e-5, 5.3916409455592e-5,      5.1669892394942e-5, 4.9603096699145e-5, 4.7695285287639e-5,      4.5928793239949e-5, 4.4288479195665e-5, 4.2761290257883e-5,      4.1335913915954e-5, 4.0002497338020e-5, 3.8752419296207e-5,      3.7578103559958e-5, 3.6472865219959e-5, 3.5430783356532e-5,      3.4446594929961e-5, 3.3515605877800e-5, 3.2633616249437e-5,      3.1796856858426e-5, 3.1001935436965e-5, 3.0245790670210e-5,      1.2277994232462e-5, 6.1695393904409e-6, 4.1198585298293e-6,      3.0924623877272e-6, 2.4752044261050e-6, 2.0633567678513e-6,      1.7690120078154e-6, 1.5481615698859e-6, 1.3763345366022e-6,      1.2388385788997e-6    };    for (int k = 0; k < n28.length; ++k) {      problems.add(new APSProblem28(n28[k], -10000.0, 10000.0, roots28[k]));    }    return (TestProblem[]) problems.toArray(new TestProblem[problems.size()]);  }  private static class APSProblem1 extends TestProblem {    private static final long serialVersionUID = -186095948802525864L;    public APSProblem1(double a, double b, double expectedRoot) {      super(a, b, expectedRoot);    }    public double valueAt(double x) {      return Math.sin(x) - x / 2;    }  }  private static class APSProblems2To11 extends TestProblem {    private static final long serialVersionUID = -1284328672006328516L;    public APSProblems2To11(double a, double b, double expectedRoot) {      super(a, b, expectedRoot);    }    public double valueAt(double x) {      double f = 0;      for (int i = 1; i <= 20; ++i) {        double n = 2.0 * i - 5.0;        double d = x - i * i;        f += n * n / (d * d * d);      }      return -2 * f;    }  }  private static class APSProblems12To14 extends TestProblem {    private static final long serialVersionUID = 3371996034561221313L;    private int n;    public APSProblems12To14(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      this.n = n;    }    public double valueAt(double x) {      return n * x * Math.exp(-x);    }  }  private static class APSProblems15To17 extends TestProblem {    private static final long serialVersionUID = -5460543876513796612L;    private int    n;    private double u;    public APSProblems15To17(int n, double u,                             double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      this.n = n;      this.u = u;    }    public double valueAt(double x) {      return Math.pow(x, n) - u;    }  }  private static class APSProblem18 extends TestProblem {    private static final long serialVersionUID = 6762799934117390438L;    public APSProblem18(double a, double b, double expectedRoot) {      super(a, b, expectedRoot);    }    public double valueAt(double x) {      return Math.sin(x) - 0.5;    }  }  private static class APSProblem19 extends TestProblem {    private static final long serialVersionUID = 4962041891152128524L;    private int n;    public APSProblem19(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      this.n = n;    }    public double valueAt(double x) {      return 2.0 * x * Math.exp(-n) - 2.0 *Math.exp(-n * x) + 1.0;    }  }  private static class APSProblem20 extends TestProblem {    private static final long serialVersionUID = -7391954140799812791L;    private int n;    private int oPoMn2;    public APSProblem20(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      this.n = n;      int oMn =  1 - n;      oPoMn2 = 1 + oMn * oMn;    }    public double valueAt(double x) {      double v = 1.0 - n * x;      return oPoMn2 * x - v * v;    }  }  private static class APSProblem21 extends TestProblem {    private static final long serialVersionUID = -4160028543895639114L;    private int n;    public APSProblem21(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      this.n = n;    }    public double valueAt(double x) {      return x * x - Math.pow(1 - x, n);    }  }  private static class APSProblem22 extends TestProblem {    private static final long serialVersionUID = 3807046732154081146L;    private int n;    private int oPoMn4;    public APSProblem22(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      this.n   = n;      int oMn  = 1 - n;      int oMn2 = oMn * oMn;      oPoMn4   = 1 + oMn2 * oMn2;    }    public double valueAt(double x) {      double oMnx  = 1 - n * x;      double oMnx2 = oMnx * oMnx;      return oPoMn4 * x - oMnx2 * oMnx2;    }  }  private static class APSProblem23 extends TestProblem {    private static final long serialVersionUID = -486669213837396921L;    private int n;    public APSProblem23(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      this.n = n;    }    public double valueAt(double x) {      return (x - 1.0) * Math.exp(-n * x) + Math.pow(x, n);    }  }  private static class APSProblem24 extends TestProblem {    private static final long serialVersionUID = -628275471717968182L;    private int n;    public APSProblem24(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      this.n = n;    }    public double valueAt(double x) {      return (n * x - 1.0) / ((n - 1) * x);    }  }  private static class APSProblem25 extends TestProblem {    private static final long serialVersionUID = 5207170686914959073L;    private double u;    private double v;;    public APSProblem25(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      u = 1.0 / n;      v = Math.pow(n, u);    }    public double valueAt(double x) {      return Math.pow(x, u) - v;    }  }  private static class APSProblem26 extends TestProblem {    private static final long serialVersionUID = 1063884352586457076L;    public APSProblem26(double a, double b, double expectedRoot) {      super(a, b, expectedRoot);    }    public double valueAt(double x) {      if (x == 0.0) {        return 0;      }      return x / Math.exp(1 / (x * x));    }    // this is a very special case since there is a wide range around    // the true root (which is 0) for which |f(x)| is smaller than the    // smallest representable positive number (according to IEEE 754):    //    f(0.03762210865...) = 2^-1024    //    f(0.03764056462...) = 2^-1023    //    f(0.03765904777...) = 2^-1022    //    f(0.03767755816...) = 2^-1021    // any root between -0.03768 and +0.03768 should be considered good    public boolean checkResult(double foundRoot, double tol) {      return Math.abs(foundRoot) <= 0.03768;    }  }  private static class APSProblem27 extends TestProblem {    private static final long serialVersionUID = -3549158218723499035L;    private double u;    public APSProblem27(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      u = n / 20.0;    }    public double valueAt(double x) {      if (x >= 0.0) {        return (x / 1.5 + Math.sin(x) - 1.0) * u;      }      return -u;    }  }  private static class APSProblem28 extends TestProblem {    private static final long serialVersionUID = -8198306839874267863L;    private double threshold;    private static final double yHigh= Math.exp(1.0) - 1.859;    private int    u;    public APSProblem28(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      threshold = 0.002 / (1 + n);      u         = (n + 1) * 500;    }    public double valueAt(double x) {      if (x >= threshold) {        return yHigh;      } else if (x >= 0) {        return Math.exp(u * x) - 1.859;      } else {        return -0.859;      }    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.roots;import org.spaceroots.mantissa.functions.FunctionException;import junit.framework.*;public class BrentSolverTest  extends TestCase {  public BrentSolverTest(String name) {    super(name);  }  public void testAlefeldPotraShi()  throws FunctionException {    TestProblem[] problems = TestProblem.getAPSProblems();    BrentSolver solver     = new BrentSolver();    for (int i = 0; i < problems.length; ++i) {      TestProblem p = problems[i];      double tol = 1.0e-10 * Math.abs(p.getExpectedRoot());      assertTrue(solver.findRoot(p, new Checker(tol), 1000,                                 p.getA(), p.valueAt(p.getA()),                                 p.getB(), p.valueAt(p.getB())));      assertTrue(p.checkResult(solver.getRoot(), tol));    }  }  private static class Checker implements ConvergenceChecker {    private double tolerance;    public Checker (double tolerance) {      this.tolerance = tolerance;    }    public int converged (double xLow, double fLow,                          double xHigh, double fHigh) {      return (Math.abs(xHigh - xLow) <= tolerance)        ? ((Math.abs(fLow) <= Math.abs(fHigh))           ? ConvergenceChecker.LOW           : ConvergenceChecker.HIGH)        : ConvergenceChecker.NONE;    }  }  public static Test suite() {    return new TestSuite(BrentSolverTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;public class HighamHall54IntegratorTest  extends TestCase {  public HighamHall54IntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      HighamHall54Integrator integrator = new HighamHall54Integrator(0.0, 1.0,                                                                     1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()+10],                           1.0, new double[pb.getDimension()+10]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testMinStep()    throws DerivativeException, IntegratorException {    try {      TestProblem1 pb = new TestProblem1();      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-15;      double scalRelativeTolerance = 1.0e-15;      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb);      integ.setStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testIncreasingTolerance()    throws DerivativeException, IntegratorException {    int previousCalls = Integer.MAX_VALUE;    for (int i = -12; i < -2; ++i) {      TestProblem1 pb = new TestProblem1();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = Math.pow(10.0, i);      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb);      integ.setStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      // the 1.3 factor is only valid for this test      // and has been obtained from trial and error      // there is no general relation between local and global errors      assertTrue(handler.getMaximalError() < (1.3 * scalAbsoluteTolerance));      int calls = pb.getCalls();      assertTrue(calls <= previousCalls);      previousCalls = calls;    }  }  public void testSwitchingFunctions()    throws DerivativeException, IntegratorException {    TestProblem4 pb = new TestProblem4();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                            scalAbsoluteTolerance,                                                            scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb);    integ.setStepHandler(handler);    SwitchingFunction[] functions = pb.getSwitchingFunctions();    for (int l = 0; l < functions.length; ++l) {      integ.addSwitchingFunction(functions[l],                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);    }    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getMaximalError() < 1.0e-7);    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                            scalAbsoluteTolerance,                                                            scalRelativeTolerance);    integ.setStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);  }  private static class KeplerHandler implements StepHandler {    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      nbSteps = 0;      maxError = 0;    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      nbSteps = 0;      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) {      ++nbSteps;      double[] interpolatedY = interpolator.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }      if (isLast) {        assertTrue(maxError < 1.54e-10);        assertTrue(nbSteps < 520);      }    }    private TestProblem3 pb;    private int nbSteps;    private double maxError;  }  public static Test suite() {    return new TestSuite(HighamHall54IntegratorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;public class DormandPrince853IntegratorTest  extends TestCase {  public DormandPrince853IntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,                                                                             1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()+10],                           1.0, new double[pb.getDimension()+10]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testNullIntervalCheck() {    try  {      TestProblem1 pb = new TestProblem1();      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,                                                                             1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()],                           0.0, new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testMinStep()    throws DerivativeException, IntegratorException {    try {      TestProblem1 pb = new TestProblem1();      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-15;      double scalRelativeTolerance = 1.0e-15;      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                  scalAbsoluteTolerance,                                                                  scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb);      integ.setStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testIncreasingTolerance()    throws DerivativeException, IntegratorException {    int previousCalls = Integer.MAX_VALUE;    for (int i = -12; i < -2; ++i) {      TestProblem1 pb = new TestProblem1();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = Math.pow(10.0, i);      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                  scalAbsoluteTolerance,                                                                  scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb);      integ.setStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      // the 1.3 factor is only valid for this test      // and has been obtained from trial and error      // there is no general relation between local and global errors      assertTrue(handler.getMaximalError() < (1.3 * scalAbsoluteTolerance));      int calls = pb.getCalls();      assertTrue(calls <= previousCalls);      previousCalls = calls;    }  }  public void testSwitchingFunctions()    throws DerivativeException, IntegratorException {    TestProblem4 pb = new TestProblem4();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-9;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                scalAbsoluteTolerance,                                                                scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb);    integ.setStepHandler(handler);    SwitchingFunction[] functions = pb.getSwitchingFunctions();    for (int l = 0; l < functions.length; ++l) {      integ.addSwitchingFunction(functions[l],                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);    }    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getMaximalError() < 5.0e-8);    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                scalAbsoluteTolerance,                                                                scalRelativeTolerance);    integ.setStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(pb.getCalls() < 2900);  }  public void testVariableSteps()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);    integ.setStepHandler(new VariableHandler());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);  }  public void testNoDenseOutput()    throws DerivativeException, IntegratorException {    TestProblem1 pb1 = new TestProblem1();    TestProblem1 pb2 = (TestProblem1) pb1.clone();    double minStep = 0.1 * (pb1.getFinalTime() - pb1.getInitialTime());    double maxStep = pb1.getFinalTime() - pb1.getInitialTime();    double scalAbsoluteTolerance = 1.0e-4;    double scalRelativeTolerance = 1.0e-4;    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                scalAbsoluteTolerance,                                                                scalRelativeTolerance);    integ.setStepHandler(DummyStepHandler.getInstance());    integ.integrate(pb1,                    pb1.getInitialTime(), pb1.getInitialState(),                    pb1.getFinalTime(), new double[pb1.getDimension()]);    int callsWithoutDenseOutput = pb1.getCalls();    integ.setStepHandler(new InterpolatingStepHandler());    integ.integrate(pb2,                    pb2.getInitialTime(), pb2.getInitialState(),                    pb2.getFinalTime(), new double[pb2.getDimension()]);    int callsWithDenseOutput = pb2.getCalls();    assertTrue(callsWithDenseOutput > callsWithoutDenseOutput);  }  public void testUnstableDerivative()  throws DerivativeException, IntegratorException {    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);    FirstOrderIntegrator integ =      new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0);    integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12);    double[] y = { Double.NaN };    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);    assertEquals(8.0, y[0], 1.0e-12);  }  private static class KeplerHandler implements StepHandler {    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public boolean requiresDenseOutput() {      return true;    }    public void reset() {      nbSteps = 0;      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast)    throws DerivativeException {      ++nbSteps;      for (int a = 1; a < 10; ++a) {        double prev   = interpolator.getPreviousTime();        double curr   = interpolator.getCurrentTime();        double interp = ((10 - a) * prev + a * curr) / 10;        interpolator.setInterpolatedTime(interp);        double[] interpolatedY = interpolator.getInterpolatedState ();        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());        double dx = interpolatedY[0] - theoreticalY[0];        double dy = interpolatedY[1] - theoreticalY[1];        double error = dx * dx + dy * dy;        if (error > maxError) {          maxError = error;        }      }      if (isLast) {        assertTrue(maxError < 2.4e-10);        assertTrue(nbSteps < 150);      }    }    private int nbSteps;    private double maxError;    private TestProblem3 pb;  }  private static class VariableHandler implements StepHandler {    public VariableHandler() {      reset();    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      firstTime = true;      minStep = 0;      maxStep = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) {      double step = Math.abs(interpolator.getCurrentTime()                             - interpolator.getPreviousTime());      if (firstTime) {        minStep   = Math.abs(step);        maxStep   = minStep;        firstTime = false;      } else {        if (step < minStep) {          minStep = step;        }        if (step > maxStep) {          maxStep = step;        }      }      if (isLast) {        assertTrue(minStep < (1.0 / 100.0));        assertTrue(maxStep > (1.0 / 2.0));      }    }    private boolean firstTime = true;    private double  minStep = 0;    private double  maxStep = 0;  }  private static class InterpolatingStepHandler implements StepHandler {    public boolean requiresDenseOutput() {      return true;    }    public void reset() {    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast)    throws DerivativeException {      double prev = interpolator.getPreviousTime();      double curr = interpolator.getCurrentTime();      interpolator.setInterpolatedTime(0.5*(prev + curr));    }  }  public static Test suite() {    return new TestSuite(DormandPrince853IntegratorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;import org.spaceroots.mantissa.estimation.EstimationException;import org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator;import org.spaceroots.mantissa.fitting.PolynomialFitter;public class MidpointIntegratorTest  extends TestCase {  public MidpointIntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      new MidpointIntegrator(0.01).integrate(pb,                                             0.0, new double[pb.getDimension()+10],                                             1.0, new double[pb.getDimension()+10]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }    public void testDecreasingSteps()    throws DerivativeException, IntegratorException  {          TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousError = Double.NaN;      for (int i = 4; i < 10; ++i) {        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();        double step = (pb.getFinalTime() - pb.getInitialTime())          * Math.pow(2.0, -i);        FirstOrderIntegrator integ = new MidpointIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb);        integ.setStepHandler(handler);        SwitchingFunction[] functions = pb.getSwitchingFunctions();        for (int l = 0; l < functions.length; ++l) {          integ.addSwitchingFunction(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);        }        integ.integrate(pb,                        pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        double error = handler.getMaximalError();        if (i > 4) {          assertTrue(error < Math.abs(previousError));        }        previousError = error;      }    }  }  public void testOrder()  throws EstimationException, DerivativeException, IntegratorException {    PolynomialFitter fitter =      new PolynomialFitter(1, new LevenbergMarquardtEstimator());    TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      for (int i = 0; i < 10; ++i) {        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();        double step  = (pb.getFinalTime() - pb.getInitialTime())          * Math.pow(2.0, -(i + 1));        FirstOrderIntegrator integ = new MidpointIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb);        integ.setStepHandler(handler);        SwitchingFunction[] functions = pb.getSwitchingFunctions();        for (int l = 0; l < functions.length; ++l) {          integ.addSwitchingFunction(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);        }        integ.integrate(pb,                        pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        fitter.addWeightedPair(1.0,                               Math.log(Math.abs(step)),                               Math.log(handler.getLastError()));      }      // this is an order 2 method      double[] coeffs = fitter.fit();      assertTrue(coeffs[1] > 1.2);      assertTrue(coeffs[1] < 2.8);    }  }  public void testSmallStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb  = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new MidpointIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb);    integ.setStepHandler(handler);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() < 2.0e-7);    assertTrue(handler.getMaximalError() < 1.0e-6);  }  public void testBigStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb  = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new MidpointIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb);    integ.setStepHandler(handler);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() > 0.01);    assertTrue(handler.getMaximalError() > 0.05);  }  public static Test suite() {    return new TestSuite(MidpointIntegratorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    y' = -y * </pre> * the solution of this equation is a simple exponential function : * <pre> *   y (t) = y (t0) exp (t0-t) * </pre> * </p> */class TestProblem1  extends TestProblemAbstract {  /** theoretical state */  private double[] y;  /**   * Simple constructor.   */  public TestProblem1() {    super();    double[] y0 = { 1.0, 0.1 };    setInitialConditions(0.0, y0);    setFinalConditions(4.0);    double[] errorScale = { 1.0, 1.0 };    setErrorScale(errorScale);    y = new double[y0.length];  }   /**   * Copy constructor.   * @param problem problem to copy   */  public TestProblem1(TestProblem1 problem) {    super(problem);    y = (double[]) problem.y.clone();  }  /**   * Clone operation.   * @return a copy of the instance   */  public Object clone() {    return new TestProblem1(this);  }  public void doComputeDerivatives(double t, double[] y, double[] yDot) {    // compute the derivatives    for (int i = 0; i < n; ++i)      yDot[i] = -y[i];  }  public double[] computeTheoreticalState(double t) {    double c = Math.exp (t0 - t);    for (int i = 0; i < n; ++i) {      y[i] = c * y0[i];    }    return y;  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;public class DormandPrince54IntegratorTest  extends TestCase {  public DormandPrince54IntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      DormandPrince54Integrator integrator = new DormandPrince54Integrator(0.0, 1.0,                                                                           1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()+10],                           1.0, new double[pb.getDimension()+10]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testMinStep()    throws DerivativeException, IntegratorException {    try {      TestProblem1 pb = new TestProblem1();      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-15;      double scalRelativeTolerance = 1.0e-15;      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                 scalAbsoluteTolerance,                                                                 scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb);      integ.setStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testSmallLastStep()    throws DerivativeException, IntegratorException {    TestProblemAbstract pb = new TestProblem5();    double minStep = 1.25;    double maxStep = Math.abs(pb.getFinalTime() - pb.getInitialTime());    double scalAbsoluteTolerance = 6.0e-4;    double scalRelativeTolerance = 6.0e-4;    AdaptiveStepsizeIntegrator integ =      new DormandPrince54Integrator(minStep, maxStep,                                    scalAbsoluteTolerance,                                    scalRelativeTolerance);    DP54SmallLastHandler handler = new DP54SmallLastHandler(minStep);    integ.setStepHandler(handler);    integ.setInitialStepSize(1.7);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.wasLastSeen());  }  private static class DP54SmallLastHandler implements StepHandler {    public DP54SmallLastHandler(double minStep) {      lastSeen = false;      this.minStep = minStep;    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {    }    public void handleStep(StepInterpolator interpolator, boolean isLast) {      if (isLast) {        lastSeen = true;        double h = interpolator.getCurrentTime() - interpolator.getPreviousTime();        assertTrue(Math.abs(h) < minStep);      }    }    public boolean wasLastSeen() {      return lastSeen;    }    private boolean lastSeen;    private double  minStep;  }  public void testIncreasingTolerance()    throws DerivativeException, IntegratorException {    int previousCalls = Integer.MAX_VALUE;    for (int i = -12; i < -2; ++i) {      TestProblem1 pb = new TestProblem1();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = Math.pow(10.0, i);      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                 scalAbsoluteTolerance,                                                                 scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb);      integ.setStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      // the 0.7 factor is only valid for this test      // and has been obtained from trial and error      // there is no general relation between local and global errors      assertTrue(handler.getMaximalError() < (0.7 * scalAbsoluteTolerance));      int calls = pb.getCalls();      assertTrue(calls <= previousCalls);      previousCalls = calls;    }  }  public void testSwitchingFunctions()    throws DerivativeException, IntegratorException {    TestProblem4 pb = new TestProblem4();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb);    integ.setStepHandler(handler);    SwitchingFunction[] functions = pb.getSwitchingFunctions();    for (int l = 0; l < functions.length; ++l) {      integ.addSwitchingFunction(functions[l],                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);    }    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getMaximalError() < 5.0e-6);    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);    integ.setStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(pb.getCalls() < 2800);  }  public void testVariableSteps()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);    integ.setStepHandler(new VariableHandler());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);  }  private static class KeplerHandler implements StepHandler {    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public boolean requiresDenseOutput() {      return true;    }    public void reset() {      nbSteps = 0;      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast)    throws DerivativeException {      ++nbSteps;      for (int a = 1; a < 10; ++a) {        double prev   = interpolator.getPreviousTime();        double curr   = interpolator.getCurrentTime();        double interp = ((10 - a) * prev + a * curr) / 10;        interpolator.setInterpolatedTime(interp);        double[] interpolatedY = interpolator.getInterpolatedState ();        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());        double dx = interpolatedY[0] - theoreticalY[0];        double dy = interpolatedY[1] - theoreticalY[1];        double error = dx * dx + dy * dy;        if (error > maxError) {          maxError = error;        }      }      if (isLast) {        assertTrue(maxError < 7.0e-10);        assertTrue(nbSteps < 400);      }    }    private int nbSteps;    private double maxError;    private TestProblem3 pb;  }  private static class VariableHandler implements StepHandler {    public VariableHandler() {      firstTime = true;      minStep = 0;      maxStep = 0;    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      firstTime = true;      minStep = 0;      maxStep = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) {      double step = Math.abs(interpolator.getCurrentTime()                             - interpolator.getPreviousTime());      if (firstTime) {        minStep   = Math.abs(step);        maxStep   = minStep;        firstTime = false;      } else {        if (step < minStep) {          minStep = step;        }        if (step > maxStep) {          maxStep = step;        }      }      if (isLast) {        assertTrue(minStep < (1.0 / 450.0));        assertTrue(maxStep > (1.0 / 4.2));      }    }      private boolean firstTime;    private double  minStep;    private double  maxStep;  }  public static Test suite() {    return new TestSuite(DormandPrince54IntegratorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;import java.util.Random;import java.io.ByteArrayOutputStream;import java.io.ByteArrayInputStream;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.IOException;public class ClassicalRungeKuttaStepInterpolatorTest  extends TestCase {  public ClassicalRungeKuttaStepInterpolatorTest(String name) {    super(name);  }  public void testSerialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    integ.setStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    oos.writeObject(integ.getStepHandler());    assertTrue(bos.size () > 700000);    assertTrue(bos.size () < 701000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError > 0.005);  }  public static Test suite() {    return new TestSuite(ClassicalRungeKuttaStepInterpolatorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;/** * This class is used to handle steps for the test problems * integrated during the junit tests for the ODE integrators. */class TestProblemHandler  implements StepHandler {  /** Associated problem. */  private TestProblemAbstract problem;  /** Maximal error encountered during the integration. */  private double maxError;  /** Error at the end of the integration. */  private double lastError;  /** Time at the end of integration. */  private double lastTime;  /**   * Simple constructor.   * @param problem problem for which steps should be handled   */  public TestProblemHandler(TestProblemAbstract problem) {    this.problem = problem;    reset();  }  public boolean requiresDenseOutput() {    return true;  }  public void reset() {    maxError  = 0;    lastError = 0;  }  public void handleStep(StepInterpolator interpolator,                         boolean isLast)    throws DerivativeException {    double pT = interpolator.getPreviousTime();    double cT = interpolator.getCurrentTime();    double[] errorScale = problem.getErrorScale();    // store the error at the last step    if (isLast) {      double[] interpolatedY = interpolator.getInterpolatedState();      double[] theoreticalY  = problem.computeTheoreticalState(cT);      for (int i = 0; i < interpolatedY.length; ++i) {        double error = Math.abs(interpolatedY[i] - theoreticalY[i]);        if (error > lastError) {          lastError = error;        }      }      lastTime = cT;    }    // walk through the step    for (int k = 0; k <= 20; ++k) {      double time = pT + (k * (cT - pT)) / 20;      interpolator.setInterpolatedTime(time);      double[] interpolatedY = interpolator.getInterpolatedState();      double[] theoreticalY  = problem.computeTheoreticalState(interpolator.getInterpolatedTime());      // update the errors      for (int i = 0; i < interpolatedY.length; ++i) {        double error = errorScale[i] * Math.abs(interpolatedY[i] - theoreticalY[i]);        if (error > maxError) {          maxError = error;        }      }    }  }  /**   * Get the maximal error encountered during integration.   * @return maximal error   */  public double getMaximalError() {    return maxError;  }  /**   * Get the error at the end of the integration.   * @return error at the end of the integration   */  public double getLastError() {    return lastError;  }  /**   * Get the time at the end of the integration.   * @return time at the end of the integration.   */  public double getLastTime() {    return lastTime;  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;/** * This class is used in the junit tests for the ODE integrators. * <p>This is the same as problem 1 except integration is done * backward in time</p> */class TestProblem5  extends TestProblem1 {  /**   * Simple constructor.   */  public TestProblem5() {    super();    setFinalConditions(2 * t0 - t1);  } }
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;import java.util.Random;import java.io.ByteArrayOutputStream;import java.io.ByteArrayInputStream;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.IOException;public class DormandPrince54StepInterpolatorTest  extends TestCase {  public DormandPrince54StepInterpolatorTest(String name) {    super(name);  }  public void testSerialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                    scalAbsoluteTolerance,                                                                    scalRelativeTolerance);    integ.setStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    oos.writeObject(integ.getStepHandler());    assertTrue(bos.size () > 119500);    assertTrue(bos.size () < 120500);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 7.0e-10);  }  public static Test suite() {    return new TestSuite(DormandPrince54StepInterpolatorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;import java.util.Random;import java.io.ByteArrayOutputStream;import java.io.ByteArrayInputStream;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.IOException;public class EulerStepInterpolatorTest  extends TestCase {  public EulerStepInterpolatorTest(String name) {    super(name);  }  public void testNoReset() {    double[]   y    =   { 0.0, 1.0, -2.0 };    double[][] yDot = { { 1.0, 2.0, -2.0 } };    EulerStepInterpolator interpolator = new EulerStepInterpolator();    interpolator.reinitialize(new DummyEquations(), y, yDot, true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    double[] result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);    }  }  public void testInterpolationAtBounds()    throws DerivativeException {    double   t0 = 0;    double[] y0 = {0.0, 1.0, -2.0};    double[] y = (double[]) y0.clone();    double[][] yDot = { new double[y0.length] };    EulerStepInterpolator interpolator = new EulerStepInterpolator();    interpolator.reinitialize(new DummyEquations(), y, yDot, true);    interpolator.storeTime(t0);    double dt = 1.0;    y[0] =  1.0;    y[1] =  3.0;    y[2] = -4.0;    yDot[0][0] = (y[0] - y0[0]) / dt;    yDot[0][1] = (y[1] - y0[1]) / dt;    yDot[0][2] = (y[2] - y0[2]) / dt;    interpolator.shift();    interpolator.storeTime(t0 + dt);    interpolator.setInterpolatedTime(interpolator.getPreviousTime());    double[] result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {      assertTrue(Math.abs(result[i] - y0[i]) < 1.0e-10);    }    interpolator.setInterpolatedTime(interpolator.getCurrentTime());    result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);    }  }  public void testInterpolationInside()    throws DerivativeException {    double[]   y    =   { 1.0, 3.0, -4.0 };    double[][] yDot = { { 1.0, 2.0, -2.0 } };    EulerStepInterpolator interpolator = new EulerStepInterpolator();    interpolator.reinitialize(new DummyEquations(), y, yDot, true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    interpolator.setInterpolatedTime(0.1);    double[] result = interpolator.getInterpolatedState();    assertTrue(Math.abs(result[0] - 0.1) < 1.0e-10);    assertTrue(Math.abs(result[1] - 1.2) < 1.0e-10);    assertTrue(Math.abs(result[2] + 2.2) < 1.0e-10);    interpolator.setInterpolatedTime(0.5);    result = interpolator.getInterpolatedState();    assertTrue(Math.abs(result[0] - 0.5) < 1.0e-10);    assertTrue(Math.abs(result[1] - 2.0) < 1.0e-10);    assertTrue(Math.abs(result[2] + 3.0) < 1.0e-10);  }  public void testSerialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    EulerIntegrator integ = new EulerIntegrator(step);    integ.setStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    oos.writeObject(integ.getStepHandler());    assertTrue(bos.size () > 82000);    assertTrue(bos.size () < 83000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 0.001);  }  private static class DummyEquations    implements FirstOrderDifferentialEquations {    public int getDimension() {      return 0;    }    public void computeDerivatives(double t, double[] y, double[] yDot) {    }  }  public static Test suite() {    return new TestSuite(EulerStepInterpolatorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;import org.spaceroots.mantissa.estimation.EstimationException;import org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator;import org.spaceroots.mantissa.fitting.PolynomialFitter;public class ClassicalRungeKuttaIntegratorTest  extends TestCase {  public ClassicalRungeKuttaIntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,                                                        0.0, new double[pb.getDimension()+10],                                                        1.0, new double[pb.getDimension()+10]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }    public void testNullIntervalCheck() {    try  {      TestProblem1 pb = new TestProblem1();      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,                                                        0.0, new double[pb.getDimension()],                                                        0.0, new double[pb.getDimension()]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }    public void testDecreasingSteps()    throws DerivativeException, IntegratorException  {          TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousError = Double.NaN;      for (int i = 4; i < 10; ++i) {        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();        double step = (pb.getFinalTime() - pb.getInitialTime())          * Math.pow(2.0, -i);        FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb);        integ.setStepHandler(handler);        SwitchingFunction[] functions = pb.getSwitchingFunctions();        for (int l = 0; l < functions.length; ++l) {          integ.addSwitchingFunction(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);        }        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        double error = handler.getMaximalError();        if (i > 4) {          assertTrue(error < Math.abs(previousError));        }        previousError = error;      }    }  }  public void testOrder()  throws EstimationException, DerivativeException,         IntegratorException {    PolynomialFitter fitter =      new PolynomialFitter(1, new LevenbergMarquardtEstimator());    TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      for (int i = 0; i < 10; ++i) {        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();        double step = (pb.getFinalTime() - pb.getInitialTime())          * Math.pow(2.0, -(i + 1));        FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb);        integ.setStepHandler(handler);        SwitchingFunction[] functions = pb.getSwitchingFunctions();        for (int l = 0; l < functions.length; ++l) {          integ.addSwitchingFunction(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);        }        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        fitter.addWeightedPair(1.0,                               Math.log(Math.abs(step)),                               Math.log(handler.getLastError()));      }      // this is an order 4 method      double[] coeffs = fitter.fit();      assertTrue(coeffs[1] > 3.2);      assertTrue(coeffs[1] < 4.8);    }  }  public void testSmallStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb);    integ.setStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() < 2.0e-13);    assertTrue(handler.getMaximalError() < 4.0e-12);  }  public void testBigStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb);    integ.setStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() > 0.0004);    assertTrue(handler.getMaximalError() > 0.005);  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    integ.setStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);  }  private static class KeplerHandler implements StepHandler {    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) {      double[] interpolatedY = interpolator.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }      if (isLast) {        // even with more than 1000 evaluations per period,        // RK4 is not able to integrate such an eccentric        // orbit with a good accuracy        assertTrue(maxError > 0.005);      }    }    private double maxError = 0;    private TestProblem3 pb;  }  public static Test suite() {    return new TestSuite(ClassicalRungeKuttaIntegratorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;import java.util.Random;import java.io.ByteArrayOutputStream;import java.io.ByteArrayInputStream;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.IOException;public class MidpointStepInterpolatorTest  extends TestCase {  public MidpointStepInterpolatorTest(String name) {    super(name);  }  public void testSerialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    MidpointIntegrator integ = new MidpointIntegrator(step);    integ.setStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    oos.writeObject(integ.getStepHandler());    assertTrue(bos.size () > 98000);    assertTrue(bos.size () < 99000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 1.0e-6);  }  public static Test suite() {    return new TestSuite(MidpointStepInterpolatorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;/** * This class is used as the base class of the problems that are * integrated during the junit tests for the ODE integrators. */abstract class TestProblemAbstract  implements FirstOrderDifferentialEquations, Cloneable {  /** Dimension of the problem. */  protected int n;  /** Number of functions calls. */  protected int calls;  /** Initial time */  protected double t0;  /** Initial state */  protected double[] y0;  /** Final time */  protected double t1;  /** Error scale */  protected double[] errorScale;  /**   * Simple constructor.   */  protected TestProblemAbstract() {    n          = 0;    calls      = 0;    t0         = 0;    y0         = null;    t1         = 0;    errorScale = null;  }  /**   * Copy constructor.   * @param problem problem to copy   */  protected TestProblemAbstract(TestProblemAbstract problem) {    n     = problem.n;    calls = problem.calls;    t0    = problem.t0;    if (problem.y0 == null) {      y0 = null;    } else {      y0 = (double[]) problem.y0.clone();    }    if (problem.errorScale == null) {      errorScale = null;    } else {      errorScale = (double[]) problem.errorScale.clone();    }    t1 = problem.t1;  }  /**   * Clone operation.   * @return a copy of the instance   */  public abstract Object clone();  /**   * Set the initial conditions   * @param t0 initial time   * @param y0 initial state vector   */  protected void setInitialConditions(double t0, double[] y0) {    calls     = 0;    n         = y0.length;    this.t0   = t0;    this.y0   = (double[]) y0.clone();    }  /**   * Set the final conditions.   * @param t1 final time   */  protected void setFinalConditions(double t1) {    this.t1 = t1;  }  /**   * Set the error scale   * @param errorScale error scale   */  protected void setErrorScale(double[] errorScale) {    this.errorScale = (double[]) errorScale.clone();   }  public int getDimension() {    return n;  }  /**   * Get the initial time.   * @return initial time   */  public double getInitialTime() {    return t0;  }  /**   * Get the initial state vector.   * @return initial state vector   */  public double[] getInitialState() {    return y0;  }  /**   * Get the final time.   * @return final time   */  public double getFinalTime() {    return t1;  }  /**   * Get the error scale.   * @return error scale   */  public double[] getErrorScale() {    return errorScale;  }  /**   * Get the switching functions.   * @return switching functions   */  public SwitchingFunction[] getSwitchingFunctions() {    return new SwitchingFunction[0];  }  /**   * Get the number of calls.   * @return nuber of calls   */  public int getCalls() {    return calls;  }  public void computeDerivatives(double t, double[] y, double[] yDot) {    ++calls;    doComputeDerivatives(t, y, yDot);  }  abstract public void doComputeDerivatives(double t, double[] y, double[] yDot);  /**   * Compute the theoretical state at the specified time.   * @param t time at which the state is required   * @return state vector at time t   */  abstract public double[] computeTheoreticalState(double t);}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;public class GraggBulirschStoerIntegratorTest  extends TestCase {  public GraggBulirschStoerIntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      GraggBulirschStoerIntegrator integrator =        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()+10],                           1.0, new double[pb.getDimension()+10]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testNullIntervalCheck() {    try  {      TestProblem1 pb = new TestProblem1();      GraggBulirschStoerIntegrator integrator =        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()],                           0.0, new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testMinStep()    throws DerivativeException, IntegratorException {    try {      TestProblem1 pb  = new TestProblem1();      double minStep   = 0.1 * (pb.getFinalTime() - pb.getInitialTime());      double maxStep   = pb.getFinalTime() - pb.getInitialTime();      double absTolerance = 1.0e-20;      double relTolerance = 1.0e-20;      FirstOrderIntegrator integ =        new GraggBulirschStoerIntegrator(minStep, maxStep,                                         absTolerance, relTolerance);      TestProblemHandler handler = new TestProblemHandler(pb);      integ.setStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testIncreasingTolerance()    throws DerivativeException, IntegratorException {    int previousCalls = Integer.MAX_VALUE;    for (int i = -12; i < -4; ++i) {      TestProblem1 pb     = new TestProblem1();      double minStep      = 0;      double maxStep      = pb.getFinalTime() - pb.getInitialTime();      double absTolerance = Math.pow(10.0, i);      double relTolerance = absTolerance;      FirstOrderIntegrator integ =        new GraggBulirschStoerIntegrator(minStep, maxStep,                                         absTolerance, relTolerance);      TestProblemHandler handler = new TestProblemHandler(pb);      integ.setStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      // the coefficients are only valid for this test      // and have been obtained from trial and error      // there is no general relation between local and global errors      double ratio =  handler.getMaximalError() / absTolerance;      assertTrue(ratio < 2.4);      assertTrue(ratio > 0.02);      int calls = pb.getCalls();      assertTrue(calls <= previousCalls);      previousCalls = calls;    }  }  public void testSwitchingFunctions()    throws DerivativeException, IntegratorException {    TestProblem4 pb = new TestProblem4();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-10;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,                                                                  scalAbsoluteTolerance,                                                                  scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb);    integ.setStepHandler(handler);    SwitchingFunction[] functions = pb.getSwitchingFunctions();    for (int l = 0; l < functions.length; ++l) {      integ.addSwitchingFunction(functions[l],                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);    }    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getMaximalError() < 5.0e-8);    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb = new TestProblem3(0.9);    double minStep        = 0;    double maxStep        = pb.getFinalTime() - pb.getInitialTime();    double absTolerance   = 1.0e-6;    double relTolerance   = 1.0e-6;    FirstOrderIntegrator integ =      new GraggBulirschStoerIntegrator(minStep, maxStep,                                       absTolerance, relTolerance);    integ.setStepHandler(new KeplerStepHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(pb.getCalls() < 2150);  }  public void testVariableSteps()    throws DerivativeException, IntegratorException {    final TestProblem3 pb = new TestProblem3(0.9);    double minStep        = 0;    double maxStep        = pb.getFinalTime() - pb.getInitialTime();    double absTolerance   = 1.0e-8;    double relTolerance   = 1.0e-8;    FirstOrderIntegrator integ =      new GraggBulirschStoerIntegrator(minStep, maxStep,                                       absTolerance, relTolerance);    integ.setStepHandler(new VariableStepHandler());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);  }  public void testUnstableDerivative()    throws DerivativeException, IntegratorException {    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);    FirstOrderIntegrator integ =      new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0);    integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12);    double[] y = { Double.NaN };    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);    assertEquals(8.0, y[0], 1.0e-12);  }  private static class KeplerStepHandler implements StepHandler {    public KeplerStepHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public boolean requiresDenseOutput() {      return true;    }    public void reset() {      nbSteps = 0;      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast)    throws DerivativeException {      ++nbSteps;      for (int a = 1; a < 100; ++a) {        double prev   = interpolator.getPreviousTime();        double curr   = interpolator.getCurrentTime();        double interp = ((100 - a) * prev + a * curr) / 100;        interpolator.setInterpolatedTime(interp);        double[] interpolatedY = interpolator.getInterpolatedState ();        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());        double dx = interpolatedY[0] - theoreticalY[0];        double dy = interpolatedY[1] - theoreticalY[1];        double error = dx * dx + dy * dy;        if (error > maxError) {          maxError = error;        }      }      if (isLast) {        assertTrue(maxError < 2.7e-6);        assertTrue(nbSteps < 80);      }    }    private int nbSteps;    private double maxError;    private TestProblem3 pb;  }  public static class VariableStepHandler implements StepHandler {    public VariableStepHandler() {      reset();    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      firstTime = true;      minStep = 0;      maxStep = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) {      double step = Math.abs(interpolator.getCurrentTime()                             - interpolator.getPreviousTime());      if (firstTime) {        minStep   = Math.abs(step);        maxStep   = minStep;        firstTime = false;      } else {        if (step < minStep) {          minStep = step;        }        if (step > maxStep) {          maxStep = step;        }      }      if (isLast) {        assertTrue(minStep < 8.2e-3);        assertTrue(maxStep > 1.7);      }    }    private boolean firstTime;    private double  minStep;    private double  maxStep;  }  public static Test suite() {    return new TestSuite(GraggBulirschStoerIntegratorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;import java.util.Random;import java.io.ByteArrayOutputStream;import java.io.ByteArrayInputStream;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.IOException;public class GraggBulirschStoerStepInterpolatorTest  extends TestCase {  public GraggBulirschStoerStepInterpolatorTest(String name) {    super(name);  }  public void testSerialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb  = new TestProblem3(0.9);    double minStep   = 0;    double maxStep   = pb.getFinalTime() - pb.getInitialTime();    double absTolerance = 1.0e-8;    double relTolerance = 1.0e-8;    GraggBulirschStoerIntegrator integ =      new GraggBulirschStoerIntegrator(minStep, maxStep,                                       absTolerance, relTolerance);    integ.setStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    oos.writeObject(integ.getStepHandler());    assertTrue(bos.size () > 34000);    assertTrue(bos.size () < 35000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 5.0e-11);  }  public static Test suite() {    return new TestSuite(GraggBulirschStoerStepInterpolatorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;import java.util.Random;public class ContinuousOutputModelTest  extends TestCase {  public ContinuousOutputModelTest(String name) {    super(name);    pb    = null;    integ = null;  }  public void testBoundaries()    throws DerivativeException, IntegratorException {    integ.setStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandler();    cm.setInterpolatedTime(2.0 * pb.getInitialTime() - pb.getFinalTime());    cm.setInterpolatedTime(2.0 * pb.getFinalTime() - pb.getInitialTime());    cm.setInterpolatedTime(0.5 * (pb.getFinalTime() + pb.getInitialTime()));  }  public void testRandomAccess()    throws DerivativeException, IntegratorException {    ContinuousOutputModel cm = new ContinuousOutputModel();    integ.setStepHandler(cm);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 1.0e-9);  }  public void checkValue(double value, double reference) {    assertTrue(Math.abs(value - reference) < 1.0e-10);  }  public static Test suite() {    return new TestSuite(ContinuousOutputModelTest.class);  }  public void setUp() {    pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    integ = new DormandPrince54Integrator(minStep, maxStep, 1.0e-8, 1.0e-8);  }  public void tearDown() {    pb    = null;    integ = null;  }  TestProblem3 pb;  FirstOrderIntegrator integ;}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;import java.util.Random;import java.io.ByteArrayOutputStream;import java.io.ByteArrayInputStream;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.IOException;public class GillStepInterpolatorTest  extends TestCase {  public GillStepInterpolatorTest(String name) {    super(name);  }  public void testSerialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    GillIntegrator integ = new GillIntegrator(step);    integ.setStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    oos.writeObject(integ.getStepHandler());    assertTrue(bos.size () > 700000);    assertTrue(bos.size () < 701000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 0.003);  }  public static Test suite() {    return new TestSuite(GillStepInterpolatorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;import java.util.Random;import java.io.ByteArrayOutputStream;import java.io.ByteArrayInputStream;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.IOException;public class ThreeEighthesStepInterpolatorTest  extends TestCase {  public ThreeEighthesStepInterpolatorTest(String name) {    super(name);  }  public void testSerialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);    integ.setStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    oos.writeObject(integ.getStepHandler());    assertTrue(bos.size () > 700000);    assertTrue(bos.size () < 701000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError > 0.005);  }  public static Test suite() {    return new TestSuite(ThreeEighthesStepInterpolatorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    y' = t^3 - t y * </pre> * with the initial condition y (0) = 0. The solution of this equation * is the following function : * <pre> *   y (t) = t^2 + 2 (ext (- t^2 / 2) - 1) * </pre> * </p> */class TestProblem2  extends TestProblemAbstract {  /** theoretical state */  private double[] y;  /**   * Simple constructor.   */  public TestProblem2() {    super();    double[] y0 = { 0.0 };    setInitialConditions(0.0, y0);    setFinalConditions(1.0);    double[] errorScale = { 1.0 };    setErrorScale(errorScale);    y = new double[y0.length];  }   /**   * Copy constructor.   * @param problem problem to copy   */  public TestProblem2(TestProblem2 problem) {    super(problem);    y = (double[]) problem.y.clone();  }  /**   * Clone operation.   * @return a copy of the instance   */  public Object clone() {    return new TestProblem2(this);  }  public void doComputeDerivatives(double t, double[] y, double[] yDot) {    // compute the derivatives    for (int i = 0; i < n; ++i)      yDot[i] = t * (t * t - y[i]);  }  public double[] computeTheoreticalState(double t) {    double t2 = t * t;    double c = t2 + 2 * (Math.exp (-0.5 * t2) - 1);    for (int i = 0; i < n; ++i) {      y[i] = c;    }    return y;  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;import org.spaceroots.mantissa.estimation.EstimationException;import org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator;import org.spaceroots.mantissa.fitting.PolynomialFitter;public class ThreeEighthesIntegratorTest  extends TestCase {  public ThreeEighthesIntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      new ThreeEighthesIntegrator(0.01).integrate(pb,                                                  0.0, new double[pb.getDimension()+10],                                                  1.0, new double[pb.getDimension()+10]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }    public void testDecreasingSteps()    throws DerivativeException, IntegratorException  {          TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {          double previousError = Double.NaN;      for (int i = 4; i < 10; ++i) {        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();        double step = (pb.getFinalTime() - pb.getInitialTime())          * Math.pow(2.0, -i);        FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb);        integ.setStepHandler(handler);        SwitchingFunction[] functions = pb.getSwitchingFunctions();        for (int l = 0; l < functions.length; ++l) {          integ.addSwitchingFunction(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);        }        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        double error = handler.getMaximalError();        if (i > 4) {          assertTrue(error < Math.abs(previousError));        }        previousError = error;      }    }  }  public void testOrder()  throws EstimationException, DerivativeException,         IntegratorException {    PolynomialFitter fitter =      new PolynomialFitter(1, new LevenbergMarquardtEstimator());    TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      for (int i = 0; i < 10; ++i) {        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();        double step = (pb.getFinalTime() - pb.getInitialTime())          * Math.pow(2.0, -(i + 1));        FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb);        integ.setStepHandler(handler);        SwitchingFunction[] functions = pb.getSwitchingFunctions();        for (int l = 0; l < functions.length; ++l) {          integ.addSwitchingFunction(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);        }        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        fitter.addWeightedPair(1.0,                               Math.log(Math.abs(step)),                               Math.log(handler.getLastError()));      }      // this is an order 4 method      double[] coeffs = fitter.fit();      assertTrue(coeffs[1] > 3.2);      assertTrue(coeffs[1] < 4.8);    }  }  public void testSmallStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb);    integ.setStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() < 2.0e-13);    assertTrue(handler.getMaximalError() < 4.0e-12);  }  public void testBigStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb);    integ.setStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() > 0.0004);    assertTrue(handler.getMaximalError() > 0.005);  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);    integ.setStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);  }  private static class KeplerHandler implements StepHandler {    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      maxError = 0;    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) {      double[] interpolatedY = interpolator.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }      if (isLast) {        // even with more than 1000 evaluations per period,        // RK4 is not able to integrate such an eccentric        // orbit with a good accuracy        assertTrue(maxError > 0.005);      }    }    private TestProblem3 pb;    private double maxError = 0;  }  public static Test suite() {    return new TestSuite(ThreeEighthesIntegratorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;import java.util.Random;import java.io.ByteArrayOutputStream;import java.io.ByteArrayInputStream;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.IOException;public class DormandPrince853StepInterpolatorTest  extends TestCase {  public DormandPrince853StepInterpolatorTest(String name) {    super(name);  }  public void testSerialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                      scalAbsoluteTolerance,                                                                      scalRelativeTolerance);    integ.setStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    oos.writeObject(integ.getStepHandler());    assertTrue(bos.size () > 86000);    assertTrue(bos.size () < 87000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 2.4e-10);  }  public static Test suite() {    return new TestSuite(DormandPrince853StepInterpolatorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;public class FirstOrderConverterTest  extends TestCase {  public FirstOrderConverterTest(String name) {    super(name);  }  public void testDoubleDimension() {    for (int i = 1; i < 10; ++i) {      SecondOrderDifferentialEquations eqn2 = new Equations(i, 0.2);      FirstOrderConverter eqn1 = new FirstOrderConverter(eqn2);      assertTrue(eqn1.getDimension() == (2 * eqn2.getDimension()));    }  }    public void testDecreasingSteps()    throws DerivativeException, IntegratorException {          double previousError = Double.NaN;    for (int i = 0; i < 10; ++i) {      double step  = Math.pow(2.0, -(i + 1));      double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, step)                   - Math.sin(4.0);      if (i > 0) {        assertTrue(Math.abs(error) < Math.abs(previousError));      }      previousError = error;          }  }  public void testSmallStep()    throws DerivativeException, IntegratorException {    double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 1.0e-4)                   - Math.sin(4.0);    assertTrue(Math.abs(error) < 1.0e-10);  }  public void testBigStep()    throws DerivativeException, IntegratorException {    double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 0.5)                   - Math.sin(4.0);    assertTrue(Math.abs(error) > 0.1);  }    public static Test suite() {    return new TestSuite(FirstOrderConverterTest.class);  }  private static class Equations    implements SecondOrderDifferentialEquations {            private int n;      private double omega2;            public Equations(int n, double omega) {        this.n = n;        omega2 = omega * omega;      }            public int getDimension() {        return n;      }            public void computeSecondDerivatives(double t, double[] y, double[] yDot,                                           double[] yDDot) {        for (int i = 0; i < n; ++i) {          yDDot[i] = -omega2 * y[i];        }    }        }  private double integrateWithSpecifiedStep(double omega,                                            double t0, double t,                                            double step)  throws DerivativeException, IntegratorException {    double[] y0 = new double[2];    y0[0] = Math.sin(omega * t0);    y0[1] = omega * Math.cos(omega * t0);    ClassicalRungeKuttaIntegrator i = new ClassicalRungeKuttaIntegrator(step);    double[] y = new double[2];    i.integrate(new FirstOrderConverter(new Equations(1, omega)), t0, y0, t, y);    return y[0];  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;public class StepNormalizerTest  extends TestCase {  public StepNormalizerTest(String name) {    super(name);    pb    = null;    integ = null;  }  public void testBoundaries()    throws DerivativeException, IntegratorException {    double range = pb.getFinalTime() - pb.getInitialTime();    setLastSeen(false);    integ.setStepHandler(new StepNormalizer(range / 10.0,                                       new FixedStepHandler() {                                         private boolean firstCall = true;                                         public void handleStep(double t,                                                                double[] y,                                                                boolean isLast) {                                           if (firstCall) {                                             checkValue(t, pb.getInitialTime());                                             firstCall = false;                                           }                                           if (isLast) {                                             setLastSeen(true);                                             checkValue(t, pb.getFinalTime());                                           }                                         }                                       }));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(lastSeen);  }  public void testBeforeEnd()    throws DerivativeException, IntegratorException {    final double range = pb.getFinalTime() - pb.getInitialTime();    setLastSeen(false);    integ.setStepHandler(new StepNormalizer(range / 10.5,                                       new FixedStepHandler() {                                         public void handleStep(double t,                                                                double[] y,                                                                boolean isLast) {                                           if (isLast) {                                             setLastSeen(true);                                             checkValue(t,                                                        pb.getFinalTime() - range / 21.0);                                           }                                         }                                       }));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(lastSeen);  }  public void checkValue(double value, double reference) {    assertTrue(Math.abs(value - reference) < 1.0e-10);  }  public void setLastSeen(boolean lastSeen) {    this.lastSeen = lastSeen;  }  public static Test suite() {    return new TestSuite(StepNormalizerTest.class);  }  public void setUp() {    pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    integ = new DormandPrince54Integrator(minStep, maxStep, 10.e-8, 1.0e-8);    lastSeen = false;  }  public void tearDown() {    pb    = null;    integ = null;  }  TestProblem3 pb;  FirstOrderIntegrator integ;  boolean lastSeen;}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;import org.spaceroots.mantissa.estimation.EstimationException;import org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator;import org.spaceroots.mantissa.fitting.PolynomialFitter;public class EulerIntegratorTest  extends TestCase {  public EulerIntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      new EulerIntegrator(0.01).integrate(pb,                                          0.0, new double[pb.getDimension()+10],                                          1.0, new double[pb.getDimension()+10]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }    public void testDecreasingSteps()    throws DerivativeException, IntegratorException {    TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousError = Double.NaN;      for (int i = 4; i < 10; ++i) {        TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();        double step = (pb.getFinalTime() - pb.getInitialTime())          * Math.pow(2.0, -i);        FirstOrderIntegrator integ = new EulerIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb);        integ.setStepHandler(handler);        SwitchingFunction[] functions = pb.getSwitchingFunctions();        for (int l = 0; l < functions.length; ++l) {          integ.addSwitchingFunction(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);        }        integ.integrate(pb,                        pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        double error = handler.getMaximalError();        if (i > 4) {          assertTrue(error < Math.abs(previousError));        }        previousError = error;            }    }  }  public void testOrder()  throws EstimationException, DerivativeException,         IntegratorException {    PolynomialFitter fitter =      new PolynomialFitter(1, new LevenbergMarquardtEstimator());    TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      for (int i = 0; i < 10; ++i) {        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();        double step  = (pb.getFinalTime() - pb.getInitialTime())          * Math.pow(2.0, -(i + 1));        FirstOrderIntegrator integ = new EulerIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb);        integ.setStepHandler(handler);        SwitchingFunction[] functions = pb.getSwitchingFunctions();        for (int l = 0; l < functions.length; ++l) {          integ.addSwitchingFunction(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);        }        integ.integrate(pb,                        pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        fitter.addWeightedPair(1.0,                               Math.log(Math.abs(step)),                               Math.log(handler.getLastError()));      }      // this is an order 1 method      double[] coeffs = fitter.fit();      assertTrue(coeffs[1] > 0.2);      assertTrue(coeffs[1] < 1.8);    }  }  public void testSmallStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb  = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new EulerIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb);    integ.setStepHandler(handler);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);   assertTrue(handler.getLastError() < 2.0e-4);   assertTrue(handler.getMaximalError() < 1.0e-3);  }  public void testBigStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb  = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new EulerIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb);    integ.setStepHandler(handler);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() > 0.01);    assertTrue(handler.getMaximalError() > 0.2);  }    public static Test suite() {    return new TestSuite(EulerIntegratorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    x'' = -x * </pre> * And when x decreases down to 0, the state should be changed as follows : * <pre> *   x' -> -x' * </pre> * The theoretical solution of this problem is x = |sin(t+a)| * </p> */class TestProblem4  extends TestProblemAbstract {  /** Time offset. */  private double a;  /** theoretical state */  private double[] y;  /** Simple constructor. */  public TestProblem4() {    super();    a = 1.2;    double[] y0 = { Math.sin(a), Math.cos(a) };    setInitialConditions(0.0, y0);    setFinalConditions(15);    double[] errorScale = { 1.0, 0.0 };    setErrorScale(errorScale);    y = new double[y0.length];  }   /**   * Copy constructor.   * @param problem problem to copy   */  public TestProblem4(TestProblem4 problem) {    super(problem);    a = problem.a;    y = (double[]) problem.y.clone();  }  /**   * Clone operation.   * @return a copy of the instance   */  public Object clone() {    return new TestProblem4(this);  }  public SwitchingFunction[] getSwitchingFunctions() {    return new SwitchingFunction[] { new Bounce(), new Stop() };  }  public void doComputeDerivatives(double t, double[] y, double[] yDot) {    yDot[0] =  y[1];    yDot[1] = -y[0];  }  public double[] computeTheoreticalState(double t) {    double sin = Math.sin(t + a);    double cos = Math.cos(t + a);    y[0] = Math.abs(sin);    y[1] = (sin >= 0) ? cos : -cos;    return y;  }  private static class Bounce implements SwitchingFunction {    private static final long serialVersionUID = 1356097180027801200L;    private int sign;    public Bounce() {      sign = +1;    }    public double g(double t, double[] y) {      return sign * y[0];    }    public int eventOccurred(double t, double[] y) {      // this sign change is needed because the state will be reset soon      sign = -sign;      return SwitchingFunction.RESET_STATE;    }      public void resetState(double t, double[] y) {      y[1] = -y[1];    }  }  private static class Stop implements SwitchingFunction {    private static final long serialVersionUID = 6975050568227951931L;    public Stop() {    }    public double g(double t, double[] y) {      return t - 12.0;    }    public int eventOccurred(double t, double[] y) {      return SwitchingFunction.STOP;    }      public void resetState(double t, double[] y) {    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    y1'' = -y1/r^3  y1 (0) = 1-e  y1' (0) = 0 *    y2'' = -y2/r^3  y2 (0) = 0    y2' (0) =sqrt((1+e)/(1-e)) *    r = sqrt (y1^2 + y2^2), e = 0.9 * </pre> * This is a two-body problem in the plane which can be solved by * Kepler's equation * <pre> *   y1 (t) = ... * </pre> * </p> */class TestProblem3  extends TestProblemAbstract {  /** Eccentricity */  double e;  /** theoretical state */  private double[] y;  /**   * Simple constructor.   * @param e eccentricity   */  public TestProblem3(double e) {    super();    this.e = e;    double[] y0 = { 1 - e, 0, 0, Math.sqrt((1+e)/(1-e)) };    setInitialConditions(0.0, y0);    setFinalConditions(20.0);    double[] errorScale = { 1.0, 1.0, 1.0, 1.0 };    setErrorScale(errorScale);    y = new double[y0.length];  }   /**   * Simple constructor.   */  public TestProblem3() {    this(0.1);  }   /**   * Copy constructor.   * @param problem problem to copy   */  public TestProblem3(TestProblem3 problem) {    super(problem);    e = problem.e;    y = (double[]) problem.y.clone();  }  /**   * Clone operation.   * @return a copy of the instance   */  public Object clone() {    return new TestProblem3(this);  }  public void doComputeDerivatives(double t, double[] y, double[] yDot) {    // current radius    double r2 = y[0] * y[0] + y[1] * y[1];    double invR3 = 1 / (r2 * Math.sqrt(r2));    // compute the derivatives    yDot[0] = y[2];    yDot[1] = y[3];    yDot[2] = -invR3  * y[0];    yDot[3] = -invR3  * y[1];  }  public double[] computeTheoreticalState(double t) {    // solve Kepler's equation    double E = t;    double d = 0;    double corr = 0;    do {      double f2  = e * Math.sin(E);      double f0  = d - f2;      double f1  = 1 - e * Math.cos(E);      double f12 = f1 + f1;      corr  = f0 * f12 / (f1 * f12 - f0 * f2);      d -= corr;      E = t + d;    } while (Math.abs(corr) > 1.0e-12);    double cosE = Math.cos(E);    double sinE = Math.sin(E);    y[0] = cosE - e;    y[1] = Math.sqrt(1 - e * e) * sinE;    y[2] = -sinE / (1 - e * cosE);    y[3] = Math.sqrt(1 - e * e) * cosE / (1 - e * cosE);    return y;  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;import org.spaceroots.mantissa.estimation.EstimationException;import org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator;import org.spaceroots.mantissa.fitting.PolynomialFitter;public class GillIntegratorTest  extends TestCase {  public GillIntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      new GillIntegrator(0.01).integrate(pb,                                         0.0, new double[pb.getDimension()+10],                                         1.0, new double[pb.getDimension()+10]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }    public void testDecreasingSteps()    throws DerivativeException, IntegratorException  {          TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousError = Double.NaN;      for (int i = 5; i < 10; ++i) {        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();        double step = (pb.getFinalTime() - pb.getInitialTime())          * Math.pow(2.0, -i);        FirstOrderIntegrator integ = new GillIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb);        integ.setStepHandler(handler);        SwitchingFunction[] functions = pb.getSwitchingFunctions();        for (int l = 0; l < functions.length; ++l) {          integ.addSwitchingFunction(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);        }        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        double error = handler.getMaximalError();        if (i > 5) {          assertTrue(error < Math.abs(previousError));        }        previousError = error;      }    }  }  public void testOrder()  throws EstimationException, DerivativeException,         IntegratorException {    PolynomialFitter fitter =      new PolynomialFitter(1, new LevenbergMarquardtEstimator());    TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {          for (int i = 0; i < 10; ++i) {        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();        double step = (pb.getFinalTime() - pb.getInitialTime())          * Math.pow(2.0, -(i + 1));        FirstOrderIntegrator integ = new GillIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb);        integ.setStepHandler(handler);        SwitchingFunction[] functions = pb.getSwitchingFunctions();        for (int l = 0; l < functions.length; ++l) {          integ.addSwitchingFunction(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);        }        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        fitter.addWeightedPair(1.0,                               Math.log(Math.abs(step)),                               Math.log(handler.getLastError()));      }      // this is an order 4 method      double[] coeffs = fitter.fit();      assertTrue(coeffs[1] > 3.2);      assertTrue(coeffs[1] < 4.8);    }  }  public void testSmallStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new GillIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb);    integ.setStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() < 2.0e-13);    assertTrue(handler.getMaximalError() < 4.0e-12);  }  public void testBigStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new GillIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb);    integ.setStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() > 0.0004);    assertTrue(handler.getMaximalError() > 0.005);  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    FirstOrderIntegrator integ = new GillIntegrator(step);    integ.setStepHandler(new KeplerStepHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);  }  public void testUnstableDerivative()  throws DerivativeException, IntegratorException {    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);    FirstOrderIntegrator integ = new GillIntegrator(0.3);    integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12);    double[] y = { Double.NaN };    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);    assertEquals(8.0, y[0], 1.0e-12);  }  private static class KeplerStepHandler implements StepHandler {    public KeplerStepHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) {      double[] interpolatedY = interpolator.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }      if (isLast) {        // even with more than 1000 evaluations per period,        // RK4 is not able to integrate such an eccentric        // orbit with a good accuracy        assertTrue(maxError > 0.001);      }    }    private double maxError;    private TestProblem3 pb;  }  public static Test suite() {    return new TestSuite(GillIntegratorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;import junit.framework.*;import java.util.Random;import java.io.ByteArrayOutputStream;import java.io.ByteArrayInputStream;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.IOException;public class HighamHall54StepInterpolatorTest  extends TestCase {  public HighamHall54StepInterpolatorTest(String name) {    super(name);  }  public void testSerialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);    integ.setStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    oos.writeObject(integ.getStepHandler());    assertTrue(bos.size () > 158000);    assertTrue(bos.size () < 159000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 1.6e-10);  }  public static Test suite() {    return new TestSuite(HighamHall54StepInterpolatorTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.ode;/** * This class is used in the junit tests for the ODE integrators. */class TestProblemFactory {  /** Problems pool. */  private static TestProblemAbstract[] pool = {    new TestProblem1(),    new TestProblem2(),    new TestProblem3(),    new TestProblem4(),    new TestProblem5()  };  /**   * Private constructor.   * This is a utility class, so there are no instance at all.   */  private TestProblemFactory() {  }  /**   * Get the problems.   * @return array of problems to solve   */  public static TestProblemAbstract[] getProblems() {    return pool;  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.random;import junit.framework.*;public class ScalarSampleStatisticsTest  extends TestCase {  public ScalarSampleStatisticsTest(String name) {    super(name);    points = null;  }  public void testBasicStats() {    ScalarSampleStatistics sample = new ScalarSampleStatistics();    for (int i = 0; i < points.length; ++i) {      sample.add(points[i]);    }    assertEquals(points.length, sample.size());    assertEquals(-5.0, sample.getMin(), 1.0e-12);    assertEquals(10.4, sample.getMax(), 1.0e-12);    assertEquals( 3.0, sample.getMean(), 1.0e-12);    assertEquals( 3.920034013457876, sample.getStandardDeviation(),                  1.0e-12);  }  public void testAddSample() {    ScalarSampleStatistics all  = new ScalarSampleStatistics();    ScalarSampleStatistics even = new ScalarSampleStatistics();    ScalarSampleStatistics odd  = new ScalarSampleStatistics();    for (int i = 0; i < points.length; ++i) {      all.add(points[i]);      if (i % 2 == 0) {        even.add(points[i]);      } else {        odd.add(points[i]);      }    }    even.add(odd);    assertEquals(all.size(), even.size());    assertEquals(all.getMin(), even.getMin(), 1.0e-12);    assertEquals(all.getMax(), even.getMax(), 1.0e-12);    assertEquals(all.getMean(), even.getMean(), 1.0e-12);    assertEquals(all.getStandardDeviation(), even.getStandardDeviation(),                 1.0e-12);  }  public void testAddArray() {    ScalarSampleStatistics loop   = new ScalarSampleStatistics();    ScalarSampleStatistics direct = new ScalarSampleStatistics();    for (int i = 0; i < points.length; ++i) {      loop.add(points[i]);    }    direct.add(points);    assertEquals(loop.size(), direct.size());    assertEquals(loop.getMin(), direct.getMin(), 1.0e-12);    assertEquals(loop.getMax(), direct.getMax(), 1.0e-12);    assertEquals(loop.getMean(), direct.getMean(), 1.0e-12);    assertEquals(loop.getStandardDeviation(), direct.getStandardDeviation(),                 1.0e-12);  }  public void setUp() {    points = new double[] {1.0, 4.2, -5, 4.0, 2.9, 10.4, 0.0, 4.1, 4.2, 4.2};  }  public void tearDown() {    points = null;  }  public static Test suite() {    return new TestSuite(ScalarSampleStatisticsTest.class);  }  private double[] points;}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.optimization;import junit.framework.*;public class MultiDirectionalTest  extends TestCase {  public MultiDirectionalTest(String name) {    super(name);  }  public void testRosenbrock()    throws CostException, NoConvergenceException {    CostFunction rosenbrock =      new CostFunction() {        public double cost(double[] x) {          ++count;          double a = x[1] - x[0] * x[0];          double b = 1.0 - x[0];          return 100 * a * a + b * b;        }      };    count = 0;    PointCostPair optimum =      new MultiDirectional().minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),                                       new double[] { -1.2,  1.0 },                                       new double[] {  3.5, -2.3 });    assertTrue(count > 60);    assertTrue(optimum.cost > 0.02);  }  public void testPowell()    throws CostException, NoConvergenceException {    CostFunction powell =      new CostFunction() {        public double cost(double[] x) {          ++count;          double a = x[0] + 10 * x[1];          double b = x[2] - x[3];          double c = x[1] - 2 * x[2];          double d = x[0] - x[3];          return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;        }      };    count = 0;    PointCostPair optimum =      new MultiDirectional().minimizes(powell, 1000, new ValueChecker(1.0e-3),                                       new double[] {  3.0, -1.0, 0.0, 1.0 },                                       new double[] {  4.0,  0.0, 1.0, 2.0 });    assertTrue(count > 850);    assertTrue(optimum.cost > 0.015);  }  private static class ValueChecker implements ConvergenceChecker {    public ValueChecker(double threshold) {      this.threshold = threshold;    }    public boolean converged(PointCostPair[] simplex) {      PointCostPair smallest = simplex[0];      PointCostPair largest  = simplex[simplex.length - 1];      return (largest.cost - smallest.cost) < threshold;    }    private double threshold;  };  public static Test suite() {    return new TestSuite(MultiDirectionalTest.class);  }  private int count;}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.optimization;import junit.framework.*;public class NelderMeadTest  extends TestCase {  public NelderMeadTest(String name) {    super(name);  }  public void testRosenbrock()    throws CostException, NoConvergenceException {    CostFunction rosenbrock =      new CostFunction() {        public double cost(double[] x) {          ++count;          double a = x[1] - x[0] * x[0];          double b = 1.0 - x[0];          return 100 * a * a + b * b;        }      };    count = 0;    PointCostPair optimum =      new NelderMead().minimizes(rosenbrock, 100, new ValueChecker(1.0e-3),                                 new double[] { -1.2,  1.0 },                                 new double[] {  3.5, -2.3 });    assertTrue(count < 50);    assertEquals(0.0, optimum.cost, 6.0e-4);    assertEquals(1.0, optimum.point[0], 0.05);    assertEquals(1.0, optimum.point[1], 0.05);  }  public void testPowell()    throws CostException, NoConvergenceException {    CostFunction powell =      new CostFunction() {        public double cost(double[] x) {          ++count;          double a = x[0] + 10 * x[1];          double b = x[2] - x[3];          double c = x[1] - 2 * x[2];          double d = x[0] - x[3];          return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;        }      };    count = 0;    PointCostPair optimum =      new NelderMead().minimizes(powell, 200, new ValueChecker(1.0e-3),                                 new double[] {  3.0, -1.0, 0.0, 1.0 },                                 new double[] {  4.0,  0.0, 1.0, 2.0 });    assertTrue(count < 150);    assertEquals(0.0, optimum.cost, 6.0e-4);    assertEquals(0.0, optimum.point[0], 0.07);    assertEquals(0.0, optimum.point[1], 0.07);    assertEquals(0.0, optimum.point[2], 0.07);    assertEquals(0.0, optimum.point[3], 0.07);  }  private static class ValueChecker implements ConvergenceChecker {    public ValueChecker(double threshold) {      this.threshold = threshold;    }    public boolean converged(PointCostPair[] simplex) {      PointCostPair smallest = simplex[0];      PointCostPair largest  = simplex[simplex.length - 1];      return (largest.cost - smallest.cost) < threshold;    }    private double threshold;  };  public static Test suite() {    return new TestSuite(NelderMeadTest.class);  }  private int count;}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.algebra;import junit.framework.*;public class LaguerreTest  extends TestCase {  public LaguerreTest(String name) {    super(name);  }  public void testOne() {    assertTrue(new Laguerre().isOne());  }  public void testFirstPolynomials() {    checkLaguerre(new Laguerre(3), 6l, "6 - 18 x + 9 x^2 - x^3");    checkLaguerre(new Laguerre(2), 2l, "2 - 4 x + x^2");    checkLaguerre(new Laguerre(1), 1l, "1 - x");    checkLaguerre(new Laguerre(0), 1l, "1");    checkLaguerre(new Laguerre(7), 5040l,                  "5040 - 35280 x + 52920 x^2 - 29400 x^3"                  + " + 7350 x^4 - 882 x^5 + 49 x^6 - x^7");    checkLaguerre(new Laguerre(6),  720l,                  "720 - 4320 x + 5400 x^2 - 2400 x^3 + 450 x^4"                  + " - 36 x^5 + x^6");    checkLaguerre(new Laguerre(5),  120l,                  "120 - 600 x + 600 x^2 - 200 x^3 + 25 x^4 - x^5");    checkLaguerre(new Laguerre(4),   24l,                  "24 - 96 x + 72 x^2 - 16 x^3 + x^4");  }  public void testDifferentials() {    for (int k = 0; k < 12; ++k) {      Polynomial.Rational Lk0 = new Laguerre(k);      Polynomial.Rational Lk1 = (Polynomial.Rational) Lk0.getDerivative();      Polynomial.Rational Lk2 = (Polynomial.Rational) Lk1.getDerivative();      Polynomial.Rational g0 = new Polynomial.Rational(k);      Polynomial.Rational g1 = new Polynomial.Rational(-1l, 1l);      Polynomial.Rational g2 = new Polynomial.Rational(1l, 0l);      Polynomial.Rational Lk0g0 = Lk0.multiply(g0);      Polynomial.Rational Lk1g1 = Lk1.multiply(g1);      Polynomial.Rational Lk2g2 = Lk2.multiply(g2);      Polynomial.Rational d = Lk0g0.add(Lk1g1.add(Lk2g2));      assertTrue(d.isZero());    }  }  public void checkLaguerre(Laguerre p, long denominator, String reference) {    assertTrue(p.multiply(denominator).toString().equals(reference));  }  public static Test suite() {    return new TestSuite(LaguerreTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.algebra;import junit.framework.*;public class PolynomialFractionTest  extends TestCase {  public PolynomialFractionTest(String name) {    super(name);  }  public void testNullDenominator() {    try {      new PolynomialFraction(1l, 0l);      fail("an exception should have been thrown");    } catch (ArithmeticException e) {    } catch (Exception e) {      fail("wrong exception caught");    }  }  public void testToString() {    checkValue(new PolynomialFraction(1l, 2l),  "1/2");    checkValue(new PolynomialFraction(-1l, 2l), "-1/2");    checkValue(new PolynomialFraction(1l, -2l), "-1/2");    checkValue(new PolynomialFraction(-1l, -2l), "1/2");    checkValue(new PolynomialFraction(0l, 500l), "0");    checkValue(new PolynomialFraction(-12l), "-12");    checkValue(new PolynomialFraction(12l), "12");  }  public void testSimplification() {    checkValue(new PolynomialFraction(2l, 4l), "1/2");    checkValue(new PolynomialFraction(307692l, 999999l), "4/13");    checkValue(new PolynomialFraction(999999l, 307692l), "13/4");  }  public void testInvert() {    PolynomialFraction f = new PolynomialFraction(2l, 4l);    f= f.invert();    checkValue(f, "2");    f = f.invert();    checkValue(f, "1/2");    f = new PolynomialFraction(120l);    f = f.invert();    checkValue(f, "1/120");    f = new PolynomialFraction(0l, 4l);    try {      f = f.invert();      fail("an exception should have been thrown");    } catch (ArithmeticException e) {    } catch (Exception e) {      fail("wrong exception caught");    }    f = new PolynomialFraction(307692l, 999999l);    PolynomialFraction fInverse = f.invert();    checkValue(fInverse, "13/4");    checkValue(f, "4/13");  }  public void testAddition() {    PolynomialFraction f1 = new PolynomialFraction(4l, 6l);    f1 = f1.add(f1);    checkValue(f1, "4/3");    checkValue(new PolynomialFraction(17l, 3l).add(new PolynomialFraction(-17l, 3l)),               "0");    checkValue(new PolynomialFraction(2l, 3l).add(new PolynomialFraction(3l, 4l)),               "17/12");    checkValue(new PolynomialFraction(1l, 6l).add(new PolynomialFraction(2l, 6l)),               "1/2");    checkValue(new PolynomialFraction(4l, 5l).add(new PolynomialFraction(-3l, 4l)),               "1/20");    checkValue(new PolynomialFraction(-3l, 4l).add(new PolynomialFraction(4l, 5l)),               "1/20");  }  public void testSubtraction() {    PolynomialFraction f1 = new PolynomialFraction(4l, 6l);    checkValue(f1.subtract(f1), "0");    checkValue(new PolynomialFraction(7l, 3l).subtract(new PolynomialFraction(-7l, 3l)),               "14/3");    checkValue(new PolynomialFraction(3l, 4l).subtract(new PolynomialFraction(2l, 3l)),               "1/12");    checkValue(new PolynomialFraction(3l, 4l).subtract(new PolynomialFraction(-2l, 3l)),               "17/12");    checkValue(new PolynomialFraction(-3l, 4l).subtract(new PolynomialFraction(2l, 3l)),               "-17/12");    checkValue(new PolynomialFraction(-3l, 4l).subtract(new PolynomialFraction(-2l, 3l)),               "-1/12");    checkValue(new PolynomialFraction(2l, 3l).subtract(new PolynomialFraction(3l, 4l)),               "-1/12");    checkValue(new PolynomialFraction(-2l, 3l).subtract(new PolynomialFraction(3l, 4l)),               "-17/12");    checkValue(new PolynomialFraction(2l, 3l).subtract(new PolynomialFraction(-3l, 4l)),               "17/12");    checkValue(new PolynomialFraction(-2l, 3l).subtract(new PolynomialFraction(-3l, 4l)),               "1/12");    checkValue(new PolynomialFraction(1l, 6l).subtract(new PolynomialFraction(2l, 6l)),               "-1/6");    checkValue(new PolynomialFraction(1l, 2l).subtract(new PolynomialFraction(1l, 6l)),               "1/3");  }  public void testMultiplication() {    PolynomialFraction f = new PolynomialFraction(2l, 3l);    checkValue(f.multiply(new PolynomialFraction(9l,4l)), "3/2");    checkValue(new PolynomialFraction(1l, 2l).multiply(new PolynomialFraction(0l)),               "0");    checkValue(new PolynomialFraction(4l, 15l).multiply(new PolynomialFraction(-5l, 2l)),               "-2/3");    checkValue(new PolynomialFraction(-4l, 15l).multiply(new PolynomialFraction(5l, 2l)),               "-2/3");    checkValue(new PolynomialFraction(4l, 15l).multiply(new PolynomialFraction(5l, 2l)),               "2/3");    checkValue(new PolynomialFraction(-4l, 15l).multiply(new PolynomialFraction(-5l, 2l)),               "2/3");  }  public void testDivision() {    PolynomialFraction f = new PolynomialFraction(2l, 3l);    ;    checkValue(f.divide(new PolynomialFraction(4l,9l)), "3/2");    try {      new PolynomialFraction(1l, 2l).divide(new PolynomialFraction(0l));      fail("an exception should have been thrown");    } catch (ArithmeticException e) {    } catch (Exception e) {      fail("wrong exception caught");    }    checkValue(new PolynomialFraction(4l, 15l).divide(new PolynomialFraction(-2l, 5l)),               "-2/3");    checkValue(new PolynomialFraction(-4l, 15l).divide(new PolynomialFraction(2l, 5l)),               "-2/3");    checkValue(new PolynomialFraction(4l, 15l).divide(new PolynomialFraction(2l, 5l)),               "2/3");    checkValue(new PolynomialFraction(-4l, 15l).divide(new PolynomialFraction(-2l, 5l)),               "2/3");  }  public void testEuclidianDivision() {    checkValue(new PolynomialFraction(new Polynomial.Rational(1l, 0l, -1l),                                      new Polynomial.Rational(2l, 2l)),               "-1/2 + 1/2 x");    checkValue(new PolynomialFraction(new Polynomial.Rational(1l, 3l, 2l),                                      new Polynomial.Rational(2l, 10l, 12l)),               "(1 + x)/(6 + 2 x)");  }  private void checkValue(PolynomialFraction f, String reference) {    assertTrue(f.toString().equals(reference));  }  public static Test suite() {    return new TestSuite(PolynomialFractionTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.algebra;import java.math.BigInteger;import junit.framework.*;public class PolynomialRationalTest  extends TestCase {  public PolynomialRationalTest(String name) {    super(name);  }  public void testZero() {    assertTrue(new Polynomial.Rational().isZero());  }  public void testConstructors() {    Polynomial.Rational p = new Polynomial.Rational(1l, 3l, -5l);    RationalNumber[]  a = p.getCoefficients();    assertEquals(a.length, 3);    assertEquals(new RationalNumber(-5l), a[0]);    assertEquals(new RationalNumber(3l), a[1]);    assertEquals(new RationalNumber(1l), a[2]);    assertEquals(2, p.getDegree());    assertEquals(1, new Polynomial.Rational(0l, 3l, 5l).getDegree());    assertEquals(0, new Polynomial.Rational(0l, 0l, 5l).getDegree());    assertEquals(0, new Polynomial.Rational(0l, 0l, 0l).getDegree());    assertEquals(1, new Polynomial.Rational(3l, 5l).getDegree());    assertEquals(0, new Polynomial.Rational(0l, 5l).getDegree());    assertEquals(0, new Polynomial.Rational(0l, 0l).getDegree());    assertEquals(0, new Polynomial.Rational(5l).getDegree());    assertEquals(0, new Polynomial.Rational(0l).getDegree());  }  public void testString() {    Polynomial.Rational p = new Polynomial.Rational(1l, 3l, -5l);    checkPolynomial(p, "-5 + 3 x + x^2");    checkPolynomial(new Polynomial.Rational(3l, -2l, 0l), "-2 x + 3 x^2");    checkPolynomial(new Polynomial.Rational(3l, -2l, 1l), "1 - 2 x + 3 x^2");    checkPolynomial(new Polynomial.Rational(3l,  2l, 0l), "2 x + 3 x^2");    checkPolynomial(new Polynomial.Rational(3l,  2l, 1l), "1 + 2 x + 3 x^2");    checkPolynomial(new Polynomial.Rational(3l,  0l, 1l), "1 + 3 x^2");    checkPolynomial(new Polynomial.Rational(0l), "0");  }  public void testAddition() {    Polynomial.Rational p1 = new Polynomial.Rational(1l, -2l);    Polynomial.Rational p2 = new Polynomial.Rational(0l, -1l, 2l);    assertTrue(p1.add(p2).isZero());    p2 = p1.add(p1);    checkPolynomial(p2, "-4 + 2 x");    p1 = new Polynomial.Rational(2l, -4l, 1l);    p2 = new Polynomial.Rational(-2l, 3l, -1l);    p1 = p1.add(p2);    assertEquals(1, p1.getDegree());    checkPolynomial(p1, "-x");  }  public void testSubtraction() {    Polynomial.Rational p1 = new Polynomial.Rational(1l, -2l);    assertTrue(p1.subtract(p1).isZero());    Polynomial.Rational p2 = new Polynomial.Rational(6l, -2l);    p2 = p2.subtract(p1);    checkPolynomial(p2, "5 x");    p1 = new Polynomial.Rational(2l, -4l, 1l);    p2 = new Polynomial.Rational(2l, 3l, -1l);    p1 = p1.subtract(p2);    assertEquals(1, p1.getDegree());    checkPolynomial(p1, "2 - 7 x");  }  public void testMultiplication() {    Polynomial.Rational p1 = new Polynomial.Rational(2l, -3l);    Polynomial.Rational p2 = new Polynomial.Rational(1l, 2l, 3l);    checkPolynomial(p1.multiply(p2), "-9 + x^2 + 2 x^3");    p1 = new Polynomial.Rational(1l, 0l);    p2 = p1;    for (int i = 2; i < 10; ++i) {      p2 = p2.multiply(p1);      checkPolynomial(p2, "x^" + i);    }  }  public void testLCM() {    Polynomial.Rational p = new Polynomial.Rational(new RationalNumber(2l, 5l),                                                    new RationalNumber(-1l, 6l),                                                    new RationalNumber(3l, 4l));    checkPolynomial(p, "3/4 - 1/6 x + 2/5 x^2");    BigInteger lcm = p.getDenominatorsLCM();    assertEquals(BigInteger.valueOf(60l), lcm);    p = (Polynomial.Rational) p.multiply(lcm);    checkPolynomial(p, "45 - 10 x + 24 x^2");  }  public void testEuclidianDivision() {    Polynomial.Rational p = new Polynomial.Rational(4l, 6l, -3l);    Polynomial.Rational q = new Polynomial.Rational(3l, 2l);    Polynomial.DivisionResult res = Polynomial.Rational.euclidianDivision(p, q);    checkPolynomial(res.quotient,  "10/9 + 4/3 x");    checkPolynomial(res.remainder, "-47/9");  }  public void checkPolynomial(Polynomial.Rational p, String reference) {    assertEquals(reference, p.toString());  }  public static Test suite() {    return new TestSuite(PolynomialRationalTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.algebra;import junit.framework.*;public class PolynomialDoubleTest  extends TestCase {  public PolynomialDoubleTest(String name) {    super(name);  }  public void testConstructors() {    Polynomial.Double p = new Polynomial.Double(1.0, 3.0, -5.0);    double[] a = p.getCoefficients();    assertEquals(a.length, 3);    assertEquals(-5.0, a[0], 1.0e-12);    assertEquals(3.0,  a[1], 1.0e-12);    assertEquals(1.0,  a[2], 1.0e-12);    assertEquals(p.getDegree(), 2);    assertEquals(1, new Polynomial.Double(0.0, 3.0, 5.0).getDegree());    assertEquals(0, new Polynomial.Double(0.0, 0.0, 5.0).getDegree());    assertEquals(0, new Polynomial.Double(0.0, 0.0, 0.0).getDegree());    assertEquals(1, new Polynomial.Double(3.0, 5.0).getDegree());    assertEquals(0, new Polynomial.Double(0.0, 5.0).getDegree());    assertEquals(0, new Polynomial.Double(0.0, 0.0).getDegree());    assertEquals(0, new Polynomial.Double(5.0).getDegree());    assertEquals(0, new Polynomial.Double(0.0).getDegree());  }  public void testConversion() {    Polynomial.Rational r = new Polynomial.Rational(1l, 3l, -5l);    r = (Polynomial.Rational) r.multiply(new RationalNumber(1l, 2l));    Polynomial.Double p = new Polynomial.Double(r);    checkPolynomial(p, "-2.5 + 1.5 x + 0.5 x^2");  }  public void testString() {    Polynomial.Double p = new Polynomial.Double(1.0, 3.0, -5.0);    checkPolynomial(p, "-5.0 + 3.0 x + x^2");    checkPolynomial(new Polynomial.Double(3.0, -2.0, 0.0),                    "-2.0 x + 3.0 x^2");    checkPolynomial(new Polynomial.Double(3.0, -2.0, 1.0),                    "1.0 - 2.0 x + 3.0 x^2");    checkPolynomial(new Polynomial.Double(3.0,  2.0, 0.0),                    "2.0 x + 3.0 x^2");    checkPolynomial(new Polynomial.Double(3.0,  2.0, 1.0),                    "1.0 + 2.0 x + 3.0 x^2");    checkPolynomial(new Polynomial.Double(3.0,  0.0, 1.0),                    "1.0 + 3.0 x^2");    checkPolynomial(new Polynomial.Double(0.0),                    "0");  }  public void testAddition() {    Polynomial.Double p1 = new Polynomial.Double(1.0, -2.0);    Polynomial.Double p2 = new Polynomial.Double(0.0, -1.0, 2.0);    assertTrue(p1.add(p2).isZero());    p2 = p1.add(p1);    checkPolynomial(p2, "-4.0 + 2.0 x");    p1 = new Polynomial.Double(2.0, -4.0, 1.0);    p2 = new Polynomial.Double(-2.0, 3.0, -1.0);    p1 = p1.add(p2);    assertEquals(1, p1.getDegree());    checkPolynomial(p1, "-x");  }  public void testSubtraction() {    Polynomial.Double p1 = new Polynomial.Double(1.0, -2.0);    assertTrue(p1.subtract(p1).isZero());    Polynomial.Double p2 = new Polynomial.Double(6.0, -2.0);    p2 = p2.subtract(p1);    checkPolynomial(p2, "5.0 x");    p1 = new Polynomial.Double(2.0, -4.0, 1.0);    p2 = new Polynomial.Double(2.0, 3.0, -1.0);    p1 = p1.subtract(p2);    assertEquals(1, p1.getDegree());    checkPolynomial(p1, "2.0 - 7.0 x");  }  public void testMultiplication() {    Polynomial.Double p1 = new Polynomial.Double(2.0, -3.0);    Polynomial.Double p2 = new Polynomial.Double(1.0, 2.0, 3.0);    checkPolynomial(p1.multiply(p2), "-9.0 + x^2 + 2.0 x^3");    p1 = new Polynomial.Double(1.0, 0.0);    p2 = p1;    for (int i = 2; i < 10; ++i) {      p2 = p2.multiply(p1);      checkPolynomial(p2, "x^" + i);    }  }  public void checkPolynomial(Polynomial.Double p, String reference) {    assertEquals(reference, p.toString());  }  public static Test suite() {    return new TestSuite(PolynomialDoubleTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.algebra;import junit.framework.*;public class ChebyshevTest  extends TestCase {  public ChebyshevTest(String name) {    super(name);  }  public void testOne() {    assertTrue(new Chebyshev().isOne());  }  public void testFirstPolynomials() {    checkPolynomial(new Chebyshev(3), "-3 x + 4 x^3");    checkPolynomial(new Chebyshev(2), "-1 + 2 x^2");    checkPolynomial(new Chebyshev(1), "x");    checkPolynomial(new Chebyshev(0), "1");    checkPolynomial(new Chebyshev(7), "-7 x + 56 x^3 - 112 x^5 + 64 x^7");    checkPolynomial(new Chebyshev(6), "-1 + 18 x^2 - 48 x^4 + 32 x^6");    checkPolynomial(new Chebyshev(5), "5 x - 20 x^3 + 16 x^5");    checkPolynomial(new Chebyshev(4), "1 - 8 x^2 + 8 x^4");  }  public void testBounds() {    for (int k = 0; k < 12; ++k) {      OrthogonalPolynomial Tk = new Chebyshev(k);      for (double x = -1.0; x <= 1.0; x += 0.02) {        assertTrue(Math.abs(Tk.valueAt(x)) < (1.0 + 1.0e-12));      }    }  }  public void testDifferentials() {    for (int k = 0; k < 12; ++k) {      Polynomial.Rational Tk0 = new Chebyshev(k);      Polynomial.Rational Tk1 = (Polynomial.Rational) Tk0.getDerivative();      Polynomial.Rational Tk2 = (Polynomial.Rational) Tk1.getDerivative();      Polynomial.Rational g0 = new Polynomial.Rational(k * k);      Polynomial.Rational g1 = new Polynomial.Rational(-1l, 0l);      Polynomial.Rational g2 = new Polynomial.Rational(-1l, 0l, 1l);      Polynomial.Rational Tk0g0 = Tk0.multiply(g0);      Polynomial.Rational Tk1g1 = Tk1.multiply(g1);      Polynomial.Rational Tk2g2 = Tk2.multiply(g2);      Polynomial.Rational d = Tk0g0.add(Tk1g1.add(Tk2g2));      assertTrue(d.isZero());    }  }  public void checkPolynomial(Polynomial.Rational p, String reference) {    assertTrue(p.toString().equals(reference));  }  public static Test suite() {    return new TestSuite(ChebyshevTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.algebra;import junit.framework.*;public class LegendreTest  extends TestCase {  public LegendreTest(String name) {    super(name);  }  public void testOne() {    assertTrue(new Legendre().isOne());  }  public void testFirstPolynomials() {    checkLegendre(new Legendre(3),  2l, "-3 x + 5 x^3");    checkLegendre(new Legendre(2),  2l, "-1 + 3 x^2");    checkLegendre(new Legendre(1),  1l, "x");    checkLegendre(new Legendre(0),  1l, "1");    checkLegendre(new Legendre(7), 16l, "-35 x + 315 x^3 - 693 x^5 + 429 x^7");    checkLegendre(new Legendre(6), 16l, "-5 + 105 x^2 - 315 x^4 + 231 x^6");    checkLegendre(new Legendre(5),  8l, "15 x - 70 x^3 + 63 x^5");    checkLegendre(new Legendre(4),  8l, "3 - 30 x^2 + 35 x^4");  }  public void testDifferentials() {    for (int k = 0; k < 12; ++k) {      Polynomial.Rational Pk0 = new Legendre(k);      Polynomial.Rational Pk1 = (Polynomial.Rational) Pk0.getDerivative();      Polynomial.Rational Pk2 = (Polynomial.Rational) Pk1.getDerivative();      Polynomial.Rational g0 = new Polynomial.Rational(k * (k + 1));      Polynomial.Rational g1 = new Polynomial.Rational(-2l, 0l);      Polynomial.Rational g2 = new Polynomial.Rational(-1l, 0l, 1l);      Polynomial.Rational Pk0g0 = Pk0.multiply(g0);      Polynomial.Rational Pk1g1 = Pk1.multiply(g1);      Polynomial.Rational Pk2g2 = Pk2.multiply(g2);      Polynomial.Rational d = Pk0g0.add(Pk1g1.add(Pk2g2));      assertTrue(d.isZero());    }  }  public void testHighDegree() {    checkLegendre(new Legendre(40), 274877906944l,                  "34461632205"                + " - 28258538408100 x^2"                + " + 3847870979902950 x^4"                + " - 207785032914759300 x^6"                + " + 5929294332103310025 x^8"                + " - 103301483474866556880 x^10"                + " + 1197358103913226000200 x^12"                + " - 9763073770369381232400 x^14"                + " + 58171647881784229843050 x^16"                + " - 260061484647976556945400 x^18"                + " + 888315281771246239250340 x^20"                + " - 2345767627188139419665400 x^22"                + " + 4819022625419112503443050 x^24"                + " - 7710436200670580005508880 x^26"                + " + 9566652323054238154983240 x^28"                + " - 9104813935044723209570256 x^30"                + " + 6516550296251767619752905 x^32"                + " - 3391858621221953912598660 x^34"                + " + 1211378079007840683070950 x^36"                + " - 265365894974690562152100 x^38"                + " + 26876802183334044115405 x^40");  }  public void checkLegendre(Legendre p, long denominator, String reference) {    assertTrue(p.multiply(denominator).toString().equals(reference));  }  public static Test suite() {    return new TestSuite(LegendreTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.algebra;import junit.framework.*;public class HermiteTest  extends TestCase {  public HermiteTest(String name) {    super(name);  }  public void testOne() {    assertTrue(new Hermite().isOne());  }  public void testFirstPolynomials() {    checkPolynomial(new Hermite(3), "-12 x + 8 x^3");    checkPolynomial(new Hermite(2), "-2 + 4 x^2");    checkPolynomial(new Hermite(1), "2 x");    checkPolynomial(new Hermite(0), "1");    checkPolynomial(new Hermite(7), "-1680 x + 3360 x^3 - 1344 x^5 + 128 x^7");    checkPolynomial(new Hermite(6), "-120 + 720 x^2 - 480 x^4 + 64 x^6");    checkPolynomial(new Hermite(5), "120 x - 160 x^3 + 32 x^5");    checkPolynomial(new Hermite(4), "12 - 48 x^2 + 16 x^4");  }  public void testDifferentials() {    for (int k = 0; k < 12; ++k) {      Polynomial.Rational Hk0 = new Hermite(k);      Polynomial.Rational Hk1 = (Polynomial.Rational) Hk0.getDerivative();      Polynomial.Rational Hk2 = (Polynomial.Rational) Hk1.getDerivative();      Polynomial.Rational g0 = new Polynomial.Rational(2l * k);      Polynomial.Rational g1 = new Polynomial.Rational(-2l, 0l);      Polynomial.Rational g2 = new Polynomial.Rational(1l);      Polynomial.Rational Hk0g0 = Hk0.multiply(g0);      Polynomial.Rational Hk1g1 = Hk1.multiply(g1);      Polynomial.Rational Hk2g2 = Hk2.multiply(g2);      Polynomial.Rational d = Hk0g0.add(Hk1g1.add(Hk2g2));      assertTrue(d.isZero());    }  }  public void checkPolynomial(Polynomial.Rational p, String reference) {    assertTrue(p.toString().equals(reference));  }  public static Test suite() {    return new TestSuite(HermiteTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.algebra;import junit.framework.*;public class RationalNumberTest  extends TestCase {  public RationalNumberTest(String name) {    super(name);  }  public void testNullDenominator() {    try {      new RationalNumber(1l, 0l);      fail("an exception should have been thrown");    } catch (ArithmeticException e) {    } catch (Exception e) {      fail("wrong exception caught");    }  }  public void testToString() {    checkValue(new RationalNumber(1l, 2l),  "1/2");    checkValue(new RationalNumber(-1l, 2l), "-1/2");    checkValue(new RationalNumber(1l, -2l), "-1/2");    checkValue(new RationalNumber(-1l, -2l), "1/2");    checkValue(new RationalNumber(0l, 500l), "0");    checkValue(new RationalNumber(-12l), "-12");    checkValue(new RationalNumber(12l), "12");  }  public void testSimplification() {    checkValue(new RationalNumber(2l, 4l), "1/2");    checkValue(new RationalNumber(307692l, 999999l), "4/13");    checkValue(new RationalNumber(999999l, 307692l), "13/4");  }  public void testInvert() {    RationalNumber f = new RationalNumber(2l, 4l).invert();    checkValue(f, "2");    f = f.invert();    checkValue(f, "1/2");    f = new RationalNumber(120l).invert();    checkValue(f, "1/120");    f = new RationalNumber(0l, 4l);    try {      f.invert();      fail("an exception should have been thrown");    } catch (ArithmeticException e) {    } catch (Exception e) {      fail("wrong exception caught");    }    f = new RationalNumber(307692l, 999999l);    RationalNumber fInverse = f.invert();    checkValue(fInverse, "13/4");    checkValue(f, "4/13");  }  public void testAddition() {    RationalNumber f1 = new RationalNumber(4l, 6l);    f1 = f1.add(f1);    checkValue(f1, "4/3");    checkValue(new RationalNumber(17l, 3l).add(new RationalNumber(-17l, 3l)),               "0");    checkValue(new RationalNumber(2l, 3l).add(new RationalNumber(3l, 4l)),               "17/12");    checkValue(new RationalNumber(1l, 6l).add(new RationalNumber(2l, 6l)),               "1/2");    checkValue(new RationalNumber(4l, 5l).add(new RationalNumber(-3l, 4l)),               "1/20");    checkValue(new RationalNumber(-3l, 4l).add(new RationalNumber(4l, 5l)),               "1/20");  }  public void testSubtraction() {    RationalNumber f1 = new RationalNumber(4l, 6l);    f1 = f1.subtract(f1);    checkValue(f1, "0");    checkValue(new RationalNumber(7l, 3l).subtract(new RationalNumber(-7l, 3l)),               "14/3");    checkValue(new RationalNumber(3l, 4l).subtract(new RationalNumber(2l, 3l)),               "1/12");    checkValue(new RationalNumber(3l, 4l).subtract(new RationalNumber(-2l, 3l)),               "17/12");    checkValue(new RationalNumber(-3l, 4l).subtract(new RationalNumber(2l, 3l)),               "-17/12");    checkValue(new RationalNumber(-3l, 4l).subtract(new RationalNumber(-2l, 3l)),               "-1/12");    checkValue(new RationalNumber(2l, 3l).subtract(new RationalNumber(3l, 4l)),               "-1/12");    checkValue(new RationalNumber(-2l, 3l).subtract(new RationalNumber(3l, 4l)),               "-17/12");    checkValue(new RationalNumber(2l, 3l).subtract(new RationalNumber(-3l, 4l)),               "17/12");    checkValue(new RationalNumber(-2l, 3l).subtract(new RationalNumber(-3l, 4l)),               "1/12");    checkValue(new RationalNumber(1l, 6l).subtract(new RationalNumber(2l, 6l)),               "-1/6");    checkValue(new RationalNumber(1l, 2l).subtract(new RationalNumber(1l, 6l)),               "1/3");  }  public void testMultiplication() {    RationalNumber f = new RationalNumber(2l, 3l);    f = f.multiply(new RationalNumber(9l,4l));    checkValue(f, "3/2");    checkValue(new RationalNumber(1l, 2l).multiply(new RationalNumber(0l)),               "0");    checkValue(new RationalNumber(4l, 15l).multiply(new RationalNumber(-5l, 2l)),               "-2/3");    checkValue(new RationalNumber(-4l, 15l).multiply(new RationalNumber(5l, 2l)),               "-2/3");    checkValue(new RationalNumber(4l, 15l).multiply(new RationalNumber(5l, 2l)),               "2/3");    checkValue(new RationalNumber(-4l, 15l).multiply(new RationalNumber(-5l, 2l)),               "2/3");  }  public void testDivision() {    RationalNumber f = new RationalNumber(2l, 3l);    f = f.divide(new RationalNumber(4l,9l));    checkValue(f, "3/2");    try {      new RationalNumber(1l, 2l).divide(new RationalNumber(0l));      fail("an exception should have been thrown");    } catch (ArithmeticException e) {    } catch (Exception e) {      fail("wrong exception caught");    }    checkValue(new RationalNumber(4l, 15l).divide(new RationalNumber(-2l, 5l)),               "-2/3");    checkValue(new RationalNumber(-4l, 15l).divide(new RationalNumber(2l, 5l)),               "-2/3");    checkValue(new RationalNumber(4l, 15l).divide(new RationalNumber(2l, 5l)),               "2/3");    checkValue(new RationalNumber(-4l, 15l).divide(new RationalNumber(-2l, 5l)),               "2/3");  }  private void checkValue(RationalNumber f, String reference) {    assertTrue(f.toString().equals(reference));  }  public static Test suite() {    return new TestSuite(RationalNumberTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.linalg;import junit.framework.*;public class NonNullRangeTest  extends TestCase {  public NonNullRangeTest(String name) {    super(name);  }  public void testPublicAttributes() {    NonNullRange r = new NonNullRange(2, 7);    assertTrue(r.begin == 2);    assertTrue(r.end   == 7);  }  public void testCopy() {    NonNullRange r1 = new NonNullRange(2, 7);    NonNullRange r2 = new NonNullRange(r1);    assertTrue(r2.begin == r1.begin);    assertTrue(r1.end   == r1.end);  }  public void testIntersection() {    NonNullRange r1 = new NonNullRange(-4, 8);    NonNullRange r2 = new NonNullRange(3, 12);    NonNullRange r3 = NonNullRange.intersection(r1, r2);    assertTrue(r3.begin == 3);    assertTrue(r3.end   == 8);  }  public void testReunion() {    NonNullRange r1 = new NonNullRange(-4, 8);    NonNullRange r2 = new NonNullRange(3, 12);    NonNullRange r3 = NonNullRange.reunion(r1, r2);    assertTrue(r3.begin == -4);    assertTrue(r3.end   == 12);  }  public static Test suite() {    return new TestSuite(NonNullRangeTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.linalg;import junit.framework.*;public class DiagonalMatrixTest  extends TestCase {  public DiagonalMatrixTest(String name) {    super(name);  }  public void testConstantDiagonal() {    checkMatrix(new DiagonalMatrix(5, 2.7), 2.7);  }  public void testNoSetOutsideOfDiagonal() {    DiagonalMatrix d = new DiagonalMatrix(4);    for (int i = 0; i < d.getRows(); ++i) {      for (int j = 0; j < d.getColumns(); ++j) {        if (i == j) {          d.setElement(i, j, 2.7);        } else {          boolean gotIt = false;          try {            d.setElement(i, j, -1.3);          } catch (ArrayIndexOutOfBoundsException e) {            gotIt = true;          }          assertTrue(gotIt);        }      }    }    checkMatrix(d, 2.7);  }  public void testCopy() {    DiagonalMatrix d1 = new DiagonalMatrix(7, 4.3);    DiagonalMatrix d2 = new DiagonalMatrix(d1);    for (int i = 0; i < d1.getRows(); ++i) {      d1.setElement(i, i, -1.0);    }    assertTrue(d2.getRows() == d1.getRows());    assertTrue(d2.getColumns() == d1.getColumns());    checkMatrix(d2, 4.3);  }  public void testDuplicate() {    DiagonalMatrix d1 = new DiagonalMatrix(6, -8.8);    Matrix d2 = d1.duplicate();    assertTrue(d2 instanceof DiagonalMatrix);    for (int i = 0; i < d1.getRows(); ++i) {      d1.setElement(i, i, -1.0);    }    assertTrue(d2.getRows() == d1.getRows());    assertTrue(d2.getColumns() == d1.getColumns());    checkMatrix(d2, -8.8);  }  public void testTranspose() {    DiagonalMatrix d = new DiagonalMatrix(5, 3.4);    Matrix transposed = d.getTranspose();    assertTrue(transposed instanceof DiagonalMatrix);    checkMatrix(transposed, 3.4);  }  public void testDeterminant() {    double expected;    expected = 1.0;    for (int k = 1; k < 10; ++k) {      expected *= 2;      DiagonalMatrix d = new DiagonalMatrix(k, 2.0);      assertTrue(Math.abs(d.getDeterminant(1.0e-10) - expected) < 1.0e-10);    }    expected = 1.0;    for (int k = 1; k < 10; ++k) {      expected *= k;      DiagonalMatrix d = new DiagonalMatrix(k);      for (int i = 0; i < k; ++i) {        d.setElement(i, i, i + 1);      }      assertTrue(Math.abs(d.getDeterminant(1.0e-10) - expected) < 1.0e-10);    }  }  public void testSolve()    throws SingularMatrixException {    DiagonalMatrix d = new DiagonalMatrix(6);    for (int i = 0; i < d.getRows(); ++i) {      d.setElement(i, i, i + 1.0);    }    GeneralMatrix b = new GeneralMatrix(6, 3);    for (int i = 0; i < b.getRows(); ++i) {      b.setElement(i, 0, i + 1.0);      b.setElement(i, 1, (i + 1.0) * (i + 1.0));      b.setElement(i, 2, 0.0);    }    Matrix result = d.solve(b, 1.0e-10);    assertTrue(result.getRows() == b.getRows());    assertTrue(result.getColumns() == b.getColumns());    for (int i = 0; i < result.getRows(); ++i) {      assertTrue(Math.abs(result.getElement(i, 0) - 1.0)       < 1.0e-10);      assertTrue(Math.abs(result.getElement(i, 1) - (i + 1.0)) < 1.0e-10);      assertTrue(Math.abs(result.getElement(i, 2) - 0.0)       < 1.0e-10);    }    boolean gotIt = false;    try {      d.setElement(3, 3, 0.0);      d.solve(b, 1.0e-10);    } catch (SingularMatrixException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testInverse()    throws SingularMatrixException {    DiagonalMatrix d = new DiagonalMatrix(4);    for (int i = 0; i < d.getRows (); ++i) {      d.setElement(i, i, i + 1.0);    }    Matrix inverse = d.getInverse(1.0e-10);    assertTrue(inverse instanceof DiagonalMatrix);    for (int i = 0; i < inverse.getRows(); ++i) {      assertTrue(Math.abs(inverse.getElement(i, i) - 1.0 / (i + 1.0)) < 1.0e-10);    }  }  public static Test suite() {    return new TestSuite(DiagonalMatrixTest.class);  }  public void checkMatrix(Matrix d, double value) {    for (int i = 0; i < d.getRows(); ++i) {      for (int j = 0; j < d.getColumns(); ++j) {        double expected = (i == j) ? value : 0.0;        assertTrue(Math.abs(d.getElement(i, j) - expected) < 1.0e-10);      }    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.linalg;import junit.framework.*;public class GeneralMatrixTest  extends TestCase {  public GeneralMatrixTest(String name) {    super(name);  }  public void testDimensions() {    GeneralMatrix m = new GeneralMatrix(3, 4);    assertTrue(m.getRows() == 3);    assertTrue(m.getColumns() == 4);  }  public void testInvalidDimensions() {    boolean gotIt;    gotIt = false;    try {      new GeneralMatrix(0, 2);    } catch(IllegalArgumentException e) {      gotIt = true;    }    assertTrue(gotIt);    gotIt = false;    try {      new GeneralMatrix(1, -3, null);    } catch(IllegalArgumentException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testElements() {    Matrix m = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    checkMatrix(m, new BilinearPattern(1.0, 0.01));  }  public void testCopy() {    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    GeneralMatrix m2 = new GeneralMatrix(m1);    for (int i = 0; i < m1.getRows(); ++i) {      for (int j = 0; j < m1.getColumns(); ++j) {        m1.setElement(i, j, -1.0);      }    }    assertTrue(m2.getRows() == m1.getRows());    assertTrue(m2.getColumns() == m1.getColumns());    checkMatrix(m2, new BilinearPattern(1.0, 0.01));  }  public void testDuplicate() {    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    Matrix m2 = m1.duplicate();    assertTrue(m2 instanceof GeneralMatrix);    for (int i = 0; i < m1.getRows(); ++i) {      for (int j = 0; j < m1.getColumns(); ++j) {        m1.setElement(i, j, -1.0);      }    }    assertTrue(m2.getRows() == m1.getRows());    assertTrue(m2.getColumns() == m1.getColumns());    checkMatrix (m2, new BilinearPattern(1.0, 0.01));  }  public void testAddKO() {    boolean gotIt = false;    try {      new GeneralMatrix(2, 3).add(new GeneralMatrix(3, 2));    } catch(IllegalArgumentException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testAddOK() {    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    Matrix m2 = buildMatrix(m1.getRows(),                            m1.getColumns(),                            new BilinearPattern(100, -0.01));    Matrix m3 = m1.add(m2);    checkMatrix(m3, new BilinearPattern(101, 0));  }  public void testSelfAdd() {    GeneralMatrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    Matrix m2 = buildMatrix(m1.getRows(),                            m1.getColumns(),                            new BilinearPattern(100, -0.01));    m1.selfAdd(m2);    checkMatrix(m1, new BilinearPattern(101, 0));  }  public void testSubKO() {    boolean gotIt = false;    try {      new GeneralMatrix(2, 3).sub(new GeneralMatrix(3, 2));    } catch(IllegalArgumentException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testSubOK() {    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    Matrix m2 = buildMatrix(m1.getRows(),                            m1.getColumns(),                            new BilinearPattern(100, -0.01));    Matrix m3 = m1.sub(m2);    checkMatrix(m3, new BilinearPattern(-99, 0.02));  }  public void testSelfSub() {    GeneralMatrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    Matrix m2 = buildMatrix(m1.getRows(),                            m1.getColumns(),                            new BilinearPattern(100, -0.01));    m1.selfSub(m2);    checkMatrix(m1, new BilinearPattern(-99, 0.02));  }  public void testMulMKO() {    boolean gotIt = false;    try {      new GeneralMatrix(2, 3).mul(new GeneralMatrix(2, 3));    } catch(IllegalArgumentException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testMulMOK() {    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    Matrix m2 = buildMatrix(m1.getColumns(), 4, new BilinearPattern(2, -1));    Matrix m3 = m1.mul(m2);    checkMatrix(m3, new ComplexPattern(m1.getColumns()));  }  public void testMulD() {    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    Matrix m2 = m1.mul(2.5);    checkMatrix(m2, new BilinearPattern(2.5, 0.025));  }  public void testSelfMul() {    Matrix m = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    m.selfMul(2.5);    checkMatrix(m, new BilinearPattern(2.5, 0.025));  }  public void testTranspose() {    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    Matrix m2 = m1.getTranspose();    assertTrue(m1.getRows() == m2.getColumns());    assertTrue(m1.getColumns() == m2.getRows());    checkMatrix(m2, new BilinearPattern(0.01, 1.0));  }  public static Test suite() {    return new TestSuite(GeneralMatrixTest.class);  }  private interface ElementPattern {    public double value(int i, int j);  }  private static class BilinearPattern implements ElementPattern {    public BilinearPattern(double coeffI, double coeffJ) {      this.coeffI = coeffI;      this.coeffJ = coeffJ;    }    public double value(int i, int j) {      return coeffI * i + coeffJ * j;    }    private final double coeffI;    private final double coeffJ;  }  private static class ComplexPattern implements ElementPattern {    public ComplexPattern(int p) {      this.p = p;    }    public double value(int i, int j) {      return p * ((2 * i - 0.01 *j) * (p - 1) / 2.0                  - i* j                  + (p - 1) * (2 * p - 1) / 300.0);    }    private final int p;  }    public GeneralMatrix buildMatrix(int rows, int columns,                                   BilinearPattern pattern) {    GeneralMatrix m = new GeneralMatrix(rows, columns);    for (int i = 0; i < m.getRows(); ++i) {      for (int j = 0; j < m.getColumns(); ++j){        m.setElement(i, j, pattern.value(i, j));      }    }    return m;  }  public void checkMatrix(Matrix m, ElementPattern pattern) {    for (int i = 0; i < m.getRows(); ++i) {      for (int j = 0; j < m.getColumns(); ++j) {        assertTrue(Math.abs(m.getElement(i, j) - pattern.value(i, j))                   < 1.0e-10);      }    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.linalg;import junit.framework.*;public class MatrixFactoryTest  extends TestCase {  public MatrixFactoryTest(String name) {    super(name);  }  public void testInvalidDimensions() {    boolean gotIt;    gotIt = false;    try {      MatrixFactory.buildMatrix(0, 2, null, 1, 1);    } catch (IllegalArgumentException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testDiagonal() {    Matrix m = MatrixFactory.buildMatrix(3, 3, null, 0, 0);    assertTrue(m instanceof DiagonalMatrix);  }  public void testLowerTriangular() {    Matrix m = MatrixFactory.buildMatrix(3, 3, null, 1, 0);    assertTrue(m instanceof LowerTriangularMatrix);  }  public void testUpperTriangular() {    Matrix m = MatrixFactory.buildMatrix(3, 3, null, 0, 1);    assertTrue(m instanceof UpperTriangularMatrix);  }  public void testSquare() {    Matrix m = MatrixFactory.buildMatrix(3, 3, null, 1, 1);    assertTrue(m instanceof GeneralSquareMatrix);  }  public void testGeneral() {    Matrix m = MatrixFactory.buildMatrix(3, 4, null, 0, 0);    assertTrue(m instanceof GeneralMatrix);  }  public static Test suite() {    return new TestSuite(MatrixFactoryTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.linalg;import junit.framework.*;public class SymetricalMatrixTest  extends TestCase {  public SymetricalMatrixTest(String name) {    super(name);  }  public void testBuildWAAt() {    double[] a = { 1.0, 2.0, 3.0 };    SymetricalMatrix s = new SymetricalMatrix(0.99, a);    checkMatrix(s, new ElementPattern() {        public double value(int i, int j) {          return 0.99 * (i + 1) * (j + 1);        }      });  }  public void testNoSetOutsideOfDiagonal() {    SymetricalMatrix s = new SymetricalMatrix(4);    for (int i = 0; i < s.getRows(); ++i) {      for (int j = 0; j < s.getColumns(); ++j) {        if (i == j) {          s.setElement(i, j, 0.5);        } else {          boolean gotIt = false;          try {            s.setElement              (i, j, -1.3);          } catch(ArrayIndexOutOfBoundsException e) {            gotIt = true;          }          assertTrue(gotIt);        }      }    }    checkMatrix(s, new ElementPattern() {        public double value(int i, int j) {          return (i == j) ? 0.5 : 0.0;        }      });  }  public void testSetElementAndSymetricalElement() {    SymetricalMatrix s = new SymetricalMatrix(5);    s.setElementAndSymetricalElement(1, 2, 3.4);    assertTrue(Math.abs(s.getElement(1, 2) - 3.4) < 1.0e-10);    assertTrue(Math.abs(s.getElement(2, 1) - 3.4) < 1.0e-10);  }  public void testCopy() {    SymetricalMatrix m1 = buildMatrix(5, new ElementPattern() {        public double value(int i, int j) {          return i * i + j * j;        }      });    SymetricalMatrix m2 = new SymetricalMatrix(m1);    for (int i = 0; i < m1.getRows(); ++i) {      for (int j = i; j < m1.getColumns(); ++j) {        m1.setElementAndSymetricalElement(i, j, -1.0);      }    }    assertTrue(m2.getRows() == m1.getRows());    assertTrue(m2.getColumns() == m1.getColumns());    checkMatrix(m2, new ElementPattern() {        public double value(int i, int j) {          return i * i + j * j;        }      });  }  public void testDuplicate() {    SymetricalMatrix m1 = buildMatrix(5, new ElementPattern() {        public double value(int i, int j) {          return i * j;        }      });    Matrix m2 = m1.duplicate();    assertTrue(m2 instanceof SymetricalMatrix);    for (int i = 0; i < m1.getRows(); ++i) {      for (int j = i; j < m1.getColumns(); ++j) {        m1.setElementAndSymetricalElement(i, j, -1.0);      }    }    assertTrue(m2.getRows() == m1.getRows());    assertTrue(m2.getColumns() == m1.getColumns());    checkMatrix(m2, new ElementPattern() {        public double value(int i, int j) {          return i * j;        }      });  }  public void testSelfAdd() {    double[] a1 = { 2.0, 4.0, 8.0, 16.0 };    SymetricalMatrix s1 = new SymetricalMatrix(0.5, a1);    double[] a2 = { 3.0, 9.0, 27.0, 81.0 };    SymetricalMatrix s2 = new SymetricalMatrix(1.0, a2);    s1.selfAdd(s2);    checkMatrix(s1, new ElementPattern() {        public double value(int i, int j) {          return 0.5 * Math.pow(2.0, i + 1) * Math.pow(2.0, j + 1)            + Math.pow(3.0, i + 1) * Math.pow(3.0, j + 1);        }      });  }  public void testSelfSub() {    double[] a1 = { 2.0, 4.0, 8.0, 16.0 };    SymetricalMatrix s1 = new SymetricalMatrix(0.5, a1);    double[] a2 = { 3.0, 9.0, 27.0, 81.0 };    SymetricalMatrix s2 = new SymetricalMatrix(1.0, a2);    s1.selfSub(s2);    checkMatrix(s1, new ElementPattern() {        public double value(int i, int j) {          return 0.5 * Math.pow(2.0, i + 1) * Math.pow(2.0, j + 1)            - Math.pow(3.0, i + 1) * Math.pow(3.0, j + 1);        }      });  }  public void testSelfAddWAAt() {    SymetricalMatrix s = new SymetricalMatrix(3);    double[] a1 = { 1.0, 2.0, 3.0 };    s.selfAddWAAt(1.0, a1);    double[] a2 = { 0.1, 0.2, 0.3 };    s.selfAddWAAt(2.0, a2);    checkMatrix(s, new ElementPattern() {        public double value(int i, int j) {          return 1.02 * (i + 1) * (j + 1);        }      });  }  public void testSingular()    throws SingularMatrixException {    SymetricalMatrix s = new SymetricalMatrix(3);    double[] a1 = { 1.0, 2.0, 3.0 };    s.selfAddWAAt(1.0, a1);    double[] a2 = { 0.1, 0.2, 0.3 };    s.selfAddWAAt(2.0, a2);    Matrix b = new GeneralMatrix(3, 1);    b.setElement(0, 0,  6.12);    b.setElement(1, 0, 12.24);    b.setElement(2, 0, 18.36);    boolean gotIt = false;    try {      s.solve(b, 1.0e-10);    } catch(SingularMatrixException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testSolve()    throws SingularMatrixException {    SymetricalMatrix s = new SymetricalMatrix(3);    double[] a1 = { 1.0, 2.0, 3.0 };    s.selfAddWAAt(1.0, a1);    double[] a2 = { 0.1, 0.2, 0.3 };    s.selfAddWAAt(2.0, a2);    double[] a3 = { 1.2, -3.0, 2.1 };    s.selfAddWAAt(3.0, a3);    double[] a4 = { 0.4, 0.1, 3.1 };    s.selfAddWAAt(2.0, a4);    Matrix b = new GeneralMatrix(3, 1);    b.setElement(0, 0, 10.08);    b.setElement(1, 0, 10.26);    b.setElement(2, 0, 42.57);    Matrix x = s.solve(b, 1.0e-10);    checkMatrix (x, new ElementPattern() {        public double value(int i, int j) {          return 1.0;        }      });    assertTrue(Math.abs(s.getDeterminant(1.0e-10) - 782.846532) < 1.0e-10);  }  public static Test suite() {    return new TestSuite(SymetricalMatrixTest.class);  }  public interface ElementPattern {    public double value(int i, int j);  }  public SymetricalMatrix buildMatrix(int order,                                      ElementPattern pattern) {    SymetricalMatrix m = new SymetricalMatrix(order);    for (int i = 0; i < m.getRows(); ++i) {      for (int j = i; j < m.getColumns(); ++j) {        m.setElementAndSymetricalElement(i, j, pattern.value(i, j));      }    }    return m;  }  public void checkMatrix(Matrix m, ElementPattern pattern) {    for (int i = 0; i < m.getRows(); ++i) {      for (int j = 0; j < m.getColumns(); ++j) {        assertTrue(Math.abs(m.getElement(i, j) - pattern.value(i, j))                   < 1.0e-10);      }    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.linalg;import junit.framework.*;public class LowerTriangularMatrixTest  extends TestCase {  public LowerTriangularMatrixTest(String name) {    super(name);  }  public void testNoSetOutsideOfLowerTriangle() {    LowerTriangularMatrix l = new LowerTriangularMatrix(4);    for (int i = 0; i < l.getRows(); ++i) {      for (int j = 0; j < l.getColumns(); ++j) {        if (i >= j) {          l.setElement(i, j, i + 0.1 * j);        } else {          boolean gotIt = false;          try {            l.setElement(i, j, -1.3);          } catch(ArrayIndexOutOfBoundsException e) {            gotIt = true;          }          assertTrue(gotIt);        }      }    }    checkMatrix(l, new BilinearPattern(1.0, 0.1));  }  public void testCopy() {    LowerTriangularMatrix l1 = buildMatrix(4, new BilinearPattern(1.0, 0.01));    LowerTriangularMatrix l2 = new LowerTriangularMatrix (l1);    checkMatrix (l2, new BilinearPattern(1.0, 0.01));  }  public void testDuplicate() {    LowerTriangularMatrix l1 = buildMatrix(4, new BilinearPattern(1.0, 0.01));    Matrix l2 = l1.duplicate();    assertTrue(l2 instanceof LowerTriangularMatrix);    checkMatrix(l2, new BilinearPattern(1.0, 0.01));  }  public void testTranspose() {    LowerTriangularMatrix l = buildMatrix(7, new BilinearPattern(1.0, 0.1));    Matrix transposed = l.getTranspose();    assertTrue(transposed instanceof UpperTriangularMatrix);    for (int i = 0; i < transposed.getRows(); ++i){      for (int j = 0; j < transposed.getColumns(); ++j) {        double expected = (i > j) ? 0.0 : (j + 0.1 * i);        assertTrue(Math.abs(transposed.getElement(i, j) - expected) < 1.0e-10);      }    }  }  public void testSelfAdd() {    LowerTriangularMatrix l1 = buildMatrix(7, new BilinearPattern(3, -0.2));    LowerTriangularMatrix l2 = buildMatrix(7, new BilinearPattern(2, -0.4));    l1.selfAdd(l2);    checkMatrix(l1, new BilinearPattern(5, -0.6));  }  public void testSelfSub() {    LowerTriangularMatrix l1 = buildMatrix(7, new BilinearPattern(3, -0.2));    LowerTriangularMatrix l2 = buildMatrix(7, new BilinearPattern(2, -0.4));    l1.selfSub(l2);    checkMatrix(l1, new BilinearPattern(1, 0.2));  }  public void testDeterminant() {    LowerTriangularMatrix l = buildMatrix(4, new ElementPattern() {        public double value(int i, int j) {          return (i == j) ? 2.0 : 1.0;        }      });    assertTrue(Math.abs(l.getDeterminant(1.0e-10) - Math.pow(2.0, l.getRows()))               < 1.0e-10);  }  public void testSolve()    throws SingularMatrixException {    LowerTriangularMatrix l = buildMatrix(7, new ElementPattern() {        public double value(int i, int j) {          return 1.0;        }      });    GeneralMatrix b = new GeneralMatrix(l.getRows(), 3);    for (int i = 0; i < b.getRows(); ++i) {      b.setElement(i, 0, i + 1.0);      b.setElement(i, 1, (i + 1.0) * (i + 2.0) / 2.0);      b.setElement(i, 2, 0.0);    }    Matrix result = l.solve(b, 1.0e-10);    assertTrue(result.getRows() == b.getRows());    assertTrue(result.getColumns() == b.getColumns());    for (int i = 0; i < result.getRows(); ++i) {      assertTrue(Math.abs(result.getElement(i, 0) - 1.0)       < 1.0e-10);      assertTrue(Math.abs(result.getElement(i, 1) - (i + 1.0)) < 1.0e-10);      assertTrue(Math.abs(result.getElement(i, 2) - 0.0)       < 1.0e-10);    }    boolean gotIt = false;    try {      l.setElement(3, 3, 0.0);      l.solve(b, 1.0e-10);    } catch(SingularMatrixException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testInverse()    throws SingularMatrixException {    LowerTriangularMatrix l = buildMatrix(5, new ElementPattern() {        public double value(int i, int j) {          return 1.0;        }      });    Matrix inverse = l.getInverse(1.0e-10);    assertTrue(inverse instanceof LowerTriangularMatrix);    checkMatrix(inverse, new ElementPattern() {        public double value(int i, int j) {          return (i == j) ? 1.0 : ((i == j + 1) ? -1.0 : 0.0);        }      });  }  public static Test suite() {    return new TestSuite(LowerTriangularMatrixTest.class);  }  public interface ElementPattern {    public double value(int i, int j);  }  private static class BilinearPattern implements ElementPattern {    public BilinearPattern(double coeffI, double coeffJ) {      this.coeffI = coeffI;      this.coeffJ = coeffJ;    }    public double value(int i, int j) {      return coeffI * i + coeffJ * j;    }    private final double coeffI;    private final double coeffJ;  }  public LowerTriangularMatrix buildMatrix(int order,                                           ElementPattern pattern) {    LowerTriangularMatrix m = new LowerTriangularMatrix(order);    for (int i = 0; i < m.getRows(); ++i) {      for (int j = 0; j <= i; ++j) {        m.setElement(i, j, pattern.value(i, j));      }    }    return m;  }  public void checkMatrix(Matrix m, ElementPattern pattern) {    for (int i = 0; i < m.getRows(); ++i) {      for (int j = 0; j < m.getColumns(); ++j) {        double expected = (j <= i) ? pattern.value(i, j) : 0.0;        assertTrue(Math.abs(m.getElement(i, j) - expected) < 1.0e-10);      }    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.linalg;import junit.framework.*;public class UpperTriangularMatrixTest  extends TestCase {  public UpperTriangularMatrixTest(String name) {    super(name);  }  public void testNoSetOutsideOfUpperTriangle() {    UpperTriangularMatrix u = new UpperTriangularMatrix(4);    for (int i = 0; i < u.getRows(); ++i) {      for (int j = 0; j < u.getColumns(); ++j) {        if (i <= j) {          u.setElement(i, j, i + 0.1 * j);        } else {          boolean gotIt = false;          try {            u.setElement(i, j, -1.3);          } catch(ArrayIndexOutOfBoundsException e) {            gotIt = true;          }          assertTrue(gotIt);        }      }    }    checkMatrix(u, new BilinearPattern(1.0, 0.1));  }  public void testCopy() {    UpperTriangularMatrix u1 = buildMatrix(4, new BilinearPattern(1.0, 0.1));    UpperTriangularMatrix u2 = new UpperTriangularMatrix(u1);    checkMatrix(u2, new BilinearPattern(1.0, 0.1));  }  public void testDuplicate() {    UpperTriangularMatrix u1 = buildMatrix(4, new BilinearPattern(1.0, 0.1));    Matrix u2 = u1.duplicate();    assertTrue(u2 instanceof UpperTriangularMatrix);    checkMatrix(u2, new BilinearPattern(1.0, 0.1));  }  public void testTranspose() {    UpperTriangularMatrix u = buildMatrix(7, new BilinearPattern(1.0, 0.1));    Matrix transposed = u.getTranspose();    assertTrue(transposed instanceof LowerTriangularMatrix);    for (int i = 0; i < transposed.getRows(); ++i){      for (int j = 0; j < transposed.getColumns(); ++j) {        double expected = (i < j) ? 0.0 : (j + 0.1 * i);        assertTrue(Math.abs(transposed.getElement(i, j) - expected) < 1.0e-10);      }    }  }  public void testSelfAdd() {    UpperTriangularMatrix u1 = buildMatrix(7, new BilinearPattern(3, -0.2));    UpperTriangularMatrix u2 = buildMatrix(7, new BilinearPattern(2, -0.4));    u1.selfAdd(u2);    checkMatrix(u1, new BilinearPattern(5, -0.6));  }  public void testSelfSub() {    UpperTriangularMatrix u1 = buildMatrix(7, new BilinearPattern(3, -0.2));    UpperTriangularMatrix u2 = buildMatrix(7, new BilinearPattern(2, -0.4));    u1.selfSub(u2);    checkMatrix(u1, new BilinearPattern(1, 0.2));  }  public void testDeterminant() {    UpperTriangularMatrix u = buildMatrix(4, new ElementPattern() {        public double value(int i, int j) {          return (i == j) ? 2.0 : 1.0;        }      });    assertTrue(Math.abs(u.getDeterminant(1.0e-10) - Math.pow(2.0, u.getRows()))               < 1.0e-10);  }  public void testSolve()    throws SingularMatrixException {    int rows = 7;    UpperTriangularMatrix u = buildMatrix(rows, new ElementPattern() {        public double value(int i, int j) {          return 1.0;        }      });    GeneralMatrix b = new GeneralMatrix(rows, 3);    for (int i = 0; i < rows; ++i) {      b.setElement(i, 0, rows - i);      b.setElement(i, 1, (rows - i) * (rows + 1 - i) / 2.0);      b.setElement(i, 2, 0.0);    }    Matrix result = u.solve(b, 1.0e-10);    assertTrue(result.getRows() == b.getRows());    assertTrue(result.getColumns() == b.getColumns());    for (int i = 0; i < result.getRows(); ++i) {      assertTrue(Math.abs(result.getElement(i, 0) - 1.0)        < 1.0e-10);      assertTrue(Math.abs(result.getElement(i, 1) - (rows - i)) < 1.0e-10);      assertTrue(Math.abs(result.getElement(i, 2) - 0.0)        < 1.0e-10);    }    boolean gotIt = false;    try {      u.setElement(3, 3, 0.0);      u.solve(b, 1.0e-10);    } catch(SingularMatrixException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testInverse()    throws SingularMatrixException {    UpperTriangularMatrix u = buildMatrix(5, new ElementPattern() {        public double value(int i, int j) {          return 1.0;        }      });    Matrix inverse = u.getInverse(1.0e-10);    assertTrue(inverse instanceof UpperTriangularMatrix);    checkMatrix(inverse, new ElementPattern() {        public double value(int i, int j) {          return (i == j) ? 1.0 : ((i == j - 1) ? -1.0 : 0.0);        }      });  }  public static Test suite() {    return new TestSuite(UpperTriangularMatrixTest.class);  }  public interface ElementPattern {    public double value(int i, int j);  }  private static class BilinearPattern implements ElementPattern {    public BilinearPattern(double coeffI, double coeffJ) {      this.coeffI = coeffI;      this.coeffJ = coeffJ;    }    public double value(int i, int j) {      return coeffI * i + coeffJ * j;    }    private final double coeffI;    private final double coeffJ;  }  public UpperTriangularMatrix buildMatrix(int order,                                           ElementPattern pattern) {    UpperTriangularMatrix m = new UpperTriangularMatrix (order);    for (int i = 0; i < m.getRows(); ++i) {      for (int j = i; j < m.getColumns(); ++j) {        m.setElement(i, j, pattern.value(i, j));      }    }    return m;  }  public void checkMatrix(Matrix m, ElementPattern pattern) {    for (int i = 0; i < m.getRows(); ++i) {      for (int j = 0; j < m.getColumns(); ++j) {        double expected = (i <= j) ? pattern.value(i, j) : 0.0;        assertTrue(Math.abs(m.getElement(i, j) - expected) < 1.0e-10);      }    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.linalg;import junit.framework.*;public class GeneralSquareMatrixTest  extends TestCase {  public GeneralSquareMatrixTest(String name) {    super(name);  }  public void testDimensions() {    GeneralSquareMatrix m = new GeneralSquareMatrix(3);    assertTrue(m.getRows() == 3);    assertTrue(m.getColumns() == 3);  }  public void testInvalidDimensions() {    boolean gotIt;    gotIt = false;    try {      new GeneralSquareMatrix(0);    } catch(IllegalArgumentException e) {      gotIt = true;    }    assertTrue(gotIt);    gotIt = false;    try {      new GeneralSquareMatrix(-3, null);    } catch(IllegalArgumentException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testElements() {    Matrix m = buildMatrix(5, new BilinearPattern(1.0, 0.01));    checkMatrix(m, new BilinearPattern(1.0, 0.01));  }  public void testCopy() {    GeneralSquareMatrix m1 = buildMatrix(5, new BilinearPattern(1.0, 0.01));    GeneralSquareMatrix m2 = new GeneralSquareMatrix(m1);    for (int i = 0; i < m1.getRows(); ++i) {      for (int j = 0; j < m1.getColumns(); ++j) {        m1.setElement(i, j, -1.0);      }    }    assertTrue(m2.getRows() == m1.getRows());    assertTrue(m2.getColumns() == m1.getColumns());    checkMatrix(m2, new BilinearPattern(1.0, 0.01));  }  public void testDuplicate() {    GeneralSquareMatrix m1 = buildMatrix(5, new BilinearPattern(1.0, 0.01));    Matrix m2 = m1.duplicate();    assertTrue(m2 instanceof GeneralSquareMatrix);    for (int i = 0; i < m1.getRows(); ++i) {      for (int j = 0; j < m1.getColumns(); ++j) {        m1.setElement(i, j, -1.0);      }    }    assertTrue(m2.getRows() == m1.getRows());    assertTrue(m2.getColumns() == m1.getColumns());    checkMatrix(m2, new BilinearPattern(1.0, 0.01));  }  public void testSelfAdd() {    GeneralSquareMatrix m1 = buildMatrix(5, new BilinearPattern(1.0, 0.01));    GeneralSquareMatrix m2 = buildMatrix(5, new BilinearPattern(2, -0.03));    m1.selfAdd(m2);    checkMatrix(m1, new BilinearPattern(3, -0.02));  }  public void testSelfSub() {    GeneralSquareMatrix m1 = buildMatrix(5, new BilinearPattern(1.0, 0.01));    GeneralSquareMatrix m2 = buildMatrix(5, new BilinearPattern(2, -0.03));    m1.selfSub(m2);    checkMatrix(m1, new BilinearPattern(-1, 0.04));  }  public void testDeterminant() {    GeneralSquareMatrix m1 = buildProblem1().a;    assertTrue(Math.abs(m1.getDeterminant(1.0e-10) - 6.0) < 1.0e-10);    GeneralSquareMatrix m2 = buildProblem2().a;    assertTrue(Math.abs(m2.getDeterminant(1.0e-10) + 0.9999999) < 1.0e-10);    GeneralSquareMatrix m3 = buildProblem3().a;    assertTrue(Math.abs(m3.getDeterminant(1.0e-10) - 0.0) < 1.0e-10);  }  public void testSolve()    throws SingularMatrixException {    LinearProblem p;    Matrix result;    p = buildProblem1();    result = p.a.solve(p.b, 1.0e-10);    checkSolve(p, result);    p = buildProblem2();    result = p.a.solve(p.b, 1.0e-10);    checkSolve(p, result);    try {      p = buildProblem3();      result = p.a.solve(p.b, 1.0e-10);      fail("got " + result + ", should have caught an exception");    } catch(SingularMatrixException e) {      // expected    } catch(Exception e) {      fail("wrong exception caught: " + e.getMessage());    }   }  public void testInverse()    throws SingularMatrixException {    SquareMatrix a, inverse;    a = buildProblem1().a;    inverse = a.getInverse(1.0e-10);    checkMatrix(a.mul(inverse), new IdentityPattern());        a = buildProblem2().a;    inverse = a.getInverse(1.0e-10);    checkMatrix(a.mul(inverse), new IdentityPattern());    try {      a = buildProblem3().a;      inverse = a.getInverse(1.0e-10);      fail("got " + inverse + ", should have caught an exception");    } catch(SingularMatrixException e) {      // expected    } catch(Exception e) {      fail("wrong exception caught: " + e.getMessage());    }  }  public static Test suite() {    return new TestSuite(GeneralSquareMatrixTest.class);  }  private interface ElementPattern {    public double value(int i, int j);  }  private static class BilinearPattern implements ElementPattern {    public BilinearPattern(double coeffI, double coeffJ) {      this.coeffI = coeffI;      this.coeffJ = coeffJ;    }    public double value(int i, int j) {      return coeffI * i + coeffJ * j;    }    private final double coeffI;    private final double coeffJ;  }  private static class IdentityPattern implements ElementPattern {    public double value(int i, int j) {      return (i == j) ? 1.0 : 0.0;    }  }  public GeneralSquareMatrix buildMatrix(int order,                                         ElementPattern pattern) {    GeneralSquareMatrix m = new GeneralSquareMatrix(order);    for (int i = 0; i < m.getRows(); ++i) {      for (int j = 0; j < m.getColumns(); ++j){        m.setElement(i, j, pattern.value(i, j));      }    }    return m;  }  public void checkMatrix(Matrix m, ElementPattern pattern) {    for (int i = 0; i < m.getRows(); ++i) {      for (int j = 0; j < m.getColumns(); ++j) {        assertTrue(Math.abs(m.getElement(i, j) - pattern.value(i, j))                   < 1.0e-10);      }    }  }  private static class LinearProblem {    public GeneralSquareMatrix a;    public Matrix              x;    public Matrix              b;    public LinearProblem(GeneralSquareMatrix a, Matrix x, Matrix b) {      this.a = a;      this.x = x;      this.b = b;    }  }  private LinearProblem buildProblem1() {    GeneralSquareMatrix a = new GeneralSquareMatrix(4);    a.setElement(0, 0,   2.0);    a.setElement(0, 1,   1.0);    a.setElement(0, 2,   0.0);    a.setElement(0, 3,   4.0);    a.setElement(1, 0,  -4.0);    a.setElement(1, 1,  -2.0);    a.setElement(1, 2,   3.0);    a.setElement(1, 3,  -7.0);    a.setElement(2, 0,   4.0);    a.setElement(2, 1,   1.0);    a.setElement(2, 2,  -2.0);    a.setElement(2, 3,   8.0);    a.setElement(3, 0,   0.0);    a.setElement(3, 1,  -3.0);    a.setElement(3, 2, -12.0);    a.setElement(3, 3,  -1.0);    GeneralMatrix x = new GeneralMatrix(4, 1);    x.setElement(0, 0,  3.0);    x.setElement(1, 0,  4.0);    x.setElement(2, 0, -1.0);    x.setElement(3, 0, -2.0);    GeneralMatrix b = new GeneralMatrix(4, 1);    b.setElement(0, 0,  2.0);    b.setElement(1, 0, -9.0);    b.setElement(2, 0,  2.0);    b.setElement(3, 0,  2.0);    return new LinearProblem(a, x, b);  }  private LinearProblem buildProblem2()  {    double epsilon = 1.0e-7;    GeneralSquareMatrix a = new GeneralSquareMatrix(2);    a.setElement(0, 0, epsilon);    a.setElement(0, 1, 1.0);    a.setElement(1, 0, 1.0);    a.setElement(1, 1, 1.0);    GeneralMatrix x = new GeneralMatrix(2, 2);    x.setElement(0, 0, 1.0 + epsilon);    x.setElement(1, 0, 1.0 - epsilon);    x.setElement(0, 1, epsilon);    x.setElement(1, 1, 1.0);    GeneralMatrix b = new GeneralMatrix(2, 2);    b.setElement(0, 0, 1.0 + epsilon * epsilon);    b.setElement(1, 0, 2.0);    b.setElement(0, 1, 1.0 + epsilon * epsilon);    b.setElement(1, 1, 1.0 + epsilon);    return new LinearProblem(a, x, b);  }  private LinearProblem buildProblem3 ()  {    GeneralSquareMatrix a = new GeneralSquareMatrix(3);    a.setElement(0, 0,  1.0);    a.setElement(0, 1,  2.0);    a.setElement(0, 1, -3.0);    a.setElement(1, 0,  2.0);    a.setElement(1, 1,  1.0);    a.setElement(1, 1,  3.0);    a.setElement(2, 0, -3.0);    a.setElement(2, 1,  0.0);    a.setElement(2, 1, -9.0);    GeneralMatrix x = new GeneralMatrix(3, 1);    GeneralMatrix b = new GeneralMatrix(3, 1);    return new LinearProblem(a, x, b);  }  private void checkSolve(LinearProblem p, Matrix result)  {    Matrix residual = p.a.mul(result).sub(p.b);    for (int i = 0; i < residual.getRows(); ++i) {      for (int j = 0; j < residual.getColumns(); ++j) {        assertTrue(Math.abs(residual.getElement(i, j)) < 1.0e-10);      }    }    for (int i = 0; i < result.getRows(); ++i) {      for (int j = 0; j < result.getColumns(); ++j) {        assertTrue(Math.abs(result.getElement(i, j) - p.x.getElement(i, j))                   < 1.0e-10);      }    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.quadrature.vectorial;import org.spaceroots.mantissa.functions.vectorial.ComputableFunction;import org.spaceroots.mantissa.functions.FunctionException;import java.util.Random;import junit.framework.*;public class GaussLegendreIntegratorTest  extends TestCase {  public GaussLegendreIntegratorTest(String name) {    super(name);  }  public void testExactIntegration()    throws FunctionException {    Random random = new Random(86343623467878363l);    int order = 0;    while (true) {      GaussLegendreIntegrator integrator = new GaussLegendreIntegrator(order,                                                                       7.0);      int availableOrder = integrator.getEvaluationsPerStep();      if (availableOrder < order) {        // we have tested all available orders        return;      }      // an order n Gauss-Legendre integrator integrates      // 2n-1 degree polynoms exactly      for (int degree = 0; degree <= 2 * availableOrder - 1; ++degree) {        for (int i = 0; i < 10; ++i) {          Polynom p = new Polynom(degree, random, 100.0);          double[] s0 = integrator.integrate(p, -5.0, 15.0);          double[] s1 = p.exactIntegration(-5.0, 15.0);          for (int j = 0; j < p.getDimension(); ++j) {            assertTrue(Math.abs(s0[j] - s1[j]) < 1.0e-12 * (1.0 + Math.abs(s0[j])));          }        }      }      ++order;    }  }  public static Test suite() {    return new TestSuite(GaussLegendreIntegratorTest.class);  }  private static class Polynom implements ComputableFunction {    public Polynom (int degree, Random random, double max) {      coeffs0 = new double[degree + 1];      coeffs1 = new double[degree + 1];      for (int i = 0; i <= degree; ++i) {        coeffs0[i] = 2.0 * max * (random.nextDouble() - 0.5);        coeffs1[i] = 2.0 * max * (random.nextDouble() - 0.5);      }    }    public int getDimension() {      return 2;    }    public double[] valueAt(double t)      throws FunctionException {      double[] y = new double[2];      y[0] = coeffs0[coeffs0.length - 1];      for (int i = coeffs0.length - 2; i >= 0; --i) {        y[0] = y[0] * t + coeffs0[i];      }      y[1] = coeffs1 [coeffs1.length - 1];      for (int i = coeffs1.length - 2; i >= 0; --i) {        y[1] = y[1] * t + coeffs1[i];      }      return y;    }    public double[] exactIntegration(double a, double b)      throws FunctionException {      double[] res = new double[2];      double yb = coeffs0[coeffs0.length - 1] / coeffs0.length;      double ya = yb;      for (int i = coeffs0.length - 2; i >= 0; --i) {        yb = yb * b + coeffs0[i] / (i + 1);        ya = ya * a + coeffs0[i] / (i + 1);      }      res[0] = yb * b - ya * a;      yb = coeffs1[coeffs1.length - 1] / coeffs1.length;      ya = yb;      for (int i = coeffs1.length - 2; i >= 0; --i) {        yb = yb * b + coeffs1[i] / (i + 1);        ya = ya * a + coeffs1[i] / (i + 1);      }      res[1] = yb * b - ya * a;      return res;    }    private double[] coeffs0;    private double[] coeffs1;    private static final long serialVersionUID = -8032020368915042278L;  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.quadrature.scalar;import org.spaceroots.mantissa.functions.scalar.ComputableFunction;import org.spaceroots.mantissa.functions.FunctionException;import java.util.Random;import junit.framework.*;public class GaussLegendreIntegratorTest  extends TestCase {  public GaussLegendreIntegratorTest(String name) {    super(name);  }  public void testExactIntegration()    throws FunctionException {    Random random = new Random(86343623467878363l);    int order = 0;    while (true) {      GaussLegendreIntegrator integrator = new GaussLegendreIntegrator(order,                                                                       7.0);      int availableOrder = integrator.getEvaluationsPerStep();      if (availableOrder < order) {        // we have tested all available orders        return;      }      // an order n Gauss-Legendre integrator integrates      // 2n-1 degree polynoms exactly      for (int degree = 0; degree <= 2 * availableOrder - 1; ++degree) {        for (int i = 0; i < 10; ++i) {          Polynom p = new Polynom(degree, random, 100.0);          double s0 = integrator.integrate(p, -5.0, 15.0);          double s1 = p.exactIntegration(-5.0, 15.0);          assertTrue(Math.abs(s0 - s1) < 1.0e-12 * (1.0 + Math.abs(s0)));        }      }      ++order;    }  }  public static Test suite() {    return new TestSuite(GaussLegendreIntegratorTest.class);  }  private static class Polynom implements ComputableFunction {    public Polynom(int degree, Random random, double max) {      coeffs = new double[degree + 1];      for (int i = 0; i <= degree; ++i) {        coeffs[i] = 2.0 * max * (random.nextDouble() - 0.5);      }    }    public double valueAt(double t)      throws FunctionException {      double y = coeffs[coeffs.length - 1];      for (int i = coeffs.length - 2; i >= 0; --i) {        y = y * t + coeffs[i];      }      return y;    }    public double exactIntegration(double a, double b)      throws FunctionException {      double yb = coeffs[coeffs.length - 1] / coeffs.length;      double ya = yb;      for (int i = coeffs.length - 2; i >= 0; --i) {        yb = yb * b + coeffs[i] / (i + 1);        ya = ya * a + coeffs[i] / (i + 1);      }      return yb * b - ya * a;    }    private double[] coeffs;     private static final long serialVersionUID = -7304282612679254557L;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class BeanTransformerTest extends TestCase {        /**     *     */    public void testConstructor(){        BeanTransformer b = new BeanTransformer();        assertNull(b.getPropertyName());    }        /**     *     */    public void testConstructorString(){        String name = "property";        BeanTransformer b = new BeanTransformer(name);        assertEquals(name, b.getPropertyName());    }        /**     *     */    public void testSetPropertyName(){        String name = "property";        BeanTransformer b = new BeanTransformer();        b.setPropertyName(name);        assertEquals(name, b.getPropertyName());    }        /**     *      */    public void testTransformNoSuchMethod(){        BeanTransformer b = new BeanTransformer("z");        TestBean target = new TestBean();try {    b.transform(target);fail("Expecting MathException");} catch (MathException e) {// expected}    }        /**     *      */    public void testTransform() throws Exception {        BeanTransformer b = new BeanTransformer("x");        TestBean target = new TestBean();double value = Double.NaN;value = b.transform(target);TestUtils.assertEquals(1.0, value, 1.0e-2);    }        /**     */    public void testTransformInvalidType() throws Exception {        BeanTransformer b = new BeanTransformer("y");        TestBean target = new TestBean();        try {b.transform(target);            fail("Expecting ClassCastException");        } catch(ClassCastException ex){            // success        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import junit.framework.TestCase;/** * @todo add javadoc comment * @version $Revision$ $Date$ */public class UnivariateRealFunctionUtilsTest extends TestCase {    /**     *       */    public void testLocalMaximumCentered() {        UnivariateRealFunction function = new SinFunction();        UnivariateRealFunction derivative = UnivariateRealFunctionUtils.centerDifferenceDerivative(function, 1.0e-5);        testLocalMaximum(derivative);    }         /**     *       */    public void testLocalMaximumForward() {        UnivariateRealFunction function = new SinFunction();        UnivariateRealFunction derivative = UnivariateRealFunctionUtils.forwardDifferenceDerivative(function, 1.0e-5);        testLocalMaximum(derivative);    }         /**     *      */    public void testLocalMaximumBackward() {        UnivariateRealFunction function = new SinFunction();        UnivariateRealFunction derivative = UnivariateRealFunctionUtils.backwardDifferenceDerivative(function, 1.0e-5);        testLocalMaximum(derivative);    }        /**     * Find a local extrema, i.e. f'(x) = 0.      */    private void testLocalMaximum(UnivariateRealFunction derivative) {        try {            double maximum = UnivariateRealSolverUtils.solve(derivative, Math.PI / 3.0, Math.PI * 2.0 / 3.0);            assertEquals(maximum, Math.PI / 2.0, 1.0e-5);        } catch (Exception ex) {            fail(ex.getMessage());        }    } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import junit.framework.TestCase;/** * * To change the template for this generated type comment go to * Window>Preferences>Java>Code Generation>Code and Comments */public class DerivativeOperatorFactoryTest extends TestCase {    /**     * Constructor for DerivativeOperatorFactoryTest.     * @param arg0     */    public DerivativeOperatorFactoryTest(String arg0) {        super(arg0);    }        //UnivariateRealFunction f = new SomeUserDefinedFunction();    //FunctionOperator derivative =      //  DerivativeOperatorFactory.newInstance().getDefaultDerivativeOperator();    //UnivariateRealFunction g = derivative.evaluate( f );    // to obtain the value of f'(0.0) use    //double fprime_at_0 = g.value( 0.0 );}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate;import java.util.ArrayList;import java.util.List;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.StatUtils;/** * Test cases for the {@link BeanListUnivariateImpl} class. * * @version $Revision$ $Date$ */public final class BeanListUnivariateImplTest extends TestCase {        private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double skewness = 0;    private double kurtosis = 0.5;    private double tolerance = 10E-15;            private List patientList = null;        public BeanListUnivariateImplTest(String name) {        super(name);    }        public void setUp() {          patientList = new ArrayList();        // Create and add patient bean 1        VitalStats vs1 = new VitalStats( new Double(120.0),                                          new Double(96.4) );        Patient p1 = new Patient( vs1, new Integer( 35 ) );        patientList.add( p1 );        // Create and add patient bean 2        VitalStats vs2 = new VitalStats( new Double(70.0),                                          new Double(97.4) );        Patient p2 = new Patient( vs2, new Integer( 23 ) );        patientList.add( p2 );        // Create and add patient bean 3        VitalStats vs3 = new VitalStats( new Double(90.0),                                          new Double(98.6) );        Patient p3 = new Patient( vs3, new Integer( 42 ) );        patientList.add( p3 );    }        public static Test suite() {        TestSuite suite = new TestSuite(BeanListUnivariateImplTest.class);        suite.setName("Frequency Tests");        return suite;    }        /** test stats */    public void testStats() {        DescriptiveStatistics u = new BeanListUnivariateImpl( patientList, "age" );         double[] values = {35d, 23d, 42d};        assertEquals("total count",3,u.getN(),tolerance);        assertEquals("mean", StatUtils.mean(values), u.getMean(), tolerance);        assertEquals("min", StatUtils.min(values), u.getMin(), tolerance);        assertEquals("max", StatUtils.max(values), u.getMax(), tolerance);        assertEquals("var", StatUtils.variance(values), u.getVariance(), tolerance);               u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }           public void testPropStats() {        DescriptiveStatistics heartU = new BeanListUnivariateImpl( patientList,                                          "vitalStats.heartRate" );               assertEquals( "Mean heart rate unexpected", 93.333,                       heartU.getMean(), 0.001 );        assertEquals( "Max heart rate unexpected", 120.0,                       heartU.getMax(), 0.001 );        DescriptiveStatistics ageU = new BeanListUnivariateImpl( patientList,                                                           "age" );        assertEquals( "Mean age unexpected", 33.333,                      ageU.getMean(), 0.001 );        assertEquals( "Max age unexpected", 42.0,                      ageU.getMax(), 0.001 );    }        public void testSetPropertyName(){        BeanListUnivariateImpl u = new BeanListUnivariateImpl(null);        String expected = "property";        u.setPropertyName(expected);        assertEquals(expected, u.getPropertyName());    }        public void testAddValue() {        DescriptiveStatistics u = new BeanListUnivariateImpl( patientList, "age" );         u.addValue(10);        double[] values = {35d, 23d, 42d, 10d};        assertEquals("total count",4,u.getN(),tolerance);        assertEquals("mean", StatUtils.mean(values), u.getMean(), tolerance);        assertEquals("min", StatUtils.min(values), u.getMin(), tolerance);        assertEquals("max", StatUtils.max(values), u.getMax(), tolerance);        assertEquals("var", StatUtils.variance(values), u.getVariance(), tolerance);               u.clear();        assertEquals("total count",0,u.getN(),tolerance);          }        /** test stats */    public void testSerialization() {                double[] values = {35d, 23d, 42d};                DescriptiveStatistics u = new BeanListUnivariateImpl( patientList, "age" );         assertEquals("total count",3,u.getN(),tolerance);        assertEquals("mean", StatUtils.mean(values), u.getMean(), tolerance);        assertEquals("min", StatUtils.min(values), u.getMin(), tolerance);        assertEquals("max", StatUtils.max(values), u.getMax(), tolerance);        assertEquals("var", StatUtils.variance(values), u.getVariance(), tolerance);                           DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u);         assertEquals("total count",3,u2.getN(),tolerance);        assertEquals("mean", StatUtils.mean(values), u2.getMean(), tolerance);        assertEquals("min", StatUtils.min(values), u2.getMin(), tolerance);        assertEquals("max", StatUtils.max(values), u2.getMax(), tolerance);        assertEquals("var", StatUtils.variance(values), u2.getVariance(), tolerance);           u.clear();        assertEquals("total count",0,u.getN(),tolerance);                    u2.clear();        assertEquals("total count",0,u2.getN(),tolerance);                }            public class VitalStats {        private Double heartrate;        private Double temperature;        public VitalStats() {        }        public VitalStats(Double heartrate, Double temperature) {            setHeartRate( heartrate );            setTemperature( temperature );        }        public Double getHeartRate() {            return heartrate;        }        public void setHeartRate(Double heartrate) {            this.heartrate = heartrate;        }        public Double getTemperature() {            return temperature;        }        public void setTemperature(Double temperature) {            this.temperature = temperature;        }    }        public class Patient {        private VitalStats vitalStats;        private Integer age;        public Patient() {        }        public Patient(VitalStats vitalStats, Integer age) {            setVitalStats( vitalStats );            setAge( age );        }        public VitalStats getVitalStats() {            return( vitalStats );        }        public void setVitalStats(VitalStats vitalStats) {            this.vitalStats = vitalStats;        }        public Integer getAge() {            return age;        }        public void setAge(Integer age) {            this.age = age;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Test cases for the {@link CholeskySolver} class. * <p> * @author Stefan Koeberle, 11/2003 */public class CholeskySolverTest extends TestCase {            private double[][] m1 = {{1}};        private double m1Det = 1.0d;                private double[][] m2 = {{1, 0} ,                                  {0, 2}};        private double m2Det = 2.0d;                                                 private double[][] m3 = {{1, 0, 0},                                  {0, 2, 0},                                  {0, 0, 3}};        private double m3Det = 6.0d;                                         private double[][] m4 = {{1, 0, 0},                                  {2, 3, 0},                                  {4, 5, 6}};        private double m4Det = 18.0d;                private double[][] m5 = {{ 1,  0,  0,  0,  0},                                  {-2,  3,  0,  0,  0},                                  { 4, -5,  6,  0,  0},                                 { 7,  8, -9, 10,  0},                                 {11, 12, 13, 14, 15}};        private double m5Det = 2700.0d;                                         private double[][] m6 = {{1, 0,  0},                                  {2, 0,  0},                                  {4, 5,  6}};                private double[][] m7 = {{1, 2, 3},                                  {4, 5, 6}};                                    /**      * Creates a new instance of CholeskySolverTest      */    public CholeskySolverTest(String nameOfTest) {        super(nameOfTest);    }//constructor CholeskySolverTest        public void setUp()     throws java.lang.Exception {        super.setUp();    }//setUp           public void tearDown()     throws java.lang.Exception {        super.tearDown();    }//tearDown        public static Test suite() {        TestSuite suite = new TestSuite(CholeskySolverTest.class);        suite.setName("CholeskySolver Tests");        return suite;    }//suite        /**      * tests CholeskySolver.setNumericalZero()      */       public void testNumericalZero() {        CholeskySolver solver = new CholeskySolver();        double numericalZero = 77.77d;        solver.setNumericalZero(numericalZero);        assertEquals(solver.getNumericalZero(), numericalZero, 0.0d);                try {            solver.decompose(                new RealMatrixImpl(new double[][]{{numericalZero/2, 0},                                                  {0, numericalZero/2}}));            fail("testing numericalZero");        } catch (IllegalArgumentException e) {}            }//testNumericalZero            /**      * tests CholeskySolver.decompose(...)      */    public void testDecompose() {                //The following decompositions should succeed.        testDecompose(m1, "Decomposing matrix m1");        testDecompose(m2, "Decomposing matrix m2");        testDecompose(m3, "Decomposing matrix m3");        testDecompose(m4, "Decomposing matrix m4");        testDecompose(m5, "Decomposing matrix m5");                //The following decompositions will fail. An IllegalArgumentException        //should be thrown.        try {            testDecompose(m6, "Decomposing matrix m6");            fail("Decomposing matrix m6");         } catch (IllegalArgumentException e) {}                 try {             CholeskySolver solver = new CholeskySolver();             solver.decompose(new RealMatrixImpl(m7));             fail("Decomposing matrix m7");         } catch (IllegalArgumentException e) {}            }//testDecomposition            /**      * tests CholeskySolver.solve(...)      */    public void testSolve() {        //If there's no matrix, there's no linear euqitation to solve ...        try {             CholeskySolver solver = new CholeskySolver();             solver.solve(new double[] {1,2,3});             fail("solving a liniar equitation with a missing matrix should fail");         } catch (IllegalStateException e) {}        //The following operations should succeed.        testSolve(m1, "Solving matrix m1");          testSolve(m2, "Solving matrix m2");        testSolve(m3, "Solving matrix m3");        testSolve(m4, "Solving matrix m4");        testSolve(m5, "Solving matrix m5");             //The following operations will fail. An IllegalArgumentException        //should be thrown.        try {          testSolve(m6, "Solving matrix m6");          fail("Solving matrix m6");         } catch (IllegalArgumentException e) {}         try {             CholeskySolver solver = new CholeskySolver();             solver.solve(new RealMatrixImpl(m3), new double[] {1, 2, 3, 4});             fail("Solving matrix m3[3x3], v[4]");         } catch (IllegalArgumentException e) {}            }//testDecomposition            /**      * tests CholeskySolver.getDeterminant(...)      */    public void testGetDeterminant() {                //Since no matrix was decomposed, there's no determinant.        try {             CholeskySolver solver = new CholeskySolver();             solver.getDeterminant();             fail("Calculating determinant of missing matrix should fail");         } catch (IllegalStateException e) {}               //These test will suceed.        testGetDeterminant(m1, m1Det, "Calculating determinant of m1");        testGetDeterminant(m2, m2Det, "Calculating determinant of m2");        testGetDeterminant(m3, m3Det, "Calculating determinant of m3");        testGetDeterminant(m4, m4Det, "Calculating determinant of m4");        testGetDeterminant(m5, m5Det, "Calculating determinant of m5");    }//test            /**     * Generates the matrix      * <code>m = lowerTriangularMatrix * lowerTriangularMatrix^T</code>.     * If alle diagonalelements of <code>lowerTriangularMatrix</code> are     * positiv, <code>m</code> will be positiv definit.      * Decomposing <code>m</code> should result in     * <code>lowerTriangularMatrix</code> again. So there's a simple test ...     */    private void testDecompose(double[][] lowerTriangularMatrix, String message)     throws IllegalArgumentException {            RealMatrix triangularMatrix = new RealMatrixImpl(lowerTriangularMatrix);        RealMatrix pdMatrix =             triangularMatrix.multiply(triangularMatrix.transpose());                CholeskySolver solver = new CholeskySolver();        solver.decompose(pdMatrix);                assertTrue(message,             areEqual(triangularMatrix, solver.getDecomposition(), 1.0E-10));        }//testDecompose          /**     * Similar to <code> private testDecompose(...)</code>.     */    private void testSolve(double[][] lowerTriangularMatrix, String message)  {              RealMatrix triangularMatrix =             new RealMatrixImpl(lowerTriangularMatrix);        RealMatrixImpl pdMatrix =             (RealMatrixImpl) triangularMatrix.multiply(triangularMatrix.transpose());        CholeskySolver solver =             new CholeskySolver();                double[] c = new double[lowerTriangularMatrix.length];        for (int i=0; i<c.length; i++)             for (int j=0; j<lowerTriangularMatrix[0].length; j++)                 c[i] += lowerTriangularMatrix[i][j];                solver.decompose(pdMatrix);        RealMatrix x = new RealMatrixImpl(solver.solve(c));        assertTrue(message,             areEqual(pdMatrix.multiply(x),  new RealMatrixImpl(c), 1.0E-10));    }//testSolve        /**     * Similar to <code> private testDecompose(...)</code>.     */    private void testGetDeterminant(double[][] lowerTriangularMatrix,                                     double determinant,                                    String message)     throws IllegalArgumentException {            RealMatrix triangularMatrix = new RealMatrixImpl(lowerTriangularMatrix);        RealMatrix pdMatrix =             triangularMatrix.multiply(triangularMatrix.transpose());        double pdDeterminant = determinant * determinant;                CholeskySolver solver = new CholeskySolver();        solver.decompose(pdMatrix);        assertEquals(message, solver.getDeterminant(), pdDeterminant, 1.0E-10);    }//testGetDeterminant            /**     * Are <code>m1</code> and <code>m2</code> equal?     */    private static boolean areEqual(RealMatrix m1, RealMatrix m2, double delta) {                double[][] mv1 = m1.getData();        double[][] mv2 = m2.getData();                if (mv1.length != mv1.length  ||            mv1[0].length != mv2[0].length)             return false;                for (int i=0; i<mv1.length; i++)             for (int j=0; j<mv1[0].length; j++)                 if (Math.abs(mv1[i][j] -mv2[i][j]) > delta)                     return false;                return true;    }//isEqual          /**     * Executes all tests of this class     */    public static void main(String[] args) {        System.out.println("Start");        TestRunner runner = new TestRunner();        runner.doRun(CholeskySolverTest.suite());        System.out.println("End");    }//main    }//class CholeskySolverTest
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.stat.StatUtils;import junit.framework.TestCase;/** * This class contains test cases for the ExpandableDoubleArray. *  * @version $Revision$ $Date$ */public abstract class DoubleArrayAbstractTest extends TestCase {    protected DoubleArray da = null;    // Array used to test rolling    protected DoubleArray ra = null;    public DoubleArrayAbstractTest(String name) {        super(name);    }    public void testAdd1000() {        for (int i = 0; i < 1000; i++) {            da.addElement(i);        }        assertEquals(            "Number of elements should be equal to 1000 after adding 1000 values",            1000,            da.getNumElements());        assertEquals(            "The element at the 56th index should be 56",            56.0,            da.getElement(56),            Double.MIN_VALUE);    }    public void testGetValues() {        double[] controlArray = { 2.0, 4.0, 6.0 };        da.addElement(2.0);        da.addElement(4.0);        da.addElement(6.0);        double[] testArray = da.getElements();        for (int i = 0; i < da.getNumElements(); i++) {            assertEquals(                "The testArray values should equal the controlArray values, index i: "                    + i                    + " does not match",                testArray[i],                controlArray[i],                Double.MIN_VALUE);        }    }    public void testAddElementRolling() {        ra.addElement(0.5);        ra.addElement(1.0);        ra.addElement(1.0);        ra.addElement(1.0);        ra.addElement(1.0);        ra.addElement(1.0);        ra.addElementRolling(2.0);        assertEquals(            "There should be 6 elements in the eda",            6,            ra.getNumElements());        assertEquals(            "The max element should be 2.0",            2.0,            StatUtils.max(ra.getElements()),            Double.MIN_VALUE);        assertEquals(            "The min element should be 1.0",            1.0,            StatUtils.min(ra.getElements()),            Double.MIN_VALUE);        for (int i = 0; i < 1024; i++) {            ra.addElementRolling(i);        }        assertEquals(            "We just inserted 1024 rolling elements, num elements should still be 6",            6,            ra.getNumElements());    }    public void testMinMax() {        da.addElement(2.0);        da.addElement(22.0);        da.addElement(-2.0);        da.addElement(21.0);        da.addElement(22.0);        da.addElement(42.0);        da.addElement(62.0);        da.addElement(22.0);        da.addElement(122.0);        da.addElement(1212.0);        assertEquals("Min should be -2.0", -2.0, StatUtils.min(da.getElements()), Double.MIN_VALUE);        assertEquals(            "Max should be 1212.0",            1212.0,            StatUtils.max(da.getElements()),            Double.MIN_VALUE);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class ContinuedFractionTest extends TestCase {    /**     * Constructor for ContinuedFractionTest.     * @param name     */    public ContinuedFractionTest(String name) {        super(name);    }    public void testGoldenRation(){        ContinuedFraction cf = new ContinuedFraction() {            public double getA(int n, double x) {                return 1.0;            }            public double getB(int n, double x) {                return 1.0;            }        };                try {            double gr = cf.evaluate(0.0, 10e-9);            assertEquals(1.61803399, gr, 10e-9);        } catch (MathException e) {            fail(e.getMessage());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.random.RandomDataImpl;import org.apache.commons.math.random.RandomData;/** * This class contains test cases for the ResizableDoubleArray. *  * @version $Revision$ $Date$ */public class ResizableDoubleArrayTest extends DoubleArrayAbstractTest {        public ResizableDoubleArrayTest(String name) {        super( name );    }          protected void tearDown() throws Exception {        da = null;        ra = null;    }           protected void setUp() throws Exception {        da = new ResizableDoubleArray();        ra = new ResizableDoubleArray();    }        public void testConstructors() {        float defaultExpansionFactor = 2.0f;        float defaultContractionCriteria = 2.5f;        int defaultMode = ResizableDoubleArray.MULTIPLICATIVE_MODE;                ResizableDoubleArray testDa = new ResizableDoubleArray(2);        assertEquals(0, testDa.getNumElements());        assertEquals(2, testDa.getInternalLength());        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);        assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);        assertEquals(defaultMode, testDa.getExpansionMode());        try {            da = new ResizableDoubleArray(-1);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                testDa = new ResizableDoubleArray(2, 2.0f);        assertEquals(0, testDa.getNumElements());        assertEquals(2, testDa.getInternalLength());        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);        assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);        assertEquals(defaultMode, testDa.getExpansionMode());                try {            da = new ResizableDoubleArray(2, 0.5f);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                testDa = new ResizableDoubleArray(2, 3.0f);        assertEquals(3.0f, testDa.getExpansionFactor(), 0);        assertEquals(3.5f, testDa.getContractionCriteria(), 0);                testDa = new ResizableDoubleArray(2, 2.0f, 3.0f);        assertEquals(0, testDa.getNumElements());        assertEquals(2, testDa.getInternalLength());        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);        assertEquals(3.0f, testDa.getContractionCriteria(), 0);        assertEquals(defaultMode, testDa.getExpansionMode());                try {            da = new ResizableDoubleArray(2, 2.0f, 1.5f);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                testDa = new ResizableDoubleArray(2, 2.0f, 3.0f,                 ResizableDoubleArray.ADDITIVE_MODE);        assertEquals(0, testDa.getNumElements());        assertEquals(2, testDa.getInternalLength());        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);        assertEquals(3.0f, testDa.getContractionCriteria(), 0);        assertEquals(ResizableDoubleArray.ADDITIVE_MODE,                 testDa.getExpansionMode());                try {            da = new ResizableDoubleArray(2, 2.0f, 2.5f, -1);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }            }            public void testSetElementArbitraryExpansion() {                // MULTIPLICATIVE_MODE         da.addElement(2.0);        da.addElement(4.0);        da.addElement(6.0);        da.setElement(1, 3.0);                // Expand the array arbitrarily to 1000 items        da.setElement(1000, 3.4);                assertEquals( "The number of elements should now be 1001, it isn't",                 da.getNumElements(), 1001);                assertEquals( "Uninitialized Elements are default value of 0.0, index 766 wasn't", 0.0,                da.getElement( 760 ), Double.MIN_VALUE );                assertEquals( "The 1000th index should be 3.4, it isn't", 3.4, da.getElement(1000),                 Double.MIN_VALUE );        assertEquals( "The 0th index should be 2.0, it isn't", 2.0, da.getElement(0),                 Double.MIN_VALUE);                 // Make sure numElements and expansion work correctly for expansion boundary cases        da.clear();        da.addElement(2.0);        da.addElement(4.0);        da.addElement(6.0);        assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());        assertEquals(3, da.getNumElements());        da.setElement(3, 7.0);        assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());        assertEquals(4, da.getNumElements());        da.setElement(10, 10.0);        assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());        assertEquals(11, da.getNumElements());        da.setElement(9, 10.0);        assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());        assertEquals(11, da.getNumElements());                try {            da.setElement(-2, 3);            fail("Expecting ArrayIndexOutOfBoundsException for negative index");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected        }                // ADDITIVE_MODE                ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 3.0f,                 ResizableDoubleArray.ADDITIVE_MODE);        assertEquals(2, testDa.getInternalLength());        testDa.addElement(1d);        testDa.addElement(1d);        assertEquals(2, testDa.getInternalLength());        testDa.addElement(1d);        assertEquals(4, testDa.getInternalLength());             }        public void testAdd1000() {        super.testAdd1000();        assertEquals("Internal Storage length should be 1024 if we started out with initial capacity of " +                "16 and an expansion factor of 2.0",                1024, ((ResizableDoubleArray) da).getInternalLength());    }        public void testAddElementRolling() {        super.testAddElementRolling();                // MULTIPLICATIVE_MODE        da.clear();        da.addElement(1);        da.addElement(2);        da.addElementRolling(3);        assertEquals(3, da.getElement(1), 0);        da.addElementRolling(4);        assertEquals(3, da.getElement(0), 0);        assertEquals(4, da.getElement(1), 0);        da.addElement(5);        assertEquals(5, da.getElement(2), 0);        da.addElementRolling(6);        assertEquals(4, da.getElement(0), 0);        assertEquals(5, da.getElement(1), 0);        assertEquals(6, da.getElement(2), 0);                   // ADDITIVE_MODE  (x's are occupied storage locations, 0's are open)        ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 2.5f,                 ResizableDoubleArray.ADDITIVE_MODE);        assertEquals(2, testDa.getInternalLength());        testDa.addElement(1d); // x,0        testDa.addElement(2d); // x,x        testDa.addElement(3d); // x,x,x,0 -- expanded        assertEquals(1d, testDa.getElement(0), 0);        assertEquals(2d, testDa.getElement(1), 0);        assertEquals(3d, testDa.getElement(2), 0);           assertEquals(4, testDa.getInternalLength());  // x,x,x,0         assertEquals(3, testDa.getNumElements());        testDa.addElementRolling(4d);        assertEquals(2d, testDa.getElement(0), 0);        assertEquals(3d, testDa.getElement(1), 0);        assertEquals(4d, testDa.getElement(2), 0);           assertEquals(4, testDa.getInternalLength());  // 0,x,x,x        assertEquals(3, testDa.getNumElements());        testDa.addElementRolling(5d);   // 0,0,x,x,x,0 -- time to contract        assertEquals(3d, testDa.getElement(0), 0);        assertEquals(4d, testDa.getElement(1), 0);        assertEquals(5d, testDa.getElement(2), 0);           assertEquals(4, testDa.getInternalLength());  // contracted -- x,x,x,0             assertEquals(3, testDa.getNumElements());        try {            testDa.getElement(4);            fail("Expecting ArrayIndexOutOfBoundsException");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected        }          try {            testDa.getElement(-1);            fail("Expecting ArrayIndexOutOfBoundsException");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected        }    }        public void testSetNumberOfElements() {        da.addElement( 1.0 );        da.addElement( 1.0 );        da.addElement( 1.0 );        da.addElement( 1.0 );        da.addElement( 1.0 );        da.addElement( 1.0 );        assertEquals( "Number of elements should equal 6", da.getNumElements(), 6);                ((ResizableDoubleArray) da).setNumElements( 3 );        assertEquals( "Number of elements should equal 3", da.getNumElements(), 3);                try {            ((ResizableDoubleArray) da).setNumElements( -3 );            fail( "Setting number of elements to negative should've thrown an exception");        } catch( IllegalArgumentException iae ) {        }                ((ResizableDoubleArray) da).setNumElements(1024);        assertEquals( "Number of elements should now be 1024", da.getNumElements(), 1024);        assertEquals( "Element 453 should be a default double", da.getElement( 453 ), 0.0, Double.MIN_VALUE);            }        public void testWithInitialCapacity() {                ResizableDoubleArray eDA2 = new ResizableDoubleArray(2);        assertEquals("Initial number of elements should be 0", 0, eDA2.getNumElements());                RandomData randomData = new RandomDataImpl();        int iterations = randomData.nextInt(100, 1000);                for( int i = 0; i < iterations; i++) {            eDA2.addElement( i );        }                assertEquals("Number of elements should be equal to " + iterations, iterations, eDA2.getNumElements());                eDA2.addElement( 2.0 );                assertEquals("Number of elements should be equals to " + (iterations +1),                iterations + 1 , eDA2.getNumElements() );    }        public void testWithInitialCapacityAndExpansionFactor() {                ResizableDoubleArray eDA3 = new ResizableDoubleArray(3, 3.0f, 3.5f);        assertEquals("Initial number of elements should be 0", 0, eDA3.getNumElements() );                RandomData randomData = new RandomDataImpl();        int iterations = randomData.nextInt(100, 3000);                for( int i = 0; i < iterations; i++) {            eDA3.addElement( i );        }                assertEquals("Number of elements should be equal to " + iterations, iterations,eDA3.getNumElements());                eDA3.addElement( 2.0 );                assertEquals("Number of elements should be equals to " + (iterations +1),                iterations +1, eDA3.getNumElements() );                assertEquals("Expansion factor should equal 3.0", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);    }        public void testDiscard() {        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        assertEquals( "Number of elements should be 11", 11, da.getNumElements());                ((ResizableDoubleArray)da).discardFrontElements(5);        assertEquals( "Number of elements should be 6", 6, da.getNumElements());                try {            ((ResizableDoubleArray)da).discardFrontElements(-1);            fail( "Trying to discard a negative number of element is not allowed");        } catch( Exception e ){        }                try {            ((ResizableDoubleArray)da).discardFrontElements( 10000 );            fail( "You can't discard more elements than the array contains");        } catch( Exception e ){        }    }        public void testMutators() {        ((ResizableDoubleArray)da).setContractionCriteria(10f);        assertEquals(10f, ((ResizableDoubleArray)da).getContractionCriteria(), 0);        ((ResizableDoubleArray)da).setExpansionFactor(8f);          assertEquals(8f, ((ResizableDoubleArray)da).getExpansionFactor(), 0);        try {            ((ResizableDoubleArray)da).setExpansionFactor(11f);  // greater than contractionCriteria            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        ((ResizableDoubleArray)da).setExpansionMode(                ResizableDoubleArray.ADDITIVE_MODE);        assertEquals(ResizableDoubleArray.ADDITIVE_MODE,                 ((ResizableDoubleArray)da).getExpansionMode());        try {            ((ResizableDoubleArray)da).setExpansionMode(-1);            fail ("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import java.math.BigDecimal;import org.apache.commons.math.TestUtils;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the MathUtils class. * * @version $Revision$ $Date$ */public final class MathUtilsTest extends TestCase {    public MathUtilsTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(MathUtilsTest.class);        suite.setName("MathUtils Tests");        return suite;    }        public void testAddAndCheck() {        int big = Integer.MAX_VALUE;        int bigNeg = Integer.MIN_VALUE;        assertEquals(big, MathUtils.addAndCheck(big, 0));        try {            int res = MathUtils.addAndCheck(big, 1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {}        try {            int res = MathUtils.addAndCheck(bigNeg, -1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {}    }        public void testMulAndCheck() {        int big = Integer.MAX_VALUE;        int bigNeg = Integer.MIN_VALUE;        assertEquals(big, MathUtils.mulAndCheck(big, 1));        try {            int res = MathUtils.mulAndCheck(big, 2);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {}        try {            int res = MathUtils.mulAndCheck(bigNeg, 2);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {}    }        public void testSubAndCheck() {        int big = Integer.MAX_VALUE;        int bigNeg = Integer.MIN_VALUE;        assertEquals(big, MathUtils.subAndCheck(big, 0));        try {            int res = MathUtils.subAndCheck(big, -1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {}        try {            int res = MathUtils.subAndCheck(bigNeg, 1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {}    }        public void testSubAndCheckErrorMessage() {        int big = Integer.MAX_VALUE;        int bigNeg = Integer.MIN_VALUE;        try {            int res = MathUtils.subAndCheck(big, -1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            assertEquals("overflow: subtract", ex.getMessage());        }    }        public void testBinomialCoefficient() {        long[] bcoef5 = {1,5,10,10,5,1};        long[] bcoef6 = {1,6,15,20,15,6,1};        for (int i = 0; i < 6; i++) {            assertEquals("5 choose " + i, bcoef5[i],                 MathUtils.binomialCoefficient(5,i));        }        for (int i = 0; i < 7; i++) {            assertEquals("6 choose " + i, bcoef6[i],                 MathUtils.binomialCoefficient(6,i));        }                for (int n = 1; n < 10; n++) {            for (int k = 0; k <= n; k++) {                assertEquals(n + " choose " + k, binomialCoefficient(n, k),                     MathUtils.binomialCoefficient(n, k));                assertEquals(n + " choose " + k,(double) binomialCoefficient(n, k),                     MathUtils.binomialCoefficientDouble(n, k),Double.MIN_VALUE);                assertEquals(n + " choose " + k,                    Math.log((double) binomialCoefficient(n, k)),                     MathUtils.binomialCoefficientLog(n, k),10E-12);            }        }            /*        * Takes a long time for recursion to unwind, but succeeds        * and yields exact value = 2,333,606,220                assertEquals(MathUtils.binomialCoefficient(34,17),            binomialCoefficient(34,17));       */    }        /** Verify that b(0,0) = 1 */    public void test0Choose0() {        assertEquals(MathUtils.binomialCoefficientDouble(0, 0), 1d, 0);        assertEquals(MathUtils.binomialCoefficientLog(0, 0), 0d, 0);        assertEquals(MathUtils.binomialCoefficient(0, 0), 1);    }        public void testBinomialCoefficientFail() {        try {            long x = MathUtils.binomialCoefficient(4,5);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }                try {            double x = MathUtils.binomialCoefficientDouble(4,5);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }                try {            double x = MathUtils.binomialCoefficientLog(4,5);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            long x = MathUtils.binomialCoefficient(67,34);            fail ("expecting ArithmeticException");        } catch (ArithmeticException ex) {            ;        }        double x = MathUtils.binomialCoefficientDouble(1030,515);        assertTrue("expecting infinite binomial coefficient",            Double.isInfinite(x));    }    public void testFactorial() {        for (int i = 1; i < 10; i++) {            assertEquals(i + "! ",factorial(i),MathUtils.factorial(i));            assertEquals(i + "! ",(double)factorial(i),                MathUtils.factorialDouble(i),Double.MIN_VALUE);            assertEquals(i + "! ",Math.log((double)factorial(i)),                MathUtils.factorialLog(i),10E-12);        }        assertEquals("0", 1, MathUtils.factorial(0));        assertEquals("0", 1.0d, MathUtils.factorialDouble(0), 1E-14);        assertEquals("0", 0.0d, MathUtils.factorialLog(0), 1E-14);    }    public void testFactorialFail() {        try {            long x = MathUtils.factorial(-1);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = MathUtils.factorialDouble(-1);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = MathUtils.factorialLog(-1);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = MathUtils.factorial(21);            fail ("expecting ArithmeticException");        } catch (ArithmeticException ex) {            ;        }        assertTrue("expecting infinite factorial value",            Double.isInfinite(MathUtils.factorialDouble(171)));    }    /**     * Exact recursive implementation to test against     */    private long binomialCoefficient(int n, int k) {        if ((n == k) || (k == 0)) {            return 1;        }        if ((k == 1) || (k == n - 1)) {            return n;        }        return binomialCoefficient(n - 1, k - 1) +            binomialCoefficient(n - 1, k);    }    /**     * Finds the largest values of n for which binomialCoefficient and     * binomialCoefficientDouble will return values that fit in a long, double,     * resp.  Remove comments around test below to get this in test-report     *        public void testLimits() {            findBinomialLimits();        }     */    private void findBinomialLimits() {        /**         * will kick out 66 as the limit for long         */        boolean foundLimit = false;        int test = 10;        while (!foundLimit) {            try {                double x = MathUtils.binomialCoefficient(test, test / 2);            } catch (ArithmeticException ex) {                foundLimit = true;                System.out.println                    ("largest n for binomialCoefficient = " + (test - 1) );            }            test++;        }       /**        * will kick out 1029 as the limit for double        */        foundLimit = false;        test = 10;        while (!foundLimit) {            double x = MathUtils.binomialCoefficientDouble(test, test / 2);            if (Double.isInfinite(x)) {                foundLimit = true;                System.out.println                    ("largest n for binomialCoefficientD = " + (test - 1) );            }            test++;        }    }    /**     * Finds the largest values of n for which factiorial and     * factorialDouble will return values that fit in a long, double,     * resp.  Remove comments around test below to get this in test-report        public void testFactiorialLimits() {            findFactorialLimits();        }     */    private void findFactorialLimits() {        /**         * will kick out 20 as the limit for long         */        boolean foundLimit = false;        int test = 10;        while (!foundLimit) {            try {                double x = MathUtils.factorial(test);            } catch (ArithmeticException ex) {                foundLimit = true;                System.out.println                    ("largest n for factorial = " + (test - 1) );            }            test++;        }       /**        * will kick out 170 as the limit for double        */        foundLimit = false;        test = 10;        while (!foundLimit) {            double x = MathUtils.factorialDouble(test);            if (Double.isInfinite(x)) {                foundLimit = true;                System.out.println                    ("largest n for factorialDouble = " + (test - 1) );            }            test++;        }    }    /**     * Exact direct multiplication implementation to test against     */    private long factorial(int n) {        long result = 1;        for (int i = 2; i <= n; i++) {            result *= i;        }        return result;    }    public void testSignDouble() {        double delta = 0.0 ;        assertEquals( 1.0, MathUtils.indicator( 2.0 ), delta ) ;        assertEquals( -1.0, MathUtils.indicator( -2.0 ), delta ) ;    }    public void testSignFloat() {        float delta = 0.0F ;        assertEquals( 1.0F, MathUtils.indicator( 2.0F ), delta ) ;        assertEquals( -1.0F, MathUtils.indicator( -2.0F ), delta ) ;    }    public void testSignByte() {        assertEquals( (byte)1, MathUtils.indicator( (byte)2 ) ) ;        assertEquals( (byte)(-1), MathUtils.indicator( (byte)(-2) ) ) ;    }    public void testSignShort() {        assertEquals( (short)1, MathUtils.indicator( (short)2 ) ) ;        assertEquals( (short)(-1), MathUtils.indicator( (short)(-2) ) ) ;    }    public void testSignInt() {        assertEquals( (int)1, MathUtils.indicator( (int)(2) ) ) ;        assertEquals( (int)(-1), MathUtils.indicator( (int)(-2) ) ) ;    }    public void testSignLong() {        assertEquals( 1L, MathUtils.indicator( 2L ) ) ;        assertEquals( -1L, MathUtils.indicator( -2L ) ) ;    }       public void testIndicatorDouble() {        double delta = 0.0 ;        assertEquals( 1.0, MathUtils.indicator( 2.0 ), delta ) ;        assertEquals( 1.0, MathUtils.indicator( 0.0 ), delta ) ;        assertEquals( -1.0, MathUtils.indicator( -2.0 ), delta ) ;    }        public void testIndicatorFloat() {        float delta = 0.0F ;        assertEquals( 1.0F, MathUtils.indicator( 2.0F ), delta ) ;        assertEquals( 1.0F, MathUtils.indicator( 0.0F ), delta ) ;        assertEquals( -1.0F, MathUtils.indicator( -2.0F ), delta ) ;    }        public void testIndicatorByte() {        assertEquals( (byte)1, MathUtils.indicator( (byte)2 ) ) ;        assertEquals( (byte)1, MathUtils.indicator( (byte)0 ) ) ;        assertEquals( (byte)(-1), MathUtils.indicator( (byte)(-2) ) ) ;    }        public void testIndicatorShort() {        assertEquals( (short)1, MathUtils.indicator( (short)2 ) ) ;        assertEquals( (short)1, MathUtils.indicator( (short)0 ) ) ;        assertEquals( (short)(-1), MathUtils.indicator( (short)(-2) ) ) ;    }        public void testIndicatorInt() {        assertEquals( (int)1, MathUtils.indicator( (int)(2) ) ) ;        assertEquals( (int)1, MathUtils.indicator( (int)(0) ) ) ;        assertEquals( (int)(-1), MathUtils.indicator( (int)(-2) ) ) ;    }        public void testIndicatorLong() {        assertEquals( 1L, MathUtils.indicator( 2L ) ) ;        assertEquals( 1L, MathUtils.indicator( 0L ) ) ;        assertEquals( -1L, MathUtils.indicator( -2L ) ) ;    }        public void testCosh() {        double x = 3.0;        double expected = 10.06766;        assertEquals(expected, MathUtils.cosh(x), 1.0e-5);    }           public void testSinh() {        double x = 3.0;        double expected = 10.01787;        assertEquals(expected, MathUtils.sinh(x), 1.0e-5);    }           public void testCoshNaN() {        assertTrue(Double.isNaN(MathUtils.cosh(Double.NaN)));    }           public void testSinhNaN() {        assertTrue(Double.isNaN(MathUtils.sinh(Double.NaN)));    }         public void testEquals() {        double[] testArray = {Double.NaN, Double.POSITIVE_INFINITY,                 Double.NEGATIVE_INFINITY, 1d, 0d};        for (int i = 0; i < testArray.length; i++) {            for (int j = 0; j < testArray.length; j ++) {                if (i == j) {                    assertTrue(MathUtils.equals(testArray[i], testArray[j]));                    assertTrue(MathUtils.equals(testArray[j], testArray[i]));                } else {                    assertTrue(!MathUtils.equals(testArray[i], testArray[j]));                    assertTrue(!MathUtils.equals(testArray[j], testArray[i]));                }            }        }     }        public void testHash() {        double[] testArray = {Double.NaN, Double.POSITIVE_INFINITY,                 Double.NEGATIVE_INFINITY, 1d, 0d, 1E-14, (1 + 1E-14),                 Double.MIN_VALUE, Double.MAX_VALUE};        for (int i = 0; i < testArray.length; i++) {            for (int j = 0; j < testArray.length; j ++) {                if (i == j) {                    assertEquals(MathUtils.hash(testArray[i]), MathUtils.hash(testArray[j]));                    assertEquals(MathUtils.hash(testArray[j]), MathUtils.hash(testArray[i]));                } else {                    assertTrue(MathUtils.hash(testArray[i]) != MathUtils.hash(testArray[j]));                    assertTrue(MathUtils.hash(testArray[j]) != MathUtils.hash(testArray[i]));                }            }        }     }        public void testGcd() {        int a = 30;        int b = 50;        int c = 77;        assertEquals(0, MathUtils.gcd(0, 0));                assertEquals(b, MathUtils.gcd( 0,  b));        assertEquals(a, MathUtils.gcd( a,  0));        assertEquals(b, MathUtils.gcd( 0, -b));        assertEquals(a, MathUtils.gcd(-a,  0));                assertEquals(10, MathUtils.gcd( a,  b));        assertEquals(10, MathUtils.gcd(-a,  b));        assertEquals(10, MathUtils.gcd( a, -b));        assertEquals(10, MathUtils.gcd(-a, -b));                assertEquals(1, MathUtils.gcd( a,  c));        assertEquals(1, MathUtils.gcd(-a,  c));        assertEquals(1, MathUtils.gcd( a, -c));        assertEquals(1, MathUtils.gcd(-a, -c));    }        public void testLcm() {        int a = 30;        int b = 50;        int c = 77;                assertEquals(0, MathUtils.lcm(0, b));        assertEquals(0, MathUtils.lcm(a, 0));        assertEquals(b, MathUtils.lcm(1, b));        assertEquals(a, MathUtils.lcm(a, 1));        assertEquals(150, MathUtils.lcm(a, b));        assertEquals(150, MathUtils.lcm(-a, b));        assertEquals(150, MathUtils.lcm(a, -b));        assertEquals(2310, MathUtils.lcm(a, c));                try {            MathUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected        }    }    public void testRoundFloat() {        float x = 1.234567890f;        assertEquals(1.23f, MathUtils.round(x, 2), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4), 0.0);                // BZ 35904        assertEquals(30.1f, MathUtils.round(30.095f, 2), 0.0f);        assertEquals(30.1f, MathUtils.round(30.095f, 1), 0.0f);        assertEquals(50.09f,  MathUtils.round(50.085f, 2), 0.0f);        assertEquals(50.19f,  MathUtils.round(50.185f, 2), 0.0f);        assertEquals(50.01f,  MathUtils.round(50.005f, 2), 0.0f);        assertEquals(30.01f,  MathUtils.round(30.005f, 2), 0.0f);        assertEquals(30.65f,  MathUtils.round(30.645f, 2), 0.0f);                assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);                assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);                assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);                assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.236f, MathUtils.round(1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.236f, MathUtils.round(-1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);                assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.235f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.235f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);                assertEquals(-1.23f, MathUtils.round(-1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);        assertEquals(1.23f, MathUtils.round(1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);                try {            MathUtils.round(1.234f, 2, BigDecimal.ROUND_UNNECESSARY);            fail();        } catch (ArithmeticException ex) {            // success        }                assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);                try {            MathUtils.round(1.234f, 2, 1923);            fail();        } catch (IllegalArgumentException ex) {            // success        }                // special values        TestUtils.assertEquals(Float.NaN, MathUtils.round(Float.NaN, 2), 0.0f);        assertEquals(0.0f, MathUtils.round(0.0f, 2), 0.0f);        assertEquals(Float.POSITIVE_INFINITY, MathUtils.round(Float.POSITIVE_INFINITY, 2), 0.0f);        assertEquals(Float.NEGATIVE_INFINITY, MathUtils.round(Float.NEGATIVE_INFINITY, 2), 0.0f);    }        public void testNextAfterSpecialCases() {        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.NEGATIVE_INFINITY, 0)));        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.POSITIVE_INFINITY, 0)));        assertTrue(Double.isNaN(MathUtils.nextAfter(Double.NaN, 0)));        assertTrue(Double.isInfinite(MathUtils.nextAfter( Double.MAX_VALUE, Double.POSITIVE_INFINITY)));        assertTrue(Double.isInfinite(MathUtils.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY)));        assertEquals( Double.MIN_VALUE, MathUtils.nextAfter(0,  1), 0);        assertEquals(-Double.MIN_VALUE, MathUtils.nextAfter(0, -1), 0);        assertEquals(0, MathUtils.nextAfter( Double.MIN_VALUE, -1), 0);        assertEquals(0, MathUtils.nextAfter(-Double.MIN_VALUE,  1), 0);    }        public void testNextAfter() {        // 0x402fffffffffffff 0x404123456789abcd -> 4030000000000000        assertEquals(16.0, MathUtils.nextAfter(15.999999999999998, 34.27555555555555), 0.0);        // 0xc02fffffffffffff 0x404123456789abcd -> c02ffffffffffffe        assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 34.27555555555555), 0.0);        // 0x402fffffffffffff 0x400123456789abcd -> 402ffffffffffffe        assertEquals(15.999999999999996, MathUtils.nextAfter(15.999999999999998, 2.142222222222222), 0.0);        // 0xc02fffffffffffff 0x400123456789abcd -> c02ffffffffffffe        assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 2.142222222222222), 0.0);        // 0x4020000000000000 0x404123456789abcd -> 4020000000000001        assertEquals(8.000000000000002, MathUtils.nextAfter(8.0, 34.27555555555555), 0.0);        // 0xc020000000000000 0x404123456789abcd -> c01fffffffffffff        assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 34.27555555555555), 0.0);        // 0x4020000000000000 0x400123456789abcd -> 401fffffffffffff        assertEquals(7.999999999999999, MathUtils.nextAfter(8.0, 2.142222222222222), 0.0);        // 0xc020000000000000 0x400123456789abcd -> c01fffffffffffff        assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 2.142222222222222), 0.0);        // 0x3f2e43753d36a223 0x3f2e43753d36a224 -> 3f2e43753d36a224        assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0);        // 0x3f2e43753d36a223 0x3f2e43753d36a223 -> 3f2e43753d36a224        assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);        // 0x3f2e43753d36a223 0x3f2e43753d36a222 -> 3f2e43753d36a222        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);        // 0x3f2e43753d36a223 0xbf2e43753d36a224 -> 3f2e43753d36a222        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0);        // 0x3f2e43753d36a223 0xbf2e43753d36a223 -> 3f2e43753d36a222        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);        // 0x3f2e43753d36a223 0xbf2e43753d36a222 -> 3f2e43753d36a222        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);        // 0xbf2e43753d36a223 0x3f2e43753d36a224 -> bf2e43753d36a222        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0);        // 0xbf2e43753d36a223 0x3f2e43753d36a223 -> bf2e43753d36a222        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);        // 0xbf2e43753d36a223 0x3f2e43753d36a222 -> bf2e43753d36a222        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);        // 0xbf2e43753d36a223 0xbf2e43753d36a224 -> bf2e43753d36a224        assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0);        // 0xbf2e43753d36a223 0xbf2e43753d36a223 -> bf2e43753d36a224        assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);        // 0xbf2e43753d36a223 0xbf2e43753d36a222 -> bf2e43753d36a222        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);    }    public void testRoundDouble() {        double x = 1.234567890;        assertEquals(1.23, MathUtils.round(x, 2), 0.0);        assertEquals(1.235, MathUtils.round(x, 3), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4), 0.0);                // JIRA MATH-151        assertEquals(39.25,MathUtils.round(39.245, 2), 0.0);        assertEquals(39.24,MathUtils.round(39.245, 2,                 BigDecimal.ROUND_DOWN), 0.0);        double xx = 39.0;        xx = xx + 245d/1000d;        assertEquals(39.25,MathUtils.round(xx, 2), 0.0);                // BZ 35904        assertEquals(30.1d, MathUtils.round(30.095d, 2), 0.0d);        assertEquals(30.1d, MathUtils.round(30.095d, 1), 0.0d);        assertEquals(33.1d, MathUtils.round(33.095d, 1), 0.0d);        assertEquals(33.1d, MathUtils.round(33.095d, 2), 0.0d);        assertEquals(50.09d,  MathUtils.round(50.085d, 2), 0.0d);        assertEquals(50.19d,  MathUtils.round(50.185d, 2), 0.0d);        assertEquals(50.01d,  MathUtils.round(50.005d, 2), 0.0d);        assertEquals(30.01d,  MathUtils.round(30.005d, 2), 0.0d);        assertEquals(30.65d,  MathUtils.round(30.645d, 2), 0.0d);                assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);                assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);                assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);                assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.236, MathUtils.round(1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.236, MathUtils.round(-1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);                assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.235, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.235, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);                assertEquals(-1.23, MathUtils.round(-1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);        assertEquals(1.23, MathUtils.round(1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);                try {            MathUtils.round(1.234, 2, BigDecimal.ROUND_UNNECESSARY);            fail();        } catch (ArithmeticException ex) {            // success        }                assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);                try {            MathUtils.round(1.234, 2, 1923);            fail();        } catch (IllegalArgumentException ex) {            // success        }        // MATH-151        assertEquals(39.25, MathUtils.round(39.245, 2, BigDecimal.ROUND_HALF_UP), 0.0);             // special values        TestUtils.assertEquals(Double.NaN, MathUtils.round(Double.NaN, 2), 0.0);        assertEquals(0.0, MathUtils.round(0.0, 2), 0.0);        assertEquals(Double.POSITIVE_INFINITY, MathUtils.round(Double.POSITIVE_INFINITY, 2), 0.0);        assertEquals(Double.NEGATIVE_INFINITY, MathUtils.round(Double.NEGATIVE_INFINITY, 2), 0.0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import java.math.BigDecimal;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class DefaultTransformerTest extends TestCase {    /**     *      */    public void testTransformDouble() throws Exception {        double expected = 1.0;        Double input = new Double(expected);        DefaultTransformer t = new DefaultTransformer();        assertEquals(expected, t.transform(input), 1.0e-4);    }        /**     *      */    public void testTransformNull(){        DefaultTransformer t = new DefaultTransformer();        try {            t.transform(null);            fail("Expection MathException");        } catch (MathException e) {            // expected        }    }        /**     *      */    public void testTransformInteger() throws Exception {        double expected = 1.0;        Integer input = new Integer(1);        DefaultTransformer t = new DefaultTransformer();        assertEquals(expected, t.transform(input), 1.0e-4);    }                /**     *      */    public void testTransformBigDecimal() throws Exception {        double expected = 1.0;        BigDecimal input = new BigDecimal("1.0");        DefaultTransformer t = new DefaultTransformer();        assertEquals(expected, t.transform(input), 1.0e-4);    }                /**     *      */    public void testTransformString() throws Exception {        double expected = 1.0;        String input = "1.0";        DefaultTransformer t = new DefaultTransformer();        assertEquals(expected, t.transform(input), 1.0e-4);    }        /**     *      */    public void testTransformObject(){        Boolean input = Boolean.TRUE;        DefaultTransformer t = new DefaultTransformer();        try {            t.transform(input);            fail("Expecting MathException");        } catch (MathException e) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class TransformerMapTest extends TestCase {    /**     *      */    public void testPutTransformer(){        NumberTransformer expected = new DefaultTransformer();                TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertEquals(expected, map.getTransformer(TransformerMapTest.class));    }        /**     *      */    public void testContainsClass(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.containsClass(TransformerMapTest.class));    }        /**     *      */    public void testContainsTransformer(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.containsTransformer(expected));    }    /**     *      */    public void testRemoveTransformer(){        NumberTransformer expected = new DefaultTransformer();                TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.containsClass(TransformerMapTest.class));        assertTrue(map.containsTransformer(expected));        map.removeTransformer(TransformerMapTest.class);        assertFalse(map.containsClass(TransformerMapTest.class));        assertFalse(map.containsTransformer(expected));    }    /**     *      */    public void testClear(){        NumberTransformer expected = new DefaultTransformer();                TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.containsClass(TransformerMapTest.class));        map.clear();        assertFalse(map.containsClass(TransformerMapTest.class));    }        /**     *      */    public void testClasses(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.classes().contains(TransformerMapTest.class));    }        /**     *      */    public void testTransformers(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.transformers().contains(expected));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;/** * @version $Revision$ $Date$ */public class TestBean {    private Double x = new Double(1.0);        private String y = "1.0";        private Double z = new Double(2.0);        /**     *      */    public Double getX() {        return x;    }    /**     *      */    public String getY() {        return y;    }    /**     *      */    public void setX(Double double1) {        x = double1;    }    /**     *      */    public void setY(String string) {        y = string;    }        /**     *      */    public Double getZ() {        throw new RuntimeException();    }    /**     *      */    public void setZ(Double double1) {        z = double1;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.transform;import org.apache.commons.math.analysis.*;import org.apache.commons.math.complex.*;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for fast Fourier transformer. * <p> * FFT algorithm is exact, the small tolerance number is used only * to account for round-off errors. *  * @version $Revision$ $Date$  */public final class FastFourierTransformerTest extends TestCase {    /**     * Test of transformer for the ad hoc data taken from Mathematica.     */    public void testAdHocData() throws MathException {        FastFourierTransformer transformer = new FastFourierTransformer();        Complex result[]; double tolerance = 1E-12;        double x[] = {1.3, 2.4, 1.7, 4.1, 2.9, 1.7, 5.1, 2.7};        Complex y[] = {            new Complex(21.9, 0.0),            new Complex(-2.09497474683058, 1.91507575950825),            new Complex(-2.6, 2.7),            new Complex(-1.10502525316942, -4.88492424049175),            new Complex(0.1, 0.0),            new Complex(-1.10502525316942, 4.88492424049175),            new Complex(-2.6, -2.7),            new Complex(-2.09497474683058, -1.91507575950825)};        result = transformer.transform(x);        for (int i = 0; i < result.length; i++) {            assertEquals(y[i].getReal(), result[i].getReal(), tolerance);            assertEquals(y[i].getImaginary(), result[i].getImaginary(), tolerance);        }        result = transformer.inversetransform(y);        for (int i = 0; i < result.length; i++) {            assertEquals(x[i], result[i].getReal(), tolerance);            assertEquals(0.0, result[i].getImaginary(), tolerance);        }        double x2[] = {10.4, 21.6, 40.8, 13.6, 23.2, 32.8, 13.6, 19.2};        transformer.scaleArray(x2, 1.0 / Math.sqrt(x2.length));        Complex y2[] = y;        result = transformer.transform2(y2);        for (int i = 0; i < result.length; i++) {            assertEquals(x2[i], result[i].getReal(), tolerance);            assertEquals(0.0, result[i].getImaginary(), tolerance);        }        result = transformer.inversetransform2(x2);        for (int i = 0; i < result.length; i++) {            assertEquals(y2[i].getReal(), result[i].getReal(), tolerance);            assertEquals(y2[i].getImaginary(), result[i].getImaginary(), tolerance);        }    }    /**     * Test of transformer for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        FastFourierTransformer transformer = new FastFourierTransformer();        Complex result[]; int N = 1 << 8;        double min, max, tolerance = 1E-12;        min = 0.0; max = 2.0 * Math.PI;        result = transformer.transform(f, min, max, N);        assertEquals(0.0, result[1].getReal(), tolerance);        assertEquals(-(N >> 1), result[1].getImaginary(), tolerance);        assertEquals(0.0, result[N-1].getReal(), tolerance);        assertEquals(N >> 1, result[N-1].getImaginary(), tolerance);        for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {            assertEquals(0.0, result[i].getReal(), tolerance);            assertEquals(0.0, result[i].getImaginary(), tolerance);        }        min = -Math.PI; max = Math.PI;        result = transformer.inversetransform(f, min, max, N);        assertEquals(0.0, result[1].getReal(), tolerance);        assertEquals(-0.5, result[1].getImaginary(), tolerance);        assertEquals(0.0, result[N-1].getReal(), tolerance);        assertEquals(0.5, result[N-1].getImaginary(), tolerance);        for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {            assertEquals(0.0, result[i].getReal(), tolerance);            assertEquals(0.0, result[i].getImaginary(), tolerance);        }    }    /**     * Test of parameters for the transformer.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        FastFourierTransformer transformer = new FastFourierTransformer();        try {            // bad interval            transformer.transform(f, 1, -1, 64);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 0);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 100);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.transform;import org.apache.commons.math.analysis.*;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for fast cosine transformer. * <p> * FCT algorithm is exact, the small tolerance number is used only * to account for round-off errors. *  * @version $Revision$ $Date$  */public final class FastCosineTransformerTest extends TestCase {    /**     * Test of transformer for the ad hoc data.     */    public void testAdHocData() throws MathException {        FastCosineTransformer transformer = new FastCosineTransformer();        double result[], tolerance = 1E-12;        double x[] = { 0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0 };        double y[] = { 172.0, -105.096569476353, 27.3137084989848,                      -12.9593152353742, 8.0, -5.78585076868676,                       4.68629150101524, -4.15826451958632, 4.0 };        result = transformer.transform(x);        for (int i = 0; i < result.length; i++) {            assertEquals(y[i], result[i], tolerance);        }        result = transformer.inversetransform(y);        for (int i = 0; i < result.length; i++) {            assertEquals(x[i], result[i], tolerance);        }        FastFourierTransformer.scaleArray(x, Math.sqrt(0.5 * (x.length-1)));        result = transformer.transform2(y);        for (int i = 0; i < result.length; i++) {            assertEquals(x[i], result[i], tolerance);        }        result = transformer.inversetransform2(x);        for (int i = 0; i < result.length; i++) {            assertEquals(y[i], result[i], tolerance);        }    }    /**     * Test of transformer for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        FastCosineTransformer transformer = new FastCosineTransformer();        double min, max, result[], tolerance = 1E-12; int N = 9;        double expected[] = { 0.0, 3.26197262739567, 0.0,                             -2.17958042710327, 0.0, -0.648846697642915,                              0.0, -0.433545502649478, 0.0 };        min = 0.0; max = 2.0 * Math.PI * N / (N-1);        result = transformer.transform(f, min, max, N);        for (int i = 0; i < N; i++) {            assertEquals(expected[i], result[i], tolerance);        }        min = -Math.PI; max = Math.PI * (N+1) / (N-1);        result = transformer.transform(f, min, max, N);        for (int i = 0; i < N; i++) {            assertEquals(-expected[i], result[i], tolerance);        }    }    /**     * Test of parameters for the transformer.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        FastCosineTransformer transformer = new FastCosineTransformer();        try {            // bad interval            transformer.transform(f, 1, -1, 65);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 1);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 64);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.transform;import org.apache.commons.math.analysis.*;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for fast sine transformer. * <p> * FST algorithm is exact, the small tolerance number is used only * to account for round-off errors. *  * @version $Revision$ $Date$  */public final class FastSineTransformerTest extends TestCase {    /**     * Test of transformer for the ad hoc data.     */    public void testAdHocData() throws MathException {        FastSineTransformer transformer = new FastSineTransformer();        double result[], tolerance = 1E-12;        double x[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 };        double y[] = { 0.0, 20.1093579685034, -9.65685424949238,                       5.98642305066196, -4.0, 2.67271455167720,                      -1.65685424949238, 0.795649469518633 };        result = transformer.transform(x);        for (int i = 0; i < result.length; i++) {            assertEquals(y[i], result[i], tolerance);        }        result = transformer.inversetransform(y);        for (int i = 0; i < result.length; i++) {            assertEquals(x[i], result[i], tolerance);        }        FastFourierTransformer.scaleArray(x, Math.sqrt(x.length / 2.0));        result = transformer.transform2(y);        for (int i = 0; i < result.length; i++) {            assertEquals(x[i], result[i], tolerance);        }        result = transformer.inversetransform2(x);        for (int i = 0; i < result.length; i++) {            assertEquals(y[i], result[i], tolerance);        }    }    /**     * Test of transformer for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        FastSineTransformer transformer = new FastSineTransformer();        double min, max, result[], tolerance = 1E-12; int N = 1 << 8;        min = 0.0; max = 2.0 * Math.PI;        result = transformer.transform(f, min, max, N);        assertEquals(N >> 1, result[2], tolerance);        for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {            assertEquals(0.0, result[i], tolerance);        }        min = -Math.PI; max = Math.PI;        result = transformer.transform(f, min, max, N);        assertEquals(-(N >> 1), result[2], tolerance);        for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {            assertEquals(0.0, result[i], tolerance);        }    }    /**     * Test of parameters for the transformer.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        FastSineTransformer transformer = new FastSineTransformer();        try {            // bad interval            transformer.transform(f, 1, -1, 64);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 0);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 100);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.special;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class BetaTest extends TestCase {    /**     * Constructor for BetaTest.     * @param name     */    public BetaTest(String name) {        super(name);    }    private void testRegularizedBeta(double expected, double x, double a,        double b)    {        try {            double actual = Beta.regularizedBeta(x, a, b);            TestUtils.assertEquals(expected, actual, 10e-5);        } catch(MathException ex){            fail(ex.getMessage());        }    }    private void testLogBeta(double expected, double a, double b) {        double actual = Beta.logBeta(a, b);        TestUtils.assertEquals(expected, actual, 10e-5);    }    public void testRegularizedBetaNanPositivePositive() {        testRegularizedBeta(Double.NaN, Double.NaN, 1.0, 1.0);    }    public void testRegularizedBetaPositiveNanPositive() {        testRegularizedBeta(Double.NaN, 0.5, Double.NaN, 1.0);    }    public void testRegularizedBetaPositivePositiveNan() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, Double.NaN);    }        public void testRegularizedBetaNegativePositivePositive() {        testRegularizedBeta(Double.NaN, -0.5, 1.0, 2.0);    }        public void testRegularizedBetaPositiveNegativePositive() {        testRegularizedBeta(Double.NaN, 0.5, -1.0, 2.0);    }        public void testRegularizedBetaPositivePositiveNegative() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, -2.0);    }        public void testRegularizedBetaZeroPositivePositive() {        testRegularizedBeta(0.0, 0.0, 1.0, 2.0);    }        public void testRegularizedBetaPositiveZeroPositive() {        testRegularizedBeta(Double.NaN, 0.5, 0.0, 2.0);    }        public void testRegularizedBetaPositivePositiveZero() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, 0.0);    }        public void testRegularizedBetaPositivePositivePositive() {        testRegularizedBeta(0.75, 0.5, 1.0, 2.0);    }        public void testLogBetaNanPositive() {        testLogBeta(Double.NaN, Double.NaN, 2.0);    }        public void testLogBetaPositiveNan() {        testLogBeta(Double.NaN, 1.0, Double.NaN);    }        public void testLogBetaNegativePositive() {        testLogBeta(Double.NaN, -1.0, 2.0);    }        public void testLogBetaPositiveNegative() {        testLogBeta(Double.NaN, 1.0, -2.0);    }        public void testLogBetaZeroPositive() {        testLogBeta(Double.NaN, 0.0, 2.0);    }        public void testLogBetaPositiveZero() {        testLogBeta(Double.NaN, 1.0, 0.0);    }        public void testLogBetaPositivePositive() {        testLogBeta(-0.693147, 1.0, 2.0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.special;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class GammaTest extends TestCase {    /**     * Constructor for BetaTest.     * @param name     */    public GammaTest(String name) {        super(name);    }    private void testRegularizedGamma(double expected, double a, double x) {        try {            double actualP = Gamma.regularizedGammaP(a, x);            double actualQ = Gamma.regularizedGammaQ(a, x);            TestUtils.assertEquals(expected, actualP, 10e-5);            TestUtils.assertEquals(actualP, 1.0 - actualQ, 10e-5);        } catch(MathException ex){            fail(ex.getMessage());        }    }    private void testLogGamma(double expected, double x) {        double actual = Gamma.logGamma(x);        TestUtils.assertEquals(expected, actual, 10e-5);    }    public void testRegularizedGammaNanPositive() {        testRegularizedGamma(Double.NaN, Double.NaN, 1.0);    }    public void testRegularizedGammaPositiveNan() {        testRegularizedGamma(Double.NaN, 1.0, Double.NaN);    }        public void testRegularizedGammaNegativePositive() {        testRegularizedGamma(Double.NaN, -1.5, 1.0);    }        public void testRegularizedGammaPositiveNegative() {        testRegularizedGamma(Double.NaN, 1.0, -1.0);    }        public void testRegularizedGammaZeroPositive() {        testRegularizedGamma(Double.NaN, 0.0, 1.0);    }        public void testRegularizedGammaPositiveZero() {        testRegularizedGamma(0.0, 1.0, 0.0);    }        public void testRegularizedGammaPositivePositive() {        testRegularizedGamma(0.632121, 1.0, 1.0);    }        public void testLogGammaNan() {        testLogGamma(Double.NaN, Double.NaN);    }        public void testLogGammaNegative() {        testLogGamma(Double.NaN, -1.0);    }        public void testLogGammaZero() {        testLogGamma(Double.NaN, 0.0);    }        public void testLogGammaPositive() {        testLogGamma(0.693147, 3.0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.apache.commons.math.special;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class ErfTest extends TestCase {    public void testErf0() throws MathException {        double actual = Erf.erf(0.0);        double expected = 0.0;        assertEquals(expected, actual, 1.0e-5);    }    public void testErf1960() throws MathException {        double x = 1.960 / Math.sqrt(2.0);        double actual = Erf.erf(x);        double expected = 0.95;        assertEquals(expected, actual, 1.0e-5);        actual = Erf.erf(-x);        expected = -expected;        assertEquals(expected, actual, 1.0e-5);    }    public void testErf2576() throws MathException {        double x = 2.576 / Math.sqrt(2.0);        double actual = Erf.erf(x);        double expected = 0.99;        assertEquals(expected, actual, 1.0e-5);            actual = Erf.erf(-x);        expected = -expected;        assertEquals(expected, actual, 1.0e-5);    }    public void testErf2807() throws MathException {        double x = 2.807 / Math.sqrt(2.0);        double actual = Erf.erf(x);        double expected = 0.995;        assertEquals(expected, actual, 1.0e-5);                actual = Erf.erf(-x);        expected = -expected;        assertEquals(expected, actual, 1.0e-5);    }    public void testErf3291() throws MathException {        double x = 3.291 / Math.sqrt(2.0);        double actual = Erf.erf(x);        double expected = 0.999;        assertEquals(expected, actual, 1.0e-5);                actual = Erf.erf(-x);        expected = -expected;        assertEquals(expected, actual, 1.0e-5);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for Muller solver. * <p> * Muller's method converges almost quadratically near roots, but it can * be very slow in regions far away from zeros. Test runs show that for * reasonably good initial values, for a default absolute accuracy of 1E-6, * it generally takes 5 to 10 iterations for the solver to converge. * <p> * Tests for the exponential function illustrate the situations where * Muller solver performs poorly. *  * @version $Revision$ $Date$  */public final class MullerSolverTest extends TestCase {    /**     * Test of solver for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new MullerSolver(f);        double min, max, expected, result, tolerance;        min = 3.0; max = 4.0; expected = Math.PI;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);        min = -1.0; max = 1.5; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the sine function using solve2().     */    public void testSinFunction2() throws MathException {        UnivariateRealFunction f = new SinFunction();        MullerSolver solver = new MullerSolver(f);        double min, max, expected, result, tolerance;        min = 3.0; max = 4.0; expected = Math.PI;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(min, max);        assertEquals(expected, result, tolerance);        min = -1.0; max = 1.5; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function.     */    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new MullerSolver(f);        double min, max, expected, result, tolerance;        min = -0.4; max = 0.2; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);        min = 0.75; max = 1.5; expected = 1.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);        min = -0.9; max = -0.2; expected = -0.5;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function using solve2().     */    public void testQuinticFunction2() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        MullerSolver solver = new MullerSolver(f);        double min, max, expected, result, tolerance;        min = -0.4; max = 0.2; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(min, max);        assertEquals(expected, result, tolerance);        min = 0.75; max = 1.5; expected = 1.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(min, max);        assertEquals(expected, result, tolerance);        min = -0.9; max = -0.2; expected = -0.5;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the exponential function.     * <p>     * It takes 10 to 15 iterations for the last two tests to converge.     * In fact, if not for the bisection alternative, the solver would     * exceed the default maximal iteration of 100.     */    public void testExpm1Function() throws MathException {        UnivariateRealFunction f = new Expm1Function();        UnivariateRealSolver solver = new MullerSolver(f);        double min, max, expected, result, tolerance;        min = -1.0; max = 2.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);        min = -20.0; max = 10.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);        min = -50.0; max = 100.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the exponential function using solve2().     * <p>     * It takes 25 to 50 iterations for the last two tests to converge.     */    public void testExpm1Function2() throws MathException {        UnivariateRealFunction f = new Expm1Function();        MullerSolver solver = new MullerSolver(f);        double min, max, expected, result, tolerance;        min = -1.0; max = 2.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(min, max);        assertEquals(expected, result, tolerance);        min = -20.0; max = 10.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(min, max);        assertEquals(expected, result, tolerance);        min = -50.0; max = 100.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the solver.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new MullerSolver(f);        try {            // bad interval            solver.solve(1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // no bracketing            solver.solve(2, 3);            fail("Expecting IllegalArgumentException - no bracketing");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for Lagrange form of polynomial function. * <p> * We use n+1 points to interpolate a polynomial of degree n. This should * give us the exact same polynomial as result. Thus we can use a very * small tolerance to account only for round-off errors. * * @version $Revision$ $Date$  */public final class PolynomialFunctionLagrangeFormTest extends TestCase {    /**     * Test of polynomial for the linear function.     */    public void testLinearFunction() throws MathException {        PolynomialFunctionLagrangeForm p;        double c[], z, expected, result, tolerance = 1E-12;        // p(x) = 1.5x - 4        double x[] = { 0.0, 3.0 };        double y[] = { -4.0, 0.5 };        p = new PolynomialFunctionLagrangeForm(x, y);        z = 2.0; expected = -1.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 4.5; expected = 2.75; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 6.0; expected = 5.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(1, p.degree());        c = p.getCoefficients();        assertEquals(2, c.length);        assertEquals(-4.0, c[0], tolerance);        assertEquals(1.5, c[1], tolerance);    }    /**     * Test of polynomial for the quadratic function.     */    public void testQuadraticFunction() throws MathException {        PolynomialFunctionLagrangeForm p;        double c[], z, expected, result, tolerance = 1E-12;        // p(x) = 2x^2 + 5x - 3 = (2x - 1)(x + 3)        double x[] = { 0.0, -1.0, 0.5 };        double y[] = { -3.0, -6.0, 0.0 };        p = new PolynomialFunctionLagrangeForm(x, y);        z = 1.0; expected = 4.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 2.5; expected = 22.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = -2.0; expected = -5.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(2, p.degree());        c = p.getCoefficients();        assertEquals(3, c.length);        assertEquals(-3.0, c[0], tolerance);        assertEquals(5.0, c[1], tolerance);        assertEquals(2.0, c[2], tolerance);    }    /**     * Test of polynomial for the quintic function.     */    public void testQuinticFunction() throws MathException {        PolynomialFunctionLagrangeForm p;        double c[], z, expected, result, tolerance = 1E-12;        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x = x(x^2 - 1)(x + 2)(x - 3)        double x[] = { 1.0, -1.0, 2.0, 3.0, -3.0, 0.5 };        double y[] = { 0.0, 0.0, -24.0, 0.0, -144.0, 2.34375 };        p = new PolynomialFunctionLagrangeForm(x, y);        z = 0.0; expected = 0.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = -2.0; expected = 0.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 4.0; expected = 360.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(5, p.degree());        c = p.getCoefficients();        assertEquals(6, c.length);        assertEquals(0.0, c[0], tolerance);        assertEquals(6.0, c[1], tolerance);        assertEquals(1.0, c[2], tolerance);        assertEquals(-7.0, c[3], tolerance);        assertEquals(-1.0, c[4], tolerance);        assertEquals(1.0, c[5], tolerance);    }    /**     * Test of parameters for the polynomial.     */    public void testParameters() throws Exception {        PolynomialFunctionLagrangeForm p;        try {            // bad input array length            double x[] = { 1.0 };            double y[] = { 2.0 };            p = new PolynomialFunctionLagrangeForm(x, y);            fail("Expecting IllegalArgumentException - bad input array length");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // mismatch input arrays            double x[] = { 1.0, 2.0, 3.0, 4.0 };            double y[] = { 0.0, -4.0, -24.0 };            p = new PolynomialFunctionLagrangeForm(x, y);            fail("Expecting IllegalArgumentException - mismatch input arrays");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * * Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.apache.commons.math.analysis;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class UnivariateRealSolverFactoryImplTest extends TestCase {        /** solver factory */    private UnivariateRealSolverFactory factory;        /** function */    private DifferentiableUnivariateRealFunction function;    /**     * @throws java.lang.Exception     * @see junit.framework.TestCase#tearDown()     */    protected void setUp() throws Exception {        super.setUp();        factory = new UnivariateRealSolverFactoryImpl();        function = new SinFunction();    }        /**     * @throws java.lang.Exception     * @see junit.framework.TestCase#tearDown()     */    protected void tearDown() throws Exception {        factory = null;        function = null;        super.tearDown();    }    public void testNewBisectionSolverNull() {        try {            UnivariateRealSolver solver = factory.newBisectionSolver(null);            fail();        } catch(IllegalArgumentException ex) {            // success        }    }    public void testNewBisectionSolverValid() {        UnivariateRealSolver solver = factory.newBisectionSolver(function);        assertNotNull(solver);        assertTrue(solver instanceof BisectionSolver);    }    public void testNewNewtonSolverNull() {        try {            UnivariateRealSolver solver = factory.newNewtonSolver(null);            fail();        } catch(IllegalArgumentException ex) {            // success        }    }    public void testNewNewtonSolverValid() {        UnivariateRealSolver solver = factory.newNewtonSolver(function);        assertNotNull(solver);        assertTrue(solver instanceof NewtonSolver);    }    public void testNewBrentSolverNull() {        try {            UnivariateRealSolver solver = factory.newBrentSolver(null);            fail();        } catch(IllegalArgumentException ex) {            // success        }    }    public void testNewBrentSolverValid() {        UnivariateRealSolver solver = factory.newBrentSolver(function);        assertNotNull(solver);        assertTrue(solver instanceof BrentSolver);    }    public void testNewSecantSolverNull() {        try {            UnivariateRealSolver solver = factory.newSecantSolver(null);            fail();        } catch(IllegalArgumentException ex) {            // success        }    }    public void testNewSecantSolverValid() {        UnivariateRealSolver solver = factory.newSecantSolver(function);        assertNotNull(solver);        assertTrue(solver instanceof SecantSolver);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for Newton form of polynomial function. * <p> * The small tolerance number is used only to account for round-off errors. * * @version $Revision$ $Date$  */public final class PolynomialFunctionNewtonFormTest extends TestCase {    /**     * Test of polynomial for the linear function.     */    public void testLinearFunction() throws MathException {        PolynomialFunctionNewtonForm p;        double coefficients[], z, expected, result, tolerance = 1E-12;        // p(x) = 1.5x - 4 = 2 + 1.5(x-4)        double a[] = { 2.0, 1.5 };        double c[] = { 4.0 };        p = new PolynomialFunctionNewtonForm(a, c);        z = 2.0; expected = -1.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 4.5; expected = 2.75; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 6.0; expected = 5.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(1, p.degree());        coefficients = p.getCoefficients();        assertEquals(2, coefficients.length);        assertEquals(-4.0, coefficients[0], tolerance);        assertEquals(1.5, coefficients[1], tolerance);    }    /**     * Test of polynomial for the quadratic function.     */    public void testQuadraticFunction() throws MathException {        PolynomialFunctionNewtonForm p;        double coefficients[], z, expected, result, tolerance = 1E-12;        // p(x) = 2x^2 + 5x - 3 = 4 + 3(x-1) + 2(x-1)(x+2)        double a[] = { 4.0, 3.0, 2.0 };        double c[] = { 1.0, -2.0 };        p = new PolynomialFunctionNewtonForm(a, c);        z = 1.0; expected = 4.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 2.5; expected = 22.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = -2.0; expected = -5.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(2, p.degree());        coefficients = p.getCoefficients();        assertEquals(3, coefficients.length);        assertEquals(-3.0, coefficients[0], tolerance);        assertEquals(5.0, coefficients[1], tolerance);        assertEquals(2.0, coefficients[2], tolerance);    }    /**     * Test of polynomial for the quintic function.     */    public void testQuinticFunction() throws MathException {        PolynomialFunctionNewtonForm p;        double coefficients[], z, expected, result, tolerance = 1E-12;        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x        //      = 6x - 6x^2 -6x^2(x-1) + x^2(x-1)(x+1) + x^2(x-1)(x+1)(x-2)        double a[] = { 0.0, 6.0, -6.0, -6.0, 1.0, 1.0 };        double c[] = { 0.0, 0.0, 1.0, -1.0, 2.0 };        p = new PolynomialFunctionNewtonForm(a, c);        z = 0.0; expected = 0.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = -2.0; expected = 0.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 4.0; expected = 360.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(5, p.degree());        coefficients = p.getCoefficients();        assertEquals(6, coefficients.length);        assertEquals(0.0, coefficients[0], tolerance);        assertEquals(6.0, coefficients[1], tolerance);        assertEquals(1.0, coefficients[2], tolerance);        assertEquals(-7.0, coefficients[3], tolerance);        assertEquals(-1.0, coefficients[4], tolerance);        assertEquals(1.0, coefficients[5], tolerance);    }    /**     * Test of parameters for the polynomial.     */    public void testParameters() throws Exception {        PolynomialFunctionNewtonForm p;        try {            // bad input array length            double a[] = { 1.0 };            double c[] = { 2.0 };            p = new PolynomialFunctionNewtonForm(a, c);            fail("Expecting IllegalArgumentException - bad input array length");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // mismatch input arrays            double a[] = { 1.0, 2.0, 3.0, 4.0 };            double c[] = { 4.0, 3.0, 2.0, 1.0 };            p = new PolynomialFunctionNewtonForm(a, c);            fail("Expecting IllegalArgumentException - mismatch input arrays");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for Romberg integrator. * <p> * Romberg algorithm is very fast for good behavior integrand. Test runs * show that for a default relative accuracy of 1E-6, it generally takes * takes less than 5 iterations for the integral to converge. *  * @version $Revision$ $Date$  */public final class RombergIntegratorTest extends TestCase {    /**     * Test of integrator for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new RombergIntegrator(f);        double min, max, expected, result, tolerance;        min = 0; max = Math.PI; expected = 2;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(min, max);        assertEquals(expected, result, tolerance);        min = -Math.PI/3; max = 0; expected = -0.5;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of integrator for the quintic function.     */    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealIntegrator integrator = new RombergIntegrator(f);        double min, max, expected, result, tolerance;        min = 0; max = 1; expected = -1.0/48;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(min, max);        assertEquals(expected, result, tolerance);        min = 0; max = 0.5; expected = 11.0/768;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(min, max);        assertEquals(expected, result, tolerance);        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the integrator.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new RombergIntegrator(f);        try {            // bad interval            integrator.integrate(1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(5);            integrator.setMaximalIterationCount(4);            integrator.integrate(-1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(10);            integrator.setMaximalIterationCount(50);            integrator.integrate(-1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.ConvergenceException;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class UnivariateRealSolverUtilsTest extends TestCase {        protected UnivariateRealFunction sin = new SinFunction();        public void testSolveNull() throws MathException {        try {            UnivariateRealSolverUtils.solve(null, 0.0, 4.0);            fail();        } catch(IllegalArgumentException ex){            // success        }    }        public void testSolveBadParameters() throws MathException {        try { // bad endpoints            double x = UnivariateRealSolverUtils.solve(sin,0.0, 4.0, 4.0);         } catch (IllegalArgumentException ex) {            // expected        }            try { // bad accuracy            double x = UnivariateRealSolverUtils.solve(sin, 0.0, 4.0, 0.0);         } catch (IllegalArgumentException ex) {            // expected        }            }        public void testSolveSin() throws MathException {             double x = UnivariateRealSolverUtils.solve(sin, 1.0,                4.0);        assertEquals(Math.PI, x, 1.0e-4);    }        public void testSolveAccuracyNull()  throws MathException {        try {            double accuracy = 1.0e-6;            UnivariateRealSolverUtils.solve(null, 0.0, 4.0, accuracy);            fail();        } catch(IllegalArgumentException ex){            // success        }    }        public void testSolveAccuracySin() throws MathException {        double accuracy = 1.0e-6;        double x = UnivariateRealSolverUtils.solve(sin, 1.0,                4.0, accuracy);        assertEquals(Math.PI, x, accuracy);    }        public void testSolveNoRoot() throws MathException {        try {            double x = UnivariateRealSolverUtils.solve(sin, 1.0,                    1.5);              fail("Expecting IllegalArgumentException ");          } catch (IllegalArgumentException ex) {            // expected        }    }        public void testBracketSin() throws MathException {        double[] result = UnivariateRealSolverUtils.bracket(sin,                 0.0, -2.0, 2.0);        assertTrue(sin.value(result[0]) < 0);        assertTrue(sin.value(result[1]) > 0);    }        public void testBracketCornerSolution() throws MathException {        try {            double[] result = UnivariateRealSolverUtils.bracket(sin,                     1.5, 0, 2.0);             fail("Expecting ConvergenceException");        } catch (ConvergenceException ex) {            // expected        }    }        public void testBadParameters() throws MathException {        try { // null function            double[] result = UnivariateRealSolverUtils.bracket(null, 1.5, 0, 2.0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try { // initial not between endpoints            double[] result = UnivariateRealSolverUtils.bracket(sin, 2.5, 0, 2.0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try { // endpoints not valid            double[] result = UnivariateRealSolverUtils.bracket(sin, 1.5, 2.0, 1.0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try { // bad maximum iterations            double[] result = UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0, 0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }            }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for Divided Difference interpolator. * <p> * The error of polynomial interpolation is *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n! * where f^(n) is the n-th derivative of the approximated function and * zeta is some point in the interval determined by x[] and z. * <p> * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound * it and use the absolute value upper bound for estimates. For reference, * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2. *  * @version $Revision$ $Date$  */public final class DividedDifferenceInterpolatorTest extends TestCase {    /**     * Test of interpolator for the sine function.     * <p>     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();        double x[], y[], z, expected, result, tolerance;        // 6 interpolating points on interval [0, 2*PI]        int n = 6;        double min = 0.0, max = 2 * Math.PI;        x = new double[n];        y = new double[n];        for (int i = 0; i < n; i++) {            x[i] = min + i * (max - min) / n;            y[i] = f.value(x[i]);        }        double derivativebound = 1.0;        UnivariateRealFunction p = interpolator.interpolate(x, y);        z = Math.PI / 4; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);    }    /**     * Test of interpolator for the exponential function.     * <p>     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]     */    public void testExpm1Function() throws MathException {        UnivariateRealFunction f = new Expm1Function();        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();        double x[], y[], z, expected, result, tolerance;        // 5 interpolating points on interval [-1, 1]        int n = 5;        double min = -1.0, max = 1.0;        x = new double[n];        y = new double[n];        for (int i = 0; i < n; i++) {            x[i] = min + i * (max - min) / n;            y[i] = f.value(x[i]);        }        double derivativebound = Math.E;        UnivariateRealFunction p = interpolator.interpolate(x, y);        z = 0.0; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = 0.5; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = -0.5; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the interpolator.     */    public void testParameters() throws Exception {        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();        try {            // bad abscissas array            double x[] = { 1.0, 2.0, 2.0, 4.0 };            double y[] = { 0.0, 4.0, 4.0, 2.5 };            UnivariateRealFunction p = interpolator.interpolate(x, y);            p.value(0.0);            fail("Expecting MathException - bad abscissas array");        } catch (MathException ex) {            // expected        }    }    /**     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!     */    protected double partialerror(double x[], double z) throws        IllegalArgumentException {        if (x.length < 1) {            throw new IllegalArgumentException                ("Interpolation array cannot be empty.");        }        double out = 1;        for (int i = 0; i < x.length; i++) {            out *= (z - x[i]) / (i + 1);        }        return out;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for trapezoid integrator. * <p> * Test runs show that for a default relative accuracy of 1E-6, it * generally takes 10 to 15 iterations for the integral to converge. *  * @version $Revision$ $Date$  */public final class TrapezoidIntegratorTest extends TestCase {    /**     * Test of integrator for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f);        double min, max, expected, result, tolerance;        min = 0; max = Math.PI; expected = 2;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(min, max);        assertEquals(expected, result, tolerance);        min = -Math.PI/3; max = 0; expected = -0.5;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of integrator for the quintic function.     */    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f);        double min, max, expected, result, tolerance;        min = 0; max = 1; expected = -1.0/48;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(min, max);        assertEquals(expected, result, tolerance);        min = 0; max = 0.5; expected = 11.0/768;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(min, max);        assertEquals(expected, result, tolerance);        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the integrator.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f);        try {            // bad interval            integrator.integrate(1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(5);            integrator.setMaximalIterationCount(4);            integrator.integrate(-1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(10);            integrator.setMaximalIterationCount(99);            integrator.integrate(-1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;// commons-mathimport org.apache.commons.math.MathException;// junitimport junit.framework.TestCase;/** * Tests the PolynomialFunction implementation of a UnivariateRealFunction. * * @version $Revision$ * @author Matt Cliff <matt@mattcliff.com> */public final class PolynomialFunctionTest extends TestCase {    /** Error tolerance for tests */    protected double tolerance = 1.0e-12;    /**     * tests the value of a constant polynomial.     *     * <p>value of this is 2.5 everywhere.</p>     */    public void testConstants() throws MathException {        double[] c = { 2.5 };        PolynomialFunction f = new PolynomialFunction( c );        // verify that we are equal to c[0] at several (nonsymmetric) places        assertEquals( f.value( 0.0), c[0], tolerance );        assertEquals( f.value( -1.0), c[0], tolerance );        assertEquals( f.value( -123.5), c[0], tolerance );        assertEquals( f.value( 3.0), c[0], tolerance );        assertEquals( f.value( 456.89), c[0], tolerance );                assertEquals(f.degree(), 0);        assertEquals(f.derivative().value(0), 0, tolerance);                assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);    }    /**     * tests the value of a linear polynomial.     *     * <p>This will test the function f(x) = 3*x - 1.5</p>     * <p>This will have the values      *  <tt>f(0.0) = -1.5, f(-1.0) = -4.5, f(-2.5) = -9.0,     *      f(0.5) = 0.0, f(1.5) = 3.0</tt> and <tt>f(3.0) = 7.5</tt>     * </p>     */    public void testLinear() throws MathException {        double[] c = { -1.5, 3.0 };        PolynomialFunction f = new PolynomialFunction( c );        // verify that we are equal to c[0] when x=0        assertEquals( f.value( 0.0), c[0], tolerance );        // now check a few other places        assertEquals( -4.5, f.value( -1.0), tolerance );        assertEquals( -9.0, f.value( -2.5), tolerance );        assertEquals( 0.0, f.value( 0.5), tolerance );        assertEquals( 3.0, f.value( 1.5), tolerance );        assertEquals( 7.5, f.value( 3.0), tolerance );                assertEquals(f.degree(), 1);                assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);        }    /**     * Tests a second order polynomial.     * <p> This will test the function f(x) = 2x^2 - 3x -2 = (2x+1)(x-2)</p>     *     */    public void testQuadratic() throws MathException {        double[] c = { -2.0, -3.0, 2.0 };        PolynomialFunction f = new PolynomialFunction( c );        // verify that we are equal to c[0] when x=0        assertEquals( f.value( 0.0), c[0], tolerance );        // now check a few other places        assertEquals( 0.0, f.value( -0.5), tolerance );        assertEquals( 0.0, f.value( 2.0), tolerance );        assertEquals( -2.0, f.value( 1.5), tolerance );        assertEquals( 7.0, f.value( -1.5), tolerance );        assertEquals( 265.5312, f.value( 12.34), tolerance );        }        /**      * This will test the quintic function      *   f(x) = x^2(x-5)(x+3)(x-1) = x^5 - 3x^4 -13x^3 + 15x^2</p>     *     */    public void testQuintic() throws MathException {        double[] c = { 0.0, 0.0, 15.0, -13.0, -3.0, 1.0 };        PolynomialFunction f = new PolynomialFunction( c );        // verify that we are equal to c[0] when x=0        assertEquals( f.value( 0.0), c[0], tolerance );        // now check a few other places        assertEquals( 0.0, f.value( 5.0), tolerance );        assertEquals( 0.0, f.value( 1.0), tolerance );        assertEquals( 0.0, f.value( -3.0), tolerance );        assertEquals( 54.84375, f.value( -1.5), tolerance );        assertEquals( -8.06637, f.value( 1.3), tolerance );                assertEquals(f.degree(), 5);        }        /**     * tests the firstDerivative function by comparision     *     * <p>This will test the functions      * <tt>f(x) = x^3 - 2x^2 + 6x + 3, g(x) = 3x^2 - 4x + 6</tt>     * and <tt>h(x) = 6x - 4</tt>     */    public void testfirstDerivativeComparision() throws MathException {        double[] f_coeff = { 3.0, 6.0, -2.0, 1.0 };        double[] g_coeff = { 6.0, -4.0, 3.0 };        double[] h_coeff = { -4.0, 6.0 };        PolynomialFunction f = new PolynomialFunction( f_coeff );        PolynomialFunction g = new PolynomialFunction( g_coeff );        PolynomialFunction h = new PolynomialFunction( h_coeff );        // compare f' = g        assertEquals( f.derivative().value(0.0), g.value(0.0), tolerance );        assertEquals( f.derivative().value(1.0), g.value(1.0), tolerance );        assertEquals( f.derivative().value(100.0), g.value(100.0), tolerance );        assertEquals( f.derivative().value(4.1), g.value(4.1), tolerance );        assertEquals( f.derivative().value(-3.25), g.value(-3.25), tolerance );        // compare g' = h        // compare f'' = h    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test the SplineInterpolator. * * @version $Revision$ $Date$  */public class SplineInterpolatorTest extends TestCase {        /** error tolerance for spline interpolator value at knot points */    protected double knotTolerance = 1E-12;       /** error tolerance for interpolating polynomial coefficients */    protected double coefficientTolerance = 1E-6;        /** error tolerance for interpolated values -- high value is from sin test */    protected double interpolationTolerance = 1E-2;    public SplineInterpolatorTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SplineInterpolatorTest.class);        suite.setName("UnivariateRealInterpolator Tests");        return suite;    }    public void testInterpolateLinearDegenerateTwoSegment()        throws Exception {        double x[] = { 0.0, 0.5, 1.0 };        double y[] = { 0.0, 0.5, 1.0 };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        verifyConsistency((PolynomialSplineFunction) f, x);                // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1d, 0d, 0d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 1d, 0d, 0d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);                // Check interpolation        assertEquals(0.0,f.value(0.0), interpolationTolerance);        assertEquals(0.4,f.value(0.4), interpolationTolerance);        assertEquals(1.0,f.value(1.0), interpolationTolerance);    }    public void testInterpolateLinearDegenerateThreeSegment()        throws Exception {        double x[] = { 0.0, 0.5, 1.0, 1.5 };        double y[] = { 0.0, 0.5, 1.0, 1.5 };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);                // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1d, 0d, 0d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 1d, 0d, 0d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[2], 1d, 0d, 0d};        TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);                // Check interpolation        assertEquals(0,f.value(0), interpolationTolerance);        assertEquals(1.4,f.value(1.4), interpolationTolerance);        assertEquals(1.5,f.value(1.5), interpolationTolerance);    }    public void testInterpolateLinear() throws Exception {        double x[] = { 0.0, 0.5, 1.0 };        double y[] = { 0.0, 0.5, 0.0 };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        verifyConsistency((PolynomialSplineFunction) f, x);                // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1.5d, 0d, -2d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 0d, -3d, 2d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        }        public void testInterpolateSin() throws Exception {        double x[] =            {                0.0,                Math.PI / 6d,                Math.PI / 2d,                5d * Math.PI / 6d,                Math.PI,                7d * Math.PI / 6d,                3d * Math.PI / 2d,                11d * Math.PI / 6d,                2.d * Math.PI };        double y[] = { 0d, 0.5d, 1d, 0.5d, 0d, -0.5d, -1d, -0.5d, 0d };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        verifyConsistency((PolynomialSplineFunction) f, x);                /* Check coefficients against values computed using R (version 1.8.1, Red Hat Linux 9)         *          * To replicate in R:         *     x[1] <- 0         *     x[2] <- pi / 6, etc, same for y[] (could use y <- scan() for y values)         *     g <- splinefun(x, y, "natural")         *     splinecoef <- eval(expression(z), envir = environment(g))         *     print(splinecoef)          */        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1.002676d, 0d, -0.17415829d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 8.594367e-01, -2.735672e-01, -0.08707914};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[2], 1.471804e-17,-5.471344e-01, 0.08707914};        TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[3], -8.594367e-01, -2.735672e-01, 0.17415829};        TestUtils.assertEquals(polynomials[3].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[4], -1.002676, 6.548562e-17, 0.17415829};        TestUtils.assertEquals(polynomials[4].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[5], -8.594367e-01, 2.735672e-01, 0.08707914};        TestUtils.assertEquals(polynomials[5].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[6], 3.466465e-16, 5.471344e-01, -0.08707914};        TestUtils.assertEquals(polynomials[6].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[7], 8.594367e-01, 2.735672e-01, -0.17415829};        TestUtils.assertEquals(polynomials[7].getCoefficients(), target, coefficientTolerance);                 //Check interpolation        assertEquals(Math.sqrt(2d) / 2d,f.value(Math.PI/4d),interpolationTolerance);        assertEquals(Math.sqrt(2d) / 2d,f.value(3d*Math.PI/4d),interpolationTolerance);         }        public void testIllegalArguments() throws MathException {        // Data set arrays of different size.        UnivariateRealInterpolator i = new SplineInterpolator();        try {            double xval[] = { 0.0, 1.0 };            double yval[] = { 0.0, 1.0, 2.0 };            i.interpolate(xval, yval);            fail("Failed to detect data set array with different sizes.");        } catch (IllegalArgumentException iae) {        }        // X values not sorted.        try {            double xval[] = { 0.0, 1.0, 0.5 };            double yval[] = { 0.0, 1.0, 2.0 };            i.interpolate(xval, yval);            fail("Failed to detect unsorted arguments.");        } catch (IllegalArgumentException iae) {        }    }        /**     * verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length.     */    protected void verifyInterpolation(UnivariateRealFunction f, double x[], double y[])          throws Exception{        for (int i = 0; i < x.length; i++) {            assertEquals(f.value(x[i]), y[i], knotTolerance);        }         }        /**     * Verifies that interpolating polynomials satisfy consistency requirement:     *    adjacent polynomials must agree through two derivatives at knot points     */    protected void verifyConsistency(PolynomialSplineFunction f, double x[])         throws Exception {        PolynomialFunction polynomials[] = f.getPolynomials();        for (int i = 1; i < x.length - 2; i++) {            // evaluate polynomials and derivatives at x[i + 1]              assertEquals(polynomials[i].value(x[i +1] - x[i]), polynomials[i + 1].value(0), 0.1);             assertEquals(polynomials[i].derivative().value(x[i +1] - x[i]),                     polynomials[i + 1].derivative().value(0), 0.5);             assertEquals(polynomials[i].polynomialDerivative().derivative().value(x[i +1] - x[i]),                     polynomials[i + 1].polynomialDerivative().derivative().value(0), 0.5);         }    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.complex.Complex;import junit.framework.TestCase;/** * Testcase for Laguerre solver. * <p> * Laguerre's method is very efficient in solving polynomials. Test runs * show that for a default absolute accuracy of 1E-6, it generally takes * less than 5 iterations to find one root, provided solveAll() is not * invoked, and 15 to 20 iterations to find all roots for quintic function. *  * @version $Revision$ $Date$  */public final class LaguerreSolverTest extends TestCase {    /**     * Test of solver for the linear function.     */    public void testLinearFunction() throws MathException {        double min, max, expected, result, tolerance;        // p(x) = 4x - 1        double coefficients[] = { -1.0, 4.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        UnivariateRealSolver solver = new LaguerreSolver(f);        min = 0.0; max = 1.0; expected = 0.25;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quadratic function.     */    public void testQuadraticFunction() throws MathException {        double min, max, expected, result, tolerance;        // p(x) = 2x^2 + 5x - 3 = (x+3)(2x-1)        double coefficients[] = { -3.0, 5.0, 2.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        UnivariateRealSolver solver = new LaguerreSolver(f);        min = 0.0; max = 2.0; expected = 0.5;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);        min = -4.0; max = -1.0; expected = -3.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function.     */    public void testQuinticFunction() throws MathException {        double min, max, expected, result, tolerance;        // p(x) = x^5 - x^4 - 12x^3 + x^2 - x - 12 = (x+1)(x+3)(x-4)(x^2-x+1)        double coefficients[] = { -12.0, -1.0, 1.0, -12.0, -1.0, 1.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        UnivariateRealSolver solver = new LaguerreSolver(f);        min = -2.0; max = 2.0; expected = -1.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);        min = -5.0; max = -2.5; expected = -3.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);        min = 3.0; max = 6.0; expected = 4.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function using solveAll().     */    public void testQuinticFunction2() throws MathException {        double initial = 0.0, tolerance;        Complex expected, result[];        // p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4)        double coefficients[] = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        LaguerreSolver solver = new LaguerreSolver(f);        result = solver.solveAll(coefficients, initial);        expected = new Complex(0.0, -2.0);        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));        TestUtils.assertContains(result, expected, tolerance);        expected = new Complex(0.0, 2.0);        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));        TestUtils.assertContains(result, expected, tolerance);        expected = new Complex(0.5, 0.5 * Math.sqrt(3.0));        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));        TestUtils.assertContains(result, expected, tolerance);        expected = new Complex(-1.0, 0.0);        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));        TestUtils.assertContains(result, expected, tolerance);                expected = new Complex(0.5, -0.5 * Math.sqrt(3.0));        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));        TestUtils.assertContains(result, expected, tolerance);    }    /**     * Test of parameters for the solver.     */    public void testParameters() throws Exception {        double coefficients[] = { -3.0, 5.0, 2.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        UnivariateRealSolver solver = new LaguerreSolver(f);        try {            // bad interval            solver.solve(1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // no bracketing            solver.solve(2, 3);            fail("Expecting IllegalArgumentException - no bracketing");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad function            UnivariateRealFunction f2 = new SinFunction();            UnivariateRealSolver solver2 = new LaguerreSolver(f2);            fail("Expecting IllegalArgumentException - bad function");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Testcase for UnivariateRealSolver. * Because Brent-Dekker is guaranteed to converge in less than the default * maximum iteration count due to bisection fallback, it is quite hard to * debug. I include measured iteration counts plus one in order to detect * regressions. On average Brent-Dekker should use 4..5 iterations for the * default absolute accuracy of 10E-8 for sinus and the quintic function around * zero, and 5..10 iterations for the other zeros. *  * @version $Revision$ $Date$  */public final class BrentSolverTest extends TestCase {    public BrentSolverTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(BrentSolverTest.class);        suite.setName("UnivariateRealSolver Tests");        return suite;    }    public void testSinZero() throws MathException {        // The sinus function is behaved well around the root at #pi. The second        // order derivative is zero, which means linar approximating methods will        // still converge quadratically.         UnivariateRealFunction f = new SinFunction();        double result;        UnivariateRealSolver solver = new BrentSolver(f);        // Somewhat benign interval. The function is monotone.        result = solver.solve(3, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        // 4 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 5);        // Larger and somewhat less benign interval. The function is grows first.        result = solver.solve(1, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        solver = new SecantSolver(f);        result = solver.solve(3, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        // 4 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 5);        result = solver.solve(1, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        assertEquals(result, solver.getResult(), 0);    }    public void testQuinticZero() throws MathException {        // The quintic function has zeros at 0, +-0.5 and +-1.        // Around the root of 0 the function is well behaved, with a second derivative        // of zero a 0.        // The other roots are less well to find, in particular the root at 1, because        // the function grows fast for x>1.        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,        // intervals containing these values are harder for the solvers.        UnivariateRealFunction f = new QuinticFunction();        double result;        // Brent-Dekker solver.        UnivariateRealSolver solver = new BrentSolver(f);        // Symmetric bracket around 0. Test whether solvers can handle hitting        // the root in the first iteration.        result = solver.solve(-0.2, 0.2);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        assertTrue(solver.getIterationCount() <= 2);        // 1 iterations on i586 JDK 1.4.1.        // Asymmetric bracket around 0, just for fun. Contains extremum.        result = solver.solve(-0.1, 0.3);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        // Large bracket around 0. Contains two extrema.        result = solver.solve(-0.3, 0.45);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        // Benign bracket around 0.5, function is monotonous.        result = solver.solve(0.3, 0.7);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        // Less benign bracket around 0.5, contains one extremum.        result = solver.solve(0.2, 0.6);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        // Large, less benign bracket around 0.5, contains both extrema.        result = solver.solve(0.05, 0.95);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        // Relatively benign bracket around 1, function is monotonous. Fast growth for x>1        // is still a problem.        result = solver.solve(0.85, 1.25);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        // Less benign bracket around 1 with extremum.        result = solver.solve(0.8, 1.2);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        // Large bracket around 1. Monotonous.        result = solver.solve(0.85, 1.75);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 10 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 11);        // Large bracket around 1. Interval contains extremum.        result = solver.solve(0.55, 1.45);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 7 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 8);        // Very large bracket around 1 for testing fast growth behaviour.        result = solver.solve(0.85, 5);        //System.out.println(       //     "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 12 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 13);        // Secant solver.        solver = new SecantSolver(f);        result = solver.solve(-0.2, 0.2);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 1 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 2);        result = solver.solve(-0.1, 0.3);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        result = solver.solve(-0.3, 0.45);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        result = solver.solve(0.3, 0.7);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 7 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 8);        result = solver.solve(0.2, 0.6);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        result = solver.solve(0.05, 0.95);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        result = solver.solve(0.85, 1.25);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 10 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 11);        result = solver.solve(0.8, 1.2);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        result = solver.solve(0.85, 1.75);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 14 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 15);        // The followig is especially slow because the solver first has to reduce        // the bracket to exclude the extremum. After that, convergence is rapide.        result = solver.solve(0.55, 1.45);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 7 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 8);        result = solver.solve(0.85, 5);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 14 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 15);        // Static solve method        result = UnivariateRealSolverUtils.solve(f, -0.2, 0.2);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = UnivariateRealSolverUtils.solve(f, -0.1, 0.3);        assertEquals(result, 0, 1E-8);        result = UnivariateRealSolverUtils.solve(f, -0.3, 0.45);        assertEquals(result, 0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.3, 0.7);        assertEquals(result, 0.5, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.2, 0.6);        assertEquals(result, 0.5, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.05, 0.95);        assertEquals(result, 0.5, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.25);        assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.8, 1.2);        assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.75);        assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.55, 1.45);        assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.85, 5);        assertEquals(result, 1.0, 1E-6);    }        public void testBadEndpoints() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new BrentSolver(f);        try {  // bad interval            solver.solve(1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {  // no bracket            solver.solve(1, 1.5);            fail("Expecting IllegalArgumentException - non-bracketing");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for Ridders solver. * <p> * Ridders' method converges superlinearly, more specific, its rate of * convergence is sqrt(2). Test runs show that for a default absolute * accuracy of 1E-6, it generally takes less than 5 iterations for close * initial bracket and 5 to 10 iterations for distant initial bracket * to converge. *  * @version $Revision$ $Date$  */public final class RiddersSolverTest extends TestCase {    /**     * Test of solver for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new RiddersSolver(f);        double min, max, expected, result, tolerance;        min = 3.0; max = 4.0; expected = Math.PI;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);        min = -1.0; max = 1.5; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function.     */    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new RiddersSolver(f);        double min, max, expected, result, tolerance;        min = -0.4; max = 0.2; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);        min = 0.75; max = 1.5; expected = 1.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);        min = -0.9; max = -0.2; expected = -0.5;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the exponential function.     */    public void testExpm1Function() throws MathException {        UnivariateRealFunction f = new Expm1Function();        UnivariateRealSolver solver = new RiddersSolver(f);        double min, max, expected, result, tolerance;        min = -1.0; max = 2.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);        min = -20.0; max = 10.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);        min = -50.0; max = 100.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the solver.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new RiddersSolver(f);        try {            // bad interval            solver.solve(1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // no bracketing            solver.solve(2, 3);            fail("Expecting IllegalArgumentException - no bracketing");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public final class BisectionSolverTest extends TestCase {    /**     *     */    public void testSinZero() throws MathException {        UnivariateRealFunction f = new SinFunction();        double result;                UnivariateRealSolver solver = new BisectionSolver(f);        result = solver.solve(3, 4);        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        result = solver.solve(1, 4);        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());    }    /**     *     */    public void testQuinticZero() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        double result;        UnivariateRealSolver solver = new BisectionSolver(f);        result = solver.solve(-0.2, 0.2);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(-0.1, 0.3);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(-0.3, 0.45);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(0.3, 0.7);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(0.2, 0.6);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(0.05, 0.95);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(0.85, 1.25);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(0.8, 1.2);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(0.85, 1.75);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(0.55, 1.45);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(0.85, 5);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());                assertEquals(result, solver.getResult(), 0);        assertTrue(solver.getIterationCount() > 0);    }        /**     *      */    public void testSetFunctionValueAccuracy(){        double expected = 1.0e-2;            UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new BisectionSolver(f);        solver.setFunctionValueAccuracy(expected);        assertEquals(expected, solver.getFunctionValueAccuracy(), 1.0e-2);    }                /**     *      */    public void testResetFunctionValueAccuracy(){        double newValue = 1.0e-2;            UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new BisectionSolver(f);        double oldValue = solver.getFunctionValueAccuracy();        solver.setFunctionValueAccuracy(newValue);        solver.resetFunctionValueAccuracy();        assertEquals(oldValue, solver.getFunctionValueAccuracy(), 1.0e-2);    }                /**     *      */    public void testSetAbsoluteAccuracy(){        double expected = 1.0e-2;         UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new BisectionSolver(f);        solver.setAbsoluteAccuracy(expected);        assertEquals(expected, solver.getAbsoluteAccuracy(), 1.0e-2);     }                /**     *      */    public void testResetAbsoluteAccuracy(){        double newValue = 1.0e-2;               UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new BisectionSolver(f);        double oldValue = solver.getAbsoluteAccuracy();        solver.setAbsoluteAccuracy(newValue);        solver.resetAbsoluteAccuracy();        assertEquals(oldValue, solver.getAbsoluteAccuracy(), 1.0e-2);    }                /**     *      */    public void testSetMaximalIterationCount(){        int expected = 100;                UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new BisectionSolver(f);        solver.setMaximalIterationCount(expected);        assertEquals(expected, solver.getMaximalIterationCount());    }                /**     *      */    public void testResetMaximalIterationCount(){        int newValue = 10000;                UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new BisectionSolver(f);        int oldValue = solver.getMaximalIterationCount();        solver.setMaximalIterationCount(newValue);        solver.resetMaximalIterationCount();        assertEquals(oldValue, solver.getMaximalIterationCount());    }                /**     *      */    public void testSetRelativeAccuracy(){        double expected = 1.0e-2;                UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new BisectionSolver(f);        solver.setRelativeAccuracy(expected);        assertEquals(expected, solver.getRelativeAccuracy(), 1.0e-2);    }                /**     *      */    public void testResetRelativeAccuracy(){        double newValue = 1.0e-2;                UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new BisectionSolver(f);        double oldValue = solver.getRelativeAccuracy();        solver.setRelativeAccuracy(newValue);        solver.resetRelativeAccuracy();        assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);    }                /**     * Test Serialization and Recovery     */   public void testSerialization() throws MathException {       UnivariateRealFunction f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction());       double result;              BisectionSolver solver = new BisectionSolver(f);       UnivariateRealSolver solver2 = (UnivariateRealSolver)TestUtils.serializeAndRecover(solver);              result = solver.solve(-0.2, 0.2);       assertEquals(result, 0, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(-0.2, 0.2), result, solver2.getAbsoluteAccuracy());              result = solver.solve(-0.1, 0.3);       assertEquals(result, 0, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(-0.1, 0.3), result, solver2.getAbsoluteAccuracy());              result = solver.solve(-0.3, 0.45);       assertEquals(result, 0, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(-0.3, 0.45), result, solver2.getAbsoluteAccuracy());              result = solver.solve(0.3, 0.7);       assertEquals(result, 0.5, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(0.3, 0.7), result, solver2.getAbsoluteAccuracy());              result = solver.solve(0.2, 0.6);       assertEquals(result, 0.5, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(0.2, 0.6), result, solver2.getAbsoluteAccuracy());              result = solver.solve(0.05, 0.95);       assertEquals(result, 0.5, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(0.05, 0.95), result, solver2.getAbsoluteAccuracy());              result = solver.solve(0.85, 1.25);       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(0.85, 1.25), result, solver2.getAbsoluteAccuracy());              result = solver.solve(0.8, 1.2);       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(0.8, 1.2), result, solver2.getAbsoluteAccuracy());              result = solver.solve(0.85, 1.75);       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(0.85, 1.75), result, solver2.getAbsoluteAccuracy());              result = solver.solve(0.55, 1.45);       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(0.55, 1.45), result, solver2.getAbsoluteAccuracy());              result = solver.solve(0.85, 5);       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(0.85, 5), result, solver2.getAbsoluteAccuracy());              /* Test Reset */       double newValue = 1.0e-2;       f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction());       solver = new BisectionSolver(f);              double oldValue = solver.getRelativeAccuracy();       solver.setRelativeAccuracy(newValue);       solver.resetRelativeAccuracy();       assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);              solver2 = (UnivariateRealSolver)TestUtils.serializeAndRecover(solver);               assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);              solver2.setRelativeAccuracy(newValue);       solver2.resetRelativeAccuracy();              assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);          }   }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for Neville interpolator. * <p> * The error of polynomial interpolation is *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n! * where f^(n) is the n-th derivative of the approximated function and * zeta is some point in the interval determined by x[] and z. * <p> * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound * it and use the absolute value upper bound for estimates. For reference, * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2. *  * @version $Revision$ $Date$  */public final class NevilleInterpolatorTest extends TestCase {    /**     * Test of interpolator for the sine function.     * <p>     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealInterpolator interpolator = new NevilleInterpolator();        double x[], y[], z, expected, result, tolerance;        // 6 interpolating points on interval [0, 2*PI]        int n = 6;        double min = 0.0, max = 2 * Math.PI;        x = new double[n];        y = new double[n];        for (int i = 0; i < n; i++) {            x[i] = min + i * (max - min) / n;            y[i] = f.value(x[i]);        }        double derivativebound = 1.0;        UnivariateRealFunction p = interpolator.interpolate(x, y);        z = Math.PI / 4; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);    }    /**     * Test of interpolator for the exponential function.     * <p>     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]     */    public void testExpm1Function() throws MathException {        UnivariateRealFunction f = new Expm1Function();        UnivariateRealInterpolator interpolator = new NevilleInterpolator();        double x[], y[], z, expected, result, tolerance;        // 5 interpolating points on interval [-1, 1]        int n = 5;        double min = -1.0, max = 1.0;        x = new double[n];        y = new double[n];        for (int i = 0; i < n; i++) {            x[i] = min + i * (max - min) / n;            y[i] = f.value(x[i]);        }        double derivativebound = Math.E;        UnivariateRealFunction p = interpolator.interpolate(x, y);        z = 0.0; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = 0.5; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = -0.5; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the interpolator.     */    public void testParameters() throws Exception {        UnivariateRealInterpolator interpolator = new NevilleInterpolator();        try {            // bad abscissas array            double x[] = { 1.0, 2.0, 2.0, 4.0 };            double y[] = { 0.0, 4.0, 4.0, 2.5 };            UnivariateRealFunction p = interpolator.interpolate(x, y);            p.value(0.0);            fail("Expecting MathException - bad abscissas array");        } catch (MathException ex) {            // expected        }    }    /**     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!     */    protected double partialerror(double x[], double z) throws        IllegalArgumentException {        if (x.length < 1) {            throw new IllegalArgumentException                ("Interpolation array cannot be empty.");        }        double out = 1;        for (int i = 0; i < x.length; i++) {            out *= (z - x[i]) / (i + 1);        }        return out;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import java.util.Arrays;import junit.framework.TestCase;import org.apache.commons.math.FunctionEvaluationException;/** * Tests the PolynomialSplineFunction implementation. * * @version $Revision$ */public class PolynomialSplineFunctionTest extends TestCase {    /** Error tolerance for tests */    protected double tolerance = 1.0e-12;        /**      * Quadratic polynomials used in tests:      *      * x^2 + x            [-1, 0)     * x^2 + x + 2        [0, 1)     * x^2 + x + 4        [1, 2)     *      * Defined so that evaluation using PolynomialSplineFunction evaluation     * algorithm agrees at knot point boundaries.     */    protected PolynomialFunction[] polynomials = {        new PolynomialFunction(new double[] {0d, 1d, 1d}),         new PolynomialFunction(new double[] {2d, 1d, 1d}),        new PolynomialFunction(new double[] {4d, 1d, 1d})    };        /** Knot points  */    protected double[] knots = {-1, 0, 1, 2};        /** Derivative of test polynomials -- 2x + 1  */    protected PolynomialFunction dp =         new PolynomialFunction(new double[] {1d, 2d});            public void testConstructor() {        PolynomialSplineFunction spline =             new PolynomialSplineFunction(knots, polynomials);        assertTrue(Arrays.equals(knots, spline.getKnots()));        assertEquals(1d, spline.getPolynomials()[0].getCoefficients()[2], 0);        assertEquals(3, spline.getN());                try { // too few knots            spline =                 new PolynomialSplineFunction(new double[] {0}, polynomials);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                try { // too many knots            spline =                 new PolynomialSplineFunction(new double[] {0,1,2,3,4}, polynomials);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                try { // knots not increasing            spline =                 new PolynomialSplineFunction(new double[] {0,1, 3, 2}, polynomials);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }        public void testValues() throws Exception {        PolynomialSplineFunction spline =             new PolynomialSplineFunction(knots, polynomials);        UnivariateRealFunction dSpline = spline.derivative();                /**         * interior points -- spline value at x should equal p(x - knot)         * where knot is the largest knot point less than or equal to x and p          * is the polynomial defined over the knot segment to which x belongs.         */        double x = -1;        int index = 0;        for (int i = 0; i < 10; i++) {           x+=0.25;           index = findKnot(knots, x);           assertEquals("spline function evaluation failed for x=" + x,                    polynomials[index].value(x - knots[index]), spline.value(x), tolerance);           assertEquals("spline derivative evaluation failed for x=" + x,                   dp.value(x - knots[index]), dSpline.value(x), tolerance);        }                // knot points -- centering should zero arguments        for (int i = 0; i < 3; i++) {            assertEquals("spline function evaluation failed for knot=" + knots[i],                    polynomials[i].value(0), spline.value(knots[i]), tolerance);            assertEquals("spline function evaluation failed for knot=" + knots[i],                    dp.value(0), dSpline.value(knots[i]), tolerance);        }                try { //outside of domain -- under min            x = spline.value(-1.5);            fail("Expecting IllegalArgumentException");        } catch (FunctionEvaluationException ex) {            // expected        }                try { //outside of domain -- over max            x = spline.value(2.5);            fail("Expecting IllegalArgumentException");        } catch (FunctionEvaluationException ex) {            // expected        }             }          /**     *  Do linear search to find largest knot point less than or equal to x.     *  Implementation does binary search.     */     protected int findKnot(double[] knots, double x) {         if (x < knots[0] || x >= knots[knots.length -1]) {             throw new IllegalArgumentException("x is out of range");         }         for (int i = 0; i < knots.length; i++) {             if (knots[i] > x) {                 return i -1;             }         }         throw new IllegalArgumentException("x is out of range");     }}    
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for Simpson integrator. * <p> * Test runs show that for a default relative accuracy of 1E-6, it * generally takes 5 to 10 iterations for the integral to converge. *  * @version $Revision$ $Date$  */public final class SimpsonIntegratorTest extends TestCase {    /**     * Test of integrator for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new SimpsonIntegrator(f);        double min, max, expected, result, tolerance;        min = 0; max = Math.PI; expected = 2;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(min, max);        assertEquals(expected, result, tolerance);        min = -Math.PI/3; max = 0; expected = -0.5;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of integrator for the quintic function.     */    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealIntegrator integrator = new SimpsonIntegrator(f);        double min, max, expected, result, tolerance;        min = 0; max = 1; expected = -1.0/48;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(min, max);        assertEquals(expected, result, tolerance);        min = 0; max = 0.5; expected = 11.0/768;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(min, max);        assertEquals(expected, result, tolerance);        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the integrator.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new SimpsonIntegrator(f);        try {            // bad interval            integrator.integrate(1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(5);            integrator.setMaximalIterationCount(4);            integrator.integrate(-1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(10);            integrator.setMaximalIterationCount(99);            integrator.integrate(-1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public final class NewtonSolverTest extends TestCase {    /**     *     */    public void testSinZero() throws MathException {        DifferentiableUnivariateRealFunction f = new SinFunction();        double result;                UnivariateRealSolver solver = new NewtonSolver(f);        result = solver.solve(3, 4);        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        result = solver.solve(1, 4);        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());                //TODO:  create abstract solver test class, move these there        assertEquals(result, solver.getResult(), 0);        assertTrue(solver.getIterationCount() > 0);    }    /**     *     */    public void testQuinticZero() throws MathException {        DifferentiableUnivariateRealFunction f = new QuinticFunction();        double result;        UnivariateRealSolver solver = new BisectionSolver(f);        result = solver.solve(-0.2, 0.2);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(-0.1, 0.3);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(-0.3, 0.45);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(0.3, 0.7);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(0.2, 0.6);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(0.05, 0.95);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(0.85, 1.25);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(0.8, 1.2);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(0.85, 1.75);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(0.55, 1.45);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(0.85, 5);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());    }        /**     * Test Serialization and Recovery     */    public void testSerialization() throws MathException {        DifferentiableUnivariateRealFunction f = new QuinticFunction();        double result;                NewtonSolver solver = new NewtonSolver(f);        NewtonSolver solver2 = (NewtonSolver)TestUtils.serializeAndRecover(solver);                result = solver.solve(-0.2, 0.2);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(-0.2, 0.2), result, solver2.getAbsoluteAccuracy());                result = solver.solve(-0.1, 0.3);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(-0.1, 0.3), result, solver2.getAbsoluteAccuracy());                result = solver.solve(-0.3, 0.45);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(-0.3, 0.45), result, solver2.getAbsoluteAccuracy());                result = solver.solve(0.3, 0.7);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(0.3, 0.7), result, solver2.getAbsoluteAccuracy());                result = solver.solve(0.2, 0.6);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(0.2, 0.6), result, solver2.getAbsoluteAccuracy());                result = solver.solve(0.05, 0.95);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(0.05, 0.95), result, solver2.getAbsoluteAccuracy());                result = solver.solve(0.85, 1.25);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(0.85, 1.25), result, solver2.getAbsoluteAccuracy());                result = solver.solve(0.8, 1.2);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(0.8, 1.2), result, solver2.getAbsoluteAccuracy());                result = solver.solve(0.85, 1.75);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(0.85, 1.75), result, solver2.getAbsoluteAccuracy());                result = solver.solve(0.55, 1.45);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(0.55, 1.45), result, solver2.getAbsoluteAccuracy());                result = solver.solve(0.85, 5);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(0.85, 5), result, solver2.getAbsoluteAccuracy());                /* Test Reset */        double newValue = 1.0e-2;        f = new QuinticFunction();        solver = new NewtonSolver(f);                double oldValue = solver.getRelativeAccuracy();        solver.setRelativeAccuracy(newValue);        solver.resetRelativeAccuracy();        assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);                solver2 = (NewtonSolver)TestUtils.serializeAndRecover(solver);                 assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);                solver2.setRelativeAccuracy(newValue);        solver2.resetRelativeAccuracy();                assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);            }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.rank;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class MaxTest extends StorelessUnivariateStatisticAbstractTest{    protected Max stat;        /**     * @param name     */    public MaxTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(MaxTest.class);        suite.setName("Max  Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {        return new Max();    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.max;    }        public void testSpecialValues() {        double[] testArray = {0d, Double.NaN, Double.NEGATIVE_INFINITY,                 Double.POSITIVE_INFINITY};        Max max = new Max();        assertTrue(Double.isNaN(max.getResult()));        max.increment(testArray[0]);        assertEquals(0d, max.getResult(), 0);        max.increment(testArray[1]);        assertEquals(0d, max.getResult(), 0);        max.increment(testArray[2]);        assertEquals(0d, max.getResult(), 0);        max.increment(testArray[3]);        assertEquals(Double.POSITIVE_INFINITY, max.getResult(), 0);        assertEquals(Double.POSITIVE_INFINITY, max.evaluate(testArray), 0);         }    public void testNaNs() {        Max max = new Max();        double nan = Double.NaN;        assertEquals(3d, max.evaluate(new double[]{nan, 2d, 3d}), 0);             assertEquals(3d, max.evaluate(new double[]{1d, nan, 3d}), 0);             assertEquals(2d, max.evaluate(new double[]{1d, 2d, nan}), 0);             assertTrue(Double.isNaN(max.evaluate(new double[]{nan, nan, nan})));         }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.rank;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class PercentileTest extends UnivariateStatisticAbstractTest{    protected Percentile stat;        /**     * @param name     */    public PercentileTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(PercentileTest.class);        suite.setName("Percentile Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {           return new Percentile(95.0);    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.percentile95;    }    public void testHighPercentile(){        double[] d = new double[]{1, 2, 3};        Percentile p = new Percentile(75);        assertEquals(3.0, p.evaluate(d), 1.0e-5);    }        public void testPercentile() {        double[] d = new double[] {1, 3, 2, 4};        Percentile p = new Percentile(30);        assertEquals(1.5, p.evaluate(d), 1.0e-5);        p.setQuantile(25);        assertEquals(1.25, p.evaluate(d), 1.0e-5);        p.setQuantile(75);        assertEquals(3.75, p.evaluate(d), 1.0e-5);        p.setQuantile(50);        assertEquals(2.5, p.evaluate(d), 1.0e-5);                // invalid percentiles        try {            p.evaluate(d, 0, d.length, -1.0);            fail();        } catch (IllegalArgumentException ex) {            // success        }        try {            p.evaluate(d, 0, d.length, 101.0);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }        public void testNISTExample() {        double[] d = new double[] {95.1772, 95.1567, 95.1937, 95.1959,                 95.1442, 95.0610,  95.1591, 95.1195, 95.1772, 95.0925, 95.1990, 95.1682        };        Percentile p = new Percentile(90);         assertEquals(95.1981, p.evaluate(d), 1.0e-4);        assertEquals(95.1990, p.evaluate(d,0,d.length, 100d), 0);    }        public void test5() {        Percentile percentile = new Percentile(5);        assertEquals(this.percentile5, percentile.evaluate(testArray), getTolerance());    }        public void testNullEmpty() {        Percentile percentile = new Percentile(50);        double[] nullArray = null;        double[] emptyArray = new double[] {};        try {            percentile.evaluate(nullArray);            fail("Expecting IllegalArgumentException for null array");        } catch (IllegalArgumentException ex) {            // expected        }          assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));            }        public void testSingleton() {        Percentile percentile = new Percentile(50);        double[] singletonArray = new double[] {1d};        assertEquals(1d, percentile.evaluate(singletonArray), 0);        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 5), 0);        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 100), 0);         assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0)));         }        public void testSpecialValues() {        Percentile percentile = new Percentile(50);        double[] specialValues = new double[] {0d, 1d, 2d, 3d, 4d,  Double.NaN};        assertEquals(2.5d, percentile.evaluate(specialValues), 0);        specialValues =  new double[] {Double.NEGATIVE_INFINITY, 1d, 2d, 3d,                Double.NaN, Double.POSITIVE_INFINITY};        assertEquals(2.5d, percentile.evaluate(specialValues), 0);        specialValues = new double[] {1d, 1d, Double.POSITIVE_INFINITY,                 Double.POSITIVE_INFINITY};        assertTrue(Double.isInfinite(percentile.evaluate(specialValues)));        specialValues = new double[] {1d, 1d, Double.NaN,                 Double.NaN};        assertTrue(Double.isNaN(percentile.evaluate(specialValues)));        specialValues = new double[] {1d, 1d, Double.NEGATIVE_INFINITY,                 Double.NEGATIVE_INFINITY};        // Interpolation results in NEGATIVE_INFINITY + POSITIVE_INFINITY        assertTrue(Double.isNaN(percentile.evaluate(specialValues)));       }        public void testSetQuantile() {        Percentile percentile = new Percentile(10);        percentile.setQuantile(100); // OK        assertEquals(100, percentile.getQuantile(), 0);              try {            percentile.setQuantile(0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            percentile = new Percentile(0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }            }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.rank;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class MedianTest extends UnivariateStatisticAbstractTest{    protected Median stat;        /**     * @param name     */    public MedianTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(MedianTest.class);        suite.setName("Median  Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {          return new Median();    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.median;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.rank;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class MinTest extends StorelessUnivariateStatisticAbstractTest{    protected Min stat;        /**     * @param name     */    public MinTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(MinTest.class);        suite.setName("Min  Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {        return new Min();    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.min;    }        public void testSpecialValues() {        double[] testArray = {0d, Double.NaN, Double.POSITIVE_INFINITY,                 Double.NEGATIVE_INFINITY};        Min min = new Min();        assertTrue(Double.isNaN(min.getResult()));        min.increment(testArray[0]);        assertEquals(0d, min.getResult(), 0);        min.increment(testArray[1]);        assertEquals(0d, min.getResult(), 0);        min.increment(testArray[2]);        assertEquals(0d, min.getResult(), 0);        min.increment(testArray[3]);        assertEquals(Double.NEGATIVE_INFINITY, min.getResult(), 0);        assertEquals(Double.NEGATIVE_INFINITY, min.evaluate(testArray), 0);         }    public void testNaNs() {        Min min = new Min();        double nan = Double.NaN;        assertEquals(2d, min.evaluate(new double[]{nan, 2d, 3d}), 0);             assertEquals(1d, min.evaluate(new double[]{1d, nan, 3d}), 0);             assertEquals(1d, min.evaluate(new double[]{1d, 2d, nan}), 0);             assertTrue(Double.isNaN(min.evaluate(new double[]{nan, nan, nan})));         }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. *  * @version $Revision$ $Date$ */public class StandardDeviationTest extends StorelessUnivariateStatisticAbstractTest{    protected StandardDeviation stat;        /**     * @param name     */    public StandardDeviationTest(String name) {        super(name);    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {        return new StandardDeviation();    }    public static Test suite() {        TestSuite suite = new TestSuite(StandardDeviationTest.class);        suite.setName("StandardDeviation Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.std;    }        /**     * Make sure Double.NaN is returned iff n = 0     *     */    public void testNaN() {        StandardDeviation std = new StandardDeviation();        assertTrue(Double.isNaN(std.getResult()));        std.increment(1d);        assertEquals(0d, std.getResult(), 0);    }        /**     * Test population version of variance     */     public void testPopulation() {        double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};        double sigma = populationStandardDeviation(values);        SecondMoment m = new SecondMoment();        m.evaluate(values);  // side effect is to add values        StandardDeviation s1 = new StandardDeviation();        s1.setBiasCorrected(false);        assertEquals(sigma, s1.evaluate(values), 1E-14);        s1.incrementAll(values);        assertEquals(sigma, s1.getResult(), 1E-14);        s1 = new StandardDeviation(false, m);        assertEquals(sigma, s1.getResult(), 1E-14);             s1 = new StandardDeviation(false);        assertEquals(sigma, s1.evaluate(values), 1E-14);        s1.incrementAll(values);        assertEquals(sigma, s1.getResult(), 1E-14);         }        /**     * Definitional formula for population standard deviation     */    protected double populationStandardDeviation(double[] v) {        double mean = new Mean().evaluate(v);        double sum = 0;        for (int i = 0; i < v.length; i++) {            sum += (v[i] - mean) * (v[i] - mean);         }        return Math.sqrt(sum / (double) v.length);    }}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.DimensionMismatchException;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;public class VectorialMeanTestextends TestCase {    public VectorialMeanTest(String name) {        super(name);        points = null;    }    public void testMismatch() {        try {            new VectorialMean(8).increment(new double[5]);            fail("an exception should have been thrown");        } catch (DimensionMismatchException dme) {            assertEquals(5, dme.getDimension1());            assertEquals(8, dme.getDimension2());        } catch (Exception e) {            fail("wrong exception type caught: " + e.getClass().getName());        }    }    public void testSimplistic() throws DimensionMismatchException {        VectorialMean stat = new VectorialMean(2);        stat.increment(new double[] {-1.0,  1.0});        stat.increment(new double[] { 1.0, -1.0});        double[] mean = stat.getResult();        assertEquals(0.0, mean[0], 1.0e-12);        assertEquals(0.0, mean[1], 1.0e-12);    }    public void testBasicStats() throws DimensionMismatchException {        VectorialMean stat = new VectorialMean(points[0].length);        for (int i = 0; i < points.length; ++i) {            stat.increment(points[i]);        }        assertEquals(points.length, stat.getN());        double[] mean = stat.getResult();        double[]   refMean = new double[] { 1.78, 1.62,  3.12};        for (int i = 0; i < mean.length; ++i) {            assertEquals(refMean[i], mean[i], 1.0e-12);        }    }    public void setUp() {        points = new double[][] {                { 1.2, 2.3,  4.5},                {-0.7, 2.3,  5.0},                { 3.1, 0.0, -3.1},                { 6.0, 1.2,  4.2},                {-0.7, 2.3,  5.0}        };    }    public void tearDown() {        points = null;    }    public static Test suite() {        return new TestSuite(VectorialMeanTest.class);    }    private double [][] points;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link FourthMoment} class. * @version $Revision$ $Date$ */public class FourthMomentTest extends StorelessUnivariateStatisticAbstractTest{    /** descriptive statistic. */    protected FourthMoment stat;        /**     * @param name     */    public FourthMomentTest(String name) {        super(name);    }        /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {        return new FourthMoment();    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {       return this.fourthMoment;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link ThirdMoment} class. * @version $Revision$ $Date$ */public class ThirdMomentTest extends StorelessUnivariateStatisticAbstractTest{    /** descriptive statistic. */    protected ThirdMoment stat;        /**     * @param name     */    public ThirdMomentTest(String name) {        super(name);    }        /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {        return new ThirdMoment();    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {      return this.thirdMoment;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class KurtosisTest extends StorelessUnivariateStatisticAbstractTest{    protected Kurtosis stat;        /**     * @param name     */    public KurtosisTest(String name) {        super(name);    }        public static Test suite() {        TestSuite suite = new TestSuite(KurtosisTest.class);        suite.setName("Kurtosis  Tests");        return suite;    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {        return new Kurtosis();    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.kurt;    }        /**     * Make sure Double.NaN is returned iff n < 4     *     */    public void testNaN() {        Kurtosis kurt = new Kurtosis();        assertTrue(Double.isNaN(kurt.getResult()));        kurt.increment(1d);        assertTrue(Double.isNaN(kurt.getResult()));        kurt.increment(1d);        assertTrue(Double.isNaN(kurt.getResult()));        kurt.increment(1d);        assertTrue(Double.isNaN(kurt.getResult()));        kurt.increment(1d);        assertFalse(Double.isNaN(kurt.getResult()));          }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. *  * @version $Revision$ $Date$ */public class SkewnessTest extends StorelessUnivariateStatisticAbstractTest{    protected Skewness stat;        /**     * @param name     */    public SkewnessTest(String name) {        super(name);    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {        return new Skewness();    }    public static Test suite() {        TestSuite suite = new TestSuite(SkewnessTest.class);        suite.setName("Skewness Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.skew;    }        /**     * Make sure Double.NaN is returned iff n < 3     *     */    public void testNaN() {        Skewness skew = new Skewness();        assertTrue(Double.isNaN(skew.getResult()));        skew.increment(1d);        assertTrue(Double.isNaN(skew.getResult()));        skew.increment(1d);        assertTrue(Double.isNaN(skew.getResult()));        skew.increment(1d);        assertFalse(Double.isNaN(skew.getResult()));          }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. *  * @version $Revision$ $Date$ */public class VarianceTest extends StorelessUnivariateStatisticAbstractTest{    protected Variance stat;        /**     * @param name     */    public VarianceTest(String name) {        super(name);    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {        return new Variance();    }    public static Test suite() {        TestSuite suite = new TestSuite(VarianceTest.class);        suite.setName("Variance Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.var;    }        /**     * Make sure Double.NaN is returned iff n = 0     *     */    public void testNaN() {        StandardDeviation std = new StandardDeviation();        assertTrue(Double.isNaN(std.getResult()));        std.increment(1d);        assertEquals(0d, std.getResult(), 0);    }        /**     * Test population version of variance     */     public void testPopulation() {        double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};        SecondMoment m = new SecondMoment();        m.evaluate(values);  // side effect is to add values        Variance v1 = new Variance();        v1.setBiasCorrected(false);        assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);        v1.incrementAll(values);        assertEquals(populationVariance(values), v1.getResult(), 1E-14);        v1 = new Variance(false, m);        assertEquals(populationVariance(values), v1.getResult(), 1E-14);             v1 = new Variance(false);        assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);        v1.incrementAll(values);        assertEquals(populationVariance(values), v1.getResult(), 1E-14);         }        /**     * Definitional formula for population variance     */    protected double populationVariance(double[] v) {        double mean = new Mean().evaluate(v);        double sum = 0;        for (int i = 0; i < v.length; i++) {           sum += (v[i] - mean) * (v[i] - mean);         }        return sum / (double) v.length;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link FirstMoment} class. * @version $Revision$ $Date$ */public class FirstMomentTest extends StorelessUnivariateStatisticAbstractTest{    /** descriptive statistic. */    protected FirstMoment stat;        /**     * @param name     */    public FirstMomentTest(String name) {        super(name);    }        /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {        return new FirstMoment();    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.mean;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class GeometricMeanTest extends StorelessUnivariateStatisticAbstractTest{    protected GeometricMean stat;        /**     * @param name     */    public GeometricMeanTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(GeometricMeanTest.class);        suite.setName("Mean  Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {        return new GeometricMean();    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.geoMean;    }        public void testSpecialValues() {        GeometricMean mean = new GeometricMean();        // empty        assertTrue(Double.isNaN(mean.getResult()));                // finite data        mean.increment(1d);        assertFalse(Double.isNaN(mean.getResult()));                // add 0 -- makes log sum blow to minus infinity, should make 0        mean.increment(0d);        assertEquals(0d, mean.getResult(), 0);                // add positive infinity - note the minus infinity above        mean.increment(Double.POSITIVE_INFINITY);        assertTrue(Double.isNaN(mean.getResult()));                // clear        mean.clear();        assertTrue(Double.isNaN(mean.getResult()));                // positive infinity by itself        mean.increment(Double.POSITIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, mean.getResult(), 0);                // negative value -- should make NaN        mean.increment(-2d);        assertTrue(Double.isNaN(mean.getResult()));    }}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.DimensionMismatchException;import org.apache.commons.math.linear.RealMatrix;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;public class VectorialCovarianceTestextends TestCase {    public VectorialCovarianceTest(String name) {        super(name);        points = null;    }    public void testMismatch() {        try {            new VectorialCovariance(8).increment(new double[5]);            fail("an exception should have been thrown");        } catch (DimensionMismatchException dme) {            assertEquals(5, dme.getDimension1());            assertEquals(8, dme.getDimension2());        } catch (Exception e) {            fail("wrong exception type caught: " + e.getClass().getName());        }    }    public void testSimplistic() throws DimensionMismatchException {        VectorialCovariance stat = new VectorialCovariance(2);        stat.increment(new double[] {-1.0,  1.0});        stat.increment(new double[] { 1.0, -1.0});        RealMatrix c = stat.getResult();        assertEquals( 2.0, c.getEntry(0, 0), 1.0e-12);        assertEquals(-2.0, c.getEntry(1, 0), 1.0e-12);        assertEquals( 2.0, c.getEntry(1, 1), 1.0e-12);    }    public void testBasicStats() throws DimensionMismatchException {        VectorialCovariance stat = new VectorialCovariance(points[0].length);        for (int i = 0; i < points.length; ++i) {            stat.increment(points[i]);        }        assertEquals(points.length, stat.getN());        RealMatrix c = stat.getResult();        double[][] refC    = new double[][] {                { 8.0470, -1.9195, -3.4445},                {-1.9195,  1.0470,  3.2795},                {-3.4445,  3.2795, 12.2070}        };        for (int i = 0; i < c.getRowDimension(); ++i) {            for (int j = 0; j <= i; ++j) {                assertEquals(refC[i][j], c.getEntry(i, j), 1.0e-12);            }        }    }    public void setUp() {        points = new double[][] {                { 1.2, 2.3,  4.5},                {-0.7, 2.3,  5.0},                { 3.1, 0.0, -3.1},                { 6.0, 1.2,  4.2},                {-0.7, 2.3,  5.0}        };    }    public void tearDown() {        points = null;    }    public static Test suite() {        return new TestSuite(VectorialCovarianceTest.class);    }    private double [][] points;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link SecondMoment} class. * @version $Revision$ $Date$ */public class SecondMomentTest extends StorelessUnivariateStatisticAbstractTest {    /** descriptive statistic. */    protected SecondMoment stat;        /**     * @param name     */    public SecondMomentTest(String name) {        super(name);    }        /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {        return new SecondMoment();    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.secondMoment;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class MeanTest extends StorelessUnivariateStatisticAbstractTest{    protected Mean stat;        /**     * @param name     */    public MeanTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(MeanTest.class);        suite.setName("Mean  Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {        return new Mean();    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.mean;    }        public void testSmallSamples() {        Mean mean = new Mean();        assertTrue(Double.isNaN(mean.getResult()));        mean.increment(1d);        assertEquals(1d, mean.getResult(), 0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.summary;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link Sum} class. * @version $Revision$ $Date$ */public class SumTest extends StorelessUnivariateStatisticAbstractTest{    protected Sum stat;        /**     * @param name     */    public SumTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SumTest.class);        suite.setName("Sum Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {        return new Sum();          }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.sum;    }        public void testSpecialValues() {        Sum sum = new Sum();        assertTrue(Double.isNaN(sum.getResult()));        sum.increment(1);        assertEquals(1, sum.getResult(), 0);        sum.increment(Double.POSITIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);        sum.increment(Double.NEGATIVE_INFINITY);        assertTrue(Double.isNaN(sum.getResult()));        sum.increment(1);        assertTrue(Double.isNaN(sum.getResult()));     }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.summary;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class SumLogTest extends StorelessUnivariateStatisticAbstractTest{    protected SumOfLogs stat;        /**     * @param name     */    public SumLogTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SumLogTest.class);        suite.setName("SumLog Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {                return new SumOfLogs();    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.sumLog;    }        public void testSpecialValues() {        SumOfLogs sum = new SumOfLogs();        // empty        assertTrue(Double.isNaN(sum.getResult()));                // finite data        sum.increment(1d);        assertFalse(Double.isNaN(sum.getResult()));                // add negative infinity        sum.increment(0d);        assertEquals(Double.NEGATIVE_INFINITY, sum.getResult(), 0);                // add positive infinity -- should make NaN        sum.increment(Double.POSITIVE_INFINITY);        assertTrue(Double.isNaN(sum.getResult()));                // clear        sum.clear();        assertTrue(Double.isNaN(sum.getResult()));                // positive infinity by itself        sum.increment(Double.POSITIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);                // negative value -- should make NaN        sum.increment(-2d);        assertTrue(Double.isNaN(sum.getResult()));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.summary;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class ProductTest extends StorelessUnivariateStatisticAbstractTest{    protected Product stat;        /**     * @param name     */    public ProductTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(ProductTest.class);        suite.setName("Product Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {        return new Product();    }    public double getTolerance() {        return 10E8;    //sic -- big absolute error due to only 15 digits of accuracy in double    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.product;    }        public void testSpecialValues() {        Product product = new Product();        assertTrue(Double.isNaN(product.getResult()));        product.increment(1);        assertEquals(1, product.getResult(), 0);        product.increment(Double.POSITIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, product.getResult(), 0);        product.increment(Double.NEGATIVE_INFINITY);        assertEquals(Double.NEGATIVE_INFINITY, product.getResult(), 0);        product.increment(Double.NaN);        assertTrue(Double.isNaN(product.getResult()));         product.increment(1);        assertTrue(Double.isNaN(product.getResult()));     }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.summary;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link SumOfSquares} class. *  * @version $Revision$ $Date$ */public class SumSqTest extends StorelessUnivariateStatisticAbstractTest{    protected SumOfSquares stat;        /**     * @param name     */    public SumSqTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SumSqTest.class);        suite.setName("SumSq Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {        return new SumOfSquares();    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.sumSq;    }        public void testSpecialValues() {        SumOfSquares sumSq = new SumOfSquares();        assertTrue(Double.isNaN(sumSq.getResult()));        sumSq.increment(2d);        assertEquals(4d, sumSq.getResult(), 0);        sumSq.increment(Double.POSITIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);        sumSq.increment(Double.NEGATIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);        sumSq.increment(Double.NaN);        assertTrue(Double.isNaN(sumSq.getResult()));         sumSq.increment(1);        assertTrue(Double.isNaN(sumSq.getResult()));     }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import java.util.ArrayList;import java.util.List;import org.apache.commons.math.util.NumberTransformer;import org.apache.commons.math.util.TransformerMap;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link Univariate} class. * * @version $Revision$ $Date$ */public final class MixedListUnivariateImplTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double skewness = 0;    private double kurtosis = 0.5;    private double tolerance = 10E-15;    private TransformerMap transformers = new TransformerMap();        public MixedListUnivariateImplTest(String name) {        super(name);        transformers = new TransformerMap();        transformers.putTransformer(Foo.class, new NumberTransformer() {            public double transform(Object o) {                return Double.parseDouble(((Foo) o).heresFoo());            }        });        transformers.putTransformer(Bar.class, new NumberTransformer() {            public double transform(Object o) {                return Double.parseDouble(((Bar) o).heresBar());            }        });    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(MixedListUnivariateImplTest.class);        suite.setName("Mixed List Tests");        return suite;    }    /** test stats */    public void testStats() {        List externalList = new ArrayList();        DescriptiveStatistics u = new ListUnivariateImpl(externalList,transformers);        assertEquals("total count", 0, u.getN(), tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        assertEquals("N", n, u.getN(), tolerance);        assertEquals("sum", sum, u.getSum(), tolerance);        assertEquals("sumsq", sumSq, u.getSumsq(), tolerance);        assertEquals("var", var, u.getVariance(), tolerance);        assertEquals("std", std, u.getStandardDeviation(), tolerance);        assertEquals("mean", mean, u.getMean(), tolerance);        assertEquals("min", min, u.getMin(), tolerance);        assertEquals("max", max, u.getMax(), tolerance);        u.clear();        assertEquals("total count", 0, u.getN(), tolerance);    }    public void testN0andN1Conditions() throws Exception {        List list = new ArrayList();        DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList(),transformers);        assertTrue(            "Mean of n = 0 set should be NaN",            Double.isNaN(u.getMean()));        assertTrue(            "Standard Deviation of n = 0 set should be NaN",            Double.isNaN(u.getStandardDeviation()));        assertTrue(            "Variance of n = 0 set should be NaN",            Double.isNaN(u.getVariance()));        u.addValue(one);        assertTrue(            "Mean of n = 1 set should be value of single item n1, instead it is " + u.getMean() ,            u.getMean() == one);                    assertTrue(            "StdDev of n = 1 set should be zero, instead it is: "                + u.getStandardDeviation(),            u.getStandardDeviation() == 0);        assertTrue(            "Variance of n = 1 set should be zero",            u.getVariance() == 0);    }    public void testSkewAndKurtosis() {        ListUnivariateImpl u =            new ListUnivariateImpl(new ArrayList(), transformers);        u.addObject("12.5");        u.addObject(new Integer(12));        u.addObject("11.8");        u.addObject("14.2");        u.addObject(new Foo());        u.addObject("14.5");        u.addObject(new Long(21));        u.addObject("8.2");        u.addObject("10.3");        u.addObject("11.3");        u.addObject(new Float(14.1));        u.addObject("9.9");        u.addObject("12.2");        u.addObject(new Bar());        u.addObject("12.1");        u.addObject("11");        u.addObject(new Double(19.8));        u.addObject("11");        u.addObject("10");        u.addObject("8.8");        u.addObject("9");        u.addObject("12.3");        assertEquals("mean", 12.40455, u.getMean(), 0.0001);        assertEquals("variance", 10.00236, u.getVariance(), 0.0001);        assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);        assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList(),transformers);        u.setWindowSize(10);        u.addValue(1.0);        u.addValue(2.0);        u.addValue(3.0);        u.addValue(4.0);        assertEquals(            "Geometric mean not expected",            2.213364,            u.getGeometricMean(),            0.00001);        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution        // of a discarded element        for (int i = 0; i < 10; i++) {            u.addValue(i + 2);        }        // Values should be (2,3,4,5,6,7,8,9,10,11)        assertEquals(            "Geometric mean not expected",            5.755931,            u.getGeometricMean(),            0.00001);    }    public final class Foo {        public String heresFoo() {            return "14.9";        }    }    public final class Bar {        public String heresBar() {            return "12.0";        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;/** * Test cases for the {@link StatisticalSummaryValues} class. * * @version $Revision$ $Date$ */public final class StatisticalSummaryValuesTest extends TestCase {            public StatisticalSummaryValuesTest(String name) {        super(name);    }        public void setUp() {      }        public static Test suite() {        TestSuite suite = new TestSuite(StatisticalSummaryValuesTest.class);        suite.setName("StatisticalSummaryValues Tests");        return suite;    }          public void testSerialization() {        StatisticalSummaryValues u = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);        TestUtils.checkSerializedEquality(u);         StatisticalSummaryValues t = (StatisticalSummaryValues) TestUtils.serializeAndRecover(u);        verifyEquality(u, t);    }        public void testEqualsAndHashCode() {        StatisticalSummaryValues u  = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);        StatisticalSummaryValues t = null;        int emptyHash = u.hashCode();        assertTrue("reflexive", u.equals(u));        assertFalse("non-null compared to null", u.equals(t));        assertFalse("wrong type", u.equals(new Double(0)));        t = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);        assertTrue("instances with same data should be equal", t.equals(u));        assertEquals("hash code", u.hashCode(), t.hashCode());                u = new StatisticalSummaryValues(Double.NaN, 2, 3, 4, 5, 6);        t = new StatisticalSummaryValues(1, Double.NaN, 3, 4, 5, 6);        assertFalse("instances based on different data should be different",                 (u.equals(t) ||t.equals(u)));    }        private void verifyEquality(StatisticalSummaryValues s, StatisticalSummaryValues u) {        assertEquals("N",s.getN(),u.getN());        TestUtils.assertEquals("sum",s.getSum(),u.getSum(), 0);        TestUtils.assertEquals("var",s.getVariance(),u.getVariance(), 0);        TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(), 0);        TestUtils.assertEquals("mean",s.getMean(),u.getMean(), 0);        TestUtils.assertEquals("min",s.getMin(),u.getMin(), 0);        TestUtils.assertEquals("max",s.getMax(),u.getMax(), 0);       }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.TestCase;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public abstract class UnivariateStatisticAbstractTest extends TestCase {    protected double mean = 12.404545454545455d;    protected double geoMean = 12.070589161633011d;    protected double var = 10.00235930735931d;    protected double std = Math.sqrt(var);    protected double skew = 1.437423729196190d;    protected double kurt = 2.377191264804700d;    protected double min = 8.2d;    protected double max = 21d;    protected double median = 12d;    protected double percentile5 = 8.29d;    protected double percentile95 = 20.82d;    protected double product = 628096400563833396009676.9200400128d;    protected double sumLog = 54.7969806116451507d;    protected double sumSq = 3595.250d;    protected double sum = 272.90d;    protected double secondMoment = 210.04954545454547d;    protected double thirdMoment = 868.0906859504136;    protected double fourthMoment = 9244.080993773481;    protected double tolerance = 10E-12;    protected double[] testArray =        {12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3,          14.1, 9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10,  8.8,           9, 12.3 };    public UnivariateStatisticAbstractTest(String name) {        super(name);    }    public abstract UnivariateStatistic getUnivariateStatistic();    public abstract double expectedValue();    public double getTolerance() {        return tolerance;    }    public void testEvaluation() throws Exception {           assertEquals(            expectedValue(),            getUnivariateStatistic().evaluate(testArray),            getTolerance());    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.random.RandomData;import org.apache.commons.math.random.RandomDataImpl;/** * Test cases for the {@link Univariate} class. * * @version $Revision$ $Date$ */public final class DescriptiveStatisticsImplTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double skewness = 0;    private double kurtosis = 0.5;    private double tolerance = 10E-15;        public DescriptiveStatisticsImplTest(String name) {        super(name);    }        public void setUp() {      }        public static Test suite() {        TestSuite suite = new TestSuite(DescriptiveStatisticsImplTest.class);        suite.setName("DescriptiveStatistics Tests");        return suite;    }        /** test stats */    public void testStats() {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();         assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }             public void testN0andN1Conditions() throws Exception {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();                             assertTrue("Mean of n = 0 set should be NaN",                 Double.isNaN( u.getMean() ) );            assertTrue("Standard Deviation of n = 0 set should be NaN",                 Double.isNaN( u.getStandardDeviation() ) );            assertTrue("Variance of n = 0 set should be NaN",                Double.isNaN(u.getVariance() ) );            u.addValue(one);            assertTrue( "Mean of n = 1 set should be value of single item n1",                u.getMean() == one);            assertTrue( "StdDev of n = 1 set should be zero, instead it is: "                 + u.getStandardDeviation(), u.getStandardDeviation() == 0);            assertTrue( "Variance of n = 1 set should be zero",                 u.getVariance() == 0);      }        public void testSkewAndKurtosis() {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();                 double[] testArray =         { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,          9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };        for( int i = 0; i < testArray.length; i++) {            u.addValue( testArray[i]);        }                assertEquals("mean", 12.40455, u.getMean(), 0.0001);        assertEquals("variance", 10.00236, u.getVariance(), 0.0001);        assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);        assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();         u.setWindowSize(10);                        u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        //assertEquals( "Product not expected",         //    24.0, u.getProduct(), Double.MIN_VALUE );        assertEquals( "Geometric mean not expected",             2.213364, u.getGeometricMean(), 0.00001 );        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution        // of a discarded element        for( int i = 0; i < 10; i++ ) {            u.addValue( i + 2 );        }        // Values should be (2,3,4,5,6,7,8,9,10,11)                //assertEquals( "Product not expected", 39916800.0,         //    u.getProduct(), 0.00001 );        assertEquals( "Geometric mean not expected", 5.755931,             u.getGeometricMean(), 0.00001 );    }        public void testGetSortedValues() {        double[] test1 = {5,4,3,2,1};        double[] test2 = {5,2,1,3,4,0};        double[] test3 = {1};        int[] testi = null;        double[] test4 = null;        RandomData rd = new RandomDataImpl();        tstGetSortedValues(test1);        tstGetSortedValues(test2);        tstGetSortedValues(test3);        for (int i = 0; i < 10; i++) {            testi = rd.nextPermutation(10,6);            test4 = new double[6];            for (int j = 0; j < testi.length; j++) {                test4[j] = (double) testi[j];            }            tstGetSortedValues(test4);        }        for (int i = 0; i < 10; i++) {            testi = rd.nextPermutation(10,5);            test4 = new double[5];            for (int j = 0; j < testi.length; j++) {                test4[j] = (double) testi[j];            }            tstGetSortedValues(test4);        }            }                private void tstGetSortedValues(double[] test) {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();         for (int i = 0; i < test.length; i++) {            u.addValue(test[i]);        }        double[] sorted = u.getSortedValues();        if (sorted.length != test.length) {            fail("wrong length for sorted values array");        }        for (int i = 0; i < sorted.length-1; i++) {            if (sorted[i] > sorted[i+1]) {                fail("sorted values out of sequence");            }        }    }        public void testPercentiles() {        double[] test = {5,4,3,2,1};        DescriptiveStatistics u = DescriptiveStatistics.newInstance();         for (int i = 0; i < test.length; i++) {            u.addValue(test[i]);        }        assertEquals("expecting min",1,u.getPercentile(5),10E-12);        assertEquals("expecting max",5,u.getPercentile(99),10E-12);        assertEquals("expecting middle",3,u.getPercentile(50),10E-12);        try {            double x = u.getPercentile(0);            fail("expecting IllegalArgumentException for getPercentile(0)");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = u.getPercentile(120);            fail("expecting IllegalArgumentException for getPercentile(120)");        } catch (IllegalArgumentException ex) {            ;        }                u.clear();        double[] test2 = {1,2,3,4};        for (int i = 0; i < test2.length; i++) {            u.addValue(test2[i]);        }        assertEquals("Q1",1.25,u.getPercentile(25),10E-12);        assertEquals("Q3",3.75,u.getPercentile(75),10E-12);        assertEquals("Q2",2.5,u.getPercentile(50),10E-12);                u.clear();        double[] test3 = {1};        for (int i = 0; i < test3.length; i++) {            u.addValue(test3[i]);        }        assertEquals("Q1",1,u.getPercentile(25),10E-12);        assertEquals("Q3",1,u.getPercentile(75),10E-12);        assertEquals("Q2",1,u.getPercentile(50),10E-12);                u.clear();        RandomData rd = new RandomDataImpl();        int[] testi = rd.nextPermutation(100,100); // will contain 0-99        for (int j = 0; j < testi.length; j++) {            u.addValue((double) testi[j]);  //OK, laugh at me for the cast        }        for (int i = 1; i < 100; i++) {            assertEquals("percentile " + i,                (double) i-1 + (double) i*(.01), u.getPercentile(i),10E-12);        }                u.clear();        double[] test4 = {1,2,3,4,100};        for (int i = 0; i < test4.length; i++) {            u.addValue(test4[i]);        }        assertEquals("80th",80.8,u.getPercentile(80),10E-12);                u.clear();        assertTrue("empty value set should return NaN",            Double.isNaN(u.getPercentile(50)));    }                                     }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;import org.apache.commons.math.random.RandomData;import org.apache.commons.math.random.RandomDataImpl;/** * Test cases for the {@link Univariate} class. * * @version $Revision$ $Date$ */public final class DescriptiveStatisticsTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double skewness = 0;    private double kurtosis = 0.5;    private double tolerance = 10E-15;        public DescriptiveStatisticsTest(String name) {        super(name);    }        public void setUp() {      }        public static Test suite() {        TestSuite suite = new TestSuite(DescriptiveStatisticsTest.class);        suite.setName("Descriptive Statistics Tests");        return suite;    }        /** test stats */    public void testStats() {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();         assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }             public void testN0andN1Conditions() throws Exception {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();                            assertTrue("Mean of n = 0 set should be NaN",                 Double.isNaN( u.getMean() ) );            assertTrue("Standard Deviation of n = 0 set should be NaN",                 Double.isNaN( u.getStandardDeviation() ) );            assertTrue("Variance of n = 0 set should be NaN",                Double.isNaN(u.getVariance() ) );            u.addValue(one);            assertTrue( "Mean of n = 1 set should be value of single item n1",                u.getMean() == one);            assertTrue( "StdDev of n = 1 set should be zero, instead it is: "                 + u.getStandardDeviation(), u.getStandardDeviation() == 0);            assertTrue( "Variance of n = 1 set should be zero",                 u.getVariance() == 0);      }        public void testSkewAndKurtosis() {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();                double[] testArray =         { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,          9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };        for( int i = 0; i < testArray.length; i++) {            u.addValue( testArray[i]);        }                assertEquals("mean", 12.40455, u.getMean(), 0.0001);        assertEquals("variance", 10.00236, u.getVariance(), 0.0001);        assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);        assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();        u.setWindowSize(10);                        u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        //assertEquals( "Product not expected",         //    24.0, u.getProduct(), Double.MIN_VALUE );        assertEquals( "Geometric mean not expected",             2.213364, u.getGeometricMean(), 0.00001 );        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution        // of a discarded element        for( int i = 0; i < 10; i++ ) {            u.addValue( i + 2 );        }        // Values should be (2,3,4,5,6,7,8,9,10,11)                //assertEquals( "Product not expected", 39916800.0,         //    u.getProduct(), 0.00001 );        assertEquals( "Geometric mean not expected", 5.755931,             u.getGeometricMean(), 0.00001 );    }        public void testAddValue() {        double[] test1 = {5,4,3,2,1,0};        double[] test2 = {5,2,1,0,4,3};        DescriptiveStatistics stats = DescriptiveStatistics.newInstance();        stats.setWindowSize(12);                for(int i = 0; i < test1.length; i++){            stats.addValue(test1[i]);        }                     double[] test3 = stats.getValues();                for(int i = 0; i < 6; i++){            assertEquals( "Added value ["+i+"] not equal",             test3[i], test1[i],0.0);            //System.out.println(test3[i] + " "+test1[i]);        }                             for(int i = 0; i < test2.length; i++){            stats.addValue(test2[i]);        }              test3 = stats.getValues();                  for(int i = 6; i < 12; i++){            assertEquals( "Added value ["+i+"] not equal",             test3[i], test2[i-6],0.0);            //System.out.println(test3[i] + " "+test2[i-6]);        }                    for(int i = 0; i < test2.length; i++){            stats.addValue(test2[i]);        }              test3 = stats.getValues();                  for(int i = 0; i < 6; i++){            assertEquals( "Added value ["+i+"] not equal",             test3[i], test2[i],0.0);            //System.out.println(test3[i] + " "+test2[i]);        }                  for(int i = 6; i < 12; i++){            assertEquals( "Added value ["+i+"] not equal",             test3[i], test2[i-6],0.0);            //System.out.println(test3[i] + " "+test2[i-6]);        }               }        public void testGetSortedValues() {        double[] test1 = {5,4,3,2,1};        double[] test2 = {5,2,1,3,4,0};        double[] test3 = {1};        int[] testi = null;        double[] test4 = null;        RandomData rd = new RandomDataImpl();        tstGetSortedValues(test1);        tstGetSortedValues(test2);        tstGetSortedValues(test3);        for (int i = 0; i < 10; i++) {            testi = rd.nextPermutation(10,6);            test4 = new double[6];            for (int j = 0; j < testi.length; j++) {                test4[j] = (double) testi[j];            }            tstGetSortedValues(test4);        }        for (int i = 0; i < 10; i++) {            testi = rd.nextPermutation(10,5);            test4 = new double[5];            for (int j = 0; j < testi.length; j++) {                test4[j] = (double) testi[j];            }            tstGetSortedValues(test4);        }            }                        private void tstGetSortedValues(double[] test) {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();        u.setWindowSize(test.length);        for (int i = 0; i < test.length; i++) {            u.addValue(test[i]);        }        double[] sorted = u.getSortedValues();        if (sorted.length != test.length) {            fail("wrong length for sorted values array");        }        for (int i = 0; i < sorted.length-1; i++) {            if (sorted[i] > sorted[i+1]) {                fail("sorted values out of sequence");            }        }    }        public void testPercentiles() {        double[] test = {5,4,3,2,1};        DescriptiveStatistics u = DescriptiveStatistics.newInstance();        u.setWindowSize(110);        for (int i = 0; i < test.length; i++) {            u.addValue(test[i]);        }        assertEquals("expecting min",1,u.getPercentile(5),10E-12);        assertEquals("expecting max",5,u.getPercentile(99),10E-12);        assertEquals("expecting middle",3,u.getPercentile(50),10E-12);        try {            double x = u.getPercentile(0);            fail("expecting IllegalArgumentException for getPercentile(0)");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = u.getPercentile(120);            fail("expecting IllegalArgumentException for getPercentile(120)");        } catch (IllegalArgumentException ex) {            ;        }                u.clear();        double[] test2 = {1,2,3,4};        for (int i = 0; i < test2.length; i++) {            u.addValue(test2[i]);        }        assertEquals("Q1",1.25,u.getPercentile(25),10E-12);        assertEquals("Q3",3.75,u.getPercentile(75),10E-12);        assertEquals("Q2",2.5,u.getPercentile(50),10E-12);                u.clear();        double[] test3 = {1};        for (int i = 0; i < test3.length; i++) {            u.addValue(test3[i]);        }        assertEquals("Q1",1,u.getPercentile(25),10E-12);        assertEquals("Q3",1,u.getPercentile(75),10E-12);        assertEquals("Q2",1,u.getPercentile(50),10E-12);                u.clear();        RandomData rd = new RandomDataImpl();        int[] testi = rd.nextPermutation(100,100); // will contain 0-99        for (int j = 0; j < testi.length; j++) {            u.addValue((double) testi[j]);  //OK, laugh at me for the cast        }        for (int i = 1; i < 100; i++) {            assertEquals("percentile " + i,                (double) i-1 + (double) i*(.01), u.getPercentile(i),10E-12);        }                u.clear();        double[] test4 = {1,2,3,4,100};        for (int i = 0; i < test4.length; i++) {            u.addValue(test4[i]);        }        assertEquals("80th",80.8,u.getPercentile(80),10E-12);                u.clear();        assertTrue("empty value set should return NaN",            Double.isNaN(u.getPercentile(50)));    }                          /** test stats */    public void testSerialization() {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();         assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);                DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u);          u2.addValue(two);        u2.addValue(three);                assertEquals("N",n,u2.getN(),tolerance);        assertEquals("sum",sum,u2.getSum(),tolerance);        assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance);        assertEquals("var",var,u2.getVariance(),tolerance);        assertEquals("std",std,u2.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u2.getMean(),tolerance);        assertEquals("min",min,u2.getMin(),tolerance);        assertEquals("max",max,u2.getMax(),tolerance);        u2.clear();        assertEquals("total count",0,u2.getN(),tolerance);        }           public void testNewInstanceClassNull() {        try {            DescriptiveStatistics u = DescriptiveStatistics.newInstance((Class)null);            fail("null is not a valid descriptive statistics class");        } catch (NullPointerException ex) {            // success        } catch (Exception ex) {            fail();        }            }        public void testNewInstanceClassValid() {        try {            DescriptiveStatistics u = DescriptiveStatistics.newInstance(                DescriptiveStatisticsImpl.class);            assertNotNull(u);            assertTrue(u instanceof DescriptiveStatisticsImpl);        } catch (Exception ex) {            fail();        }    }        public void testWindowSize() {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();        u.setWindowSize(1234);        assertEquals(1234, u.getWindowSize());                u.addValue(1.0);        u.addValue(2.0);        u.addValue(3.0);        u.addValue(4.0);        u.addValue(5.0);        assertEquals(5, u.getN());                u.setWindowSize(DescriptiveStatistics.INFINITE_WINDOW);        assertEquals(5, u.getN());    }        public void testWindowing() {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();        u.setWindowSize(2);                u.addValue(1.0);        assertEquals(1.0, u.getMean(), tolerance);                u.addValue(2.0);        assertEquals(1.5, u.getMean(), tolerance);                u.addValue(3.0);        assertEquals(2.5, u.getMean(), tolerance);                u.setWindowSize(1);        assertEquals(3.0, u.getMean(), tolerance);    }        public void testToString() {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();        assertTrue(u.toString().indexOf("NaN") > 0);          assertTrue(u.toString().startsWith("DescriptiveStatistics"));        double[] testArray =             { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,                9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };        for( int i = 0; i < testArray.length; i++) {            u.addValue( testArray[i]);        }                assertTrue(u.toString().indexOf("NaN") == -1);          assertTrue(u.toString().startsWith("DescriptiveStatistics"));    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.moment.Mean;/** * Tests for AbstractUnivariateStatistic  * * @version $Revision$ $Date$ */public class AbstractUnivariateStatisticTest extends TestCase {        public AbstractUnivariateStatisticTest(String name) {        super(name);    }        public static Test suite() {        TestSuite suite = new TestSuite(AbstractUnivariateStatisticTest.class);        suite.setName("AbstractUnivariateStatistic Tests");        return suite;    }        protected double[] testArray = {0, 1, 2, 3, 4, 5};    protected double[] nullArray = null;    protected double[] singletonArray = {0};    protected Mean testStatistic = new Mean();        public void testTestPositive() {        for (int j = 0; j < 6; j++) {            for (int i = 1; i < (7 - j); i++) {                assertTrue(testStatistic.test(testArray, 0, i));            }          }        assertTrue(testStatistic.test(singletonArray, 0, 1));    }        public void testTestNegative() {        assertFalse(testStatistic.test(singletonArray, 0, 0));        assertFalse(testStatistic.test(testArray, 0, 0));        try {            testStatistic.test(singletonArray, 2, 1);  // start past end            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, 0, 7);  // end past end            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, -1, 1);  // start negative            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, 0, -1);  // length negative            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(nullArray, 0, 1);  // null array            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }          } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import java.util.ArrayList;import java.util.List;import org.apache.commons.math.TestUtils;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link Univariate} class. * * @version $Revision$ $Date$ */public final class ListUnivariateImplTest extends TestCase {        private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double skewness = 0;    private double kurtosis = 0.5;    private double tolerance = 10E-15;        public ListUnivariateImplTest(String name) {        super(name);    }        public void setUp() {      }        public static Test suite() {        TestSuite suite = new TestSuite(ListUnivariateImplTest.class);        suite.setName("Frequency Tests");        return suite;    }        /** test stats */    public void testStats() {        List externalList = new ArrayList();                DescriptiveStatistics u = new ListUnivariateImpl( externalList );         assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }             public void testN0andN1Conditions() throws Exception {        List list = new ArrayList();                DescriptiveStatistics u = new ListUnivariateImpl( list );                        assertTrue("Mean of n = 0 set should be NaN", Double.isNaN( u.getMean() ) );        assertTrue("Standard Deviation of n = 0 set should be NaN", Double.isNaN( u.getStandardDeviation() ) );        assertTrue("Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance() ) );        list.add( new Double(one));        assertTrue( "Mean of n = 1 set should be value of single item n1", u.getMean() == one);        assertTrue( "StdDev of n = 1 set should be zero, instead it is: " + u.getStandardDeviation(), u.getStandardDeviation() == 0);        assertTrue( "Variance of n = 1 set should be zero", u.getVariance() == 0);      }        public void testSkewAndKurtosis() {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();                double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,                                             9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };        for( int i = 0; i < testArray.length; i++) {            u.addValue( testArray[i]);        }                assertEquals("mean", 12.40455, u.getMean(), 0.0001);        assertEquals("variance", 10.00236, u.getVariance(), 0.0001);        assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);        assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());        u.setWindowSize(10);                        u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001 );        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution        // of a discarded element        for( int i = 0; i < 10; i++ ) {            u.addValue( i + 2 );        }        // Values should be (2,3,4,5,6,7,8,9,10,11)                assertEquals( "Geometric mean not expected", 5.755931, u.getGeometricMean(), 0.00001 );    }        /** test stats */    public void testSerialization() {                DescriptiveStatistics u = null;                try {            u = DescriptiveStatistics.newInstance(ListUnivariateImpl.class);        } catch (InstantiationException e) {            fail(e.getMessage());        } catch (IllegalAccessException e) {            fail(e.getMessage());        }                assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);                DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u);          u2.addValue(two);        u2.addValue(three);                assertEquals("N",n,u2.getN(),tolerance);        assertEquals("sum",sum,u2.getSum(),tolerance);        assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance);        assertEquals("var",var,u2.getVariance(),tolerance);        assertEquals("std",std,u2.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u2.getMean(),tolerance);        assertEquals("min",min,u2.getMin(),tolerance);        assertEquals("max",max,u2.getMax(),tolerance);        u2.clear();        assertEquals("total count",0,u2.getN(),tolerance);        }       }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;/** * Test cases for the {@link DescriptiveStatistics} class. * * @version $Revision$ $Date$ */public final class SummaryStatisticsImplTest extends TestCase {    private double one = 1;    private float twoF = 2;    private long twoL = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double tolerance = 10E-15;        protected SummaryStatistics u = null;        public SummaryStatisticsImplTest(String name) {        super(name);    }        public void setUp() {          u = SummaryStatistics.newInstance();    }        public static Test suite() {        TestSuite suite = new TestSuite(SummaryStatisticsImplTest.class);        suite.setName("Frequency Tests");        return suite;    }        /** test stats */    public void testStats() {        assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(twoF);        u.addValue(twoL);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }             public void testN0andN1Conditions() throws Exception {        assertTrue("Mean of n = 0 set should be NaN",             Double.isNaN( u.getMean() ) );        assertTrue("Standard Deviation of n = 0 set should be NaN",             Double.isNaN( u.getStandardDeviation() ) );        assertTrue("Variance of n = 0 set should be NaN",             Double.isNaN(u.getVariance() ) );                /* n=1 */        u.addValue(one);        assertTrue("mean should be one (n = 1)",             u.getMean() == one);        assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(),             u.getGeometricMean() == one);        assertTrue("Std should be zero (n = 1)",             u.getStandardDeviation() == 0.0);        assertTrue("variance should be zero (n = 1)",             u.getVariance() == 0.0);                            /* n=2 */                       u.addValue(twoF);        assertTrue("Std should not be zero (n = 2)",             u.getStandardDeviation() != 0.0);        assertTrue("variance should not be zero (n = 2)",             u.getVariance() != 0.0);                }    public void testProductAndGeometricMean() throws Exception {                    u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        assertEquals( "Geometric mean not expected", 2.213364,             u.getGeometricMean(), 0.00001 );    }        public void testNaNContracts() {        double nan = Double.NaN;        assertTrue("mean not NaN",Double.isNaN(u.getMean()));         assertTrue("min not NaN",Double.isNaN(u.getMin()));         assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation()));         assertTrue("var not NaN",Double.isNaN(u.getVariance()));         assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));                u.addValue(1.0);                assertEquals( "mean not expected", 1.0,             u.getMean(), Double.MIN_VALUE);        assertEquals( "variance not expected", 0.0,             u.getVariance(), Double.MIN_VALUE);        assertEquals( "geometric mean not expected", 1.0,             u.getGeometricMean(), Double.MIN_VALUE);                u.addValue(-1.0);                assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));                u.addValue(0.0);                assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));                //FiXME: test all other NaN contract specs    }        public void testGetSummary() {          StatisticalSummary summary = u.getSummary();        verifySummary(summary);        u.addValue(1d);        summary = u.getSummary();        verifySummary(summary);        u.addValue(2d);        summary = u.getSummary();        verifySummary(summary);        u.addValue(2d);        summary = u.getSummary();        verifySummary(summary);         }        public void testSerialization() {        // Empty test        TestUtils.checkSerializedEquality(u);        SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);        StatisticalSummary summary = s.getSummary();        verifySummary(summary);                // Add some data        u.addValue(2d);        u.addValue(1d);        u.addValue(3d);        u.addValue(4d);        u.addValue(5d);                // Test again        TestUtils.checkSerializedEquality(u);        s = (SummaryStatistics) TestUtils.serializeAndRecover(u);        summary = s.getSummary();        verifySummary(summary);            }        public void testEqualsAndHashCode() {        SummaryStatistics t = null;        int emptyHash = u.hashCode();        assertTrue("reflexive", u.equals(u));        assertFalse("non-null compared to null", u.equals(t));        assertFalse("wrong type", u.equals(new Double(0)));        t = SummaryStatistics.newInstance();        assertTrue("empty instances should be equal", t.equals(u));        assertTrue("empty instances should be equal", u.equals(t));        assertEquals("empty hash code", emptyHash, t.hashCode());                // Add some data to u        u.addValue(2d);        u.addValue(1d);        u.addValue(3d);        u.addValue(4d);        assertFalse("different n's should make instances not equal", t.equals(u));        assertFalse("different n's should make instances not equal", u.equals(t));        assertTrue("different n's should make hashcodes different",                 u.hashCode() != t.hashCode());                //Add data in different order to t, should not affect identity or hashcode        t.addValue(4d);        t.addValue(2d);        t.addValue(3d);        t.addValue(1d);        assertTrue("summaries based on same data should be equal", t.equals(u));        assertTrue("summaries based on same data should be equal", u.equals(t));        assertEquals("summaries based on same data should have same hashcodes",                 u.hashCode(), t.hashCode());                   // Clear and make sure summaries are indistinguishable from empty summary        u.clear();        t.clear();        assertTrue("empty instances should be equal", t.equals(u));        assertTrue("empty instances should be equal", u.equals(t));        assertEquals("empty hash code", emptyHash, t.hashCode());        assertEquals("empty hash code", emptyHash, u.hashCode());    }        private void verifySummary(StatisticalSummary s) {        assertEquals("N",s.getN(),u.getN());        TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);        TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);        TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);        TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);        TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);        TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);       }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import org.apache.commons.math.stat.descriptive.moment.FourthMoment;import org.apache.commons.math.stat.descriptive.moment.Kurtosis;import org.apache.commons.math.stat.descriptive.moment.Mean;import org.apache.commons.math.stat.descriptive.moment.Skewness;import org.apache.commons.math.stat.descriptive.moment.Variance;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class InteractionTest extends TestCase {    protected double mean = 12.40454545454550;    protected double var = 10.00235930735930;    protected double skew = 1.437423729196190;    protected double kurt = 2.377191264804700;    protected double tolerance = 10E-12;    protected double[] testArray =        {            12.5,            12,            11.8,            14.2,            14.9,            14.5,            21,            8.2,            10.3,            11.3,            14.1,            9.9,            12.2,            12,            12.1,            11,            19.8,            11,            10,            8.8,            9,            12.3 };    public InteractionTest(String name) {        super(name);    }    public void testInteraction() {                FourthMoment m4 = new FourthMoment();        Mean m = new Mean(m4);        Variance v = new Variance(m4);        Skewness s= new Skewness(m4);        Kurtosis k = new Kurtosis(m4);        for (int i = 0; i < testArray.length; i++){            m4.increment(testArray[i]);        }                assertEquals(mean,m.getResult(),tolerance);        assertEquals(var,v.getResult(),tolerance);        assertEquals(skew ,s.getResult(),tolerance);        assertEquals(kurt,k.getResult(),tolerance);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.moment.SecondMoment;/** * Test cases for {@link StorelessUnivariateStatistic} classes. * @version $Revision$ $Date$ */public abstract class StorelessUnivariateStatisticAbstractTest    extends UnivariateStatisticAbstractTest {    public StorelessUnivariateStatisticAbstractTest(String name) {        super(name);    }        /** Small sample arrays */    protected double[][] smallSamples = {{}, {1}, {1,2}, {1,2,3}, {1,2,3,4}};    /** Return a new instance of the statistic */    public abstract UnivariateStatistic getUnivariateStatistic();    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */    public abstract double expectedValue();        /** Verify that calling increment() in a loop over testArray results in correct state */    public void testIncrementation() throws Exception {        StorelessUnivariateStatistic statistic =            (StorelessUnivariateStatistic) getUnivariateStatistic();        statistic.clear();        for (int i = 0; i < testArray.length; i++) {            statistic.increment(testArray[i]);        }        assertEquals(expectedValue(), statistic.getResult(), getTolerance());        assertEquals(testArray.length, statistic.getN());        statistic.clear();        assertTrue(Double.isNaN(statistic.getResult()));        assertEquals(0, statistic.getN());    }    public void testSerialization() throws Exception {        StorelessUnivariateStatistic statistic =            (StorelessUnivariateStatistic) getUnivariateStatistic();                TestUtils.checkSerializedEquality(statistic);        statistic.clear();        for (int i = 0; i < testArray.length; i++) {            statistic.increment(testArray[i]);            if(i % 5 == 0)                statistic = (StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);         }                TestUtils.checkSerializedEquality(statistic);                assertEquals(expectedValue(), statistic.getResult(), getTolerance());        statistic.clear();        assertTrue(Double.isNaN(statistic.getResult()));    }        public void testEqualsAndHashCode() {        StorelessUnivariateStatistic statistic =            (StorelessUnivariateStatistic) getUnivariateStatistic();        StorelessUnivariateStatistic statistic2 = null;                assertTrue("non-null, compared to null", !statistic.equals(statistic2));        assertTrue("reflexive, non-null", statistic.equals(statistic));                int emptyHash = statistic.hashCode();        statistic2 = (StorelessUnivariateStatistic) getUnivariateStatistic();        assertTrue("empty stats should be equal", statistic.equals(statistic2));        assertEquals("empty stats should have the same hashcode",                 emptyHash, statistic2.hashCode());                statistic.increment(1d);        assertTrue("reflexive, non-empty", statistic.equals(statistic));        assertTrue("non-empty, compared to empty", !statistic.equals(statistic2));        assertTrue("non-empty, compared to empty", !statistic2.equals(statistic));        assertTrue("non-empty stat should have different hashcode from empty stat",                statistic.hashCode() != emptyHash);                statistic2.increment(1d);        assertTrue("stats with same data should be equal", statistic.equals(statistic2));        assertEquals("stats with same data should have the same hashcode",                 statistic.hashCode(), statistic2.hashCode());                statistic.increment(Double.POSITIVE_INFINITY);        assertTrue("stats with different n's should not be equal", !statistic2.equals(statistic));        assertTrue("stats with different n's should have different hashcodes",                statistic.hashCode() != statistic2.hashCode());                statistic2.increment(Double.POSITIVE_INFINITY);        assertTrue("stats with same data should be equal", statistic.equals(statistic2));        assertEquals("stats with same data should have the same hashcode",                 statistic.hashCode(), statistic2.hashCode());                 statistic.clear();        statistic2.clear();        assertTrue("cleared stats should be equal", statistic.equals(statistic2));        assertEquals("cleared stats should have thashcode of empty stat",                 emptyHash, statistic2.hashCode());        assertEquals("cleared stats should have thashcode of empty stat",                 emptyHash, statistic.hashCode());            }        public void testMomentSmallSamples() {        UnivariateStatistic stat = getUnivariateStatistic();        if (stat instanceof SecondMoment) {            SecondMoment moment = (SecondMoment) getUnivariateStatistic();            assertTrue(Double.isNaN(moment.getResult()));            moment.increment(1d);            assertEquals(0d, moment.getResult(), 0);        }    }        /**      * Make sure that evaluate(double[]) and inrementAll(double[]),      * getResult() give same results.     */    public void testConsistency() {        StorelessUnivariateStatistic stat = (StorelessUnivariateStatistic) getUnivariateStatistic();        stat.incrementAll(testArray);        assertEquals(stat.getResult(), stat.evaluate(testArray), getTolerance());        for (int i = 0; i < smallSamples.length; i++) {            stat.clear();            for (int j =0; j < smallSamples[i].length; j++) {                stat.increment(smallSamples[i][j]);            }            TestUtils.assertEquals(stat.getResult(), stat.evaluate(smallSamples[i]), getTolerance());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.SummaryStatistics;/** * Test cases for the TTestImpl class. * * @version $Revision$ $Date$ */public class TTestTest extends TestCase {    protected TTest testStatistic = new TTestImpl();        private double[] tooShortObs = { 1.0 };    private double[] nullObserved = null;    private double[] emptyObs = {};    private SummaryStatistics emptyStats = SummaryStatistics.newInstance();      private SummaryStatistics nullStats = null;       SummaryStatistics tooShortStats = null;      public TTestTest(String name) {        super(name);    }    public void setUp() {        tooShortStats = SummaryStatistics.newInstance();        tooShortStats.addValue(0d);    }    public static Test suite() {        TestSuite suite = new TestSuite(TTestTest.class);        suite.setName("TestStatistic Tests");        return suite;    }    public void testOneSampleT() throws Exception {        double[] observed =            {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0,  88.0, 98.0, 94.0, 101.0, 92.0, 95.0 };        double mu = 100.0;        SummaryStatistics sampleStats = null;        sampleStats = SummaryStatistics.newInstance();        for (int i = 0; i < observed.length; i++) {            sampleStats.addValue(observed[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("t statistic",  -2.81976445346,                testStatistic.t(mu, observed), 10E-10);        assertEquals("t statistic",  -2.81976445346,                testStatistic.t(mu, sampleStats), 10E-10);        assertEquals("p value", 0.0136390585873,                testStatistic.tTest(mu, observed), 10E-10);        assertEquals("p value", 0.0136390585873,                testStatistic.tTest(mu, sampleStats), 10E-10);        try {            testStatistic.t(mu, nullObserved);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(mu, nullStats);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(mu, emptyObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }         try {            testStatistic.t(mu, emptyStats);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(mu, tooShortObs);            fail("insufficient data to compute t statistic, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // exptected        }        try {            testStatistic.tTest(mu, tooShortObs);            fail("insufficient data to perform t test, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {           // expected        }          try {            testStatistic.t(mu, tooShortStats);            fail("insufficient data to compute t statistic, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // exptected        }        try {            testStatistic.tTest(mu, tooShortStats);            fail("insufficient data to perform t test, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // exptected        }      }        public void testOneSampleTTest() throws Exception {        double[] oneSidedP =            {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d };        SummaryStatistics oneSidedPStats = SummaryStatistics.newInstance();            for (int i = 0; i < oneSidedP.length; i++) {            oneSidedPStats.addValue(oneSidedP[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("one sample t stat", 3.86485535541,                 testStatistic.t(0d, oneSidedP), 10E-10);        assertEquals("one sample t stat", 3.86485535541,                 testStatistic.t(0d, oneSidedPStats),1E-10);        assertEquals("one sample p value", 0.000521637019637,                testStatistic.tTest(0d, oneSidedP) / 2d, 10E-10);        assertEquals("one sample p value", 0.000521637019637,                testStatistic.tTest(0d, oneSidedPStats) / 2d, 10E-5);        assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedP, 0.01));        assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedPStats, 0.01));        assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedP, 0.0001));        assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedPStats, 0.0001));                 try {            testStatistic.tTest(0d, oneSidedP, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // exptected        }                  try {            testStatistic.tTest(0d, oneSidedPStats, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }              }        public void testTwoSampleTHeterscedastic() throws Exception {        double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };        double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };        SummaryStatistics sampleStats1 = SummaryStatistics.newInstance();          for (int i = 0; i < sample1.length; i++) {            sampleStats1.addValue(sample1[i]);        }        SummaryStatistics sampleStats2 = SummaryStatistics.newInstance();            for (int i = 0; i < sample2.length; i++) {            sampleStats2.addValue(sample2[i]);        }                 // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("two sample heteroscedastic t stat", 1.60371728768,                 testStatistic.t(sample1, sample2), 1E-10);        assertEquals("two sample heteroscedastic t stat", 1.60371728768,                 testStatistic.t(sampleStats1, sampleStats2), 1E-10);        assertEquals("two sample heteroscedastic p value", 0.128839369622,                 testStatistic.tTest(sample1, sample2), 1E-10);        assertEquals("two sample heteroscedastic p value", 0.128839369622,                 testStatistic.tTest(sampleStats1, sampleStats2), 1E-10);             assertTrue("two sample heteroscedastic t-test reject",                 testStatistic.tTest(sample1, sample2, 0.2));        assertTrue("two sample heteroscedastic t-test reject",                 testStatistic.tTest(sampleStats1, sampleStats2, 0.2));        assertTrue("two sample heteroscedastic t-test accept",                 !testStatistic.tTest(sample1, sample2, 0.1));        assertTrue("two sample heteroscedastic t-test accept",                 !testStatistic.tTest(sampleStats1, sampleStats2, 0.1));             try {            testStatistic.tTest(sample1, sample2, .95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                 try {            testStatistic.tTest(sampleStats1, sampleStats2, .95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected         }                  try {            testStatistic.tTest(sample1, tooShortObs, .01);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            testStatistic.tTest(sampleStats1, tooShortStats, .01);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            testStatistic.tTest(sample1, tooShortObs);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {           // expected        }                  try {            testStatistic.tTest(sampleStats1, tooShortStats);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            testStatistic.t(sample1, tooShortObs);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                try {            testStatistic.t(sampleStats1, tooShortStats);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {           // expected        }    }    public void testTwoSampleTHomoscedastic() throws Exception {        double[] sample1 ={2, 4, 6, 8, 10, 97};        double[] sample2 = {4, 6, 8, 10, 16};        SummaryStatistics sampleStats1 = SummaryStatistics.newInstance();          for (int i = 0; i < sample1.length; i++) {            sampleStats1.addValue(sample1[i]);        }        SummaryStatistics sampleStats2 = SummaryStatistics.newInstance();            for (int i = 0; i < sample2.length; i++) {            sampleStats2.addValue(sample2[i]);        }                // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("two sample homoscedastic t stat", 0.73096310086,               testStatistic.homoscedasticT(sample1, sample2), 10E-11);        assertEquals("two sample homoscedastic p value", 0.4833963785,                 testStatistic.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);             assertTrue("two sample homoscedastic t-test reject",                 testStatistic.homoscedasticTTest(sample1, sample2, 0.49));        assertTrue("two sample homoscedastic t-test accept",                 !testStatistic.homoscedasticTTest(sample1, sample2, 0.48));    }        public void testSmallSamples() throws Exception {        double[] sample1 = {1d, 3d};        double[] sample2 = {4d, 5d};                        // Target values computed using R, version 1.8.1 (linux version)        assertEquals(-2.2360679775, testStatistic.t(sample1, sample2),                1E-10);        assertEquals(0.198727388935, testStatistic.tTest(sample1, sample2),                1E-10);    }        public void testPaired() throws Exception {        double[] sample1 = {1d, 3d, 5d, 7d};        double[] sample2 = {0d, 6d, 11d, 2d};        double[] sample3 = {5d, 7d, 8d, 10d};        double[] sample4 = {0d, 2d};                // Target values computed using R, version 1.8.1 (linux version)        assertEquals(-0.3133, testStatistic.pairedT(sample1, sample2), 1E-4);        assertEquals(0.774544295819, testStatistic.pairedTTest(sample1, sample2), 1E-10);        assertEquals(0.001208, testStatistic.pairedTTest(sample1, sample3), 1E-6);        assertFalse(testStatistic.pairedTTest(sample1, sample3, .001));        assertTrue(testStatistic.pairedTTest(sample1, sample3, .002));        }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import junit.framework.Test;import junit.framework.TestSuite;/** * Test cases for the ChiSquareTestFactory. * * @version $Revision$ $Date$ */public class ChiSquareFactoryTest extends ChiSquareTestTest {    public ChiSquareFactoryTest(String name) {        super(name);    }        public void setUp() {        testStatistic = TestUtils.getChiSquareTest();    }    public static Test suite() {        TestSuite suite = new TestSuite(ChiSquareFactoryTest.class);        suite.setName("ChiSquareTestFactory Tests");        return suite;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import junit.framework.Test;import junit.framework.TestSuite;/** * Test cases for the TTestTestFactory. * * @version $Revision$ $Date$ */public class TTestFactoryTest extends TTestTest {    public TTestFactoryTest(String name) {        super(name);    }        public void setUp() {        testStatistic = TestUtils.getTTest();    }    public static Test suite() {        TestSuite suite = new TestSuite(TTestFactoryTest.class);        suite.setName("TTestFactory Tests");        return suite;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the ChiSquareTestImpl class. * * @version $Revision$ $Date$ */public class ChiSquareTestTest extends TestCase {    protected ChiSquareTest testStatistic = new ChiSquareTestImpl();    public ChiSquareTestTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(ChiSquareTestTest.class);        suite.setName("TestStatistic Tests");        return suite;    }    public void testChiSquare() throws Exception {         // Target values computed using R version 1.8.1         // Some assembly required ;-)          //      Use sum((obs - exp)^2/exp) for the chi-square statistic and        //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value                long[] observed = {10, 9, 11};        double[] expected = {10, 10, 10};        assertEquals("chi-square statistic", 0.2,  testStatistic.chiSquare(expected, observed), 10E-12);        assertEquals("chi-square p-value", 0.904837418036, testStatistic.chiSquareTest(expected, observed), 1E-10);                long[] observed1 = { 500, 623, 72, 70, 31 };        double[] expected1 = { 485, 541, 82, 61, 37 };        assertEquals( "chi-square test statistic", 16.4131070362, testStatistic.chiSquare(expected1, observed1), 1E-10);        assertEquals("chi-square p-value", 0.002512096, testStatistic.chiSquareTest(expected1, observed1), 1E-9);        assertTrue("chi-square test reject", testStatistic.chiSquareTest(expected1, observed1, 0.003));        assertTrue("chi-square test accept", !testStatistic.chiSquareTest(expected1, observed1, 0.002));        try {            testStatistic.chiSquareTest(expected1, observed1, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  long[] tooShortObs = { 0 };        double[] tooShortEx = { 1 };        try {            testStatistic.chiSquare(tooShortEx, tooShortObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        // unmatched arrays        long[] unMatchedObs = { 0, 1, 2, 3 };        double[] unMatchedEx = { 1, 1, 2 };        try {            testStatistic.chiSquare(unMatchedEx, unMatchedObs);            fail("arrays have different lengths, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                // 0 expected count        expected[0] = 0;        try {            testStatistic.chiSquareTest(expected, observed, .01);            fail("bad expected count, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                 // negative observed count        expected[0] = 1;        observed[0] = -1;        try {            testStatistic.chiSquareTest(expected, observed, .01);            fail("bad expected count, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }             }    public void testChiSquareIndependence() throws Exception {                // Target values computed using R version 1.8.1                 long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};        assertEquals( "chi-square test statistic", 22.709027688, testStatistic.chiSquare(counts), 1E-9);        assertEquals("chi-square p-value", 0.000144751460134, testStatistic.chiSquareTest(counts), 1E-9);        assertTrue("chi-square test reject", testStatistic.chiSquareTest(counts, 0.0002));        assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts, 0.0001));                    long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };        assertEquals( "chi-square test statistic", 0.168965517241, testStatistic.chiSquare(counts2), 1E-9);        assertEquals("chi-square p-value",0.918987499852, testStatistic.chiSquareTest(counts2), 1E-9);        assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts2, 0.1));                 // ragged input array        long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};        try {            testStatistic.chiSquare(counts3);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                // insufficient data        long[][] counts4 = {{40, 22, 43}};        try {            testStatistic.chiSquare(counts4);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }         long[][] counts5 = {{40}, {40}, {30}, {10}};        try {            testStatistic.chiSquare(counts5);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                 // negative counts        long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };        try {            testStatistic.chiSquare(counts6);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                 // bad alpha        try {            testStatistic.chiSquareTest(counts, 0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }     }        public void testChiSquareLargeTestStatistic() throws Exception {        double[] exp = new double[] {            3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0,             232921.0, 437665.75        };        long[] obs = new long[] {            2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899        };        org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =            new org.apache.commons.math.stat.inference.ChiSquareTestImpl();         double cst = csti.chiSquareTest(exp, obs);         assertEquals("chi-square p-value", 0.0, cst, 1E-3);        assertEquals( "chi-square test statistic",                 3624883.342907764, testStatistic.chiSquare(exp, obs), 1E-9);    }        /** Contingency table containing zeros - PR # 32531 */    public void testChiSquareZeroCount() throws Exception {        // Target values computed using R version 1.8.1         long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};        assertEquals( "chi-square test statistic", 9.67444662263,                testStatistic.chiSquare(counts), 1E-9);        assertEquals("chi-square p-value", 0.0462835770603,                testStatistic.chiSquareTest(counts), 1E-9);           }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.SummaryStatistics;/** * Test cases for the TestUtils class. * * @version $Revision$ $Date$ */public class TestUtilsTest extends TestCase {    public TestUtilsTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(TestUtilsTest.class);        suite.setName("TestUtils Tests");        return suite;    }    public void testChiSquare() throws Exception {                // Target values computed using R version 1.8.1         // Some assembly required ;-)          //      Use sum((obs - exp)^2/exp) for the chi-square statistic and        //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value                long[] observed = {10, 9, 11};        double[] expected = {10, 10, 10};        assertEquals("chi-square statistic", 0.2,  TestUtils.chiSquare(expected, observed), 10E-12);        assertEquals("chi-square p-value", 0.904837418036, TestUtils.chiSquareTest(expected, observed), 1E-10);                long[] observed1 = { 500, 623, 72, 70, 31 };        double[] expected1 = { 485, 541, 82, 61, 37 };        assertEquals( "chi-square test statistic", 16.4131070362, TestUtils.chiSquare(expected1, observed1), 1E-10);        assertEquals("chi-square p-value", 0.002512096, TestUtils.chiSquareTest(expected1, observed1), 1E-9);        assertTrue("chi-square test reject", TestUtils.chiSquareTest(expected1, observed1, 0.003));        assertTrue("chi-square test accept", !TestUtils.chiSquareTest(expected1, observed1, 0.002));        try {            TestUtils.chiSquareTest(expected1, observed1, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  long[] tooShortObs = { 0 };        double[] tooShortEx = { 1 };        try {            TestUtils.chiSquare(tooShortEx, tooShortObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        // unmatched arrays        long[] unMatchedObs = { 0, 1, 2, 3 };        double[] unMatchedEx = { 1, 1, 2 };        try {            TestUtils.chiSquare(unMatchedEx, unMatchedObs);            fail("arrays have different lengths, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                // 0 expected count        expected[0] = 0;        try {            TestUtils.chiSquareTest(expected, observed, .01);            fail("bad expected count, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                 // negative observed count        expected[0] = 1;        observed[0] = -1;        try {            TestUtils.chiSquareTest(expected, observed, .01);            fail("bad expected count, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }             }    public void testChiSquareIndependence() throws Exception {                // Target values computed using R version 1.8.1                 long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};        assertEquals( "chi-square test statistic", 22.709027688, TestUtils.chiSquare(counts), 1E-9);        assertEquals("chi-square p-value", 0.000144751460134, TestUtils.chiSquareTest(counts), 1E-9);        assertTrue("chi-square test reject", TestUtils.chiSquareTest(counts, 0.0002));        assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts, 0.0001));                    long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };        assertEquals( "chi-square test statistic", 0.168965517241, TestUtils.chiSquare(counts2), 1E-9);        assertEquals("chi-square p-value",0.918987499852, TestUtils.chiSquareTest(counts2), 1E-9);        assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts2, 0.1));                 // ragged input array        long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};        try {            TestUtils.chiSquare(counts3);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                // insufficient data        long[][] counts4 = {{40, 22, 43}};        try {            TestUtils.chiSquare(counts4);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }         long[][] counts5 = {{40}, {40}, {30}, {10}};        try {            TestUtils.chiSquare(counts5);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                 // negative counts        long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };        try {            TestUtils.chiSquare(counts6);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                 // bad alpha        try {            TestUtils.chiSquareTest(counts, 0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }     }        public void testChiSquareLargeTestStatistic() throws Exception {        double[] exp = new double[] {                3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0,                 232921.0, 437665.75        };        long[] obs = new long[] {                2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899        };        org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =            new org.apache.commons.math.stat.inference.ChiSquareTestImpl();         double cst = csti.chiSquareTest(exp, obs);         assertEquals("chi-square p-value", 0.0, cst, 1E-3);        assertEquals( "chi-square test statistic",                 3624883.342907764, TestUtils.chiSquare(exp, obs), 1E-9);    }        /** Contingency table containing zeros - PR # 32531 */    public void testChiSquareZeroCount() throws Exception {        // Target values computed using R version 1.8.1         long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};        assertEquals( "chi-square test statistic", 9.67444662263,                TestUtils.chiSquare(counts), 1E-9);        assertEquals("chi-square p-value", 0.0462835770603,                TestUtils.chiSquareTest(counts), 1E-9);           }        private double[] tooShortObs = { 1.0 };    private double[] nullObserved = null;    private double[] emptyObs = {};    private SummaryStatistics emptyStats = SummaryStatistics.newInstance();      private SummaryStatistics nullStats = null;       SummaryStatistics tooShortStats = null;      public void testOneSampleT() throws Exception {        double[] observed =            {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0,  88.0, 98.0, 94.0, 101.0, 92.0, 95.0 };        double mu = 100.0;        SummaryStatistics sampleStats = null;        sampleStats = SummaryStatistics.newInstance();        for (int i = 0; i < observed.length; i++) {            sampleStats.addValue(observed[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("t statistic",  -2.81976445346,                TestUtils.t(mu, observed), 10E-10);        assertEquals("t statistic",  -2.81976445346,                TestUtils.t(mu, sampleStats), 10E-10);        assertEquals("p value", 0.0136390585873,                TestUtils.tTest(mu, observed), 10E-10);        assertEquals("p value", 0.0136390585873,                TestUtils.tTest(mu, sampleStats), 10E-10);        try {            TestUtils.t(mu, nullObserved);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(mu, nullStats);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(mu, emptyObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                try {            TestUtils.t(mu, emptyStats);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(mu, tooShortObs);            fail("insufficient data to compute t statistic, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // exptected        }        try {            TestUtils.tTest(mu, tooShortObs);            fail("insufficient data to perform t test, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }          try {            TestUtils.t(mu, tooShortStats);            fail("insufficient data to compute t statistic, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // exptected        }        try {            TestUtils.tTest(mu, tooShortStats);            fail("insufficient data to perform t test, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // exptected        }      }        public void testOneSampleTTest() throws Exception {        double[] oneSidedP =            {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d };        SummaryStatistics oneSidedPStats = SummaryStatistics.newInstance();            for (int i = 0; i < oneSidedP.length; i++) {            oneSidedPStats.addValue(oneSidedP[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("one sample t stat", 3.86485535541,                 TestUtils.t(0d, oneSidedP), 10E-10);        assertEquals("one sample t stat", 3.86485535541,                 TestUtils.t(0d, oneSidedPStats),1E-10);        assertEquals("one sample p value", 0.000521637019637,                TestUtils.tTest(0d, oneSidedP) / 2d, 10E-10);        assertEquals("one sample p value", 0.000521637019637,                TestUtils.tTest(0d, oneSidedPStats) / 2d, 10E-5);        assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedP, 0.01));        assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedPStats, 0.01));        assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedP, 0.0001));        assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedPStats, 0.0001));                try {            TestUtils.tTest(0d, oneSidedP, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // exptected        }                  try {            TestUtils.tTest(0d, oneSidedPStats, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }              }        public void testTwoSampleTHeterscedastic() throws Exception {        double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };        double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };        SummaryStatistics sampleStats1 = SummaryStatistics.newInstance();          for (int i = 0; i < sample1.length; i++) {            sampleStats1.addValue(sample1[i]);        }        SummaryStatistics sampleStats2 = SummaryStatistics.newInstance();            for (int i = 0; i < sample2.length; i++) {            sampleStats2.addValue(sample2[i]);        }                // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("two sample heteroscedastic t stat", 1.60371728768,                 TestUtils.t(sample1, sample2), 1E-10);        assertEquals("two sample heteroscedastic t stat", 1.60371728768,                 TestUtils.t(sampleStats1, sampleStats2), 1E-10);        assertEquals("two sample heteroscedastic p value", 0.128839369622,                 TestUtils.tTest(sample1, sample2), 1E-10);        assertEquals("two sample heteroscedastic p value", 0.128839369622,                 TestUtils.tTest(sampleStats1, sampleStats2), 1E-10);             assertTrue("two sample heteroscedastic t-test reject",                 TestUtils.tTest(sample1, sample2, 0.2));        assertTrue("two sample heteroscedastic t-test reject",                 TestUtils.tTest(sampleStats1, sampleStats2, 0.2));        assertTrue("two sample heteroscedastic t-test accept",                 !TestUtils.tTest(sample1, sample2, 0.1));        assertTrue("two sample heteroscedastic t-test accept",                 !TestUtils.tTest(sampleStats1, sampleStats2, 0.1));                try {            TestUtils.tTest(sample1, sample2, .95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                 try {            TestUtils.tTest(sampleStats1, sampleStats2, .95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected         }                  try {            TestUtils.tTest(sample1, tooShortObs, .01);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            TestUtils.tTest(sampleStats1, tooShortStats, .01);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            TestUtils.tTest(sample1, tooShortObs);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            TestUtils.tTest(sampleStats1, tooShortStats);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            TestUtils.t(sample1, tooShortObs);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                try {            TestUtils.t(sampleStats1, tooShortStats);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testTwoSampleTHomoscedastic() throws Exception {        double[] sample1 ={2, 4, 6, 8, 10, 97};        double[] sample2 = {4, 6, 8, 10, 16};        SummaryStatistics sampleStats1 = SummaryStatistics.newInstance();          for (int i = 0; i < sample1.length; i++) {            sampleStats1.addValue(sample1[i]);        }        SummaryStatistics sampleStats2 = SummaryStatistics.newInstance();            for (int i = 0; i < sample2.length; i++) {            sampleStats2.addValue(sample2[i]);        }                // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("two sample homoscedastic t stat", 0.73096310086,                 TestUtils.homoscedasticT(sample1, sample2), 10E-11);        assertEquals("two sample homoscedastic p value", 0.4833963785,                 TestUtils.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);             assertTrue("two sample homoscedastic t-test reject",                 TestUtils.homoscedasticTTest(sample1, sample2, 0.49));        assertTrue("two sample homoscedastic t-test accept",                 !TestUtils.homoscedasticTTest(sample1, sample2, 0.48));    }        public void testSmallSamples() throws Exception {        double[] sample1 = {1d, 3d};        double[] sample2 = {4d, 5d};                        // Target values computed using R, version 1.8.1 (linux version)        assertEquals(-2.2360679775, TestUtils.t(sample1, sample2),                1E-10);        assertEquals(0.198727388935, TestUtils.tTest(sample1, sample2),                1E-10);    }        public void testPaired() throws Exception {        double[] sample1 = {1d, 3d, 5d, 7d};        double[] sample2 = {0d, 6d, 11d, 2d};        double[] sample3 = {5d, 7d, 8d, 10d};        double[] sample4 = {0d, 2d};                // Target values computed using R, version 1.8.1 (linux version)        assertEquals(-0.3133, TestUtils.pairedT(sample1, sample2), 1E-4);        assertEquals(0.774544295819, TestUtils.pairedTTest(sample1, sample2), 1E-10);        assertEquals(0.001208, TestUtils.pairedTTest(sample1, sample3), 1E-6);        assertFalse(TestUtils.pairedTTest(sample1, sample3, .001));        assertTrue(TestUtils.pairedTTest(sample1, sample3, .002));        }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.regression;import java.util.Random;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the TestStatistic class. * * @version $Revision$ $Date$ */public final class SimpleRegressionTest extends TestCase {    /*      * NIST "Norris" refernce data set from      * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat     * Strangely, order is {y,x}     */    private double[][] data = { { 0.1, 0.2 }, {338.8, 337.4 }, {118.1, 118.2 },             {888.0, 884.6 }, {9.2, 10.1 }, {228.1, 226.5 }, {668.5, 666.3 }, {998.5, 996.3 },             {449.1, 448.6 }, {778.9, 777.0 }, {559.2, 558.2 }, {0.3, 0.4 }, {0.1, 0.6 }, {778.1, 775.5 },             {668.8, 666.9 }, {339.3, 338.0 }, {448.9, 447.5 }, {10.8, 11.6 }, {557.7, 556.0 },             {228.3, 228.1 }, {998.0, 995.8 }, {888.8, 887.6 }, {119.6, 120.2 }, {0.3, 0.3 },             {0.6, 0.3 }, {557.6, 556.8 }, {339.3, 339.1 }, {888.0, 887.2 }, {998.5, 999.0 },             {778.9, 779.0 }, {10.2, 11.1 }, {117.6, 118.3 }, {228.9, 229.2 }, {668.4, 669.1 },             {449.2, 448.9 }, {0.2, 0.5 }    };    /*      * Correlation example from      * http://www.xycoon.com/correlation.htm     */    private double[][] corrData = { { 101.0, 99.2 }, {100.1, 99.0 }, {100.0, 100.0 },             {90.6, 111.6 }, {86.5, 122.2 }, {89.7, 117.6 }, {90.6, 121.1 }, {82.8, 136.0 },             {70.1, 154.2 }, {65.4, 153.6 }, {61.3, 158.5 }, {62.5, 140.6 }, {63.6, 136.2 },             {52.6, 168.0 }, {59.7, 154.3 }, {59.5, 149.0 }, {61.3, 165.5 }    };    /*     * From Moore and Mcabe, "Introduction to the Practice of Statistics"     * Example 10.3      */    private double[][] infData = { { 15.6, 5.2 }, {26.8, 6.1 }, {37.8, 8.7 }, {36.4, 8.5 },            {35.5, 8.8 }, {18.6, 4.9 }, {15.3, 4.5 }, {7.9, 2.5 }, {0.0, 1.1 }    };        /*     * Data with bad linear fit     */    private double[][] infData2 = { { 1, 1 }, {2, 0 }, {3, 5 }, {4, 2 },            {5, -1 }, {6, 12 }    };    public SimpleRegressionTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(SimpleRegressionTest.class);        suite.setName("BivariateRegression Tests");        return suite;    }    public void testNorris() {        SimpleRegression regression = new SimpleRegression();        for (int i = 0; i < data.length; i++) {            regression.addData(data[i][1], data[i][0]);        }        // Tests against certified values from          // http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat        assertEquals("slope", 1.00211681802045, regression.getSlope(), 10E-12);        assertEquals("slope std err", 0.429796848199937E-03,                regression.getSlopeStdErr(),10E-12);        assertEquals("number of observations", 36, regression.getN());        assertEquals( "intercept", -0.262323073774029,            regression.getIntercept(),10E-12);        assertEquals("std err intercept", 0.232818234301152,            regression.getInterceptStdErr(),10E-12);        assertEquals("r-square", 0.999993745883712,            regression.getRSquare(), 10E-12);        assertEquals("SSR", 4255954.13232369,            regression.getRegressionSumSquares(), 10E-9);        assertEquals("MSE", 0.782864662630069,            regression.getMeanSquareError(), 10E-10);        assertEquals("SSE", 26.6173985294224,            regression.getSumSquaredErrors(),10E-9);        // ------------  End certified data tests                  assertEquals( "predict(0)",  -0.262323073774029,            regression.predict(0), 10E-12);        assertEquals("predict(1)", 1.00211681802045 - 0.262323073774029,            regression.predict(1), 10E-12);    }    public void testCorr() {        SimpleRegression regression = new SimpleRegression();        regression.addData(corrData);        assertEquals("number of observations", 17, regression.getN());        assertEquals("r-square", .896123, regression.getRSquare(), 10E-6);        assertEquals("r", -0.94663767742, regression.getR(), 1E-10);    }    public void testNaNs() {        SimpleRegression regression = new SimpleRegression();        assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept()));        assertTrue("slope not NaN", Double.isNaN(regression.getSlope()));        assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));        assertTrue("e not NaN", Double.isNaN(regression.getR()));        assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare()));        assertTrue( "RSS not NaN", Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE not NaN",Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("SSTO not NaN", Double.isNaN(regression.getTotalSumSquares()));        assertTrue("predict not NaN", Double.isNaN(regression.predict(0)));        regression.addData(1, 2);        regression.addData(1, 3);        // No x variation, so these should still blow...        assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept()));        assertTrue("slope not NaN", Double.isNaN(regression.getSlope()));        assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));        assertTrue("e not NaN", Double.isNaN(regression.getR()));        assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare()));        assertTrue("RSS not NaN", Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE not NaN", Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("predict not NaN", Double.isNaN(regression.predict(0)));        // but SSTO should be OK        assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares()));        regression = new SimpleRegression();        regression.addData(1, 2);        regression.addData(3, 3);        // All should be OK except MSE, s(b0), s(b1) which need one more df         assertTrue("interceptNaN", !Double.isNaN(regression.getIntercept()));        assertTrue("slope NaN", !Double.isNaN(regression.getSlope()));        assertTrue ("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));        assertTrue("r NaN", !Double.isNaN(regression.getR()));        assertTrue("r-square NaN", !Double.isNaN(regression.getRSquare()));        assertTrue("RSS NaN", !Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE NaN", !Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares()));        assertTrue("predict NaN", !Double.isNaN(regression.predict(0)));        regression.addData(1, 4);        // MSE, MSE, s(b0), s(b1) should all be OK now        assertTrue("MSE NaN", !Double.isNaN(regression.getMeanSquareError()));        assertTrue("slope std err NaN", !Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err NaN", !Double.isNaN(regression.getInterceptStdErr()));    }    public void testClear() {        SimpleRegression regression = new SimpleRegression();        regression.addData(corrData);        assertEquals("number of observations", 17, regression.getN());        regression.clear();        assertEquals("number of observations", 0, regression.getN());        regression.addData(corrData);        assertEquals("r-square", .896123, regression.getRSquare(), 10E-6);        regression.addData(data);        assertEquals("number of observations", 53, regression.getN());    }    public void testInference() throws Exception {        //----------  verified against R, version 1.8.1 -----        // infData        SimpleRegression regression = new SimpleRegression();        regression.addData(infData);        assertEquals("slope std err", 0.011448491,                regression.getSlopeStdErr(), 1E-10);        assertEquals("std err intercept", 0.286036932,                regression.getInterceptStdErr(),1E-8);        assertEquals("significance", 4.596e-07,                regression.getSignificance(),1E-8);            assertEquals("slope conf interval half-width", 0.0270713794287,                 regression.getSlopeConfidenceInterval(),1E-8);        // infData2        regression = new SimpleRegression();        regression.addData(infData2);        assertEquals("slope std err", 1.07260253,                regression.getSlopeStdErr(), 1E-8);        assertEquals("std err intercept",4.17718672,                regression.getInterceptStdErr(),1E-8);        assertEquals("significance", 0.261829133982,                regression.getSignificance(),1E-11);            assertEquals("slope conf interval half-width", 2.97802204827,                 regression.getSlopeConfidenceInterval(),1E-8);        //------------- End R-verified tests -------------------------------                //FIXME: get a real example to test against with alpha = .01        assertTrue("tighter means wider",                regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01));             try {            double x = regression.getSlopeConfidenceInterval(1);            fail("expecting IllegalArgumentException for alpha = 1");        } catch (IllegalArgumentException ex) {            ;        }      }    public void testPerfect() throws Exception {        SimpleRegression regression = new SimpleRegression();        int n = 100;        for (int i = 0; i < n; i++) {            regression.addData(((double) i) / (n - 1), i);        }        assertEquals(0.0, regression.getSignificance(), 1.0e-5);        assertTrue(regression.getSlope() > 0.0);        assertTrue(regression.getSumSquaredErrors() >= 0.0);    }    public void testPerfectNegative() throws Exception {        SimpleRegression regression = new SimpleRegression();        int n = 100;        for (int i = 0; i < n; i++) {            regression.addData(- ((double) i) / (n - 1), i);        }           assertEquals(0.0, regression.getSignificance(), 1.0e-5);        assertTrue(regression.getSlope() < 0.0);       }    public void testRandom() throws Exception {        SimpleRegression regression = new SimpleRegression();        Random random = new Random(1);        int n = 100;        for (int i = 0; i < n; i++) {            regression.addData(((double) i) / (n - 1), random.nextDouble());        }        assertTrue( 0.0 < regression.getSignificance()                    && regression.getSignificance() < 1.0);           }            // Jira MATH-85 = Bugzilla 39432    public void testSSENonNegative() {        double[] y = { 8915.102, 8919.302, 8923.502 };        double[] x = { 1.107178495E2, 1.107264895E2, 1.107351295E2 };        SimpleRegression reg = new SimpleRegression();        for (int i = 0; i < x.length; i++) {            reg.addData(x[i], y[i]);        }        assertTrue(reg.getSumSquaredErrors() >= 0.0);    } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.data;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.lang.reflect.Method;import java.net.URL;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;import org.apache.commons.math.stat.descriptive.SummaryStatistics;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public abstract class CertifiedDataAbstractTest extends TestCase {        private DescriptiveStatistics descriptives;        private SummaryStatistics summaries;        private Map certifiedValues;        protected void setUp() throws Exception {        descriptives = DescriptiveStatistics.newInstance();        summaries = SummaryStatistics.newInstance();        certifiedValues = new HashMap();                loadData();    }    private void loadData() throws IOException {        BufferedReader in = null;        try {            URL resourceURL = getClass().getClassLoader().getResource(getResourceName());            in = new BufferedReader(new InputStreamReader(resourceURL.openStream()));                        String line = in.readLine();            while (line != null) {                                /* this call to StringUtils did little for the                  * following conditional structure                  */                line = line.trim();                // not empty line or comment                if (!("".equals(line) || line.startsWith("#"))) {                    int n = line.indexOf('=');                    if (n == -1) {                        // data value                        double value = Double.parseDouble(line);                        descriptives.addValue(value);                        summaries.addValue(value);                    } else {                        // certified value                        String name = line.substring(0, n).trim();                        String valueString = line.substring(n + 1).trim();                        Double value = new Double(valueString);                        certifiedValues.put(name, value);                    }                }                line = in.readLine();            }        } finally {            if (in != null) {                in.close();            }        }    }    /**     * @return     */    protected abstract String getResourceName();    protected double getMaximumAbsoluteError() {        return 1.0e-5;    }        protected void tearDown() throws Exception {        descriptives.clear();        descriptives = null;                summaries.clear();        summaries = null;                certifiedValues.clear();        certifiedValues = null;    }        public void testCertifiedValues() throws Exception {        Iterator iter = certifiedValues.keySet().iterator();        while (iter.hasNext()) {            String name = iter.next().toString();            Double expectedValue = (Double)certifiedValues.get(name);            try {                Double summariesValue = (Double)this.getProperty(summaries, name);                TestUtils.assertEquals("summary value for " + name + " is incorrect.",                        summariesValue.doubleValue(), expectedValue.doubleValue(), getMaximumAbsoluteError());            } catch (Exception ex) {            }                        try {                Double descriptivesValue = (Double)this.getProperty(descriptives, name);                TestUtils.assertEquals("descriptive value for " + name + " is incorrect.",                        descriptivesValue.doubleValue(), expectedValue.doubleValue(), getMaximumAbsoluteError());            } catch (Exception ex) {            }        }    }            protected Object getProperty(Object bean, String name) throws Exception{        // Get the value of prop        String prop = "get" + name.substring(0,1).toUpperCase() + name.substring(1);         Method meth = bean.getClass().getMethod(prop, new Class[0]);        return meth.invoke(bean, new Object[0]);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.data;/** * @version $Revision$ $Date$ */public class LotteryTest extends CertifiedDataAbstractTest {    protected String getResourceName() {        return "org/apache/commons/math/stat/data/Lottery.txt";    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.data;/** * @version $Revision$ $Date$ */public class LewTest extends CertifiedDataAbstractTest {    protected String getResourceName() {        return "org/apache/commons/math/stat/data/Lew.txt";    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import java.io.BufferedReader;import java.io.InputStreamReader;import org.apache.commons.math.stat.descriptive.SummaryStatistics;import org.apache.commons.math.stat.descriptive.SummaryStatisticsImpl;import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;/** * Certified data test cases. * @version $Revision$ $Date$ */public class CertifiedDataTest extends TestCase  {    protected double mean = Double.NaN;    protected double std = Double.NaN;    /**     * Certified Data Test Constructor     * @param name     */    public CertifiedDataTest(String name) {        super(name);    }    /* (non-Javadoc)     * @see junit.framework.TestCase#setUp()     */    public void setUp() {    }    /**     * @return The test suite     */    public static Test suite() {        TestSuite suite = new TestSuite(CertifiedDataTest.class);        suite.setName("Certified Tests");        return suite;    }    /**     * Test StorelessDescriptiveStatistics    */    public void testUnivariateImpl() throws Exception {        SummaryStatistics u = SummaryStatistics.newInstance(SummaryStatisticsImpl.class);        loadStats("data/PiDigits.txt", u);        assertEquals("PiDigits: std", std, u.getStandardDeviation(), .0000000000001);        assertEquals("PiDigits: mean", mean, u.getMean(), .0000000000001);          loadStats("data/Mavro.txt", u);        assertEquals("Mavro: std", std, u.getStandardDeviation(), .00000000000001);        assertEquals("Mavro: mean", mean, u.getMean(), .00000000000001);                //loadStats("data/Michelso.txt");        //assertEquals("Michelso: std", std, u.getStandardDeviation(), .00000000000001);        //assertEquals("Michelso: mean", mean, u.getMean(), .00000000000001);                                                   loadStats("data/NumAcc1.txt", u);        assertEquals("NumAcc1: std", std, u.getStandardDeviation(), .00000000000001);        assertEquals("NumAcc1: mean", mean, u.getMean(), .00000000000001);                //loadStats("data/NumAcc2.txt");        //assertEquals("NumAcc2: std", std, u.getStandardDeviation(), .000000001);        //assertEquals("NumAcc2: mean", mean, u.getMean(), .00000000000001);    }    /**     * Test StorelessDescriptiveStatistics     */    public void testStoredUnivariateImpl() throws Exception {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();                loadStats("data/PiDigits.txt", u);        assertEquals("PiDigits: std", std, u.getStandardDeviation(), .0000000000001);        assertEquals("PiDigits: mean", mean, u.getMean(), .0000000000001);                loadStats("data/Mavro.txt", u);        assertEquals("Mavro: std", std, u.getStandardDeviation(), .00000000000001);        assertEquals("Mavro: mean", mean, u.getMean(), .00000000000001);                        //loadStats("data/Michelso.txt");        //assertEquals("Michelso: std", std, u.getStandardDeviation(), .00000000000001);        //assertEquals("Michelso: mean", mean, u.getMean(), .00000000000001);           loadStats("data/NumAcc1.txt", u);        assertEquals("NumAcc1: std", std, u.getStandardDeviation(), .00000000000001);        assertEquals("NumAcc1: mean", mean, u.getMean(), .00000000000001);                //loadStats("data/NumAcc2.txt");        //assertEquals("NumAcc2: std", std, u.getStandardDeviation(), .000000001);        //assertEquals("NumAcc2: mean", mean, u.getMean(), .00000000000001);    }    /**     * loads a DescriptiveStatistics off of a test file     * @param file     * @param statistical summary     */    private void loadStats(String resource, Object u) throws Exception {                DescriptiveStatistics d = null;        SummaryStatistics s = null;        if (u instanceof DescriptiveStatistics) {            d = (DescriptiveStatistics) u;        } else {            s = (SummaryStatistics) u;        }        u.getClass().getDeclaredMethod(                "clear", new Class[]{}).invoke(u, new Object[]{});        mean = Double.NaN;        std = Double.NaN;                BufferedReader in =            new BufferedReader(                    new InputStreamReader(                            getClass().getResourceAsStream(resource)));                String line = null;                for (int j = 0; j < 60; j++) {            line = in.readLine();            if (j == 40) {                mean =                    Double.parseDouble(                            line.substring(line.lastIndexOf(":") + 1).trim());            }            if (j == 41) {                std =                    Double.parseDouble(                            line.substring(line.lastIndexOf(":") + 1).trim());            }        }                line = in.readLine();                while (line != null) {            if (d != null) {                d.addValue(Double.parseDouble(line.trim()));            }  else {                s.addValue(Double.parseDouble(line.trim()));            }            line = in.readLine();        }                in.close();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat;import java.io.BufferedReader;import java.io.IOException;import java.io.StringReader;import java.util.Iterator;import org.apache.commons.math.TestUtils;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link Frequency} class. * * @version $Revision$ $Date$ */public final class FrequencyTest extends TestCase {    private long oneL = 1;    private long twoL = 2;    private long threeL = 3;    private int oneI = 1;    private int twoI = 2;    private int threeI=3;    private String oneS = "1";    private String twoS = "2";    private double tolerance = 10E-15;    private Frequency f = null;        public FrequencyTest(String name) {        super(name);    }        public void setUp() {          f = new Frequency();    }        public static Test suite() {        TestSuite suite = new TestSuite(FrequencyTest.class);        suite.setName("Frequency Tests");        return suite;    }        /** test freq counts */    public void testCounts() {        assertEquals("total count",0,f.getSumFreq());        f.addValue(oneL);        f.addValue(twoL);        f.addValue(1);        f.addValue(oneI);        assertEquals("one frequency count",3,f.getCount(1));        assertEquals("two frequency count",1,f.getCount(2));        assertEquals("three frequency count",0,f.getCount(3));        assertEquals("total count",4,f.getSumFreq());        assertEquals("zero cumulative frequency", 0, f.getCumFreq(0));        assertEquals("one cumulative frequency", 3,  f.getCumFreq(1));        assertEquals("two cumulative frequency", 4,  f.getCumFreq(2));        assertEquals("Integer argument cum freq",4, f.getCumFreq(new Integer(2)));        assertEquals("five cumulative frequency", 4,  f.getCumFreq(5));        assertEquals("foo cumulative frequency", 0,  f.getCumFreq("foo"));                f.clear();        assertEquals("total count",0,f.getSumFreq());                // userguide examples -------------------------------------------------------------------        f.addValue("one");        f.addValue("One");        f.addValue("oNe");        f.addValue("Z");        assertEquals("one cumulative frequency", 1 ,  f.getCount("one"));        assertEquals("Z cumulative pct", 0.5,  f.getCumPct("Z"), tolerance);        assertEquals("z cumulative pct", 1.0,  f.getCumPct("z"), tolerance);        assertEquals("Ot cumulative pct", 0.25,  f.getCumPct("Ot"), tolerance);        f.clear();                f = null;        Frequency f = new Frequency();        f.addValue(1);        f.addValue(new Integer(1));        f.addValue(new Long(1));        f.addValue(2);        f.addValue(new Integer(-1));        assertEquals("1 count", 3, f.getCount(1));        assertEquals("1 count", 3, f.getCount(new Integer(1)));        assertEquals("0 cum pct", 0.2, f.getCumPct(0), tolerance);        assertEquals("1 pct", 0.6, f.getPct(new Integer(1)), tolerance);        assertEquals("-2 cum pct", 0, f.getCumPct(-2), tolerance);        assertEquals("10 cum pct", 1, f.getCumPct(10), tolerance);                   f = null;        f = new Frequency(String.CASE_INSENSITIVE_ORDER);        f.addValue("one");        f.addValue("One");        f.addValue("oNe");        f.addValue("Z");        assertEquals("one count", 3 ,  f.getCount("one"));        assertEquals("Z cumulative pct -- case insensitive", 1 ,  f.getCumPct("Z"), tolerance);        assertEquals("z cumulative pct -- case insensitive", 1 ,  f.getCumPct("z"), tolerance);        f = null;        f = new Frequency();        assertEquals(0L, f.getCount('a'));        assertEquals(0L, f.getCumFreq('b'));        TestUtils.assertEquals(Double.NaN, f.getPct('a'), 0.0);        TestUtils.assertEquals(Double.NaN, f.getCumPct('b'), 0.0);        f.addValue('a');        f.addValue('b');        f.addValue('c');        f.addValue('d');        assertEquals(1L, f.getCount('a'));        assertEquals(2L, f.getCumFreq('b'));        assertEquals(0.25, f.getPct('a'), 0.0);        assertEquals(0.5, f.getCumPct('b'), 0.0);        assertEquals(1.0, f.getCumPct('e'), 0.0);    }             /** test pcts */    public void testPcts() {        f.addValue(oneL);        f.addValue(twoL);        f.addValue(oneI);        f.addValue(twoI);        f.addValue(threeL);        f.addValue(threeL);        f.addValue(3);        f.addValue(threeI);        assertEquals("one pct",0.25,f.getPct(1),tolerance);        assertEquals("two pct",0.25,f.getPct(new Long(2)),tolerance);        assertEquals("three pct",0.5,f.getPct(threeL),tolerance);        assertEquals("five pct",0,f.getPct(5),tolerance);        assertEquals("foo pct",0,f.getPct("foo"),tolerance);        assertEquals("one cum pct",0.25,f.getCumPct(1),tolerance);        assertEquals("two cum pct",0.50,f.getCumPct(new Long(2)),tolerance);        assertEquals("Integer argument",0.50,f.getCumPct(new Integer(2)),tolerance);        assertEquals("three cum pct",1.0,f.getCumPct(threeL),tolerance);        assertEquals("five cum pct",1.0,f.getCumPct(5),tolerance);        assertEquals("zero cum pct",0.0,f.getCumPct(0),tolerance);        assertEquals("foo cum pct",0,f.getCumPct("foo"),tolerance);    }        /** test adding incomparable values */    public void testAdd() {        char aChar = 'a';        char bChar = 'b';        String aString = "a";        f.addValue(aChar);        f.addValue(bChar);        try {            f.addValue(aString);                fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        assertEquals("a pct",0.5,f.getPct(aChar),tolerance);        assertEquals("b cum pct",1.0,f.getCumPct(bChar),tolerance);        assertEquals("a string pct",0.0,f.getPct(aString),tolerance);        assertEquals("a string cum pct",0.0,f.getCumPct(aString),tolerance);    }        /** test empty table */    public void testEmptyTable() {        assertEquals("freq sum, empty table", 0, f.getSumFreq());        assertEquals("count, empty table", 0, f.getCount(0));        assertEquals("count, empty table",0, f.getCount(new Integer(0)));        assertEquals("cum freq, empty table", 0, f.getCumFreq(0));        assertEquals("cum freq, empty table", 0, f.getCumFreq("x"));        assertTrue("pct, empty table", Double.isNaN(f.getPct(0)));        assertTrue("pct, empty table", Double.isNaN(f.getPct(new Integer(0))));        assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(0)));        assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(new Integer(0))));       }        /**     * Tests toString()      */    public void testToString(){        f.addValue(oneL);        f.addValue(twoL);        f.addValue(oneI);        f.addValue(twoI);                String s = f.toString();        //System.out.println(s);        assertNotNull(s);        BufferedReader reader = new BufferedReader(new StringReader(s));        try {            String line = reader.readLine(); // header line            assertNotNull(line);                        line = reader.readLine(); // one's or two's line            assertNotNull(line);                                    line = reader.readLine(); // one's or two's line            assertNotNull(line);            line = reader.readLine(); // no more elements            assertNull(line);        } catch(IOException ex){            fail(ex.getMessage());        }            }    public void testIntegerValues() {        Object obj1 = null;        obj1 = new Integer(1);        Integer int1 = new Integer(1);        f.addValue(obj1);        f.addValue(int1);        f.addValue(2);        f.addValue(new Long(2));        assertEquals("Integer 1 count", 2, f.getCount(1));        assertEquals("Integer 1 count", 2, f.getCount(new Integer(1)));        assertEquals("Integer 1 count", 2, f.getCount(new Long(1)));        assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(1), tolerance);        assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(new Long(1)), tolerance);        assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(new Integer(1)), tolerance);        Iterator it = f.valuesIterator();        while (it.hasNext()) {            assertTrue(it.next() instanceof Long);        }         }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;/** * Test cases for the {@link StatUtils} class. * @version $Revision$ $Date$ */public final class StatUtilsTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double skewness = 0;    private double kurtosis = 0.5;    private double tolerance = 10E-15;    private double nan = Double.NaN;    public StatUtilsTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(StatUtilsTest.class);        suite.setName("StatUtil Tests");        return suite;    }    /** test stats */    public void testStats() {        double[] values = new double[] { one, two, two, three };        assertEquals("sum", sum, StatUtils.sum(values), tolerance);        assertEquals("sumsq", sumSq, StatUtils.sumSq(values), tolerance);        assertEquals("var", var, StatUtils.variance(values), tolerance);        assertEquals("var with mean", var, StatUtils.variance(values, mean), tolerance);        assertEquals("mean", mean, StatUtils.mean(values), tolerance);        assertEquals("min", min, StatUtils.min(values), tolerance);        assertEquals("max", max, StatUtils.max(values), tolerance);    }    public void testN0andN1Conditions() throws Exception {        double[] values = new double[0];        assertTrue(            "Mean of n = 0 set should be NaN",            Double.isNaN(StatUtils.mean(values)));        assertTrue(            "Variance of n = 0 set should be NaN",            Double.isNaN(StatUtils.variance(values)));        values = new double[] { one };        assertTrue(            "Mean of n = 1 set should be value of single item n1",            StatUtils.mean(values) == one);        assertTrue(            "Variance of n = 1 set should be zero",            StatUtils.variance(values) == 0);    }    public void testArrayIndexConditions() throws Exception {        double[] values = { 1.0, 2.0, 3.0, 4.0 };        assertEquals(            "Sum not expected",            5.0,            StatUtils.sum(values, 1, 2),            Double.MIN_VALUE);        assertEquals(            "Sum not expected",            3.0,            StatUtils.sum(values, 0, 2),            Double.MIN_VALUE);        assertEquals(            "Sum not expected",            7.0,            StatUtils.sum(values, 2, 2),            Double.MIN_VALUE);        try {            StatUtils.sum(values, 2, 3);            assertTrue("Didn't throw exception", false);        } catch (Exception e) {            assertTrue(true);        }        try {            StatUtils.sum(values, -1, 2);            assertTrue("Didn't throw exception", false);        } catch (Exception e) {            assertTrue(true);        }    }        public void testSumSq() {        double[] x = null;                // test null        try {            StatUtils.sumSq(x);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                try {            StatUtils.sumSq(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x), tolerance);        TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(4, StatUtils.sumSq(x), tolerance);        TestUtils.assertEquals(4, StatUtils.sumSq(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(18, StatUtils.sumSq(x), tolerance);        TestUtils.assertEquals(8, StatUtils.sumSq(x, 1, 2), tolerance);    }        public void testProduct() {        double[] x = null;                // test null        try {            StatUtils.product(x);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                try {            StatUtils.product(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.product(x), tolerance);        TestUtils.assertEquals(Double.NaN, StatUtils.product(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.product(x), tolerance);        TestUtils.assertEquals(two, StatUtils.product(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(12, StatUtils.product(x), tolerance);        TestUtils.assertEquals(4, StatUtils.product(x, 1, 2), tolerance);    }        public void testSumLog() {        double[] x = null;                // test null        try {            StatUtils.sumLog(x);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                try {            StatUtils.sumLog(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x), tolerance);        TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x), tolerance);        TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(Math.log(one) + 2.0 * Math.log(two) + Math.log(three), StatUtils.sumLog(x), tolerance);        TestUtils.assertEquals(2.0 * Math.log(two), StatUtils.sumLog(x, 1, 2), tolerance);    }        public void testMean() {        double[] x = null;                try {            StatUtils.mean(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.mean(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.mean(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(2.5, StatUtils.mean(x, 2, 2), tolerance);    }        public void testVariance() {        double[] x = null;                try {            StatUtils.variance(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.variance(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(0.0, StatUtils.variance(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(0.5, StatUtils.variance(x, 2, 2), tolerance);                // test precomputed mean        x = new double[] {one, two, two, three};        TestUtils.assertEquals(0.5, StatUtils.variance(x,2.5, 2, 2), tolerance);    }        public void testMax() {        double[] x = null;                try {            StatUtils.max(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.max(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.max(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(three, StatUtils.max(x, 1, 3), tolerance);        // test first nan is ignored        x = new double[] {nan, two, three};        TestUtils.assertEquals(three, StatUtils.max(x), tolerance);        // test middle nan is ignored        x = new double[] {one, nan, three};        TestUtils.assertEquals(three, StatUtils.max(x), tolerance);                // test last nan is ignored        x = new double[] {one, two, nan};        TestUtils.assertEquals(two, StatUtils.max(x), tolerance);        // test all nan returns nan        x = new double[] {nan, nan, nan};        TestUtils.assertEquals(nan, StatUtils.max(x), tolerance);    }        public void testMin() {        double[] x = null;                try {            StatUtils.min(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.min(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.min(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(two, StatUtils.min(x, 1, 3), tolerance);        // test first nan is ignored        x = new double[] {nan, two, three};        TestUtils.assertEquals(two, StatUtils.min(x), tolerance);        // test middle nan is ignored        x = new double[] {one, nan, three};        TestUtils.assertEquals(one, StatUtils.min(x), tolerance);                // test last nan is ignored        x = new double[] {one, two, nan};        TestUtils.assertEquals(one, StatUtils.min(x), tolerance);        // test all nan returns nan        x = new double[] {nan, nan, nan};        TestUtils.assertEquals(nan, StatUtils.min(x), tolerance);    }        public void testPercentile() {        double[] x = null;                // test null        try {            StatUtils.percentile(x, .25);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                try {            StatUtils.percentile(x, 0, 4, 0.25);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 25), tolerance);        TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 0, 0, 25), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.percentile(x, 25), tolerance);        TestUtils.assertEquals(two, StatUtils.percentile(x, 0, 1, 25), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(2.5, StatUtils.percentile(x, 70), tolerance);        TestUtils.assertEquals(2.5, StatUtils.percentile(x, 1, 3, 62.5), tolerance);    }        public void testDifferenceStats() throws Exception {        double sample1[] = {1d, 2d, 3d, 4d};        double sample2[] = {1d, 3d, 4d, 2d};        double diff[] = {0d, -1d, -1d, 2d};        double small[] = {1d, 4d};        double meanDifference = StatUtils.meanDifference(sample1, sample2);        assertEquals(StatUtils.sumDifference(sample1, sample2), StatUtils.sum(diff), tolerance);        assertEquals(meanDifference, StatUtils.mean(diff), tolerance);        assertEquals(StatUtils.varianceDifference(sample1, sample2, meanDifference),                 StatUtils.variance(diff), tolerance);        try {            StatUtils.meanDifference(sample1, small);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            StatUtils.varianceDifference(sample1, small, meanDifference);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            double[] single = {1.0};            StatUtils.varianceDifference(single, single, meanDifference);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }        public void testGeometricMean() throws Exception {        double[] test = null;        try {            double x = StatUtils.geometricMean(test);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        test = new double[] {2, 4, 6, 8};        assertEquals(Math.exp(0.25d * StatUtils.sumLog(test)),                 StatUtils.geometricMean(test), Double.MIN_VALUE);        assertEquals(Math.exp(0.5 * StatUtils.sumLog(test, 0, 2)),                 StatUtils.geometricMean(test, 0, 2), Double.MIN_VALUE);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class InvalidMatrixExceptionTest extends TestCase {    /**     *      */    public void testConstructor(){        InvalidMatrixException ex = new InvalidMatrixException();        assertNull(ex.getMessage());    }        /**     *      */    public void testConstructorMessage(){        String msg = "message";        InvalidMatrixException ex = new InvalidMatrixException(msg);        assertEquals(msg, ex.getMessage());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class MatrixIndexExceptionTest extends TestCase {        /**     *      */    public void testConstructorMessage(){        String msg = "message";        MatrixIndexException ex = new MatrixIndexException(msg);        assertEquals(msg, ex.getMessage());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import java.math.BigDecimal;/** * Test cases for the {@link BigMatrixImpl} class. * * @version $Revision$ $Date$ */public final class BigMatrixImplTest extends TestCase {        // Test data for String constructors    protected  String[][] testDataString = { {"1","2","3"}, {"2","5","3"}, {"1","0","8"} };        // 3 x 3 identity matrix    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };        // Test data for group operations    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},             {-1d,0d,-8d} };    protected double[] testDataRow1 = {1d,2d,3d};    protected double[] testDataCol3 = {3d,3d,8d};    protected double[][] testDataInv =         { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };    protected double[] preMultTest = {8,12,33};    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};    protected double[][] testDataPlusInv =         { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };        // lu decomposition tests    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},            {0.33333333333333,0d,0.33333333333333} };        // singular matrices    protected double[][] singular = { {2d,3d}, {2d,3d} };    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},            {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};        // vectors    protected double[] testVector = {1,2,3};    protected double[] testVector2 = {1,2,3,4};        // submatrix accessor tests    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},            {2, 4, 6, 8}, {4, 5, 6, 7}};     // array selections    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};    // effective permutations    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};    // contiguous ranges    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};    protected double[][] subRows23Cols00 = {{2} , {4}};    protected double[][] subRows00Cols33 = {{4}};    // row matrices    protected double[][] subRow0 = {{1,2,3,4}};    protected double[][] subRow3 = {{4,5,6,7}};    // column matrices    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};        // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;        public BigMatrixImplTest(String name) {        super(name);    }        public void setUp() {            }        public static Test suite() {        TestSuite suite = new TestSuite(BigMatrixImplTest.class);        suite.setName("BigMatrixImpl Tests");        return suite;    }    public static final double[] asDouble(BigDecimal[] data) {        double d[] = new double[data.length];        for (int i=0;i<d.length;i++) {            d[i] = data[i].doubleValue();        }        return d;    }    public static final double[][] asDouble(BigDecimal[][] data) {        double d[][] = new double[data.length][data[0].length];        for (int i=0;i<d.length;i++) {            for (int j=0;j<d[i].length;j++)            d[i][j] = data[i][j].doubleValue();        }        return d;    }    public static final BigDecimal[] asBigDecimal(double [] data) {        BigDecimal d[] = new BigDecimal[data.length];        for (int i=0;i<d.length;i++) {            d[i] = new BigDecimal(data[i]);        }        return d;    }    public static final BigDecimal[][] asBigDecimal(double [][] data) {        BigDecimal d[][] = new BigDecimal[data.length][data[0].length];        for (int i=0;i<d.length;i++) {            for (int j=0;j<data[i].length;j++) {                d[i][j] = new BigDecimal(data[i][j]);            }        }        return d;    }    /** test dimensions */    public void testDimensions() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl m2 = new BigMatrixImpl(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());    }          /** test copy functions */    public void testCopyFunctions() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl m2 = new BigMatrixImpl(m.getData());        assertEquals(m2,m);    }        /** test constructors */    public void testConstructors() {        BigMatrix m1 = new BigMatrixImpl(testData);        BigMatrix m2 = new BigMatrixImpl(testDataString);        BigMatrix m3 = new BigMatrixImpl(asBigDecimal(testData));        assertClose("double, string", m1, m2, Double.MIN_VALUE);        assertClose("double, BigDecimal", m1, m3, Double.MIN_VALUE);        assertClose("string, BigDecimal", m2, m3, Double.MIN_VALUE);        try {            BigMatrix m4 = new BigMatrixImpl(new String[][] {{"0", "hello", "1"}});            fail("Expecting NumberFormatException");        } catch (NumberFormatException ex) {            // expected        }        try {            BigMatrix m4 = new BigMatrixImpl(new String[][] {});            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            BigMatrix m4 = new BigMatrixImpl(new String[][] {{},{}});            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            BigMatrix m4 = new BigMatrixImpl(new String[][] {{"a", "b"},{"c"}});            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            BigMatrix m4 = new BigMatrixImpl(0, 1);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            BigMatrix m4 = new BigMatrixImpl(1, 0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }        /** test add */    public void testAdd() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);        BigMatrixImpl mPlusMInv = (BigMatrixImpl)m.add(mInv);        double[][] sumEntries = asDouble(mPlusMInv.getData());        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                    testDataPlusInv[row][col],sumEntries[row][col],                        entryTolerance);            }        }        }        /** test add failure */    public void testAddFail() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl m2 = new BigMatrixImpl(testData2);        try {            BigMatrixImpl mPlusMInv = (BigMatrixImpl)m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        /** test norm */    public void testNorm() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl m2 = new BigMatrixImpl(testData2);        assertEquals("testData norm",14d,m.getNorm().doubleValue(),entryTolerance);        assertEquals("testData2 norm",7d,m2.getNorm().doubleValue(),entryTolerance);    }         /** test m-n = m + -n */    public void testPlusMinus() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl m2 = new BigMatrixImpl(testDataInv);        assertClose("m-n = m + -n",m.subtract(m2),            m2.scalarMultiply(new BigDecimal(-1d)).add(m),entryTolerance);        try {            BigMatrix a = m.subtract(new BigMatrixImpl(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }       /** test multiply */     public void testMultiply() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);        BigMatrixImpl identity = new BigMatrixImpl(id);        BigMatrixImpl m2 = new BigMatrixImpl(testData2);        assertClose("inverse multiply",m.multiply(mInv),            identity,entryTolerance);        assertClose("inverse multiply",mInv.multiply(m),            identity,entryTolerance);        assertClose("identity multiply",m.multiply(identity),            m,entryTolerance);        assertClose("identity multiply",identity.multiply(mInv),            mInv,entryTolerance);        assertClose("identity multiply",m2.multiply(identity),            m2,entryTolerance);         try {            BigMatrix a = m.multiply(new BigMatrixImpl(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }           //Additional Test for BigMatrixImplTest.testMultiply    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};    private double[][] d4 = new double[][] {{1},{2},{3},{4}};    private double[][] d5 = new double[][] {{30},{70}};         public void testMultiply2() {        BigMatrix m3 = new BigMatrixImpl(d3);       BigMatrix m4 = new BigMatrixImpl(d4);       BigMatrix m5 = new BigMatrixImpl(d5);       assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);   }              /** test isSingular */    public void testIsSingular() {        BigMatrixImpl m = new BigMatrixImpl(singular);        assertTrue("singular",m.isSingular());        m = new BigMatrixImpl(bigSingular);        assertTrue("big singular",m.isSingular());        m = new BigMatrixImpl(id);        assertTrue("identity nonsingular",!m.isSingular());        m = new BigMatrixImpl(testData);        assertTrue("testData nonsingular",!m.isSingular());    }            /** test inverse */    public void testInverse() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrix mInv = new BigMatrixImpl(testDataInv);        assertClose("inverse",mInv,m.inverse(),normTolerance);        assertClose("inverse^2",m,m.inverse().inverse(),10E-12);                // Not square        m = new BigMatrixImpl(testData2);        try {            m.inverse();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }                // Singular        m = new BigMatrixImpl(singular);        try {            m.inverse();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        /** test solve */    public void testSolve() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrix mInv = new BigMatrixImpl(testDataInv);        // being a bit slothful here -- actually testing that X = A^-1 * B        assertClose("inverse-operate",                    asDouble(mInv.operate(asBigDecimal(testVector))),                    asDouble(m.solve(asBigDecimal(testVector))),                    normTolerance);        try {            double[] x = asDouble(m.solve(asBigDecimal(testVector2)));            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }               BigMatrix bs = new BigMatrixImpl(bigSingular);        try {            BigMatrix a = bs.solve(bs);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            ;        }        try {            BigMatrix a = m.solve(bs);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            BigMatrix a = (new BigMatrixImpl(testData2)).solve(bs);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }         try {            (new BigMatrixImpl(testData2)).luDecompose();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            ;        }      }        /** test determinant */    public void testDeterminant() {               BigMatrix m = new BigMatrixImpl(bigSingular);        assertEquals("singular determinant",0,m.getDeterminant().doubleValue(),0);        m = new BigMatrixImpl(detData);        assertEquals("nonsingular test",-3d,m.getDeterminant().doubleValue(),normTolerance);                // Examples verified against R (version 1.8.1, Red Hat Linux 9)        m = new BigMatrixImpl(detData2);        assertEquals("nonsingular R test 1",-2d,m.getDeterminant().doubleValue(),normTolerance);        m = new BigMatrixImpl(testData);        assertEquals("nonsingular  R test 2",-1d,m.getDeterminant().doubleValue(),normTolerance);        try {            double a = new BigMatrixImpl(testData2).getDeterminant().doubleValue();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            ;        }          }        /** test trace */    public void testTrace() {        BigMatrix m = new BigMatrixImpl(id);        assertEquals("identity trace",3d,m.getTrace().doubleValue(),entryTolerance);        m = new BigMatrixImpl(testData2);        try {            double x = m.getTrace().doubleValue();            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }        /** test sclarAdd */    public void testScalarAdd() {        BigMatrix m = new BigMatrixImpl(testData);        assertClose("scalar add",new BigMatrixImpl(testDataPlus2),            m.scalarAdd(new BigDecimal(2d)),entryTolerance);    }                        /** test operate */    public void testOperate() {        BigMatrix m = new BigMatrixImpl(id);        double[] x = asDouble(m.operate(asBigDecimal(testVector)));        assertClose("identity operate",testVector,x,entryTolerance);        m = new BigMatrixImpl(bigSingular);        try {            x = asDouble(m.operate(asBigDecimal(testVector)));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }        /** test transpose */    public void testTranspose() {        BigMatrix m = new BigMatrixImpl(testData);        assertClose("inverse-transpose",m.inverse().transpose(),            m.transpose().inverse(),normTolerance);        m = new BigMatrixImpl(testData2);        BigMatrix mt = new BigMatrixImpl(testData2T);        assertClose("transpose",mt,m.transpose(),normTolerance);    }        /** test preMultiply by vector */    public void testPremultiplyVector() {        BigMatrix m = new BigMatrixImpl(testData);        assertClose("premultiply",asDouble(m.preMultiply(asBigDecimal(testVector))),preMultTest,normTolerance);        m = new BigMatrixImpl(bigSingular);        try {            m.preMultiply(asBigDecimal(testVector));            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testPremultiply() {        BigMatrix m3 = new BigMatrixImpl(d3);        BigMatrix m4 = new BigMatrixImpl(d4);        BigMatrix m5 = new BigMatrixImpl(d5);        assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);                BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);        BigMatrixImpl identity = new BigMatrixImpl(id);        BigMatrixImpl m2 = new BigMatrixImpl(testData2);        assertClose("inverse multiply",m.preMultiply(mInv),                identity,entryTolerance);        assertClose("inverse multiply",mInv.preMultiply(m),                identity,entryTolerance);        assertClose("identity multiply",m.preMultiply(identity),                m,entryTolerance);        assertClose("identity multiply",identity.preMultiply(mInv),                mInv,entryTolerance);        try {            BigMatrix a = m.preMultiply(new BigMatrixImpl(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }        public void testGetVectors() {        BigMatrix m = new BigMatrixImpl(testData);        assertClose("get row",m.getRowAsDoubleArray(0),testDataRow1,entryTolerance);        assertClose("get col",m.getColumnAsDoubleArray(2),testDataCol3,entryTolerance);        try {            double[] x = m.getRowAsDoubleArray(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            ;        }        try {            double[] x = m.getColumnAsDoubleArray(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            ;        }    }          public void testLUDecomposition() throws Exception {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrix lu = m.getLUMatrix();        assertClose("LU decomposition", lu, (BigMatrix) new BigMatrixImpl(testDataLU), normTolerance);        verifyDecomposition(m, lu);        m = new BigMatrixImpl(luData);        lu = m.getLUMatrix();        assertClose("LU decomposition", lu, (BigMatrix) new BigMatrixImpl(luDataLUDecomposition), normTolerance);        verifyDecomposition(m, lu);        m = new BigMatrixImpl(testDataMinus);        lu = m.getLUMatrix();        verifyDecomposition(m, lu);        m = new BigMatrixImpl(id);        lu = m.getLUMatrix();        verifyDecomposition(m, lu);        try {            m = new BigMatrixImpl(bigSingular); // singular            lu = m.getLUMatrix();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }        try {            m = new BigMatrixImpl(testData2);  // not square            lu = m.getLUMatrix();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }       /**    * test submatrix accessors    */    public void testSubMatrix() {        BigMatrix m = new BigMatrixImpl(subTestData);        BigMatrix mRows23Cols00 = new BigMatrixImpl(subRows23Cols00);        BigMatrix mRows00Cols33 = new BigMatrixImpl(subRows00Cols33);        BigMatrix mRows01Cols23 = new BigMatrixImpl(subRows01Cols23);        BigMatrix mRows02Cols13 = new BigMatrixImpl(subRows02Cols13);        BigMatrix mRows03Cols12 = new BigMatrixImpl(subRows03Cols12);        BigMatrix mRows03Cols123 = new BigMatrixImpl(subRows03Cols123);        BigMatrix mRows20Cols123 = new BigMatrixImpl(subRows20Cols123);        BigMatrix mRows31Cols31 = new BigMatrixImpl(subRows31Cols31);        assertEquals("Rows23Cols00", mRows23Cols00,                 m.getSubMatrix(2 , 3 , 0, 0));        assertEquals("Rows00Cols33", mRows00Cols33,                 m.getSubMatrix(0 , 0 , 3, 3));        assertEquals("Rows01Cols23", mRows01Cols23,                m.getSubMatrix(0 , 1 , 2, 3));           assertEquals("Rows02Cols13", mRows02Cols13,                m.getSubMatrix(new int[] {0,2}, new int[] {1,3}));          assertEquals("Rows03Cols12", mRows03Cols12,                m.getSubMatrix(new int[] {0,3}, new int[] {1,2}));          assertEquals("Rows03Cols123", mRows03Cols123,                m.getSubMatrix(new int[] {0,3}, new int[] {1,2,3}));         assertEquals("Rows20Cols123", mRows20Cols123,                m.getSubMatrix(new int[] {2,0}, new int[] {1,2,3}));         assertEquals("Rows31Cols31", mRows31Cols31,                m.getSubMatrix(new int[] {3,1}, new int[] {3,1}));         assertEquals("Rows31Cols31", mRows31Cols31,                m.getSubMatrix(new int[] {3,1}, new int[] {3,1}));                 try {            m.getSubMatrix(1,0,2,4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(-1,1,2,2);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(1,0,2,2);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(1,0,2,4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(new int[] {}, new int[] {0});            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(new int[] {0}, new int[] {4});            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }        public void testGetColumnMatrix() {        BigMatrix m = new BigMatrixImpl(subTestData);        BigMatrix mColumn1 = new BigMatrixImpl(subColumn1);        BigMatrix mColumn3 = new BigMatrixImpl(subColumn3);        assertEquals("Column1", mColumn1,                 m.getColumnMatrix(1));        assertEquals("Column3", mColumn3,                 m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }        public void testGetRowMatrix() {        BigMatrix m = new BigMatrixImpl(subTestData);        BigMatrix mRow0 = new BigMatrixImpl(subRow0);        BigMatrix mRow3 = new BigMatrixImpl(subRow3);        assertEquals("Row0", mRow0,                 m.getRowMatrix(0));        assertEquals("Row3", mRow3,                 m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }        public void testEqualsAndHashCode() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl m1 = (BigMatrixImpl) m.copy();        BigMatrixImpl mt = (BigMatrixImpl) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(new BigMatrixImpl(bigSingular)));        // Different scales make BigDecimals, so matrices unequal        m = new BigMatrixImpl(new String[][] {{"2.0"}});        m1 = new BigMatrixImpl(new String[][] {{"2.00"}});        assertTrue(m.hashCode() != m1.hashCode());        assertFalse(m.equals(m1));    }        public void testToString() {        BigMatrixImpl m = new BigMatrixImpl(testData);        assertEquals("BigMatrixImpl{{1,2,3},{2,5,3},{1,0,8}}",                m.toString());        m = new BigMatrixImpl();        assertEquals("BigMatrixImpl{}",                m.toString());    }        public void testSetSubMatrix() throws Exception {        BigDecimal[][] detData3 =             MatrixUtils.createBigMatrix(detData2).getData();        BigMatrixImpl m = new BigMatrixImpl(testData);        m.setSubMatrix(detData3,1,1);        BigMatrix expected = MatrixUtils.createBigMatrix            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);                  m.setSubMatrix(detData3,0,0);        expected = MatrixUtils.createBigMatrix            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);                  BigDecimal[][] testDataPlus3 =             MatrixUtils.createBigMatrix(testDataPlus2).getData();        m.setSubMatrix(testDataPlus3,0,0);              expected = MatrixUtils.createBigMatrix        (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});        assertEquals(expected, m);                   // javadoc example        BigMatrixImpl matrix = (BigMatrixImpl) MatrixUtils.createBigMatrix            (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});        matrix.setSubMatrix(new BigDecimal[][] {{new BigDecimal(3),            new BigDecimal(4)}, {new BigDecimal(5), new BigDecimal(6)}}, 1, 1);        expected = MatrixUtils.createBigMatrix            (new BigDecimal[][] {{new BigDecimal(1), new BigDecimal(2),             new BigDecimal(3), new BigDecimal(4)}, {new BigDecimal(5),             new BigDecimal(3), new BigDecimal(4), new BigDecimal(8)},             {new BigDecimal(9), new BigDecimal(5) , new BigDecimal(6),              new BigDecimal(2)}});        assertEquals(expected, matrix);                   // dimension overflow        try {              m.setSubMatrix(matrix.getData(),1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }                // null        try {            m.setSubMatrix(null,1,1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }                // ragged        try {            m.setSubMatrix(new BigDecimal[][] {{new BigDecimal(1)},                    {new BigDecimal(2), new BigDecimal(3)}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }                // empty        try {            m.setSubMatrix(new BigDecimal[][] {{}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }            }        //--------------- -----------------Protected methods            /** verifies that two matrices are close (1-norm) */                  protected void assertClose(String msg, BigMatrix m, BigMatrix n,        double tolerance) {        assertTrue(msg,m.subtract(n).getNorm().doubleValue() < tolerance);    }        /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, double[] m, double[] n,        double tolerance) {        if (m.length != n.length) {            fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " +  i + " elements differ",                 m[i],n[i],tolerance);        }    }        /** extracts the l  and u matrices from compact lu representation */    protected void splitLU(BigMatrix lu, BigDecimal[][] lowerData, BigDecimal[][] upperData) throws InvalidMatrixException {        if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||                lowerData.length != upperData.length                || lowerData.length != lu.getRowDimension()) {            throw new InvalidMatrixException("incorrect dimensions");        }            int n = lu.getRowDimension();        for (int i = 0; i < n; i++) {            for (int j = 0; j < n; j++) {                if (j < i) {                    lowerData[i][j] = lu.getEntry(i, j);                    upperData[i][j] = new BigDecimal(0);                } else if (i == j) {                    lowerData[i][j] = new BigDecimal(1);                    upperData[i][j] = lu.getEntry(i, j);                } else {                    lowerData[i][j] = new BigDecimal(0);                    upperData[i][j] = lu.getEntry(i, j);                }               }        }    }        /** Returns the result of applying the given row permutation to the matrix */    protected BigMatrix permuteRows(BigMatrix matrix, int[] permutation) {        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {            throw new IllegalArgumentException("dimension mismatch");        }        int n = matrix.getRowDimension();        int m = matrix.getColumnDimension();        BigDecimal out[][] = new BigDecimal[m][n];        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                out[i][j] = matrix.getEntry(permutation[i], j);            }        }        return new BigMatrixImpl(out);    }        /** Extracts l and u matrices from lu and verifies that matrix = l times u modulo permutation */    protected void verifyDecomposition(BigMatrix matrix, BigMatrix lu) throws Exception{        int n = matrix.getRowDimension();        BigDecimal[][] lowerData = new BigDecimal[n][n];        BigDecimal[][] upperData = new BigDecimal[n][n];        splitLU(lu, lowerData, upperData);        BigMatrix lower =new BigMatrixImpl(lowerData);        BigMatrix upper = new BigMatrixImpl(upperData);        int[] permutation = ((BigMatrixImpl) matrix).getPermutation();        BigMatrix permuted = permuteRows(matrix, permutation);        assertClose("lu decomposition does not work", permuted,                lower.multiply(upper), normTolerance);    }             /** Useful for debugging */    private void dumpMatrix(BigMatrix m) {          for (int i = 0; i < m.getRowDimension(); i++) {              String os = "";              for (int j = 0; j < m.getColumnDimension(); j++) {                  os += m.getEntry(i, j) + " ";              }              System.out.println(os);          }    }        }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link RealMatrixImpl} class. * * @version $Revision$ $Date$ */public final class RealMatrixImplTest extends TestCase {        // 3 x 3 identity matrix    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };        // Test data for group operations    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},        {-1d,0d,-8d} };    protected double[] testDataRow1 = {1d,2d,3d};    protected double[] testDataCol3 = {3d,3d,8d};    protected double[][] testDataInv =         { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };    protected double[] preMultTest = {8,12,33};    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};    protected double[][] testDataPlusInv =         { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };        // lu decomposition tests    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},            {0.33333333333333,0d,0.33333333333333} };        // singular matrices    protected double[][] singular = { {2d,3d}, {2d,3d} };    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};        // vectors    protected double[] testVector = {1,2,3};    protected double[] testVector2 = {1,2,3,4};        // submatrix accessor tests    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},            {2, 4, 6, 8}, {4, 5, 6, 7}};     // array selections    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};    // effective permutations    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};    // contiguous ranges    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};    protected double[][] subRows23Cols00 = {{2} , {4}};    protected double[][] subRows00Cols33 = {{4}};    // row matrices    protected double[][] subRow0 = {{1,2,3,4}};    protected double[][] subRow3 = {{4,5,6,7}};    // column matrices    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};        // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;        public RealMatrixImplTest(String name) {        super(name);    }        public void setUp() {            }        public static Test suite() {        TestSuite suite = new TestSuite(RealMatrixImplTest.class);        suite.setName("RealMatrixImpl Tests");        return suite;    }        /** test dimensions */    public void testDimensions() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());    }         /** test copy functions */    public void testCopyFunctions() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(m.getData());        assertEquals(m2,m);    }                   /** test add */    public void testAdd() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);        RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(mInv);        double[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                    testDataPlusInv[row][col],sumEntries[row][col],                        entryTolerance);            }        }        }        /** test add failure */    public void testAddFail() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        try {            RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        /** test norm */    public void testNorm() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertEquals("testData norm",14d,m.getNorm(),entryTolerance);        assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);    }         /** test m-n = m + -n */    public void testPlusMinus() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testDataInv);        assertClose("m-n = m + -n",m.subtract(m2),            m2.scalarMultiply(-1d).add(m),entryTolerance);                try {            RealMatrix a = m.subtract(new RealMatrixImpl(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }       /** test multiply */     public void testMultiply() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);        RealMatrixImpl identity = new RealMatrixImpl(id);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertClose("inverse multiply",m.multiply(mInv),            identity,entryTolerance);        assertClose("inverse multiply",mInv.multiply(m),            identity,entryTolerance);        assertClose("identity multiply",m.multiply(identity),            m,entryTolerance);        assertClose("identity multiply",identity.multiply(mInv),            mInv,entryTolerance);        assertClose("identity multiply",m2.multiply(identity),            m2,entryTolerance);         try {            RealMatrix a = m.multiply(new RealMatrixImpl(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }           //Additional Test for RealMatrixImplTest.testMultiply    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};    private double[][] d4 = new double[][] {{1},{2},{3},{4}};    private double[][] d5 = new double[][] {{30},{70}};         public void testMultiply2() {        RealMatrix m3 = new RealMatrixImpl(d3);          RealMatrix m4 = new RealMatrixImpl(d4);       RealMatrix m5 = new RealMatrixImpl(d5);       assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);   }              /** test isSingular */    public void testIsSingular() {        RealMatrixImpl m = new RealMatrixImpl(singular);        assertTrue("singular",m.isSingular());        m = new RealMatrixImpl(bigSingular);        assertTrue("big singular",m.isSingular());        m = new RealMatrixImpl(id);        assertTrue("identity nonsingular",!m.isSingular());        m = new RealMatrixImpl(testData);        assertTrue("testData nonsingular",!m.isSingular());    }            /** test inverse */    public void testInverse() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrix mInv = new RealMatrixImpl(testDataInv);        assertClose("inverse",mInv,m.inverse(),normTolerance);        assertClose("inverse^2",m,m.inverse().inverse(),10E-12);                // Not square        m = new RealMatrixImpl(testData2);        try {            m.inverse();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }                // Singular        m = new RealMatrixImpl(singular);        try {            m.inverse();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        /** test solve */    public void testSolve() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrix mInv = new RealMatrixImpl(testDataInv);        // being a bit slothful here -- actually testing that X = A^-1 * B        assertClose("inverse-operate",mInv.operate(testVector),            m.solve(testVector),normTolerance);        try {            double[] x = m.solve(testVector2);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }               RealMatrix bs = new RealMatrixImpl(bigSingular);        try {            RealMatrix a = bs.solve(bs);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            ;        }        try {            RealMatrix a = m.solve(bs);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            RealMatrix a = (new RealMatrixImpl(testData2)).solve(bs);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }         try {            (new RealMatrixImpl(testData2)).luDecompose();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            ;        }      }        /** test determinant */    public void testDeterminant() {               RealMatrix m = new RealMatrixImpl(bigSingular);        assertEquals("singular determinant",0,m.getDeterminant(),0);        m = new RealMatrixImpl(detData);        assertEquals("nonsingular test",-3d,m.getDeterminant(),normTolerance);                // Examples verified against R (version 1.8.1, Red Hat Linux 9)        m = new RealMatrixImpl(detData2);        assertEquals("nonsingular R test 1",-2d,m.getDeterminant(),normTolerance);        m = new RealMatrixImpl(testData);        assertEquals("nonsingular  R test 2",-1d,m.getDeterminant(),normTolerance);        try {            double a = new RealMatrixImpl(testData2).getDeterminant();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            ;        }          }        /** test trace */    public void testTrace() {        RealMatrix m = new RealMatrixImpl(id);        assertEquals("identity trace",3d,m.getTrace(),entryTolerance);        m = new RealMatrixImpl(testData2);        try {            double x = m.getTrace();            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }        /** test sclarAdd */    public void testScalarAdd() {        RealMatrix m = new RealMatrixImpl(testData);        assertClose("scalar add",new RealMatrixImpl(testDataPlus2),            m.scalarAdd(2d),entryTolerance);    }                        /** test operate */    public void testOperate() {        RealMatrix m = new RealMatrixImpl(id);        double[] x = m.operate(testVector);        assertClose("identity operate",testVector,x,entryTolerance);        m = new RealMatrixImpl(bigSingular);        try {            x = m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }        /** test transpose */    public void testTranspose() {        RealMatrix m = new RealMatrixImpl(testData);         assertClose("inverse-transpose",m.inverse().transpose(),            m.transpose().inverse(),normTolerance);        m = new RealMatrixImpl(testData2);        RealMatrix mt = new RealMatrixImpl(testData2T);        assertClose("transpose",mt,m.transpose(),normTolerance);    }        /** test preMultiply by vector */    public void testPremultiplyVector() {        RealMatrix m = new RealMatrixImpl(testData);        assertClose("premultiply",m.preMultiply(testVector),preMultTest,normTolerance);        m = new RealMatrixImpl(bigSingular);        try {            m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testPremultiply() {        RealMatrix m3 = new RealMatrixImpl(d3);           RealMatrix m4 = new RealMatrixImpl(d4);        RealMatrix m5 = new RealMatrixImpl(d5);        assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);                RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);        RealMatrixImpl identity = new RealMatrixImpl(id);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertClose("inverse multiply",m.preMultiply(mInv),                identity,entryTolerance);        assertClose("inverse multiply",mInv.preMultiply(m),                identity,entryTolerance);        assertClose("identity multiply",m.preMultiply(identity),                m,entryTolerance);        assertClose("identity multiply",identity.preMultiply(mInv),                mInv,entryTolerance);        try {            RealMatrix a = m.preMultiply(new RealMatrixImpl(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }        public void testGetVectors() {        RealMatrix m = new RealMatrixImpl(testData);        assertClose("get row",m.getRow(0),testDataRow1,entryTolerance);        assertClose("get col",m.getColumn(2),testDataCol3,entryTolerance);        try {            double[] x = m.getRow(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            ;        }        try {            double[] x = m.getColumn(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            ;        }    }        public void testGetEntry() {        RealMatrix m = new RealMatrixImpl(testData);        assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);        try {            m.getEntry(10, 4);            fail ("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }            public void testLUDecomposition() throws Exception {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrix lu = m.getLUMatrix();        assertClose("LU decomposition", lu, (RealMatrix) new RealMatrixImpl(testDataLU), normTolerance);        verifyDecomposition(m, lu);        // access LU decomposition on same object to verify caching.        lu = m.getLUMatrix();        assertClose("LU decomposition", lu, (RealMatrix) new RealMatrixImpl(testDataLU), normTolerance);        verifyDecomposition(m, lu);        m = new RealMatrixImpl(luData);        lu = m.getLUMatrix();        assertClose("LU decomposition", lu, (RealMatrix) new RealMatrixImpl(luDataLUDecomposition), normTolerance);        verifyDecomposition(m, lu);        m = new RealMatrixImpl(testDataMinus);        lu = m.getLUMatrix();        verifyDecomposition(m, lu);        m = new RealMatrixImpl(id);        lu = m.getLUMatrix();        verifyDecomposition(m, lu);        try {            m = new RealMatrixImpl(bigSingular); // singular            lu = m.getLUMatrix();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }        try {            m = new RealMatrixImpl(testData2);  // not square            lu = m.getLUMatrix();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        /** test examples in user guide */    public void testExamples() {        // Create a real matrix with two rows and three columns        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};        RealMatrix m = new RealMatrixImpl(matrixData);        // One more with three rows, two columns        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};        RealMatrix n = new RealMatrixImpl(matrixData2);        // Now multiply m by n        RealMatrix p = m.multiply(n);        assertEquals(2, p.getRowDimension());        assertEquals(2, p.getColumnDimension());        // Invert p        RealMatrix pInverse = p.inverse();         assertEquals(2, pInverse.getRowDimension());        assertEquals(2, pInverse.getColumnDimension());                // Solve example        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};        RealMatrix coefficients = new RealMatrixImpl(coefficientsData);        double[] constants = {1, -2, 1};        double[] solution = coefficients.solve(constants);        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);               }        // test submatrix accessors    public void testSubMatrix() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealMatrix mRows23Cols00 = new RealMatrixImpl(subRows23Cols00);        RealMatrix mRows00Cols33 = new RealMatrixImpl(subRows00Cols33);        RealMatrix mRows01Cols23 = new RealMatrixImpl(subRows01Cols23);        RealMatrix mRows02Cols13 = new RealMatrixImpl(subRows02Cols13);        RealMatrix mRows03Cols12 = new RealMatrixImpl(subRows03Cols12);        RealMatrix mRows03Cols123 = new RealMatrixImpl(subRows03Cols123);        RealMatrix mRows20Cols123 = new RealMatrixImpl(subRows20Cols123);        RealMatrix mRows31Cols31 = new RealMatrixImpl(subRows31Cols31);        assertEquals("Rows23Cols00", mRows23Cols00,                 m.getSubMatrix(2 , 3 , 0, 0));        assertEquals("Rows00Cols33", mRows00Cols33,                 m.getSubMatrix(0 , 0 , 3, 3));        assertEquals("Rows01Cols23", mRows01Cols23,                m.getSubMatrix(0 , 1 , 2, 3));           assertEquals("Rows02Cols13", mRows02Cols13,                m.getSubMatrix(new int[] {0,2}, new int[] {1,3}));          assertEquals("Rows03Cols12", mRows03Cols12,                m.getSubMatrix(new int[] {0,3}, new int[] {1,2}));          assertEquals("Rows03Cols123", mRows03Cols123,                m.getSubMatrix(new int[] {0,3}, new int[] {1,2,3}));         assertEquals("Rows20Cols123", mRows20Cols123,                m.getSubMatrix(new int[] {2,0}, new int[] {1,2,3}));         assertEquals("Rows31Cols31", mRows31Cols31,                m.getSubMatrix(new int[] {3,1}, new int[] {3,1}));         assertEquals("Rows31Cols31", mRows31Cols31,                m.getSubMatrix(new int[] {3,1}, new int[] {3,1}));                 try {            m.getSubMatrix(1,0,2,4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(-1,1,2,2);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(1,0,2,2);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(1,0,2,4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(new int[] {}, new int[] {0});            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(new int[] {0}, new int[] {4});            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }        public void testGetRowMatrix() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealMatrix mRow0 = new RealMatrixImpl(subRow0);        RealMatrix mRow3 = new RealMatrixImpl(subRow3);        assertEquals("Row0", mRow0,                 m.getRowMatrix(0));        assertEquals("Row3", mRow3,                 m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }        public void testGetColumnMatrix() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealMatrix mColumn1 = new RealMatrixImpl(subColumn1);        RealMatrix mColumn3 = new RealMatrixImpl(subColumn3);        assertEquals("Column1", mColumn1,                 m.getColumnMatrix(1));        assertEquals("Column3", mColumn3,                 m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }        public void testEqualsAndHashCode() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m1 = (RealMatrixImpl) m.copy();        RealMatrixImpl mt = (RealMatrixImpl) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(new RealMatrixImpl(bigSingular)));     }        public void testToString() {        RealMatrixImpl m = new RealMatrixImpl(testData);        assertEquals("RealMatrixImpl{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",                m.toString());        m = new RealMatrixImpl();        assertEquals("RealMatrixImpl{}",                m.toString());    }        public void testSetSubMatrix() throws Exception {        RealMatrixImpl m = new RealMatrixImpl(testData);        m.setSubMatrix(detData2,1,1);        RealMatrix expected = MatrixUtils.createRealMatrix            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);                  m.setSubMatrix(detData2,0,0);        expected = MatrixUtils.createRealMatrix            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);                  m.setSubMatrix(testDataPlus2,0,0);              expected = MatrixUtils.createRealMatrix            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});        assertEquals(expected, m);                   // javadoc example        RealMatrixImpl matrix = (RealMatrixImpl) MatrixUtils.createRealMatrix            (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});        matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1);        expected = MatrixUtils.createRealMatrix            (new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}});        assertEquals(expected, matrix);                   // dimension overflow        try {              m.setSubMatrix(testData,1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // dimension underflow        try {              m.setSubMatrix(testData,-1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        try {              m.setSubMatrix(testData,1,-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }                // null        try {            m.setSubMatrix(null,1,1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }        RealMatrixImpl m2 = new RealMatrixImpl();        try {            m2.setSubMatrix(testData,0,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        try {            m2.setSubMatrix(testData,1,0);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }                // ragged        try {            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }               // empty        try {            m.setSubMatrix(new double[][] {{}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }            }        //--------------- -----------------Protected methods            /** verifies that two matrices are close (1-norm) */                  protected void assertClose(String msg, RealMatrix m, RealMatrix n,        double tolerance) {        assertTrue(msg,m.subtract(n).getNorm() < tolerance);    }        /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, double[] m, double[] n,        double tolerance) {        if (m.length != n.length) {            fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " +  i + " elements differ",                 m[i],n[i],tolerance);        }    }        /** extracts the l  and u matrices from compact lu representation */    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) throws InvalidMatrixException {           if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||                lowerData.length != upperData.length                || lowerData.length != lu.getRowDimension()) {            throw new InvalidMatrixException("incorrect dimensions");        }            int n = lu.getRowDimension();        for (int i = 0; i < n; i++) {            for (int j = 0; j < n; j++) {                if (j < i) {                    lowerData[i][j] = lu.getEntry(i, j);                    upperData[i][j] = 0d;                } else if (i == j) {                    lowerData[i][j] = 1d;                    upperData[i][j] = lu.getEntry(i, j);                } else {                    lowerData[i][j] = 0d;                    upperData[i][j] = lu.getEntry(i, j);                }               }        }    }        /** Returns the result of applying the given row permutation to the matrix */    protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) {        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {            throw new IllegalArgumentException("dimension mismatch");        }        int n = matrix.getRowDimension();        int m = matrix.getColumnDimension();        double out[][] = new double[m][n];        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                out[i][j] = matrix.getEntry(permutation[i], j);            }        }        return new RealMatrixImpl(out);    }        /** Extracts l and u matrices from lu and verifies that matrix = l times u modulo permutation */    protected void verifyDecomposition(RealMatrix matrix, RealMatrix lu) throws Exception{        int n = matrix.getRowDimension();        double[][] lowerData = new double[n][n];        double[][] upperData = new double[n][n];        splitLU(lu, lowerData, upperData);        RealMatrix lower =new RealMatrixImpl(lowerData);        RealMatrix upper = new RealMatrixImpl(upperData);        int[] permutation = ((RealMatrixImpl) matrix).getPermutation();        RealMatrix permuted = permuteRows(matrix, permutation);        assertClose("lu decomposition does not work", permuted, lower.multiply(upper), normTolerance);    }              /** Useful for debugging */    private void dumpMatrix(RealMatrix m) {          for (int i = 0; i < m.getRowDimension(); i++) {              String os = "";              for (int j = 0; j < m.getColumnDimension(); j++) {                  os += m.getEntry(i, j) + " ";              }              System.out.println(os);          }    }        }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.math.BigDecimal;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link MatrixUtils} class. * * @version $Revision$ $Date$ */public final class MatrixUtilsTest extends TestCase {        protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    protected double[][] nullMatrix = null;    protected double[] row = {1,2,3};    protected BigDecimal[] bigRow =         {new BigDecimal(1),new BigDecimal(2),new BigDecimal(3)};    protected String[] stringRow = {"1", "2", "3"};    protected double[][] rowMatrix = {{1,2,3}};    protected BigDecimal[][] bigRowMatrix =         {{new BigDecimal(1), new BigDecimal(2), new BigDecimal(3)}};    protected String[][] stringRowMatrix = {{"1", "2", "3"}};    protected double[] col = {0,4,6};    protected BigDecimal[] bigCol =         {new BigDecimal(0),new BigDecimal(4),new BigDecimal(6)};    protected String[] stringCol = {"0","4","6"};    protected double[] nullDoubleArray = null;    protected double[][] colMatrix = {{0},{4},{6}};    protected BigDecimal[][] bigColMatrix =         {{new BigDecimal(0)},{new BigDecimal(4)},{new BigDecimal(6)}};    protected String[][] stringColMatrix = {{"0"}, {"4"}, {"6"}};        public MatrixUtilsTest(String name) {        super(name);    }        public void setUp() {         }        public static Test suite() {        TestSuite suite = new TestSuite(MatrixUtilsTest.class);        suite.setName("MatrixUtils Tests");        return suite;    }        public void testCreateRealMatrix() {        assertEquals(new RealMatrixImpl(testData),                 MatrixUtils.createRealMatrix(testData));        try {            MatrixUtils.createRealMatrix(new double[][] {{1}, {1,2}});  // ragged            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }         try {            MatrixUtils.createRealMatrix(new double[][] {{}, {}});  // no columns            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createRealMatrix(null);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }     }        public void testCreateBigMatrix() {        assertEquals(new BigMatrixImpl(testData),                 MatrixUtils.createBigMatrix(testData));        assertEquals(new BigMatrixImpl(bigColMatrix),                 MatrixUtils.createBigMatrix(bigColMatrix));        assertEquals(new BigMatrixImpl(stringColMatrix),                 MatrixUtils.createBigMatrix(stringColMatrix));        try {            MatrixUtils.createBigMatrix(new double[][] {{1}, {1,2}});  // ragged            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }         try {            MatrixUtils.createBigMatrix(new double[][] {{}, {}});  // no columns            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createBigMatrix(nullMatrix);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }     }            public void testCreateRowRealMatrix() {        assertEquals((RealMatrixImpl) MatrixUtils.createRowRealMatrix(row),               new RealMatrixImpl(rowMatrix));        try {            MatrixUtils.createRowRealMatrix(new double[] {});  // empty            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createRowRealMatrix(null);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }     }        public void testCreateRowBigMatrix() {        assertEquals((BigMatrixImpl) MatrixUtils.createRowBigMatrix(row),                new BigMatrixImpl(rowMatrix));        assertEquals((BigMatrixImpl) MatrixUtils.createRowBigMatrix(bigRow),                new BigMatrixImpl(bigRowMatrix));        assertEquals((BigMatrixImpl) MatrixUtils.createRowBigMatrix(stringRow),                new BigMatrixImpl(stringRowMatrix));        try {            MatrixUtils.createRowBigMatrix(new double[] {});  // empty            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createRowBigMatrix(nullDoubleArray);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }     }        public void testCreateColumnRealMatrix() {        assertEquals((RealMatrixImpl) MatrixUtils.createColumnRealMatrix(col),                new RealMatrixImpl(colMatrix));        try {            MatrixUtils.createColumnRealMatrix(new double[] {});  // empty            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createColumnRealMatrix(null);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }     }        public void testCreateColumnBigMatrix() {        assertEquals((BigMatrixImpl) MatrixUtils.createColumnBigMatrix(col),                new BigMatrixImpl(colMatrix));        assertEquals((BigMatrixImpl) MatrixUtils.createColumnBigMatrix(bigCol),                new BigMatrixImpl(bigColMatrix));        assertEquals((BigMatrixImpl) MatrixUtils.createColumnBigMatrix(stringCol),                new BigMatrixImpl(stringColMatrix));                  try {            MatrixUtils.createColumnBigMatrix(new double[] {});  // empty            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createColumnBigMatrix(nullDoubleArray);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }     }        /**     * Verifies that the matrix is an identity matrix     */    protected void checkIdentityMatrix(RealMatrix m) {        for (int i = 0; i < m.getRowDimension(); i++) {            for (int j =0; j < m.getColumnDimension(); j++) {                if (i == j) {                    assertEquals(m.getEntry(i, j), 1d, 0);                } else {                    assertEquals(m.getEntry(i, j), 0d, 0);                }            }        }       }        public void testCreateIdentityMatrix() {        checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(3));        checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(2));        checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(1));        try {            MatrixUtils.createRealIdentityMatrix(0);        } catch (IllegalArgumentException ex) {            // expected        }    }        /**     * Verifies that the matrix is an identity matrix     */    protected void checkIdentityBigMatrix(BigMatrix m) {        for (int i = 0; i < m.getRowDimension(); i++) {            for (int j =0; j < m.getColumnDimension(); j++) {                if (i == j) {                    assertEquals(m.getEntry(i, j), BigMatrixImpl.ONE);                } else {                    assertEquals(m.getEntry(i, j), BigMatrixImpl.ZERO);                }            }        }       }        public void testCreateBigIdentityMatrix() {        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(3));        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(2));        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(1));        try {            MatrixUtils.createRealIdentityMatrix(0);        } catch (IllegalArgumentException ex) {            // expected        }    }        }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;public class QRDecompositionImplTest extends TestCase {    double[][] testData3x3NonSingular = {             { 12, -51, 4 },             { 6, 167, -68 },            { -4, 24, -41 }, };    double[][] testData3x3Singular = {             { 1, 4, 7, },             { 2, 5, 8, },            { 3, 6, 9, }, };    double[][] testData3x4 = {             { 12, -51, 4, 1 },             { 6, 167, -68, 2 },            { -4, 24, -41, 3 }, };    double[][] testData4x3 = {             { 12, -51, 4, },             { 6, 167, -68, },            { -4, 24, -41, },             { -5, 34, 7, }, };    final double entryTolerance = 10e-16;    final double normTolerance = 10e-14;    public QRDecompositionImplTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(QRDecompositionImplTest.class);        suite.setName("QRDecompositionImpl Tests");        return suite;    }    /** test dimensions */    public void testDimensions() {        RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);        QRDecomposition qr = new QRDecompositionImpl(matrix);        assertEquals("3x3 Q size", qr.getQ().getRowDimension(), 3);        assertEquals("3x3 Q size", qr.getQ().getColumnDimension(), 3);        assertEquals("3x3 R size", qr.getR().getRowDimension(), 3);        assertEquals("3x3 R size", qr.getR().getColumnDimension(), 3);        matrix = new RealMatrixImpl(testData4x3);        qr = new QRDecompositionImpl(matrix);        assertEquals("4x3 Q size", qr.getQ().getRowDimension(), 4);        assertEquals("4x3 Q size", qr.getQ().getColumnDimension(), 4);        assertEquals("4x3 R size", qr.getR().getRowDimension(), 4);        assertEquals("4x3 R size", qr.getR().getColumnDimension(), 3);        matrix = new RealMatrixImpl(testData3x4);        qr = new QRDecompositionImpl(matrix);        assertEquals("3x4 Q size", qr.getQ().getRowDimension(), 3);        assertEquals("3x4 Q size", qr.getQ().getColumnDimension(), 3);        assertEquals("3x4 R size", qr.getR().getRowDimension(), 3);        assertEquals("3x4 R size", qr.getR().getColumnDimension(), 4);    }    /** test A = QR */    public void testAEqualQR() {        RealMatrix A = new RealMatrixImpl(testData3x3NonSingular);        QRDecomposition qr = new QRDecompositionImpl(A);        RealMatrix Q = qr.getQ();        RealMatrix R = qr.getR();        double norm = Q.multiply(R).subtract(A).getNorm();        assertEquals("3x3 nonsingular A = QR", 0, norm, normTolerance);        RealMatrix matrix = new RealMatrixImpl(testData3x3Singular);        qr = new QRDecompositionImpl(matrix);        norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();        assertEquals("3x3 singular A = QR", 0, norm, normTolerance);        matrix = new RealMatrixImpl(testData3x4);        qr = new QRDecompositionImpl(matrix);        norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();        assertEquals("3x4 A = QR", 0, norm, normTolerance);        matrix = new RealMatrixImpl(testData4x3);        qr = new QRDecompositionImpl(matrix);        norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();        assertEquals("4x3 A = QR", 0, norm, normTolerance);    }    /** test the orthogonality of Q */    public void testQOrthogonal() {        RealMatrix matrix = new RealMatrixImpl(testData3x3NonSingular);        matrix = new QRDecompositionImpl(matrix).getQ();        RealMatrix eye = MatrixUtils.createRealIdentityMatrix(3);        double norm = matrix.transpose().multiply(matrix).subtract(eye)                .getNorm();        assertEquals("3x3 nonsingular Q'Q = I", 0, norm, normTolerance);        matrix = new RealMatrixImpl(testData3x3Singular);        matrix = new QRDecompositionImpl(matrix).getQ();        eye = MatrixUtils.createRealIdentityMatrix(3);        norm = matrix.transpose().multiply(matrix).subtract(eye)                .getNorm();        assertEquals("3x3 singular Q'Q = I", 0, norm, normTolerance);        matrix = new RealMatrixImpl(testData3x4);        matrix = new QRDecompositionImpl(matrix).getQ();        eye = MatrixUtils.createRealIdentityMatrix(3);        norm = matrix.transpose().multiply(matrix).subtract(eye)                .getNorm();        assertEquals("3x4 Q'Q = I", 0, norm, normTolerance);        matrix = new RealMatrixImpl(testData4x3);        matrix = new QRDecompositionImpl(matrix).getQ();        eye = MatrixUtils.createRealIdentityMatrix(4);        norm = matrix.transpose().multiply(matrix).subtract(eye)                .getNorm();        assertEquals("4x3 Q'Q = I", 0, norm, normTolerance);    }    /** test that R is upper triangular */    public void testRUpperTriangular() {        RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);        RealMatrix R = new QRDecompositionImpl(matrix).getR();        for (int i = 0; i < R.getRowDimension(); i++)            for (int j = 0; j < i; j++)                assertEquals("R lower triangle", R.getEntry(i, j), 0,                        entryTolerance);        matrix = new RealMatrixImpl(testData3x4);        R = new QRDecompositionImpl(matrix).getR();        for (int i = 0; i < R.getRowDimension(); i++)            for (int j = 0; j < i; j++)                assertEquals("R lower triangle", R.getEntry(i, j), 0,                        entryTolerance);        matrix = new RealMatrixImpl(testData4x3);        R = new QRDecompositionImpl(matrix).getR();        for (int i = 0; i < R.getRowDimension(); i++)            for (int j = 0; j < i; j++)                assertEquals("R lower triangle", R.getEntry(i, j), 0,                        entryTolerance);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import org.apache.commons.math.ConvergenceException;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class FractionTest extends TestCase {    private void assertFraction(int expectedNumerator, int expectedDenominator, Fraction actual) {        assertEquals(expectedNumerator, actual.getNumerator());        assertEquals(expectedDenominator, actual.getDenominator());    }        public void testConstructor() {        assertFraction(0, 1, new Fraction(0, 1));        assertFraction(0, 1, new Fraction(0, 2));        assertFraction(0, 1, new Fraction(0, -1));        assertFraction(1, 2, new Fraction(1, 2));        assertFraction(1, 2, new Fraction(2, 4));        assertFraction(-1, 2, new Fraction(-1, 2));        assertFraction(-1, 2, new Fraction(1, -2));        assertFraction(-1, 2, new Fraction(-2, 4));        assertFraction(-1, 2, new Fraction(2, -4));                // overflow        try {            new Fraction(Integer.MIN_VALUE, -1);            fail();        } catch (ArithmeticException ex) {            // success        }        try {            new Fraction(1, Integer.MIN_VALUE);            fail();        } catch (ArithmeticException ex) {            // success        }        try {                    assertFraction(0, 1, new Fraction(0.00000000000001));            assertFraction(2, 5, new Fraction(0.40000000000001));            assertFraction(15, 1, new Fraction(15.0000000000001));                    } catch (ConvergenceException ex) {            fail(ex.getMessage());        }    }        public void testCompareTo() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(1, 3);        Fraction third = new Fraction(1, 2);                assertEquals(0, first.compareTo(first));        assertEquals(0, first.compareTo(third));        assertEquals(1, first.compareTo(second));        assertEquals(-1, second.compareTo(first));    }        public void testDoubleValue() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(1, 3);        assertEquals(0.5, first.doubleValue(), 0.0);        assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);    }        public void testFloatValue() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(1, 3);        assertEquals(0.5f, first.floatValue(), 0.0f);        assertEquals((float)(1.0 / 3.0), second.floatValue(), 0.0f);    }        public void testIntValue() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(3, 2);        assertEquals(0, first.intValue());        assertEquals(1, second.intValue());    }        public void testLongValue() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(3, 2);        assertEquals(0L, first.longValue());        assertEquals(1L, second.longValue());    }        public void testConstructorDouble() {        try {            assertFraction(1, 2, new Fraction(0.5));            assertFraction(1, 3, new Fraction(1.0 / 3.0));            assertFraction(17, 100, new Fraction(17.0 / 100.0));            assertFraction(317, 100, new Fraction(317.0 / 100.0));            assertFraction(-1, 2, new Fraction(-0.5));            assertFraction(-1, 3, new Fraction(-1.0 / 3.0));            assertFraction(-17, 100, new Fraction(17.0 / -100.0));            assertFraction(-317, 100, new Fraction(-317.0 / 100.0));        } catch (ConvergenceException ex) {            fail(ex.getMessage());        }    }        public void testAbs() {        Fraction a = new Fraction(10, 21);        Fraction b = new Fraction(-10, 21);        Fraction c = new Fraction(10, -21);                assertFraction(10, 21, a.abs());        assertFraction(10, 21, b.abs());        assertFraction(10, 21, c.abs());    }        public void testReciprocal() {        Fraction f = null;                f = new Fraction(50, 75);        f = f.reciprocal();        assertEquals(3, f.getNumerator());        assertEquals(2, f.getDenominator());                f = new Fraction(4, 3);        f = f.reciprocal();        assertEquals(3, f.getNumerator());        assertEquals(4, f.getDenominator());                f = new Fraction(-15, 47);        f = f.reciprocal();        assertEquals(-47, f.getNumerator());        assertEquals(15, f.getDenominator());                f = new Fraction(0, 3);        try {            f = f.reciprocal();            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}        // large values        f = new Fraction(Integer.MAX_VALUE, 1);        f = f.reciprocal();        assertEquals(1, f.getNumerator());        assertEquals(Integer.MAX_VALUE, f.getDenominator());    }        public void testNegate() {        Fraction f = null;                f = new Fraction(50, 75);        f = f.negate();        assertEquals(-2, f.getNumerator());        assertEquals(3, f.getDenominator());                f = new Fraction(-50, 75);        f = f.negate();        assertEquals(2, f.getNumerator());        assertEquals(3, f.getDenominator());        // large values        f = new Fraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE);        f = f.negate();        assertEquals(Integer.MIN_VALUE+2, f.getNumerator());        assertEquals(Integer.MAX_VALUE, f.getDenominator());        f = new Fraction(Integer.MIN_VALUE, 1);        try {            f = f.negate();            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}    }        public void testAdd() {        Fraction a = new Fraction(1, 2);        Fraction b = new Fraction(2, 3);                assertFraction(1, 1, a.add(a));        assertFraction(7, 6, a.add(b));        assertFraction(7, 6, b.add(a));        assertFraction(4, 3, b.add(b));                Fraction f1 = new Fraction(Integer.MAX_VALUE - 1, 1);        Fraction f2 = Fraction.ONE;        Fraction f = f1.add(f2);        assertEquals(Integer.MAX_VALUE, f.getNumerator());        assertEquals(1, f.getDenominator());                f1 = new Fraction(-1, 13*13*2*2);        f2 = new Fraction(-2, 13*17*2);        f = f1.add(f2);        assertEquals(13*13*17*2*2, f.getDenominator());        assertEquals(-17 - 2*13*2, f.getNumerator());                try {            f.add(null);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {}                // if this fraction is added naively, it will overflow.        // check that it doesn't.        f1 = new Fraction(1,32768*3);        f2 = new Fraction(1,59049);        f = f1.add(f2);        assertEquals(52451, f.getNumerator());        assertEquals(1934917632, f.getDenominator());        f1 = new Fraction(Integer.MIN_VALUE, 3);        f2 = new Fraction(1,3);        f = f1.add(f2);        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());        assertEquals(3, f.getDenominator());                f1 = new Fraction(Integer.MAX_VALUE - 1, 1);        f2 = Fraction.ONE;        f = f1.add(f2);        assertEquals(Integer.MAX_VALUE, f.getNumerator());        assertEquals(1, f.getDenominator());                try {            f = f.add(Fraction.ONE); // should overflow            fail("expecting ArithmeticException but got: " + f.toString());        } catch (ArithmeticException ex) {}                // denominator should not be a multiple of 2 or 3 to trigger overflow        f1 = new Fraction(Integer.MIN_VALUE, 5);        f2 = new Fraction(-1,5);        try {            f = f1.add(f2); // should overflow            fail("expecting ArithmeticException but got: " + f.toString());        } catch (ArithmeticException ex) {}                try {            f= new Fraction(-Integer.MAX_VALUE, 1);            f = f.add(f);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}                try {            f= new Fraction(-Integer.MAX_VALUE, 1);            f = f.add(f);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}                f1 = new Fraction(3,327680);        f2 = new Fraction(2,59049);        try {            f = f1.add(f2); // should overflow            fail("expecting ArithmeticException but got: " + f.toString());        } catch (ArithmeticException ex) {}    }        public void testDivide() {        Fraction a = new Fraction(1, 2);        Fraction b = new Fraction(2, 3);                assertFraction(1, 1, a.divide(a));        assertFraction(3, 4, a.divide(b));        assertFraction(4, 3, b.divide(a));        assertFraction(1, 1, b.divide(b));                Fraction f1 = new Fraction(3, 5);        Fraction f2 = Fraction.ZERO;        try {            Fraction f = f1.divide(f2);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}                f1 = new Fraction(0, 5);        f2 = new Fraction(2, 7);        Fraction f = f1.divide(f2);        assertSame(Fraction.ZERO, f);                f1 = new Fraction(2, 7);        f2 = Fraction.ONE;        f = f1.divide(f2);        assertEquals(2, f.getNumerator());        assertEquals(7, f.getDenominator());                f1 = new Fraction(1, Integer.MAX_VALUE);        f = f1.divide(f1);          assertEquals(1, f.getNumerator());        assertEquals(1, f.getDenominator());                f1 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        f2 = new Fraction(1, Integer.MAX_VALUE);        f = f1.divide(f2);        assertEquals(Integer.MIN_VALUE, f.getNumerator());        assertEquals(1, f.getDenominator());        try {            f.divide(null);            fail("IllegalArgumentException");        } catch (IllegalArgumentException ex) {}                try {            f1 = new Fraction(1, Integer.MAX_VALUE);            f = f1.divide(f1.reciprocal());  // should overflow            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}        try {            f1 = new Fraction(1, -Integer.MAX_VALUE);            f = f1.divide(f1.reciprocal());  // should overflow            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}    }        public void testMultiply() {        Fraction a = new Fraction(1, 2);        Fraction b = new Fraction(2, 3);                assertFraction(1, 4, a.multiply(a));        assertFraction(1, 3, a.multiply(b));        assertFraction(1, 3, b.multiply(a));        assertFraction(4, 9, b.multiply(b));                Fraction f1 = new Fraction(Integer.MAX_VALUE, 1);        Fraction f2 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        Fraction f = f1.multiply(f2);        assertEquals(Integer.MIN_VALUE, f.getNumerator());        assertEquals(1, f.getDenominator());        try {            f.multiply(null);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {}    }        public void testSubtract() {        Fraction a = new Fraction(1, 2);        Fraction b = new Fraction(2, 3);                assertFraction(0, 1, a.subtract(a));        assertFraction(-1, 6, a.subtract(b));        assertFraction(1, 6, b.subtract(a));        assertFraction(0, 1, b.subtract(b));                Fraction f = new Fraction(1,1);        try {            f.subtract(null);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {}                // if this fraction is subtracted naively, it will overflow.        // check that it doesn't.        Fraction f1 = new Fraction(1,32768*3);        Fraction f2 = new Fraction(1,59049);        f = f1.subtract(f2);        assertEquals(-13085, f.getNumerator());        assertEquals(1934917632, f.getDenominator());        f1 = new Fraction(Integer.MIN_VALUE, 3);        f2 = new Fraction(1,3).negate();        f = f1.subtract(f2);        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());        assertEquals(3, f.getDenominator());                f1 = new Fraction(Integer.MAX_VALUE, 1);        f2 = Fraction.ONE;        f = f1.subtract(f2);        assertEquals(Integer.MAX_VALUE-1, f.getNumerator());        assertEquals(1, f.getDenominator());        try {            f1 = new Fraction(1, Integer.MAX_VALUE);            f2 = new Fraction(1, Integer.MAX_VALUE - 1);            f = f1.subtract(f2);            fail("expecting ArithmeticException");  //should overflow        } catch (ArithmeticException ex) {}                // denominator should not be a multiple of 2 or 3 to trigger overflow        f1 = new Fraction(Integer.MIN_VALUE, 5);        f2 = new Fraction(1,5);        try {            f = f1.subtract(f2); // should overflow            fail("expecting ArithmeticException but got: " + f.toString());        } catch (ArithmeticException ex) {}                try {            f= new Fraction(Integer.MIN_VALUE, 1);            f = f.subtract(Fraction.ONE);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}                try {            f= new Fraction(Integer.MAX_VALUE, 1);            f = f.subtract(Fraction.ONE.negate());            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}                f1 = new Fraction(3,327680);        f2 = new Fraction(2,59049);        try {            f = f1.subtract(f2); // should overflow            fail("expecting ArithmeticException but got: " + f.toString());        } catch (ArithmeticException ex) {}    }        public void testEqualsAndHashCode() {        Fraction zero  = new Fraction(0,1);        Fraction nullFraction = null;        int zeroHash = zero.hashCode();        assertTrue( zero.equals(zero));        assertFalse(zero.equals(nullFraction));        assertFalse(zero.equals(new Double(0)));        Fraction zero2 = new Fraction(0,2);        assertTrue(zero.equals(zero2));        assertEquals(zero.hashCode(), zero2.hashCode());        Fraction one = new Fraction(1,1);        assertFalse((one.equals(zero) ||zero.equals(one)));    }        public void testGetReducedFraction() {        Fraction threeFourths = new Fraction(3, 4);        assertTrue(threeFourths.equals(Fraction.getReducedFraction(6, 8)));        assertTrue(Fraction.ZERO.equals(Fraction.getReducedFraction(0, -1)));        try {            Fraction f = Fraction.getReducedFraction(1, 0);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected        }        assertEquals(Fraction.getReducedFraction                (2, Integer.MIN_VALUE).getNumerator(),-1);        assertEquals(Fraction.getReducedFraction                (1, -1).getNumerator(), -1);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import java.text.NumberFormat;import java.text.ParseException;import java.util.Locale;import junit.framework.TestCase;public class FractionFormatTest extends TestCase {     FractionFormat properFormat = null;    FractionFormat improperFormat = null;    protected Locale getLocale() {        return Locale.getDefault();    }    protected void setUp() throws Exception {        properFormat = FractionFormat.getProperInstance(getLocale());        improperFormat = FractionFormat.getImproperInstance(getLocale());    }       public void testFormat() {        Fraction c = new Fraction(1, 2);        String expected = "1 / 2";                String actual = properFormat.format(c);         assertEquals(expected, actual);        actual = improperFormat.format(c);        assertEquals(expected, actual);    }    public void testFormatNegative() {        Fraction c = new Fraction(-1, 2);        String expected = "-1 / 2";        String actual = properFormat.format(c);         assertEquals(expected, actual);        actual = improperFormat.format(c);         assertEquals(expected, actual);    }    public void testFormatZero() {        Fraction c = new Fraction(0, 1);        String expected = "0 / 1";        String actual = properFormat.format(c);         assertEquals(expected, actual);        actual = improperFormat.format(c);         assertEquals(expected, actual);    }        public void testFormatImproper() {        Fraction c = new Fraction(5, 3);        String actual = properFormat.format(c);         assertEquals("1 2 / 3", actual);        actual = improperFormat.format(c);         assertEquals("5 / 3", actual);    }        public void testFormatImproperNegative() {        Fraction c = new Fraction(-5, 3);        String actual = properFormat.format(c);         assertEquals("-1 2 / 3", actual);        actual = improperFormat.format(c);         assertEquals("-5 / 3", actual);    }        public void testParse() {        String source = "1 / 2";        try {            Fraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(1, c.getNumerator());            assertEquals(2, c.getDenominator());                        c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(1, c.getNumerator());            assertEquals(2, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }    }        public void testParseInteger() {        String source = "10";        try {            Fraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(10, c.getNumerator());            assertEquals(1, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }        try {            Fraction c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(10, c.getNumerator());            assertEquals(1, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }    }        public void testParseInvalid() {        String source = "a";        String msg = "should not be able to parse '10 / a'.";        try {            properFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }        try {            improperFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }    }        public void testParseInvalidDenominator() {        String source = "10 / a";        String msg = "should not be able to parse '10 / a'.";        try {            properFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }        try {            improperFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }    }        public void testParseNegative() {        try {            String source = "-1 / 2";            Fraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumerator());            assertEquals(2, c.getDenominator());                        c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumerator());            assertEquals(2, c.getDenominator());            source = "1 / -2";            c = properFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumerator());            assertEquals(2, c.getDenominator());                        c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumerator());            assertEquals(2, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }    }        public void testParseProper() {        String source = "1 2 / 3";        try {            Fraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(5, c.getNumerator());            assertEquals(3, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }                try {            improperFormat.parse(source);            fail("invalid improper fraction.");        } catch (ParseException ex) {            // success        }    }        public void testParseProperNegative() {        String source = "-1 2 / 3";        try {            Fraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(-5, c.getNumerator());            assertEquals(3, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }                try {            improperFormat.parse(source);            fail("invalid improper fraction.");        } catch (ParseException ex) {            // success        }    }        public void testParseProperInvalidMinus() {        String source = "2 -2 / 3";        try {            Fraction c = properFormat.parse(source);            fail("invalid minus in improper fraction.");        } catch (ParseException ex) {            // expected        }        source = "2 2 / -3";        try {            Fraction c = properFormat.parse(source);            fail("invalid minus in improper fraction.");        } catch (ParseException ex) {            // expected        }    }        public void testNumeratorFormat() {        NumberFormat old = properFormat.getNumeratorFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        properFormat.setNumeratorFormat(nf);        assertEquals(nf, properFormat.getNumeratorFormat());        properFormat.setNumeratorFormat(old);        old = improperFormat.getNumeratorFormat();        nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        improperFormat.setNumeratorFormat(nf);        assertEquals(nf, improperFormat.getNumeratorFormat());        improperFormat.setNumeratorFormat(old);    }        public void testDenominatorFormat() {        NumberFormat old = properFormat.getDenominatorFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        properFormat.setDenominatorFormat(nf);        assertEquals(nf, properFormat.getDenominatorFormat());        properFormat.setDenominatorFormat(old);        old = improperFormat.getDenominatorFormat();        nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        improperFormat.setDenominatorFormat(nf);        assertEquals(nf, improperFormat.getDenominatorFormat());        improperFormat.setDenominatorFormat(old);    }        public void testWholeFormat() {        ProperFractionFormat format = (ProperFractionFormat)properFormat;                NumberFormat old = format.getWholeFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        format.setWholeFormat(nf);        assertEquals(nf, format.getWholeFormat());        format.setWholeFormat(old);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class DistributionFactoryImplTest extends TestCase {    /** */    private DistributionFactory factory;        /**     * Constructor for DistributionFactoryImplTest.     * @param name     */    public DistributionFactoryImplTest(String name) {        super(name);    }    /**     * @throws java.lang.Exception     */    protected void setUp() throws Exception {        super.setUp();        factory = new DistributionFactoryImpl();    }    /**     * @throws java.lang.Exception     */    protected void tearDown() throws Exception {        factory = null;        super.tearDown();    }        public void testCreateChiSquareDistributionNegative(){        try {            factory.createChiSquareDistribution(-1.0);            fail("negative degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateChiSquareDistributionZero(){        try {            factory.createChiSquareDistribution(0.0);            fail("zero degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateChiSquareDistributionPositive(){        try {            factory.createChiSquareDistribution(1.0);        } catch (IllegalArgumentException ex) {            fail("positive degrees of freedom.  IllegalArgumentException is not expected");        }    }        public void testCreateFDistributionNegativePositive(){        try {            factory.createFDistribution(-1.0, 1.0);            fail("negative degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateFDistributionZeroPositive(){        try {            factory.createFDistribution(0.0, 1.0);            fail("zero degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateFDistributionPositiveNegative(){        try {            factory.createFDistribution(1.0, -1.0);            fail("negative degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateFDistributionPositiveZero(){        try {            factory.createFDistribution(1.0, 0.0);            fail("zero degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateFDistributionPositivePositive(){        try {            factory.createFDistribution(1.0, 1.0);        } catch (IllegalArgumentException ex) {            fail("positive degrees of freedom.  IllegalArgumentException is not expected");        }    }        public void testCreateExponentialDistributionNegative(){        try {            factory.createExponentialDistribution(-1.0);            fail("negative mean.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateExponentialDistributionZero(){        try {            factory.createExponentialDistribution(0.0);            fail("zero mean.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateExponentialDistributionPositive(){        try {            factory.createExponentialDistribution(1.0);        } catch (IllegalArgumentException ex) {            fail("positive mean.  IllegalArgumentException is not expected");        }    }        public void testCreateGammaDistributionNegativePositive(){        try {            factory.createGammaDistribution(-1.0, 1.0);            fail("negative alpha.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateGammaDistributionZeroPositive(){        try {            factory.createGammaDistribution(0.0, 1.0);            fail("zero alpha.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateGammaDistributionPositiveNegative(){        try {            factory.createGammaDistribution(1.0, -1.0);            fail("negative beta.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateGammaDistributionPositiveZero(){        try {            factory.createGammaDistribution(1.0, 0.0);            fail("zero beta.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateGammaDistributionPositivePositive(){        try {            factory.createGammaDistribution(1.0, 1.0);        } catch (IllegalArgumentException ex) {            fail("positive alpah and beta.  IllegalArgumentException is not expected");        }    }        public void testCreateTDistributionNegative(){        try {            factory.createTDistribution(-1.0);            fail("negative degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateTDistributionZero(){        try {            factory.createTDistribution(0.0);            fail("zero degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateTDistributionPositive(){        try {            factory.createTDistribution(1.0);        } catch (IllegalArgumentException ex) {            fail("positive degrees of freedom.  IllegalArgumentException is not expected");        }    }        public void testBinomialDistributionNegativePositive(){        try {            factory.createBinomialDistribution(-1, 0.5);            fail("negative number of trials.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex ) {        }    }        public void testBinomialDistributionZeroPositive(){        try {            factory.createBinomialDistribution(0, 0.5);        } catch (IllegalArgumentException ex ) {            fail("zero number of trials.  IllegalArgumentException is not expected");        }    }        public void testBinomialDistributionPositivePositive(){        try {            factory.createBinomialDistribution(10, 0.5);        } catch (IllegalArgumentException ex ) {            fail("positive number of trials.  IllegalArgumentException is not expected");        }    }        public void testBinomialDistributionPositiveNegative(){        try {            factory.createBinomialDistribution(10, -0.5);            fail("negative probability of success.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex ) {        }    }        public void testBinomialDistributionPositiveZero(){        try {            factory.createBinomialDistribution(10, 0.0);        } catch (IllegalArgumentException ex ) {            fail("zero probability of success.  IllegalArgumentException is not expected");        }    }        public void testBinomialDistributionPositiveOne(){        try {            factory.createBinomialDistribution(10, 1.0);        } catch (IllegalArgumentException ex ) {            fail("valid probability of success.  IllegalArgumentException is not expected");        }    }        public void testBinomialDistributionPositiveTwo(){        try {            factory.createBinomialDistribution(10, 2.0);            fail("high probability of success.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex ) {        }    }        public void testHypergeometricDistributionNegativePositivePositive(){        try {            factory.createHypergeometricDistribution(-1, 10, 10);            fail("negative population size.  IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }    }        public void testHypergeometricDistributionZeroPositivePositive(){        try {            factory.createHypergeometricDistribution(0, 10, 10);            fail("zero population size.  IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }    }        public void testHypergeometricDistributionPositiveNegativePositive(){        try {            factory.createHypergeometricDistribution(20, -1, 10);            fail("negative number of successes.  IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }    }        public void testHypergeometricDistributionPositiveZeroPositive(){        try {            factory.createHypergeometricDistribution(20, 0, 10);        } catch(IllegalArgumentException ex) {            fail("valid number of successes.  IllegalArgumentException is not expected");        }    }        public void testHypergeometricDistributionPositivePositiveNegative(){        try {            factory.createHypergeometricDistribution(20, 10, -1);            fail("negative sample size.  IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }    }        public void testHypergeometricDistributionPositivePositiveZero(){        try {            factory.createHypergeometricDistribution(20, 10, 0);        } catch(IllegalArgumentException ex) {            fail("valid sample size.  IllegalArgumentException is not expected");        }    }        public void testHypergeometricDistributionSmallPopulationSize() {        try {            factory.createHypergeometricDistribution(5, 3, 10);            fail("sample size larger than population size.  IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }    }        public void testCauchyDistributionNegative() {        try {            factory.createCauchyDistribution(0.0, -1.0);            fail("invalid scale. IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }    }        public void testCauchyDistributionZero() {        try {            factory.createCauchyDistribution(0.0, 0.0);            fail("invalid scale. IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }    }        public void testWeibullDistributionNegativePositive() {        try {            factory.createWeibullDistribution(-1.0, 1.0);            fail("invalid shape. IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }    }        public void testWeibullDistributionZeroPositive() {        try {            factory.createWeibullDistribution(0.0, 1.0);            fail("invalid shape. IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }    }        public void testWeibullDistributionPositiveNegative() {        try {            factory.createWeibullDistribution(1.0, -1.0);            fail("invalid scale. IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }    }        public void testWeibullDistributionPositiveZero() {        try {            factory.createWeibullDistribution(1.0, 0.0);            fail("invalid scale. IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for WeibullDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. *  * @version $Revision: 1.8 $ $Date: 2004-07-24 16:41:37 -0500 (Sat, 24 Jul 2004) $ */public class WeibullDistributionTest extends ContinuousDistributionAbstractTest  {        /**     * Constructor for CauchyDistributionTest.     * @param arg0     */    public WeibullDistributionTest(String arg0) {        super(arg0);    }        //-------------- Implementations for abstract methods -----------------------        /** Creates the default continuous distribution instance to use in tests. */    public ContinuousDistribution makeDistribution() {        return DistributionFactory.newInstance().createWeibullDistribution(1.2, 2.1);    }           /** Creates the default cumulative probability distribution test input values */    public double[] makeCumulativeTestPoints() {        // quantiles computed using Mathematica         return new double[] {0.00664355181d, 0.04543282833d, 0.09811627374d,                0.1767135246d, 0.3219468654d, 4.207902826d, 5.23968437d,                6.232056007d, 7.497630467d, 10.51154969d};    }        /** Creates the default cumulative probability density test expected values */    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,                0.975d, 0.990d, 0.999d};    }        //---------------------------- Additional test cases -------------------------        public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0.0, 1.0});        setInverseCumulativeTestValues(                new double[] {0.0, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }        public void testAlpha() {        WeibullDistribution distribution = (WeibullDistribution) getDistribution();        double expected = Math.random();        distribution.setShape(expected);        assertEquals(expected, distribution.getShape(), 0.0);    }        public void testBeta() {        WeibullDistribution distribution = (WeibullDistribution) getDistribution();        double expected = Math.random();        distribution.setScale(expected);        assertEquals(expected, distribution.getScale(), 0.0);    }        public void testSetAlpha() {        WeibullDistribution distribution = (WeibullDistribution) getDistribution();        try {            distribution.setShape(0.0);            fail("Can not have 0.0 alpha.");        } catch (IllegalArgumentException ex) {            // success        }                try {            distribution.setShape(-1.0);            fail("Can not have negative alpha.");        } catch (IllegalArgumentException ex) {            // success        }    }        public void testSetBeta() {        WeibullDistribution distribution = (WeibullDistribution) getDistribution();        try {            distribution.setScale(0.0);            fail("Can not have 0.0 beta.");        } catch (IllegalArgumentException ex) {            // success        }                try {            distribution.setScale(-1.0);            fail("Can not have negative beta.");        } catch (IllegalArgumentException ex) {            // success        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for PascalDistribution. * Extends IntegerDistributionAbstractTest.  See class javadoc for * IntegerDistributionAbstractTest for details. *  * @version $Revision:$ $Date:$ */public class PascalDistributionTest extends IntegerDistributionAbstractTest {        /**     * Constructor for PascalDistributionTest.     * @param name     */    public PascalDistributionTest(String name) {        super(name);    }        //-------------- Implementations for abstract methods -----------------------        /** Creates the default discrete distribution instance to use in tests. */    public IntegerDistribution makeDistribution() {        return DistributionFactory.newInstance().createPascalDistribution(10,0.70);    }        /** Creates the default probability density test input values */    public int[] makeDensityTestPoints() {      return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};    }        /** Creates the default probability density test expected values */    public double[] makeDensityTestValues() {      return new double[] {0d, 0.02824d, 0.08474d, 0.13982d,           0.16779d, 0.16359d, 0.1374d, 0.10306d, 0.070673d, 0.04505d, 0.02703d, 0.01540d, 0.0084};    }        /** Creates the default cumulative probability density test input values */    public int[] makeCumulativeTestPoints() {      return makeDensityTestPoints();    }        /** Creates the default cumulative probability density test expected values */    public double[] makeCumulativeTestValues() {      return new double[] {0d, 0.02824d, 0.11299d, 0.25281d, 0.42060d, 0.58420d,          0.72162d, 0.82468d, 0.89535d, 0.94041d, 0.967446d, 0.98285, 0.99125d};        }        /** Creates the default inverse cumulative probability test input values */    public double[] makeInverseCumulativeTestPoints() {      return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,          0.990d, 0.975d, 0.950d, 0.900d, 1};         }        /** Creates the default inverse cumulative probability density test expected values */    public int[] makeInverseCumulativeTestValues() {      return new int[] {-1, -1, -1, -1, 0, 0, 13, 10, 9, 8, 7, Integer.MAX_VALUE};    }    //----------------- Additional test cases ---------------------------------       /** Test degenerate case p = 0   */    public void testDegenerate0() throws Exception {        setDistribution(DistributionFactory.newInstance().createPascalDistribution(5,0.0d));        setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });        setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 0d});        setDensityTestPoints(new int[] {-1, 0, 1, 10, 11});        setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 1});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();         }        /** Test degenerate case p = 1   */    public void testDegenerate1() throws Exception {        setDistribution(DistributionFactory.newInstance().createPascalDistribution(5,1.0d));        setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });        setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10});        setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {-1, -1});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();         }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.TestUtils;/** * Test cases for HyperGeometriclDistribution. * Extends IntegerDistributionAbstractTest.  See class javadoc for * IntegerDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class HypergeometricDistributionTest extends IntegerDistributionAbstractTest {    /**     * Constructor for ChiSquareDistributionTest.     * @param name     */    public HypergeometricDistributionTest(String name) {        super(name);    }//-------------- Implementations for abstract methods -----------------------        /** Creates the default discrete distribution instance to use in tests. */    public IntegerDistribution makeDistribution() {        return DistributionFactory.newInstance().createHypergeometricDistribution(10,5, 5);    }        /** Creates the default probability density test input values */    public int[] makeDensityTestPoints() {        return new int[] {-1, 0, 1, 2, 3, 4, 5, 10};    }        /** Creates the default probability density test expected values */    public double[] makeDensityTestValues() {        return new double[] {0d, 0.003968d, 0.099206d, 0.396825d, 0.396825d,                 0.099206d, 0.003968d, 0d};    }        /** Creates the default cumulative probability density test input values */    public int[] makeCumulativeTestPoints() {        return makeDensityTestPoints();    }        /** Creates the default cumulative probability density test expected values */    public double[] makeCumulativeTestValues() {        return new double[] {0d, .003968d, .103175d, .50000d, .896825d, .996032d,                1.00000d, 1d};    }        /** Creates the default inverse cumulative probability test input values */    public double[] makeInverseCumulativeTestPoints() {        return new double[] {0d, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d, 1d};     }        /** Creates the default inverse cumulative probability density test expected values */    public int[] makeInverseCumulativeTestValues() {        return new int[] {-1, -1, 0, 0, 0, 0, 4, 3, 3, 3, 3, 5};    }        //-------------------- Additional test cases ------------------------------        /** Verify that if there are no failures, mass is concentrated on sampleSize */    public void testDegenerateNoFailures() throws Exception {        setDistribution(DistributionFactory.newInstance().createHypergeometricDistribution(5,5,3));        setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });        setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});        setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {2, 2});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();         }        /** Verify that if there are no successes, mass is concentrated on 0 */    public void testDegenerateNoSuccesses() throws Exception {        setDistribution(DistributionFactory.newInstance().createHypergeometricDistribution(5,0,3));        setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });        setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});        setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {-1, -1});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();         }        /** Verify that if sampleSize = populationSize, mass is concentrated on numberOfSuccesses */    public void testDegenerateFullSample() throws Exception {        setDistribution(DistributionFactory.newInstance().createHypergeometricDistribution(5,3,5));        setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });        setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});        setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {2, 2});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();         }    public void testPopulationSize() {        HypergeometricDistribution dist = DistributionFactory.newInstance().createHypergeometricDistribution(5,3,5);        try {            dist.setPopulationSize(-1);            fail("negative population size.  IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }                dist.setPopulationSize(10);        assertEquals(10, dist.getPopulationSize());    }        public void testLargeValues() {        int populationSize = 3456;        int sampleSize = 789;        int numberOfSucceses = 101;        double[][] data = {            {0.0, 2.75646034603961e-12, 2.75646034603961e-12, 1.0},            {1.0, 8.55705370142386e-11, 8.83269973602783e-11, 0.999999999997244},            {2.0, 1.31288129219665e-9, 1.40120828955693e-9, 0.999999999911673},            {3.0, 1.32724172984193e-8, 1.46736255879763e-8, 0.999999998598792},            {4.0, 9.94501711734089e-8, 1.14123796761385e-7, 0.999999985326375},            {5.0, 5.89080768883643e-7, 7.03204565645028e-7, 0.999999885876203},            {20.0, 0.0760051397707708, 0.27349758476299, 0.802507555007781},             {21.0, 0.087144222047629, 0.360641806810619, 0.72650241523701},             {22.0, 0.0940378846881819, 0.454679691498801, 0.639358193189381},             {23.0, 0.0956897500614809, 0.550369441560282, 0.545320308501199},             {24.0, 0.0919766921922999, 0.642346133752582, 0.449630558439718},             {25.0, 0.083641637261095, 0.725987771013677, 0.357653866247418},             {96.0, 5.93849188852098e-57, 1.0, 6.01900244560712e-57},            {97.0, 7.96593036832547e-59, 1.0, 8.05105570861321e-59},             {98.0, 8.44582921934367e-61, 1.0, 8.5125340287733e-61},            {99.0, 6.63604297068222e-63, 1.0, 6.670480942963e-63},             {100.0, 3.43501099007557e-65, 1.0, 3.4437972280786e-65},            {101.0, 8.78623800302957e-68, 1.0, 8.78623800302957e-68},        };                testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);    }    private void testHypergeometricDistributionProbabilities(int populationSize, int sampleSize, int numberOfSucceses, double[][] data) {        HypergeometricDistributionImpl dist = new HypergeometricDistributionImpl(populationSize, numberOfSucceses, sampleSize);        for (int i = 0; i < data.length; ++i) {            int x = (int)data[i][0];            double pdf = data[i][1];            double actualPdf = dist.probability(x);            TestUtils.assertRelativelyEquals(pdf, actualPdf, 1.0e-9);            double cdf = data[i][2];            double actualCdf = dist.cumulativeProbability(x);            TestUtils.assertRelativelyEquals(cdf, actualCdf, 1.0e-9);            double cdf1 = data[i][3];            double actualCdf1 = dist.upperCumulativeProbability(x);            TestUtils.assertRelativelyEquals(cdf1, actualCdf1, 1.0e-9);        }    }        public void testMoreLargeValues() {        int populationSize = 26896;        int sampleSize = 895;        int numberOfSucceses = 55;        double[][] data = {            {0.0, 0.155168304750504, 0.155168304750504, 1.0},             {1.0, 0.29437545000746, 0.449543754757964, 0.844831695249496},             {2.0, 0.273841321577003, 0.723385076334967, 0.550456245242036},             {3.0, 0.166488572570786, 0.889873648905753, 0.276614923665033},             {4.0, 0.0743969744713231, 0.964270623377076, 0.110126351094247},             {5.0, 0.0260542785784855, 0.990324901955562, 0.0357293766229237},             {20.0, 3.57101101678792e-16, 1.0, 3.78252101622096e-16},             {21.0, 2.00551638598312e-17, 1.0, 2.11509999433041e-17},             {22.0, 1.04317070180562e-18, 1.0, 1.09583608347287e-18},             {23.0, 5.03153504903308e-20, 1.0, 5.266538166725e-20},             {24.0, 2.2525984149695e-21, 1.0, 2.35003117691919e-21},             {25.0, 9.3677424515947e-23, 1.0, 9.74327619496943e-23},             {50.0, 9.83633962945521e-69, 1.0, 9.8677629437617e-69},             {51.0, 3.13448949497553e-71, 1.0, 3.14233143064882e-71},             {52.0, 7.82755221928122e-74, 1.0, 7.84193567329055e-74},             {53.0, 1.43662126065532e-76, 1.0, 1.43834540093295e-76},             {54.0, 1.72312692517348e-79, 1.0, 1.7241402776278e-79},             {55.0, 1.01335245432581e-82, 1.0, 1.01335245432581e-82},                };        testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import junit.framework.TestCase;/** * Abstract base class for {@link IntegerDistribution} tests. * <p> * To create a concrete test class for an integer distribution implementation, *  implement makeDistribution() to return a distribution instance to use in  *  tests and each of the test data generation methods below.  In each case, the *  test points and test values arrays returned represent parallel arrays of  *  inputs and expected values for the distribution returned by makeDistribution(). *  <p> *  makeDensityTestPoints() -- arguments used to test probability density calculation *  makeDensityTestValues() -- expected probability densities *  makeCumulativeTestPoints() -- arguments used to test cumulative probabilities *  makeCumulativeTestValues() -- expected cumulative probabilites *  makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf evaluation *  makeInverseCumulativeTestValues() -- expected inverse cdf values * <p> *  To implement additional test cases with different distribution instances and test data, *  use the setXxx methods for the instance data in test cases and call the verifyXxx methods *  to verify results.  *  * @version $Revision$ $Date$ */public abstract class IntegerDistributionAbstractTest extends TestCase {    //-------------------- Private test instance data -------------------------    /** Discrete distribution instance used to perform tests */    private IntegerDistribution distribution;        /** Tolerance used in comparing expected and returned values */    private double tolerance = 1E-4;        /** Arguments used to test probability density calculations */    private int[] densityTestPoints;        /** Values used to test probability density calculations */    private double[] densityTestValues;        /** Arguments used to test cumulative probability density calculations */    private int[] cumulativeTestPoints;        /** Values used to test cumulative probability density calculations */    private double[] cumulativeTestValues;        /** Arguments used to test inverse cumulative probability density calculations */    private double[] inverseCumulativeTestPoints;        /** Values used to test inverse cumulative probability density calculations */    private int[] inverseCumulativeTestValues;        //-------------------------------------------------------------------------        /**     * Constructor for IntegerDistributionAbstractTest.     * @param name     */    public IntegerDistributionAbstractTest(String name) {        super(name);    }        //-------------------- Abstract methods -----------------------------------        /** Creates the default discrete distribution instance to use in tests. */    public abstract IntegerDistribution makeDistribution();        /** Creates the default probability density test input values */    public abstract int[] makeDensityTestPoints();        /** Creates the default probability density test expected values */    public abstract double[] makeDensityTestValues();        /** Creates the default cumulative probability density test input values */    public abstract int[] makeCumulativeTestPoints();        /** Creates the default cumulative probability density test expected values */    public abstract double[] makeCumulativeTestValues();        /** Creates the default inverse cumulative probability test input values */    public abstract double[] makeInverseCumulativeTestPoints();        /** Creates the default inverse cumulative probability density test expected values */    public abstract int[] makeInverseCumulativeTestValues();        //-------------------- Setup / tear down ----------------------------------         /**     * Setup sets all test instance data to default values      */    protected void setUp() throws Exception {        super.setUp();        distribution = makeDistribution();        densityTestPoints = makeDensityTestPoints();        densityTestValues = makeDensityTestValues();        cumulativeTestPoints = makeCumulativeTestPoints();        cumulativeTestValues = makeCumulativeTestValues();        inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();        inverseCumulativeTestValues = makeInverseCumulativeTestValues();       }        /**     * Cleans up test instance data     */    protected void tearDown() throws Exception {              super.tearDown();        distribution = null;        densityTestPoints = null;        densityTestValues = null;        cumulativeTestPoints = null;        cumulativeTestValues = null;        inverseCumulativeTestPoints = null;        inverseCumulativeTestValues = null;       }        //-------------------- Verification methods -------------------------------        /**     * Verifies that probability density calculations match exptected values     * using current test instance data     */    protected void verifyDensities() throws Exception {        for (int i = 0; i < densityTestPoints.length; i++) {            assertEquals("Incorrect density value returned for " + densityTestPoints[i],                    densityTestValues[i],                     distribution.probability(densityTestPoints[i]), tolerance);        }         }        /**     * Verifies that cumulative probability density calculations match exptected values     * using current test instance data     */       protected void verifyCumulativeProbabilities() throws Exception {        for (int i = 0; i < cumulativeTestPoints.length; i++) {            assertEquals("Incorrect cumulative probability value returned for " + cumulativeTestPoints[i],                    cumulativeTestValues[i],                     distribution.cumulativeProbability(cumulativeTestPoints[i]), tolerance);        }               }        /**     * Verifies that inverse cumulative probability density calculations match exptected values     * using current test instance data     */    protected void verifyInverseCumulativeProbabilities() throws Exception {        for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {            assertEquals("Incorrect inverse cumulative probability value returned for "                     + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i],                     distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]));        }               }        //------------------------ Default test cases -----------------------------    /**     * Verifies that probability density calculations match exptected values     * using default test instance data     */    public void testDensities() throws Exception {        verifyDensities();         }        /**     * Verifies that cumulative probability density calculations match exptected values     * using default test instance data     */    public void testCumulativeProbabilities() throws Exception {        verifyCumulativeProbabilities();          }        /**     * Verifies that inverse cumulative probability density calculations match exptected values     * using default test instance data     */    public void testInverseCumulativeProbabilities() throws Exception {        verifyInverseCumulativeProbabilities();           }        /**     * Verifies that illegal arguments are correctly handled     */    public void testIllegalArguments() throws Exception {        try {            distribution.cumulativeProbability(1, 0);            fail("Expecting IllegalArgumentException for bad cumulativeProbability interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            distribution.inverseCumulativeProbability(-1);            fail("Expecting IllegalArgumentException for p = -1");        } catch (IllegalArgumentException ex) {            // expected        }        try {            distribution.inverseCumulativeProbability(2);            fail("Expecting IllegalArgumentException for p = 2");        } catch (IllegalArgumentException ex) {            // expected        }           }        //------------------ Getters / Setters for test instance data -----------    /**     * @return Returns the cumulativeTestPoints.     */    protected int[] getCumulativeTestPoints() {        return cumulativeTestPoints;    }    /**     * @param cumulativeTestPoints The cumulativeTestPoints to set.     */    protected void setCumulativeTestPoints(int[] cumulativeTestPoints) {        this.cumulativeTestPoints = cumulativeTestPoints;    }    /**     * @return Returns the cumulativeTestValues.     */    protected double[] getCumulativeTestValues() {        return cumulativeTestValues;    }    /**     * @param cumulativeTestValues The cumulativeTestValues to set.     */    protected void setCumulativeTestValues(double[] cumulativeTestValues) {        this.cumulativeTestValues = cumulativeTestValues;    }    /**     * @return Returns the densityTestPoints.     */    protected int[] getDensityTestPoints() {        return densityTestPoints;    }    /**     * @param densityTestPoints The densityTestPoints to set.     */    protected void setDensityTestPoints(int[] densityTestPoints) {        this.densityTestPoints = densityTestPoints;    }    /**     * @return Returns the densityTestValues.     */    protected double[] getDensityTestValues() {        return densityTestValues;    }    /**     * @param densityTestValues The densityTestValues to set.     */    protected void setDensityTestValues(double[] densityTestValues) {        this.densityTestValues = densityTestValues;    }    /**     * @return Returns the distribution.     */    protected IntegerDistribution getDistribution() {        return distribution;    }    /**     * @param distribution The distribution to set.     */    protected void setDistribution(IntegerDistribution distribution) {        this.distribution = distribution;    }    /**     * @return Returns the inverseCumulativeTestPoints.     */    protected double[] getInverseCumulativeTestPoints() {        return inverseCumulativeTestPoints;    }    /**     * @param inverseCumulativeTestPoints The inverseCumulativeTestPoints to set.     */    protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) {        this.inverseCumulativeTestPoints = inverseCumulativeTestPoints;    }    /**     * @return Returns the inverseCumulativeTestValues.     */    protected int[] getInverseCumulativeTestValues() {        return inverseCumulativeTestValues;    }    /**     * @param inverseCumulativeTestValues The inverseCumulativeTestValues to set.     */    protected void setInverseCumulativeTestValues(int[] inverseCumulativeTestValues) {        this.inverseCumulativeTestValues = inverseCumulativeTestValues;    }    /**     * @return Returns the tolerance.     */    protected double getTolerance() {        return tolerance;    }    /**     * @param tolerance The tolerance to set.     */    protected void setTolerance(double tolerance) {        this.tolerance = tolerance;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for TDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */public class TDistributionTest extends ContinuousDistributionAbstractTest {    /**     * Constructor for TDistributionTest.     * @param name     */    public TDistributionTest(String name) {        super(name);    }//-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    public ContinuousDistribution makeDistribution() {        return DistributionFactory.newInstance().createTDistribution(5.0);    }    /** Creates the default cumulative probability distribution test input values */    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 1.8.1 (linux version)        return new double[] {-5.89343,-3.36493, -2.570582, -2.015048,            -1.475884, 0.0, 5.89343, 3.36493, 2.570582,            2.015048, 1.475884};    }    /** Creates the default cumulative probability density test expected values */    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.5d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d};    }    // --------------------- Override tolerance  --------------    protected void setup() throws Exception {        super.setUp();        setTolerance(1E-6);    }    //---------------------------- Additional test cases -------------------------    /**     * @see <a href="http://issues.apache.org/bugzilla/show_bug.cgi?id=27243">     *      Bug report that prompted this unit test.</a>     */    public void testCumulativeProbabilityAgaintStackOverflow() throws Exception {        TDistributionImpl td = new TDistributionImpl(5.);        double est;        est = td.cumulativeProbability(.1);        est = td.cumulativeProbability(.01);    }    public void testSmallDf() throws Exception {        setDistribution(DistributionFactory.newInstance().createTDistribution(1d));        setTolerance(1E-4);        // quantiles computed using R version 1.8.1 (linux version)        setCumulativeTestPoints(new double[] {-318.3088, -31.82052, -12.70620, -6.313752,            -3.077684, 0.0, 318.3088, 31.82052, 12.70620,            6.313752, 3.077684});        setInverseCumulativeTestValues(getCumulativeTestPoints());        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }    public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0, 1});        setInverseCumulativeTestValues(                new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }    public void testDfAccessors() {        TDistribution distribution = (TDistribution) getDistribution();        assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);        distribution.setDegreesOfFreedom(4d);        assertEquals(4d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);        try {            distribution.setDegreesOfFreedom(0d);            fail("Expecting IllegalArgumentException for df = 0");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for CauchyDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class CauchyDistributionTest extends ContinuousDistributionAbstractTest  {        /**     * Constructor for CauchyDistributionTest.     * @param arg0     */    public CauchyDistributionTest(String arg0) {        super(arg0);    }        //-------------- Implementations for abstract methods -----------------------        /** Creates the default continuous distribution instance to use in tests. */    public ContinuousDistribution makeDistribution() {        return DistributionFactory.newInstance().createCauchyDistribution(1.2, 2.1);    }           /** Creates the default cumulative probability distribution test input values */    public double[] makeCumulativeTestPoints() {        // quantiles computed using Mathematica         return new double[] {-667.2485619d, -65.6230835d, -25.48302995d,                -12.05887818d, -5.263135428d, 7.663135428d, 14.45887818d,                27.88302995d, 68.0230835d, 669.6485619d};    }        /** Creates the default cumulative probability density test expected values */    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,                0.975d, 0.990d, 0.999d};    }        //---------------------------- Additional test cases -------------------------        public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0.0, 1.0});        setInverseCumulativeTestValues(                new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }        public void testMedian() {        CauchyDistribution distribution = (CauchyDistribution) getDistribution();        double expected = Math.random();        distribution.setMedian(expected);        assertEquals(expected, distribution.getMedian(), 0.0);    }        public void testScale() {        CauchyDistribution distribution = (CauchyDistribution) getDistribution();        double expected = Math.random();        distribution.setScale(expected);        assertEquals(expected, distribution.getScale(), 0.0);    }        public void testSetScale() {        CauchyDistribution distribution = (CauchyDistribution) getDistribution();        try {            distribution.setScale(0.0);            fail("Can not have 0.0 scale.");        } catch (IllegalArgumentException ex) {            // success        }                try {            distribution.setScale(-1.0);            fail("Can not have negative scale.");        } catch (IllegalArgumentException ex) {            // success        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for FDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class FDistributionTest extends ContinuousDistributionAbstractTest {    /**     * Constructor for FDistributionTest.     * @param name     */    public FDistributionTest(String name) {        super(name);    }    //-------------- Implementations for abstract methods -----------------------        /** Creates the default continuous distribution instance to use in tests. */    public ContinuousDistribution makeDistribution() {        return DistributionFactory.newInstance().createFDistribution(5.0, 6.0);    }           /** Creates the default cumulative probability distribution test input values */    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 1.8.1 (linux version)        return new double[] {0.03468084d ,0.09370091d, 0.1433137d,            0.2020084d, 0.2937283d, 20.80266d, 8.745895d, 5.987565d,             4.387374d, 3.107512d};    }        /** Creates the default cumulative probability density test expected values */    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d};     }        // --------------------- Override tolerance  --------------    protected void setup() throws Exception {        super.setUp();        setTolerance(1E-6);    }    //---------------------------- Additional test cases -------------------------    public void testCumulativeProbabilityExtremes() throws Exception {        setCumulativeTestPoints(new double[] {-2, 0});        setCumulativeTestValues(new double[] {0, 0});        verifyCumulativeProbabilities();    }    public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0, 1});        setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }        public void testDfAccessors() {        FDistribution distribution = (FDistribution) getDistribution();        assertEquals(5d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);        distribution.setNumeratorDegreesOfFreedom(4d);        assertEquals(4d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);        assertEquals(6d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);        distribution.setDenominatorDegreesOfFreedom(4d);        assertEquals(4d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);        try {            distribution.setNumeratorDegreesOfFreedom(0d);            fail("Expecting IllegalArgumentException for df = 0");        } catch (IllegalArgumentException ex) {            // expected        }        try {            distribution.setDenominatorDegreesOfFreedom(0d);            fail("Expecting IllegalArgumentException for df = 0");        } catch (IllegalArgumentException ex) {            // expected        }    }     public void testLargeDegreesOfFreedom() throws Exception {        org.apache.commons.math.distribution.FDistributionImpl fd =            new org.apache.commons.math.distribution.FDistributionImpl(                100000., 100000.);        double p = fd.cumulativeProbability(.999);        double x = fd.inverseCumulativeProbability(p);        assertEquals(.999, x, 1.0e-5);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for GammaDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class GammaDistributionTest extends ContinuousDistributionAbstractTest {        /**     * Constructor for GammaDistributionTest.     * @param name     */    public GammaDistributionTest(String name) {        super(name);    }        //-------------- Implementations for abstract methods -----------------------        /** Creates the default continuous distribution instance to use in tests. */    public ContinuousDistribution makeDistribution() {        return DistributionFactory.newInstance().createGammaDistribution(4d, 2d);    }           /** Creates the default cumulative probability distribution test input values */    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 1.8.1 (linux version)        return new double[] {0.8571048, 1.646497, 2.179731, 2.732637,            3.489539, 26.12448, 20.09024, 17.53455,            15.50731, 13.36157};    }        /** Creates the default cumulative probability density test expected values */    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d};     }        // --------------------- Override tolerance  --------------    protected void setup() throws Exception {        super.setUp();        setTolerance(1E-6);    }    //---------------------------- Additional test cases -------------------------    public void testParameterAccessors() {        GammaDistribution distribution = (GammaDistribution) getDistribution();        assertEquals(4d, distribution.getAlpha(), 0);        distribution.setAlpha(3d);        assertEquals(3d, distribution.getAlpha(), 0);        assertEquals(2d, distribution.getBeta(), 0);        distribution.setBeta(4d);        assertEquals(4d, distribution.getBeta(), 0);        try {            distribution.setAlpha(0d);            fail("Expecting IllegalArgumentException for alpha = 0");        } catch (IllegalArgumentException ex) {            // expected        }        try {            distribution.setBeta(0d);            fail("Expecting IllegalArgumentException for beta = 0");        } catch (IllegalArgumentException ex) {            // expected        }    }         public void testProbabilities() throws Exception {        testProbability(-1.000, 4.0, 2.0, .0000);        testProbability(15.501, 4.0, 2.0, .9499);        testProbability(0.504, 4.0, 1.0, .0018);        testProbability(10.011, 1.0, 2.0, .9933);        testProbability(5.000, 2.0, 2.0, .7127);    }    public void testValues() throws Exception {        testValue(15.501, 4.0, 2.0, .9499);        testValue(0.504, 4.0, 1.0, .0018);        testValue(10.011, 1.0, 2.0, .9933);        testValue(5.000, 2.0, 2.0, .7127);    }    private void testProbability(double x, double a, double b, double expected) throws Exception {        DistributionFactory factory = DistributionFactory.newInstance();        GammaDistribution distribution = factory.createGammaDistribution( a, b );        double actual = distribution.cumulativeProbability(x);        assertEquals("probability for " + x, expected, actual, 10e-4);    }    private void testValue(double expected, double a, double b, double p) throws Exception {        DistributionFactory factory = DistributionFactory.newInstance();        GammaDistribution distribution = factory.createGammaDistribution( a, b );        double actual = distribution.inverseCumulativeProbability(p);        assertEquals("critical value for " + p, expected, actual, 10e-4);    }        public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0, 1});        setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for NormalDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class NormalDistributionTest extends ContinuousDistributionAbstractTest  {        /**     * Constructor for NormalDistributionTest.     * @param arg0     */    public NormalDistributionTest(String arg0) {        super(arg0);    }        //-------------- Implementations for abstract methods -----------------------        /** Creates the default continuous distribution instance to use in tests. */    public ContinuousDistribution makeDistribution() {        return DistributionFactory.newInstance().createNormalDistribution(2.1, 1.4);    }           /** Creates the default cumulative probability distribution test input values */    public double[] makeCumulativeTestPoints() {        // quantiles computed using R         return new double[] {-2.226325d, -1.156887d, -0.6439496d, -0.2027951d, 0.3058278d,                 6.426325d, 5.356887d, 4.84395d, 4.402795d, 3.894172d};    }        /** Creates the default cumulative probability density test expected values */    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d};     }        // --------------------- Override tolerance  --------------    protected void setup() throws Exception {        super.setUp();        setTolerance(1E-6);    }        //---------------------------- Additional test cases -------------------------        private void verifyQuantiles() throws Exception {        NormalDistribution distribution = (NormalDistribution) getDistribution();        double mu = distribution.getMean();        double sigma = distribution.getStandardDeviation();        setCumulativeTestPoints( new double[] {mu - 2 *sigma, mu - sigma,                 mu, mu + sigma, mu +2 * sigma,  mu +3 * sigma, mu + 4 * sigma,                mu + 5 * sigma});        // Quantiles computed using R (same as Mathematica)        setCumulativeTestValues(new double[] {0.02275013, 0.1586553, 0.5, 0.8413447,                 0.9772499, 0.9986501, 0.9999683,  0.9999997});        verifyCumulativeProbabilities();           }        public void testQuantiles() throws Exception {        verifyQuantiles();        setDistribution(DistributionFactory.newInstance().createNormalDistribution(0, 1));        verifyQuantiles();        setDistribution(DistributionFactory.newInstance().createNormalDistribution(0, 0.1));        verifyQuantiles();    }        public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0, 1});        setInverseCumulativeTestValues(                new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }        public void testGetMean() {        NormalDistribution distribution = (NormalDistribution) getDistribution();        assertEquals(2.1, distribution.getMean(), 0);    }        public void testSetMean() throws Exception {        double mu = Math.random();        NormalDistribution distribution = (NormalDistribution) getDistribution();        distribution.setMean(mu);        verifyQuantiles();    }        public void testGetStandardDeviation() {        NormalDistribution distribution = (NormalDistribution) getDistribution();        assertEquals(1.4, distribution.getStandardDeviation(), 0);      }        public void testSetStandardDeviation() throws Exception {        double sigma = 0.1d + Math.random();        NormalDistribution distribution = (NormalDistribution) getDistribution();        distribution.setStandardDeviation(sigma);        assertEquals(sigma, distribution.getStandardDeviation(), 0);        verifyQuantiles();        try {            distribution.setStandardDeviation(0);            fail("Expecting IllegalArgumentException for sd = 0");        } catch (IllegalArgumentException ex) {            // Expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for ExponentialDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class ExponentialDistributionTest extends ContinuousDistributionAbstractTest {    /**     * Constructor for ExponentialDistributionTest.     * @param name     */    public ExponentialDistributionTest(String name) {        super(name);    }    //-------------- Implementations for abstract methods -----------------------        /** Creates the default continuous distribution instance to use in tests. */    public ContinuousDistribution makeDistribution() {        return DistributionFactory.newInstance().createExponentialDistribution(5.0);    }           /** Creates the default cumulative probability distribution test input values */    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 1.8.1 (linux version)        return new double[] {0.005002502d, 0.05025168d, 0.1265890d, 0.2564665d, 0.5268026d,                 34.53878d, 23.02585d, 18.44440d, 14.97866d, 11.51293d};    }        /** Creates the default cumulative probability density test expected values */    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d};     }        //------------ Additional tests -------------------------------------------     public void testCumulativeProbabilityExtremes() throws Exception {        setCumulativeTestPoints(new double[] {-2, 0});        setCumulativeTestValues(new double[] {0, 0});        verifyCumulativeProbabilities();    }    public void testInverseCumulativeProbabilityExtremes() throws Exception {         setInverseCumulativeTestPoints(new double[] {0, 1});         setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});         verifyInverseCumulativeProbabilities();    }    public void testCumulativeProbability2() throws Exception {        double actual = getDistribution().cumulativeProbability(0.25, 0.75);        assertEquals(0.0905214, actual, 10e-4);    }        public void testMeanAccessors() {        ExponentialDistribution distribution = (ExponentialDistribution) getDistribution();        assertEquals(5d, distribution.getMean(), Double.MIN_VALUE);        distribution.setMean(2d);        assertEquals(2d, distribution.getMean(), Double.MIN_VALUE);        try {            distribution.setMean(0);            fail("Expecting IllegalArgumentException for 0 mean");        } catch (IllegalArgumentException ex) {            // expected        }    }   }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for BinomialDistribution. * Extends IntegerDistributionAbstractTest.  See class javadoc for * IntegerDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class BinomialDistributionTest extends IntegerDistributionAbstractTest {        /**     * Constructor for BinomialDistributionTest.     * @param name     */    public BinomialDistributionTest(String name) {        super(name);    }        //-------------- Implementations for abstract methods -----------------------        /** Creates the default discrete distribution instance to use in tests. */    public IntegerDistribution makeDistribution() {        return DistributionFactory.newInstance().createBinomialDistribution(10,0.70);    }        /** Creates the default probability density test input values */    public int[] makeDensityTestPoints() {        return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};    }        /** Creates the default probability density test expected values */    public double[] makeDensityTestValues() {        return new double[] {0d, 0.0000d, 0.0001d, 0.0014d, 0.0090d, 0.0368d, 0.1029d,                 0.2001d, 0.2668d, 0.2335d, 0.1211d, 0.0282d, 0d};    }        /** Creates the default cumulative probability density test input values */    public int[] makeCumulativeTestPoints() {        return makeDensityTestPoints();    }        /** Creates the default cumulative probability density test expected values */    public double[] makeCumulativeTestValues() {        return new double[] {0d, 0.0000d, 0.0001d, 0.0016d, 0.0106d, 0.0473d,                0.1503d, 0.3504d, 0.6172d, 0.8507d, 0.9718d, 1d, 1d};        }        /** Creates the default inverse cumulative probability test input values */    public double[] makeInverseCumulativeTestPoints() {        return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d,1};         }        /** Creates the default inverse cumulative probability density test expected values */    public int[] makeInverseCumulativeTestValues() {        return new int[] {-1, 1, 2, 3, 4, 4, 9, 9, 9, 8, 8, Integer.MAX_VALUE};    }    //----------------- Additional test cases ---------------------------------       /** Test degenerate case p = 0   */    public void testDegenerate0() throws Exception {        setDistribution(DistributionFactory.newInstance().createBinomialDistribution(5,0.0d));        setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });        setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 10, 11});        setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {-1, -1});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();         }        /** Test degenerate case p = 1   */    public void testDegenerate1() throws Exception {        setDistribution(DistributionFactory.newInstance().createBinomialDistribution(5,1.0d));        setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });        setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10});        setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 1d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {4, 4});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();         }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.MathException;/** * <code>PoissonDistributionTest</code> *  * @version $Revision$ $Date$ */public class PoissonDistributionTest extends IntegerDistributionAbstractTest {    /**     * Poisson parameter value for the test distribution.     */    private static final double DEFAULT_TEST_POISSON_PARAMETER = 4.0;    /**     * Constructor.     * @param name     */    public PoissonDistributionTest(String name) {        super(name);        setTolerance(1e-12);    }    /**      * Creates the default discrete distribution instance to use in tests.      */    public IntegerDistribution makeDistribution() {        return DistributionFactory.newInstance().createPoissonDistribution            (DEFAULT_TEST_POISSON_PARAMETER);      }    /**      * Creates the default probability density test input values.     */    public int[] makeDensityTestPoints() {        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};    }    /**     * Creates the default probability density test expected values.     * These and all other test values are generated by R, version 1.8.1     */    public double[] makeDensityTestValues() {        return new double[] { 0d, 0.0183156388887d,  0.073262555555d,                0.14652511111d, 0.195366814813d, 0.195366814813,                 0.156293451851d, 0.00529247667642d, 8.27746364655e-09};    }    /**     * Creates the default cumulative probability density test input values.     */    public int[] makeCumulativeTestPoints() {        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20 };    }    /**     * Creates the default cumulative probability density test expected values.     */    public double[] makeCumulativeTestValues() {        return new double[] { 0d,  0.0183156388887d, 0.0915781944437d,                 0.238103305554d, 0.433470120367d, 0.62883693518,                0.78513038703d,  0.99716023388d, 0.999999998077 };    }    /**      * Creates the default inverse cumulative probability test input values.     * Increased 3rd and 7th values slightly as computed cumulative     * probabilities for corresponding values exceeds the target value (still      * within tolerance).     */    public double[] makeInverseCumulativeTestPoints() {        return new double[] { 0d,  0.018315638889d, 0.0915781944437d,                 0.238103305554d, 0.433470120367d, 0.62883693518,                0.78513038704d,  0.99716023388d, 0.999999998077 };    }    /**     * Creates the default inverse cumulative probability density test expected values.     */    public int[] makeInverseCumulativeTestValues() {        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};    }    /**     * Test the normal approximation of the Poisson distribution by     * calculating P(90 &le; X &le; 110) for X = Po(100) and     * P(9900 &le; X &le; 10200) for X  = Po(10000)     */    public void testNormalApproximateProbability() throws Exception {        PoissonDistribution dist = DistributionFactory.newInstance().createPoissonDistribution(100);        double result = dist.normalApproximateProbability(110)                - dist.normalApproximateProbability(89);        assertEquals(0.706281887248, result, 1E-10);        dist.setMean(10000);        result = dist.normalApproximateProbability(10200)        - dist.normalApproximateProbability(9899);        assertEquals(0.820070051552, result, 1E-10);    }    /**     * Test the degenerate cases of a 0.0 and 1.0 inverse cumulative probability.     * @throws Exception     */    public void testDegenerateInverseCumulativeProbability() throws Exception {        PoissonDistribution dist = DistributionFactory.newInstance().createPoissonDistribution(DEFAULT_TEST_POISSON_PARAMETER);        assertEquals(Integer.MAX_VALUE, dist.inverseCumulativeProbability(1.0d));        assertEquals(-1, dist.inverseCumulativeProbability(0d));    }        public void testMean() {        PoissonDistribution dist = DistributionFactory.newInstance().createPoissonDistribution(DEFAULT_TEST_POISSON_PARAMETER);        try {            dist.setMean(-1);            fail("negative mean.  IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }                dist.setMean(10.0);        assertEquals(10.0, dist.getMean(), 0.0);    }        public void testLargeMeanCumulativeProbability() {        PoissonDistribution dist = DistributionFactory.newInstance().createPoissonDistribution(1.0);        double mean = 1.0;        while (mean <= 10000000.0) {            dist.setMean(mean);                        double x = mean * 2.0;            double dx = x / 10.0;            while (x >= 0) {                try {                    dist.cumulativeProbability(x);                } catch (MathException ex) {                    fail("mean of " + mean + " and x of " + x + " caused " + ex.getMessage());                }                x -= dx;            }                        mean *= 10.0;        }    }        public void testLargeMeanInverseCumulativeProbability() {        PoissonDistribution dist = DistributionFactory.newInstance().createPoissonDistribution(1.0);        double mean = 1.0;        while (mean <= 10000000.0) {            dist.setMean(mean);                        double p = 0.1;            double dp = p;            while (p < 1.0) {                try {                    dist.inverseCumulativeProbability(p);                } catch (MathException ex) {                    fail("mean of " + mean + " and p of " + p + " caused " + ex.getMessage());                }                p += dp;            }                        mean *= 10.0;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for ChiSquareDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class ChiSquareDistributionTest extends ContinuousDistributionAbstractTest {        /**     * Constructor for ChiSquareDistributionTest.     * @param name     */    public ChiSquareDistributionTest(String name) {        super(name);    }        //-------------- Implementations for abstract methods -----------------------        /** Creates the default continuous distribution instance to use in tests. */    public ContinuousDistribution makeDistribution() {        return DistributionFactory.newInstance().createChiSquareDistribution(5.0);    }           /** Creates the default cumulative probability distribution test input values */    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 1.8.1 (linux version)        return new double[] {0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d,                 20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d};    }        /** Creates the default cumulative probability density test expected values */    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d};     }        /** Creates the default inverse cumulative probability test input values */    public double[] makeInverseCumulativeTestPoints() {        return new double[] {0, 0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d, 1};         }        /** Creates the default inverse cumulative probability density test expected values */    public double[] makeInverseCumulativeTestValues() {        return new double[] {0, 0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d,                 20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d,                 Double.POSITIVE_INFINITY};    }     // --------------------- Override tolerance  --------------    protected void setup() throws Exception {        super.setUp();        setTolerance(1E-6);    } //---------------------------- Additional test cases -------------------------        public void testSmallDf() throws Exception {        setDistribution(DistributionFactory.newInstance().createChiSquareDistribution(0.1d));        setTolerance(1E-4);        // quantiles computed using R version 1.8.1 (linux version)        setCumulativeTestPoints(new double[] {1.168926E-60, 1.168926E-40, 1.063132E-32,                 1.144775E-26, 1.168926E-20, 5.472917, 2.175255, 1.13438,                 0.5318646, 0.1526342});        setInverseCumulativeTestValues(getCumulativeTestPoints());        setInverseCumulativeTestPoints(getCumulativeTestValues());        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }        public void testDfAccessors() {        ChiSquaredDistribution distribution = (ChiSquaredDistribution) getDistribution();        assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);        distribution.setDegreesOfFreedom(4d);        assertEquals(4d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);        try {            distribution.setDegreesOfFreedom(0d);            fail("Expecting IllegalArgumentException for df = 0");        } catch (IllegalArgumentException ex) {            // expected        }    }     }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;/** * Abstract base class for {@link ContinuousDistribution} tests. * <p> * To create a concrete test class for a continuous distribution * implementation, first implement makeDistribution() to return a distribution * instance to use in tests. Then implement each of the test data generation * methods below.  In each case, the test points and test values arrays * returned represent parallel arrays of inputs and expected values for the * distribution returned by makeDistribution().  Default implementations * are provided for the makeInverseXxx methods that just invert the mapping * defined by the arrays returned by the makeCumulativeXxx methods. * <p> * makeCumulativeTestPoints() -- arguments used to test cumulative probabilities * makeCumulativeTestValues() -- expected cumulative probabilites * makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf * makeInverseCumulativeTestValues() -- expected inverse cdf values * <p> * To implement additional test cases with different distribution instances and * test data, use the setXxx methods for the instance data in test cases and * call the verifyXxx methods to verify results.  * <p> * Error tolerance can be overriden by implementing getTolerance(). * <p> * Test data should be validated against reference tables or other packages * where possible, and the source of the reference data and/or validation * should be documented in the test cases.  A framework for validating * distribution data against R is included in the /src/test/R source tree. * <p> * See {@link NormalDistributionTest} and {@link ChiSquareDistributionTest} * for examples. *  * @version $Revision$ $Date$ */public abstract class ContinuousDistributionAbstractTest extends TestCase {    //-------------------- Private test instance data -------------------------    /**  Distribution instance used to perform tests */    private ContinuousDistribution distribution;        /** Tolerance used in comparing expected and returned values */    private double tolerance = 1E-4;        /** Arguments used to test cumulative probability density calculations */    private double[] cumulativeTestPoints;        /** Values used to test cumulative probability density calculations */    private double[] cumulativeTestValues;        /** Arguments used to test inverse cumulative probability density calculations */    private double[] inverseCumulativeTestPoints;        /** Values used to test inverse cumulative probability density calculations */    private double[] inverseCumulativeTestValues;        //-------------------------------------------------------------------------        /**     * Constructor for ContinuousDistributionAbstractTest.     * @param name     */    public ContinuousDistributionAbstractTest(String name) {        super(name);    }        //-------------------- Abstract methods -----------------------------------        /** Creates the default continuous distribution instance to use in tests. */    public abstract ContinuousDistribution makeDistribution();        /** Creates the default cumulative probability density test input values */    public abstract double[] makeCumulativeTestPoints();        /** Creates the default cumulative probability density test expected values */    public abstract double[] makeCumulativeTestValues();        //---- Default implementations of inverse test data generation methods ----        /** Creates the default inverse cumulative probability test input values */    public double[] makeInverseCumulativeTestPoints() {        return makeCumulativeTestValues();    }        /** Creates the default inverse cumulative probability density test expected values */    public double[] makeInverseCumulativeTestValues() {        return makeCumulativeTestPoints();    }        //-------------------- Setup / tear down ----------------------------------         /**     * Setup sets all test instance data to default values      */    protected void setUp() throws Exception {        super.setUp();        distribution = makeDistribution();        cumulativeTestPoints = makeCumulativeTestPoints();        cumulativeTestValues = makeCumulativeTestValues();        inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();        inverseCumulativeTestValues = makeInverseCumulativeTestValues();       }        /**     * Cleans up test instance data     */    protected void tearDown() throws Exception {              super.tearDown();        distribution = null;        cumulativeTestPoints = null;        cumulativeTestValues = null;        inverseCumulativeTestPoints = null;        inverseCumulativeTestValues = null;       }        //-------------------- Verification methods -------------------------------        /**     * Verifies that cumulative probability density calculations match expected values     * using current test instance data     */       protected void verifyCumulativeProbabilities() throws Exception {        for (int i = 0; i < cumulativeTestPoints.length; i++) {            TestUtils.assertEquals("Incorrect cumulative probability value returned for "                 + cumulativeTestPoints[i], cumulativeTestValues[i],                 distribution.cumulativeProbability(cumulativeTestPoints[i]),                 getTolerance());        }               }        /**     * Verifies that inverse cumulative probability density calculations match expected values     * using current test instance data     */    protected void verifyInverseCumulativeProbabilities() throws Exception {        for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {            TestUtils.assertEquals("Incorrect inverse cumulative probability value returned for "                 + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i],                  distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]),                  getTolerance());        }               }        //------------------------ Default test cases -----------------------------        /**     * Verifies that cumulative probability density calculations match expected values     * using default test instance data     */    public void testCumulativeProbabilities() throws Exception {        verifyCumulativeProbabilities();          }        /**     * Verifies that inverse cumulative probability density calculations match expected values     * using default test instance data     */    public void testInverseCumulativeProbabilities() throws Exception {        verifyInverseCumulativeProbabilities();           }        /**     * Verifies that probability computations are consistent     */    public void testConsistency() throws Exception {        for (int i=1; i < cumulativeTestPoints.length; i++) {                        // check that cdf(x, x) = 0            TestUtils.assertEquals(0d,                distribution.cumulativeProbability                 (cumulativeTestPoints[i], cumulativeTestPoints[i]), tolerance);                        // check that P(a < X < b) = P(X < b) - P(X < a)            double upper = Math.max(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);            double lower = Math.min(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);            double diff = distribution.cumulativeProbability(upper) -                 distribution.cumulativeProbability(lower);            double direct = distribution.cumulativeProbability(lower, upper);            TestUtils.assertEquals("Inconsistent cumulative probabilities for ("                     + lower + "," + upper + ")", diff, direct, tolerance);        }    }        /**     * Verifies that illegal arguments are correctly handled     */    public void testIllegalArguments() throws Exception {        try {            distribution.cumulativeProbability(1, 0);            fail("Expecting IllegalArgumentException for bad cumulativeProbability interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            distribution.inverseCumulativeProbability(-1);            fail("Expecting IllegalArgumentException for p = -1");        } catch (IllegalArgumentException ex) {            // expected        }        try {            distribution.inverseCumulativeProbability(2);            fail("Expecting IllegalArgumentException for p = 2");        } catch (IllegalArgumentException ex) {            // expected        }           }        //------------------ Getters / Setters for test instance data -----------    /**     * @return Returns the cumulativeTestPoints.     */    protected double[] getCumulativeTestPoints() {        return cumulativeTestPoints;    }    /**     * @param cumulativeTestPoints The cumulativeTestPoints to set.     */    protected void setCumulativeTestPoints(double[] cumulativeTestPoints) {        this.cumulativeTestPoints = cumulativeTestPoints;    }    /**     * @return Returns the cumulativeTestValues.     */    protected double[] getCumulativeTestValues() {        return cumulativeTestValues;    }    /**     * @param cumulativeTestValues The cumulativeTestValues to set.     */    protected void setCumulativeTestValues(double[] cumulativeTestValues) {        this.cumulativeTestValues = cumulativeTestValues;    }    /**     * @return Returns the distribution.     */    protected ContinuousDistribution getDistribution() {        return distribution;    }    /**     * @param distribution The distribution to set.     */    protected void setDistribution(ContinuousDistribution distribution) {        this.distribution = distribution;    }    /**     * @return Returns the inverseCumulativeTestPoints.     */    protected double[] getInverseCumulativeTestPoints() {        return inverseCumulativeTestPoints;    }    /**     * @param inverseCumulativeTestPoints The inverseCumulativeTestPoints to set.     */    protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) {        this.inverseCumulativeTestPoints = inverseCumulativeTestPoints;    }    /**     * @return Returns the inverseCumulativeTestValues.     */    protected double[] getInverseCumulativeTestValues() {        return inverseCumulativeTestValues;    }    /**     * @param inverseCumulativeTestValues The inverseCumulativeTestValues to set.     */    protected void setInverseCumulativeTestValues(double[] inverseCumulativeTestValues) {        this.inverseCumulativeTestValues = inverseCumulativeTestValues;    }    /**     * @return Returns the tolerance.     */    protected double getTolerance() {        return tolerance;    }    /**     * @param tolerance The tolerance to set.     */    protected void setTolerance(double tolerance) {        this.tolerance = tolerance;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import junit.framework.Test;import junit.framework.TestSuite;import java.util.Random;/** * Test cases for the RandomAdaptor class * * @version $Revision:$ $Date$ */public class RandomAdaptorTest extends RandomDataTest {        public RandomAdaptorTest(String name) {        super(name);    }         public static Test suite() {        TestSuite suite = new TestSuite(RandomAdaptorTest.class);        suite.setName("RandomAdaptor Tests");        return suite;    }        public void testAdaptor() {        ConstantGenerator generator = new ConstantGenerator();        Random random = RandomAdaptor.createAdaptor(generator);        checkConstant(random);        RandomAdaptor randomAdaptor = new RandomAdaptor(generator);        checkConstant(randomAdaptor);     }        private void checkConstant(Random random) {        byte[] bytes = new byte[] {0};        random.nextBytes(bytes);        assertEquals(0, bytes[0]);          assertEquals(false, random.nextBoolean());        assertEquals(0, random.nextDouble(), 0);        assertEquals(0, random.nextFloat(), 0);        assertEquals(0, random.nextGaussian(), 0);        assertEquals(0, random.nextInt());        assertEquals(0, random.nextInt(1));        assertEquals(0, random.nextLong());        random.setSeed(100);        assertEquals(0, random.nextDouble(), 0);    }        /*     * "Constant" generator to test Adaptor delegation.     * "Powered by Eclipse ;-)"     *      */    private class ConstantGenerator implements RandomGenerator {                public boolean nextBoolean() {            return false;        }                public void nextBytes(byte[] bytes) {        }        public double nextDouble() {            return 0;        }        public float nextFloat() {            return 0;        }        public double nextGaussian() {            return 0;        }        public int nextInt() {            return 0;        }        public int nextInt(int n) {            return 0;        }        public long nextLong() {            return 0;        }        public void setSeed(long seed) {        }           }}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.random;import org.apache.commons.math.DimensionMismatchException;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;import org.apache.commons.math.stat.descriptive.moment.VectorialMean;import junit.framework.*;public class UncorrelatedRandomVectorGeneratorTestextends TestCase {    public UncorrelatedRandomVectorGeneratorTest(String name) {        super(name);        mean = null;        standardDeviation = null;        generator = null;    }    public void testMeanAndCorrelation() throws DimensionMismatchException {        VectorialMean meanStat = new VectorialMean(mean.length);        VectorialCovariance covStat = new VectorialCovariance(mean.length);        for (int i = 0; i < 10000; ++i) {            double[] v = generator.nextVector();            meanStat.increment(v);            covStat.increment(v);        }        double[] estimatedMean = meanStat.getResult();        double scale;        RealMatrix estimatedCorrelation = covStat.getResult();        for (int i = 0; i < estimatedMean.length; ++i) {            assertEquals(mean[i], estimatedMean[i], 0.07);            for (int j = 0; j < i; ++j) {                scale = standardDeviation[i] * standardDeviation[j];                assertEquals(0, estimatedCorrelation.getEntry(i, j) / scale, 0.03);            }            scale = standardDeviation[i] * standardDeviation[i];            assertEquals(1, estimatedCorrelation.getEntry(i, i) / scale, 0.025);        }    }    public void setUp() {        mean              = new double[] {0.0, 1.0, -3.0, 2.3};        standardDeviation = new double[] {1.0, 2.0, 10.0, 0.1};        RandomGenerator rg = new JDKRandomGenerator();        rg.setSeed(17399225432l);        generator =            new UncorrelatedRandomVectorGenerator(mean, standardDeviation,                    new GaussianRandomGenerator(rg));    }    public void tearDown() {        mean = null;        standardDeviation = null;        generator = null;    }    public static Test suite() {        return new TestSuite(UncorrelatedRandomVectorGeneratorTest.class);    }    private double[] mean;    private double[] standardDeviation;    private UncorrelatedRandomVectorGenerator generator;}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.random;import org.apache.commons.math.stat.StatUtils;import junit.framework.*;public class GaussianRandomGeneratorTestextends TestCase {    public GaussianRandomGeneratorTest(String name) {        super(name);    }    public void testMeanAndStandardDeviation() {        RandomGenerator rg = new JDKRandomGenerator();        rg.setSeed(17399225432l);        GaussianRandomGenerator generator = new GaussianRandomGenerator(rg);        double[] sample = new double[10000];        for (int i = 0; i < sample.length; ++i) {            sample[i] = generator.nextNormalizedDouble();        }        assertEquals(0.0, StatUtils.mean(sample), 0.012);        assertEquals(1.0, StatUtils.variance(sample), 0.01);    }    public static Test suite() {        return new TestSuite(GaussianRandomGeneratorTest.class);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import junit.framework.Test;import junit.framework.TestSuite;import java.security.NoSuchProviderException;import java.security.NoSuchAlgorithmException;import java.util.HashSet;import org.apache.commons.math.RetryTestCase;import org.apache.commons.math.stat.Frequency;import org.apache.commons.math.stat.inference.ChiSquareTestImpl;import org.apache.commons.math.stat.descriptive.SummaryStatistics;/** * Test cases for the RandomData class. * * @version $Revision$ $Date$ */public class RandomDataTest extends RetryTestCase {    public RandomDataTest(String name) {        super(name);        randomData = new RandomDataImpl();    }    protected long smallSampleSize = 1000;    protected double[] expected = {250,250,250,250};    protected int largeSampleSize = 10000;    private int tolerance = 50;    private String[] hex =         {"0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"};     protected RandomDataImpl randomData = null;     protected ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();        public void setUp() {     }    public static Test suite() {        TestSuite suite = new TestSuite(RandomDataTest.class);        suite.setName("RandomData Tests");        return suite;    }    /** test dispersion and failure modes for nextInt() */    public void testNextInt() {        try {            int x = randomData.nextInt(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        Frequency freq = new Frequency();        int value = 0;        for (int i=0;i<smallSampleSize;i++) {            value = randomData.nextInt(0,3);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 16.27);        }        /** test dispersion and failure modes for nextLong() */    public void testNextLong() {       try {            long x = randomData.nextLong(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }       Frequency freq = new Frequency();       long value = 0;        for (int i=0;i<smallSampleSize;i++) {            value = randomData.nextLong(0,3);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 16.27);        }        /** test dispersion and failure modes for nextSecureLong() */    public void testNextSecureLong() {        try {            long x = randomData.nextSecureLong(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        Frequency freq = new Frequency();        long value = 0;        for (int i=0;i<smallSampleSize;i++) {            value = randomData.nextSecureLong(0,3);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 16.27);        }        /** test dispersion and failure modes for nextSecureInt() */    public void testNextSecureInt() {        try {            long x = randomData.nextSecureInt(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        Frequency freq = new Frequency();        int value = 0;        for (int i=0;i<smallSampleSize;i++) {            value = randomData.nextSecureInt(0,3);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 16.27);        }        /**      * Make sure that empirical distribution of random Poisson(4)'s      * has P(X <= 5) close to actual cumulative Poisson probablity     * and that nextPoisson fails when mean is non-positive     * TODO: replace with statistical test, adding test stat to TestStatistic     */    public void testNextPoisson() {        try {            long x = randomData.nextPoisson(0);            fail("zero mean -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        Frequency f = new Frequency();        long v = 0;        for (int i = 0; i<largeSampleSize; i++) {            try {                f.addValue(randomData.nextPoisson(4.0d));            } catch (Exception ex) {                fail(ex.getMessage());            }        }        long cumFreq = f.getCount(0) + f.getCount(1) + f.getCount(2) +                         f.getCount(3) + f.getCount(4) + f.getCount(5);        long sumFreq = f.getSumFreq();        double cumPct =             new Double(cumFreq).doubleValue()/new Double(sumFreq).doubleValue();        assertEquals("cum Poisson(4)",cumPct,0.7851,0.2);        try {            long x = randomData.nextPoisson(-1);            fail("negative mean supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        try {            long x = randomData.nextPoisson(0);            fail("0 mean supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }            }        /** test dispersion and failute modes for nextHex() */    public void testNextHex() {        try {            String x = randomData.nextHexString(-1);            fail("negative length supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        try {            String x = randomData.nextHexString(0);            fail("zero length supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        String hexString = randomData.nextHexString(3);        if (hexString.length() != 3) {                fail("incorrect length for generated string");        }        hexString = randomData.nextHexString(1);        if (hexString.length() != 1) {                fail("incorrect length for generated string");        }        try {            hexString = randomData.nextHexString(0);            fail("zero length requested -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        if (hexString.length() != 1) {                fail("incorrect length for generated string");        }              Frequency f = new Frequency();        for (int i = 0; i < smallSampleSize; i++) {            hexString = randomData.nextHexString(100);            if (hexString.length() != 100) {                fail("incorrect length for generated string");            }            for (int j = 0; j < hexString.length(); j++) {                f.addValue(hexString.substring(j,j+1));            }        }        double[] expected = new double[16];        long[] observed = new long[16];        for (int i = 0; i < 16; i++) {            expected[i] = (double)smallSampleSize*100/(double)16;            observed[i] = f.getCount(hex[i]);        }        /* Use ChiSquare dist with df = 16-1 = 15, alpha = .001         * Change to 30.58 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 37.70);        }        /** test dispersion and failute modes for nextHex() */    public void testNextSecureHex() {        try {            String x = randomData.nextSecureHexString(-1);            fail("negative length -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        try {            String x = randomData.nextSecureHexString(0);            fail("zero length -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        String hexString = randomData.nextSecureHexString(3);        if (hexString.length() != 3) {                fail("incorrect length for generated string");        }        hexString = randomData.nextSecureHexString(1);        if (hexString.length() != 1) {                fail("incorrect length for generated string");        }        try {            hexString = randomData.nextSecureHexString(0);            fail("zero length requested -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        if (hexString.length() != 1) {                fail("incorrect length for generated string");        }              Frequency f = new Frequency();        for (int i = 0; i < smallSampleSize; i++) {            hexString = randomData.nextSecureHexString(100);            if (hexString.length() != 100) {                fail("incorrect length for generated string");            }            for (int j = 0; j < hexString.length(); j++) {                f.addValue(hexString.substring(j,j+1));            }        }        double[] expected = new double[16];        long[] observed = new long[16];        for (int i = 0; i < 16; i++) {            expected[i] = (double)smallSampleSize*100/(double)16;            observed[i] = f.getCount(hex[i]);        }        /* Use ChiSquare dist with df = 16-1 = 15, alpha = .001         * Change to 30.58 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 37.70);        }        /** test failure modes and dispersion of nextUniform() */      public void testNextUniform() {            try {            double x = randomData.nextUniform(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = randomData.nextUniform(3,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        double[] expected = {500,500};        long[] observed = {0,0};        double lower = -1d;        double upper = 20d;        double midpoint = (lower + upper)/2d;        double result = 0;        for (int i = 0; i < 1000; i++) {            result = randomData.nextUniform(lower,upper);            if ((result == lower) || (result == upper)) {                fail("generated value equal to an endpoint: " + result);            }             if (result < midpoint) {                observed[0]++;            } else {                observed[1]++;            }        }        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001         * Change to 6.64 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 10.83);      }        /** test failure modes and distribution of nextGaussian() */      public void testNextGaussian() {         try {            double x = randomData.nextGaussian(0,0);            fail("zero sigma -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        SummaryStatistics u = SummaryStatistics.newInstance();        for (int i = 0; i<largeSampleSize; i++) {            u.addValue(randomData.nextGaussian(0,1));        }        double xbar = u.getMean();        double s = u.getStandardDeviation();        double n = (double) u.getN();         /* t-test at .001-level TODO: replace with externalized t-test, with         * test statistic defined in TestStatistic         */        assertTrue(Math.abs(xbar)/(s/Math.sqrt(n))< 3.29);    }        /** test failure modes and distribution of nextExponential() */      public void testNextExponential() {        try {            double x = randomData.nextExponential(-1);            fail("negative mean -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        assertEquals("0 mean", 0,randomData.nextExponential(0),10E-8);         long cumFreq = 0;        double v = 0;        for (int i = 0; i < largeSampleSize; i++) {            v = randomData.nextExponential(1);            assertTrue("exponential deviate postive", v > 0);            if (v < 2) cumFreq++;        }        /* TODO: Replace with a statistical test, with statistic added to         * TestStatistic.  Check below compares observed cumulative distribution         * evaluated at 2 with exponential CDF          */        assertEquals("exponential cumulative distribution",            (double)cumFreq/(double)largeSampleSize,0.8646647167633873,.2);    }         /** test reseeding, algorithm/provider games */    public void testConfig() throws NoSuchProviderException,       NoSuchAlgorithmException {        randomData.reSeed(1000);        double v = randomData.nextUniform(0,1);        randomData.reSeed();        assertTrue("different seeds",             Math.abs(v - randomData.nextUniform(0,1)) > 10E-12);        randomData.reSeed(1000);        assertEquals("same seeds",v,randomData.nextUniform(0,1),10E-12);        randomData.reSeedSecure(1000);        String hex = randomData.nextSecureHexString(40);        randomData.reSeedSecure();        assertTrue("different seeds",            !hex.equals(randomData.nextSecureHexString(40)));        randomData.reSeedSecure(1000);        assertTrue("same seeds",            !hex.equals(randomData.nextSecureHexString(40)));                 /* remove this test back soon,         * since it takes about 4 seconds         try {            randomData.setSecureAlgorithm("SHA1PRNG","SUN");        } catch (NoSuchProviderException ex) {            ;        }        assertTrue("different seeds",            !hex.equals(randomData.nextSecureHexString(40)));        try {            randomData.setSecureAlgorithm("NOSUCHTHING","SUN");            fail("expecting NoSuchAlgorithmException");        } catch (NoSuchProviderException ex) {            ;        } catch (NoSuchAlgorithmException ex) {            ;        }                try {            randomData.setSecureAlgorithm("SHA1PRNG","NOSUCHPROVIDER");            fail("expecting NoSuchProviderException");        } catch (NoSuchProviderException ex) {            ;        }         */                // test reseeding without first using the generators        RandomDataImpl rd = new RandomDataImpl();        rd.reSeed(100);        double ret = rd.nextLong(1,2);        RandomDataImpl rd2 = new RandomDataImpl();        rd2.reSeedSecure(2000);        ret = rd2.nextSecureLong(1,2);        rd = new RandomDataImpl();        rd.reSeed();        ret = rd.nextLong(1,2);        rd2 = new RandomDataImpl();        rd2.reSeedSecure();        ret = rd2.nextSecureLong(1,2);    }        /** tests for nextSample() sampling from Collection */    public void testNextSample() {       Object[][] c = {{"0","1"},{"0","2"},{"0","3"},{"0","4"},{"1","2"},                        {"1","3"},{"1","4"},{"2","3"},{"2","4"},{"3","4"}};       long[] observed = {0,0,0,0,0,0,0,0,0,0};       double[] expected = {100,100,100,100,100,100,100,100,100,100};              HashSet cPop = new HashSet();  //{0,1,2,3,4}       for (int i = 0; i < 5; i++) {           cPop.add(Integer.toString(i));       }              Object[] sets = new Object[10]; // 2-sets from 5       for (int i = 0; i < 10; i ++) {           HashSet hs = new HashSet();           hs.add(c[i][0]);           hs.add(c[i][1]);           sets[i] = hs;       }              for (int i = 0; i < 1000; i ++) {           Object[] cSamp = randomData.nextSample(cPop,2);           observed[findSample(sets,cSamp)]++;       }               /* Use ChiSquare dist with df = 10-1 = 9, alpha = .001         * Change to 21.67 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 27.88);                // Make sure sample of size = size of collection returns same collection       HashSet hs = new HashSet();       hs.add("one");       Object[] one = randomData.nextSample(hs,1);       String oneString = (String) one[0];       if ((one.length != 1) || !oneString.equals("one")){           fail("bad sample for set size = 1, sample size = 1");       }              // Make sure we fail for sample size > collection size       try {           one = randomData.nextSample(hs,2);           fail("sample size > set size, expecting IllegalArgumentException");       } catch (IllegalArgumentException ex) {           ;       }              // Make sure we fail for empty collection       try {           hs = new HashSet();           one = randomData.nextSample(hs,0);           fail("n = k = 0, expecting IllegalArgumentException");       } catch (IllegalArgumentException ex) {           ;       }    }        private int findSample(Object[] u, Object[] samp) {        int result = -1;        for (int i = 0; i < u.length; i++) {            HashSet set = (HashSet) u[i];            HashSet sampSet = new HashSet();            for (int j = 0; j < samp.length; j++) {                sampSet.add(samp[j]);            }            if (set.equals(sampSet)) {                                return i;           }        }        fail("sample not found:{" + samp[0] + "," + samp[1] + "}");        return -1;    }        /** tests for nextPermutation */    public void testNextPermutation() {        int[][] p = {{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};        long[] observed = {0,0,0,0,0,0};        double[] expected = {100,100,100,100,100,100};                for (int i = 0; i < 600; i++) {            int[] perm = randomData.nextPermutation(3,3);            observed[findPerm(p,perm)]++;        }                  /* Use ChiSquare dist with df = 6-1 = 5, alpha = .001         * Change to 15.09 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected,observed) < 20.52);                 // Check size = 1 boundary case        int[] perm = randomData.nextPermutation(1,1);        if ((perm.length != 1) || (perm[0] != 0)){            fail("bad permutation for n = 1, sample k = 1");                        // Make sure we fail for k size > n             try {                perm = randomData.nextPermutation(2,3);                fail("permutation k > n, expecting IllegalArgumentException");            } catch (IllegalArgumentException ex) {                ;            }                        // Make sure we fail for n = 0            try {                perm = randomData.nextPermutation(0,0);                fail("permutation k = n = 0, expecting IllegalArgumentException");            } catch (IllegalArgumentException ex) {                ;            }                       }           }        private int findPerm(int[][] p, int[] samp) {        int result = -1;        for (int i = 0; i < p.length; i++) {            boolean good = true;            for (int j = 0; j < samp.length; j++) {                if (samp[j] != p[i][j]) {                    good = false;                }            }            if (good)  {                return i;            }        }                fail("permutation not found");        return -1;    }   }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import java.util.Random;/** * Dummy AbstractRandomGenerator concrete subclass that just wraps a  * java.util.Random instance.  Used by AbstractRandomGeneratorTest to test * default implementations in AbstractRandomGenerator. * * @version $Revision:$ $Date$ */public class TestRandomGenerator extends AbstractRandomGenerator {    private Random random = new Random();        public void setSeed(long seed) {       clear();       random.setSeed(seed);    }        public double nextDouble() {        return random.nextDouble();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.Frequency; /** * Test cases for the AbstractRandomGenerator class * * @version $Revision:$ $Date$ */public class AbstractRandomGeneratorTest extends RandomDataTest {        protected TestRandomGenerator testGenerator = new TestRandomGenerator();        public AbstractRandomGeneratorTest(String name) {        super(name);        randomData = new RandomDataImpl(testGenerator);    }         public static Test suite() {        TestSuite suite = new TestSuite(AbstractRandomGeneratorTest.class);        suite.setName("AbstractRandomGenerator Tests");        return suite;    }        public void testNextInt() {        try {            int x = testGenerator.nextInt(-1);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        Frequency freq = new Frequency();        int value = 0;        for (int i=0; i<smallSampleSize; i++) {            value = testGenerator.nextInt(4);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected,observed) < 16.27);        }        public void testNextLong() {        long q1 = Long.MAX_VALUE/4;        long q2 = 2 *  q1;        long q3 = 3 * q1;                Frequency freq = new Frequency();        long val = 0;        int value = 0;        for (int i=0; i<smallSampleSize; i++) {            val = testGenerator.nextLong();            if (val < q1) {                value = 0;            } else if (val < q2) {                value = 1;            } else if (val < q3) {                value = 2;            } else {                value = 3;            }            freq.addValue(value);          }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected,observed) < 16.27);        }        public void testNextBoolean() {        long halfSampleSize = smallSampleSize / 2;         double[] expected = {halfSampleSize, halfSampleSize};        long[] observed = new long[2];        for (int i=0; i<smallSampleSize; i++) {            if (testGenerator.nextBoolean()) {                observed[0]++;            } else {                observed[1]++;            }        }        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001         * Change to 6.635 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected,observed) < 10.828);        }        public void testNextFloat() {        Frequency freq = new Frequency();        float val = 0;        int value = 0;        for (int i=0; i<smallSampleSize; i++) {            val = testGenerator.nextFloat();            if (val < 0.25) {                value = 0;            } else if (val < 0.5) {                value = 1;            } else if (val < 0.75) {                value = 2;            } else {                value = 3;            }            freq.addValue(value);          }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected,observed) < 16.27);        }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import junit.framework.Test;import junit.framework.TestSuite;import java.net.URL;import org.apache.commons.math.RetryTestCase;import org.apache.commons.math.stat.descriptive.SummaryStatistics; /** * Test cases for the ValueServer class. * * @version $Revision$ $Date$ */public final class ValueServerTest extends RetryTestCase {    private ValueServer vs = new ValueServer();        public ValueServerTest(String name) {        super(name);    }    public void setUp() {        vs.setMode(ValueServer.DIGEST_MODE);        try {            URL url = getClass().getResource("testData.txt");            vs.setValuesFileURL(url);         } catch (Exception ex) {            fail("malformed test URL");        }    }    public static Test suite() {        TestSuite suite = new TestSuite(ValueServerTest.class);        suite.setName("ValueServer Tests");        return suite;    }       /**       * Generate 1000 random values and make sure they look OK.<br>      * Note that there is a non-zero (but very small) probability that      * these tests will fail even if the code is working as designed.      */    public void testNextDigest() throws Exception{        double next = 0.0;        double tolerance = 0.1;        vs.computeDistribution();        assertTrue("empirical distribution property",             vs.getEmpiricalDistribution() != null);        SummaryStatistics stats = SummaryStatistics.newInstance();        for (int i = 1; i < 1000; i++) {            next = vs.getNext();            stats.addValue(next);        }            assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);        assertEquals         ("std dev", 1.0173699343977738, stats.getStandardDeviation(),             tolerance);                vs.computeDistribution(500);        stats = SummaryStatistics.newInstance();        for (int i = 1; i < 1000; i++) {            next = vs.getNext();            stats.addValue(next);        }            assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);        assertEquals         ("std dev", 1.0173699343977738, stats.getStandardDeviation(),             tolerance);            }        /**      * Make sure exception thrown if digest getNext is attempted      * before loading empiricalDistribution.      */    public void testNextDigestFail() throws Exception {        try {            vs.getNext();            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {;}    }        /**     * Test ValueServer REPLAY_MODE using values in testData file.<br>      * Check that the values 1,2,1001,1002 match data file values 1 and 2.     * the sample data file.     */    public void testReplay() throws Exception {        double firstDataValue = 4.038625496201205;        double secondDataValue = 3.6485326248346936;        double tolerance = 10E-15;        double compareValue = 0.0d;        vs.setMode(ValueServer.REPLAY_MODE);        vs.resetReplayFile();        compareValue = vs.getNext();        assertEquals(compareValue,firstDataValue,tolerance);        compareValue = vs.getNext();        assertEquals(compareValue,secondDataValue,tolerance);        for (int i = 3; i < 1001; i++) {           compareValue = vs.getNext();        }        compareValue = vs.getNext();        assertEquals(compareValue,firstDataValue,tolerance);        compareValue = vs.getNext();        assertEquals(compareValue,secondDataValue,tolerance);        vs.closeReplayFile();        // make sure no NPE        vs.closeReplayFile();    }        /**      * Test other ValueServer modes     */    public void testModes() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        vs.setMu(0);        assertEquals("constant mode test",vs.getMu(),vs.getNext(),Double.MIN_VALUE);        vs.setMode(ValueServer.UNIFORM_MODE);        vs.setMu(2);        double val = vs.getNext();        assertTrue(val > 0 && val < 4);        vs.setSigma(1);        vs.setMode(ValueServer.GAUSSIAN_MODE);        val = vs.getNext();        assertTrue("gaussian value close enough to mean",            val < vs.getMu() + 100*vs.getSigma());        vs.setMode(ValueServer.EXPONENTIAL_MODE);        val = vs.getNext();        assertTrue(val > 0);        try {            vs.setMode(1000);            vs.getNext();            fail("bad mode, expecting IllegalStateException");        } catch (IllegalStateException ex) {            ;        }    }        /**     * Test fill     */    public void testFill() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        vs.setMu(2);        double[] val = new double[5];        vs.fill(val);        for (int i = 0; i < 5; i++) {            assertEquals("fill test in place",2,val[i],Double.MIN_VALUE);        }        double v2[] = vs.fill(3);        for (int i = 0; i < 3; i++) {            assertEquals("fill test in place",2,v2[i],Double.MIN_VALUE);        }    }        /**     * Test getters to make Clover happy     */    public void testProperties() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        assertEquals("mode test",ValueServer.CONSTANT_MODE,vs.getMode());        vs.setValuesFileURL("http://www.apache.org");        URL url = vs.getValuesFileURL();        assertEquals("valuesFileURL test","http://www.apache.org",url.toString());    }                          }
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.random;import org.apache.commons.math.stat.StatUtils;import junit.framework.*;public class UniformRandomGeneratorTestextends TestCase {    public UniformRandomGeneratorTest(String name) {        super(name);    }    public void testMeanAndStandardDeviation() {        RandomGenerator rg = new JDKRandomGenerator();        rg.setSeed(17399225432l);        UniformRandomGenerator generator = new UniformRandomGenerator(rg);        double[] sample = new double[10000];        for (int i = 0; i < sample.length; ++i) {            sample[i] = generator.nextNormalizedDouble();        }        assertEquals(0.0, StatUtils.mean(sample), 0.07);        assertEquals(1.0, StatUtils.variance(sample), 0.02);    }    public static Test suite() {        return new TestSuite(UniformRandomGeneratorTest.class);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import junit.framework.Test;import junit.framework.TestSuite;import java.io.BufferedReader;import java.io.File;import java.io.IOException;import java.io.InputStreamReader;import java.net.URL;import java.util.ArrayList;import java.util.Iterator;import org.apache.commons.math.RetryTestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.SummaryStatistics;/** * Test cases for the EmpiricalDistribution class * * @version $Revision$ $Date$ */public final class EmpiricalDistributionTest extends RetryTestCase {    protected EmpiricalDistribution empiricalDistribution = null;    protected EmpiricalDistribution empiricalDistribution2 = null;    protected File file = null;    protected URL url = null;     protected double[] dataArray = null;        public EmpiricalDistributionTest(String name) {        super(name);    }    public void setUp() throws IOException {        empiricalDistribution = new EmpiricalDistributionImpl(100);        url = getClass().getResource("testData.txt");                empiricalDistribution2 = new EmpiricalDistributionImpl(100);        BufferedReader in =                 new BufferedReader(new InputStreamReader(                        url.openStream()));        String str = null;        ArrayList list = new ArrayList();        while ((str = in.readLine()) != null) {            list.add(Double.valueOf(str));        }        in.close();        in = null;                dataArray = new double[list.size()];        int i = 0;        for (Iterator iter = list.iterator(); iter.hasNext();) {            dataArray[i] = ((Double)iter.next()).doubleValue();            i++;        }                     }    public static Test suite() {        TestSuite suite = new TestSuite(EmpiricalDistributionTest.class);        suite.setName("EmpiricalDistribution Tests");        return suite;    }    /**     * Test EmpiricalDistrbution.load() using sample data file.<br>      * Check that the sampleCount, mu and sigma match data in      * the sample data file.     */    public void testLoad() throws Exception {        empiricalDistribution.load(url);           // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1        // Make sure that loaded distribution matches this        assertEquals(empiricalDistribution.getSampleStats().getN(),1000,10E-7);        //TODO: replace with statistical tests        assertEquals            (empiricalDistribution.getSampleStats().getMean(),                5.069831575018909,10E-7);        assertEquals          (empiricalDistribution.getSampleStats().getStandardDeviation(),                1.0173699343977738,10E-7);    }    /**     * Test EmpiricalDistrbution.load(double[]) using data taken from     * sample data file.<br>      * Check that the sampleCount, mu and sigma match data in      * the sample data file.     */    public void testDoubleLoad() throws Exception {        empiricalDistribution2.load(dataArray);           // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1        // Make sure that loaded distribution matches this        assertEquals(empiricalDistribution2.getSampleStats().getN(),1000,10E-7);        //TODO: replace with statistical tests        assertEquals            (empiricalDistribution2.getSampleStats().getMean(),                5.069831575018909,10E-7);        assertEquals          (empiricalDistribution2.getSampleStats().getStandardDeviation(),                1.0173699343977738,10E-7);                double[] bounds = empiricalDistribution2.getUpperBounds();        assertEquals(bounds.length, 100);        assertEquals(bounds[99], 1.0, 10e-12);              }       /**       * Generate 1000 random values and make sure they look OK.<br>      * Note that there is a non-zero (but very small) probability that      * these tests will fail even if the code is working as designed.      */    public void testNext() throws Exception {        tstGen(0.1);        tstDoubleGen(0.1);    }        /**      * Make sure exception thrown if digest getNext is attempted      * before loading empiricalDistribution.     */    public void testNexFail() {        try {            empiricalDistribution.getNextValue();            empiricalDistribution2.getNextValue();            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {;}    }        /**     * Make sure we can handle a grid size that is too fine     */    public void testGridTooFine() throws Exception {        empiricalDistribution = new EmpiricalDistributionImpl(1001);        tstGen(0.1);            empiricalDistribution2 = new EmpiricalDistributionImpl(1001);                   tstDoubleGen(0.1);    }        /**     * How about too fat?     */    public void testGridTooFat() throws Exception {        empiricalDistribution = new EmpiricalDistributionImpl(1);        tstGen(5); // ridiculous tolerance; but ridiculous grid size                   // really just checking to make sure we do not bomb        empiricalDistribution2 = new EmpiricalDistributionImpl(1);                   tstDoubleGen(5);               }        /**     * Test bin index overflow problem (BZ 36450)     */    public void testBinIndexOverflow() throws Exception {        double[] x = new double[] {9474.94326071674, 2080107.8865462579};        new EmpiricalDistributionImpl().load(x);    }        public void testSerialization() {        // Empty        EmpiricalDistribution dist = new EmpiricalDistributionImpl();        EmpiricalDistribution dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(dist);        verifySame(dist, dist2);                // Loaded        empiricalDistribution2.load(dataArray);           dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(empiricalDistribution2);        verifySame(empiricalDistribution2, dist2);    }        private void verifySame(EmpiricalDistribution d1, EmpiricalDistribution d2) {        assertEquals(d1.isLoaded(), d2.isLoaded());        assertEquals(d1.getBinCount(), d2.getBinCount());        assertEquals(d1.getSampleStats(), d2.getSampleStats());        if (d1.isLoaded()) {            for (int i = 0;  i < d1.getUpperBounds().length; i++) {                assertEquals(d1.getUpperBounds()[i], d2.getUpperBounds()[i], 0);            }            assertEquals(d1.getBinStats(), d2.getBinStats());        }    }        private void tstGen(double tolerance)throws Exception {        empiricalDistribution.load(url);           SummaryStatistics stats = SummaryStatistics.newInstance();        for (int i = 1; i < 1000; i++) {            stats.addValue(empiricalDistribution.getNextValue());        }        assertEquals("mean", stats.getMean(),5.069831575018909,tolerance);        assertEquals         ("std dev", stats.getStandardDeviation(),1.0173699343977738,tolerance);    }    private void tstDoubleGen(double tolerance)throws Exception {        empiricalDistribution2.load(dataArray);           SummaryStatistics stats = SummaryStatistics.newInstance();        for (int i = 1; i < 1000; i++) {            stats.addValue(empiricalDistribution2.getNextValue());        }        assertEquals("mean", stats.getMean(),5.069831575018909,tolerance);        assertEquals         ("std dev", stats.getStandardDeviation(),1.0173699343977738,tolerance);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class ComplexTest extends TestCase {        private double inf = Double.POSITIVE_INFINITY;    private double neginf = Double.NEGATIVE_INFINITY;    private double nan = Double.NaN;    private Complex oneInf = new Complex(1, inf);    private Complex oneNegInf = new Complex(1, neginf);    private Complex infOne = new Complex(inf, 1);    private Complex negInfInf = new Complex(neginf, inf);    private Complex negInfNegInf = new Complex(neginf, neginf);    private Complex oneNaN = new Complex(1, nan);        public void testConstructor() {        Complex z = new Complex(3.0, 4.0);        assertEquals(3.0, z.getReal(), 1.0e-5);        assertEquals(4.0, z.getImaginary(), 1.0e-5);    }        public void testConstructorNaN() {        Complex z = new Complex(3.0, Double.NaN);        assertTrue(z.isNaN());        z = new Complex(nan, 4.0);        assertTrue(z.isNaN());        z = new Complex(3.0, 4.0);        assertFalse(z.isNaN());    }        public void testAbs() {        Complex z = new Complex(3.0, 4.0);        assertEquals(5.0, z.abs(), 1.0e-5);    }        public void testAbsNaN() {        assertTrue(Double.isNaN(Complex.NaN.abs()));        Complex z = new Complex(inf, nan);        assertTrue(Double.isNaN(z.abs()));    }        public void testAbsInfinite() {        Complex z = new Complex(inf, 0);        assertEquals(inf, z.abs(), 0);        z = new Complex(0, neginf);        assertEquals(inf, z.abs(), 0);        z = new Complex(inf, neginf);        assertEquals(inf, z.abs(), 0);         }        public void testAdd() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.add(y);        assertEquals(8.0, z.getReal(), 1.0e-5);        assertEquals(10.0, z.getImaginary(), 1.0e-5);    }        public void testAddNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.add(Complex.NaN);        assertTrue(z.isNaN());        z = new Complex(1, nan);        Complex w = x.add(z);        assertEquals(w.real, 4.0, 0);        assertTrue(Double.isNaN(w.imaginary));    }        public void testAddInfinite() {        Complex x = new Complex(1, 1);        Complex z = new Complex(inf, 0);        Complex w = x.add(z);        assertEquals(w.imaginary, 1, 0);        assertEquals(inf, w.real, 0);                x = new Complex(neginf, 0);        assertTrue(Double.isNaN(x.add(z).real));    }        public void testConjugate() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.conjugate();        assertEquals(3.0, z.getReal(), 1.0e-5);        assertEquals(-4.0, z.getImaginary(), 1.0e-5);    }        public void testConjugateNaN() {        Complex z = Complex.NaN.conjugate();        assertTrue(z.isNaN());    }        public void testConjugateInfiinite() {        Complex z = new Complex(0, inf);        assertEquals(neginf, z.conjugate().imaginary, 0);        z = new Complex(0, neginf);        assertEquals(inf, z.conjugate().imaginary, 0);    }        public void testDivide() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.divide(y);        assertEquals(39.0 / 61.0, z.getReal(), 1.0e-5);        assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5);    }        public void testDivideInfinite() {        Complex x = new Complex(3, 4);        Complex w = new Complex(neginf, inf);        assertTrue(x.divide(w).equals(Complex.ZERO));                Complex z = w.divide(x);        assertTrue(Double.isNaN(z.real));        assertEquals(inf, z.imaginary, 0);                w = new Complex(inf, inf);        z = w.divide(x);        assertTrue(Double.isNaN(z.imaginary));        assertEquals(inf, z.real, 0);                w = new Complex(1, inf);        z = w.divide(w);        assertTrue(Double.isNaN(z.real));        assertTrue(Double.isNaN(z.imaginary));    }        public void testDivideNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.divide(Complex.NaN);        assertTrue(z.isNaN());    }        public void testDivideNaNInf() {         Complex z = oneInf.divide(Complex.ONE);       assertTrue(Double.isNaN(z.real));       assertEquals(inf, z.imaginary, 0);              z = negInfNegInf.divide(oneNaN);       assertTrue(Double.isNaN(z.real));       assertTrue(Double.isNaN(z.imaginary));              z = negInfInf.divide(Complex.ONE);       assertTrue(Double.isNaN(z.real));       assertTrue(Double.isNaN(z.imaginary));    }        public void testMultiply() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.multiply(y);        assertEquals(-9.0, z.getReal(), 1.0e-5);        assertEquals(38.0, z.getImaginary(), 1.0e-5);    }        public void testMultiplyNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.multiply(Complex.NaN);        assertTrue(z.isNaN());    }        public void testMultiplyNaNInf() {        Complex z = new Complex(1,1);        Complex w = z.multiply(infOne);        assertEquals(w.real, inf, 0);        assertEquals(w.imaginary, inf, 0);                w = oneInf.multiply(oneNegInf);        assertEquals(w.real, inf, 0);        assertTrue(Double.isNaN(w.imaginary));                w = negInfNegInf.multiply(oneNaN);        assertTrue(Double.isNaN(w.real));        assertTrue(Double.isNaN(w.imaginary));      }        public void testNegate() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.negate();        assertEquals(-3.0, z.getReal(), 1.0e-5);        assertEquals(-4.0, z.getImaginary(), 1.0e-5);    }        public void testNegateNaN() {        Complex z = Complex.NaN.negate();        assertTrue(z.isNaN());    }        public void testSubtract() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.subtract(y);        assertEquals(-2.0, z.getReal(), 1.0e-5);        assertEquals(-2.0, z.getImaginary(), 1.0e-5);    }        public void testSubtractNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.subtract(Complex.NaN);        assertTrue(z.isNaN());    }        public void testEqualsNull() {        Complex x = new Complex(3.0, 4.0);        assertFalse(x.equals(null));    }        public void testEqualsClass() {        Complex x = new Complex(3.0, 4.0);        assertFalse(x.equals(this));    }        public void testEqualsSame() {        Complex x = new Complex(3.0, 4.0);        assertTrue(x.equals(x));    }        public void testEqualsTrue() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(3.0, 4.0);        assertTrue(x.equals(y));    }        public void testEqualsRealDifference() {        Complex x = new Complex(0.0, 0.0);        Complex y = new Complex(0.0 + Double.MIN_VALUE, 0.0);        assertFalse(x.equals(y));    }        public void testEqualsImaginaryDifference() {        Complex x = new Complex(0.0, 0.0);        Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);        assertFalse(x.equals(y));    }        public void testEqualsNaN() {        Complex realNaN = new Complex(Double.NaN, 0.0);        Complex imaginaryNaN = new Complex(0.0, Double.NaN);        Complex complexNaN = Complex.NaN;        assertTrue(realNaN.equals(imaginaryNaN));        assertTrue(imaginaryNaN.equals(complexNaN));        assertTrue(realNaN.equals(complexNaN));    }        public void testHashCode() {        Complex x = new Complex(0.0, 0.0);        Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);        assertFalse(x.hashCode()==y.hashCode());        y = new Complex(0.0 + Double.MIN_VALUE, 0.0);        assertFalse(x.hashCode()==y.hashCode());        Complex realNaN = new Complex(Double.NaN, 0.0);        Complex imaginaryNaN = new Complex(0.0, Double.NaN);        assertEquals(realNaN.hashCode(), imaginaryNaN.hashCode());        assertEquals(imaginaryNaN.hashCode(), Complex.NaN.hashCode());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import java.util.Locale;public class FrenchComplexFormatTest extends ComplexFormatAbstractTest {        protected char getDecimalCharacter() {        return ',';    }        protected Locale getLocale() {        return Locale.FRENCH;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import java.text.NumberFormat;import java.text.ParseException;import java.util.Locale;import junit.framework.TestCase;public abstract class ComplexFormatAbstractTest extends TestCase {     ComplexFormat complexFormat = null;    ComplexFormat complexFormatJ = null;    protected abstract Locale getLocale();    protected abstract char getDecimalCharacter();        protected void setUp() throws Exception {        complexFormat = ComplexFormat.getInstance(getLocale());        complexFormatJ = ComplexFormat.getInstance(getLocale());        complexFormatJ.setImaginaryCharacter("j");    }       public void testSimpleNoDecimals() {        Complex c = new Complex(1, 1);        String expected = "1 + 1i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testSimpleWithDecimals() {        Complex c = new Complex(1.23, 1.43);        String expected = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testSimpleWithDecimalsTrunc() {        Complex c = new Complex(1.2323, 1.4343);        String expected = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testNegativeReal() {        Complex c = new Complex(-1.2323, 1.4343);        String expected = "-1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testNegativeImaginary() {        Complex c = new Complex(1.2323, -1.4343);        String expected = "1" + getDecimalCharacter() + "23 - 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testNegativeBoth() {        Complex c = new Complex(-1.2323, -1.4343);        String expected = "-1" + getDecimalCharacter() + "23 - 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testZeroReal() {        Complex c = new Complex(0.0, -1.4343);        String expected = "0 - 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testZeroImaginary() {        Complex c = new Complex(30.233, 0);        String expected = "30" + getDecimalCharacter() + "23";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testDifferentImaginaryChar() {        Complex c = new Complex(1, 1);        String expected = "1 + 1j";        String actual = complexFormatJ.format(c);         assertEquals(expected, actual);    }        public void testStaticFormatComplex() {        Locale defaultLocal = Locale.getDefault();        Locale.setDefault(getLocale());                Complex c = new Complex(232.222, -342.33);        String expected = "232" + getDecimalCharacter() + "22 - 342" + getDecimalCharacter() + "33i";        String actual = ComplexFormat.formatComplex(c);         assertEquals(expected, actual);                Locale.setDefault(defaultLocal);    }    public void testNan() {        Complex c = new Complex(Double.NaN, Double.NaN);        String expected = "(NaN) + (NaN)i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testPositiveInfinity() {        Complex c = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);        String expected = "(Infinity) + (Infinity)i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testNegativeInfinity() {        Complex c = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);        String expected = "(-Infinity) - (Infinity)i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }        public void testParseSimpleNoDecimals() {        String source = "1 + 1i";        Complex expected = new Complex(1, 1);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseSimpleWithDecimals() {        String source = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";        Complex expected = new Complex(1.23, 1.43);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseSimpleWithDecimalsTrunc() {        String source = "1" + getDecimalCharacter() + "2323 + 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(1.2323, 1.4343);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeReal() {        String source = "-1" + getDecimalCharacter() + "2323 + 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(-1.2323, 1.4343);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeImaginary() {        String source = "1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(1.2323, -1.4343);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeBoth() {        String source = "-1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(-1.2323, -1.4343);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseZeroReal() {        String source = "0" + getDecimalCharacter() + "0 - 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(0.0, -1.4343);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseZeroImaginary() {        String source = "-1" + getDecimalCharacter() + "2323";        Complex expected = new Complex(-1.2323, 0);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseDifferentImaginaryChar() {        String source = "-1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343j";        Complex expected = new Complex(-1.2323, -1.4343);        try {            Complex actual = (Complex)complexFormatJ.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }        public void testParseNan() {        String source = "(NaN) + (NaN)i";        Complex expected = new Complex(Double.NaN, Double.NaN);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParsePositiveInfinity() {        String source = "(Infinity) + (Infinity)i";        Complex expected = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testPaseNegativeInfinity() {        String source = "(-Infinity) - (Infinity)i";        Complex expected = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }        public void testConstructorSingleFormat() {        NumberFormat nf = NumberFormat.getInstance();        ComplexFormat cf = new ComplexFormat(nf);        assertNotNull(cf);        assertEquals(nf, cf.getRealFormat());    }        public void testGetImaginaryFormat() {        NumberFormat nf = NumberFormat.getInstance();        ComplexFormat cf = new ComplexFormat();                assertNotSame(nf, cf.getImaginaryFormat());        cf.setImaginaryFormat(nf);        assertSame(nf, cf.getImaginaryFormat());    }        public void testSetImaginaryFormatNull() {        try {            ComplexFormat cf = new ComplexFormat();            cf.setImaginaryFormat(null);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }        public void testSetRealFormatNull() {        try {            ComplexFormat cf = new ComplexFormat();            cf.setRealFormat(null);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }        public void testGetRealFormat() {        NumberFormat nf = NumberFormat.getInstance();        ComplexFormat cf = new ComplexFormat();                assertNotSame(nf, cf.getRealFormat());        cf.setRealFormat(nf);        assertSame(nf, cf.getRealFormat());    }        public void testSetImaginaryCharacterNull() {        try {            ComplexFormat cf = new ComplexFormat();            cf.setImaginaryCharacter(null);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }        public void testSetImaginaryCharacterEmpty() {        try {            ComplexFormat cf = new ComplexFormat();            cf.setImaginaryCharacter("");            fail();        } catch (IllegalArgumentException ex) {            // success        }    }        public void testFormatNumber() {        ComplexFormat cf = ComplexFormat.getInstance(getLocale());        Double pi = new Double(Math.PI);        String text = cf.format(pi);        assertEquals("3" + getDecimalCharacter() + "14", text);    }        public void testFormatObject() {        try {            ComplexFormat cf = new ComplexFormat();            Object object = new Object();            cf.format(object);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class ComplexUtilsTest extends TestCase {        private double inf = Double.POSITIVE_INFINITY;    private double negInf = Double.NEGATIVE_INFINITY;    private double nan = Double.NaN;    private double pi = Math.PI;        private Complex oneInf = new Complex(1, inf);    private Complex oneNegInf = new Complex(1, negInf);    private Complex infOne = new Complex(inf, 1);    private Complex negInfOne = new Complex(negInf, 1);    private Complex negInfInf = new Complex(negInf, inf);    private Complex infNegInf = new Complex(inf, negInf);    private Complex infInf = new Complex(inf, inf);    private Complex negInfNegInf = new Complex(negInf, negInf);    private Complex oneNaN = new Complex(1, nan);    private Complex infNaN = new Complex(inf, nan);    private Complex negInfNaN = new Complex(negInf, nan);    private Complex nanInf = new Complex(nan, inf);    private Complex nanNegInf = new Complex(nan, negInf);    private Complex zeroNaN = new Complex(0, nan);    private Complex nanZero = new Complex(nan, 0);    private Complex infZero = new Complex(inf, 0);    private Complex zeroInf = new Complex(0, inf);    private Complex zeroNegInf = new Complex(0, negInf);    private Complex negInfZero = new Complex(negInf, 0);        private ComplexFormat fmt = new ComplexFormat();        public void testAcos() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(0.936812, -2.30551);        TestUtils.assertEquals(expected, ComplexUtils.acos(z), 1.0e-5);        TestUtils.assertEquals(new Complex(Math.acos(0), 0),                 ComplexUtils.acos(Complex.ZERO), 1.0e-12);    }        public void testAcosInf() {        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneNegInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infOne));        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfOne));        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infNegInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfNegInf));    }        public void testAcosNaN() {        assertTrue(ComplexUtils.acos(Complex.NaN).isNaN());    }        public void testAcosNull() {        try {            Complex z = ComplexUtils.acos(null);             fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }        public void testAsin() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(0.633984, 2.30551);        TestUtils.assertEquals(expected, ComplexUtils.asin(z), 1.0e-5);    }        public void testAsinNaN() {        assertTrue(ComplexUtils.asin(Complex.NaN).isNaN());    }        public void testAsinInf() {        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneNegInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infOne));        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfOne));        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infNegInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfNegInf));    }        public void testAsinNull() {        try {            Complex z = ComplexUtils.asin(null);             fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }        public void testAtan() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(1.44831, 0.158997);        TestUtils.assertEquals(expected, ComplexUtils.atan(z), 1.0e-5);    }        public void testAtanInf() {        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneNegInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infOne));        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfOne));        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infNegInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfNegInf));    }         public void testAtanNaN() {        assertTrue(ComplexUtils.atan(Complex.NaN).isNaN());        assertTrue(ComplexUtils.atan(Complex.I).isNaN());    }        public void testAtanNull() {        try {            Complex z = ComplexUtils.atan(null);             fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }        public void testCos() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-27.03495, -3.851153);        TestUtils.assertEquals(expected, ComplexUtils.cos(z), 1.0e-5);    }        public void testCosNaN() {        assertTrue(ComplexUtils.cos(Complex.NaN).isNaN());    }        public void testCosInf() {        TestUtils.assertSame(infNegInf, ComplexUtils.cos(oneInf));        TestUtils.assertSame(infInf, ComplexUtils.cos(oneNegInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infOne));        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfOne));        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infNegInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfNegInf));    }         public void testCosNull() {        try {            Complex z = ComplexUtils.cos(null);             fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }        public void testCosh() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-6.58066, -7.58155);        TestUtils.assertEquals(expected, ComplexUtils.cosh(z), 1.0e-5);    }        public void testCoshNaN() {        assertTrue(ComplexUtils.cosh(Complex.NaN).isNaN());    }        public void testCoshInf() {          TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneNegInf));        TestUtils.assertSame(infInf, ComplexUtils.cosh(infOne));        TestUtils.assertSame(infNegInf, ComplexUtils.cosh(negInfOne));        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infNegInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfNegInf));    }         public void testCoshNull() {        try {            Complex z = ComplexUtils.cosh(null);             fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }        public void testExp() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-13.12878, -15.20078);        TestUtils.assertEquals(expected, ComplexUtils.exp(z), 1.0e-5);        TestUtils.assertEquals(Complex.ONE,                 ComplexUtils.exp(Complex.ZERO), 10e-12);        Complex iPi = Complex.I.multiply(new Complex(pi,0));        TestUtils.assertEquals(Complex.ONE.negate(),                 ComplexUtils.exp(iPi), 10e-12);    }        public void testExpNaN() {        assertTrue(ComplexUtils.exp(Complex.NaN).isNaN());    }        public void testExpInf() {        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneNegInf));        TestUtils.assertSame(infInf, ComplexUtils.exp(infOne));        TestUtils.assertSame(Complex.ZERO, ComplexUtils.exp(negInfOne));        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infNegInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfNegInf));    }        public void testExpNull() {        try {            Complex z = ComplexUtils.exp(null);             fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }        public void testLog() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(1.60944, 0.927295);        TestUtils.assertEquals(expected, ComplexUtils.log(z), 1.0e-5);    }        public void testLogNaN() {        assertTrue(ComplexUtils.log(Complex.NaN).isNaN());    }        public void testLogInf() {        TestUtils.assertEquals(new Complex(inf, pi / 2),                ComplexUtils.log(oneInf), 10e-12);        TestUtils.assertEquals(new Complex(inf, -pi / 2),                ComplexUtils.log(oneNegInf), 10e-12);        TestUtils.assertEquals(infZero, ComplexUtils.log(infOne), 10e-12);        TestUtils.assertEquals(new Complex(inf, pi),                ComplexUtils.log(negInfOne), 10e-12);        TestUtils.assertEquals(new Complex(inf, pi / 4),                ComplexUtils.log(infInf), 10e-12);        TestUtils.assertEquals(new Complex(inf, -pi / 4),                ComplexUtils.log(infNegInf), 10e-12);        TestUtils.assertEquals(new Complex(inf, 3d * pi / 4),                ComplexUtils.log(negInfInf), 10e-12);        TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),                ComplexUtils.log(negInfNegInf), 10e-12);    }        public void testLogZero() {        TestUtils.assertSame(negInfZero, ComplexUtils.log(Complex.ZERO));    }        public void testlogNull() {        try {            Complex z = ComplexUtils.log(null);             fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }        public void testPolar2Complex() {        TestUtils.assertEquals(Complex.ONE,                 ComplexUtils.polar2Complex(1, 0), 10e-12);        TestUtils.assertEquals(Complex.ZERO,                 ComplexUtils.polar2Complex(0, 1), 10e-12);        TestUtils.assertEquals(Complex.ZERO,                 ComplexUtils.polar2Complex(0, -1), 10e-12);        TestUtils.assertEquals(Complex.I,                 ComplexUtils.polar2Complex(1, pi/2), 10e-12);        TestUtils.assertEquals(Complex.I.negate(),                 ComplexUtils.polar2Complex(1, -pi/2), 10e-12);        double r = 0;        for (int i = 0; i < 5; i++) {          r += i;          double theta = 0;          for (int j =0; j < 20; j++) {              theta += pi / 6;              TestUtils.assertEquals(altPolar(r, theta),                       ComplexUtils.polar2Complex(r, theta), 10e-12);          }          theta = -2 * pi;          for (int j =0; j < 20; j++) {              theta -= pi / 6;              TestUtils.assertEquals(altPolar(r, theta),                       ComplexUtils.polar2Complex(r, theta), 10e-12);          }        }       }        protected Complex altPolar(double r, double theta) {        return ComplexUtils.exp(Complex.I.multiply                (new Complex(theta, 0))).multiply(new Complex(r, 0));    }        public void testPolar2ComplexIllegalModulus() {        try {            Complex z = ComplexUtils.polar2Complex(-1, 0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }           }        public void testPolar2ComplexNaN() {        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(nan, 1));        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, nan));        TestUtils.assertSame(Complex.NaN,                 ComplexUtils.polar2Complex(nan, nan));         }        public void testPolar2ComplexInf() {        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, inf));        TestUtils.assertSame(Complex.NaN,                ComplexUtils.polar2Complex(1, negInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(inf, inf));        TestUtils.assertSame(Complex.NaN,                ComplexUtils.polar2Complex(inf, negInf));        TestUtils.assertSame(infInf, ComplexUtils.polar2Complex(inf, pi/4));        TestUtils.assertSame(infNaN, ComplexUtils.polar2Complex(inf, 0));        TestUtils.assertSame(infNegInf, ComplexUtils.polar2Complex(inf, -pi/4));        TestUtils.assertSame(negInfInf, ComplexUtils.polar2Complex(inf, 3*pi/4));        TestUtils.assertSame(negInfNegInf, ComplexUtils.polar2Complex(inf, 5*pi/4));    }        public void testPow() {        Complex x = new Complex(3, 4);        Complex y = new Complex(5, 6);        Complex expected = new Complex(-1.860893, 11.83677);        TestUtils.assertEquals(expected, ComplexUtils.pow(x, y), 1.0e-5);    }        public void testPowNaNBase() {        Complex x = new Complex(3, 4);        assertTrue(ComplexUtils.pow(Complex.NaN, x).isNaN());    }        public void testPowNaNExponent() {        Complex x = new Complex(3, 4);        assertTrue(ComplexUtils.pow(x, Complex.NaN).isNaN());    }       public void testPowInf() {       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneInf));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneNegInf));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infOne));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infInf));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infNegInf));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfInf));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfNegInf));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infOne, Complex.ONE));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfOne, Complex.ONE));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, Complex.ONE));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, Complex.ONE));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfInf, Complex.ONE));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, Complex.ONE));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infNegInf));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, negInfNegInf));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infInf));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infNegInf));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, negInfNegInf));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infInf));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infNegInf));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, negInfNegInf));       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infInf));      }      public void testPowZero() {       TestUtils.assertSame(Complex.NaN,                ComplexUtils.pow(Complex.ZERO, Complex.ONE));       TestUtils.assertSame(Complex.NaN,                ComplexUtils.pow(Complex.ZERO, Complex.ZERO));       TestUtils.assertSame(Complex.NaN,                ComplexUtils.pow(Complex.ZERO, Complex.I));       TestUtils.assertEquals(Complex.ONE,               ComplexUtils.pow(Complex.ONE, Complex.ZERO), 10e-12);       TestUtils.assertEquals(Complex.ONE,               ComplexUtils.pow(Complex.I, Complex.ZERO), 10e-12);       TestUtils.assertEquals(Complex.ONE,               ComplexUtils.pow(new Complex(-1, 3), Complex.ZERO), 10e-12);   }        public void testpowNull() {        try {            Complex z = ComplexUtils.pow(null, Complex.ONE);             fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }        try {            Complex z = ComplexUtils.pow(Complex.ONE, null);             fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }        public void testSin() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(3.853738, -27.01681);        TestUtils.assertEquals(expected, ComplexUtils.sin(z), 1.0e-5);    }        public void testSinInf() {        TestUtils.assertSame(infInf, ComplexUtils.sin(oneInf));        TestUtils.assertSame(infNegInf, ComplexUtils.sin(oneNegInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infOne));        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfOne));        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infNegInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfNegInf));    }        public void testSinNaN() {        assertTrue(ComplexUtils.sin(Complex.NaN).isNaN());    }        public void testSinNull() {        try {            Complex z = ComplexUtils.sin(null);             fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }         public void testSinh() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-6.54812, -7.61923);        TestUtils.assertEquals(expected, ComplexUtils.sinh(z), 1.0e-5);    }        public void testSinhNaN() {        assertTrue(ComplexUtils.sinh(Complex.NaN).isNaN());    }        public void testSinhInf() {        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneNegInf));        TestUtils.assertSame(infInf, ComplexUtils.sinh(infOne));        TestUtils.assertSame(negInfInf, ComplexUtils.sinh(negInfOne));        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infNegInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfNegInf));    }        public void testsinhNull() {        try {            Complex z = ComplexUtils.sinh(null);             fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }        public void testSqrtRealPositive() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(2, 1);        TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);    }        public void testSqrtRealZero() {        Complex z = new Complex(0.0, 4);        Complex expected = new Complex(1.41421, 1.41421);        TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);    }        public void testSqrtRealNegative() {        Complex z = new Complex(-3.0, 4);        Complex expected = new Complex(1, 2);        TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);    }        public void testSqrtImaginaryZero() {        Complex z = new Complex(-3.0, 0.0);        Complex expected = new Complex(0.0, 1.73205);        TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);    }        public void testSqrtImaginaryNegative() {        Complex z = new Complex(-3.0, -4.0);        Complex expected = new Complex(1.0, -2.0);        TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);    }        public void testSqrtPolar() {        double r = 1;        for (int i = 0; i < 5; i++) {            r += i;            double theta = 0;            for (int j =0; j < 11; j++) {                theta += pi /12;                Complex z = ComplexUtils.polar2Complex(r, theta);                Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2);                TestUtils.assertEquals(sqrtz, ComplexUtils.sqrt(z), 10e-12);            }        }           }        public void testSqrtNaN() {        assertTrue(ComplexUtils.sqrt(Complex.NaN).isNaN());    }          public void testSqrtInf() {        TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneInf));        TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneNegInf));        TestUtils.assertSame(infZero, ComplexUtils.sqrt(infOne));        TestUtils.assertSame(zeroInf, ComplexUtils.sqrt(negInfOne));        TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infInf));        TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infNegInf));        TestUtils.assertSame(nanInf, ComplexUtils.sqrt(negInfInf));        TestUtils.assertSame(nanNegInf, ComplexUtils.sqrt(negInfNegInf));    }        public void testSqrtNull() {        try {            Complex z = ComplexUtils.sqrt(null);             fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }    public void testSqrt1z() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(4.08033, -2.94094);        TestUtils.assertEquals(expected, ComplexUtils.sqrt1z(z), 1.0e-5);    }        public void testSqrt1zNaN() {        assertTrue(ComplexUtils.sqrt1z(Complex.NaN).isNaN());    }        public void testSqrt1zNull() {        try {            Complex z = ComplexUtils.sqrt1z(null);             fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }        public void testTan() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-0.000187346, 0.999356);        TestUtils.assertEquals(expected, ComplexUtils.tan(z), 1.0e-5);    }        public void testTanNaN() {        assertTrue(ComplexUtils.tan(Complex.NaN).isNaN());    }        public void testTanInf() {        TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneInf));        TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneNegInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infOne));        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfOne));        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infNegInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfNegInf));    }       public void testTanCritical() {        TestUtils.assertSame(infNaN, ComplexUtils.tan(new Complex(pi/2, 0)));        TestUtils.assertSame(negInfNaN, ComplexUtils.tan(new Complex(-pi/2, 0)));    }        public void testTanNull() {        try {            Complex z = ComplexUtils.tan(null);             fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }        public void testTanh() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(1.00071, 0.00490826);        TestUtils.assertEquals(expected, ComplexUtils.tanh(z), 1.0e-5);    }        public void testTanhNaN() {        assertTrue(ComplexUtils.tanh(Complex.NaN).isNaN());    }        public void testTanhInf() {        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneNegInf));        TestUtils.assertSame(nanZero, ComplexUtils.tanh(infOne));        TestUtils.assertSame(nanZero, ComplexUtils.tanh(negInfOne));        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infNegInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfNegInf));    }        public void testTanhCritical() {        TestUtils.assertSame(nanInf, ComplexUtils.tanh(new Complex(0, pi/2)));    }        public void testTanhNull() {        try {            Complex z = ComplexUtils.tanh(null);             fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import java.util.Locale;public class ComplexFormatTest extends ComplexFormatAbstractTest {    protected char getDecimalCharacter() {        return '.';    }        protected Locale getLocale() {        return Locale.US;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.util.Locale;import junit.framework.TestCase;/** * @version $Revision:$ */public class ArgumentOutsideDomainExceptionTest extends TestCase {        public void testConstructor(){        ArgumentOutsideDomainException ex = new ArgumentOutsideDomainException(Math.PI, 10.0, 20.0);        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertTrue(ex.getMessage().indexOf("3.14") > 0);        assertEquals(Math.PI, ex.getArgument(), 0);        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import junit.framework.TestCase;import java.io.ByteArrayOutputStream;import java.io.PrintStream;import java.io.PrintWriter;import java.util.Locale;/** * @version $Revision$ $Date$ */public class MathExceptionTest extends TestCase {    public void testConstructor(){        MathException ex = new MathException();        assertNull(ex.getCause());        assertNull(ex.getMessage());        assertNull(ex.getMessage(Locale.FRENCH));    }        public void testConstructorPatternArguments(){        String pattern = "a {0}x{1} matrix cannot be a rotation matrix";        Object[] arguments = { new Integer(6), new Integer(4) };        MathException ex = new MathException(pattern, arguments);        assertNull(ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }        public void testConstructorCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathException ex = new MathException(cause);        assertEquals(cause, ex.getCause());    }    public void testConstructorPatternArgumentsCause(){        String pattern = "a {0}x{1} matrix cannot be a rotation matrix";        Object[] arguments = { new Integer(6), new Integer(4) };        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathException ex = new MathException(pattern, arguments, cause);        assertEquals(cause, ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }        /**     * Tests the printStackTrace() operation.     */    public void testPrintStackTrace() {        String outMsg = "outer message";        String inMsg = "inner message";        MathException cause = new MathConfigurationException(inMsg, new Object[0]);        MathException ex = new MathException(outMsg, new Object[0], cause);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        PrintStream ps = new PrintStream(baos);        ex.printStackTrace(ps);        String stack = baos.toString();        String outerMsg = "org.apache.commons.math.MathException: outer message";        String innerMsg = "Caused by: " +         "org.apache.commons.math.MathConfigurationException: inner message";        assertTrue(stack.startsWith(outerMsg));        assertTrue(stack.indexOf(innerMsg) > 0);                PrintWriter pw = new PrintWriter(ps, true);        ex.printStackTrace(pw);        stack = baos.toString();        assertTrue(stack.startsWith(outerMsg));        assertTrue(stack.indexOf(innerMsg) > 0);    }        /**     * Test serialization     */    public void testSerialization() {        String outMsg = "outer message";        String inMsg = "inner message";        MathException cause = new MathConfigurationException(inMsg, new Object[0]);        MathException ex = new MathException(outMsg, new Object[0], cause);        MathException image = (MathException) TestUtils.serializeAndRecover(ex);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        PrintStream ps = new PrintStream(baos);        ex.printStackTrace(ps);        String stack = baos.toString();                ByteArrayOutputStream baos2 = new ByteArrayOutputStream();        PrintStream ps2 = new PrintStream(baos2);        image.printStackTrace(ps2);        String stack2 = baos2.toString();                // See if JDK supports nested exceptions.  If not, stack trace of        // inner exception will not be serialized        boolean jdkSupportsNesting = false;        try {            Throwable.class.getDeclaredMethod("getCause", new Class[0]);            jdkSupportsNesting = true;        } catch (NoSuchMethodException e) {            jdkSupportsNesting = false;        }                if (jdkSupportsNesting) {            assertEquals(stack, stack2);        } else {            assertTrue(stack2.indexOf(inMsg) != -1);            assertTrue(stack2.indexOf("MathConfigurationException") != -1);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.util.Locale;import junit.framework.TestCase;/** * @version $Revision:$ */public class MaxIterationsExceededExceptionTest extends TestCase {        public void testConstructor(){        MaxIterationsExceededException ex = new MaxIterationsExceededException(1000000);        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertTrue(ex.getMessage().indexOf("1,000,000") > 0);        assertEquals(1000000, ex.getMaxIterations());        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.util.Locale;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class FunctionEvaluationExceptionTest extends TestCase {        public void testConstructor(){        FunctionEvaluationException ex = new FunctionEvaluationException(0.0);        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertTrue(ex.getMessage().indexOf("0") > 0);        assertEquals(0.0, ex.getArgument(), 0);    }        public void testConstructorPatternArguments(){        String pattern = "Evaluation failed for argument = {0}";        Object[] arguments = { new Double(0.0) };        FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments);        assertNull(ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    public void testConstructorPatternArgumentsCause(){        String pattern = "Evaluation failed for argument = {0}";        Object[] arguments = { new Double(0.0) };        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments, cause);        assertEquals(cause, ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import junit.framework.TestCase;import java.util.Locale;/** * @version $Revision$ $Date$ */public class MathConfigurationExceptionTest extends TestCase {    public void testConstructor(){        MathConfigurationException ex = new MathConfigurationException();        assertNull(ex.getCause());        assertNull(ex.getMessage());        assertNull(ex.getMessage(Locale.FRENCH));    }        public void testConstructorPatternArguments(){        String pattern = "a {0}x{1} matrix cannot be a rotation matrix";        Object[] arguments = { new Integer(6), new Integer(4) };        MathConfigurationException ex = new MathConfigurationException(pattern, arguments);        assertNull(ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }        public void testConstructorCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathConfigurationException ex = new MathConfigurationException(cause);        assertEquals(cause, ex.getCause());    }    public void testConstructorPatternArgumentsCause(){        String pattern = "a {0}x{1} matrix cannot be a rotation matrix";        Object[] arguments = { new Integer(6), new Integer(4) };        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathConfigurationException ex = new MathConfigurationException(pattern, arguments, cause);        assertEquals(cause, ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import junit.framework.Assert;import junit.framework.AssertionFailedError;import org.apache.commons.math.complex.Complex;import org.apache.commons.math.complex.ComplexFormat;/** * @version $Revision$ $Date$ */public class TestUtils {    /**     * Collection of static methods used in math unit tests.     */    private TestUtils() {        super();    }    /**     * Verifies that expected and actual are within delta, or are both NaN or     * infinities of the same sign.     */    public static void assertEquals(double expected, double actual, double delta) {        assertEquals(null, expected, actual, delta);    }    /**     * Verifies that expected and actual are within delta, or are both NaN or     * infinities of the same sign.     */    public static void assertEquals(String msg, double expected, double actual, double delta) {        // check for NaN        if(Double.isNaN(expected)){            Assert.assertTrue("" + actual + " is not NaN.",                Double.isNaN(actual));        } else {            Assert.assertEquals(msg, expected, actual, delta);        }    }        /**     * Verifies that the two arguments are exactly the same, either     * both NaN or infinities of same sign, or identical floating point values.     */    public static void assertSame(double expected, double actual) {     assertEquals(expected, actual, 0);    }        /**     * Verifies that real and imaginary parts of the two complex arguments     * are exactly the same.  Also ensures that NaN / infinite components match.     */    public static void assertSame(Complex expected, Complex actual) {        assertSame(expected.getReal(), actual.getReal());        assertSame(expected.getImaginary(), actual.getImaginary());    }        /**     * Verifies that real and imaginary parts of the two complex arguments     * differ by at most delta.  Also ensures that NaN / infinite components match.     */    public static void assertEquals(Complex expected, Complex actual, double delta) {        assertEquals(expected.getReal(), actual.getReal(), delta);        assertEquals(expected.getImaginary(), actual.getImaginary(), delta);    }        /**     * Verifies that two double arrays have equal entries, up to tolerance     */    public static void assertEquals(double a[], double b[], double tolerance) {        Assert.assertEquals(a.length, b.length);        for (int i = 0; i < a.length; i++) {            Assert.assertEquals(a[i], b[i], tolerance);        }    }        /**     * Serializes an object to a temp file and then recovers the object from the file.     * Returns the deserialized object.     *      * @param o  object to serialize and recover     * @return  the recovered, deseriailized object     */    public static Object serializeAndRecover(Object o){                Object result = null;        File tmp = null;        FileOutputStream fo = null;        FileInputStream fi = null;                try {            // serialize the Object            tmp = File.createTempFile("test",".ser");            fo = new FileOutputStream(tmp);            ObjectOutputStream so = new ObjectOutputStream(fo);            so.writeObject(o);            so.flush();            fo.close();            // deserialize the Object            fi = new FileInputStream(tmp);            ObjectInputStream si = new ObjectInputStream(fi);              result = si.readObject();        } catch (Exception ex) {                    } finally {            if (fo != null) {                try {                    fo.close();                } catch (IOException ex) {                }            }            if (fi != null) {                try {                    fi.close();                } catch (IOException ex) {                }            }        }                   if (tmp != null) {            tmp.delete();        }                return result;    }        /**     * Verifies that serialization preserves equals and hashCode.     * Serializes the object, then recovers it and checks equals and hash code.     *      * @param object  the object to serialize and recover     */    public static void checkSerializedEquality(Object object) {        Object object2 = serializeAndRecover(object);        Assert.assertEquals("Equals check", object, object2);        Assert.assertEquals("HashCode check", object.hashCode(), object2.hashCode());    }    /**     * Verifies that the relative error in actual vs. expected is less than or     * equal to relativeError.  If expected is infinite or NaN, actual must be     * the same (NaN or infinity of the same sign).     *      * @param expected expected value     * @param actual  observed value     * @param relativeError  maximum allowable relative error     */    public static void assertRelativelyEquals(double expected, double actual,            double relativeError) {        assertRelativelyEquals(null, expected, actual, relativeError);    }        /**     * Verifies that the relative error in actual vs. expected is less than or     * equal to relativeError.  If expected is infinite or NaN, actual must be     * the same (NaN or infinity of the same sign).     *      * @param msg  message to return with failure     * @param expected expected value     * @param actual  observed value     * @param relativeError  maximum allowable relative error     */    public static void assertRelativelyEquals(String msg, double expected,            double actual, double relativeError) {        if (Double.isNaN(expected)) {            Assert.assertTrue(msg, Double.isNaN(actual));        } else if (Double.isNaN(actual)) {            Assert.assertTrue(msg, Double.isNaN(expected));        } else if (Double.isInfinite(actual) || Double.isInfinite(expected)) {            Assert.assertEquals(expected, actual, relativeError);        } else if (expected == 0.0) {            Assert.assertEquals(msg, actual, expected, relativeError);        } else {            double x = Math.abs((expected - actual) / expected);            Assert.assertEquals(msg, 0.0, x, relativeError);        }    }        /**     * Fails iff values does not contain a number within epsilon of z.     *      * @param msg  message to return with failure     * @param values complex array to search     * @param z  value sought     * @param epsilon  tolerance     */    public static void assertContains(String msg, Complex[] values,            Complex z, double epsilon) {        int i = 0;        boolean found = false;        while (!found && i < values.length) {            try {                assertEquals(values[i], z, epsilon);                found = true;             } catch (AssertionFailedError er) {                // no match            }            i++;        }        if (!found) {            Assert.fail(msg +                 " Unable to find " + ComplexFormat.formatComplex(z));        }    }        /**     * Fails iff values does not contain a number within epsilon of z.     *      * @param values complex array to search     * @param z  value sought     * @param epsilon  tolerance     */    public static void assertContains(Complex[] values,            Complex z, double epsilon) {        assertContains(null, values, z, epsilon);          }        /**     * Fails iff values does not contain a number within epsilon of x.     *      * @param msg  message to return with failure     * @param values double array to search     * @param x value sought     * @param epsilon  tolerance     */    public static void assertContains(String msg, double[] values,            double x, double epsilon) {        int i = 0;        boolean found = false;        while (!found && i < values.length) {            try {                assertEquals(values[i], x, epsilon);                found = true;             } catch (AssertionFailedError er) {                // no match            }            i++;        }        if (!found) {            Assert.fail(msg + " Unable to find" + x);        }    }        /**     * Fails iff values does not contain a number within epsilon of x.     *      * @param values double array to search     * @param x value sought     * @param epsilon  tolerance     */    public static void assertContains(double[] values, double x,            double epsilon) {       assertContains(null, values, x, epsilon);    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import junit.framework.TestCase;import java.util.Locale;/** * @version $Revision: 480442 $ $Date: 2006-11-29 08:21:22 +0100 (mer., 29 nov. 2006) $ */public class ConvergenceExceptionTest extends TestCase {    public void testConstructor(){        ConvergenceException ex = new ConvergenceException();        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertNotNull(ex.getMessage(Locale.FRENCH));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }        public void testConstructorPatternArguments(){        String pattern = "a {0}x{1} matrix cannot be a rotation matrix";        Object[] arguments = { new Integer(6), new Integer(4) };        ConvergenceException ex = new ConvergenceException(pattern, arguments);        assertNull(ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }        public void testConstructorCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        ConvergenceException ex = new ConvergenceException(cause);        assertEquals(cause, ex.getCause());    }    public void testConstructorPatternArgumentsCause(){        String pattern = "a {0}x{1} matrix cannot be a rotation matrix";        Object[] arguments = { new Integer(6), new Integer(4) };        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        ConvergenceException ex = new ConvergenceException(pattern, arguments, cause);        assertEquals(cause, ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.util.Locale;import junit.framework.TestCase;/** * @version $Revision:$ */public class DuplicateSampleAbscissaExceptionTest extends TestCase {        public void testConstructor(){        DuplicateSampleAbscissaException ex = new DuplicateSampleAbscissaException(1.2, 10, 11);        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertTrue(ex.getMessage().indexOf("1.2") > 0);        assertEquals(1.2, ex.getDuplicateAbscissa(), 0);        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.MathException;/** * An interface for Chi-Square tests. * * @version $Revision$ $Date$  */public interface ChiSquareTest {          /**     * Computes the <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm">     * Chi-Square statistic</a> comparing <code>observed</code> and <code>expected</code>      * freqeuncy counts.      * <p>     * This statistic can be used to perform a Chi-Square test evaluating the null hypothesis that     *  the observed counts follow the expected distribution.     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Expected counts must all be positive.       * </li>     * <li>Observed counts must all be >= 0.        * </li>     * <li>The observed and expected arrays must have the same length and     * their common length must be at least 2.       * </li></ul><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.     *     * @param observed array of observed frequency counts     * @param expected array of expected frequency counts     * @return chiSquare statistic     * @throws IllegalArgumentException if preconditions are not met     */    double chiSquare(double[] expected, long[] observed)         throws IllegalArgumentException;        /**     * Returns the <i>observed significance level</i>, or <a href=     * "http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a      * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm">     * Chi-square goodness of fit test</a> comparing the <code>observed</code>      * frequency counts to those in the <code>expected</code> array.     * <p>     * The number returned is the smallest significance level at which one can reject      * the null hypothesis that the observed counts conform to the frequency distribution      * described by the expected counts.      * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Expected counts must all be positive.       * </li>     * <li>Observed counts must all be >= 0.        * </li>     * <li>The observed and expected arrays must have the same length and     * their common length must be at least 2.       * </li></ul><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.     *     * @param observed array of observed frequency counts     * @param expected array of expected frequency counts     * @return p-value     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs computing the p-value     */    double chiSquareTest(double[] expected, long[] observed)         throws IllegalArgumentException, MathException;        /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm">     * Chi-square goodness of fit test</a> evaluating the null hypothesis that the observed counts      * conform to the frequency distribution described by the expected counts, with      * significance level <code>alpha</code>.  Returns true iff the null hypothesis can be rejected     * with 100 * (1 - alpha) percent confidence.     * <p>     * <strong>Example:</strong><br>     * To test the hypothesis that <code>observed</code> follows      * <code>expected</code> at the 99% level, use <p>     * <code>chiSquareTest(expected, observed, 0.01) </code>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Expected counts must all be positive.       * </li>     * <li>Observed counts must all be >= 0.        * </li>     * <li>The observed and expected arrays must have the same length and     * their common length must be at least 2.       * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.     *     * @param observed array of observed frequency counts     * @param expected array of expected frequency counts     * @param alpha significance level of the test     * @return true iff null hypothesis can be rejected with confidence     * 1 - alpha     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean chiSquareTest(double[] expected, long[] observed, double alpha)         throws IllegalArgumentException, MathException;        /**     *  Computes the Chi-Square statistic associated with a      * <a href="http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm">     *  chi-square test of independence</a> based on the input <code>counts</code>     *  array, viewed as a two-way table.       * <p>     * The rows of the 2-way table are <code>count[0], ... , count[count.length - 1] </code>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>All counts must be >= 0.       * </li>     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length).      * </li>     * <li>The 2-way table represented by <code>counts</code> must have at least 2 columns and     *        at least 2 rows.     * </li>     * </li></ul><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.     *     * @param counts array representation of 2-way table     * @return chiSquare statistic     * @throws IllegalArgumentException if preconditions are not met     */    double chiSquare(long[][] counts)     throws IllegalArgumentException;        /**     * Returns the <i>observed significance level</i>, or <a href=     * "http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a      * <a href="http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm">     * chi-square test of independence</a> based on the input <code>counts</code>     * array, viewed as a two-way table.       * <p>     * The rows of the 2-way table are <code>count[0], ... , count[count.length - 1] </code>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>All counts must be >= 0.       * </li>     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length).      * </li>     * <li>The 2-way table represented by <code>counts</code> must have at least 2 columns and     *        at least 2 rows.     * </li>     * </li></ul><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.     *     * @param counts array representation of 2-way table     * @return p-value     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs computing the p-value     */    double chiSquareTest(long[][] counts)     throws IllegalArgumentException, MathException;        /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm">     * chi-square test of independence</a> evaluating the null hypothesis that the classifications      * represented by the counts in the columns of the input 2-way table are independent of the rows,     * with significance level <code>alpha</code>.  Returns true iff the null hypothesis can be rejected     * with 100 * (1 - alpha) percent confidence.     * <p>     * The rows of the 2-way table are <code>count[0], ... , count[count.length - 1] </code>     * <p>     * <strong>Example:</strong><br>     * To test the null hypothesis that the counts in <code>count[0], ... , count[count.length - 1] </code>     *  all correspond to the same underlying probability distribution at the 99% level, use <p>     * <code>chiSquareTest(counts, 0.01) </code>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>All counts must be >= 0.       * </li>     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length).      * </li>     * <li>The 2-way table represented by <code>counts</code> must have at least 2 columns and     *        at least 2 rows.     * </li>     * </li></ul><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.     *     * @param counts array representation of 2-way table     * @param alpha significance level of the test     * @return true iff null hypothesis can be rejected with confidence     * 1 - alpha     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean chiSquareTest(long[][] counts, double alpha)     throws IllegalArgumentException, MathException;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.MathException;import org.apache.commons.math.stat.descriptive.StatisticalSummary;/** * An interface for Student's t-tests. * <p> * Tests can be:<ul> * <li>One-sample or two-sample</li> * <li>One-sided or two-sided</li> * <li>Paired or unpaired (for two-sample tests)</li> * <li>Homoscedastic (equal variance assumption) or heteroscedastic * (for two sample tests)</li> * <li>Fixed significance level (boolean-valued) or returning p-values. * </li></ul> * <p> * Test statistics are available for all tests.  Methods including "Test" in * in their names perform tests, all other methods return t-statistics.  Among * the "Test" methods, <code>double-</code>valued methods return p-values; * <code>boolean-</code>valued methods perform fixed significance level tests. * Significance levels are always specified as numbers between 0 and 0.5 * (e.g. tests at the 95% level  use <code>alpha=0.05</code>). * <p> * Input to tests can be either <code>double[]</code> arrays or  * {@link StatisticalSummary} instances. *  * * @version $Revision$ $Date$  */public interface TTest {    /**     * Computes a paired, 2-sample t-statistic based on the data in the input      * arrays.  The t-statistic returned is equivalent to what would be returned by     * computing the one-sample t-statistic {@link #t(double, double[])}, with     * <code>mu = 0</code> and the sample array consisting of the (signed)      * differences between corresponding entries in <code>sample1</code> and      * <code>sample2.</code>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The input arrays must have the same length and their common length     * must be at least 2.     * </li></ul>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if the statistic can not be computed do to a     *         convergence or other numerical error.     */    public abstract double pairedT(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or      * <i> p-value</i>, associated with a paired, two-sample, two-tailed t-test      * based on the data in the input arrays.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the mean of the paired     * differences is 0 in favor of the two-sided alternative that the mean paired      * difference is not equal to 0. For a one-sided test, divide the returned      * value by 2.     * <p>     * This test is equivalent to a one-sample t-test computed using     * {@link #tTest(double, double[])} with <code>mu = 0</code> and the sample     * array consisting of the signed differences between corresponding elements of      * <code>sample1</code> and <code>sample2.</code>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The input array lengths must be the same and their common length must     * be at least 2.     * </li></ul>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    public abstract double pairedTTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException;    /**     * Performs a paired t-test evaluating the null hypothesis that the      * mean of the paired differences between <code>sample1</code> and     * <code>sample2</code> is 0 in favor of the two-sided alternative that the      * mean paired difference is not equal to 0, with significance level      * <code>alpha</code>.     * <p>     * Returns <code>true</code> iff the null hypothesis can be rejected with      * confidence <code>1 - alpha</code>.  To perform a 1-sided test, use      * <code>alpha * 2</code>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The input array lengths must be the same and their common length      * must be at least 2.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with      * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    public abstract boolean pairedTTest(        double[] sample1,        double[] sample2,        double alpha)        throws IllegalArgumentException, MathException;    /**     * Computes a <a href="http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula">      * t statistic </a> given observed values and a comparison constant.     * <p>     * This statistic can be used to perform a one sample t-test for the mean.     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array length must be at least 2.     * </li></ul>     *     * @param mu comparison constant     * @param observed array of values     * @return t statistic     * @throws IllegalArgumentException if input array length is less than 2     */    public abstract double t(double mu, double[] observed)        throws IllegalArgumentException;    /**     * Computes a <a href="http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula">     * t statistic </a> to use in comparing the mean of the dataset described by      * <code>sampleStats</code> to <code>mu</code>.     * <p>     * This statistic can be used to perform a one sample t-test for the mean.     * <p>     * <strong>Preconditions</strong>: <ul>     * <li><code>observed.getN() > = 2</code>.     * </li></ul>     *     * @param mu comparison constant     * @param sampleStats DescriptiveStatistics holding sample summary statitstics     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    public abstract double t(double mu, StatisticalSummary sampleStats)        throws IllegalArgumentException;    /**     * Computes a 2-sample t statistic,  under the hypothesis of equal      * subpopulation variances.  To compute a t-statistic without the     * equal variances hypothesis, use {@link #t(double[], double[])}.     * <p>     * This statistic can be used to perform a (homoscedastic) two-sample     * t-test to compare sample means.        * <p>     * The t-statisitc is     * <p>     * &nbsp;&nbsp;<code>  t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))</code>     * <p>     * where <strong><code>n1</code></strong> is the size of first sample;      * <strong><code> n2</code></strong> is the size of second sample;      * <strong><code> m1</code></strong> is the mean of first sample;       * <strong><code> m2</code></strong> is the mean of second sample</li>     * </ul>     * and <strong><code>var</code></strong> is the pooled variance estimate:     * <p>     * <code>var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))</code>     * <p>      * with <strong><code>var1<code></strong> the variance of the first sample and     * <strong><code>var2</code></strong> the variance of the second sample.     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li></ul>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    public abstract double homoscedasticT(double[] sample1, double[] sample2)        throws IllegalArgumentException;    /**     * Computes a 2-sample t statistic, without the hypothesis of equal     * subpopulation variances.  To compute a t-statistic assuming equal     * variances, use {@link #homoscedasticT(double[], double[])}.     * <p>     * This statistic can be used to perform a two-sample t-test to compare     * sample means.     * <p>     * The t-statisitc is     * <p>     * &nbsp;&nbsp; <code>  t = (m1 - m2) / sqrt(var1/n1 + var2/n2)</code>     * <p>     *  where <strong><code>n1</code></strong> is the size of the first sample     * <strong><code> n2</code></strong> is the size of the second sample;      * <strong><code> m1</code></strong> is the mean of the first sample;       * <strong><code> m2</code></strong> is the mean of the second sample;     * <strong><code> var1</code></strong> is the variance of the first sample;     * <strong><code> var2</code></strong> is the variance of the second sample;       * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li></ul>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    public abstract double t(double[] sample1, double[] sample2)        throws IllegalArgumentException;    /**     * Computes a 2-sample t statistic </a>, comparing the means of the datasets     * described by two {@link StatisticalSummary} instances, without the     * assumption of equal subpopulation variances.  Use      * {@link #homoscedasticT(StatisticalSummary, StatisticalSummary)} to     * compute a t-statistic under the equal variances assumption.     * <p>     * This statistic can be used to perform a two-sample t-test to compare     * sample means.     * <p>      * The returned  t-statisitc is     * <p>     * &nbsp;&nbsp; <code>  t = (m1 - m2) / sqrt(var1/n1 + var2/n2)</code>     * <p>     * where <strong><code>n1</code></strong> is the size of the first sample;      * <strong><code> n2</code></strong> is the size of the second sample;      * <strong><code> m1</code></strong> is the mean of the first sample;       * <strong><code> m2</code></strong> is the mean of the second sample     * <strong><code> var1</code></strong> is the variance of the first sample;       * <strong><code> var2</code></strong> is the variance of the second sample     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li></ul>     *     * @param sampleStats1 StatisticalSummary describing data from the first sample     * @param sampleStats2 StatisticalSummary describing data from the second sample     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    public abstract double t(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException;    /**     * Computes a 2-sample t statistic, comparing the means of the datasets     * described by two {@link StatisticalSummary} instances, under the     * assumption of equal subpopulation variances.  To compute a t-statistic     * without the equal variances assumption, use      * {@link #t(StatisticalSummary, StatisticalSummary)}.     * <p>     * This statistic can be used to perform a (homoscedastic) two-sample     * t-test to compare sample means.     * <p>     * The t-statisitc returned is     * <p>     * &nbsp;&nbsp;<code>  t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))</code>     * <p>     * where <strong><code>n1</code></strong> is the size of first sample;      * <strong><code> n2</code></strong> is the size of second sample;      * <strong><code> m1</code></strong> is the mean of first sample;       * <strong><code> m2</code></strong> is the mean of second sample     * and <strong><code>var</code></strong> is the pooled variance estimate:     * <p>     * <code>var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))</code>     * <p>      * with <strong><code>var1<code></strong> the variance of the first sample and     * <strong><code>var2</code></strong> the variance of the second sample.     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li></ul>     *     * @param sampleStats1 StatisticalSummary describing data from the first sample     * @param sampleStats2 StatisticalSummary describing data from the second sample     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    public abstract double homoscedasticT(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException;    /**     * Returns the <i>observed significance level</i>, or      * <i>p-value</i>, associated with a one-sample, two-tailed t-test      * comparing the mean of the input array with the constant <code>mu</code>.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the mean equals      * <code>mu</code> in favor of the two-sided alternative that the mean     * is different from <code>mu</code>. For a one-sided test, divide the      * returned value by 2.     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array length must be at least 2.     * </li></ul>     *     * @param mu constant value to compare sample mean against     * @param sample array of sample data values     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    public abstract double tTest(double mu, double[] sample)        throws IllegalArgumentException, MathException;    /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that the mean of the population from     * which <code>sample</code> is drawn equals <code>mu</code>.     * <p>     * Returns <code>true</code> iff the null hypothesis can be      * rejected with confidence <code>1 - alpha</code>.  To      * perform a 1-sided test, use <code>alpha * 2</code>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>sample mean = mu </code> at     * the 95% level, use <br><code>tTest(mu, sample, 0.05) </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>     * at the 99% level, first verify that the measured sample mean is less      * than <code>mu</code> and then use      * <br><code>tTest(mu, sample, 0.02) </code>     * </li></ol>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the one-sample      * parametric t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample">here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array length must be at least 2.     * </li></ul>     *     * @param mu constant value to compare sample mean against     * @param sample array of sample data values     * @param alpha significance level of the test     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error computing the p-value     */    public abstract boolean tTest(double mu, double[] sample, double alpha)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or      * <i>p-value</i>, associated with a one-sample, two-tailed t-test      * comparing the mean of the dataset described by <code>sampleStats</code>     * with the constant <code>mu</code>.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the mean equals      * <code>mu</code> in favor of the two-sided alternative that the mean     * is different from <code>mu</code>. For a one-sided test, divide the      * returned value by 2.     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The sample must contain at least 2 observations.     * </li></ul>     *     * @param mu constant value to compare sample mean against     * @param sampleStats StatisticalSummary describing sample data     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    public abstract double tTest(double mu, StatisticalSummary sampleStats)        throws IllegalArgumentException, MathException;    /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that the mean of the     * population from which the dataset described by <code>stats</code> is     * drawn equals <code>mu</code>.     * <p>     * Returns <code>true</code> iff the null hypothesis can be rejected with     * confidence <code>1 - alpha</code>.  To  perform a 1-sided test, use     * <code>alpha * 2.</code>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>sample mean = mu </code> at     * the 95% level, use <br><code>tTest(mu, sampleStats, 0.05) </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>     * at the 99% level, first verify that the measured sample mean is less      * than <code>mu</code> and then use      * <br><code>tTest(mu, sampleStats, 0.02) </code>     * </li></ol>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the one-sample      * parametric t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample">here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The sample must include at least 2 observations.     * </li></ul>     *     * @param mu constant value to compare sample mean against     * @param sampleStats StatisticalSummary describing sample data values     * @param alpha significance level of the test     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    public abstract boolean tTest(        double mu,        StatisticalSummary sampleStats,        double alpha)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or      * <i>p-value</i>, associated with a two-sample, two-tailed t-test      * comparing the means of the input arrays.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.      * For a one-sided test, divide the returned value by 2.     * <p>     * The test does not assume that the underlying popuation variances are     * equal  and it uses approximated degrees of freedom computed from the      * sample data to compute the p-value.  The t-statistic used is as defined in     * {@link #t(double[], double[])} and the Welch-Satterthwaite approximation     * to the degrees of freedom is used,      * as described      * <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">     * here.</a>  To perform the test under the assumption of equal subpopulation     * variances, use {@link #homoscedasticTTest(double[], double[])}.      * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li></ul>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    public abstract double tTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or      * <i>p-value</i>, associated with a two-sample, two-tailed t-test      * comparing the means of the input arrays, under the assumption that     * the two samples are drawn from subpopulations with equal variances.     * To perform the test without the equal variances assumption, use     * {@link #tTest(double[], double[])}.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.      * For a one-sided test, divide the returned value by 2.     * <p>     * A pooled variance estimate is used to compute the t-statistic.  See     * {@link #homoscedasticT(double[], double[])}. The sum of the sample sizes     * minus 2 is used as the degrees of freedom.     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li></ul>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    public abstract double homoscedasticTTest(        double[] sample1,        double[] sample2)        throws IllegalArgumentException, MathException;    /**     * Performs a      * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code>      * and <code>sample2</code> are drawn from populations with the same mean,      * with significance level <code>alpha</code>.  This test does not assume     * that the subpopulation variances are equal.  To perform the test assuming     * equal variances, use      * {@link #homoscedasticTTest(double[], double[], double)}.     * <p>     * Returns <code>true</code> iff the null hypothesis that the means are     * equal can be rejected with confidence <code>1 - alpha</code>.  To      * perform a 1-sided test, use <code>alpha * 2</code>     * <p>     * See {@link #t(double[], double[])} for the formula used to compute the     * t-statistic.  Degrees of freedom are approximated using the     * <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">     * Welch-Satterthwaite approximation.</a>         * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at     * the 95% level,  use      * <br><code>tTest(sample1, sample2, 0.05). </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code>,     * at the 99% level, first verify that the measured  mean of <code>sample 1</code>     * is less than the mean of <code>sample 2</code> and then use      * <br><code>tTest(sample1, sample2, 0.02) </code>     * </li></ol>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with      * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    public abstract boolean tTest(        double[] sample1,        double[] sample2,        double alpha)        throws IllegalArgumentException, MathException;    /**     * Performs a      * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code>      * and <code>sample2</code> are drawn from populations with the same mean,      * with significance level <code>alpha</code>,  assuming that the     * subpopulation variances are equal.  Use      * {@link #tTest(double[], double[], double)} to perform the test without     * the assumption of equal variances.     * <p>     * Returns <code>true</code> iff the null hypothesis that the means are     * equal can be rejected with confidence <code>1 - alpha</code>.  To      * perform a 1-sided test, use <code>alpha * 2.</code>  To perform the test     * without the assumption of equal subpopulation variances, use      * {@link #tTest(double[], double[], double)}.     * <p>     * A pooled variance estimate is used to compute the t-statistic. See     * {@link #t(double[], double[])} for the formula. The sum of the sample     * sizes minus 2 is used as the degrees of freedom.     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at     * the 95% level, use <br><code>tTest(sample1, sample2, 0.05). </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2, </code>     * at the 99% level, first verify that the measured mean of      * <code>sample 1</code> is less than the mean of <code>sample 2</code>     * and then use     * <br><code>tTest(sample1, sample2, 0.02) </code>     * </li></ol>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with      * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    public abstract boolean homoscedasticTTest(        double[] sample1,        double[] sample2,        double alpha)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or      * <i>p-value</i>, associated with a two-sample, two-tailed t-test      * comparing the means of the datasets described by two StatisticalSummary     * instances.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.      * For a one-sided test, divide the returned value by 2.     * <p>     * The test does not assume that the underlying popuation variances are     * equal  and it uses approximated degrees of freedom computed from the      * sample data to compute the p-value.   To perform the test assuming     * equal variances, use      * {@link #homoscedasticTTest(StatisticalSummary, StatisticalSummary)}.     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li></ul>     *     * @param sampleStats1  StatisticalSummary describing data from the first sample     * @param sampleStats2  StatisticalSummary describing data from the second sample     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    public abstract double tTest(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or      * <i>p-value</i>, associated with a two-sample, two-tailed t-test      * comparing the means of the datasets described by two StatisticalSummary     * instances, under the hypothesis of equal subpopulation variances. To     * perform a test without the equal variances assumption, use     * {@link #tTest(StatisticalSummary, StatisticalSummary)}.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.      * For a one-sided test, divide the returned value by 2.     * <p>     * See {@link #homoscedasticT(double[], double[])} for the formula used to     * compute the t-statistic. The sum of the  sample sizes minus 2 is used as     * the degrees of freedom.     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li></ul>     *     * @param sampleStats1  StatisticalSummary describing data from the first sample     * @param sampleStats2  StatisticalSummary describing data from the second sample     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    public abstract double homoscedasticTTest(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException, MathException;    /**     * Performs a      * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that      * <code>sampleStats1</code> and <code>sampleStats2</code> describe     * datasets drawn from populations with the same mean, with significance     * level <code>alpha</code>.   This test does not assume that the     * subpopulation variances are equal.  To perform the test under the equal     * variances assumption, use     * {@link #homoscedasticTTest(StatisticalSummary, StatisticalSummary)}.     * <p>     * Returns <code>true</code> iff the null hypothesis that the means are     * equal can be rejected with confidence <code>1 - alpha</code>.  To      * perform a 1-sided test, use <code>alpha * 2</code>     * <p>     * See {@link #t(double[], double[])} for the formula used to compute the     * t-statistic.  Degrees of freedom are approximated using the     * <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">     * Welch-Satterthwaite approximation.</a>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at     * the 95%, use      * <br><code>tTest(sampleStats1, sampleStats2, 0.05) </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code>     * at the 99% level,  first verify that the measured mean of       * <code>sample 1</code> is less than  the mean of <code>sample 2</code>     * and then use      * <br><code>tTest(sampleStats1, sampleStats2, 0.02) </code>     * </li></ol>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul>     *     * @param sampleStats1 StatisticalSummary describing sample data values     * @param sampleStats2 StatisticalSummary describing sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with      * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    public abstract boolean tTest(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2,        double alpha)        throws IllegalArgumentException, MathException;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.discovery.tools.DiscoverClass;/** * Abstract factory to create inference test instances. * * @since 1.1 * @version $Revision$ $Date$  */public abstract class TestFactory {    /**     * Default constructor.     */    protected TestFactory() {        super();    }        /**     * Create an instance of a <code>TestFactory</code>     *      * @return a new factory.      */    public static TestFactory newInstance() {        TestFactory factory = null;        try {            DiscoverClass dc = new DiscoverClass();            factory = (TestFactory) dc.newInstance(                    TestFactory.class,            "org.apache.commons.math.stat.inference.TestFactoryImpl");        } catch(Throwable t) {            return new TestFactoryImpl();        }        return factory;    }        /**     * Create a TTest instance.     *      * @return a new TTest instance     */    public abstract TTest createTTest();        /**     * Create a ChiSquareTest instance.     *      * @return a new ChiSquareTest instance     */    public abstract ChiSquareTest createChiSquareTest();  }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.MathException;import org.apache.commons.math.stat.descriptive.StatisticalSummary;/** * A collection of static methods to create inference test instances or to * perform inference tests. * * @since 1.1 * @version $Revision$ $Date$  */public class TestUtils  {    /**     * Prevent instantiation.     */    protected TestUtils() {        super();    }        /** Singleton TTest instance initialized using configured factory */    private static TTest tTest = TestFactory.newInstance().createTTest();       /** Singleton ChiSquareTest instance initialized using configured factory */    private static ChiSquareTest chiSquareTest =         TestFactory.newInstance().createChiSquareTest();        /**     * Return a (singleton) TTest instance.  Does not create a new instance.     *      * @return a TTest instance     */    public static TTest getTTest() {        return tTest;    }        /**     * Return a (singleton) ChiSquareTest instance.  Does not create a new instance.     *      * @return a ChiSquareTest instance     */    public static ChiSquareTest getChiSquareTest() {        return chiSquareTest;    }        /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticT(double[], double[])     */    public static double homoscedasticT(double[] sample1, double[] sample2)        throws IllegalArgumentException {        return tTest.homoscedasticT(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticT(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double homoscedasticT(StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException {        return tTest.homoscedasticT(sampleStats1, sampleStats2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticTTest(double[], double[], double)     */    public static boolean homoscedasticTTest(double[] sample1, double[] sample2,            double alpha)        throws IllegalArgumentException, MathException {        return tTest. homoscedasticTTest(sample1, sample2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticTTest(double[], double[])     */    public static double homoscedasticTTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException {        return tTest.homoscedasticTTest(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticTTest(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double homoscedasticTTest(StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException, MathException {        return tTest.homoscedasticTTest(sampleStats1, sampleStats2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#pairedT(double[], double[])     */    public static double pairedT(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException {        return tTest.pairedT(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#pairedTTest(double[], double[], double)     */    public static boolean pairedTTest(double[] sample1, double[] sample2,        double alpha)        throws IllegalArgumentException, MathException {        return tTest.pairedTTest(sample1, sample2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#pairedTTest(double[], double[])     */    public static double pairedTTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException {        return tTest.pairedTTest(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#t(double, double[])     */    public static double t(double mu, double[] observed)        throws IllegalArgumentException {        return tTest.t(mu, observed);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#t(double, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double t(double mu, StatisticalSummary sampleStats)        throws IllegalArgumentException {        return tTest.t(mu, sampleStats);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#t(double[], double[])     */    public static double t(double[] sample1, double[] sample2)        throws IllegalArgumentException {        return tTest.t(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#t(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double t(StatisticalSummary sampleStats1,            StatisticalSummary sampleStats2)        throws IllegalArgumentException {        return tTest.t(sampleStats1, sampleStats2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, double[], double)     */    public static boolean tTest(double mu, double[] sample, double alpha)        throws IllegalArgumentException, MathException {        return tTest.tTest(mu, sample, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, double[])     */    public static double tTest(double mu, double[] sample)        throws IllegalArgumentException, MathException {        return tTest.tTest(mu, sample);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, org.apache.commons.math.stat.descriptive.StatisticalSummary, double)     */    public static boolean tTest(double mu, StatisticalSummary sampleStats,        double alpha)        throws IllegalArgumentException, MathException {        return tTest. tTest(mu, sampleStats, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double tTest(double mu, StatisticalSummary sampleStats)        throws IllegalArgumentException, MathException {        return tTest.tTest(mu, sampleStats);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double[], double[], double)     */    public static boolean tTest(double[] sample1, double[] sample2, double alpha)        throws IllegalArgumentException, MathException {        return tTest.tTest(sample1, sample2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double[], double[])     */    public static double tTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException {        return tTest.tTest(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary, double)     */    public static boolean tTest(StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2, double alpha)        throws IllegalArgumentException, MathException {        return tTest. tTest(sampleStats1, sampleStats2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double tTest(StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException, MathException {        return tTest.tTest(sampleStats1, sampleStats2);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquare(double[], long[])     */    public static double chiSquare(double[] expected, long[] observed)        throws IllegalArgumentException {        return chiSquareTest.chiSquare(expected, observed);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquare(long[][])     */    public static double chiSquare(long[][] counts)         throws IllegalArgumentException {        return chiSquareTest.chiSquare(counts);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(double[], long[], double)     */    public static boolean chiSquareTest(double[] expected, long[] observed,        double alpha)        throws IllegalArgumentException, MathException {        return chiSquareTest.chiSquareTest(expected, observed, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(double[], long[])     */    public static double chiSquareTest(double[] expected, long[] observed)        throws IllegalArgumentException, MathException {        return chiSquareTest.chiSquareTest(expected, observed);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(long[][], double)     */    public static boolean chiSquareTest(long[][] counts, double alpha)        throws IllegalArgumentException, MathException {        return chiSquareTest. chiSquareTest(counts, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(long[][])     */    public static double chiSquareTest(long[][] counts)        throws IllegalArgumentException, MathException {        return chiSquareTest. chiSquareTest(counts);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;/** * A concrete inference test factory.  This is the default factory used by * Commons-Math. *   * @since 1.1 * @version $Revision$ $Date$ */public class TestFactoryImpl extends TestFactory {    /**     * Default constructor.      */    public TestFactoryImpl() {        super();    }         /**     * Create a TTest instance.     *      * @return a new TTest instance     */    public TTest createTTest() {               return new TTestImpl();    }        /**     * Create a ChiSquareTest instance.     *      * @return a new ChiSquareTest instance     */    public ChiSquareTest createChiSquareTest() {        return new ChiSquareTestImpl();    }    }