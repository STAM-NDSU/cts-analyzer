/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.special;import junit.framework.TestCase;/** * @author Brent Worden */public class BetaTest extends TestCase {    /**     * Constructor for BetaTest.     * @param name     */    public BetaTest(String name) {        super(name);    }    private void testRegularizedBeta(double expected, double x, double a, double b) {        double actual = Beta.regularizedBeta(x, a, b);        if (Double.isNaN(expected)) {            assertTrue(Double.isNaN(actual));        } else {            assertEquals(expected, actual, 10e-5);        }    }    private void testLogBeta(double expected, double a, double b) {        double actual = Beta.logBeta(a, b);        if (Double.isNaN(expected)) {            assertTrue(Double.isNaN(actual));        } else {            assertEquals(expected, actual, 10e-5);        }    }    public void testRegularizedBetaNanPositivePositive() {        testRegularizedBeta(Double.NaN, Double.NaN, 1.0, 1.0);    }    public void testRegularizedBetaPositiveNanPositive() {        testRegularizedBeta(Double.NaN, 0.5, Double.NaN, 1.0);    }    public void testRegularizedBetaPositivePositiveNan() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, Double.NaN);    }        public void testRegularizedBetaNegativePositivePositive() {        testRegularizedBeta(Double.NaN, -0.5, 1.0, 2.0);    }        public void testRegularizedBetaPositiveNegativePositive() {        testRegularizedBeta(Double.NaN, 0.5, -1.0, 2.0);    }        public void testRegularizedBetaPositivePositiveNegative() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, -2.0);    }        public void testRegularizedBetaZeroPositivePositive() {        testRegularizedBeta(0.0, 0.0, 1.0, 2.0);    }        public void testRegularizedBetaPositiveZeroPositive() {        testRegularizedBeta(Double.NaN, 0.5, 0.0, 2.0);    }        public void testRegularizedBetaPositivePositiveZero() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, 0.0);    }        public void testRegularizedBetaPositivePositivePositive() {        testRegularizedBeta(0.75, 0.5, 1.0, 2.0);    }        public void testLogBetaNanPositive() {        testLogBeta(Double.NaN, Double.NaN, 2.0);    }        public void testLogBetaPositiveNan() {        testLogBeta(Double.NaN, 1.0, Double.NaN);    }        public void testLogBetaNegativePositive() {        testLogBeta(Double.NaN, -1.0, 2.0);    }        public void testLogBetaPositiveNegative() {        testLogBeta(Double.NaN, 1.0, -2.0);    }        public void testLogBetaZeroPositive() {        testLogBeta(Double.NaN, 0.0, 2.0);    }        public void testLogBetaPositiveZero() {        testLogBeta(Double.NaN, 1.0, 0.0);    }        public void testLogBetaPositivePositive() {        testLogBeta(-0.693147, 1.0, 2.0);    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.special;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @author Brent Worden */public class GammaTest extends TestCase {    /**     * Constructor for BetaTest.     * @param name     */    public GammaTest(String name) {        super(name);    }    private void testRegularizedGamma(double expected, double a, double x) {        double actual = Gamma.regularizedGammaP(a, x);        TestUtils.assertEquals(expected, actual, 10e-5);    }    private void testLogGamma(double expected, double x) {        double actual = Gamma.logGamma(x);        TestUtils.assertEquals(expected, actual, 10e-5);    }    public void testRegularizedGammaNanPositive() {        testRegularizedGamma(Double.NaN, Double.NaN, 1.0);    }    public void testRegularizedGammaPositiveNan() {        testRegularizedGamma(Double.NaN, 1.0, Double.NaN);    }        public void testRegularizedGammaNegativePositive() {        testRegularizedGamma(Double.NaN, -1.5, 1.0);    }        public void testRegularizedGammaPositiveNegative() {        testRegularizedGamma(Double.NaN, 1.0, -1.0);    }        public void testRegularizedGammaZeroPositive() {        testRegularizedGamma(Double.NaN, 0.0, 1.0);    }        public void testRegularizedGammaPositiveZero() {        testRegularizedGamma(0.0, 1.0, 0.0);    }        public void testRegularizedGammaPositivePositive() {        testRegularizedGamma(0.632121, 1.0, 1.0);    }        public void testLogGammaNan() {        testLogGamma(Double.NaN, Double.NaN);    }        public void testLogGammaNegative() {        testLogGamma(Double.NaN, -1.0);    }        public void testLogGammaZero() {        testLogGamma(Double.NaN, 0.0);    }        public void testLogGammaPositive() {        testLogGamma(0.693147, 3.0);    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the TestStatistic class. * * @author Phil Steitz * @version $Revision: 1.2 $ $Date: 2003/06/11 03:33:05 $ */public final class BivariateRegressionTest extends TestCase {    /*      * NIST "Norris" refernce data set from      * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat     * Strangely, order is {y,x}     */    private double[][] data = {{0.1,0.2},{338.8,337.4},{118.1,118.2},        {888.0,884.6},{9.2,10.1},{228.1,226.5},{668.5,666.3},{998.5,996.3},        {449.1,448.6},{778.9,777.0},{559.2,558.2},{0.3,0.4},{0.1,0.6},        {778.1,775.5},{668.8,666.9},{339.3,338.0},{448.9,447.5},{10.8,11.6},        {557.7,556.0},{228.3,228.1},{998.0,995.8},{888.8,887.6},{119.6,120.2},        {0.3,0.3},{0.6,0.3},{557.6,556.8},{339.3,339.1},{888.0,887.2},        {998.5,999.0},{778.9,779.0},{10.2,11.1},{117.6,118.3},{228.9,229.2},        {668.4,669.1},{449.2,448.9},{0.2,0.5}};             /*      * Correlation example from      * http://www.xycoon.com/correlation.htm     */    private double[][] corrData = {{101.0,99.2},{100.1,99.0},{100.0,100.0},        {90.6,111.6},{86.5,122.2},{89.7,117.6},{90.6,121.1},{82.8,136.0},        {70.1,154.2},{65.4,153.6},{61.3,158.5},{62.5,140.6},{63.6,136.2},        {52.6,168.0},{59.7,154.3},{59.5,149.0},{61.3,165.5}};            /*     * From Moore and Mcabe, "Introduction to the Practice of Statistics"     * Example 10.3      */    private double[][] infData = {{15.6,5.2},{26.8,6.1},{37.8,8.7},{36.4,8.5},    {35.5,8.8},{18.6,4.9},{15.3,4.5},{7.9,2.5},{0.0,1.1}};        /*     * From http://www.xycoon.com/simple_linear_regression.htm     */    private double[][] infData2 = {{1,3},{2,5},{3,7},{4,14},{5,11}};        public BivariateRegressionTest(String name) {        super(name);    }        public void setUp() {     }    public static Test suite() {        TestSuite suite = new TestSuite(BivariateRegressionTest.class);        suite.setName("BivariateRegression Tests");        return suite;    }        public void testNorris() {       BivariateRegression regression = new BivariateRegression();       for (int i = 0; i < data.length; i++) {           regression.addData(data[i][1],data[i][0]);       }       assertEquals("slope",1.00211681802045,             regression.getSlope(),10E-12);       assertEquals("slope std err",0.429796848199937E-03,             regression.getSlopeStdErr(),10E-12);       assertEquals("number of observations",36,regression.getN());       assertEquals("intercept", -0.262323073774029,            regression.getIntercept(),10E-12);       assertEquals("std err intercept", 0.232818234301152,             regression.getInterceptStdErr(),10E-12);       assertEquals("r-square",0.999993745883712,            regression.getRSquare(),10E-12);       assertEquals("SSR",4255954.13232369,             regression.getRegressionSumSquares(),10E-8);       assertEquals("MSE",0.782864662630069,             regression.getMeanSquareError(),10E-8);       assertEquals("SSE",26.6173985294224,             regression.getSumSquaredErrors(),10E-8);       assertEquals("predict(0)",-0.262323073774029,            regression.predict(0),10E-12);       assertEquals("predict(1)",1.00211681802045-0.262323073774029,            regression.predict(1),10E-11);    }        public void testCorr() {       BivariateRegression regression = new BivariateRegression();       regression.addData(corrData);       assertEquals("number of observations",17,regression.getN());       assertEquals("r-square",.896123,            regression.getRSquare(),10E-6);       assertEquals("r",-.946638,             regression.getR(),10E-6);    }          public void testNaNs() {                BivariateRegression regression = new BivariateRegression();                assertTrue("intercept not NaN",Double.isNaN(regression.getIntercept()));        assertTrue("slope not NaN",Double.isNaN(regression.getSlope()));        assertTrue("slope std err not NaN",            Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN",            Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN",Double.isNaN(regression.getMeanSquareError()));        assertTrue("e not NaN",Double.isNaN(regression.getR()));        assertTrue("r-square not NaN",Double.isNaN(regression.getRSquare()));        assertTrue("RSS not NaN",            Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE not NaN",Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("SSTO not NaN",Double.isNaN(regression.getTotalSumSquares()));        assertTrue("predict not NaN",Double.isNaN(regression.predict(0)));                regression.addData(1,2);        regression.addData(1,3);                // No x variation, so these should still blow...        assertTrue("intercept not NaN",Double.isNaN(regression.getIntercept()));        assertTrue("slope not NaN",Double.isNaN(regression.getSlope()));        assertTrue("slope std err not NaN",            Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN",            Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN",Double.isNaN(regression.getMeanSquareError()));        assertTrue("e not NaN",Double.isNaN(regression.getR()));        assertTrue("r-square not NaN",Double.isNaN(regression.getRSquare()));        assertTrue("RSS not NaN",            Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE not NaN",Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("predict not NaN",Double.isNaN(regression.predict(0)));                // but SSTO should be OK         assertTrue("SSTO NaN",!Double.isNaN(regression.getTotalSumSquares()));                regression = new BivariateRegression();                regression.addData(1,2);        regression.addData(3,3);                // All should be OK except MSE, s(b0), s(b1) which need one more df         assertTrue("interceptNaN",!Double.isNaN(regression.getIntercept()));        assertTrue("slope NaN",!Double.isNaN(regression.getSlope()));        assertTrue("slope std err not NaN",            Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN",            Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN",Double.isNaN(regression.getMeanSquareError()));        assertTrue("r NaN",!Double.isNaN(regression.getR()));        assertTrue("r-square NaN",!Double.isNaN(regression.getRSquare()));        assertTrue("RSS NaN",            !Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE NaN",!Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("SSTO NaN",!Double.isNaN(regression.getTotalSumSquares()));        assertTrue("predict NaN",!Double.isNaN(regression.predict(0)));                regression.addData(1,4);                // MSE, MSE, s(b0), s(b1) should all be OK now        assertTrue("MSE NaN",!Double.isNaN(regression.getMeanSquareError()));        assertTrue("slope std err NaN",            !Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err NaN",            !Double.isNaN(regression.getInterceptStdErr()));    }        public void testClear() {       BivariateRegression regression = new BivariateRegression();       regression.addData(corrData);       assertEquals("number of observations",17,regression.getN());       regression.clear();       assertEquals("number of observations",0,regression.getN());       regression.addData(corrData);       assertEquals("r-square",.896123,regression.getRSquare(),10E-6);       regression.addData(data);       assertEquals("number of observations",53,regression.getN());    }        public void testInference() {       BivariateRegression regression = new BivariateRegression();       regression.addData(infData);       assertEquals("slope confidence interval", 0.0271,            regression.getSlopeConfidenceInterval(),0.0001);       assertEquals("slope std err",0.01146,            regression.getSlopeStdErr(),0.0001);              regression = new BivariateRegression();       regression.addData(infData2);       assertEquals("significance", 0.023331,            regression.getSignificance(),0.0001);              //FIXME: get a real example to test against with alpha = .01       assertTrue("tighter means wider",            regression.getSlopeConfidenceInterval() <             regression.getSlopeConfidenceInterval(0.01));              try {           double x = regression.getSlopeConfidenceInterval(1);           fail("expecting IllegalArgumentException for alpha = 1");       } catch (IllegalArgumentException ex) {           ;       }           }                                        }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.RandomDataImpl;import org.apache.commons.math.RandomData;/** * Test cases for the {@link Univariate} class. * * @author <a href="mailto:phil@steitz.com">Phil Steitz</a> * @version $Revision: 1.2 $ $Date: 2003/06/04 02:24:51 $ */public final class StoreUnivariateImplTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double skewness = 0;    private double kurtosis = 0.5;    private int kClass = StoreUnivariate.LEPTOKURTIC;    private double tolerance = 10E-15;        public StoreUnivariateImplTest(String name) {        super(name);    }        public void setUp() {      }        public static Test suite() {        TestSuite suite = new TestSuite(StoreUnivariateImplTest.class);        suite.setName("Freq Tests");        return suite;    }        /** test stats */    public void testStats() {        StoreUnivariate u = new StoreUnivariateImpl();         assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }             public void testN0andN1Conditions() throws Exception {    StoreUnivariate u = new StoreUnivariateImpl();                    assertTrue("Mean of n = 0 set should be NaN",                 Double.isNaN( u.getMean() ) );            assertTrue("Standard Deviation of n = 0 set should be NaN",                 Double.isNaN( u.getStandardDeviation() ) );            assertTrue("Variance of n = 0 set should be NaN",                Double.isNaN(u.getVariance() ) );            u.addValue(one);            assertTrue( "Mean of n = 1 set should be value of single item n1",                u.getMean() == one);            assertTrue( "StdDev of n = 1 set should be zero, instead it is: "                 + u.getStandardDeviation(), u.getStandardDeviation() == 0);            assertTrue( "Variance of n = 1 set should be zero",                 u.getVariance() == 0);    }        public void testSkewAndKurtosis() {    StoreUnivariate u = new StoreUnivariateImpl();        double[] testArray =         { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,          9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };    for( int i = 0; i < testArray.length; i++) {    u.addValue( testArray[i]);    }    assertEquals("mean", 12.40455, u.getMean(), 0.0001);assertEquals("variance", 10.00236, u.getVariance(), 0.0001);assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);    assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {    StoreUnivariateImpl u = new StoreUnivariateImpl();        u.setWindowSize(10);                u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        assertEquals( "Product not expected",             24.0, u.getProduct(), Double.MIN_VALUE );        assertEquals( "Geometric mean not expected",             2.213364, u.getGeometricMean(), 0.00001 );        // Now test rolling - UnivariateImpl should discount the contribution        // of a discarded element        for( int i = 0; i < 10; i++ ) {            u.addValue( i + 2 );        }        // Values should be (2,3,4,5,6,7,8,9,10,11)                assertEquals( "Product not expected", 39916800.0,             u.getProduct(), 0.00001 );        assertEquals( "Geometric mean not expected", 5.755931,             u.getGeometricMean(), 0.00001 );    }        public void testGetSortedValues() {        double[] test1 = {5,4,3,2,1};        double[] test2 = {5,2,1,3,4,0};        double[] test3 = {1};        int[] testi = null;        double[] test4 = null;        RandomData rd = new RandomDataImpl();        tstGetSortedValues(test1);        tstGetSortedValues(test2);        tstGetSortedValues(test3);        for (int i = 0; i < 10; i++) {            testi = rd.nextPermutation(10,6);            test4 = new double[6];            for (int j = 0; j < testi.length; j++) {                test4[j] = (double) testi[j];            }            tstGetSortedValues(test4);        }        for (int i = 0; i < 10; i++) {            testi = rd.nextPermutation(10,5);            test4 = new double[5];            for (int j = 0; j < testi.length; j++) {                test4[j] = (double) testi[j];            }            tstGetSortedValues(test4);        }            }                private void tstGetSortedValues(double[] test) {        StoreUnivariateImpl u = new StoreUnivariateImpl();        for (int i = 0; i < test.length; i++) {            u.addValue(test[i]);        }        double[] sorted = u.getSortedValues();        if (sorted.length != test.length) {            fail("wrong length for sorted values array");        }        for (int i = 0; i < sorted.length-1; i++) {            if (sorted[i] > sorted[i+1]) {                fail("sorted values out of sequence");            }        }    }        public void testPercentiles() {        double[] test = {5,4,3,2,1};        StoreUnivariateImpl u = new StoreUnivariateImpl();        for (int i = 0; i < test.length; i++) {            u.addValue(test[i]);        }        assertEquals("expecting min",1,u.getPercentile(5),10E-12);        assertEquals("expecting max",5,u.getPercentile(99),10E-12);        assertEquals("expecting middle",3,u.getPercentile(50),10E-12);        try {            double x = u.getPercentile(0);            fail("expecting IllegalArgumentException for getPercentile(0)");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = u.getPercentile(120);            fail("expecting IllegalArgumentException for getPercentile(120)");        } catch (IllegalArgumentException ex) {            ;        }                u.clear();        double[] test2 = {1,2,3,4};        for (int i = 0; i < test2.length; i++) {            u.addValue(test2[i]);        }        assertEquals("Q1",1.25,u.getPercentile(25),10E-12);        assertEquals("Q3",3.75,u.getPercentile(75),10E-12);        assertEquals("Q2",2.5,u.getPercentile(50),10E-12);                u.clear();        double[] test3 = {1};        for (int i = 0; i < test3.length; i++) {            u.addValue(test3[i]);        }        assertEquals("Q1",1,u.getPercentile(25),10E-12);        assertEquals("Q3",1,u.getPercentile(75),10E-12);        assertEquals("Q2",1,u.getPercentile(50),10E-12);                u.clear();        RandomData rd = new RandomDataImpl();        int[] testi = rd.nextPermutation(100,100); // will contain 0-99        for (int j = 0; j < testi.length; j++) {            u.addValue((double) testi[j]);  //OK, laugh at me for the cast        }        for (int i = 1; i < 100; i++) {            assertEquals("percentile " + i,                (double) i-1 + (double) i*(.01), u.getPercentile(i),10E-12);        }                u.clear();        double[] test4 = {1,2,3,4,100};        for (int i = 0; i < test4.length; i++) {            u.addValue(test4[i]);        }        assertEquals("80th",80.8,u.getPercentile(80),10E-12);                u.clear();        assertTrue("empty value set should return NaN",            Double.isNaN(u.getPercentile(50)));    }                                     }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStreamReader;import org.apache.commons.logging.*;/** * Test cases for the {@link Univariate} class. * * @author Mark R. Diggory * @version $Revision: 1.6 $ $Date: 2003/06/16 14:29:30 $ */public class CertifiedDataTest extends TestCase {protected Univariate u = null;protected double mean = Double.NaN;protected double std = Double.NaN;protected Log log = LogFactory.getLog(this.getClass());/** * Certified Data Test Constructor * @param name */public CertifiedDataTest(String name) {super(name);}/* (non-Javadoc) * @see junit.framework.TestCase#setUp() */public void setUp() {}/** * @return The test suite */public static Test suite() {TestSuite suite = new TestSuite(CertifiedDataTest.class);suite.setName("Certified Tests");return suite;}/** * Test UnivariateImpl*/public void testUnivariateImpl() {u = new UnivariateImpl();loadStats("data/Lew.txt");assertEquals("Lew: std", std, u.getStandardDeviation(), .000000000001);assertEquals("Lew: mean", mean, u.getMean(), .000000000001);loadStats("data/Lottery.txt");assertEquals("Lottery: std", std, u.getStandardDeviation(), .000000000001);assertEquals("Lottery: mean", mean, u.getMean(), .000000000001);loadStats("data/PiDigits.txt");assertEquals("PiDigits: std", std, u.getStandardDeviation(), .0000000000001);assertEquals("PiDigits: mean", mean, u.getMean(), .0000000000001);loadStats("data/Mavro.txt");assertEquals("Mavro: std", std, u.getStandardDeviation(), .00000000000001);assertEquals("Mavro: mean", mean, u.getMean(), .00000000000001);//loadStats("data/Michelso.txt");//assertEquals("Michelso: std", std, u.getStandardDeviation(), .00000000000001);//assertEquals("Michelso: mean", mean, u.getMean(), .00000000000001);loadStats("data/NumAcc1.txt");assertEquals("NumAcc1: std", std, u.getStandardDeviation(), .00000000000001);assertEquals("NumAcc1: mean", mean, u.getMean(), .00000000000001);//loadStats("data/NumAcc2.txt");//assertEquals("NumAcc2: std", std, u.getStandardDeviation(), .000000001);//assertEquals("NumAcc2: mean", mean, u.getMean(), .00000000000001);}/** * Test UnivariateImpl */public void testStoredUnivariateImpl() {u = new StoreUnivariateImpl();loadStats("data/Lew.txt");assertEquals("Lew: std", std, u.getStandardDeviation(), .000000000001);assertEquals("Lew: mean", mean, u.getMean(), .000000000001);loadStats("data/Lottery.txt");assertEquals("Lottery: std", std, u.getStandardDeviation(), .000000000001);assertEquals("Lottery: mean", mean, u.getMean(), .000000000001);  loadStats("data/PiDigits.txt");assertEquals("PiDigits: std", std, u.getStandardDeviation(), .0000000000001);assertEquals("PiDigits: mean", mean, u.getMean(), .0000000000001);loadStats("data/Mavro.txt");assertEquals("Mavro: std", std, u.getStandardDeviation(), .00000000000001);assertEquals("Mavro: mean", mean, u.getMean(), .00000000000001);//loadStats("data/Michelso.txt");//assertEquals("Michelso: std", std, u.getStandardDeviation(), .00000000000001);//assertEquals("Michelso: mean", mean, u.getMean(), .00000000000001);loadStats("data/NumAcc1.txt");assertEquals("NumAcc1: std", std, u.getStandardDeviation(), .00000000000001);assertEquals("NumAcc1: mean", mean, u.getMean(), .00000000000001);//loadStats("data/NumAcc2.txt");//assertEquals("NumAcc2: std", std, u.getStandardDeviation(), .000000001);//assertEquals("NumAcc2: mean", mean, u.getMean(), .00000000000001);}/** * loads a Univariate off of a test file * @param file */private void loadStats(String resource) {try {u.clear();mean = Double.NaN;std = Double.NaN;BufferedReader in =new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(resource)));String line = null;for (int j = 0; j < 60; j++) {line = in.readLine();if (j == 40) {mean =Double.parseDouble(line.substring(line.lastIndexOf(":") + 1).trim());}if (j == 41) {std =Double.parseDouble(line.substring(line.lastIndexOf(":") + 1).trim());}}line = in.readLine();while (line != null) {u.addValue(Double.parseDouble(line.trim()));line = in.readLine();}in.close();} catch (FileNotFoundException fnfe) {log.error(fnfe.getMessage(), fnfe);} catch (IOException ioe) {log.error(ioe.getMessage(), ioe);}}}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat;import java.util.ArrayList;import java.util.List;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link Univariate} class. * * @author <a href="mailto:phil@steitz.com">Phil Steitz</a> * @version $Revision: 1.1 $ $Date: 2003/05/29 20:35:46 $ */public final class ListUnivariateImplTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double skewness = 0;    private double kurtosis = 0.5;    private int kClass = StoreUnivariate.LEPTOKURTIC;    private double tolerance = 10E-15;        public ListUnivariateImplTest(String name) {        super(name);    }        public void setUp() {      }        public static Test suite() {        TestSuite suite = new TestSuite(ListUnivariateImplTest.class);        suite.setName("Freq Tests");        return suite;    }        /** test stats */    public void testStats() {    List externalList = new ArrayList();            StoreUnivariate u = new ListUnivariateImpl( externalList );         assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }             public void testN0andN1Conditions() throws Exception {    List list = new ArrayList();        StoreUnivariate u = new ListUnivariateImpl( list );        assertTrue("Mean of n = 0 set should be NaN", Double.isNaN( u.getMean() ) );assertTrue("Standard Deviation of n = 0 set should be NaN", Double.isNaN( u.getStandardDeviation() ) );assertTrue("Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance() ) );list.add( new Double(one));assertTrue( "Mean of n = 1 set should be value of single item n1", u.getMean() == one);assertTrue( "StdDev of n = 1 set should be zero, instead it is: " + u.getStandardDeviation(), u.getStandardDeviation() == 0);assertTrue( "Variance of n = 1 set should be zero", u.getVariance() == 0);    }        public void testSkewAndKurtosis() {    StoreUnivariate u = new StoreUnivariateImpl();        double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,     9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };    for( int i = 0; i < testArray.length; i++) {    u.addValue( testArray[i]);    }    assertEquals("mean", 12.40455, u.getMean(), 0.0001);assertEquals("variance", 10.00236, u.getVariance(), 0.0001);assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);    assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {    ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());        u.setWindowSize(10);                u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        assertEquals( "Product not expected", 24.0, u.getProduct(), Double.MIN_VALUE );        assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001 );        // Now test rolling - UnivariateImpl should discount the contribution        // of a discarded element        for( int i = 0; i < 10; i++ ) {            u.addValue( i + 2 );        }        // Values should be (2,3,4,5,6,7,8,9,10,11)                assertEquals( "Product not expected", 39916800.0, u.getProduct(), 0.00001 );        assertEquals( "Geometric mean not expected", 5.755931, u.getGeometricMean(), 0.00001 );    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link Univariate} class. * * @author Phil Steitz * @author Tim Obrien * @version $Revision: 1.1 $ $Date: 2003/05/29 20:35:46 $ */public final class UnivariateImplTest extends TestCase {    private double one = 1;    private float twoF = 2;    private long twoL = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double tolerance = 10E-15;        public UnivariateImplTest(String name) {        super(name);    }        public void setUp() {      }        public static Test suite() {        TestSuite suite = new TestSuite(UnivariateImplTest.class);        suite.setName("Freq Tests");        return suite;    }        /** test stats */    public void testStats() {        UnivariateImpl u = new UnivariateImpl();         assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(twoF);        u.addValue(twoL);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }             public void testN0andN1Conditions() throws Exception {    UnivariateImpl u = new UnivariateImpl();        assertTrue("Mean of n = 0 set should be NaN",             Double.isNaN( u.getMean() ) );assertTrue("Standard Deviation of n = 0 set should be NaN",             Double.isNaN( u.getStandardDeviation() ) );assertTrue("Variance of n = 0 set should be NaN",             Double.isNaN(u.getVariance() ) );assertTrue("skew of n = 0 set should be NaN",Double.isNaN(u.getSkewness() ) );assertTrue("kurtosis of n = 0 set should be NaN", Double.isNaN(u.getKurtosis() ) );/* n=1 */u.addValue(one);assertTrue("mean should be one (n = 1)", u.getMean() == one);assertTrue("geometric should be one (n = 1)", u.getGeometricMean() == one);assertTrue("Std should be zero (n = 1)", u.getStandardDeviation() == 0.0);assertTrue("variance should be zero (n = 1)", u.getVariance() == 0.0);assertTrue("skew should be zero (n = 1)", u.getSkewness() == 0.0);assertTrue("kurtosis should be zero (n = 1)", u.getKurtosis() == 0.0);/* n=2 */u.addValue(twoF);assertTrue("Std should not be zero (n = 2)", u.getStandardDeviation() != 0.0);assertTrue("variance should not be zero (n = 2)", u.getVariance() != 0.0);assertTrue("skew should not be zero (n = 2)", u.getSkewness() == 0.0);assertTrue("kurtosis should be zero (n = 2)", u.getKurtosis() == 0.0);/* n=3 */u.addValue(twoL);assertTrue("skew should not be zero (n = 3)", u.getSkewness() != 0.0);assertTrue("kurtosis should be zero (n = 3)", u.getKurtosis() == 0.0);        /* n=4 */u.addValue(three);assertTrue("kurtosis should not be zero (n = 4)", u.getKurtosis() != 0.0);                        }    public void testProductAndGeometricMean() throws Exception {    UnivariateImpl u = new UnivariateImpl(10);                u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        assertEquals( "Product not expected", 24.0, u.getProduct(),            Double.MIN_VALUE );        assertEquals( "Geometric mean not expected", 2.213364,             u.getGeometricMean(), 0.00001 );        // Now test rolling - UnivariateImpl should discount the contribution        // of a discarded element        for( int i = 0; i < 10; i++ ) {            u.addValue( i + 2 );        }        // Values should be (2,3,4,5,6,7,8,9,10,11)                assertEquals( "Product not expected", 39916800.0,             u.getProduct(), 0.00001 );        assertEquals( "Geometric mean not expected", 5.755931,             u.getGeometricMean(), 0.00001 );    }        public void testRollingMinMax() {        UnivariateImpl u = new UnivariateImpl(3);        u.addValue( 1.0 );        u.addValue( 5.0 );        u.addValue( 3.0 );        u.addValue( 4.0 ); // discarding min        assertEquals( "min not expected", 3.0,             u.getMin(), Double.MIN_VALUE);        u.addValue(1.0);  // discarding max        assertEquals( "max not expected", 4.0,             u.getMax(), Double.MIN_VALUE);    }        public void testNaNContracts() {        UnivariateImpl u = new UnivariateImpl();        double nan = Double.NaN;        assertTrue("mean not NaN",Double.isNaN(u.getMean()));         assertTrue("min not NaN",Double.isNaN(u.getMin()));         assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation()));         assertTrue("var not NaN",Double.isNaN(u.getVariance()));         assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));                u.addValue(1.0);                assertEquals( "mean not expected", 1.0,             u.getMean(), Double.MIN_VALUE);        assertEquals( "variance not expected", 0.0,             u.getVariance(), Double.MIN_VALUE);        assertEquals( "geometric mean not expected", 1.0,             u.getGeometricMean(), Double.MIN_VALUE);                u.addValue(-1.0);                assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));                u.addValue(0.0);                assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));                //FiXME: test all other NaN contract specs    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat;import java.util.ArrayList;import java.util.List;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.beans.*;/** * Test cases for the {@link BeanListUnivariateImpl} class. * * @author <a href="mailto:tobrien@apache.org">Tim O'Brien</a> * @version $Revision: 1.1 $ $Date: 2003/05/29 20:35:46 $ */public final class BeanListUnivariateImplTest extends TestCase {        private List patientList = null;    private double tolerance = Double.MIN_VALUE;        public BeanListUnivariateImplTest(String name) {        super(name);    }        public void setUp() {          patientList = new ArrayList();        // Create and add patient bean 1        VitalStats vs1 = new VitalStats( new Double(120.0),                                          new Double(96.4) );        Patient p1 = new Patient( vs1, new Integer( 35 ) );        patientList.add( p1 );        // Create and add patient bean 2        VitalStats vs2 = new VitalStats( new Double(70.0),                                          new Double(97.4) );        Patient p2 = new Patient( vs2, new Integer( 23 ) );        patientList.add( p2 );        // Create and add patient bean 3        VitalStats vs3 = new VitalStats( new Double(90.0),                                          new Double(98.6) );        Patient p3 = new Patient( vs3, new Integer( 42 ) );        patientList.add( p3 );    }        public static Test suite() {        TestSuite suite = new TestSuite(BeanListUnivariateImplTest.class);        suite.setName("Freq Tests");        return suite;    }        /** test stats */    public void testStats() {            StoreUnivariate u = new BeanListUnivariateImpl( patientList );         assertEquals("total count",3,u.getN(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }             public void testPropStats() {        StoreUnivariate heartU = new BeanListUnivariateImpl( patientList,                                          "vitalStats.heartRate" );                assertEquals( "Mean heart rate unexpected", 93.333,                       heartU.getMean(), 0.001 );        assertEquals( "Max heart rate unexpected", 120.0,                       heartU.getMax(), 0.001 );        StoreUnivariate ageU = new BeanListUnivariateImpl( patientList,                                                           "age" );        assertEquals( "Mean age unexpected", 33.333,                      ageU.getMean(), 0.001 );        assertEquals( "Max age unexpected", 42.0,                      ageU.getMax(), 0.001 );    }    /*    public void testN0andN1Conditions() throws Exception {    List list = new ArrayList();        StoreUnivariate u = new ListUnivariateImpl( list );        assertTrue("Mean of n = 0 set should be NaN", Double.isNaN( u.getMean() ) );assertTrue("Standard Deviation of n = 0 set should be NaN", Double.isNaN( u.getStandardDeviation() ) );assertTrue("Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance() ) );list.add( new Double(one));assertTrue( "Mean of n = 1 set should be value of single item n1", u.getMean() == one);assertTrue( "StdDev of n = 1 set should be zero, instead it is: " + u.getStandardDeviation(), u.getStandardDeviation() == 0);assertTrue( "Variance of n = 1 set should be zero", u.getVariance() == 0);    }        public void testSkewAndKurtosis() {    StoreUnivariate u = new StoreUnivariateImpl();        double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,     9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };    for( int i = 0; i < testArray.length; i++) {    u.addValue( testArray[i]);    }    assertEquals("mean", 12.40455, u.getMean(), 0.0001);assertEquals("variance", 10.00236, u.getVariance(), 0.0001);assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);    assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {    ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());        u.setWindowSize(10);                u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        assertEquals( "Product not expected", 24.0, u.getProduct(), Double.MIN_VALUE );        assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001 );        // Now test rolling - UnivariateImpl should discount the contribution        // of a discarded element        for( int i = 0; i < 10; i++ ) {            u.addValue( i + 2 );        }        // Values should be (2,3,4,5,6,7,8,9,10,11)                assertEquals( "Product not expected", 39916800.0, u.getProduct(), 0.00001 );        assertEquals( "Geometric mean not expected", 5.755931, u.getGeometricMean(), 0.00001 );        } */}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link StatUtils} class. * * @author <a href="mailto:phil@steitz.com">Phil Steitz</a> * @author <a href="mailto:mdiggory@apache.org">Mark Diggory</a> * @version $Revision: 1.1 $ $Date: 2003/06/18 15:59:55 $ */public final class StatUtilsTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double skewness = 0;    private double kurtosis = 0.5;    private int kClass = StoreUnivariate.LEPTOKURTIC;    private double tolerance = 10E-15;    public StatUtilsTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(StatUtilsTest.class);        suite.setName("StatUtil Tests");        return suite;    }    /** test stats */    public void testStats() {        double[] values = new double[] { one, two, two, three };        assertEquals("sum", sum, StatUtils.sum(values), tolerance);        assertEquals("sumsq", sumSq, StatUtils.sumSq(values), tolerance);        assertEquals("var", var, StatUtils.variance(values), tolerance);        assertEquals(            "std",            std,            StatUtils.standardDeviation(values),            tolerance);        assertEquals("mean", mean, StatUtils.mean(values), tolerance);        assertEquals("min", min, StatUtils.min(values), tolerance);        assertEquals("max", max, StatUtils.max(values), tolerance);    }    public void testN0andN1Conditions() throws Exception {        double[] values = new double[0];        assertTrue(            "Mean of n = 0 set should be NaN",            Double.isNaN(StatUtils.mean(values)));        assertTrue(            "Standard Deviation of n = 0 set should be NaN",            Double.isNaN(StatUtils.standardDeviation(values)));        assertTrue(            "Variance of n = 0 set should be NaN",            Double.isNaN(StatUtils.variance(values)));        values = new double[] { one };        assertTrue(            "Mean of n = 1 set should be value of single item n1",            StatUtils.mean(values) == one);        assertTrue(            "StdDev of n = 1 set should be zero, instead it is: "                + StatUtils.standardDeviation(values),            StatUtils.standardDeviation(values) == 0);        assertTrue(            "Variance of n = 1 set should be zero",            StatUtils.variance(values) == 0);    }    public void testSkewAndKurtosis() {        double[] values =            {                12.5,                12,                11.8,                14.2,                14.9,                14.5,                21,                8.2,                10.3,                11.3,                14.1,                9.9,                12.2,                12,                12.1,                11,                19.8,                11,                10,                8.8,                9,                12.3 };        assertEquals("mean", 12.40455, StatUtils.mean(values), 0.0001);        assertEquals("variance", 10.00236, StatUtils.variance(values), 0.0001);        assertEquals("skewness", 1.437424, StatUtils.skewness(values), 0.0001);        assertEquals("kurtosis", 2.37719, StatUtils.kurtosis(values), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {        double[] values = { 1.0, 2.0, 3.0, 4.0 };        assertEquals(            "Product not expected",            24.0,            StatUtils.product(values),            Double.MIN_VALUE);        assertEquals(            "Geometric mean not expected",            2.213364,            StatUtils.geometricMean(values),            0.00001);    }}
package org.apache.commons.math.stat.distribution;import junit.framework.TestCase;/** * @author Brent Worden */public class DistributionFactoryImplTest extends TestCase {    /** */    private DistributionFactory factory;    /** * Constructor for DistributionFactoryImplTest. * @param name */public DistributionFactoryImplTest(String name) {super(name);}/** * @throws java.lang.Exception */protected void setUp() throws Exception {super.setUp();        factory = new DistributionFactoryImpl();}/** * @throws java.lang.Exception */protected void tearDown() throws Exception {        factory = null;super.tearDown();}        public void testCreateChiSquareDistributionNegative(){        try {            factory.createChiSquareDistribution(-1.0);            fail("negative degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateChiSquareDistributionZero(){        try {            factory.createChiSquareDistribution(0.0);            fail("zero degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateChiSquareDistributionPositive(){        try {            factory.createChiSquareDistribution(1.0);        } catch (IllegalArgumentException ex) {            fail("positive degrees of freedom.  IllegalArgumentException is not expected");        }    }        public void testCreateFDistributionNegativePositive(){        try {            factory.createFDistribution(-1.0, 1.0);            fail("negative degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateFDistributionZeroPositive(){        try {            factory.createFDistribution(0.0, 1.0);            fail("zero degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateFDistributionPositiveNegative(){        try {            factory.createFDistribution(1.0, -1.0);            fail("negative degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateFDistributionPositiveZero(){        try {            factory.createFDistribution(1.0, 0.0);            fail("zero degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateFDistributionPositivePositive(){        try {            factory.createFDistribution(1.0, 1.0);        } catch (IllegalArgumentException ex) {            fail("positive degrees of freedom.  IllegalArgumentException is not expected");        }    }        public void testCreateExponentialDistributionNegative(){        try {            factory.createExponentialDistribution(-1.0);            fail("negative mean.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateExponentialDistributionZero(){        try {            factory.createExponentialDistribution(0.0);            fail("zero mean.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateExponentialDistributionPositive(){        try {            factory.createExponentialDistribution(1.0);        } catch (IllegalArgumentException ex) {            fail("positive mean.  IllegalArgumentException is not expected");        }    }        public void testCreateGammaDistributionNegativePositive(){        try {            factory.createGammaDistribution(-1.0, 1.0);            fail("negative alpha.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateGammaDistributionZeroPositive(){        try {            factory.createGammaDistribution(0.0, 1.0);            fail("zero alpha.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateGammaDistributionPositiveNegative(){        try {            factory.createGammaDistribution(1.0, -1.0);            fail("negative beta.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateGammaDistributionPositiveZero(){        try {            factory.createGammaDistribution(1.0, 0.0);            fail("zero beta.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateGammaDistributionPositivePositive(){        try {            factory.createGammaDistribution(1.0, 1.0);        } catch (IllegalArgumentException ex) {            fail("positive alpah and beta.  IllegalArgumentException is not expected");        }    }        public void testCreateTDistributionNegative(){        try {            factory.createTDistribution(-1.0);            fail("negative degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateTDistributionZero(){        try {            factory.createTDistribution(0.0);            fail("zero degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateTDistributionPositive(){        try {            factory.createTDistribution(1.0);        } catch (IllegalArgumentException ex) {            fail("positive degrees of freedom.  IllegalArgumentException is not expected");        }    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat.distribution;import junit.framework.TestCase;/** * @author Brent Worden */public class TDistributionTest extends TestCase {    private TDistribution t;        /**     * Constructor for ChiSquareDistributionTest.     * @param name     */    public TDistributionTest(String name) {        super(name);    }    /*     * @see TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        t = DistributionFactory.newInstance().createTDistribution(5.0);    }    /*     * @see TestCase#tearDown()     */    protected void tearDown() throws Exception {        t = null;        super.tearDown();    }    public void testInverseCummulativeProbability001() {        testValue(-5.893, .001);    }        public void testInverseCumulativeProbability010() {        testValue(-3.365, .010);    }        public void testInverseCumulativeProbability025() {        testValue(-2.571, .025);    }    public void testInverseCumulativeProbability050() {        testValue(-2.015, .050);    }        public void testInverseCumulativeProbability100() {        testValue(-1.476, .100);    }    public void testInverseCummulativeProbability999() {        testValue(5.893, .999);    }        public void testInverseCumulativeProbability990() {        testValue(3.365, .990);    }        public void testInverseCumulativeProbability975() {        testValue(2.571, .975);    }    public void testInverseCumulativeProbability950() {        testValue(2.015, .950);    }        public void testInverseCumulativeProbability900() {        testValue(1.476, .900);    }    public void testCummulativeProbability001() {        testProbability(-5.893, .001);    }        public void testCumulativeProbability010() {        testProbability(-3.365, .010);    }        public void testCumulativeProbability025() {        testProbability(-2.571, .025);    }    public void testCumulativeProbability050() {        testProbability(-2.015, .050);    }        public void testCumulativeProbability100() {        testProbability(-1.476, .100);    }    public void testCummulativeProbability999() {        testProbability(5.893, .999);    }        public void testCumulativeProbability990() {        testProbability(3.365, .990);    }        public void testCumulativeProbability975() {        testProbability(2.571, .975);    }    public void testCumulativeProbability950() {        testProbability(2.015, .950);    }        public void testCumulativeProbability900() {        testProbability(1.476, .900);    }        private void testProbability(double x, double expected){        double actual = t.cummulativeProbability(x);        assertEquals(expected, actual, 10e-4);    }        private void testValue(double expected, double p){        double actual = t.inverseCummulativeProbability(p);        assertEquals(expected, actual, 10e-4);    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat.distribution;import junit.framework.TestCase;/** * @author Brent Worden */public class FDistributionTest extends TestCase {    private FDistribution f;        /**     * Constructor for ChiSquareDistributionTest.     * @param name     */    public FDistributionTest(String name) {        super(name);    }    /*     * @see TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        f = DistributionFactory.newInstance().createFDistribution(5.0, 6.0);    }    /*     * @see TestCase#tearDown()     */    protected void tearDown() throws Exception {        f = null;        super.tearDown();    }    public void testLowerTailProbability(){        testProbability(1.0 / 10.67, .010);        testProbability(1.0 /  6.98, .025);        testProbability(1.0 /  4.95, .050);        testProbability(1.0 /  3.40, .100);    }    public void testUpperTailProbability(){        testProbability(8.75, .990);        testProbability(5.99, .975);        testProbability(4.39, .950);        testProbability(3.11, .900);    }        public void testLowerTailValues(){        testValue(1.0 / 10.67, .010);        testValue(1.0 /  6.98, .025);        testValue(1.0 /  4.95, .050);        testValue(1.0 /  3.40, .100);    }        public void testUpperTailValues(){        testValue(8.75, .990);        testValue(5.99, .975);        testValue(4.39, .950);        testValue(3.11, .900);    }        private void testProbability(double x, double expected){        double actual = f.cummulativeProbability(x);        assertEquals("probability for " + x, expected, actual, 1e-3);    }        private void testValue(double expected, double p){        double actual = f.inverseCummulativeProbability(p);        assertEquals("value for " + p, expected, actual, 1e-2);    }}
package org.apache.commons.math.stat.distribution;import junit.framework.TestCase;/** * @author Brent Worden */public class GammaDistributionTest extends TestCase {/** * Constructor for ChiSquareDistributionTest. * @param name */public GammaDistributionTest(String name) {super(name);}    public void testProbabilities(){        testProbability(15.5, 4.0, 2.0, .9499);        testProbability( 0.5, 4.0, 1.0, .0018);        testProbability(10.0, 1.0, 2.0, .9933);        testProbability( 5.0, 2.0, 2.0, .7127);    }        private void testProbability(double x, double a, double b, double expected){        double actual = DistributionFactory.newInstance().createGammaDistribution(a, b).cummulativeProbability(x);        assertEquals("probability for " + x, expected, actual, 10e-4);    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat.distribution;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @author Brent Worden */public class ExponentialDistributionTest extends TestCase {    private ExponentialDistribution exp;        /**     * Constructor for ChiSquareDistributionTest.     * @param name     */    public ExponentialDistributionTest(String name) {        super(name);    }    /*     * @see TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        exp = DistributionFactory.newInstance().createExponentialDistribution(5.0);    }    /*     * @see TestCase#tearDown()     */    protected void tearDown() throws Exception {        exp = null;        super.tearDown();    }    public void testInverseCummulativeProbability001() {        testValue(.005003, .001);    }        public void testInverseCummulativeProbability010() {        testValue(0.050252, .010);    }        public void testInverseCummulativeProbability025() {        testValue(0.126589, .025);    }    public void testInverseCummulativeProbability050() {        testValue(0.256566, .050);    }        public void testInverseCummulativeProbability100() {        testValue(0.526803, .100);    }    public void testInverseCummulativeProbability999() {        testValue(34.5388, .999);    }        public void testInverseCummulativeProbability990() {        testValue(23.0259, .990);    }        public void testInverseCummulativeProbability975() {        testValue(18.4444, .975);    }    public void testInverseCummulativeProbability950() {        testValue(14.9787, .950);    }        public void testInverseCummulativeProbability900() {        testValue(11.5129, .900);    }    public void testCummulativeProbability001() {        testProbability(0.005003, .001);    }        public void testCummulativeProbability010() {        testProbability(0.050252, .010);    }        public void testCummulativeProbability025() {        testProbability(0.126589, .025);    }    public void testCummulativeProbability050() {        testProbability(0.256566, .050);    }        public void testCummulativeProbability100() {        testProbability(0.526803, .100);    }    public void testCummulativeProbability999() {        testProbability(34.5388, .999);    }        public void testCummulativeProbability990() {        testProbability(23.0259, .990);    }        public void testCummulativeProbability975() {        testProbability(18.4444, .975);    }    public void testCummulativeProbability950() {        testProbability(14.9787, .950);    }        public void testCummulativeProbability900() {        testProbability(11.5129, .900);    }    public void testCummulativeProbabilityNegative() {        testProbability(-1.0, 0.0);    }    public void testCummulativeProbabilityZero() {        testProbability(0.0, 0.0);    }    public void testInverseCummulativeProbabilityNegative() {        testValue(Double.NaN, -1.0);    }    public void testInverseCummulativeProbabilityZero() {        testValue(0.0, 0.0);    }    public void testInverseCummulativeProbabilityOne() {        testValue(Double.POSITIVE_INFINITY, 1.0);    }    public void testInverseCummulativeProbabilityPositive() {        testValue(Double.NaN, 2.0);    }        public void testCummulativeProbability2() {        double actual = exp.cummulativeProbability(0.25, 0.75);        assertEquals(0.0905214, actual, 10e-4);    }        private void testProbability(double x, double expected){        double actual = exp.cummulativeProbability(x);        TestUtils.assertEquals(expected, actual, 10e-4);    }        private void testValue(double expected, double p){        double actual = exp.inverseCummulativeProbability(p);        TestUtils.assertEquals(expected, actual, 10e-4);    }}
package org.apache.commons.math.stat.distribution;import junit.framework.TestCase;/** * @author Brent Worden */public class ChiSquareDistributionTest extends TestCase {    private ChiSquaredDistribution chiSquare;    /** * Constructor for ChiSquareDistributionTest. * @param name */public ChiSquareDistributionTest(String name) {super(name);}/* * @see TestCase#setUp() */protected void setUp() throws Exception {super.setUp();        chiSquare = DistributionFactory.newInstance().createChiSquareDistribution(5.0);}/* * @see TestCase#tearDown() */protected void tearDown() throws Exception {        chiSquare = null;super.tearDown();}    public void testLowerTailProbability(){        testProbability( .210, .001);        testProbability( .554, .010);        testProbability( .831, .025);        testProbability(1.145, .050);        testProbability(1.610, .100);    }    public void testUpperTailProbability(){        testProbability(20.515, .999);        testProbability(15.086, .990);        testProbability(12.833, .975);        testProbability(11.070, .950);        testProbability( 9.236, .900);    }        public void testLowerTailValues(){        testValue(.001,  .210);        testValue(.010,  .554);        testValue(.025,  .831);        testValue(.050, 1.145);        testValue(.100, 1.610);    }        public void testUpperTailValues(){        testValue(.999, 20.515);        testValue(.990, 15.086);        testValue(.975, 12.833);        testValue(.950, 11.070);        testValue(.900,  9.236);    }        private void testProbability(double x, double expected){        double actual = chiSquare.cummulativeProbability(x);        assertEquals("probability for " + x, expected, actual, 10e-4);    }        private void testValue(double p, double expected){        double actual = chiSquare.inverseCummulativeProbability(p);        assertEquals("value for " + p, expected, actual, 10e-4);    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import junit.framework.TestCase;/** * This class contains test cases for the ExpandableDoubleArray. *  * @author <a href="mailto:tobrien@apache.org">Tim O'Brien</a> */public abstract class DoubleArrayAbstractTest extends TestCase {protected DoubleArray da = null;// Array used to test rollingprotected DoubleArray ra = null;public DoubleArrayAbstractTest(String name) {super(name);}public void testAdd1000() {for (int i = 0; i < 1000; i++) {da.addElement(i);}assertEquals("Number of elements should be equal to 1000 after adding 1000 values",1000,da.getNumElements());assertEquals("The element at the 56th index should be 56",56.0,da.getElement(56),Double.MIN_VALUE);}public void testGetValues() {double[] controlArray = { 2.0, 4.0, 6.0 };da.addElement(2.0);da.addElement(4.0);da.addElement(6.0);double[] testArray = da.getElements();for (int i = 0; i < da.getNumElements(); i++) {assertEquals("The testArray values should equal the controlArray values, index i: "+ i+ " does not match",testArray[i],controlArray[i],Double.MIN_VALUE);}}public void testAddElementRolling() {ra.addElement(0.5);ra.addElement(1.0);ra.addElement(1.0);ra.addElement(1.0);ra.addElement(1.0);ra.addElement(1.0);ra.addElementRolling(2.0);assertEquals("There should be 6 elements in the eda",6,ra.getNumElements());assertEquals("The max element should be 2.0",2.0,ra.getMax(),Double.MIN_VALUE);assertEquals("The min element should be 1.0",1.0,ra.getMin(),Double.MIN_VALUE);for (int i = 0; i < 1024; i++) {ra.addElementRolling(i);}assertEquals("We just inserted 1024 rolling elements, num elements should still be 6",6,ra.getNumElements());}public void testMinMax() {da.addElement(2.0);da.addElement(22.0);da.addElement(-2.0);da.addElement(21.0);da.addElement(22.0);da.addElement(42.0);da.addElement(62.0);da.addElement(22.0);da.addElement(122.0);da.addElement(1212.0);assertEquals("Min should be -2.0", -2.0, da.getMin(), Double.MIN_VALUE);assertEquals("Max should be 1212.0",1212.0,da.getMax(),Double.MIN_VALUE);}}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import junit.framework.TestCase;/** * @author Brent Worden */public class ContinuedFractionTest extends TestCase {/** * Constructor for ContinuedFractionTest. * @param name */public ContinuedFractionTest(String name) {super(name);}public void testGoldenRation(){        ContinuedFraction cf = new ContinuedFraction() {public double getA(int n, double x) {return 1.0;}public double getB(int n, double x) {return 1.0;}};        double gr = cf.evaluate(0.0, 10e-9);        assertEquals(1.61803399, gr, 10e-9);}}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.framework.AssertionFailedError;/** * Test cases for the MathUtils class. * * @author Phil Steitz * @version $Revision: 1.2 $ $Date: 2003/06/06 03:07:39 $ */public final class MathUtilsTest extends TestCase {    public MathUtilsTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(MathUtilsTest.class);        suite.setName("MathUtils Tests");        return suite;    }        public void testBinomialCoefficient() {        long[] bcoef5 = {1,5,10,10,5,1};        long[] bcoef6 = {1,6,15,20,15,6,1};        for (int i = 0; i < 6; i++) {            assertEquals("5 choose " + i, bcoef5[i],                 MathUtils.binomialCoefficient(5,i));        }        for (int i = 0; i < 7; i++) {            assertEquals("6 choose " + i, bcoef6[i],                 MathUtils.binomialCoefficient(6,i));        }                for (int n = 1; n < 10; n++) {            for (int k = 0; k <= n; k++) {                assertEquals(n + " choose " + k, binomialCoefficient(n, k),                     MathUtils.binomialCoefficient(n, k));                assertEquals(n + " choose " + k,(double) binomialCoefficient(n, k),                     MathUtils.binomialCoefficientDouble(n, k),Double.MIN_VALUE);                assertEquals(n + " choose " + k,                    Math.log((double) binomialCoefficient(n, k)),                     MathUtils.binomialCoefficientLog(n, k),10E-12);            }        }            /*        * Takes a long time for recursion to unwind, but succeeds        * and yields exact value = 2,333,606,220                assertEquals(MathUtils.binomialCoefficient(34,17),            binomialCoefficient(34,17));       */    }        public void testBinomialCoefficientFail() {        try {            long x = MathUtils.binomialCoefficient(0,0);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            long x = MathUtils.binomialCoefficient(4,5);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = MathUtils.binomialCoefficientDouble(0,0);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = MathUtils.binomialCoefficientDouble(4,5);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = MathUtils.binomialCoefficientLog(0,0);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = MathUtils.binomialCoefficientLog(4,5);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            long x = MathUtils.binomialCoefficient(67,34);            fail ("expecting ArithmeticException");        } catch (ArithmeticException ex) {            ;        }        double x = MathUtils.binomialCoefficientDouble(1030,515);        assertTrue("expecting infinite binomial coefficient",            Double.isInfinite(x));    }    public void testFactorial() {        for (int i = 1; i < 10; i++) {            assertEquals(i + "! ",factorial(i),MathUtils.factorial(i));            assertEquals(i + "! ",(double)factorial(i),                MathUtils.factorialDouble(i),Double.MIN_VALUE);            assertEquals(i + "! ",Math.log((double)factorial(i)),                MathUtils.factorialLog(i),10E-12);        }    }    public void testFactorialFail() {        try {            long x = MathUtils.factorial(0);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = MathUtils.factorialDouble(0);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = MathUtils.factorialLog(0);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = MathUtils.factorial(21);            fail ("expecting ArithmeticException");        } catch (ArithmeticException ex) {            ;        }        assertTrue("expecting infinite factorial value",            Double.isInfinite(MathUtils.factorialDouble(171)));    }    /**     * Exact recursive implementation to test against     */    private long binomialCoefficient(int n, int k) {        if ((n == k) || (k == 0)) {            return 1;        }        if ((k == 1) || (k == n - 1)) {            return n;        }        return binomialCoefficient(n - 1, k - 1) +            binomialCoefficient(n - 1, k);    }    /**     * Finds the largest values of n for which binomialCoefficient and     * binomialCoefficientDouble will return values that fit in a long, double,     * resp.  Remove comments around test below to get this in test-report     *        public void testLimits() {            findBinomialLimits();        }     */    private void findBinomialLimits() {        /**         * will kick out 66 as the limit for long         */        boolean foundLimit = false;        int test = 10;        while (!foundLimit) {            try {                double x = MathUtils.binomialCoefficient(test, test / 2);            } catch (ArithmeticException ex) {                foundLimit = true;                System.out.println                    ("largest n for binomialCoefficient = " + (test - 1) );            }            test++;        }       /**        * will kick out 1029 as the limit for double        */        foundLimit = false;        test = 10;        while (!foundLimit) {            double x = MathUtils.binomialCoefficientDouble(test, test / 2);            if (Double.isInfinite(x)) {                foundLimit = true;                System.out.println                    ("largest n for binomialCoefficientD = " + (test - 1) );            }            test++;        }    }    /**     * Finds the largest values of n for which factiorial and     * factorialDouble will return values that fit in a long, double,     * resp.  Remove comments around test below to get this in test-report        public void testFactiorialLimits() {            findFactorialLimits();        }     */    private void findFactorialLimits() {        /**         * will kick out 20 as the limit for long         */        boolean foundLimit = false;        int test = 10;        while (!foundLimit) {            try {                double x = MathUtils.factorial(test);            } catch (ArithmeticException ex) {                foundLimit = true;                System.out.println                    ("largest n for factorial = " + (test - 1) );            }            test++;        }       /**        * will kick out 170 as the limit for double        */        foundLimit = false;        test = 10;        while (!foundLimit) {            double x = MathUtils.factorialDouble(test);            if (Double.isInfinite(x)) {                foundLimit = true;                System.out.println                    ("largest n for factorialDouble = " + (test - 1) );            }            test++;        }    }    /**     * Exact direct multiplication implementation to test against     */    private long factorial(int n) {        long result = 1;        for (int i = 2; i <= n; i++) {            result *= i;        }        return result;    }    public void testSignDouble() {        double delta = 0.0 ;        assertEquals( 1.0, MathUtils.sign( 2.0 ), delta ) ;        assertEquals( -1.0, MathUtils.sign( -2.0 ), delta ) ;    }    public void testSignFloat() {        float delta = 0.0F ;        assertEquals( 1.0F, MathUtils.sign( 2.0F ), delta ) ;        assertEquals( -1.0F, MathUtils.sign( -2.0F ), delta ) ;    }    public void testSignByte() {        assertEquals( (byte)1, MathUtils.sign( (byte)2 ) ) ;        assertEquals( (byte)(-1), MathUtils.sign( (byte)(-2) ) ) ;    }    public void testSignShort() {        assertEquals( (short)1, MathUtils.sign( (short)2 ) ) ;        assertEquals( (short)(-1), MathUtils.sign( (short)(-2) ) ) ;    }    public void testSignInt() {        assertEquals( (int)1, MathUtils.sign( (int)(2) ) ) ;        assertEquals( (int)(-1), MathUtils.sign( (int)(-2) ) ) ;    }    public void testSignLong() {        assertEquals( 1L, MathUtils.sign( 2L ) ) ;        assertEquals( -1L, MathUtils.sign( -2L ) ) ;    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the TestStatistic class. * * @author Phil Steitz * @version $Revision: 1.3 $ $Date: 2003/05/26 17:29:36 $ */public final class TestStatisticTest extends TestCase {    private TestStatisticImpl testStatistic = new TestStatisticImpl();        public TestStatisticTest(String name) {        super(name);    }            public void setUp() {     }    public static Test suite() {        TestSuite suite = new TestSuite(TestStatisticTest.class);        suite.setName("TestStatistic Tests");        return suite;    }    public void testChiSquare() {       double[] observed = {11,24,69,96};       double[] expected = {8.2,25.2,65.8,100.8};       assertEquals("chi-square statistic",            1.39743495,testStatistic.chiSquare(expected,observed),10E-5);              double[] tooShortObs = {0};       double[] tooShortEx = {1};       try {           testStatistic.chiSquare(tooShortObs,tooShortEx);           fail("arguments too short, IllegalArgumentException expected");       } catch (IllegalArgumentException ex) {           ;       }              double[] unMatchedObs = {0,1,2,3};       double[] unMatchedEx = {1,1,2};       try {           testStatistic.chiSquare(unMatchedEx,unMatchedObs);           fail("arrays have different lengths, IllegalArgumentException expected");       } catch (IllegalArgumentException ex) {           ;       }              expected[0] = 0;       assertEquals("chi-square statistic", Double.POSITIVE_INFINITY,            testStatistic.chiSquare(expected,observed),Double.MIN_VALUE);    }           public void testT(){double[] observed = {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0,            94.0, 101.0, 88.0, 98.0, 94.0, 101.0, 92.0, 95.0};        double mu = 100.0;        assertEquals("t statistic", -2.82, testStatistic.t(mu, observed),            10E-3);                double[] nullObserved = null;        try {            testStatistic.t(mu, nullObserved);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }                double[] emptyObs = {};        try {            testStatistic.t(mu, emptyObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }                double[] tooShortObs = {1.0};        try {            testStatistic.t(mu, tooShortObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;/** * This class contains test cases for the ExpandableDoubleArray. *  * @author <a href="mailto:tobrien@apache.org">Tim O'Brien</a> */public class ContractableDoubleArrayTest extends ExpandableDoubleArrayTest {public ContractableDoubleArrayTest(String name) {super( name );}/* (non-Javadoc) * @see junit.framework.TestCase#setUp() */protected void setUp() throws Exception {da = new ContractableDoubleArray();ra = new ContractableDoubleArray();}}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;/** * This class contains test cases for the ExpandableDoubleArray. *  * @author <a href="mailto:tobrien@apache.org">Tim O'Brien</a> */public class FixedDoubleArrayTest extends DoubleArrayAbstractTest {public FixedDoubleArrayTest(String name) {super( name );}/* (non-Javadoc) * @see junit.framework.TestCase#setUp() */protected void setUp() throws Exception {da = new FixedDoubleArray(4000);}/* (non-Javadoc) * @see junit.framework.TestCase#tearDown() */protected void tearDown() throws Exception {da = null;}/** TEST NORMAL OPERATIONS - calling super class test and then checking internal *   storage **/public void testAddElementRolling() {ra = new FixedDoubleArray(6);super.testAddElementRolling();assertEquals( "FixedDoubleArray should have 6 size internal storage", 6, ((FixedDoubleArray) ra).internalArray.length);}public void testExceedingElements() {for( int i = 0; i < 3999; i++) {da.addElement( 1.0 );}da.addElement( 1.0 );try {da.addElement( 2.0 );fail( " Adding more than 4000 elements should cause an exception ");} catch( Exception e ) {}da.addElementRolling(2.0);assertEquals( "This is the first rolling add, the first element should be 2.0",2.0, da.getElement(0), Double.MIN_VALUE);}public void testGetExceeding() {try {da.getElement(100);fail( "I haven't added 100 elements to the list yet, trying to getElement(100) should " +"thrown an error");} catch (Exception e ){ }}public void testSetElement() {da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.setElement( 2, 4.0 );assertEquals( "Index 2 should be 4.0", 4.0, da.getElement(2), Double.MIN_VALUE);try {da.setElement(2000, 45.0);fail( "The array does not contain 2000 elements yet, setting this element should" +" cause an excpetion");} catch(Exception e) {}}public void testOnlyRolling() {for( int i = 0; i < 8000; i++) {da.addElementRolling( i );}assertEquals( "The 2000th element should equal 6000",6000.0, da.getElement(2000), Double.MIN_VALUE);}public void testClear() {for( int i = 0; i < 10; i++) {da.addElementRolling(1.0);}assertEquals( "There should be ten elements in the array",10, da.getNumElements() );da.clear();assertEquals( "There should be zero elements in the array",0, da.getNumElements() );for( int i = 0; i < 10; i++) {da.addElementRolling(1.0);}assertEquals( "There should be ten elements in the array",10, da.getNumElements() );}public void testDiscardFront() {try {da.discardFrontElements( 2 );fail( "Discard front elements should throw an exception");} catch( Exception e ) {}}}
package org.apache.commons.math;import junit.framework.Assert;/** * @author Brent Worden */public class TestUtils {    /**     *      */    private TestUtils() {        super();    }    public static void assertEquals(double expected, double actual, double delta) {        // check for NaN        if(Double.isNaN(expected)){            Assert.assertTrue(Double.isNaN(actual));        } else {            Assert.assertEquals(expected, actual, delta);        }    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution.  * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.framework.AssertionFailedError;import java.security.NoSuchProviderException;import java.security.NoSuchAlgorithmException;import java.util.Collection;import java.util.HashSet;import org.apache.commons.math.stat.Univariate;import org.apache.commons.math.stat.UnivariateImpl;/** * Test cases for the RandomData class. * * @author Phil Steitz * @version $Revision: 1.5 $ $Date: 2003/06/04 02:45:49 $ */public final class RandomDataTest extends TestCase {    public RandomDataTest(String name) {        super(name);    }    private long smallSampleSize = 1000;    private double[] expected = {250,250,250,250};    private int largeSampleSize = 10000;    private int tolerance = 50;    private String[] hex =         {"0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"};     private RandomDataImpl randomData = new RandomDataImpl();     private TestStatisticImpl testStatistic = new TestStatisticImpl();            public void setUp() {     }    public static Test suite() {        TestSuite suite = new TestSuite(RandomDataTest.class);        suite.setName("RandomData Tests");        return suite;    }    /** test dispersion and failure modes for nextInt() */    public void testNextInt() {        try {            int x = randomData.nextInt(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        Freq freq = new Freq();        int value = 0;        for (int i=0;i<smallSampleSize;i++) {            value = randomData.nextInt(0,3);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        double[] observed = new double[4];        for (int i=0; i<4; i++) {            String iString = new Integer(i).toString();            observed[i] = freq.getCount(iString);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 16.27);        }        /** test dispersion and failure modes for nextLong() */    public void testNextLong() {       try {            long x = randomData.nextLong(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }       Freq freq = new Freq();       long value = 0;        for (int i=0;i<smallSampleSize;i++) {            value = randomData.nextLong(0,3);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        double[] observed = new double[4];        for (int i=0; i<4; i++) {            String iString = new Integer(i).toString();            observed[i] = freq.getCount(iString);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 16.27);        }        /** test dispersion and failure modes for nextSecureLong() */    public void testNextSecureLong() {        try {            long x = randomData.nextSecureLong(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        Freq freq = new Freq();        long value = 0;        for (int i=0;i<smallSampleSize;i++) {            value = randomData.nextSecureLong(0,3);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        double[] observed = new double[4];        for (int i=0; i<4; i++) {            String iString = new Integer(i).toString();            observed[i] = freq.getCount(iString);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 16.27);        }        /** test dispersion and failure modes for nextSecureInt() */    public void testNextSecureInt() {        try {            long x = randomData.nextSecureInt(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        Freq freq = new Freq();        int value = 0;        for (int i=0;i<smallSampleSize;i++) {            value = randomData.nextSecureInt(0,3);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        double[] observed = new double[4];        for (int i=0; i<4; i++) {            String iString = new Integer(i).toString();            observed[i] = freq.getCount(iString);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 16.27);        }        /**      * Make sure that empirical distribution of random Poisson(4)'s      * has P(X <= 5) close to actual cumulative Poisson probablity     * and that nextPoisson fails when mean is non-positive     * TODO: replace with statistical test, adding test stat to TestStatistic     */    public void testNextPoisson() {        try {            long x = randomData.nextPoisson(0);            fail("zero mean -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        Freq f = new Freq();        long v = 0;        for (int i = 0; i<largeSampleSize; i++) {            try {                f.addValue(randomData.nextPoisson(4.0d));            } catch (Exception ex) {                fail(ex.getMessage());            }        }        long cumFreq = f.getCount("0") + f.getCount("1") + f.getCount("2") +                         f.getCount("3") + f.getCount("4") + f.getCount("5");        long sumFreq = f.getSumFreq();        double cumPct =             new Double(cumFreq).doubleValue()/new Double(sumFreq).doubleValue();        assertEquals("cum Poisson(4)",cumPct,0.7851,0.2);        try {            long x = randomData.nextPoisson(-1);            fail("negative mean supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        try {            long x = randomData.nextPoisson(0);            fail("0 mean supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }            }        /** test dispersion and failute modes for nextHex() */    public void testNextHex() {        try {            String x = randomData.nextHexString(-1);            fail("negative length supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        try {            String x = randomData.nextHexString(0);            fail("zero length supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        String hexString = randomData.nextHexString(3);        if (hexString.length() != 3) {                fail("incorrect length for generated string");        }        hexString = randomData.nextHexString(1);        if (hexString.length() != 1) {                fail("incorrect length for generated string");        }        try {            hexString = randomData.nextHexString(0);            fail("zero length requested -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        if (hexString.length() != 1) {                fail("incorrect length for generated string");        }              Freq f = new Freq();        for (int i = 0; i < smallSampleSize; i++) {            hexString = randomData.nextHexString(100);            if (hexString.length() != 100) {                fail("incorrect length for generated string");            }            for (int j = 0; j < hexString.length(); j++) {                f.addValue(hexString.substring(j,j+1));            }        }        double[] expected = new double[16];        double[] observed = new double[16];        for (int i = 0; i < 16; i++) {            expected[i] = (double)smallSampleSize*100/(double)16;            observed[i] = f.getCount(hex[i]);        }        /* Use ChiSquare dist with df = 16-1 = 15, alpha = .001         * Change to 30.58 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 37.70);        }        /** test dispersion and failute modes for nextHex() */    public void testNextSecureHex() {        try {            String x = randomData.nextSecureHexString(-1);            fail("negative length -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        try {            String x = randomData.nextSecureHexString(0);            fail("zero length -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        String hexString = randomData.nextSecureHexString(3);        if (hexString.length() != 3) {                fail("incorrect length for generated string");        }        hexString = randomData.nextSecureHexString(1);        if (hexString.length() != 1) {                fail("incorrect length for generated string");        }        try {            hexString = randomData.nextSecureHexString(0);            fail("zero length requested -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        if (hexString.length() != 1) {                fail("incorrect length for generated string");        }              Freq f = new Freq();        for (int i = 0; i < smallSampleSize; i++) {            hexString = randomData.nextSecureHexString(100);            if (hexString.length() != 100) {                fail("incorrect length for generated string");            }            for (int j = 0; j < hexString.length(); j++) {                f.addValue(hexString.substring(j,j+1));            }        }        double[] expected = new double[16];        double[] observed = new double[16];        for (int i = 0; i < 16; i++) {            expected[i] = (double)smallSampleSize*100/(double)16;            observed[i] = f.getCount(hex[i]);        }        /* Use ChiSquare dist with df = 16-1 = 15, alpha = .001         * Change to 30.58 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 37.70);        }        /** test failure modes and dispersion of nextUniform() */      public void testNextUniform() {            try {            double x = randomData.nextUniform(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = randomData.nextUniform(3,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        double[] expected = new double[] {500,500};        double[] observed = new double[] {0,0};        double lower = -1d;        double upper = 20d;        double midpoint = (lower + upper)/2d;        double result = 0;        for (int i = 0; i < 1000; i++) {            result = randomData.nextUniform(lower,upper);            if ((result == lower) || (result == upper)) {                fail("generated value equal to an endpoint: " + result);            }             if (result < midpoint) {                observed[0]++;            } else {                observed[1]++;            }        }        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001         * Change to 6.64 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 10.83);      }        /** test failure modes and distribution of nextGaussian() */      public void testNextGaussian() {         try {            double x = randomData.nextGaussian(0,0);            fail("zero sigma -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        Univariate u = new UnivariateImpl();        for (int i = 0; i<largeSampleSize; i++) {            u.addValue(randomData.nextGaussian(0,1));        }        double xbar = u.getMean();        double s = u.getStandardDeviation();        double n = (double) u.getN();         /* t-test at .001-level TODO: replace with externalized t-test, with         * test statistic defined in TestStatistic         */        assertTrue(Math.abs(xbar)/(s/Math.sqrt(n))< 3.29);    }        /** test failure modes and distribution of nextExponential() */      public void testNextExponential() {        try {            double x = randomData.nextExponential(-1);            fail("negative mean -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        assertEquals("0 mean", 0,randomData.nextExponential(0),10E-8);         long cumFreq = 0;        double v = 0;        for (int i = 0; i < largeSampleSize; i++) {            v = randomData.nextExponential(1);            assertTrue("exponential deviate postive", v > 0);            if (v < 2) cumFreq++;        }        /* TODO: Replace with a statistical test, with statistic added to         * TestStatistic.  Check below compares observed cumulative distribution         * evaluated at 2 with exponential CDF          */        assertEquals("exponential cumulative distribution",            (double)cumFreq/(double)largeSampleSize,0.8646647167633873,.2);    }         /** test reseeding, algorithm/provider games */    public void testConfig() throws NoSuchProviderException,       NoSuchAlgorithmException{        randomData.reSeed(1000);        double v = randomData.nextUniform(0,1);        randomData.reSeed();        assertTrue("different seeds",             Math.abs(v - randomData.nextUniform(0,1)) > 10E-12);        randomData.reSeed(1000);        assertEquals("same seeds",v,randomData.nextUniform(0,1),10E-12);        randomData.reSeedSecure(1000);        String hex = randomData.nextSecureHexString(40);        randomData.reSeedSecure();        assertTrue("different seeds",            !hex.equals(randomData.nextSecureHexString(40)));        randomData.reSeedSecure(1000);        assertTrue("same seeds",            !hex.equals(randomData.nextSecureHexString(40)));                 /* remove this test back soon,         * since it takes about 4 seconds */                 randomData.setSecureAlgorithm("SHA1PRNG","SUN");        assertTrue("different seeds",            !hex.equals(randomData.nextSecureHexString(40)));        try {            randomData.setSecureAlgorithm("NOSUCHTHING","SUN");            fail("expecting NoSuchAlgorithmException");        } catch (NoSuchAlgorithmException ex) {            ;        }                try {            randomData.setSecureAlgorithm("SHA1PRNG","NOSUCHPROVIDER");            fail("expecting NoSuchProviderException");        } catch (NoSuchProviderException ex) {            ;        }                 // test reseeding without first using the generators        RandomDataImpl rd = new RandomDataImpl();        rd.reSeed(100);        double ret = rd.nextLong(1,2);        RandomDataImpl rd2 = new RandomDataImpl();        rd2.reSeedSecure(2000);        ret = rd2.nextSecureLong(1,2);        rd = new RandomDataImpl();        rd.reSeed();        ret = rd.nextLong(1,2);        rd2 = new RandomDataImpl();        rd2.reSeedSecure();        ret = rd2.nextSecureLong(1,2);    }        /** tests for nextSample() sampling from Collection */    public void testNextSample() {       Object[][] c = {{"0","1"},{"0","2"},{"0","3"},{"0","4"},{"1","2"},                        {"1","3"},{"1","4"},{"2","3"},{"2","4"},{"3","4"}};       double[] observed = {0,0,0,0,0,0,0,0,0,0};       double[] expected = {100,100,100,100,100,100,100,100,100,100};              HashSet cPop = new HashSet();  //{0,1,2,3,4}       for (int i = 0; i < 5; i++) {           cPop.add(Integer.toString(i));       }              Object[] sets = new Object[10]; // 2-sets from 5       for (int i = 0; i < 10; i ++) {           HashSet hs = new HashSet();           hs.add(c[i][0]);           hs.add(c[i][1]);           sets[i] = hs;       }              for (int i = 0; i < 1000; i ++) {           Object[] cSamp = randomData.nextSample(cPop,2);           observed[findSample(sets,cSamp)]++;       }               /* Use ChiSquare dist with df = 10-1 = 9, alpha = .001         * Change to 21.67 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 27.88);                // Make sure sample of size = size of collection returns same collection       HashSet hs = new HashSet();       hs.add("one");       Object[] one = randomData.nextSample(hs,1);       String oneString = (String) one[0];       if ((one.length != 1) || !oneString.equals("one")){           fail("bad sample for set size = 1, sample size = 1");       }              // Make sure we fail for sample size > collection size       try {           one = randomData.nextSample(hs,2);           fail("sample size > set size, expecting IllegalArgumentException");       } catch (IllegalArgumentException ex) {           ;       }              // Make sure we fail for empty collection       try {           hs = new HashSet();           one = randomData.nextSample(hs,0);           fail("n = k = 0, expecting IllegalArgumentException");       } catch (IllegalArgumentException ex) {           ;       }    }        private int findSample(Object[] u, Object[] samp) {        int result = -1;        for (int i = 0; i < u.length; i++) {            HashSet set = (HashSet) u[i];            HashSet sampSet = new HashSet();            for (int j = 0; j < samp.length; j++) {                sampSet.add(samp[j]);            }            if (set.equals(sampSet)) {                                return i;           }        }        fail("sample not found:{" + samp[0] + "," + samp[1] + "}");        return -1;    }        /** tests for nextPermutation */    public void testNextPermutation() {         int[][] p = {{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};         double[] observed = {0,0,0,0,0,0,};         double[] expected = {100,100,100,100,100,100};                  for (int i = 0; i < 600; i++) {             int[] perm = randomData.nextPermutation(3,3);             observed[findPerm(p,perm)]++;         }                   /* Use ChiSquare dist with df = 6-1 = 5, alpha = .001         * Change to 15.09 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 20.52);                   // Check size = 1 boundary case         int[] perm = randomData.nextPermutation(1,1);         if ((perm.length != 1) || (perm[0] != 0)){           fail("bad permutation for n = 1, sample k = 1");                   // Make sure we fail for k size > n         try {           perm = randomData.nextPermutation(2,3);           fail("permutation k > n, expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {           ;        }                   // Make sure we fail for n = 0        try {           perm = randomData.nextPermutation(0,0);           fail("permutation k = n = 0, expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {           ;        }                          }             }        private int findPerm(int[][] p, int[] samp) {        int result = -1;        for (int i = 0; i < p.length; i++) {            boolean good = true;            for (int j = 0; j < samp.length; j++) {                if (samp[j] != p[i][j]) {                    good = false;                }            }            if (good)  {                return i;            }        }                fail("permutation not found");        return -1;    }                                                               }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link Freq} class. * * @author Phil Steitz * @version $Revision: 1.1 $ $Date: 2003/05/12 19:04:38 $ */public final class FreqTest extends TestCase {    private long oneL = 1;    private long twoL = 2;    private int oneI = 1;    private int twoI = 2;    private String oneS = "1";    private String twoS = "2";    private double tolerance = 10E-15;        public FreqTest(String name) {        super(name);    }        public void setUp() {      }        public static Test suite() {        TestSuite suite = new TestSuite(FreqTest.class);        suite.setName("Freq Tests");        return suite;    }        /** test freq counts */    public void testCounts() {        Freq f = new Freq("test counts");         assertEquals("total count",0,f.getSumFreq());        f.addValue(oneL);        f.addValue(twoL);        f.addValue(oneS);        f.addValue(oneI);        assertEquals("one frequency count",3,f.getCount("1"));        assertEquals("two frequency count",1,f.getCount("2"));        assertEquals("foo frequency count",0,f.getCount("foo"));        assertEquals("total count",4,f.getSumFreq());        f.clear();        assertEquals("total count",0,f.getSumFreq());    }             /** test pcts */    public void testPcts() {        Freq f = new Freq("test counts");         f.addValue(oneL);        f.addValue(twoL);        f.addValue(oneI);        f.addValue(twoI);        f.addValue("foo");        f.addValue("foo");        f.addValue("foo");        f.addValue("foo");        assertEquals("one pct",0.25,f.getPct("1"),tolerance);        assertEquals("two pct",0.25,f.getPct("2"),tolerance);        assertEquals("foo pct",0.5,f.getPct("foo"),tolerance);        assertEquals("bar pct",0,f.getPct("bar"),tolerance);    }      }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link RealMatrixImpl} class. * * @author Phil Steitz * @version $Revision: 1.2 $ $Date: 2003/06/15 17:01:39 $ */public final class RealMatrixImplTest extends TestCase {        private double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    private double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };    private double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},        {-1d,0d,-8d} };    private double[] testDataRow1 = {1d,2d,3d};    private double[] testDataCol3 = {3d,3d,8d};    private double[][] testDataInv =         { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };    private double[][] preMultTest = {{8,12,33}};    private double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};    private double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};    private double[][] testDataPlusInv =         { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };    private double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };    private double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };    private double[][] singular = { {2d,3d}, {2d,3d} };    private double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd    private double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };    private double[] testVector = {1,2,3};    private double[] testVector2 = {1,2,3,4};    private double entryTolerance = 10E-16;    private double normTolerance = 10E-14;        public RealMatrixImplTest(String name) {        super(name);    }        public void setUp() {            }        public static Test suite() {        TestSuite suite = new TestSuite(RealMatrixImplTest.class);        suite.setName("RealMatrixImpl Tests");        return suite;    }        /** test dimensions */    public void testDimensions() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());    }         /** test copy functions */    public void testCopyFunctions() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        m2.setData(m.getData());        assertClose("getData",m2,m,entryTolerance);        // no dangling reference...        m2.setEntry(1,1,2000d);        RealMatrixImpl m3 = new RealMatrixImpl(testData);        assertClose("no getData side effect",m,m3,entryTolerance);        m3 = (RealMatrixImpl) m.copy();        double[][] stompMe = {{1d,2d,3d}};        m3.setDataRef(stompMe);        assertClose("no copy side effect",m,new RealMatrixImpl(testData),            entryTolerance);    }                   /** test add */    public void testAdd() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);        RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(mInv);        double[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                    testDataPlusInv[row][col],sumEntries[row][col],                        entryTolerance);            }        }        }        /** test add failure */    public void testAddFail() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        try {            RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        /** test norm */    public void testNorm() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertEquals("testData norm",14d,m.getNorm(),entryTolerance);        assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);    }         /** test m-n = m + -n */    public void testPlusMinus() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testDataInv);        assertClose("m-n = m + -n",m.subtract(m2),            m2.scalarMultiply(-1d).add(m),entryTolerance);                try {            RealMatrix a = m.subtract(new RealMatrixImpl(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }        /** test multiply */     public void testMultiply() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);        RealMatrixImpl identity = new RealMatrixImpl(id);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertClose("inverse multiply",m.multiply(mInv),            identity,entryTolerance);        assertClose("inverse multiply",mInv.multiply(m),            identity,entryTolerance);        assertClose("identity multiply",m.multiply(identity),            m,entryTolerance);        assertClose("identity multiply",identity.multiply(mInv),            mInv,entryTolerance);        assertClose("identity multiply",m2.multiply(identity),            m2,entryTolerance);         try {            RealMatrix a = m.multiply(new RealMatrixImpl(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }               /** test isSingular */    public void testIsSingular() {        RealMatrixImpl m = new RealMatrixImpl(singular);        assertTrue("singular",m.isSingular());        m = new RealMatrixImpl(bigSingular);        assertTrue("big singular",m.isSingular());        m = new RealMatrixImpl(id);        assertTrue("identity nonsingular",!m.isSingular());        m = new RealMatrixImpl(testData);        assertTrue("testData nonsingular",!m.isSingular());    }            /** test inverse */    public void testInverse() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrix mInv = new RealMatrixImpl(testDataInv);        assertClose("inverse",mInv,m.inverse(),normTolerance);        assertClose("inverse^2",m,m.inverse().inverse(),10E-12);    }        /** test solve */    public void testSolve() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrix mInv = new RealMatrixImpl(testDataInv);        // being a bit slothful here -- actually testing that X = A^-1 * B        assertClose("inverse-operate",mInv.operate(testVector),            m.solve(testVector),normTolerance);        try {            double[] x = m.solve(testVector2);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }               RealMatrix bs = new RealMatrixImpl(bigSingular);        try {            RealMatrix a = bs.solve(bs);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            RealMatrix a = m.solve(bs);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }        /** test determinant */    public void testDeterminant() {               RealMatrix m = new RealMatrixImpl(bigSingular);        assertEquals("singular determinant",0,m.getDeterminant(),0);        m = new RealMatrixImpl(detData);        assertEquals("nonsingular test",-3d,m.getDeterminant(),normTolerance);        try {            double a = new RealMatrixImpl(testData2).getDeterminant();            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }        /** test trace */    public void testTrace() {        RealMatrix m = new RealMatrixImpl(id);        assertEquals("identity trace",3d,m.getTrace(),entryTolerance);        m = new RealMatrixImpl(testData2);        try {            double x = m.getTrace();            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }        /** test sclarAdd */    public void testScalarAdd() {        RealMatrix m = new RealMatrixImpl(testData);        assertClose("scalar add",new RealMatrixImpl(testDataPlus2),            m.scalarAdd(2d),entryTolerance);    }                        /** test operate */    public void testOperate() {        RealMatrix m = new RealMatrixImpl(id);        double[] x = m.operate(testVector);        assertClose("identity operate",testVector,x,entryTolerance);        m = new RealMatrixImpl(bigSingular);        try {            x = m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }        /** test transpose */    public void testTranspose() {        RealMatrix m = new RealMatrixImpl(testData);         assertClose("inverse-transpose",m.inverse().transpose(),            m.transpose().inverse(),normTolerance);        m = new RealMatrixImpl(testData2);        RealMatrix mt = new RealMatrixImpl(testData2T);        assertClose("transpose",mt,m.transpose(),normTolerance);    }        /** test preMultiply */    public void testPremultiply() {        RealMatrix m = new RealMatrixImpl(testData);        RealMatrix mp = new RealMatrixImpl(preMultTest);        assertClose("premultiply",m.preMultiply(testVector),mp,normTolerance);        m = new RealMatrixImpl(bigSingular);        try {            RealMatrix x = m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testGetVectors() {        RealMatrix m = new RealMatrixImpl(testData);        assertClose("get row",m.getRow(1),testDataRow1,entryTolerance);        assertClose("get col",m.getColumn(3),testDataCol3,entryTolerance);        try {            double[] x = m.getRow(10);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double[] x = m.getColumn(-1);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testEntryMutators() {        RealMatrix m = new RealMatrixImpl(testData);        assertEquals("get entry",m.getEntry(1,2),2d,entryTolerance);        m.setEntry(1,2,100d);        assertEquals("get entry",m.getEntry(1,2),100d,entryTolerance);        try {            double x = m.getEntry(0,2);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            m.setEntry(1,4,200d);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }    }                //--------------- -----------------Private methods            /** verifies that two matrices are close (1-norm) */                  private void assertClose(String msg, RealMatrix m, RealMatrix n,        double tolerance) {        assertTrue(msg,m.subtract(n).getNorm() < tolerance);    }        /** verifies that two vectors are close (sup norm) */    private void assertClose(String msg, double[] m, double[] n,        double tolerance) {        if (m.length != n.length) {            fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " +  i + " elements differ",                 m[i],n[i],tolerance);        }    }        /** Useful for debugging */    private void dumpMatrix(RealMatrix m) {          for (int i = 0; i < m.getRowDimension(); i++) {              String os = "";              for (int j = 0; j < m.getColumnDimension(); j++) {                  os += m.getEntry(i+1, j+1) + " ";              }              System.out.println(os);          }    }        }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import junit.framework.Assert;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * @author pietsch at apache.org * * Testcase for UnivariateRealSolver. *  */public final class RealSolverTest extends TestCase {    public RealSolverTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(RealSolverTest.class);        suite.setName("UnivariateRealSolver Tests");        return suite;    }    public void testSinZero() throws MathException {        UnivariateRealFunction f = new SinFunction();        double result;        UnivariateRealSolver solver = new BrentSolver(f);        result = solver.solve(3, 4);        Assert.assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        solver = new SecantSolver(f);        result = solver.solve(3, 4);        Assert.assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());    }    public void testQuinticZero() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        double result;        UnivariateRealSolver solver = new BrentSolver(f);        // symmetric bracket around 0        result = solver.solve(-0.2, 0.2);        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());        // asymmetric bracket around 0        result = solver.solve(-0.2, 0.4);        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());        // symmetric bracket around 0.5        result = solver.solve(0.2, 0.8);        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // asymmetric bracket around 0.5        result = solver.solve(0.2, 0.6);        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // symmetric bracket around 1        result = solver.solve(0.6, 1.4);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // asymmetric bracket around 1        result = solver.solve(0.7, 2.4);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        solver = new SecantSolver(f);        // symmetric bracket around 0        result = solver.solve(-0.2, 0.2);        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());        // asymmetric bracket around 0        result = solver.solve(-0.2, 0.4);        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());        // symmetric bracket around 0.5        result = solver.solve(0.2, 0.8);        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // asymmetric bracket around 0.5        result = solver.solve(0.2, 0.6);        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // symmetric bracket around 1        result = solver.solve(0.6, 1.4);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // asymmetric bracket around 1        result = solver.solve(0.7, 2.4);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // Static solve method        // symmetric bracket around 0        result = UnivariateRealSolverFactory.solve(f,-0.2, 0.2);        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());        // asymmetric bracket around 0        result = UnivariateRealSolverFactory.solve(f,-0.2, 0.4);        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());        // symmetric bracket around 0.5        result = UnivariateRealSolverFactory.solve(f,0.2, 0.8);        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // asymmetric bracket around 0.5        result = UnivariateRealSolverFactory.solve(f,0.2, 0.6);        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // symmetric bracket around 1        result = UnivariateRealSolverFactory.solve(f,0.6, 1.4);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // asymmetric bracket around 1        result = UnivariateRealSolverFactory.solve(f,0.7, 2.4);        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.framework.AssertionFailedError;import java.net.URL;import org.apache.commons.math.stat.Univariate;import org.apache.commons.math.stat.UnivariateImpl; /** * Test cases for the ValueServer class. * * @author  Phil Steitz * @version $Revision: 1.4 $ */public final class ValueServerTest extends TestCase {    private ValueServer vs = new ValueServer();        public ValueServerTest(String name) {        super(name);    }    public void setUp() {        vs.setMode(ValueServer.DIGEST_MODE);        try {            URL url = getClass().getResource("testData.txt");            vs.setValuesFileURL(url.toExternalForm());         } catch (Exception ex) {            fail("malformed test URL");        }    }    public static Test suite() {        TestSuite suite = new TestSuite(ValueServerTest.class);        suite.setName("ValueServer Tests");        return suite;    }       /**       * Generate 1000 random values and make sure they look OK.<br>      * Note that there is a non-zero (but very small) probability that      * these tests will fail even if the code is working as designed.      */    public void testNextDigest() throws Exception{        double next = 0.0;        double tolerance = 0.1;        vs.computeDistribution();        assertTrue("empirical distribution property",             vs.getEmpiricalDistribution() != null);        Univariate stats = new UnivariateImpl();        for (int i = 1; i < 1000; i++) {            next = vs.getNext();            stats.addValue(next);        }            assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);        assertEquals         ("std dev", 1.0173699343977738, stats.getStandardDeviation(),             tolerance);                vs.computeDistribution(500);        stats = new UnivariateImpl();        for (int i = 1; i < 1000; i++) {            next = vs.getNext();            stats.addValue(next);        }            assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);        assertEquals         ("std dev", 1.0173699343977738, stats.getStandardDeviation(),             tolerance);            }        /**      * Make sure exception thrown if digest getNext is attempted      * before loading empiricalDistribution.      */    public void testNextDigestFail() throws Exception {        try {            vs.getNext();            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {;}    }        /**      * Make sure exception thrown if nextReplay() is attempted      * before opening replay file.      */    public void testNextReplayFail() throws Exception {        try {            vs.setMode(ValueServer.REPLAY_MODE);            vs.getNext();            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {;}    }        /**     * Test ValueServer REPLAY_MODE using values in testData file.<br>      * Check that the values 1,2,1001,1002 match data file values 1 and 2.     * the sample data file.     */    public void testReplay() throws Exception {        double firstDataValue = 4.038625496201205;        double secondDataValue = 3.6485326248346936;        double tolerance = 10E-15;        double compareValue = 0.0d;        vs.setMode(ValueServer.REPLAY_MODE);        vs.openReplayFile();        compareValue = vs.getNext();        assertEquals(compareValue,firstDataValue,tolerance);        compareValue = vs.getNext();        assertEquals(compareValue,secondDataValue,tolerance);        for (int i = 3; i < 1001; i++) {           compareValue = vs.getNext();        }        compareValue = vs.getNext();        assertEquals(compareValue,firstDataValue,tolerance);        compareValue = vs.getNext();        assertEquals(compareValue,secondDataValue,tolerance);        vs.closeReplayFile();        // make sure no NPE        vs.closeReplayFile();    }        /**      * Test other ValueServer modes     */    public void testModes() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        vs.setMu(0);        assertEquals("constant mode test",vs.getMu(),vs.getNext(),Double.MIN_VALUE);        vs.setMode(ValueServer.UNIFORM_MODE);        vs.setMu(2);        double val = vs.getNext();        assertTrue(val > 0 && val < 4);        vs.setSigma(1);        vs.setMode(ValueServer.GAUSSIAN_MODE);        val = vs.getNext();        assertTrue("gaussian value close enough to mean",            val < vs.getMu() + 100*vs.getSigma());        vs.setMode(ValueServer.EXPONENTIAL_MODE);        val = vs.getNext();        assertTrue(val > 0);        try {            vs.setMode(1000);            vs.getNext();            fail("bad mode, expecting IllegalStateException");        } catch (IllegalStateException ex) {            ;        }    }        /**     * Test fill     */    public void testFill() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        vs.setMu(2);        double[] val = new double[5];        vs.fill(val);        for (int i = 0; i < 5; i++) {            assertEquals("fill test in place",2,val[i],Double.MIN_VALUE);        }        double v2[] = vs.fill(3);        for (int i = 0; i < 3; i++) {            assertEquals("fill test in place",2,v2[i],Double.MIN_VALUE);        }    }        /**     * Test getters to make Clover happy     */    public void testProperties() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        assertEquals("mode test",ValueServer.CONSTANT_MODE,vs.getMode());        vs.setValuesFileURL("http://www.apache.org");        String s = vs.getValuesFileURL();        assertEquals("valuesFileURL test","http://www.apache.org",s);    }                                                }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;/** * This class contains test cases for the ExpandableDoubleArray. *  * @author <a href="mailto:tobrien@apache.org">Tim O'Brien</a> */public class ExpandableDoubleArrayTest extends DoubleArrayAbstractTest {public ExpandableDoubleArrayTest(String name) {super( name );}/* (non-Javadoc) * @see junit.framework.TestCase#setUp() */protected void setUp() throws Exception {da = new ExpandableDoubleArray();ra = new ExpandableDoubleArray();}/* (non-Javadoc) * @see junit.framework.TestCase#tearDown() */protected void tearDown() throws Exception {da = null;ra = null;}/** TEST NORMAL OPERATIONS - calling super class test and then checking internal *   storage **/public void testSetElementArbitraryExpansion() {double[] controlArray = {2.0, 4.0, 6.0};da.addElement(2.0);da.addElement(4.0);da.addElement(6.0);da.setElement(1, 3.0);// Expand the array arbitrarily to 1000 itemsda.setElement(1000, 3.4);assertEquals( "The number of elements should now be 1001, it isn't", da.getNumElements(), 1001);assertEquals( "Uninitialized Elements are default value of 0.0, index 766 wasn't", 0.0,da.getElement( 760 ), Double.MIN_VALUE );assertEquals( "The 1000th index should be 3.4, it isn't", 3.4, da.getElement(1000), Double.MIN_VALUE );assertEquals( "The 0th index should be 2.0, it isn't", 2.0, da.getElement(0), Double.MIN_VALUE);}public void testAdd1000() {super.testAdd1000();assertEquals("Internal Storage length should be 1024 if we started out with initial capacity of " +"16 and an expansion factor of 2.0",1024, ((ExpandableDoubleArray) da).getInternalLength());}public void testAddElementRolling() {super.testAddElementRolling();}public void testSetNumberOfElements() {da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );assertEquals( "Number of elements should equal 6", da.getNumElements(), 6);((ExpandableDoubleArray) da).setNumElements( 3 );assertEquals( "Number of elements should equal 3", da.getNumElements(), 3);try {((ExpandableDoubleArray) da).setNumElements( -3 );fail( "Setting number of elements to negative should've thrown an exception");} catch( IllegalArgumentException iae ) {}((ExpandableDoubleArray) da).setNumElements(1024);assertEquals( "Number of elements should now be 1024", da.getNumElements(), 1024);assertEquals( "Element 453 should be a default double", da.getElement( 453 ), 0.0, Double.MIN_VALUE);}/** TESTS WHICH FOCUS ON ExpandableSpecific internal storage */public void testWithInitialCapacity() {ExpandableDoubleArray eDA2 = new ExpandableDoubleArray(2);assertEquals("Initial number of elements should be 0", 0, eDA2.getNumElements());int iterations = (int) Math.pow(2.0, 15.0);for( int i = 0; i < iterations; i++) {eDA2.addElement( i );}assertEquals("Number of elements should be equal to 2^15", (int) Math.pow(2.0, 15.0), eDA2.getNumElements());eDA2.addElement( 2.0 );assertEquals("Number of elements should be equals to 2^15 + 1",        ( (int) Math.pow(2.0, 15.0) + 1 ), eDA2.getNumElements() );}public void testWithInitialCapacityAndExpansionFactor() {ExpandableDoubleArray eDA3 = new ExpandableDoubleArray(3, 3.0f);assertEquals("Initial number of elements should be 0", 0, eDA3.getNumElements() );int iterations = (int) Math.pow(3.0, 7.0);for( int i = 0; i < iterations; i++) {eDA3.addElement( i );}assertEquals("Number of elements should be equal to 3^7", (int) Math.pow(3.0, 7.0), eDA3.getNumElements());eDA3.addElement( 2.0 );assertEquals("Number of elements should be equals to 3^7 + 1",( (int) Math.pow(3.0, 7.0) + 1 ), eDA3.getNumElements() );   assertEquals("Expansion factor should equal 3.0", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);}public void testDiscard() {da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);assertEquals( "Number of elements should be 11", 11, da.getNumElements());da.discardFrontElements(5);assertEquals( "Number of elements should be 6", 6, da.getNumElements());try {da.discardFrontElements(-1);fail( "Trying to discard a negative number of element is not allowed");} catch( Exception e ){}try {da.discardFrontElements( 10000 );fail( "You can't discard more elements than the array contains");} catch( Exception e ){}}/** TEST ERROR CONDITIONS **/public void testIllegalInitialCapacity() {try {ExpandableDoubleArray eDA = new ExpandableDoubleArray(-3, 2.0f);fail( "That constructor should have thrown an IllegalArgumentException because " +"the initialCapacity was negative, if it didn't then" +" the range checking of initialCapacity is not working properly" );} catch( IllegalArgumentException iae ) {}try {ExpandableDoubleArray eDA = new ExpandableDoubleArray(0, 2.0f);fail( "That constructor should have thrown an IllegalArgumentException because " +"the initialCapacity was ZERO if it didn't then" +" the range checking of initialCapacity is not working properly" );} catch( IllegalArgumentException iae ) {}}public void testIllegalExpansionFactor() {try {ExpandableDoubleArray eDA = new ExpandableDoubleArray(3, 0.66f);fail( "That constructor should have thrown an IllegalArgumentException because " +"the expansionFactor for 0.66 which would shrink the array instead of expand the array");} catch( IllegalArgumentException iae ) {}try {ExpandableDoubleArray eDA = new ExpandableDoubleArray(3, 0.0f);fail( "That constructor should have thrown an IllegalArgumentException because " +"the expansionFactor for 0.0");} catch( IllegalArgumentException iae) {}try {ExpandableDoubleArray eDA = new ExpandableDoubleArray(3, -4.35f);fail( "That constructor should have thrown an IllegalArgumentException because " +"the expansionFactor for -4.35");} catch( IllegalArgumentException iae) {}}public void testSetOutOfBounds() {try {da.setElement( -1, 2.0);fail( "Cannot set a negative index");} catch( Exception e ){}}public void testGetOutOfBounds() {try {da.getElement(10000);fail( "Cannot get an element that is larger than the number of elements");} catch( Exception e ) {}try {da.getElement(-3);fail("Cannot get a negative index");} catch( Exception e ){}}}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.framework.AssertionFailedError;import java.io.File;import java.net.URL;import org.apache.commons.math.stat.Univariate;import org.apache.commons.math.stat.UnivariateImpl;/** * Test cases for the EmpiricalDistribution class * * @author Phil Steitz * @version $Revision: 1.2 $ $Date: 2003/05/29 20:35:45 $ */public final class EmpiricalDistributionTest extends TestCase {    private EmpiricalDistribution empiricalDistribution = null;    private File file = null;        public EmpiricalDistributionTest(String name) {        super(name);    }    public void setUp() {        empiricalDistribution = new EmpiricalDistributionImpl(100);        URL url = getClass().getResource("testData.txt");        file = new File(url.getFile());    }    public static Test suite() {        TestSuite suite = new TestSuite(EmpiricalDistributionTest.class);        suite.setName("EmpiricalDistribution Tests");        return suite;    }    /**     * Test EmpiricalDistrbution.load() using sample data file.<br>      * Check that the sampleCount, mu and sigma match data in      * the sample data file.     */    public void testLoad() throws Exception {        empiricalDistribution.load(file);           // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1        // Make sure that loaded distribution matches this        assertEquals(empiricalDistribution.getSampleStats().getN(),1000,10E-7);        //TODO: replace with statistical tests        assertEquals            (empiricalDistribution.getSampleStats().getMean(),                5.069831575018909,10E-7);        assertEquals          (empiricalDistribution.getSampleStats().getStandardDeviation(),                1.0173699343977738,10E-7);    }        /**       * Generate 1000 random values and make sure they look OK.<br>      * Note that there is a non-zero (but very small) probability that      * these tests will fail even if the code is working as designed.      */    public void testNext() throws Exception {        tstGen(0.1);    }        /**      * Make sure exception thrown if digest getNext is attempted      * before loading empiricalDistribution.     */    public void testNexFail() {        try {            empiricalDistribution.getNextValue();            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {;}    }        /**     * Make sure we can handle a grid size that is too fine     */    public void testGridTooFine() throws Exception {        empiricalDistribution = new EmpiricalDistributionImpl(10000);        tstGen(0.1);        }        /**     * How about too fat?     */    public void testGridTooFat() throws Exception {        empiricalDistribution = new EmpiricalDistributionImpl(1);        tstGen(5); // ridiculous tolerance; but ridiculous grid size                   // really just checking to make sure we do not bomb    }        private void tstGen(double tolerance)throws Exception {        empiricalDistribution.load(file);           Univariate stats = new UnivariateImpl();        for (int i = 1; i < 1000; i++) {            stats.addValue(empiricalDistribution.getNextValue());        }        //TODO: replace these with statistical tests -- refactor as necessary        assertEquals("mean", stats.getMean(),5.069831575018909,tolerance);        assertEquals         ("std dev", stats.getStandardDeviation(),1.0173699343977738,tolerance);    }                               }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import org.apache.commons.math.stat.Univariate;import org.apache.commons.math.stat.UnivariateImpl;/** * Implements the following test statistics <ul> * <li> *   <a href ="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm"> *   Chi-Square</a> * </li> * <li> *   <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda352.htm"> *     One Sample t-test</a> * </li> * </ul> * @author Phil Steitz * @version $Revision: 1.4 $ $Date: 2003/06/06 03:38:03 $ *  */public class TestStatisticImpl implements TestStatistic {        /**     * Default constructor.     */    public TestStatisticImpl() {    }        /**     * Computes Chi-Square statistic given observed and expected counts <br>     * <strong>Algorithm</strong>:      * http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm <br>     * <strong>Numerical considerations</strong>: none <br>     * @param observed array of observed frequency counts     * @param expected array of expected frequency counts     * @throws IllegalArgumentException if input arrays have different lengths     * or length is less than 2     */    public double chiSquare(double[] expected, double[] observed) {        double sumSq = 0.0d;        double dev = 0.0d;        if ((expected.length < 2) || (expected.length != observed.length)) {            throw new IllegalArgumentException                ("observed, expected array lengths incorrect");        }        for (int i = 0; i < observed.length; i++) {            dev = (observed[i] - expected[i]);            sumSq += dev * dev / expected[i];        }                return sumSq;    }               /**     * Computes t statistic given observed values<br/>     * <strong>Algorithm</strong>:      * http://www.itl.nist.gov/div898/handbook/eda/section3/eda352.htm<br/>     * <strong>Numerical considerations</strong>: none <br>     * @param mu hypothesized mean value.     * @param observed array of observed values     * @return t-test statistic for the hypothesized mean and observed values.     * @throws IllegalArgumentException if input array length is less than 2     */public double t(double mu, double[] observed) {        if((observed == null) || (observed.length < 2)) {            throw new IllegalArgumentException                ("observed array length incorrect");        }                // leverage Univariate to compute statistics        Univariate univariate = new UnivariateImpl();        for (int i = 0; i < observed.length; i++) {univariate.addValue(observed[i]);}        double n = univariate.getN();        double xbar = univariate.getMean();        double std = univariate.getStandardDeviation();        return (xbar - mu) / (std / Math.sqrt(n));}}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;/** * Interfaces for the following test statistics <ul> * <li><a href ="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm"> *     Chi-Square</a></li> * <li><a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda352.htm"> *     One Sample t-test</a></li> * </ul> *  * @author Phil Steitz * @version $Revision: 1.3 $ $Date: 2003/06/06 03:38:03 $ *  */public interface TestStatistic {        /**     * <strong>Description</strong>:     * Computes Chi-Square statistic given observed and expected freqeuncy counts <br>     * This statistic can be used to perform Chi-Square tests for goodness     * of fit.<br>     * <strong>Definition</strong>:      * http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm <br>     * <strong>Preconditions</strong>: <ul>     * <li>Expected counts should all be positive. If any expected     * counts are 0, the test will return INFINITY.  Negative expected or observed counts      * make the statistic meaningless.</li>     * <li>The observed and expected arrays <i>must</i> have the same length and     * their common length must be at least 2 </li>     * </ul>     * @param observed array of observed frequency counts     * @param expected array of exptected frequency counts     * @throws IllegalArgumentException if input arrays have different lengths     * or length is less than 2     */    public double chiSquare(double[] expected, double[] observed);        /**     * <strong>Description</strong>:     * Computes one sample, t-test statistic given observed values <br/>     * This statistic can be used to perform one sample tests for means.<br/>     * <strong>Definition</strong>:      * http://www.itl.nist.gov/div898/handbook/eda/section3/eda352.htm<br/>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array length <i>must</i> be at least 2.</li>     * </ul>     * @param mu hypothesized mean value.     * @param observed array of observed values     * @throws IllegalArgumentException if input array length is less than 2     */    public double t(double mu, double[] observed);}