// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.functions.vectorial;import org.spaceroots.mantissa.functions.FunctionException;import org.spaceroots.mantissa.functions.ExhaustedSampleException;import junit.framework.*;public class BasicSampledFunctionIteratorTest  extends TestCase {  public BasicSampledFunctionIteratorTest(String name) {    super(name);  }  public void testIteration()    throws ExhaustedSampleException, FunctionException {    BasicSampledFunctionIterator iter =      new BasicSampledFunctionIterator(new Function(0.0, 0.1, 10));    for (int i = 0; i < 10; ++i) {      assertTrue(iter.hasNext());      VectorialValuedPair pair = iter.nextSamplePoint();      assertTrue(Math.abs(pair.x    - 0.1 * i) < 1.0e-10);      assertTrue(Math.abs(pair.y[0] + 0.1 * i) < 1.0e-10);      assertTrue(Math.abs(pair.y[1] + 0.2 * i) < 1.0e-10);    }  }  public void testExhausted()    throws ExhaustedSampleException, FunctionException {    BasicSampledFunctionIterator iter =      new BasicSampledFunctionIterator(new Function(0.0, 0.1, 10));    for (int i = 0; i < 10; ++i) {      assertTrue(iter.hasNext());      iter.nextSamplePoint();    }    assertTrue(! iter.hasNext());    boolean exceptionOccurred = false;    try {      iter.nextSamplePoint();    } catch(ExhaustedSampleException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);  }  public void testUnderlyingException()    throws ExhaustedSampleException, FunctionException {    BasicSampledFunctionIterator iter =      new BasicSampledFunctionIterator(new ExceptionGeneratingFunction());    boolean exceptionOccurred = false;    try {      iter.nextSamplePoint();    } catch(FunctionException e) {      exceptionOccurred = true;    }    assertTrue(! exceptionOccurred);    exceptionOccurred = false;    try {      iter.nextSamplePoint();    } catch(FunctionException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);  }  public static Test suite() {    return new TestSuite(BasicSampledFunctionIteratorTest.class);  }  private static class Function    implements SampledFunction {    private static final long serialVersionUID = -6049535144225908344L;    private double   begin;    private double   step;    private int      n;    private double[] values;    public Function(double begin, double step, int n) {      this.begin  = begin;      this.step   = step;      this.n      = n;      values      = new double[2];    }    public int size() {      return n;    }    public int getDimension() {      return 2;    }    public VectorialValuedPair samplePointAt(int i)      throws FunctionException {      if (i < 0 || i >= n) {        throw new FunctionException("outside of range");      }      double x = begin + i * step;      values[0] = -x;      values[1] = 2.0 * values[0];      return new VectorialValuedPair(x, values);    }  }  private static class ExceptionGeneratingFunction    implements SampledFunction {    private static final long serialVersionUID = 3750401068561053681L;    private boolean fireException = false;    public int size() {      return 2;    }    public int getDimension() {      return 2;    }    public VectorialValuedPair samplePointAt(int i)      throws FunctionException {      if (fireException) {        throw new FunctionException("boom");      }      fireException = true;      return new VectorialValuedPair(0.0, new double[] { 0, 1 });    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.functions.vectorial;import junit.framework.*;public class VectorialValuedPairTest  extends TestCase {  public VectorialValuedPairTest(String name) {    super(name);  }  public void testConstructor() {    double[] tab = new double[2];    tab[0] = -8.4;    tab[1] = -3.2;    VectorialValuedPair pair = new VectorialValuedPair(1.2, tab);    assertTrue(Math.abs(pair.x    - 1.2) < 1.0e-10);    assertTrue(Math.abs(pair.y[0] + 8.4) < 1.0e-10);    assertTrue(Math.abs(pair.y[1] + 3.2) < 1.0e-10);  }  public void testCopyConstructor() {    double[] tab = new double[2];    tab[0] = -8.4;    tab[1] = -3.2;    VectorialValuedPair pair1 = new VectorialValuedPair(1.2, tab);    VectorialValuedPair pair2 = new VectorialValuedPair(pair1.x,                                                        pair1.y);    assertTrue(Math.abs(pair2.x    - pair1.x)    < 1.0e-10);    assertTrue(Math.abs(pair2.y[0] - pair1.y[0]) < 1.0e-10);    assertTrue(Math.abs(pair2.y[1] - pair1.y[1]) < 1.0e-10);    assertTrue(Math.abs(pair2.x    - 1.2)        < 1.0e-10);    assertTrue(Math.abs(pair2.y[0] + 8.4)        < 1.0e-10);    assertTrue(Math.abs(pair2.y[1] + 3.2)        < 1.0e-10);  }  public static Test suite() {    return new TestSuite(VectorialValuedPairTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.functions.vectorial;import org.spaceroots.mantissa.functions.FunctionException;import junit.framework.*;public class ComputableFunctionSamplerTest  extends TestCase {  public ComputableFunctionSamplerTest(String name) {    super(name);  }  public void testBeginStepNumber()    throws FunctionException {    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0), 0.0, 0.099, 11);    assertTrue(sampler.size() == 11);    assertTrue(sampler.getDimension() == 2);    assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).x     - 0.495) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).y[0]  + 0.495) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).y[1]  + 0.990) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).x    - 0.990) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).y[0] + 0.990) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).y[1] + 1.980) < 1.0e-10);  }  public void testRangeNumber()    throws FunctionException {    double[] range = new double[2];    range[0] = 0.0;    range[1] = 1.0;    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function (0.0, 1.0), range, 11);    assertTrue(sampler.size() == 11);    assertTrue(sampler.getDimension() == 2);    assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).x     - 0.5) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).y[0]  + 0.5) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).y[1]  + 1.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).x    - 1.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).y[0] + 1.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).y[1] + 2.0) < 1.0e-10);  }  public void testRangeStepNoAdjust()    throws FunctionException {    double[] range = new double[2];    range[0] = 0.0;    range[1] = 1.0;    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0),                                     range, 0.083, false);    assertTrue(sampler.size() == 12);    assertTrue(sampler.getDimension() == 2);    assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).x     - 0.415) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).y[0]  + 0.415) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).y[1]  + 0.830) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(11).x    - 0.913) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(11).y[0] + 0.913) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(11).y[1] + 1.826) < 1.0e-10);  }  public void testRangeStepAdjust()    throws FunctionException {    double[] range = new double[2];    range[0] = 0.0;    range[1] = 1.0;    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0),                                    range, 0.083, true);    assertTrue(sampler.size() == 13);    assertTrue(sampler.getDimension() == 2);    assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(6).x     - 0.5) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(6).y[0]  + 0.5) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(6).y[1]  + 1.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(12).x    - 1.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(12).y[0] + 1.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(12).y[1] + 2.0) < 1.0e-10);  }  public void testOutOfRange()    throws FunctionException {    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0), 0.0, 1.0, 10);    boolean exceptionOccurred = false;    try {      sampler.samplePointAt(-1);    } catch(ArrayIndexOutOfBoundsException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);    exceptionOccurred = false;    try {      sampler.samplePointAt(10);    } catch(ArrayIndexOutOfBoundsException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);  }  public void testUnderlyingException() {    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new ExceptionGeneratingFunction(),                                    0.0, 0.1, 11);    boolean exceptionOccurred = false;    try {      sampler.samplePointAt(2);    } catch(FunctionException e) {      exceptionOccurred = true;    }    assertTrue(! exceptionOccurred);    exceptionOccurred = false;    try {      sampler.samplePointAt(8);    } catch(FunctionException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);  }  public static Test suite() {    return new TestSuite(ComputableFunctionSamplerTest.class);  }  private static class Function    implements ComputableFunction {    private double   min;    private double   max;    private double[] values;    public int getDimension() {      return 2;    }    public Function(double min, double max) {      this.min = min;      this.max = max;      values   = new double[2];    }    public double[] valueAt(double x)      throws FunctionException {      if (x < min || x > max) {        throw new FunctionException("outside of range");      }      values[0] = -x;      values[1] = -2.0 * x;      return values;    }    private static final long serialVersionUID = -1859103913610458563L;  }  private static class ExceptionGeneratingFunction    implements ComputableFunction {    public int getDimension() {      return 2;    }    public double[] valueAt(double x)      throws FunctionException {      if (x < 0.5) {        double[] res = new double[2];        res[0] = -x;        res[1] = -2.0 * x;        return res;      }      throw new FunctionException("upper half range exception");     }    private static final long serialVersionUID = 2849780376767626912L;  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.functions.scalar;import org.spaceroots.mantissa.functions.FunctionException;import org.spaceroots.mantissa.functions.ExhaustedSampleException;import junit.framework.*;public class BasicSampledFunctionIteratorTest  extends TestCase {  public BasicSampledFunctionIteratorTest(String name) {    super(name);  }  public void testIteration()    throws ExhaustedSampleException, FunctionException {    BasicSampledFunctionIterator iter =      new BasicSampledFunctionIterator(new Function(0.0, 0.1, 10));    for (int i = 0; i < 10; ++i) {      assertTrue(iter.hasNext());      ScalarValuedPair pair = iter.nextSamplePoint();      assertTrue(Math.abs(pair.getX() - 0.1 * i) < 1.0e-10);      assertTrue(Math.abs(pair.getY() + 0.1 * i) < 1.0e-10);    }  }  public void testExhausted()    throws ExhaustedSampleException, FunctionException {    BasicSampledFunctionIterator iter =      new BasicSampledFunctionIterator(new Function(0.0, 0.1, 10));    for (int i = 0; i < 10; ++i) {      assertTrue(iter.hasNext());      iter.nextSamplePoint();    }    assertTrue(! iter.hasNext());    boolean exceptionOccurred = false;    try {      iter.nextSamplePoint();    } catch(ExhaustedSampleException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);  }  public void testUnderlyingException()    throws ExhaustedSampleException, FunctionException {    BasicSampledFunctionIterator iter =      new BasicSampledFunctionIterator(new ExceptionGeneratingFunction());    boolean exceptionOccurred = false;    try {      iter.nextSamplePoint();    } catch(FunctionException e) {      exceptionOccurred = true;    }    assertTrue(! exceptionOccurred);    exceptionOccurred = false;    try {      iter.nextSamplePoint();    } catch (FunctionException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);  }  public static Test suite() {    return new TestSuite(BasicSampledFunctionIteratorTest.class);  }  private static class Function    implements SampledFunction {    private static final long serialVersionUID = -5071329620086891960L;    private double begin;    private double step;    private int    n;    public Function(double begin, double step, int n) {      this.begin = begin;      this.step  = step;      this.n     = n;    }    public int size() {      return n;    }    public ScalarValuedPair samplePointAt(int i)      throws FunctionException {      if (i < 0 || i >= n) {        throw new FunctionException("outside of range");      }      double x = begin + i * step;      return new ScalarValuedPair(x, -x);    }  }  private static class ExceptionGeneratingFunction    implements SampledFunction {    private static final long serialVersionUID = 1417147976215668305L;    private boolean fireException = false;    public int size() {      return 2;    }    public ScalarValuedPair samplePointAt(int i)      throws FunctionException {      if (fireException) {        throw new FunctionException("boom");      }      fireException = true;      return new ScalarValuedPair(0.0, 0.0);    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.functions.scalar;import junit.framework.*;public class ScalarValuedPairTest  extends TestCase {  public ScalarValuedPairTest(String name) {    super(name);  }  public void testConstructor() {    ScalarValuedPair pair = new ScalarValuedPair(1.2, -8.4);    assertTrue(Math.abs(pair.getX() - 1.2) < 1.0e-10);    assertTrue(Math.abs(pair.getY() + 8.4) < 1.0e-10);  }  public void testCopyConstructor() {    ScalarValuedPair pair1 = new ScalarValuedPair(1.2, -8.4);    ScalarValuedPair pair2 = new ScalarValuedPair(pair1);    assertTrue(Math.abs(pair2.getX() - pair1.getX()) < 1.0e-10);    assertTrue(Math.abs(pair2.getY() - pair1.getY()) < 1.0e-10);    assertTrue(Math.abs(pair2.getX() - 1.2) < 1.0e-10);    assertTrue(Math.abs(pair2.getY() + 8.4) < 1.0e-10);  }  public static Test suite() {    return new TestSuite(ScalarValuedPairTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.functions.scalar;import org.spaceroots.mantissa.functions.FunctionException;import junit.framework.*;public class ComputableFunctionSamplerTest  extends TestCase {  public ComputableFunctionSamplerTest(String name) {    super(name);  }  public void testBeginStepNumber()    throws FunctionException {    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0),                                    0.0, 0.099, 11);    assertTrue(sampler.size() == 11);    assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).getX()  - 0.495) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).getY()  + 0.495) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).getX() - 0.990) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).getY() + 0.990) < 1.0e-10);  }  public void testRangeNumber()    throws FunctionException {    double[] range = new double[2];    range[0] = 0.0;    range[1] = 1.0;    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0), range, 11);    assertTrue(sampler.size() == 11);    assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).getX()  - 0.5) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).getY()  + 0.5) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).getX() - 1.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(10).getY() + 1.0) < 1.0e-10);  }  public void testRangeStepNoAdjust()    throws FunctionException {    double[] range = new double[2];    range[0] = 0.0;    range[1] = 1.0;    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0),                                    range, 0.083, false);    assertTrue(sampler.size() == 12);    assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.000) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).getX()  - 0.415) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(5).getY()  + 0.415) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(11).getX() - 0.913) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(11).getY() + 0.913) < 1.0e-10);  }  public void testRangeStepAdjust()    throws FunctionException {    double[] range = new double[2];    range[0] = 0.0;    range[1] = 1.0;    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0),                                    range, 0.083, true);    assertTrue(sampler.size() == 13);    assertTrue(Math.abs(sampler.samplePointAt(0).getX()  - 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(0).getY()  - 0.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(6).getX()  - 0.5) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(6).getY()  + 0.5) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(12).getX() - 1.0) < 1.0e-10);    assertTrue(Math.abs(sampler.samplePointAt(12).getY() + 1.0) < 1.0e-10);  }  public void testOutOfRange()    throws FunctionException {    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new Function(0.0, 1.0), 0.0, 1.0, 10);    boolean exceptionOccurred = false;    try {      sampler.samplePointAt(-1);    } catch(ArrayIndexOutOfBoundsException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);    exceptionOccurred = false;    try {      sampler.samplePointAt(10);    } catch(ArrayIndexOutOfBoundsException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);  }  public void testUnderlyingException() {    ComputableFunctionSampler sampler =      new ComputableFunctionSampler(new ExceptionGeneratingFunction(),                                    0.0, 0.1, 11);    boolean exceptionOccurred = false;    try {      sampler.samplePointAt(2);    } catch(FunctionException e) {      exceptionOccurred = true;    }    assertTrue(! exceptionOccurred);    exceptionOccurred = false;    try {      sampler.samplePointAt(8);    } catch(FunctionException e) {      exceptionOccurred = true;    }    assertTrue(exceptionOccurred);  }  public static Test suite() {    return new TestSuite(ComputableFunctionSamplerTest.class);  }  private static class Function    implements ComputableFunction {    private static final long serialVersionUID = -7173012970400285826L;    private double min;    private double max;    public Function(double min, double max) {      this.min = min;      this.max = max;    }    public double valueAt(double x)      throws FunctionException {      if (x < min || x > max) {        throw new FunctionException("outside of range");      }      return -x;    }  }  private static class ExceptionGeneratingFunction  implements ComputableFunction {    private static final long serialVersionUID = 7853080602731012102L;    public double valueAt(double x)      throws FunctionException {      if (x < 0.5) {        return -x;      }      throw new FunctionException("upper half range exception");    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.utilities;import junit.framework.*;public class ArrayMapperTest  extends TestCase {  public ArrayMapperTest(String name) {    super(name);    mapper = null;    b1 = null;    b2 = null;    b3 = null;  }  public void testDimensionCheck() {    int size = b1.getStateDimension();    size += b2.getStateDimension();    size += b3.getStateDimension();    assertTrue(mapper.getDataArray().length == size);  }  public void testUpdateObjects() {    double[] data = new double [7];    for (int i = 0; i < 7; ++i) {      data [i] = i * 0.1;    }    mapper.updateObjects(data);    assertTrue(Math.abs(b1.getElement(0) - 0.0) < 1.0e-10);    assertTrue(Math.abs(b2.getElement(0) - 0.4) < 1.0e-10);    assertTrue(Math.abs(b2.getElement(1) - 0.3) < 1.0e-10);    assertTrue(Math.abs(b2.getElement(2) - 0.2) < 1.0e-10);    assertTrue(Math.abs(b2.getElement(3) - 0.1) < 1.0e-10);    assertTrue(Math.abs(b3.getElement(0) - 0.6) < 1.0e-10);    assertTrue(Math.abs(b3.getElement(1) - 0.5) < 1.0e-10);  }    public void testUpdateArray() {    b1.setElement(0,  0.0);    b2.setElement(0, 40.0);    b2.setElement(1, 30.0);    b2.setElement(2, 20.0);    b2.setElement(3, 10.0);    b3.setElement(0, 60.0);    b3.setElement(1, 50.0);    mapper.updateArray();    double[] data = mapper.getDataArray();    for (int i = 0; i < 7; ++i) {      assertTrue(Math.abs(data [i] - i * 10.0) < 1.0e-10);    }  }    public void setUp() {    b1 = new DomainObject(1);    b2 = new DomainObject(4);    b3 = new DomainObject(2);    mapper = new ArrayMapper();    mapper.manageMappable(b1);    mapper.manageMappable(b2);    mapper.manageMappable(b3);  }  public void tearOff() {    b1 = null;    b2 = null;    b3 = null;    mapper = null;  }  public static Test suite() {    return new TestSuite(ArrayMapperTest.class);  }  private static class DomainObject implements ArraySliceMappable {    private double[] data;    public DomainObject(int size) {      data = new double [size];    }    public int getStateDimension() {      return data.length;    }    public void mapStateFromArray(int start, double[] array) {      for (int i = 0; i < data.length; ++i) {        data [data.length - 1 - i] = array [start + i];      }    }        public void mapStateToArray(int start, double[] array) {      for (int i = 0; i < data.length; ++i) {        array [start + i] = data [data.length - 1 - i];      }    }    public double getElement(int i) {      return data [i];    }    public void setElement(int i, double value) {      data [i] = value;    }  }  private DomainObject b1;  private DomainObject b2;  private DomainObject b3;  private ArrayMapper mapper;}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.utilities;import java.util.Iterator;import junit.framework.*;public class IntervalsListTest  extends TestCase {  public IntervalsListTest(String name) {    super(name);  }  public void testAddBetween() {    IntervalsList il =      new IntervalsList (new Interval(10, 20), new Interval(50, 60));    il.addToSelf(new Interval(30, 40));    checkEquals(new Interval[] {                  new Interval(10, 20),                  new Interval(30, 40),                  new Interval(50, 60)                }, il);  }  public void testAddReducingLastHole() {    IntervalsList il =      new IntervalsList (new Interval(10, 20), new Interval(50, 60));    il.addToSelf(new Interval(30, 55));    checkEquals(new Interval[] {                  new Interval(10, 20),                  new Interval(30, 60)                }, il);  }  public void test1() {    IntervalsList list1 = new IntervalsList(-2.0, -1.0);    IntervalsList list2 = new IntervalsList(new Interval(-0.9, -0.8));    check(list1, list2, 2.5,          true, false, 1, true, false, 1, false,          new Interval[] { new Interval(-2.0, -1.0),                           new Interval(-0.9, -0.8) },          new Interval[0]);    list2.addToSelf(new Interval(1.0, 3.0));    check(list1, list2, 2.5,          true, false, 1, false, false, 2, false,          new Interval[] { new Interval(-2.0, -1.0),                           new Interval(-0.9, -0.8),                           new Interval( 1.0,  3.0) },          new Interval[0]);    list1.addToSelf(new Interval(-1.2, 0.0));    check(list1, list2, -1.1,          true, false, 1, false, false, 2, true,          new Interval[] { new Interval(-2.0,  0.0),                           new Interval( 1.0,  3.0) },          new Interval[] { new Interval(-0.9, -0.8) });    IntervalsList list = new IntervalsList(new Interval(-10.0, -8.0));    list.addToSelf(new Interval(-6.0, -4.0));    list.addToSelf(new Interval(-0.85, 1.2));    list1.addToSelf(list);    check(list1, list2, 0,          false, false, 3, false, false, 2, true,          new Interval[] { new Interval(-10.0, -8.0),                           new Interval( -6.0, -4.0),                           new Interval( -2.0,  3.0) },          new Interval[] { new Interval( -0.9, -0.8),                           new Interval(  1.0,  1.2) });  }  private void check(IntervalsList l1, IntervalsList l2, double x,                     boolean b1, boolean b2, int i1,                     boolean b3, boolean b4, int i2,                     boolean b5, Interval[] add, Interval[] inter) {    assertTrue(l1.isConnex()     ^ (!b1));    assertTrue(l1.isEmpty()      ^ (!b2));    assertEquals(i1, l1.getIntervals().size());    assertTrue(l2.isConnex()     ^ (!b3));    assertTrue(l2.isEmpty()      ^ (!b4));    assertEquals(i2, l2.getIntervals().size());    assertTrue(l1.contains(x)    ^ (!b5));    checkEquals(add,   IntervalsList.add(l1, l2));    checkEquals(inter, IntervalsList.intersection(l1, l2));  }  private void checkEquals(Interval[] sa, IntervalsList sb) {    assertEquals(sa.length, sb.getIntervals().size());    Iterator iterB = sb.getIntervals().iterator();    for (int i = 0; i < sa.length; ++i) {      Interval ib = (Interval) iterB.next();      assertEquals(sa[i].getInf(), ib.getInf(), 1.0e-10);      assertEquals(sa[i].getSup(), ib.getSup(), 1.0e-10);    }  }  public static Test suite() {    return new TestSuite(IntervalsListTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.utilities;import junit.framework.*;public class MappableScalarTest  extends TestCase {  public MappableScalarTest(String name) {    super(name);    mapper  = null;    scalar1 = null;    scalar2 = null;    scalar3 = null;  }  public void testDimensionCheck() {    assertTrue(mapper.getDataArray().length == 3);  }  public void testUpdateObjects() {    double[] data = new double [mapper.getDataArray().length];    for (int i = 0; i < data.length; ++i) {      data [i] = i * 0.1;    }    mapper.updateObjects(data);    assertTrue(Math.abs(scalar1.getValue() - 0.0) < 1.0e-10);    assertTrue(Math.abs(scalar2.getValue() - 0.1) < 1.0e-10);    assertTrue(Math.abs(scalar3.getValue() - 0.2) < 1.0e-10);  }    public void testUpdateArray() {    scalar1.setValue(00.0);    scalar2.setValue(10.0);    scalar3.setValue(20.0);    mapper.updateArray();    double[] data = mapper.getDataArray();    for (int i = 0; i < data.length; ++i) {      assertTrue(Math.abs(data [i] - i * 10.0) < 1.0e-10);    }  }    public static Test suite() {    return new TestSuite(MappableScalarTest.class);  }  public void setUp() {    scalar1 = new MappableScalar();    scalar2 = new MappableScalar(2);    scalar3 = new MappableScalar(-3);    mapper = new ArrayMapper();    mapper.manageMappable(scalar1);    mapper.manageMappable(scalar2);    mapper.manageMappable(scalar3);  }  public void tearDown() {    scalar1 = null;    scalar2 = null;    scalar3 = null;    mapper = null;  }  private MappableScalar scalar1;  private MappableScalar scalar2;  private MappableScalar scalar3;  private ArrayMapper mapper;}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.utilities;import junit.framework.*;public class MappableArrayTest  extends TestCase {  public MappableArrayTest(String name) {    super(name);    array1 = null;    array2 = null;    array3 = null;    mapper = null;  }  public void testDimensionCheck() {    assertTrue(mapper.getDataArray().length == 9);  }  public void testUpdateObjects() {    double[] data = new double [mapper.getDataArray().length];    for (int i = 0; i < data.length; ++i) {      data [i] = i * 0.1;    }    mapper.updateObjects(data);    double[] a1 = array1.getArray();    assertTrue(Math.abs(a1[0] - 0.0) < 1.0e-10);    assertTrue(Math.abs(a1[1] - 0.1) < 1.0e-10);    assertTrue(Math.abs(a1[2] - 0.2) < 1.0e-10);    assertTrue(Math.abs(a1[3] - 0.3) < 1.0e-10);    double[] a2 = array2.getArray();    assertTrue(Math.abs(a2[0] - 0.4) < 1.0e-10);    assertTrue(Math.abs(a2[1] - 0.5) < 1.0e-10);    double[] a3 = array3.getArray();    assertTrue(Math.abs(a3[0] - 0.6) < 1.0e-10);    assertTrue(Math.abs(a3[1] - 0.7) < 1.0e-10);    assertTrue(Math.abs(a3[2] - 0.8) < 1.0e-10);  }    public static Test suite() {    return new TestSuite(MappableArrayTest.class);  }  public void setUp() {    array1 = new MappableArray(4);    array2 = new MappableArray(new double[2]);    array3 = new MappableArray(new double[3]);    mapper = new ArrayMapper();    mapper.manageMappable(array1);    mapper.manageMappable(array2);    mapper.manageMappable(array3);  }  public void tearDown() {    array1 = null;    array2 = null;    array3 = null;    mapper = null;  }  private MappableArray array1;  private MappableArray array2;  private MappableArray array3;  private ArrayMapper   mapper;}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.utilities;import junit.framework.*;public class IntervalTest  extends TestCase {  public IntervalTest(String name) {    super(name);  }  public void test1() {    check(new Interval(-10.0, 10.0), new Interval(11.0, 12.0), 2.5,          true, false, false,          new Interval(-10.0, 12.0), new Interval(11.0, 11.0));  }  public void test2() {    check(new Interval(-10.0, 10.0), new Interval(9.0, 12.0), 50.0,          false, false, true,          new Interval(-10.0, 12.0), new Interval(9.0, 10.0));  }  public void test3() {    check(new Interval(-10.0, 10.0), new Interval(-12.0, -11.0), 0.0,          true, false, false,          new Interval(-12.0, 10.0), new Interval(-10.0, -10.0));  }  public void test4() {    check(new Interval(-10.0, 10.0), new Interval(-4.0, 5.0), 0.0,          true, true, true,          new Interval(-10.0, 10.0), new Interval(-4.0, 5.0));  }  public void test5() {    check(new Interval(-10.0, 10.0), new Interval(-10.0, 10.0), 0.0,          true, true, true,          new Interval(-10.0, 10.0), new Interval(-10.0, 10.0));  }  private void check(Interval i1, Interval i2, double x,                     boolean b1, boolean b2, boolean b3,                     Interval add, Interval inter) {    assertTrue(i1.contains(x)    ^ (!b1));    assertTrue(i1.contains(i2)   ^ (!b2));    assertTrue(i1.intersects(i2) ^ (!b3));    assertEquals(add.getInf(), Interval.add(i1, i2).getInf(), 1.0e-10);    assertEquals(add.getSup(), Interval.add(i1, i2).getSup(), 1.0e-10);    assertEquals(inter.getInf(), Interval.intersection(i1, i2).getInf(), 1.0e-10);    assertEquals(inter.getSup(), Interval.intersection(i1, i2).getSup(), 1.0e-10);    Interval ia = new Interval(i1);    ia.addToSelf(i2);    assertEquals(add.getInf(), ia.getInf(), 1.0e-10);    assertEquals(add.getSup(), ia.getSup(), 1.0e-10);    Interval ib = new Interval(i1);    ib.intersectSelf(i2);    assertEquals(inter.getInf(), ib.getInf(), 1.0e-10);    assertEquals(inter.getSup(), ib.getSup(), 1.0e-10);  }  public static Test suite() {    return new TestSuite(IntervalTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.roots;import org.spaceroots.mantissa.functions.scalar.ComputableFunction;import java.util.ArrayList;/** This class implement a reference problem for junit tests. */public abstract class TestProblem implements ComputableFunction {  private double a;  private double b;  private double expectedRoot;  protected TestProblem(double a, double b, double expectedRoot) {    this.a            = a;    this.b            = b;    this.expectedRoot = expectedRoot;  }  public double getA() {    return a;  }  public double getB() {    return b;  }  public double getExpectedRoot() {    return expectedRoot;  }  public boolean checkResult(double foundRoot, double tol) {    return Math.abs(foundRoot - expectedRoot) <= tol;  }  /** Get the reference problems from G. E. Alefeld, F. A. Potra and Y. Shi. */  public static TestProblem[] getAPSProblems() {    ArrayList problems = new ArrayList();    // problem 1    problems.add(new APSProblem1(Math.PI / 2, Math.PI, 1.8954942670340));    // problems 2 to 11    double[] roots2To11 = {      3.0229153472731,  6.6837535608081, 11.238701655002, 19.676000080623,     29.828227326505,  41.906116195289,  55.953595800143, 71.985665586588,     90.008868539167, 110.02653274833    };    for (int k = 0, n = 1; n <= 10; ++n) {      problems.add(new APSProblems2To11(1.0e-9 + n * n,                                        (n+1) * (n+1) - 1.0e-9,                                        roots2To11[k++]));    }    // problems 12 to 14    problems.add(new APSProblems12To14( -40, -9.0, 31.0, 0.0));    problems.add(new APSProblems12To14(-100, -9.0, 31.0, 0.0));    problems.add(new APSProblems12To14(-200, -9.0, 31.0, 0.0));    // problems 15 to 17    int[] n15 = { 4, 6, 8, 10, 12 };    double[] roots15 = {      0.66874030497642, 0.76472449133173, 0.81776543395794,      0.85133992252078, 0.87448527222117    };    for (int k = 0; k < n15.length; ++k) {      problems.add(new APSProblems15To17(n15[k], 0.2, 0.0, 5.0, roots15[k]));    }    int[] n16 = { 4, 6, 8, 10, 12 };    for (int k = 0; k < n16.length; ++k) {      problems.add(new APSProblems15To17(n16[k], 1.0, 0.0, 5.0, 1.0));    }    int[] n17 = { 8, 10, 12, 14 };    for (int k = 0; k < n17.length; ++k) {      problems.add(new APSProblems15To17(n17[k], 1.0, -0.95, 4.05, 1.0));    }    // problem 18    problems.add(new APSProblem18(0.0, 1.5, 0.52359877559830));    // problem 19    int[] n19 = { 1, 2, 3, 4, 5, 20, 40, 60, 80, 100 };    double[] roots19 = {      0.42247770964124,   0.30669941048320,   0.22370545765466,      0.17171914751951,   0.13825715505682,   3.4657359020854e-2,      1.7328679513999e-2, 1.1552453009332e-2, 8.6643397569993e-3,      6.9314718055995e-3    };    for (int k = 0; k < n19.length; ++k) {      problems.add(new APSProblem19(n19[k], 0.0, 1.0, roots19[k]));    }    // problem 20    int[] n20 = { 5, 10, 20 };    double[] roots20 = {      3.8402551840622e-2, 9.9000099980005e-3, 2.4937500390620e-3    };    for (int k = 0; k < n20.length; ++k) {      problems.add(new APSProblem20(n20[k], 0.0, 1.0, roots20[k]));    }    // problem 21    int[] n21 = { 2, 5, 10, 15, 20 };    double[] roots21 = {      0.5, 0.34595481584824, 0.24512233375331,      0.19554762353657, 0.16492095727644    };    for (int k = 0; k < n21.length; ++k) {      problems.add(new APSProblem21(n21[k], 0.0, 1.0, roots21[k]));    }    // problem 22    int[] n22 = { 1, 2, 4, 5, 8, 15, 20 };    double[] roots22 = {      0.27550804099948,   0.13775402049974,   1.0305283778156e-2,      3.6171081789041e-3, 4.1087291849640e-4, 2.5989575892908e-5,      7.6685951221853e-6    };    for (int k = 0; k < n22.length; ++k) {      problems.add(new APSProblem22(n22[k], 0.0, 1.0, roots22[k]));    }    // problem 23    int[] n23 = { 1, 5, 10, 15, 20 };    double[] roots23 = {      0.40105813754155, 0.51615351875793, 0.53952222690842,      0.54818229434066, 0.55270466667849    };    for (int k = 0; k < n23.length; ++k) {      problems.add(new APSProblem23(n23[k], 0.0, 1.0, roots23[k]));    }    // problem 24    int[] n24 = { 2, 5, 15, 20 };    for (int k = 0; k < n24.length; ++k) {      problems.add(new APSProblem24(n24[k], 0.01, 1, 1.0 / n24[k]));    }    // problem 25    int[] n25 = {       2,  3,  4,  5,  6,       7,  9, 11, 13, 15,      17, 19, 21, 23, 25,      27, 29, 31, 33    };    for (int k = 0; k < n25.length; ++k) {      problems.add(new APSProblem25(n25[k], 1.0, 100.0, n25[k]));    }    // problem 26    problems.add(new APSProblem26(-1.0, 4.0, 0.0));    // problem 27    int[] n27 = {      1,  2,  3,  4,  5,  6,  7,  8,  9,  10,     11, 12, 13, 14, 15, 16, 17, 18, 19,  20,     21, 22, 23, 24, 25, 26, 27, 28, 29,  30,     31, 32, 33, 34, 35, 36, 37, 38, 39,  40    };    for (int k = 0; k < n27.length; ++k) {      problems.add(new APSProblem27(n27[k], -10000.0, Math.PI / 2,                                    0.62380651896161));    }    // problem 28    int[] n28 = {       20,  21,  22,  23,  24,  25,  26,  27,  28,   29,       30,  31,  32,  33,  34,  35,  36,  37,  38,   39, 40,      100, 200, 300, 400, 500, 600, 700, 800, 900, 1000 };    double[] roots28 = {      5.9051305594220e-5, 5.6367155339937e-5, 5.3916409455592e-5,      5.1669892394942e-5, 4.9603096699145e-5, 4.7695285287639e-5,      4.5928793239949e-5, 4.4288479195665e-5, 4.2761290257883e-5,      4.1335913915954e-5, 4.0002497338020e-5, 3.8752419296207e-5,      3.7578103559958e-5, 3.6472865219959e-5, 3.5430783356532e-5,      3.4446594929961e-5, 3.3515605877800e-5, 3.2633616249437e-5,      3.1796856858426e-5, 3.1001935436965e-5, 3.0245790670210e-5,      1.2277994232462e-5, 6.1695393904409e-6, 4.1198585298293e-6,      3.0924623877272e-6, 2.4752044261050e-6, 2.0633567678513e-6,      1.7690120078154e-6, 1.5481615698859e-6, 1.3763345366022e-6,      1.2388385788997e-6    };    for (int k = 0; k < n28.length; ++k) {      problems.add(new APSProblem28(n28[k], -10000.0, 10000.0, roots28[k]));    }    return (TestProblem[]) problems.toArray(new TestProblem[problems.size()]);  }  private static class APSProblem1 extends TestProblem {    private static final long serialVersionUID = -186095948802525864L;    public APSProblem1(double a, double b, double expectedRoot) {      super(a, b, expectedRoot);    }    public double valueAt(double x) {      return Math.sin(x) - x / 2;    }  }  private static class APSProblems2To11 extends TestProblem {    private static final long serialVersionUID = -1284328672006328516L;    public APSProblems2To11(double a, double b, double expectedRoot) {      super(a, b, expectedRoot);    }    public double valueAt(double x) {      double f = 0;      for (int i = 1; i <= 20; ++i) {        double n = 2.0 * i - 5.0;        double d = x - i * i;        f += n * n / (d * d * d);      }      return -2 * f;    }  }  private static class APSProblems12To14 extends TestProblem {    private static final long serialVersionUID = 3371996034561221313L;    private int n;    public APSProblems12To14(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      this.n = n;    }    public double valueAt(double x) {      return n * x * Math.exp(-x);    }  }  private static class APSProblems15To17 extends TestProblem {    private static final long serialVersionUID = -5460543876513796612L;    private int    n;    private double u;    public APSProblems15To17(int n, double u,                             double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      this.n = n;      this.u = u;    }    public double valueAt(double x) {      return Math.pow(x, n) - u;    }  }  private static class APSProblem18 extends TestProblem {    private static final long serialVersionUID = 6762799934117390438L;    public APSProblem18(double a, double b, double expectedRoot) {      super(a, b, expectedRoot);    }    public double valueAt(double x) {      return Math.sin(x) - 0.5;    }  }  private static class APSProblem19 extends TestProblem {    private static final long serialVersionUID = 4962041891152128524L;    private int n;    public APSProblem19(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      this.n = n;    }    public double valueAt(double x) {      return 2.0 * x * Math.exp(-n) - 2.0 *Math.exp(-n * x) + 1.0;    }  }  private static class APSProblem20 extends TestProblem {    private static final long serialVersionUID = -7391954140799812791L;    private int n;    private int oPoMn2;    public APSProblem20(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      this.n = n;      int oMn =  1 - n;      oPoMn2 = 1 + oMn * oMn;    }    public double valueAt(double x) {      double v = 1.0 - n * x;      return oPoMn2 * x - v * v;    }  }  private static class APSProblem21 extends TestProblem {    private static final long serialVersionUID = -4160028543895639114L;    private int n;    public APSProblem21(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      this.n = n;    }    public double valueAt(double x) {      return x * x - Math.pow(1 - x, n);    }  }  private static class APSProblem22 extends TestProblem {    private static final long serialVersionUID = 3807046732154081146L;    private int n;    private int oPoMn4;    public APSProblem22(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      this.n   = n;      int oMn  = 1 - n;      int oMn2 = oMn * oMn;      oPoMn4   = 1 + oMn2 * oMn2;    }    public double valueAt(double x) {      double oMnx  = 1 - n * x;      double oMnx2 = oMnx * oMnx;      return oPoMn4 * x - oMnx2 * oMnx2;    }  }  private static class APSProblem23 extends TestProblem {    private static final long serialVersionUID = -486669213837396921L;    private int n;    public APSProblem23(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      this.n = n;    }    public double valueAt(double x) {      return (x - 1.0) * Math.exp(-n * x) + Math.pow(x, n);    }  }  private static class APSProblem24 extends TestProblem {    private static final long serialVersionUID = -628275471717968182L;    private int n;    public APSProblem24(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      this.n = n;    }    public double valueAt(double x) {      return (n * x - 1.0) / ((n - 1) * x);    }  }  private static class APSProblem25 extends TestProblem {    private static final long serialVersionUID = 5207170686914959073L;    private double u;    private double v;;    public APSProblem25(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      u = 1.0 / n;      v = Math.pow(n, u);    }    public double valueAt(double x) {      return Math.pow(x, u) - v;    }  }  private static class APSProblem26 extends TestProblem {    private static final long serialVersionUID = 1063884352586457076L;    public APSProblem26(double a, double b, double expectedRoot) {      super(a, b, expectedRoot);    }    public double valueAt(double x) {      if (x == 0.0) {        return 0;      }      return x / Math.exp(1 / (x * x));    }    // this is a very special case since there is a wide range around    // the true root (which is 0) for which |f(x)| is smaller than the    // smallest representable positive number (according to IEEE 754):    //    f(0.03762210865...) = 2^-1024    //    f(0.03764056462...) = 2^-1023    //    f(0.03765904777...) = 2^-1022    //    f(0.03767755816...) = 2^-1021    // any root between -0.03768 and +0.03768 should be considered good    public boolean checkResult(double foundRoot, double tol) {      return Math.abs(foundRoot) <= 0.03768;    }  }  private static class APSProblem27 extends TestProblem {    private static final long serialVersionUID = -3549158218723499035L;    private double u;    public APSProblem27(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      u = n / 20.0;    }    public double valueAt(double x) {      if (x >= 0.0) {        return (x / 1.5 + Math.sin(x) - 1.0) * u;      }      return -u;    }  }  private static class APSProblem28 extends TestProblem {    private static final long serialVersionUID = -8198306839874267863L;    private double threshold;    private static final double yHigh= Math.exp(1.0) - 1.859;    private int    u;    public APSProblem28(int n, double a, double b, double expectedRoot) {      super(a, b, expectedRoot);      threshold = 0.002 / (1 + n);      u         = (n + 1) * 500;    }    public double valueAt(double x) {      if (x >= threshold) {        return yHigh;      } else if (x >= 0) {        return Math.exp(u * x) - 1.859;      } else {        return -0.859;      }    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.roots;import org.spaceroots.mantissa.functions.FunctionException;import junit.framework.*;public class BrentSolverTest  extends TestCase {  public BrentSolverTest(String name) {    super(name);  }  public void testAlefeldPotraShi()  throws FunctionException {    TestProblem[] problems = TestProblem.getAPSProblems();    BrentSolver solver     = new BrentSolver();    for (int i = 0; i < problems.length; ++i) {      TestProblem p = problems[i];      double tol = 1.0e-10 * Math.abs(p.getExpectedRoot());      assertTrue(solver.findRoot(p, new Checker(tol), 1000,                                 p.getA(), p.valueAt(p.getA()),                                 p.getB(), p.valueAt(p.getB())));      assertTrue(p.checkResult(solver.getRoot(), tol));    }  }  private static class Checker implements ConvergenceChecker {    private double tolerance;    public Checker (double tolerance) {      this.tolerance = tolerance;    }    public int converged (double xLow, double fLow,                          double xHigh, double fHigh) {      return (Math.abs(xHigh - xLow) <= tolerance)        ? ((Math.abs(fLow) <= Math.abs(fHigh))           ? ConvergenceChecker.LOW           : ConvergenceChecker.HIGH)        : ConvergenceChecker.NONE;    }  }  public static Test suite() {    return new TestSuite(BrentSolverTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.random;import junit.framework.*;public class ScalarSampleStatisticsTest  extends TestCase {  public ScalarSampleStatisticsTest(String name) {    super(name);    points = null;  }  public void testBasicStats() {    ScalarSampleStatistics sample = new ScalarSampleStatistics();    for (int i = 0; i < points.length; ++i) {      sample.add(points[i]);    }    assertEquals(points.length, sample.size());    assertEquals(-5.0, sample.getMin(), 1.0e-12);    assertEquals(10.4, sample.getMax(), 1.0e-12);    assertEquals( 3.0, sample.getMean(), 1.0e-12);    assertEquals( 3.920034013457876, sample.getStandardDeviation(),                  1.0e-12);  }  public void testAddSample() {    ScalarSampleStatistics all  = new ScalarSampleStatistics();    ScalarSampleStatistics even = new ScalarSampleStatistics();    ScalarSampleStatistics odd  = new ScalarSampleStatistics();    for (int i = 0; i < points.length; ++i) {      all.add(points[i]);      if (i % 2 == 0) {        even.add(points[i]);      } else {        odd.add(points[i]);      }    }    even.add(odd);    assertEquals(all.size(), even.size());    assertEquals(all.getMin(), even.getMin(), 1.0e-12);    assertEquals(all.getMax(), even.getMax(), 1.0e-12);    assertEquals(all.getMean(), even.getMean(), 1.0e-12);    assertEquals(all.getStandardDeviation(), even.getStandardDeviation(),                 1.0e-12);  }  public void testAddArray() {    ScalarSampleStatistics loop   = new ScalarSampleStatistics();    ScalarSampleStatistics direct = new ScalarSampleStatistics();    for (int i = 0; i < points.length; ++i) {      loop.add(points[i]);    }    direct.add(points);    assertEquals(loop.size(), direct.size());    assertEquals(loop.getMin(), direct.getMin(), 1.0e-12);    assertEquals(loop.getMax(), direct.getMax(), 1.0e-12);    assertEquals(loop.getMean(), direct.getMean(), 1.0e-12);    assertEquals(loop.getStandardDeviation(), direct.getStandardDeviation(),                 1.0e-12);  }  public void setUp() {    points = new double[] {1.0, 4.2, -5, 4.0, 2.9, 10.4, 0.0, 4.1, 4.2, 4.2};  }  public void tearDown() {    points = null;  }  public static Test suite() {    return new TestSuite(ScalarSampleStatisticsTest.class);  }  private double[] points;}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.algebra;import junit.framework.*;public class PolynomialFractionTest  extends TestCase {  public PolynomialFractionTest(String name) {    super(name);  }  public void testNullDenominator() {    try {      new PolynomialFraction(1l, 0l);      fail("an exception should have been thrown");    } catch (ArithmeticException e) {    } catch (Exception e) {      fail("wrong exception caught");    }  }  public void testToString() {    checkValue(new PolynomialFraction(1l, 2l),  "1/2");    checkValue(new PolynomialFraction(-1l, 2l), "-1/2");    checkValue(new PolynomialFraction(1l, -2l), "-1/2");    checkValue(new PolynomialFraction(-1l, -2l), "1/2");    checkValue(new PolynomialFraction(0l, 500l), "0");    checkValue(new PolynomialFraction(-12l), "-12");    checkValue(new PolynomialFraction(12l), "12");  }  public void testSimplification() {    checkValue(new PolynomialFraction(2l, 4l), "1/2");    checkValue(new PolynomialFraction(307692l, 999999l), "4/13");    checkValue(new PolynomialFraction(999999l, 307692l), "13/4");  }  public void testInvert() {    PolynomialFraction f = new PolynomialFraction(2l, 4l);    f= f.invert();    checkValue(f, "2");    f = f.invert();    checkValue(f, "1/2");    f = new PolynomialFraction(120l);    f = f.invert();    checkValue(f, "1/120");    f = new PolynomialFraction(0l, 4l);    try {      f = f.invert();      fail("an exception should have been thrown");    } catch (ArithmeticException e) {    } catch (Exception e) {      fail("wrong exception caught");    }    f = new PolynomialFraction(307692l, 999999l);    PolynomialFraction fInverse = f.invert();    checkValue(fInverse, "13/4");    checkValue(f, "4/13");  }  public void testAddition() {    PolynomialFraction f1 = new PolynomialFraction(4l, 6l);    f1 = f1.add(f1);    checkValue(f1, "4/3");    checkValue(new PolynomialFraction(17l, 3l).add(new PolynomialFraction(-17l, 3l)),               "0");    checkValue(new PolynomialFraction(2l, 3l).add(new PolynomialFraction(3l, 4l)),               "17/12");    checkValue(new PolynomialFraction(1l, 6l).add(new PolynomialFraction(2l, 6l)),               "1/2");    checkValue(new PolynomialFraction(4l, 5l).add(new PolynomialFraction(-3l, 4l)),               "1/20");    checkValue(new PolynomialFraction(-3l, 4l).add(new PolynomialFraction(4l, 5l)),               "1/20");  }  public void testSubtraction() {    PolynomialFraction f1 = new PolynomialFraction(4l, 6l);    checkValue(f1.subtract(f1), "0");    checkValue(new PolynomialFraction(7l, 3l).subtract(new PolynomialFraction(-7l, 3l)),               "14/3");    checkValue(new PolynomialFraction(3l, 4l).subtract(new PolynomialFraction(2l, 3l)),               "1/12");    checkValue(new PolynomialFraction(3l, 4l).subtract(new PolynomialFraction(-2l, 3l)),               "17/12");    checkValue(new PolynomialFraction(-3l, 4l).subtract(new PolynomialFraction(2l, 3l)),               "-17/12");    checkValue(new PolynomialFraction(-3l, 4l).subtract(new PolynomialFraction(-2l, 3l)),               "-1/12");    checkValue(new PolynomialFraction(2l, 3l).subtract(new PolynomialFraction(3l, 4l)),               "-1/12");    checkValue(new PolynomialFraction(-2l, 3l).subtract(new PolynomialFraction(3l, 4l)),               "-17/12");    checkValue(new PolynomialFraction(2l, 3l).subtract(new PolynomialFraction(-3l, 4l)),               "17/12");    checkValue(new PolynomialFraction(-2l, 3l).subtract(new PolynomialFraction(-3l, 4l)),               "1/12");    checkValue(new PolynomialFraction(1l, 6l).subtract(new PolynomialFraction(2l, 6l)),               "-1/6");    checkValue(new PolynomialFraction(1l, 2l).subtract(new PolynomialFraction(1l, 6l)),               "1/3");  }  public void testMultiplication() {    PolynomialFraction f = new PolynomialFraction(2l, 3l);    checkValue(f.multiply(new PolynomialFraction(9l,4l)), "3/2");    checkValue(new PolynomialFraction(1l, 2l).multiply(new PolynomialFraction(0l)),               "0");    checkValue(new PolynomialFraction(4l, 15l).multiply(new PolynomialFraction(-5l, 2l)),               "-2/3");    checkValue(new PolynomialFraction(-4l, 15l).multiply(new PolynomialFraction(5l, 2l)),               "-2/3");    checkValue(new PolynomialFraction(4l, 15l).multiply(new PolynomialFraction(5l, 2l)),               "2/3");    checkValue(new PolynomialFraction(-4l, 15l).multiply(new PolynomialFraction(-5l, 2l)),               "2/3");  }  public void testDivision() {    PolynomialFraction f = new PolynomialFraction(2l, 3l);    ;    checkValue(f.divide(new PolynomialFraction(4l,9l)), "3/2");    try {      new PolynomialFraction(1l, 2l).divide(new PolynomialFraction(0l));      fail("an exception should have been thrown");    } catch (ArithmeticException e) {    } catch (Exception e) {      fail("wrong exception caught");    }    checkValue(new PolynomialFraction(4l, 15l).divide(new PolynomialFraction(-2l, 5l)),               "-2/3");    checkValue(new PolynomialFraction(-4l, 15l).divide(new PolynomialFraction(2l, 5l)),               "-2/3");    checkValue(new PolynomialFraction(4l, 15l).divide(new PolynomialFraction(2l, 5l)),               "2/3");    checkValue(new PolynomialFraction(-4l, 15l).divide(new PolynomialFraction(-2l, 5l)),               "2/3");  }  public void testEuclidianDivision() {    checkValue(new PolynomialFraction(new Polynomial.Rational(1l, 0l, -1l),                                      new Polynomial.Rational(2l, 2l)),               "-1/2 + 1/2 x");    checkValue(new PolynomialFraction(new Polynomial.Rational(1l, 3l, 2l),                                      new Polynomial.Rational(2l, 10l, 12l)),               "(1 + x)/(6 + 2 x)");  }  private void checkValue(PolynomialFraction f, String reference) {    assertTrue(f.toString().equals(reference));  }  public static Test suite() {    return new TestSuite(PolynomialFractionTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.algebra;import java.math.BigInteger;import junit.framework.*;public class PolynomialRationalTest  extends TestCase {  public PolynomialRationalTest(String name) {    super(name);  }  public void testZero() {    assertTrue(new Polynomial.Rational().isZero());  }  public void testConstructors() {    Polynomial.Rational p = new Polynomial.Rational(1l, 3l, -5l);    RationalNumber[]  a = p.getCoefficients();    assertEquals(a.length, 3);    assertEquals(new RationalNumber(-5l), a[0]);    assertEquals(new RationalNumber(3l), a[1]);    assertEquals(new RationalNumber(1l), a[2]);    assertEquals(2, p.getDegree());    assertEquals(1, new Polynomial.Rational(0l, 3l, 5l).getDegree());    assertEquals(0, new Polynomial.Rational(0l, 0l, 5l).getDegree());    assertEquals(0, new Polynomial.Rational(0l, 0l, 0l).getDegree());    assertEquals(1, new Polynomial.Rational(3l, 5l).getDegree());    assertEquals(0, new Polynomial.Rational(0l, 5l).getDegree());    assertEquals(0, new Polynomial.Rational(0l, 0l).getDegree());    assertEquals(0, new Polynomial.Rational(5l).getDegree());    assertEquals(0, new Polynomial.Rational(0l).getDegree());  }  public void testString() {    Polynomial.Rational p = new Polynomial.Rational(1l, 3l, -5l);    checkPolynomial(p, "-5 + 3 x + x^2");    checkPolynomial(new Polynomial.Rational(3l, -2l, 0l), "-2 x + 3 x^2");    checkPolynomial(new Polynomial.Rational(3l, -2l, 1l), "1 - 2 x + 3 x^2");    checkPolynomial(new Polynomial.Rational(3l,  2l, 0l), "2 x + 3 x^2");    checkPolynomial(new Polynomial.Rational(3l,  2l, 1l), "1 + 2 x + 3 x^2");    checkPolynomial(new Polynomial.Rational(3l,  0l, 1l), "1 + 3 x^2");    checkPolynomial(new Polynomial.Rational(0l), "0");  }  public void testAddition() {    Polynomial.Rational p1 = new Polynomial.Rational(1l, -2l);    Polynomial.Rational p2 = new Polynomial.Rational(0l, -1l, 2l);    assertTrue(p1.add(p2).isZero());    p2 = p1.add(p1);    checkPolynomial(p2, "-4 + 2 x");    p1 = new Polynomial.Rational(2l, -4l, 1l);    p2 = new Polynomial.Rational(-2l, 3l, -1l);    p1 = p1.add(p2);    assertEquals(1, p1.getDegree());    checkPolynomial(p1, "-x");  }  public void testSubtraction() {    Polynomial.Rational p1 = new Polynomial.Rational(1l, -2l);    assertTrue(p1.subtract(p1).isZero());    Polynomial.Rational p2 = new Polynomial.Rational(6l, -2l);    p2 = p2.subtract(p1);    checkPolynomial(p2, "5 x");    p1 = new Polynomial.Rational(2l, -4l, 1l);    p2 = new Polynomial.Rational(2l, 3l, -1l);    p1 = p1.subtract(p2);    assertEquals(1, p1.getDegree());    checkPolynomial(p1, "2 - 7 x");  }  public void testMultiplication() {    Polynomial.Rational p1 = new Polynomial.Rational(2l, -3l);    Polynomial.Rational p2 = new Polynomial.Rational(1l, 2l, 3l);    checkPolynomial(p1.multiply(p2), "-9 + x^2 + 2 x^3");    p1 = new Polynomial.Rational(1l, 0l);    p2 = p1;    for (int i = 2; i < 10; ++i) {      p2 = p2.multiply(p1);      checkPolynomial(p2, "x^" + i);    }  }  public void testLCM() {    Polynomial.Rational p = new Polynomial.Rational(new RationalNumber(2l, 5l),                                                    new RationalNumber(-1l, 6l),                                                    new RationalNumber(3l, 4l));    checkPolynomial(p, "3/4 - 1/6 x + 2/5 x^2");    BigInteger lcm = p.getDenominatorsLCM();    assertEquals(BigInteger.valueOf(60l), lcm);    p = (Polynomial.Rational) p.multiply(lcm);    checkPolynomial(p, "45 - 10 x + 24 x^2");  }  public void testEuclidianDivision() {    Polynomial.Rational p = new Polynomial.Rational(4l, 6l, -3l);    Polynomial.Rational q = new Polynomial.Rational(3l, 2l);    Polynomial.DivisionResult res = Polynomial.Rational.euclidianDivision(p, q);    checkPolynomial(res.quotient,  "10/9 + 4/3 x");    checkPolynomial(res.remainder, "-47/9");  }  public void checkPolynomial(Polynomial.Rational p, String reference) {    assertEquals(reference, p.toString());  }  public static Test suite() {    return new TestSuite(PolynomialRationalTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.algebra;import junit.framework.*;public class PolynomialDoubleTest  extends TestCase {  public PolynomialDoubleTest(String name) {    super(name);  }  public void testConstructors() {    Polynomial.Double p = new Polynomial.Double(1.0, 3.0, -5.0);    double[] a = p.getCoefficients();    assertEquals(a.length, 3);    assertEquals(-5.0, a[0], 1.0e-12);    assertEquals(3.0,  a[1], 1.0e-12);    assertEquals(1.0,  a[2], 1.0e-12);    assertEquals(p.getDegree(), 2);    assertEquals(1, new Polynomial.Double(0.0, 3.0, 5.0).getDegree());    assertEquals(0, new Polynomial.Double(0.0, 0.0, 5.0).getDegree());    assertEquals(0, new Polynomial.Double(0.0, 0.0, 0.0).getDegree());    assertEquals(1, new Polynomial.Double(3.0, 5.0).getDegree());    assertEquals(0, new Polynomial.Double(0.0, 5.0).getDegree());    assertEquals(0, new Polynomial.Double(0.0, 0.0).getDegree());    assertEquals(0, new Polynomial.Double(5.0).getDegree());    assertEquals(0, new Polynomial.Double(0.0).getDegree());  }  public void testConversion() {    Polynomial.Rational r = new Polynomial.Rational(1l, 3l, -5l);    r = (Polynomial.Rational) r.multiply(new RationalNumber(1l, 2l));    Polynomial.Double p = new Polynomial.Double(r);    checkPolynomial(p, "-2.5 + 1.5 x + 0.5 x^2");  }  public void testString() {    Polynomial.Double p = new Polynomial.Double(1.0, 3.0, -5.0);    checkPolynomial(p, "-5.0 + 3.0 x + x^2");    checkPolynomial(new Polynomial.Double(3.0, -2.0, 0.0),                    "-2.0 x + 3.0 x^2");    checkPolynomial(new Polynomial.Double(3.0, -2.0, 1.0),                    "1.0 - 2.0 x + 3.0 x^2");    checkPolynomial(new Polynomial.Double(3.0,  2.0, 0.0),                    "2.0 x + 3.0 x^2");    checkPolynomial(new Polynomial.Double(3.0,  2.0, 1.0),                    "1.0 + 2.0 x + 3.0 x^2");    checkPolynomial(new Polynomial.Double(3.0,  0.0, 1.0),                    "1.0 + 3.0 x^2");    checkPolynomial(new Polynomial.Double(0.0),                    "0");  }  public void testAddition() {    Polynomial.Double p1 = new Polynomial.Double(1.0, -2.0);    Polynomial.Double p2 = new Polynomial.Double(0.0, -1.0, 2.0);    assertTrue(p1.add(p2).isZero());    p2 = p1.add(p1);    checkPolynomial(p2, "-4.0 + 2.0 x");    p1 = new Polynomial.Double(2.0, -4.0, 1.0);    p2 = new Polynomial.Double(-2.0, 3.0, -1.0);    p1 = p1.add(p2);    assertEquals(1, p1.getDegree());    checkPolynomial(p1, "-x");  }  public void testSubtraction() {    Polynomial.Double p1 = new Polynomial.Double(1.0, -2.0);    assertTrue(p1.subtract(p1).isZero());    Polynomial.Double p2 = new Polynomial.Double(6.0, -2.0);    p2 = p2.subtract(p1);    checkPolynomial(p2, "5.0 x");    p1 = new Polynomial.Double(2.0, -4.0, 1.0);    p2 = new Polynomial.Double(2.0, 3.0, -1.0);    p1 = p1.subtract(p2);    assertEquals(1, p1.getDegree());    checkPolynomial(p1, "2.0 - 7.0 x");  }  public void testMultiplication() {    Polynomial.Double p1 = new Polynomial.Double(2.0, -3.0);    Polynomial.Double p2 = new Polynomial.Double(1.0, 2.0, 3.0);    checkPolynomial(p1.multiply(p2), "-9.0 + x^2 + 2.0 x^3");    p1 = new Polynomial.Double(1.0, 0.0);    p2 = p1;    for (int i = 2; i < 10; ++i) {      p2 = p2.multiply(p1);      checkPolynomial(p2, "x^" + i);    }  }  public void checkPolynomial(Polynomial.Double p, String reference) {    assertEquals(reference, p.toString());  }  public static Test suite() {    return new TestSuite(PolynomialDoubleTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.algebra;import junit.framework.*;public class RationalNumberTest  extends TestCase {  public RationalNumberTest(String name) {    super(name);  }  public void testNullDenominator() {    try {      new RationalNumber(1l, 0l);      fail("an exception should have been thrown");    } catch (ArithmeticException e) {    } catch (Exception e) {      fail("wrong exception caught");    }  }  public void testToString() {    checkValue(new RationalNumber(1l, 2l),  "1/2");    checkValue(new RationalNumber(-1l, 2l), "-1/2");    checkValue(new RationalNumber(1l, -2l), "-1/2");    checkValue(new RationalNumber(-1l, -2l), "1/2");    checkValue(new RationalNumber(0l, 500l), "0");    checkValue(new RationalNumber(-12l), "-12");    checkValue(new RationalNumber(12l), "12");  }  public void testSimplification() {    checkValue(new RationalNumber(2l, 4l), "1/2");    checkValue(new RationalNumber(307692l, 999999l), "4/13");    checkValue(new RationalNumber(999999l, 307692l), "13/4");  }  public void testInvert() {    RationalNumber f = new RationalNumber(2l, 4l).invert();    checkValue(f, "2");    f = f.invert();    checkValue(f, "1/2");    f = new RationalNumber(120l).invert();    checkValue(f, "1/120");    f = new RationalNumber(0l, 4l);    try {      f.invert();      fail("an exception should have been thrown");    } catch (ArithmeticException e) {    } catch (Exception e) {      fail("wrong exception caught");    }    f = new RationalNumber(307692l, 999999l);    RationalNumber fInverse = f.invert();    checkValue(fInverse, "13/4");    checkValue(f, "4/13");  }  public void testAddition() {    RationalNumber f1 = new RationalNumber(4l, 6l);    f1 = f1.add(f1);    checkValue(f1, "4/3");    checkValue(new RationalNumber(17l, 3l).add(new RationalNumber(-17l, 3l)),               "0");    checkValue(new RationalNumber(2l, 3l).add(new RationalNumber(3l, 4l)),               "17/12");    checkValue(new RationalNumber(1l, 6l).add(new RationalNumber(2l, 6l)),               "1/2");    checkValue(new RationalNumber(4l, 5l).add(new RationalNumber(-3l, 4l)),               "1/20");    checkValue(new RationalNumber(-3l, 4l).add(new RationalNumber(4l, 5l)),               "1/20");  }  public void testSubtraction() {    RationalNumber f1 = new RationalNumber(4l, 6l);    f1 = f1.subtract(f1);    checkValue(f1, "0");    checkValue(new RationalNumber(7l, 3l).subtract(new RationalNumber(-7l, 3l)),               "14/3");    checkValue(new RationalNumber(3l, 4l).subtract(new RationalNumber(2l, 3l)),               "1/12");    checkValue(new RationalNumber(3l, 4l).subtract(new RationalNumber(-2l, 3l)),               "17/12");    checkValue(new RationalNumber(-3l, 4l).subtract(new RationalNumber(2l, 3l)),               "-17/12");    checkValue(new RationalNumber(-3l, 4l).subtract(new RationalNumber(-2l, 3l)),               "-1/12");    checkValue(new RationalNumber(2l, 3l).subtract(new RationalNumber(3l, 4l)),               "-1/12");    checkValue(new RationalNumber(-2l, 3l).subtract(new RationalNumber(3l, 4l)),               "-17/12");    checkValue(new RationalNumber(2l, 3l).subtract(new RationalNumber(-3l, 4l)),               "17/12");    checkValue(new RationalNumber(-2l, 3l).subtract(new RationalNumber(-3l, 4l)),               "1/12");    checkValue(new RationalNumber(1l, 6l).subtract(new RationalNumber(2l, 6l)),               "-1/6");    checkValue(new RationalNumber(1l, 2l).subtract(new RationalNumber(1l, 6l)),               "1/3");  }  public void testMultiplication() {    RationalNumber f = new RationalNumber(2l, 3l);    f = f.multiply(new RationalNumber(9l,4l));    checkValue(f, "3/2");    checkValue(new RationalNumber(1l, 2l).multiply(new RationalNumber(0l)),               "0");    checkValue(new RationalNumber(4l, 15l).multiply(new RationalNumber(-5l, 2l)),               "-2/3");    checkValue(new RationalNumber(-4l, 15l).multiply(new RationalNumber(5l, 2l)),               "-2/3");    checkValue(new RationalNumber(4l, 15l).multiply(new RationalNumber(5l, 2l)),               "2/3");    checkValue(new RationalNumber(-4l, 15l).multiply(new RationalNumber(-5l, 2l)),               "2/3");  }  public void testDivision() {    RationalNumber f = new RationalNumber(2l, 3l);    f = f.divide(new RationalNumber(4l,9l));    checkValue(f, "3/2");    try {      new RationalNumber(1l, 2l).divide(new RationalNumber(0l));      fail("an exception should have been thrown");    } catch (ArithmeticException e) {    } catch (Exception e) {      fail("wrong exception caught");    }    checkValue(new RationalNumber(4l, 15l).divide(new RationalNumber(-2l, 5l)),               "-2/3");    checkValue(new RationalNumber(-4l, 15l).divide(new RationalNumber(2l, 5l)),               "-2/3");    checkValue(new RationalNumber(4l, 15l).divide(new RationalNumber(2l, 5l)),               "2/3");    checkValue(new RationalNumber(-4l, 15l).divide(new RationalNumber(-2l, 5l)),               "2/3");  }  private void checkValue(RationalNumber f, String reference) {    assertTrue(f.toString().equals(reference));  }  public static Test suite() {    return new TestSuite(RationalNumberTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.linalg;import junit.framework.*;public class NonNullRangeTest  extends TestCase {  public NonNullRangeTest(String name) {    super(name);  }  public void testPublicAttributes() {    NonNullRange r = new NonNullRange(2, 7);    assertTrue(r.begin == 2);    assertTrue(r.end   == 7);  }  public void testCopy() {    NonNullRange r1 = new NonNullRange(2, 7);    NonNullRange r2 = new NonNullRange(r1);    assertTrue(r2.begin == r1.begin);    assertTrue(r1.end   == r1.end);  }  public void testIntersection() {    NonNullRange r1 = new NonNullRange(-4, 8);    NonNullRange r2 = new NonNullRange(3, 12);    NonNullRange r3 = NonNullRange.intersection(r1, r2);    assertTrue(r3.begin == 3);    assertTrue(r3.end   == 8);  }  public void testReunion() {    NonNullRange r1 = new NonNullRange(-4, 8);    NonNullRange r2 = new NonNullRange(3, 12);    NonNullRange r3 = NonNullRange.reunion(r1, r2);    assertTrue(r3.begin == -4);    assertTrue(r3.end   == 12);  }  public static Test suite() {    return new TestSuite(NonNullRangeTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.linalg;import junit.framework.*;public class DiagonalMatrixTest  extends TestCase {  public DiagonalMatrixTest(String name) {    super(name);  }  public void testConstantDiagonal() {    checkMatrix(new DiagonalMatrix(5, 2.7), 2.7);  }  public void testNoSetOutsideOfDiagonal() {    DiagonalMatrix d = new DiagonalMatrix(4);    for (int i = 0; i < d.getRows(); ++i) {      for (int j = 0; j < d.getColumns(); ++j) {        if (i == j) {          d.setElement(i, j, 2.7);        } else {          boolean gotIt = false;          try {            d.setElement(i, j, -1.3);          } catch (ArrayIndexOutOfBoundsException e) {            gotIt = true;          }          assertTrue(gotIt);        }      }    }    checkMatrix(d, 2.7);  }  public void testCopy() {    DiagonalMatrix d1 = new DiagonalMatrix(7, 4.3);    DiagonalMatrix d2 = new DiagonalMatrix(d1);    for (int i = 0; i < d1.getRows(); ++i) {      d1.setElement(i, i, -1.0);    }    assertTrue(d2.getRows() == d1.getRows());    assertTrue(d2.getColumns() == d1.getColumns());    checkMatrix(d2, 4.3);  }  public void testDuplicate() {    DiagonalMatrix d1 = new DiagonalMatrix(6, -8.8);    Matrix d2 = d1.duplicate();    assertTrue(d2 instanceof DiagonalMatrix);    for (int i = 0; i < d1.getRows(); ++i) {      d1.setElement(i, i, -1.0);    }    assertTrue(d2.getRows() == d1.getRows());    assertTrue(d2.getColumns() == d1.getColumns());    checkMatrix(d2, -8.8);  }  public void testTranspose() {    DiagonalMatrix d = new DiagonalMatrix(5, 3.4);    Matrix transposed = d.getTranspose();    assertTrue(transposed instanceof DiagonalMatrix);    checkMatrix(transposed, 3.4);  }  public void testDeterminant() {    double expected;    expected = 1.0;    for (int k = 1; k < 10; ++k) {      expected *= 2;      DiagonalMatrix d = new DiagonalMatrix(k, 2.0);      assertTrue(Math.abs(d.getDeterminant(1.0e-10) - expected) < 1.0e-10);    }    expected = 1.0;    for (int k = 1; k < 10; ++k) {      expected *= k;      DiagonalMatrix d = new DiagonalMatrix(k);      for (int i = 0; i < k; ++i) {        d.setElement(i, i, i + 1);      }      assertTrue(Math.abs(d.getDeterminant(1.0e-10) - expected) < 1.0e-10);    }  }  public void testSolve()    throws SingularMatrixException {    DiagonalMatrix d = new DiagonalMatrix(6);    for (int i = 0; i < d.getRows(); ++i) {      d.setElement(i, i, i + 1.0);    }    GeneralMatrix b = new GeneralMatrix(6, 3);    for (int i = 0; i < b.getRows(); ++i) {      b.setElement(i, 0, i + 1.0);      b.setElement(i, 1, (i + 1.0) * (i + 1.0));      b.setElement(i, 2, 0.0);    }    Matrix result = d.solve(b, 1.0e-10);    assertTrue(result.getRows() == b.getRows());    assertTrue(result.getColumns() == b.getColumns());    for (int i = 0; i < result.getRows(); ++i) {      assertTrue(Math.abs(result.getElement(i, 0) - 1.0)       < 1.0e-10);      assertTrue(Math.abs(result.getElement(i, 1) - (i + 1.0)) < 1.0e-10);      assertTrue(Math.abs(result.getElement(i, 2) - 0.0)       < 1.0e-10);    }    boolean gotIt = false;    try {      d.setElement(3, 3, 0.0);      d.solve(b, 1.0e-10);    } catch (SingularMatrixException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testInverse()    throws SingularMatrixException {    DiagonalMatrix d = new DiagonalMatrix(4);    for (int i = 0; i < d.getRows (); ++i) {      d.setElement(i, i, i + 1.0);    }    Matrix inverse = d.getInverse(1.0e-10);    assertTrue(inverse instanceof DiagonalMatrix);    for (int i = 0; i < inverse.getRows(); ++i) {      assertTrue(Math.abs(inverse.getElement(i, i) - 1.0 / (i + 1.0)) < 1.0e-10);    }  }  public static Test suite() {    return new TestSuite(DiagonalMatrixTest.class);  }  public void checkMatrix(Matrix d, double value) {    for (int i = 0; i < d.getRows(); ++i) {      for (int j = 0; j < d.getColumns(); ++j) {        double expected = (i == j) ? value : 0.0;        assertTrue(Math.abs(d.getElement(i, j) - expected) < 1.0e-10);      }    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.linalg;import junit.framework.*;public class GeneralMatrixTest  extends TestCase {  public GeneralMatrixTest(String name) {    super(name);  }  public void testDimensions() {    GeneralMatrix m = new GeneralMatrix(3, 4);    assertTrue(m.getRows() == 3);    assertTrue(m.getColumns() == 4);  }  public void testInvalidDimensions() {    boolean gotIt;    gotIt = false;    try {      new GeneralMatrix(0, 2);    } catch(IllegalArgumentException e) {      gotIt = true;    }    assertTrue(gotIt);    gotIt = false;    try {      new GeneralMatrix(1, -3, null);    } catch(IllegalArgumentException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testElements() {    Matrix m = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    checkMatrix(m, new BilinearPattern(1.0, 0.01));  }  public void testCopy() {    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    GeneralMatrix m2 = new GeneralMatrix(m1);    for (int i = 0; i < m1.getRows(); ++i) {      for (int j = 0; j < m1.getColumns(); ++j) {        m1.setElement(i, j, -1.0);      }    }    assertTrue(m2.getRows() == m1.getRows());    assertTrue(m2.getColumns() == m1.getColumns());    checkMatrix(m2, new BilinearPattern(1.0, 0.01));  }  public void testDuplicate() {    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    Matrix m2 = m1.duplicate();    assertTrue(m2 instanceof GeneralMatrix);    for (int i = 0; i < m1.getRows(); ++i) {      for (int j = 0; j < m1.getColumns(); ++j) {        m1.setElement(i, j, -1.0);      }    }    assertTrue(m2.getRows() == m1.getRows());    assertTrue(m2.getColumns() == m1.getColumns());    checkMatrix (m2, new BilinearPattern(1.0, 0.01));  }  public void testAddKO() {    boolean gotIt = false;    try {      new GeneralMatrix(2, 3).add(new GeneralMatrix(3, 2));    } catch(IllegalArgumentException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testAddOK() {    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    Matrix m2 = buildMatrix(m1.getRows(),                            m1.getColumns(),                            new BilinearPattern(100, -0.01));    Matrix m3 = m1.add(m2);    checkMatrix(m3, new BilinearPattern(101, 0));  }  public void testSelfAdd() {    GeneralMatrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    Matrix m2 = buildMatrix(m1.getRows(),                            m1.getColumns(),                            new BilinearPattern(100, -0.01));    m1.selfAdd(m2);    checkMatrix(m1, new BilinearPattern(101, 0));  }  public void testSubKO() {    boolean gotIt = false;    try {      new GeneralMatrix(2, 3).sub(new GeneralMatrix(3, 2));    } catch(IllegalArgumentException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testSubOK() {    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    Matrix m2 = buildMatrix(m1.getRows(),                            m1.getColumns(),                            new BilinearPattern(100, -0.01));    Matrix m3 = m1.sub(m2);    checkMatrix(m3, new BilinearPattern(-99, 0.02));  }  public void testSelfSub() {    GeneralMatrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    Matrix m2 = buildMatrix(m1.getRows(),                            m1.getColumns(),                            new BilinearPattern(100, -0.01));    m1.selfSub(m2);    checkMatrix(m1, new BilinearPattern(-99, 0.02));  }  public void testMulMKO() {    boolean gotIt = false;    try {      new GeneralMatrix(2, 3).mul(new GeneralMatrix(2, 3));    } catch(IllegalArgumentException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testMulMOK() {    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    Matrix m2 = buildMatrix(m1.getColumns(), 4, new BilinearPattern(2, -1));    Matrix m3 = m1.mul(m2);    checkMatrix(m3, new ComplexPattern(m1.getColumns()));  }  public void testMulD() {    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    Matrix m2 = m1.mul(2.5);    checkMatrix(m2, new BilinearPattern(2.5, 0.025));  }  public void testSelfMul() {    Matrix m = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    m.selfMul(2.5);    checkMatrix(m, new BilinearPattern(2.5, 0.025));  }  public void testTranspose() {    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));    Matrix m2 = m1.getTranspose();    assertTrue(m1.getRows() == m2.getColumns());    assertTrue(m1.getColumns() == m2.getRows());    checkMatrix(m2, new BilinearPattern(0.01, 1.0));  }  public static Test suite() {    return new TestSuite(GeneralMatrixTest.class);  }  private interface ElementPattern {    public double value(int i, int j);  }  private static class BilinearPattern implements ElementPattern {    public BilinearPattern(double coeffI, double coeffJ) {      this.coeffI = coeffI;      this.coeffJ = coeffJ;    }    public double value(int i, int j) {      return coeffI * i + coeffJ * j;    }    private final double coeffI;    private final double coeffJ;  }  private static class ComplexPattern implements ElementPattern {    public ComplexPattern(int p) {      this.p = p;    }    public double value(int i, int j) {      return p * ((2 * i - 0.01 *j) * (p - 1) / 2.0                  - i* j                  + (p - 1) * (2 * p - 1) / 300.0);    }    private final int p;  }    public GeneralMatrix buildMatrix(int rows, int columns,                                   BilinearPattern pattern) {    GeneralMatrix m = new GeneralMatrix(rows, columns);    for (int i = 0; i < m.getRows(); ++i) {      for (int j = 0; j < m.getColumns(); ++j){        m.setElement(i, j, pattern.value(i, j));      }    }    return m;  }  public void checkMatrix(Matrix m, ElementPattern pattern) {    for (int i = 0; i < m.getRows(); ++i) {      for (int j = 0; j < m.getColumns(); ++j) {        assertTrue(Math.abs(m.getElement(i, j) - pattern.value(i, j))                   < 1.0e-10);      }    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.linalg;import junit.framework.*;public class MatrixFactoryTest  extends TestCase {  public MatrixFactoryTest(String name) {    super(name);  }  public void testInvalidDimensions() {    boolean gotIt;    gotIt = false;    try {      MatrixFactory.buildMatrix(0, 2, null, 1, 1);    } catch (IllegalArgumentException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testDiagonal() {    Matrix m = MatrixFactory.buildMatrix(3, 3, null, 0, 0);    assertTrue(m instanceof DiagonalMatrix);  }  public void testLowerTriangular() {    Matrix m = MatrixFactory.buildMatrix(3, 3, null, 1, 0);    assertTrue(m instanceof LowerTriangularMatrix);  }  public void testUpperTriangular() {    Matrix m = MatrixFactory.buildMatrix(3, 3, null, 0, 1);    assertTrue(m instanceof UpperTriangularMatrix);  }  public void testSquare() {    Matrix m = MatrixFactory.buildMatrix(3, 3, null, 1, 1);    assertTrue(m instanceof GeneralSquareMatrix);  }  public void testGeneral() {    Matrix m = MatrixFactory.buildMatrix(3, 4, null, 0, 0);    assertTrue(m instanceof GeneralMatrix);  }  public static Test suite() {    return new TestSuite(MatrixFactoryTest.class);  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.linalg;import junit.framework.*;public class SymetricalMatrixTest  extends TestCase {  public SymetricalMatrixTest(String name) {    super(name);  }  public void testBuildWAAt() {    double[] a = { 1.0, 2.0, 3.0 };    SymetricalMatrix s = new SymetricalMatrix(0.99, a);    checkMatrix(s, new ElementPattern() {        public double value(int i, int j) {          return 0.99 * (i + 1) * (j + 1);        }      });  }  public void testNoSetOutsideOfDiagonal() {    SymetricalMatrix s = new SymetricalMatrix(4);    for (int i = 0; i < s.getRows(); ++i) {      for (int j = 0; j < s.getColumns(); ++j) {        if (i == j) {          s.setElement(i, j, 0.5);        } else {          boolean gotIt = false;          try {            s.setElement              (i, j, -1.3);          } catch(ArrayIndexOutOfBoundsException e) {            gotIt = true;          }          assertTrue(gotIt);        }      }    }    checkMatrix(s, new ElementPattern() {        public double value(int i, int j) {          return (i == j) ? 0.5 : 0.0;        }      });  }  public void testSetElementAndSymetricalElement() {    SymetricalMatrix s = new SymetricalMatrix(5);    s.setElementAndSymetricalElement(1, 2, 3.4);    assertTrue(Math.abs(s.getElement(1, 2) - 3.4) < 1.0e-10);    assertTrue(Math.abs(s.getElement(2, 1) - 3.4) < 1.0e-10);  }  public void testCopy() {    SymetricalMatrix m1 = buildMatrix(5, new ElementPattern() {        public double value(int i, int j) {          return i * i + j * j;        }      });    SymetricalMatrix m2 = new SymetricalMatrix(m1);    for (int i = 0; i < m1.getRows(); ++i) {      for (int j = i; j < m1.getColumns(); ++j) {        m1.setElementAndSymetricalElement(i, j, -1.0);      }    }    assertTrue(m2.getRows() == m1.getRows());    assertTrue(m2.getColumns() == m1.getColumns());    checkMatrix(m2, new ElementPattern() {        public double value(int i, int j) {          return i * i + j * j;        }      });  }  public void testDuplicate() {    SymetricalMatrix m1 = buildMatrix(5, new ElementPattern() {        public double value(int i, int j) {          return i * j;        }      });    Matrix m2 = m1.duplicate();    assertTrue(m2 instanceof SymetricalMatrix);    for (int i = 0; i < m1.getRows(); ++i) {      for (int j = i; j < m1.getColumns(); ++j) {        m1.setElementAndSymetricalElement(i, j, -1.0);      }    }    assertTrue(m2.getRows() == m1.getRows());    assertTrue(m2.getColumns() == m1.getColumns());    checkMatrix(m2, new ElementPattern() {        public double value(int i, int j) {          return i * j;        }      });  }  public void testSelfAdd() {    double[] a1 = { 2.0, 4.0, 8.0, 16.0 };    SymetricalMatrix s1 = new SymetricalMatrix(0.5, a1);    double[] a2 = { 3.0, 9.0, 27.0, 81.0 };    SymetricalMatrix s2 = new SymetricalMatrix(1.0, a2);    s1.selfAdd(s2);    checkMatrix(s1, new ElementPattern() {        public double value(int i, int j) {          return 0.5 * Math.pow(2.0, i + 1) * Math.pow(2.0, j + 1)            + Math.pow(3.0, i + 1) * Math.pow(3.0, j + 1);        }      });  }  public void testSelfSub() {    double[] a1 = { 2.0, 4.0, 8.0, 16.0 };    SymetricalMatrix s1 = new SymetricalMatrix(0.5, a1);    double[] a2 = { 3.0, 9.0, 27.0, 81.0 };    SymetricalMatrix s2 = new SymetricalMatrix(1.0, a2);    s1.selfSub(s2);    checkMatrix(s1, new ElementPattern() {        public double value(int i, int j) {          return 0.5 * Math.pow(2.0, i + 1) * Math.pow(2.0, j + 1)            - Math.pow(3.0, i + 1) * Math.pow(3.0, j + 1);        }      });  }  public void testSelfAddWAAt() {    SymetricalMatrix s = new SymetricalMatrix(3);    double[] a1 = { 1.0, 2.0, 3.0 };    s.selfAddWAAt(1.0, a1);    double[] a2 = { 0.1, 0.2, 0.3 };    s.selfAddWAAt(2.0, a2);    checkMatrix(s, new ElementPattern() {        public double value(int i, int j) {          return 1.02 * (i + 1) * (j + 1);        }      });  }  public void testSingular()    throws SingularMatrixException {    SymetricalMatrix s = new SymetricalMatrix(3);    double[] a1 = { 1.0, 2.0, 3.0 };    s.selfAddWAAt(1.0, a1);    double[] a2 = { 0.1, 0.2, 0.3 };    s.selfAddWAAt(2.0, a2);    Matrix b = new GeneralMatrix(3, 1);    b.setElement(0, 0,  6.12);    b.setElement(1, 0, 12.24);    b.setElement(2, 0, 18.36);    boolean gotIt = false;    try {      s.solve(b, 1.0e-10);    } catch(SingularMatrixException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testSolve()    throws SingularMatrixException {    SymetricalMatrix s = new SymetricalMatrix(3);    double[] a1 = { 1.0, 2.0, 3.0 };    s.selfAddWAAt(1.0, a1);    double[] a2 = { 0.1, 0.2, 0.3 };    s.selfAddWAAt(2.0, a2);    double[] a3 = { 1.2, -3.0, 2.1 };    s.selfAddWAAt(3.0, a3);    double[] a4 = { 0.4, 0.1, 3.1 };    s.selfAddWAAt(2.0, a4);    Matrix b = new GeneralMatrix(3, 1);    b.setElement(0, 0, 10.08);    b.setElement(1, 0, 10.26);    b.setElement(2, 0, 42.57);    Matrix x = s.solve(b, 1.0e-10);    checkMatrix (x, new ElementPattern() {        public double value(int i, int j) {          return 1.0;        }      });    assertTrue(Math.abs(s.getDeterminant(1.0e-10) - 782.846532) < 1.0e-10);  }  public static Test suite() {    return new TestSuite(SymetricalMatrixTest.class);  }  public interface ElementPattern {    public double value(int i, int j);  }  public SymetricalMatrix buildMatrix(int order,                                      ElementPattern pattern) {    SymetricalMatrix m = new SymetricalMatrix(order);    for (int i = 0; i < m.getRows(); ++i) {      for (int j = i; j < m.getColumns(); ++j) {        m.setElementAndSymetricalElement(i, j, pattern.value(i, j));      }    }    return m;  }  public void checkMatrix(Matrix m, ElementPattern pattern) {    for (int i = 0; i < m.getRows(); ++i) {      for (int j = 0; j < m.getColumns(); ++j) {        assertTrue(Math.abs(m.getElement(i, j) - pattern.value(i, j))                   < 1.0e-10);      }    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.linalg;import junit.framework.*;public class LowerTriangularMatrixTest  extends TestCase {  public LowerTriangularMatrixTest(String name) {    super(name);  }  public void testNoSetOutsideOfLowerTriangle() {    LowerTriangularMatrix l = new LowerTriangularMatrix(4);    for (int i = 0; i < l.getRows(); ++i) {      for (int j = 0; j < l.getColumns(); ++j) {        if (i >= j) {          l.setElement(i, j, i + 0.1 * j);        } else {          boolean gotIt = false;          try {            l.setElement(i, j, -1.3);          } catch(ArrayIndexOutOfBoundsException e) {            gotIt = true;          }          assertTrue(gotIt);        }      }    }    checkMatrix(l, new BilinearPattern(1.0, 0.1));  }  public void testCopy() {    LowerTriangularMatrix l1 = buildMatrix(4, new BilinearPattern(1.0, 0.01));    LowerTriangularMatrix l2 = new LowerTriangularMatrix (l1);    checkMatrix (l2, new BilinearPattern(1.0, 0.01));  }  public void testDuplicate() {    LowerTriangularMatrix l1 = buildMatrix(4, new BilinearPattern(1.0, 0.01));    Matrix l2 = l1.duplicate();    assertTrue(l2 instanceof LowerTriangularMatrix);    checkMatrix(l2, new BilinearPattern(1.0, 0.01));  }  public void testTranspose() {    LowerTriangularMatrix l = buildMatrix(7, new BilinearPattern(1.0, 0.1));    Matrix transposed = l.getTranspose();    assertTrue(transposed instanceof UpperTriangularMatrix);    for (int i = 0; i < transposed.getRows(); ++i){      for (int j = 0; j < transposed.getColumns(); ++j) {        double expected = (i > j) ? 0.0 : (j + 0.1 * i);        assertTrue(Math.abs(transposed.getElement(i, j) - expected) < 1.0e-10);      }    }  }  public void testSelfAdd() {    LowerTriangularMatrix l1 = buildMatrix(7, new BilinearPattern(3, -0.2));    LowerTriangularMatrix l2 = buildMatrix(7, new BilinearPattern(2, -0.4));    l1.selfAdd(l2);    checkMatrix(l1, new BilinearPattern(5, -0.6));  }  public void testSelfSub() {    LowerTriangularMatrix l1 = buildMatrix(7, new BilinearPattern(3, -0.2));    LowerTriangularMatrix l2 = buildMatrix(7, new BilinearPattern(2, -0.4));    l1.selfSub(l2);    checkMatrix(l1, new BilinearPattern(1, 0.2));  }  public void testDeterminant() {    LowerTriangularMatrix l = buildMatrix(4, new ElementPattern() {        public double value(int i, int j) {          return (i == j) ? 2.0 : 1.0;        }      });    assertTrue(Math.abs(l.getDeterminant(1.0e-10) - Math.pow(2.0, l.getRows()))               < 1.0e-10);  }  public void testSolve()    throws SingularMatrixException {    LowerTriangularMatrix l = buildMatrix(7, new ElementPattern() {        public double value(int i, int j) {          return 1.0;        }      });    GeneralMatrix b = new GeneralMatrix(l.getRows(), 3);    for (int i = 0; i < b.getRows(); ++i) {      b.setElement(i, 0, i + 1.0);      b.setElement(i, 1, (i + 1.0) * (i + 2.0) / 2.0);      b.setElement(i, 2, 0.0);    }    Matrix result = l.solve(b, 1.0e-10);    assertTrue(result.getRows() == b.getRows());    assertTrue(result.getColumns() == b.getColumns());    for (int i = 0; i < result.getRows(); ++i) {      assertTrue(Math.abs(result.getElement(i, 0) - 1.0)       < 1.0e-10);      assertTrue(Math.abs(result.getElement(i, 1) - (i + 1.0)) < 1.0e-10);      assertTrue(Math.abs(result.getElement(i, 2) - 0.0)       < 1.0e-10);    }    boolean gotIt = false;    try {      l.setElement(3, 3, 0.0);      l.solve(b, 1.0e-10);    } catch(SingularMatrixException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testInverse()    throws SingularMatrixException {    LowerTriangularMatrix l = buildMatrix(5, new ElementPattern() {        public double value(int i, int j) {          return 1.0;        }      });    Matrix inverse = l.getInverse(1.0e-10);    assertTrue(inverse instanceof LowerTriangularMatrix);    checkMatrix(inverse, new ElementPattern() {        public double value(int i, int j) {          return (i == j) ? 1.0 : ((i == j + 1) ? -1.0 : 0.0);        }      });  }  public static Test suite() {    return new TestSuite(LowerTriangularMatrixTest.class);  }  public interface ElementPattern {    public double value(int i, int j);  }  private static class BilinearPattern implements ElementPattern {    public BilinearPattern(double coeffI, double coeffJ) {      this.coeffI = coeffI;      this.coeffJ = coeffJ;    }    public double value(int i, int j) {      return coeffI * i + coeffJ * j;    }    private final double coeffI;    private final double coeffJ;  }  public LowerTriangularMatrix buildMatrix(int order,                                           ElementPattern pattern) {    LowerTriangularMatrix m = new LowerTriangularMatrix(order);    for (int i = 0; i < m.getRows(); ++i) {      for (int j = 0; j <= i; ++j) {        m.setElement(i, j, pattern.value(i, j));      }    }    return m;  }  public void checkMatrix(Matrix m, ElementPattern pattern) {    for (int i = 0; i < m.getRows(); ++i) {      for (int j = 0; j < m.getColumns(); ++j) {        double expected = (j <= i) ? pattern.value(i, j) : 0.0;        assertTrue(Math.abs(m.getElement(i, j) - expected) < 1.0e-10);      }    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.linalg;import junit.framework.*;public class UpperTriangularMatrixTest  extends TestCase {  public UpperTriangularMatrixTest(String name) {    super(name);  }  public void testNoSetOutsideOfUpperTriangle() {    UpperTriangularMatrix u = new UpperTriangularMatrix(4);    for (int i = 0; i < u.getRows(); ++i) {      for (int j = 0; j < u.getColumns(); ++j) {        if (i <= j) {          u.setElement(i, j, i + 0.1 * j);        } else {          boolean gotIt = false;          try {            u.setElement(i, j, -1.3);          } catch(ArrayIndexOutOfBoundsException e) {            gotIt = true;          }          assertTrue(gotIt);        }      }    }    checkMatrix(u, new BilinearPattern(1.0, 0.1));  }  public void testCopy() {    UpperTriangularMatrix u1 = buildMatrix(4, new BilinearPattern(1.0, 0.1));    UpperTriangularMatrix u2 = new UpperTriangularMatrix(u1);    checkMatrix(u2, new BilinearPattern(1.0, 0.1));  }  public void testDuplicate() {    UpperTriangularMatrix u1 = buildMatrix(4, new BilinearPattern(1.0, 0.1));    Matrix u2 = u1.duplicate();    assertTrue(u2 instanceof UpperTriangularMatrix);    checkMatrix(u2, new BilinearPattern(1.0, 0.1));  }  public void testTranspose() {    UpperTriangularMatrix u = buildMatrix(7, new BilinearPattern(1.0, 0.1));    Matrix transposed = u.getTranspose();    assertTrue(transposed instanceof LowerTriangularMatrix);    for (int i = 0; i < transposed.getRows(); ++i){      for (int j = 0; j < transposed.getColumns(); ++j) {        double expected = (i < j) ? 0.0 : (j + 0.1 * i);        assertTrue(Math.abs(transposed.getElement(i, j) - expected) < 1.0e-10);      }    }  }  public void testSelfAdd() {    UpperTriangularMatrix u1 = buildMatrix(7, new BilinearPattern(3, -0.2));    UpperTriangularMatrix u2 = buildMatrix(7, new BilinearPattern(2, -0.4));    u1.selfAdd(u2);    checkMatrix(u1, new BilinearPattern(5, -0.6));  }  public void testSelfSub() {    UpperTriangularMatrix u1 = buildMatrix(7, new BilinearPattern(3, -0.2));    UpperTriangularMatrix u2 = buildMatrix(7, new BilinearPattern(2, -0.4));    u1.selfSub(u2);    checkMatrix(u1, new BilinearPattern(1, 0.2));  }  public void testDeterminant() {    UpperTriangularMatrix u = buildMatrix(4, new ElementPattern() {        public double value(int i, int j) {          return (i == j) ? 2.0 : 1.0;        }      });    assertTrue(Math.abs(u.getDeterminant(1.0e-10) - Math.pow(2.0, u.getRows()))               < 1.0e-10);  }  public void testSolve()    throws SingularMatrixException {    int rows = 7;    UpperTriangularMatrix u = buildMatrix(rows, new ElementPattern() {        public double value(int i, int j) {          return 1.0;        }      });    GeneralMatrix b = new GeneralMatrix(rows, 3);    for (int i = 0; i < rows; ++i) {      b.setElement(i, 0, rows - i);      b.setElement(i, 1, (rows - i) * (rows + 1 - i) / 2.0);      b.setElement(i, 2, 0.0);    }    Matrix result = u.solve(b, 1.0e-10);    assertTrue(result.getRows() == b.getRows());    assertTrue(result.getColumns() == b.getColumns());    for (int i = 0; i < result.getRows(); ++i) {      assertTrue(Math.abs(result.getElement(i, 0) - 1.0)        < 1.0e-10);      assertTrue(Math.abs(result.getElement(i, 1) - (rows - i)) < 1.0e-10);      assertTrue(Math.abs(result.getElement(i, 2) - 0.0)        < 1.0e-10);    }    boolean gotIt = false;    try {      u.setElement(3, 3, 0.0);      u.solve(b, 1.0e-10);    } catch(SingularMatrixException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testInverse()    throws SingularMatrixException {    UpperTriangularMatrix u = buildMatrix(5, new ElementPattern() {        public double value(int i, int j) {          return 1.0;        }      });    Matrix inverse = u.getInverse(1.0e-10);    assertTrue(inverse instanceof UpperTriangularMatrix);    checkMatrix(inverse, new ElementPattern() {        public double value(int i, int j) {          return (i == j) ? 1.0 : ((i == j - 1) ? -1.0 : 0.0);        }      });  }  public static Test suite() {    return new TestSuite(UpperTriangularMatrixTest.class);  }  public interface ElementPattern {    public double value(int i, int j);  }  private static class BilinearPattern implements ElementPattern {    public BilinearPattern(double coeffI, double coeffJ) {      this.coeffI = coeffI;      this.coeffJ = coeffJ;    }    public double value(int i, int j) {      return coeffI * i + coeffJ * j;    }    private final double coeffI;    private final double coeffJ;  }  public UpperTriangularMatrix buildMatrix(int order,                                           ElementPattern pattern) {    UpperTriangularMatrix m = new UpperTriangularMatrix (order);    for (int i = 0; i < m.getRows(); ++i) {      for (int j = i; j < m.getColumns(); ++j) {        m.setElement(i, j, pattern.value(i, j));      }    }    return m;  }  public void checkMatrix(Matrix m, ElementPattern pattern) {    for (int i = 0; i < m.getRows(); ++i) {      for (int j = 0; j < m.getColumns(); ++j) {        double expected = (i <= j) ? pattern.value(i, j) : 0.0;        assertTrue(Math.abs(m.getElement(i, j) - expected) < 1.0e-10);      }    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.linalg;import junit.framework.*;public class GeneralSquareMatrixTest  extends TestCase {  public GeneralSquareMatrixTest(String name) {    super(name);  }  public void testDimensions() {    GeneralSquareMatrix m = new GeneralSquareMatrix(3);    assertTrue(m.getRows() == 3);    assertTrue(m.getColumns() == 3);  }  public void testInvalidDimensions() {    boolean gotIt;    gotIt = false;    try {      new GeneralSquareMatrix(0);    } catch(IllegalArgumentException e) {      gotIt = true;    }    assertTrue(gotIt);    gotIt = false;    try {      new GeneralSquareMatrix(-3, null);    } catch(IllegalArgumentException e) {      gotIt = true;    }    assertTrue(gotIt);  }  public void testElements() {    Matrix m = buildMatrix(5, new BilinearPattern(1.0, 0.01));    checkMatrix(m, new BilinearPattern(1.0, 0.01));  }  public void testCopy() {    GeneralSquareMatrix m1 = buildMatrix(5, new BilinearPattern(1.0, 0.01));    GeneralSquareMatrix m2 = new GeneralSquareMatrix(m1);    for (int i = 0; i < m1.getRows(); ++i) {      for (int j = 0; j < m1.getColumns(); ++j) {        m1.setElement(i, j, -1.0);      }    }    assertTrue(m2.getRows() == m1.getRows());    assertTrue(m2.getColumns() == m1.getColumns());    checkMatrix(m2, new BilinearPattern(1.0, 0.01));  }  public void testDuplicate() {    GeneralSquareMatrix m1 = buildMatrix(5, new BilinearPattern(1.0, 0.01));    Matrix m2 = m1.duplicate();    assertTrue(m2 instanceof GeneralSquareMatrix);    for (int i = 0; i < m1.getRows(); ++i) {      for (int j = 0; j < m1.getColumns(); ++j) {        m1.setElement(i, j, -1.0);      }    }    assertTrue(m2.getRows() == m1.getRows());    assertTrue(m2.getColumns() == m1.getColumns());    checkMatrix(m2, new BilinearPattern(1.0, 0.01));  }  public void testSelfAdd() {    GeneralSquareMatrix m1 = buildMatrix(5, new BilinearPattern(1.0, 0.01));    GeneralSquareMatrix m2 = buildMatrix(5, new BilinearPattern(2, -0.03));    m1.selfAdd(m2);    checkMatrix(m1, new BilinearPattern(3, -0.02));  }  public void testSelfSub() {    GeneralSquareMatrix m1 = buildMatrix(5, new BilinearPattern(1.0, 0.01));    GeneralSquareMatrix m2 = buildMatrix(5, new BilinearPattern(2, -0.03));    m1.selfSub(m2);    checkMatrix(m1, new BilinearPattern(-1, 0.04));  }  public void testDeterminant() {    GeneralSquareMatrix m1 = buildProblem1().a;    assertTrue(Math.abs(m1.getDeterminant(1.0e-10) - 6.0) < 1.0e-10);    GeneralSquareMatrix m2 = buildProblem2().a;    assertTrue(Math.abs(m2.getDeterminant(1.0e-10) + 0.9999999) < 1.0e-10);    GeneralSquareMatrix m3 = buildProblem3().a;    assertTrue(Math.abs(m3.getDeterminant(1.0e-10) - 0.0) < 1.0e-10);  }  public void testSolve()    throws SingularMatrixException {    LinearProblem p;    Matrix result;    p = buildProblem1();    result = p.a.solve(p.b, 1.0e-10);    checkSolve(p, result);    p = buildProblem2();    result = p.a.solve(p.b, 1.0e-10);    checkSolve(p, result);    try {      p = buildProblem3();      result = p.a.solve(p.b, 1.0e-10);      fail("got " + result + ", should have caught an exception");    } catch(SingularMatrixException e) {      // expected    } catch(Exception e) {      fail("wrong exception caught: " + e.getMessage());    }   }  public void testInverse()    throws SingularMatrixException {    SquareMatrix a, inverse;    a = buildProblem1().a;    inverse = a.getInverse(1.0e-10);    checkMatrix(a.mul(inverse), new IdentityPattern());        a = buildProblem2().a;    inverse = a.getInverse(1.0e-10);    checkMatrix(a.mul(inverse), new IdentityPattern());    try {      a = buildProblem3().a;      inverse = a.getInverse(1.0e-10);      fail("got " + inverse + ", should have caught an exception");    } catch(SingularMatrixException e) {      // expected    } catch(Exception e) {      fail("wrong exception caught: " + e.getMessage());    }  }  public static Test suite() {    return new TestSuite(GeneralSquareMatrixTest.class);  }  private interface ElementPattern {    public double value(int i, int j);  }  private static class BilinearPattern implements ElementPattern {    public BilinearPattern(double coeffI, double coeffJ) {      this.coeffI = coeffI;      this.coeffJ = coeffJ;    }    public double value(int i, int j) {      return coeffI * i + coeffJ * j;    }    private final double coeffI;    private final double coeffJ;  }  private static class IdentityPattern implements ElementPattern {    public double value(int i, int j) {      return (i == j) ? 1.0 : 0.0;    }  }  public GeneralSquareMatrix buildMatrix(int order,                                         ElementPattern pattern) {    GeneralSquareMatrix m = new GeneralSquareMatrix(order);    for (int i = 0; i < m.getRows(); ++i) {      for (int j = 0; j < m.getColumns(); ++j){        m.setElement(i, j, pattern.value(i, j));      }    }    return m;  }  public void checkMatrix(Matrix m, ElementPattern pattern) {    for (int i = 0; i < m.getRows(); ++i) {      for (int j = 0; j < m.getColumns(); ++j) {        assertTrue(Math.abs(m.getElement(i, j) - pattern.value(i, j))                   < 1.0e-10);      }    }  }  private static class LinearProblem {    public GeneralSquareMatrix a;    public Matrix              x;    public Matrix              b;    public LinearProblem(GeneralSquareMatrix a, Matrix x, Matrix b) {      this.a = a;      this.x = x;      this.b = b;    }  }  private LinearProblem buildProblem1() {    GeneralSquareMatrix a = new GeneralSquareMatrix(4);    a.setElement(0, 0,   2.0);    a.setElement(0, 1,   1.0);    a.setElement(0, 2,   0.0);    a.setElement(0, 3,   4.0);    a.setElement(1, 0,  -4.0);    a.setElement(1, 1,  -2.0);    a.setElement(1, 2,   3.0);    a.setElement(1, 3,  -7.0);    a.setElement(2, 0,   4.0);    a.setElement(2, 1,   1.0);    a.setElement(2, 2,  -2.0);    a.setElement(2, 3,   8.0);    a.setElement(3, 0,   0.0);    a.setElement(3, 1,  -3.0);    a.setElement(3, 2, -12.0);    a.setElement(3, 3,  -1.0);    GeneralMatrix x = new GeneralMatrix(4, 1);    x.setElement(0, 0,  3.0);    x.setElement(1, 0,  4.0);    x.setElement(2, 0, -1.0);    x.setElement(3, 0, -2.0);    GeneralMatrix b = new GeneralMatrix(4, 1);    b.setElement(0, 0,  2.0);    b.setElement(1, 0, -9.0);    b.setElement(2, 0,  2.0);    b.setElement(3, 0,  2.0);    return new LinearProblem(a, x, b);  }  private LinearProblem buildProblem2()  {    double epsilon = 1.0e-7;    GeneralSquareMatrix a = new GeneralSquareMatrix(2);    a.setElement(0, 0, epsilon);    a.setElement(0, 1, 1.0);    a.setElement(1, 0, 1.0);    a.setElement(1, 1, 1.0);    GeneralMatrix x = new GeneralMatrix(2, 2);    x.setElement(0, 0, 1.0 + epsilon);    x.setElement(1, 0, 1.0 - epsilon);    x.setElement(0, 1, epsilon);    x.setElement(1, 1, 1.0);    GeneralMatrix b = new GeneralMatrix(2, 2);    b.setElement(0, 0, 1.0 + epsilon * epsilon);    b.setElement(1, 0, 2.0);    b.setElement(0, 1, 1.0 + epsilon * epsilon);    b.setElement(1, 1, 1.0 + epsilon);    return new LinearProblem(a, x, b);  }  private LinearProblem buildProblem3 ()  {    GeneralSquareMatrix a = new GeneralSquareMatrix(3);    a.setElement(0, 0,  1.0);    a.setElement(0, 1,  2.0);    a.setElement(0, 1, -3.0);    a.setElement(1, 0,  2.0);    a.setElement(1, 1,  1.0);    a.setElement(1, 1,  3.0);    a.setElement(2, 0, -3.0);    a.setElement(2, 1,  0.0);    a.setElement(2, 1, -9.0);    GeneralMatrix x = new GeneralMatrix(3, 1);    GeneralMatrix b = new GeneralMatrix(3, 1);    return new LinearProblem(a, x, b);  }  private void checkSolve(LinearProblem p, Matrix result)  {    Matrix residual = p.a.mul(result).sub(p.b);    for (int i = 0; i < residual.getRows(); ++i) {      for (int j = 0; j < residual.getColumns(); ++j) {        assertTrue(Math.abs(residual.getElement(i, j)) < 1.0e-10);      }    }    for (int i = 0; i < result.getRows(); ++i) {      for (int j = 0; j < result.getColumns(); ++j) {        assertTrue(Math.abs(result.getElement(i, j) - p.x.getElement(i, j))                   < 1.0e-10);      }    }  }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.spaceroots.mantissa.quadrature.vectorial;import org.spaceroots.mantissa.functions.vectorial.ComputableFunction;import org.spaceroots.mantissa.functions.FunctionException;import java.util.Random;import junit.framework.*;public class GaussLegendreIntegratorTest  extends TestCase {  public GaussLegendreIntegratorTest(String name) {    super(name);  }  public void testExactIntegration()    throws FunctionException {    Random random = new Random(86343623467878363l);    int order = 0;    while (true) {      GaussLegendreIntegrator integrator = new GaussLegendreIntegrator(order,                                                                       7.0);      int availableOrder = integrator.getEvaluationsPerStep();      if (availableOrder < order) {        // we have tested all available orders        return;      }      // an order n Gauss-Legendre integrator integrates      // 2n-1 degree polynoms exactly      for (int degree = 0; degree <= 2 * availableOrder - 1; ++degree) {        for (int i = 0; i < 10; ++i) {          Polynom p = new Polynom(degree, random, 100.0);          double[] s0 = integrator.integrate(p, -5.0, 15.0);          double[] s1 = p.exactIntegration(-5.0, 15.0);          for (int j = 0; j < p.getDimension(); ++j) {            assertTrue(Math.abs(s0[j] - s1[j]) < 1.0e-12 * (1.0 + Math.abs(s0[j])));          }        }      }      ++order;    }  }  public static Test suite() {    return new TestSuite(GaussLegendreIntegratorTest.class);  }  private static class Polynom implements ComputableFunction {    public Polynom (int degree, Random random, double max) {      coeffs0 = new double[degree + 1];      coeffs1 = new double[degree + 1];      for (int i = 0; i <= degree; ++i) {        coeffs0[i] = 2.0 * max * (random.nextDouble() - 0.5);        coeffs1[i] = 2.0 * max * (random.nextDouble() - 0.5);      }    }    public int getDimension() {      return 2;    }    public double[] valueAt(double t)      throws FunctionException {      double[] y = new double[2];      y[0] = coeffs0[coeffs0.length - 1];      for (int i = coeffs0.length - 2; i >= 0; --i) {        y[0] = y[0] * t + coeffs0[i];      }      y[1] = coeffs1 [coeffs1.length - 1];      for (int i = coeffs1.length - 2; i >= 0; --i) {        y[1] = y[1] * t + coeffs1[i];      }      return y;    }    public double[] exactIntegration(double a, double b)      throws FunctionException {      double[] res = new double[2];      double yb = coeffs0[coeffs0.length - 1] / coeffs0.length;      double ya = yb;      for (int i = coeffs0.length - 2; i >= 0; --i) {        yb = yb * b + coeffs0[i] / (i + 1);        ya = ya * a + coeffs0[i] / (i + 1);      }      res[0] = yb * b - ya * a;      yb = coeffs1[coeffs1.length - 1] / coeffs1.length;      ya = yb;      for (int i = coeffs1.length - 2; i >= 0; --i) {        yb = yb * b + coeffs1[i] / (i + 1);        ya = ya * a + coeffs1[i] / (i + 1);      }      res[1] = yb * b - ya * a;      return res;    }    private double[] coeffs0;    private double[] coeffs1;    private static final long serialVersionUID = -8032020368915042278L;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class BeanTransformerTest extends TestCase {        /**     *     */    public void testConstructor(){        BeanTransformer b = new BeanTransformer();        assertNull(b.getPropertyName());    }        /**     *     */    public void testConstructorString(){        String name = "property";        BeanTransformer b = new BeanTransformer(name);        assertEquals(name, b.getPropertyName());    }        /**     *     */    public void testSetPropertyName(){        String name = "property";        BeanTransformer b = new BeanTransformer();        b.setPropertyName(name);        assertEquals(name, b.getPropertyName());    }        /**     *      */    public void testTransformNoSuchMethod(){        BeanTransformer b = new BeanTransformer("z");        TestBean target = new TestBean();try {    b.transform(target);fail("Expecting MathException");} catch (MathException e) {// expected}    }        /**     *      */    public void testTransform() throws Exception {        BeanTransformer b = new BeanTransformer("x");        TestBean target = new TestBean();double value = Double.NaN;value = b.transform(target);TestUtils.assertEquals(1.0, value, 1.0e-2);    }        /**     */    public void testTransformInvalidType() throws Exception {        BeanTransformer b = new BeanTransformer("y");        TestBean target = new TestBean();        try {b.transform(target);            fail("Expecting ClassCastException");        } catch(ClassCastException ex){            // success        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import junit.framework.TestCase;/** * @todo add javadoc comment * @version $Revision$ $Date$ */public class UnivariateRealFunctionUtilsTest extends TestCase {    /**     *       */    public void testLocalMaximumCentered() {        UnivariateRealFunction function = new SinFunction();        UnivariateRealFunction derivative = UnivariateRealFunctionUtils.centerDifferenceDerivative(function, 1.0e-5);        testLocalMaximum(derivative);    }         /**     *       */    public void testLocalMaximumForward() {        UnivariateRealFunction function = new SinFunction();        UnivariateRealFunction derivative = UnivariateRealFunctionUtils.forwardDifferenceDerivative(function, 1.0e-5);        testLocalMaximum(derivative);    }         /**     *      */    public void testLocalMaximumBackward() {        UnivariateRealFunction function = new SinFunction();        UnivariateRealFunction derivative = UnivariateRealFunctionUtils.backwardDifferenceDerivative(function, 1.0e-5);        testLocalMaximum(derivative);    }        /**     * Find a local extrema, i.e. f'(x) = 0.      */    private void testLocalMaximum(UnivariateRealFunction derivative) {        try {            double maximum = UnivariateRealSolverUtils.solve(derivative, Math.PI / 3.0, Math.PI * 2.0 / 3.0);            assertEquals(maximum, Math.PI / 2.0, 1.0e-5);        } catch (Exception ex) {            fail(ex.getMessage());        }    } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import junit.framework.TestCase;/** * * To change the template for this generated type comment go to * Window>Preferences>Java>Code Generation>Code and Comments */public class DerivativeOperatorFactoryTest extends TestCase {    /**     * Constructor for DerivativeOperatorFactoryTest.     * @param arg0     */    public DerivativeOperatorFactoryTest(String arg0) {        super(arg0);    }        //UnivariateRealFunction f = new SomeUserDefinedFunction();    //FunctionOperator derivative =      //  DerivativeOperatorFactory.newInstance().getDefaultDerivativeOperator();    //UnivariateRealFunction g = derivative.evaluate( f );    // to obtain the value of f'(0.0) use    //double fprime_at_0 = g.value( 0.0 );}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate;import java.util.ArrayList;import java.util.List;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.StatUtils;/** * Test cases for the {@link BeanListUnivariateImpl} class. * * @version $Revision$ $Date$ */public final class BeanListUnivariateImplTest extends TestCase {        private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double skewness = 0;    private double kurtosis = 0.5;    private double tolerance = 10E-15;            private List patientList = null;        public BeanListUnivariateImplTest(String name) {        super(name);    }        public void setUp() {          patientList = new ArrayList();        // Create and add patient bean 1        VitalStats vs1 = new VitalStats( Double.valueOf(120.0),                                          Double.valueOf(96.4) );        Patient p1 = new Patient( vs1, Integer.valueOf( 35 ) );        patientList.add( p1 );        // Create and add patient bean 2        VitalStats vs2 = new VitalStats( Double.valueOf(70.0),                                          Double.valueOf(97.4) );        Patient p2 = new Patient( vs2, Integer.valueOf( 23 ) );        patientList.add( p2 );        // Create and add patient bean 3        VitalStats vs3 = new VitalStats( Double.valueOf(90.0),                                          Double.valueOf(98.6) );        Patient p3 = new Patient( vs3, Integer.valueOf( 42 ) );        patientList.add( p3 );    }        public static Test suite() {        TestSuite suite = new TestSuite(BeanListUnivariateImplTest.class);        suite.setName("Frequency Tests");        return suite;    }        /** test stats */    public void testStats() {        DescriptiveStatistics u = new BeanListUnivariateImpl( patientList, "age" );         double[] values = {35d, 23d, 42d};        assertEquals("total count",3,u.getN(),tolerance);        assertEquals("mean", StatUtils.mean(values), u.getMean(), tolerance);        assertEquals("min", StatUtils.min(values), u.getMin(), tolerance);        assertEquals("max", StatUtils.max(values), u.getMax(), tolerance);        assertEquals("var", StatUtils.variance(values), u.getVariance(), tolerance);               u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }           public void testPropStats() {        DescriptiveStatistics heartU = new BeanListUnivariateImpl( patientList,                                          "vitalStats.heartRate" );               assertEquals( "Mean heart rate unexpected", 93.333,                       heartU.getMean(), 0.001 );        assertEquals( "Max heart rate unexpected", 120.0,                       heartU.getMax(), 0.001 );        DescriptiveStatistics ageU = new BeanListUnivariateImpl( patientList,                                                           "age" );        assertEquals( "Mean age unexpected", 33.333,                      ageU.getMean(), 0.001 );        assertEquals( "Max age unexpected", 42.0,                      ageU.getMax(), 0.001 );    }        public void testSetPropertyName(){        BeanListUnivariateImpl u = new BeanListUnivariateImpl(null);        String expected = "property";        u.setPropertyName(expected);        assertEquals(expected, u.getPropertyName());    }        public void testAddValue() {        DescriptiveStatistics u = new BeanListUnivariateImpl( patientList, "age" );         u.addValue(10);        double[] values = {35d, 23d, 42d, 10d};        assertEquals("total count",4,u.getN(),tolerance);        assertEquals("mean", StatUtils.mean(values), u.getMean(), tolerance);        assertEquals("min", StatUtils.min(values), u.getMin(), tolerance);        assertEquals("max", StatUtils.max(values), u.getMax(), tolerance);        assertEquals("var", StatUtils.variance(values), u.getVariance(), tolerance);               u.clear();        assertEquals("total count",0,u.getN(),tolerance);          }        /** test stats */    public void testSerialization() {                double[] values = {35d, 23d, 42d};                DescriptiveStatistics u = new BeanListUnivariateImpl( patientList, "age" );         assertEquals("total count",3,u.getN(),tolerance);        assertEquals("mean", StatUtils.mean(values), u.getMean(), tolerance);        assertEquals("min", StatUtils.min(values), u.getMin(), tolerance);        assertEquals("max", StatUtils.max(values), u.getMax(), tolerance);        assertEquals("var", StatUtils.variance(values), u.getVariance(), tolerance);                           DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u);         assertEquals("total count",3,u2.getN(),tolerance);        assertEquals("mean", StatUtils.mean(values), u2.getMean(), tolerance);        assertEquals("min", StatUtils.min(values), u2.getMin(), tolerance);        assertEquals("max", StatUtils.max(values), u2.getMax(), tolerance);        assertEquals("var", StatUtils.variance(values), u2.getVariance(), tolerance);           u.clear();        assertEquals("total count",0,u.getN(),tolerance);                    u2.clear();        assertEquals("total count",0,u2.getN(),tolerance);                }            public class VitalStats {        private Double heartrate;        private Double temperature;        public VitalStats() {        }        public VitalStats(Double heartrate, Double temperature) {            setHeartRate( heartrate );            setTemperature( temperature );        }        public Double getHeartRate() {            return heartrate;        }        public void setHeartRate(Double heartrate) {            this.heartrate = heartrate;        }        public Double getTemperature() {            return temperature;        }        public void setTemperature(Double temperature) {            this.temperature = temperature;        }    }        public class Patient {        private VitalStats vitalStats;        private Integer age;        public Patient() {        }        public Patient(VitalStats vitalStats, Integer age) {            setVitalStats( vitalStats );            setAge( age );        }        public VitalStats getVitalStats() {            return( vitalStats );        }        public void setVitalStats(VitalStats vitalStats) {            this.vitalStats = vitalStats;        }        public Integer getAge() {            return age;        }        public void setAge(Integer age) {            this.age = age;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Test cases for the {@link CholeskySolver} class. * <p> * @author Stefan Koeberle, 11/2003 */public class CholeskySolverTest extends TestCase {            private double[][] m1 = {{1}};        private double m1Det = 1.0d;                private double[][] m2 = {{1, 0} ,                                  {0, 2}};        private double m2Det = 2.0d;                                                 private double[][] m3 = {{1, 0, 0},                                  {0, 2, 0},                                  {0, 0, 3}};        private double m3Det = 6.0d;                                         private double[][] m4 = {{1, 0, 0},                                  {2, 3, 0},                                  {4, 5, 6}};        private double m4Det = 18.0d;                private double[][] m5 = {{ 1,  0,  0,  0,  0},                                  {-2,  3,  0,  0,  0},                                  { 4, -5,  6,  0,  0},                                 { 7,  8, -9, 10,  0},                                 {11, 12, 13, 14, 15}};        private double m5Det = 2700.0d;                                         private double[][] m6 = {{1, 0,  0},                                  {2, 0,  0},                                  {4, 5,  6}};                private double[][] m7 = {{1, 2, 3},                                  {4, 5, 6}};                                    /**      * Creates a new instance of CholeskySolverTest      */    public CholeskySolverTest(String nameOfTest) {        super(nameOfTest);    }//constructor CholeskySolverTest        public void setUp()     throws java.lang.Exception {        super.setUp();    }//setUp           public void tearDown()     throws java.lang.Exception {        super.tearDown();    }//tearDown        public static Test suite() {        TestSuite suite = new TestSuite(CholeskySolverTest.class);        suite.setName("CholeskySolver Tests");        return suite;    }//suite        /**      * tests CholeskySolver.setNumericalZero()      */       public void testNumericalZero() {        CholeskySolver solver = new CholeskySolver();        double numericalZero = 77.77d;        solver.setNumericalZero(numericalZero);        assertEquals(solver.getNumericalZero(), numericalZero, 0.0d);                try {            solver.decompose(                new Array2DRowRealMatrix(new double[][]{{numericalZero/2, 0},                                                  {0, numericalZero/2}}));            fail("testing numericalZero");        } catch (IllegalArgumentException e) {}            }//testNumericalZero            /**      * tests CholeskySolver.decompose(...)      */    public void testDecompose() {                //The following decompositions should succeed.        testDecompose(m1, "Decomposing matrix m1");        testDecompose(m2, "Decomposing matrix m2");        testDecompose(m3, "Decomposing matrix m3");        testDecompose(m4, "Decomposing matrix m4");        testDecompose(m5, "Decomposing matrix m5");                //The following decompositions will fail. An IllegalArgumentException        //should be thrown.        try {            testDecompose(m6, "Decomposing matrix m6");            fail("Decomposing matrix m6");         } catch (IllegalArgumentException e) {}                 try {             CholeskySolver solver = new CholeskySolver();             solver.decompose(new Array2DRowRealMatrix(m7));             fail("Decomposing matrix m7");         } catch (IllegalArgumentException e) {}            }//testDecomposition            /**      * tests CholeskySolver.solve(...)      */    public void testSolve() {        //If there's no matrix, there's no linear euqitation to solve ...        try {             CholeskySolver solver = new CholeskySolver();             solver.solve(new double[] {1,2,3});             fail("solving a liniar equitation with a missing matrix should fail");         } catch (IllegalStateException e) {}        //The following operations should succeed.        testSolve(m1, "Solving matrix m1");          testSolve(m2, "Solving matrix m2");        testSolve(m3, "Solving matrix m3");        testSolve(m4, "Solving matrix m4");        testSolve(m5, "Solving matrix m5");             //The following operations will fail. An IllegalArgumentException        //should be thrown.        try {          testSolve(m6, "Solving matrix m6");          fail("Solving matrix m6");         } catch (IllegalArgumentException e) {}         try {             CholeskySolver solver = new CholeskySolver();             solver.solve(new Array2DRowRealMatrix(m3), new double[] {1, 2, 3, 4});             fail("Solving matrix m3[3x3], v[4]");         } catch (IllegalArgumentException e) {}            }//testDecomposition            /**      * tests CholeskySolver.getDeterminant(...)      */    public void testGetDeterminant() {                //Since no matrix was decomposed, there's no determinant.        try {             CholeskySolver solver = new CholeskySolver();             solver.getDeterminant();             fail("Calculating determinant of missing matrix should fail");         } catch (IllegalStateException e) {}               //These test will suceed.        testGetDeterminant(m1, m1Det, "Calculating determinant of m1");        testGetDeterminant(m2, m2Det, "Calculating determinant of m2");        testGetDeterminant(m3, m3Det, "Calculating determinant of m3");        testGetDeterminant(m4, m4Det, "Calculating determinant of m4");        testGetDeterminant(m5, m5Det, "Calculating determinant of m5");    }//test            /**     * Generates the matrix      * <code>m = lowerTriangularMatrix * lowerTriangularMatrix^T</code>.     * If alle diagonalelements of <code>lowerTriangularMatrix</code> are     * positiv, <code>m</code> will be positiv definit.      * Decomposing <code>m</code> should result in     * <code>lowerTriangularMatrix</code> again. So there's a simple test ...     */    private void testDecompose(double[][] lowerTriangularMatrix, String message)     throws IllegalArgumentException {            RealMatrix triangularMatrix = new Array2DRowRealMatrix(lowerTriangularMatrix);        RealMatrix pdMatrix =             triangularMatrix.multiply(triangularMatrix.transpose());                CholeskySolver solver = new CholeskySolver();        solver.decompose(pdMatrix);                assertTrue(message,             areEqual(triangularMatrix, solver.getDecomposition(), 1.0E-10));        }//testDecompose          /**     * Similar to <code> private testDecompose(...)</code>.     */    private void testSolve(double[][] lowerTriangularMatrix, String message)  {              RealMatrix triangularMatrix =             new Array2DRowRealMatrix(lowerTriangularMatrix);        Array2DRowRealMatrix pdMatrix =             (Array2DRowRealMatrix) triangularMatrix.multiply(triangularMatrix.transpose());        CholeskySolver solver =             new CholeskySolver();                double[] c = new double[lowerTriangularMatrix.length];        for (int i=0; i<c.length; i++)             for (int j=0; j<lowerTriangularMatrix[0].length; j++)                 c[i] += lowerTriangularMatrix[i][j];                solver.decompose(pdMatrix);        RealMatrix x = new Array2DRowRealMatrix(solver.solve(c));        assertTrue(message,             areEqual(pdMatrix.multiply(x),  new Array2DRowRealMatrix(c), 1.0E-10));    }//testSolve        /**     * Similar to <code> private testDecompose(...)</code>.     */    private void testGetDeterminant(double[][] lowerTriangularMatrix,                                     double determinant,                                    String message)     throws IllegalArgumentException {            RealMatrix triangularMatrix = new Array2DRowRealMatrix(lowerTriangularMatrix);        RealMatrix pdMatrix =             triangularMatrix.multiply(triangularMatrix.transpose());        double pdDeterminant = determinant * determinant;                CholeskySolver solver = new CholeskySolver();        solver.decompose(pdMatrix);        assertEquals(message, solver.getDeterminant(), pdDeterminant, 1.0E-10);    }//testGetDeterminant            /**     * Are <code>m1</code> and <code>m2</code> equal?     */    private static boolean areEqual(RealMatrix m1, RealMatrix m2, double delta) {                double[][] mv1 = m1.getData();        double[][] mv2 = m2.getData();                if (mv1.length != mv1.length  ||            mv1[0].length != mv2[0].length)             return false;                for (int i=0; i<mv1.length; i++)             for (int j=0; j<mv1[0].length; j++)                 if (Math.abs(mv1[i][j] -mv2[i][j]) > delta)                     return false;                return true;    }//isEqual          /**     * Executes all tests of this class     */    public static void main(String[] args) {        System.out.println("Start");        TestRunner runner = new TestRunner();        runner.doRun(CholeskySolverTest.suite());        System.out.println("End");    }//main    }//class CholeskySolverTest
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Arrays;import java.util.Random;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link RecursiveLayoutRealMatrix} class. * * @version $Revision$ $Date$ */public final class RecursiveLayoutRealMatrixTest extends TestCase {    // 3 x 3 identity matrix    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };        // Test data for group operations    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},        {-1d,0d,-8d} };    protected double[] testDataRow1 = {1d,2d,3d};    protected double[] testDataCol3 = {3d,3d,8d};    protected double[][] testDataInv =         { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };    protected double[] preMultTest = {8,12,33};    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};    protected double[][] testDataPlusInv =         { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };        // lu decomposition tests    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},            {0.33333333333333,0d,0.33333333333333} };        // singular matrices    protected double[][] singular = { {2d,3d}, {2d,3d} };    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};        // vectors    protected double[] testVector = {1,2,3};    protected double[] testVector2 = {1,2,3,4};        // submatrix accessor tests    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},            {2, 4, 6, 8}, {4, 5, 6, 7}};     // array selections    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};    // effective permutations    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};    // contiguous ranges    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};    protected double[][] subRows23Cols00 = {{2} , {4}};    protected double[][] subRows00Cols33 = {{4}};    // row matrices    protected double[][] subRow0 = {{1,2,3,4}};    protected double[][] subRow3 = {{4,5,6,7}};    // column matrices    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};        // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;        public RecursiveLayoutRealMatrixTest(String name) {        super(name);    }        public void setUp() {            }        public static Test suite() {        TestSuite suite = new TestSuite(RecursiveLayoutRealMatrixTest.class);        suite.setName("RecursiveLayoutRealMatrix Tests");        return suite;    }        /** test dimensions */    public void testDimensions() {        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);        RecursiveLayoutRealMatrix m2 = new RecursiveLayoutRealMatrix(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());    }         /** test copy functions */    public void testCopyFunctions() {        Random r = new Random(66636328996002l);        RecursiveLayoutRealMatrix m1 = createRandomMatrix(r, 47, 83);        RecursiveLayoutRealMatrix m2 = new RecursiveLayoutRealMatrix(m1.getData());        assertEquals(m1, m2);        RecursiveLayoutRealMatrix m3 = new RecursiveLayoutRealMatrix(testData);        RecursiveLayoutRealMatrix m4 = new RecursiveLayoutRealMatrix(m3.getData());        assertEquals(m3, m4);    }                   /** test add */    public void testAdd() {        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);        RecursiveLayoutRealMatrix mInv = new RecursiveLayoutRealMatrix(testDataInv);        RealMatrix mPlusMInv = m.add(mInv);        double[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                    testDataPlusInv[row][col],sumEntries[row][col],                        entryTolerance);            }        }        }        /** test add failure */    public void testAddFail() {        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);        RecursiveLayoutRealMatrix m2 = new RecursiveLayoutRealMatrix(testData2);        try {            m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        /** test norm */    public void testNorm() {        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);        RecursiveLayoutRealMatrix m2 = new RecursiveLayoutRealMatrix(testData2);        assertEquals("testData norm",14d,m.getNorm(),entryTolerance);        assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);    }        /** test Frobenius norm */    public void testFrobeniusNorm() {        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);        RecursiveLayoutRealMatrix m2 = new RecursiveLayoutRealMatrix(testData2);        assertEquals("testData Frobenius norm", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);        assertEquals("testData2 Frobenius norm", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);    }         /** test m-n = m + -n */    public void testPlusMinus() {        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);        RecursiveLayoutRealMatrix m2 = new RecursiveLayoutRealMatrix(testDataInv);        assertClose(m.subtract(m2), m2.scalarMultiply(-1d).add(m), entryTolerance);                try {            m.subtract(new RecursiveLayoutRealMatrix(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }       /** test multiply */     public void testMultiply() {        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);        RecursiveLayoutRealMatrix mInv = new RecursiveLayoutRealMatrix(testDataInv);        RecursiveLayoutRealMatrix identity = new RecursiveLayoutRealMatrix(id);        RecursiveLayoutRealMatrix m2 = new RecursiveLayoutRealMatrix(testData2);        assertClose(m.multiply(mInv), identity, entryTolerance);        assertClose(mInv.multiply(m), identity, entryTolerance);        assertClose(m.multiply(identity), m, entryTolerance);        assertClose(identity.multiply(mInv), mInv, entryTolerance);        assertClose(m2.multiply(identity), m2, entryTolerance);         try {            m.multiply(new RecursiveLayoutRealMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }          }    public void testSeveralBlocks() {        RealMatrix m = new RecursiveLayoutRealMatrix(35, 71);        for (int i = 0; i < m.getRowDimension(); ++i) {            for (int j = 0; j < m.getColumnDimension(); ++j) {                m.setEntry(i, j, i + j / 1024.0);            }        }        RealMatrix mT = m.transpose();        assertEquals(m.getRowDimension(), mT.getColumnDimension());        assertEquals(m.getColumnDimension(), mT.getRowDimension());        for (int i = 0; i < mT.getRowDimension(); ++i) {            for (int j = 0; j < mT.getColumnDimension(); ++j) {                assertEquals(m.getEntry(j, i), mT.getEntry(i, j), 0);            }        }        RealMatrix mPm = m.add(m);        for (int i = 0; i < mPm.getRowDimension(); ++i) {            for (int j = 0; j < mPm.getColumnDimension(); ++j) {                assertEquals(2 * m.getEntry(i, j), mPm.getEntry(i, j), 0);            }        }        RealMatrix mPmMm = mPm.subtract(m);        for (int i = 0; i < mPmMm.getRowDimension(); ++i) {            for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {                assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j), 0);            }        }        RealMatrix mTm = mT.multiply(m);        for (int i = 0; i < mTm.getRowDimension(); ++i) {            for (int j = 0; j < mTm.getColumnDimension(); ++j) {                double sum = 0;                for (int k = 0; k < mT.getColumnDimension(); ++k) {                    sum += (k + i / 1024.0) * (k + j / 1024.0);                }                assertEquals(sum, mTm.getEntry(i, j), 0);            }        }        RealMatrix mmT = m.multiply(mT);        for (int i = 0; i < mmT.getRowDimension(); ++i) {            for (int j = 0; j < mmT.getColumnDimension(); ++j) {                double sum = 0;                for (int k = 0; k < m.getColumnDimension(); ++k) {                    sum += (i + k / 1024.0) * (j + k / 1024.0);                }                assertEquals(sum, mmT.getEntry(i, j), 0);            }        }        RealMatrix sub1 = m.getSubMatrix(2, 9, 5, 20);        for (int i = 0; i < sub1.getRowDimension(); ++i) {            for (int j = 0; j < sub1.getColumnDimension(); ++j) {                assertEquals((i + 2) + (j + 5) / 1024.0, sub1.getEntry(i, j), 0);            }        }        RealMatrix sub2 = m.getSubMatrix(10, 12, 3, 70);        for (int i = 0; i < sub2.getRowDimension(); ++i) {            for (int j = 0; j < sub2.getColumnDimension(); ++j) {                assertEquals((i + 10) + (j + 3) / 1024.0, sub2.getEntry(i, j), 0);            }        }        RealMatrix sub3 = m.getSubMatrix(30, 34, 0, 5);        for (int i = 0; i < sub3.getRowDimension(); ++i) {            for (int j = 0; j < sub3.getColumnDimension(); ++j) {                assertEquals((i + 30) + (j + 0) / 1024.0, sub3.getEntry(i, j), 0);            }        }        RealMatrix sub4 = m.getSubMatrix(30, 32, 62, 65);        for (int i = 0; i < sub4.getRowDimension(); ++i) {            for (int j = 0; j < sub4.getColumnDimension(); ++j) {                assertEquals((i + 30) + (j + 62) / 1024.0, sub4.getEntry(i, j), 0);            }        }    }    //Additional Test for RecursiveLayoutRealMatrixTest.testMultiply    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};    private double[][] d4 = new double[][] {{1},{2},{3},{4}};    private double[][] d5 = new double[][] {{30},{70}};         public void testMultiply2() {        RealMatrix m3 = new RecursiveLayoutRealMatrix(d3);          RealMatrix m4 = new RecursiveLayoutRealMatrix(d4);       RealMatrix m5 = new RecursiveLayoutRealMatrix(d5);       assertClose(m3.multiply(m4), m5, entryTolerance);   }              /** test trace */    public void testTrace() {        RealMatrix m = new RecursiveLayoutRealMatrix(id);        assertEquals("identity trace",3d,m.getTrace(),entryTolerance);        m = new RecursiveLayoutRealMatrix(testData2);        try {            m.getTrace();            fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            ;        }          }        /** test scalarAdd */    public void testScalarAdd() {        RealMatrix m = new RecursiveLayoutRealMatrix(testData);        assertClose(new RecursiveLayoutRealMatrix(testDataPlus2), m.scalarAdd(2d), entryTolerance);    }                        /** test operate */    public void testOperate() {        RealMatrix m = new RecursiveLayoutRealMatrix(id);        assertClose(testVector, m.operate(testVector), entryTolerance);        assertClose(testVector, m.operate(new RealVectorImpl(testVector)).getData(), entryTolerance);        m = new RecursiveLayoutRealMatrix(bigSingular);        try {            m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }    public void testMultiplyMedium() {        RealMatrix m1 = new RecursiveLayoutRealMatrix(                new double[][] {                        {  80,  45,  13,  77, -82 },                        { -90,  33,  98,  80,  74 },                        {  24, -37,  36,  -8, -69 },                        { -74,   2,  32, -67, -65 },                        { -29, -81,  44,  54, -65 },                        {  17,  58, -36, -98,  25 },                        {  48, -64, -95, -75,  34 }                });        RealMatrix m2 = new RecursiveLayoutRealMatrix(                new double[][] {                        {  81,  58,  70,  18,   5, -57 },                        { -54,  33,  87,  68, -22,  73 },                        { -78,  -5,  34,  -7,  -3, -31 },                        { -16, -82, -68,   7,  10, -47 },                        {  51,   4,  92,  15,  32, -51 }                });        RealMatrix m1m2 = m1.multiply(m2);        RealMatrix reference = new RecursiveLayoutRealMatrix(                new double[][]{                        {  -2378,   -582,  -2823,  3718, -2483, -1115 },                        { -14222, -10885,   1271,  1608,  1698, -3033 },                        {  -2257,    371,  -6119, -3427, -1462, -1290 },                        { -10841,    848,  -5342, -2864, -3260,  9836 },                        {  -5586,  -9263, -17233, -6935,   -35, -4847 },                        {   3896,  11216,  13976,  4191, -1263,  7712 },                        {  17688,   7433,   2790, -2838,  2271, -2672 }                 });        assertEquals(0, m1m2.subtract(reference).getNorm(), 0.0);    }    public void testOperateLarge() {        int testBlockSize = 64;        int p = (7 * testBlockSize) / 2;        int q = (5 * testBlockSize) / 2;        int r =  3 * testBlockSize;        Random random = new Random(111007463902334l);        RealMatrix m1 = createRandomMatrix(random, p, q);        RealMatrix m2 = createRandomMatrix(random, q, r);        RealMatrix m1m2 = m1.multiply(m2);        for (int i = 0; i < r; ++i) {            checkArrays(m1m2.getColumn(i), m1.operate(m2.getColumn(i)));        }    }    public void testOperatePremultiplyLarge() {        int testBlockSize = 64;        int p = (7 * testBlockSize) / 2;        int q = (5 * testBlockSize) / 2;        int r =  3 * testBlockSize;        Random random = new Random(111007463902334l);        RealMatrix m1 = createRandomMatrix(random, p, q);        RealMatrix m2 = createRandomMatrix(random, q, r);        RealMatrix m1m2 = m1.multiply(m2);        for (int i = 0; i < p; ++i) {            checkArrays(m1m2.getRow(i), m2.preMultiply(m1.getRow(i)));        }    }    /** test issue MATH-209 */    public void testMath209() {        RealMatrix a = new RecursiveLayoutRealMatrix(new double[][] {                { 1, 2 }, { 3, 4 }, { 5, 6 }        });        double[] b = a.operate(new double[] { 1, 1 });        assertEquals(a.getRowDimension(), b.length);        assertEquals( 3.0, b[0], 1.0e-12);        assertEquals( 7.0, b[1], 1.0e-12);        assertEquals(11.0, b[2], 1.0e-12);    }        /** test transpose */    public void testTranspose() {        RealMatrix m = new RecursiveLayoutRealMatrix(testData);         RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();        assertClose(mIT, mTI, normTolerance);        m = new RecursiveLayoutRealMatrix(testData2);        RealMatrix mt = new RecursiveLayoutRealMatrix(testData2T);        assertClose(mt, m.transpose(), normTolerance);    }        /** test preMultiply by vector */    public void testPremultiplyVector() {        RealMatrix m = new RecursiveLayoutRealMatrix(testData);        assertClose(m.preMultiply(testVector), preMultTest, normTolerance);        assertClose(m.preMultiply(new RealVectorImpl(testVector).getData()),                    preMultTest, normTolerance);        m = new RecursiveLayoutRealMatrix(bigSingular);        try {            m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testPremultiply() {        RealMatrix m3 = new RecursiveLayoutRealMatrix(d3);           RealMatrix m4 = new RecursiveLayoutRealMatrix(d4);        RealMatrix m5 = new RecursiveLayoutRealMatrix(d5);        assertClose(m4.preMultiply(m3), m5, entryTolerance);                RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);        RecursiveLayoutRealMatrix mInv = new RecursiveLayoutRealMatrix(testDataInv);        RecursiveLayoutRealMatrix identity = new RecursiveLayoutRealMatrix(id);        assertClose(m.preMultiply(mInv), identity, entryTolerance);        assertClose(mInv.preMultiply(m), identity, entryTolerance);        assertClose(m.preMultiply(identity), m, entryTolerance);        assertClose(identity.preMultiply(mInv), mInv, entryTolerance);        try {            m.preMultiply(new RecursiveLayoutRealMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }        public void testGetVectors() {        RealMatrix m = new RecursiveLayoutRealMatrix(testData);        assertClose(m.getRow(0), testDataRow1, entryTolerance);        assertClose(m.getColumn(2), testDataCol3, entryTolerance);        try {            m.getRow(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            ;        }        try {            m.getColumn(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            ;        }    }        public void testGetEntry() {        RealMatrix m = new RecursiveLayoutRealMatrix(testData);        assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);        try {            m.getEntry(10, 4);            fail ("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }            /** test examples in user guide */    public void testExamples() {        // Create a real matrix with two rows and three columns        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};        RealMatrix m = new RecursiveLayoutRealMatrix(matrixData);        // One more with three rows, two columns        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};        RealMatrix n = new RecursiveLayoutRealMatrix(matrixData2);        // Now multiply m by n        RealMatrix p = m.multiply(n);        assertEquals(2, p.getRowDimension());        assertEquals(2, p.getColumnDimension());        // Invert p        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();         assertEquals(2, pInverse.getRowDimension());        assertEquals(2, pInverse.getColumnDimension());                // Solve example        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};        RealMatrix coefficients = new RecursiveLayoutRealMatrix(coefficientsData);        double[] constants = {1, -2, 1};        double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);               }        // test submatrix accessors    public void testGetSubMatrix() {        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);           checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);          checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);          checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);         checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int startRow, int endRow, int startColumn, int endColumn,                                   boolean mustFail) {        try {            RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);            assertEquals(new RecursiveLayoutRealMatrix(reference), sub);            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }        private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int[] selectedRows, int[] selectedColumns,                                   boolean mustFail) {        try {            RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);            assertEquals(new RecursiveLayoutRealMatrix(reference), sub);            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    public void testGetSetMatrixLarge() {        int n = 3 * 64;        RealMatrix m = new RecursiveLayoutRealMatrix(n, n);        RealMatrix sub = new RecursiveLayoutRealMatrix(n - 4, n - 4).scalarAdd(1);        m.setSubMatrix(sub.getData(), 2, 2);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));    }    public void testCopySubMatrix() {        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);           checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);          checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);          checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);         checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);                 checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, -1, 1, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkCopy(RealMatrix m, double[][] reference,                           int startRow, int endRow, int startColumn, int endColumn,                           boolean mustFail) {        try {            double[][] sub = (reference == null) ?                             new double[1][1] :                             new double[reference.length][reference[0].length];            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);            assertEquals(new RecursiveLayoutRealMatrix(reference), new RecursiveLayoutRealMatrix(sub));            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }        private void checkCopy(RealMatrix m, double[][] reference,                           int[] selectedRows, int[] selectedColumns,                           boolean mustFail) {        try {            double[][] sub = (reference == null) ?                    new double[1][1] :                    new double[reference.length][reference[0].length];            m.copySubMatrix(selectedRows, selectedColumns, sub);            assertEquals(new RecursiveLayoutRealMatrix(reference), new RecursiveLayoutRealMatrix(sub));            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    public void testGetRowMatrix() {        RealMatrix m     = new RecursiveLayoutRealMatrix(subTestData);        RealMatrix mRow0 = new RecursiveLayoutRealMatrix(subRow0);        RealMatrix mRow3 = new RecursiveLayoutRealMatrix(subRow3);        assertEquals("Row0", mRow0, m.getRowMatrix(0));        assertEquals("Row3", mRow3, m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowMatrix() {        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);        RealMatrix mRow3 = new RecursiveLayoutRealMatrix(subRow3);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowMatrix(0, mRow3);        assertEquals(mRow3, m.getRowMatrix(0));        try {            m.setRowMatrix(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowMatrix(0, m);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        public void testGetSetRowMatrixLarge() {        int n = 3 * 64;        RealMatrix m = new RecursiveLayoutRealMatrix(n, n);        RealMatrix sub = new RecursiveLayoutRealMatrix(1, n).scalarAdd(1);        m.setRowMatrix(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        assertEquals(sub, m.getRowMatrix(2));    }        public void testGetColumnMatrix() {        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);        RealMatrix mColumn1 = new RecursiveLayoutRealMatrix(subColumn1);        RealMatrix mColumn3 = new RecursiveLayoutRealMatrix(subColumn3);        assertEquals(mColumn1, m.getColumnMatrix(1));        assertEquals(mColumn3, m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnMatrix() {        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);        RealMatrix mColumn3 = new RecursiveLayoutRealMatrix(subColumn3);        assertNotSame(mColumn3, m.getColumnMatrix(1));        m.setColumnMatrix(1, mColumn3);        assertEquals(mColumn3, m.getColumnMatrix(1));        try {            m.setColumnMatrix(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnMatrix(0, m);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetSetColumnMatrixLarge() {        int n = 3 * 64;        RealMatrix m = new RecursiveLayoutRealMatrix(n, n);        RealMatrix sub = new RecursiveLayoutRealMatrix(n, 1).scalarAdd(1);        m.setColumnMatrix(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        assertEquals(sub, m.getColumnMatrix(2));    }        public void testGetRowVector() {        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);        RealVector mRow0 = new RealVectorImpl(subRow0[0]);        RealVector mRow3 = new RealVectorImpl(subRow3[0]);        assertEquals(mRow0, m.getRowVector(0));        assertEquals(mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowVector() {        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);        RealVector mRow3 = new RealVectorImpl(subRow3[0]);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowVector(0, mRow3);        assertEquals(mRow3, m.getRowVector(0));        try {            m.setRowVector(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowVector(0, new RealVectorImpl(5));            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetSetRowVectorLarge() {        int n = 3 * 64;        RealMatrix m = new RecursiveLayoutRealMatrix(n, n);        RealVector sub = new RealVectorImpl(n, 1.0);        m.setRowVector(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        assertEquals(sub, m.getRowVector(2));    }        public void testGetColumnVector() {        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);        RealVector mColumn1 = columnToVector(subColumn1);        RealVector mColumn3 = columnToVector(subColumn3);        assertEquals(mColumn1, m.getColumnVector(1));        assertEquals(mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnVector() {        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);        RealVector mColumn3 = columnToVector(subColumn3);        assertNotSame(mColumn3, m.getColumnVector(1));        m.setColumnVector(1, mColumn3);        assertEquals(mColumn3, m.getColumnVector(1));        try {            m.setColumnVector(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnVector(0, new RealVectorImpl(5));            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetSetColumnVectorLarge() {        int n = 3 * 64;        RealMatrix m = new RecursiveLayoutRealMatrix(n, n);        RealVector sub = new RealVectorImpl(n, 1.0);        m.setColumnVector(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        assertEquals(sub, m.getColumnVector(2));    }        private RealVector columnToVector(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new RealVectorImpl(data, false);    }    public void testGetRow() {        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);        checkArrays(subRow0[0], m.getRow(0));        checkArrays(subRow3[0], m.getRow(3));        try {            m.getRow(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRow(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRow() {        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);        assertTrue(subRow3[0][0] != m.getRow(0)[0]);        m.setRow(0, subRow3[0]);        checkArrays(subRow3[0], m.getRow(0));        try {            m.setRow(-1, subRow3[0]);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRow(0, new double[5]);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetSetRowLarge() {        int n = 3 * 64;        RealMatrix m = new RecursiveLayoutRealMatrix(n, n);        double[] sub = new double[n];        Arrays.fill(sub, 1.0);        m.setRow(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        checkArrays(sub, m.getRow(2));    }        public void testGetColumn() {        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);        double[] mColumn1 = columnToArray(subColumn1);        double[] mColumn3 = columnToArray(subColumn3);        checkArrays(mColumn1, m.getColumn(1));        checkArrays(mColumn3, m.getColumn(3));        try {            m.getColumn(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumn(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumn() {        RealMatrix m = new RecursiveLayoutRealMatrix(subTestData);        double[] mColumn3 = columnToArray(subColumn3);        assertTrue(mColumn3[0] != m.getColumn(1)[0]);        m.setColumn(1, mColumn3);        checkArrays(mColumn3, m.getColumn(1));        try {            m.setColumn(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumn(0, new double[5]);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetSetColumnLarge() {        int n = 3 * 64;        RealMatrix m = new RecursiveLayoutRealMatrix(n, n);        double[] sub = new double[n];        Arrays.fill(sub, 1.0);        m.setColumn(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        checkArrays(sub, m.getColumn(2));    }        private double[] columnToArray(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return data;    }    private void checkArrays(double[] expected, double[] actual) {        assertEquals(expected.length, actual.length);        for (int i = 0; i < expected.length; ++i) {            assertEquals(expected[i], actual[i], 1.0e-9 * Math.abs(expected[i]));                    }    }        public void testEqualsAndHashCode() {        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);        RecursiveLayoutRealMatrix m1 = (RecursiveLayoutRealMatrix) m.copy();        RecursiveLayoutRealMatrix mt = (RecursiveLayoutRealMatrix) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(new RecursiveLayoutRealMatrix(bigSingular)));     }        public void testToString() {        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);        assertEquals("RecursiveLayoutRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",                m.toString());    }        public void testSetSubMatrix() throws Exception {        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(testData);        m.setSubMatrix(detData2,1,1);        RealMatrix expected = new RecursiveLayoutRealMatrix            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);                  m.setSubMatrix(detData2,0,0);        expected = new RecursiveLayoutRealMatrix            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);                  m.setSubMatrix(testDataPlus2,0,0);              expected = new RecursiveLayoutRealMatrix            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});        assertEquals(expected, m);                   // javadoc example        RecursiveLayoutRealMatrix matrix = new RecursiveLayoutRealMatrix            (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});        matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1);        expected = new RecursiveLayoutRealMatrix            (new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}});        assertEquals(expected, matrix);           // dimension overflow        try {              m.setSubMatrix(testData,1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // dimension underflow        try {              m.setSubMatrix(testData,-1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        try {              m.setSubMatrix(testData,1,-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }                // null        try {            m.setSubMatrix(null,1,1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }                // ragged        try {            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }               // empty        try {            m.setSubMatrix(new double[][] {{}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }            }    public void testWalk() {        int rows    = 150;        int columns = 75;        RealMatrix m = new RecursiveLayoutRealMatrix(rows, columns);        m.walkInRowOrder(new SetVisitor());        GetVisitor getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new RecursiveLayoutRealMatrix(rows, columns);        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);                                assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);                                assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new RecursiveLayoutRealMatrix(rows, columns);        m.walkInColumnOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new RecursiveLayoutRealMatrix(rows, columns);        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);                                assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);                                assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new RecursiveLayoutRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new RecursiveLayoutRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);                                assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);                                assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new RecursiveLayoutRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new RecursiveLayoutRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);                                assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);                                assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }    }        private static class SetVisitor extends DefaultRealMatrixChangingVisitor {        private static final long serialVersionUID = 1773444180892369386L;        public double visit(int i, int j, double value) {            return i + j / 1024.0;        }    }    private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {        private static final long serialVersionUID = -7745543227178932689L;        private int count = 0;        public void visit(int i, int j, double value) {            ++count;            assertEquals(i + j / 1024.0, value, 0.0);        }        public int getCount() {            return count;        }    };    //--------------- -----------------Protected methods            /** verifies that two matrices are close (1-norm) */                  protected void assertClose(RealMatrix m, RealMatrix n, double tolerance) {        assertTrue(m.subtract(n).getNorm() < tolerance);    }        /** verifies that two vectors are close (sup norm) */    protected void assertClose(double[] m, double[] n, double tolerance) {        if (m.length != n.length) {            fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            assertEquals(m[i], n[i], tolerance);        }    }    private RecursiveLayoutRealMatrix createRandomMatrix(Random r, int rows, int columns) {        RecursiveLayoutRealMatrix m = new RecursiveLayoutRealMatrix(rows, columns);        for (int i = 0; i < rows; ++i) {            for (int j = 0; j < columns; ++j) {                m.setEntry(i, j, 200 * r.nextDouble() - 100);            }        }        return m;    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.stat.StatUtils;import junit.framework.TestCase;/** * This class contains test cases for the ExpandableDoubleArray. *  * @version $Revision$ $Date$ */public abstract class DoubleArrayAbstractTest extends TestCase {    protected DoubleArray da = null;    // Array used to test rolling    protected DoubleArray ra = null;    public DoubleArrayAbstractTest(String name) {        super(name);    }    public void testAdd1000() {        for (int i = 0; i < 1000; i++) {            da.addElement(i);        }        assertEquals(            "Number of elements should be equal to 1000 after adding 1000 values",            1000,            da.getNumElements());        assertEquals(            "The element at the 56th index should be 56",            56.0,            da.getElement(56),            Double.MIN_VALUE);    }    public void testGetValues() {        double[] controlArray = { 2.0, 4.0, 6.0 };        da.addElement(2.0);        da.addElement(4.0);        da.addElement(6.0);        double[] testArray = da.getElements();        for (int i = 0; i < da.getNumElements(); i++) {            assertEquals(                "The testArray values should equal the controlArray values, index i: "                    + i                    + " does not match",                testArray[i],                controlArray[i],                Double.MIN_VALUE);        }    }    public void testAddElementRolling() {        ra.addElement(0.5);        ra.addElement(1.0);        ra.addElement(1.0);        ra.addElement(1.0);        ra.addElement(1.0);        ra.addElement(1.0);        ra.addElementRolling(2.0);        assertEquals(            "There should be 6 elements in the eda",            6,            ra.getNumElements());        assertEquals(            "The max element should be 2.0",            2.0,            StatUtils.max(ra.getElements()),            Double.MIN_VALUE);        assertEquals(            "The min element should be 1.0",            1.0,            StatUtils.min(ra.getElements()),            Double.MIN_VALUE);        for (int i = 0; i < 1024; i++) {            ra.addElementRolling(i);        }        assertEquals(            "We just inserted 1024 rolling elements, num elements should still be 6",            6,            ra.getNumElements());    }    public void testMinMax() {        da.addElement(2.0);        da.addElement(22.0);        da.addElement(-2.0);        da.addElement(21.0);        da.addElement(22.0);        da.addElement(42.0);        da.addElement(62.0);        da.addElement(22.0);        da.addElement(122.0);        da.addElement(1212.0);        assertEquals("Min should be -2.0", -2.0, StatUtils.min(da.getElements()), Double.MIN_VALUE);        assertEquals(            "Max should be 1212.0",            1212.0,            StatUtils.max(da.getElements()),            Double.MIN_VALUE);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class ContinuedFractionTest extends TestCase {    /**     * Constructor for ContinuedFractionTest.     * @param name     */    public ContinuedFractionTest(String name) {        super(name);    }    public void testGoldenRatio(){        ContinuedFraction cf = new ContinuedFraction() {                        @Override            public double getA(int n, double x) {                return 1.0;            }            @Override            public double getB(int n, double x) {                return 1.0;            }        };                try {            double gr = cf.evaluate(0.0, 10e-9);            assertEquals(1.61803399, gr, 10e-9);        } catch (MathException e) {            fail(e.getMessage());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import java.util.ConcurrentModificationException;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.NoSuchElementException;import java.util.Random;import java.util.Set;import java.util.Map.Entry;import org.apache.commons.math.Field;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionConversionException;import org.apache.commons.math.fraction.FractionField;import junit.framework.TestCase;public class OpenIntToFieldTest extends TestCase {    private Map<Integer, Fraction> javaMap = new HashMap<Integer, Fraction>();    private FractionField field = FractionField.getInstance();    @Override    protected void setUp() throws Exception {        javaMap.put(50, new Fraction(100.0));        javaMap.put(75, new Fraction(75.0));        javaMap.put(25, new Fraction(500.0));        javaMap.put(Integer.MAX_VALUE, new Fraction(Integer.MAX_VALUE));        javaMap.put(0, new Fraction(-1.0));        javaMap.put(1, new Fraction(0.0));        javaMap.put(33, new Fraction(-0.1));        javaMap.put(23234234, new Fraction(-242343.0));        javaMap.put(23321, new Fraction (Integer.MIN_VALUE));        javaMap.put(-4444, new Fraction(332.0));        javaMap.put(-1, new Fraction(-2323.0));        javaMap.put(Integer.MIN_VALUE, new Fraction(44.0));        /* Add a few more to cause the table to rehash */        javaMap.putAll(generate());    }    private Map<Integer, Fraction> generate() {        Map<Integer, Fraction> map = new HashMap<Integer, Fraction>();        Random r = new Random();        double dd=0;        for (int i = 0; i < 2000; ++i)            dd = r.nextDouble();             try {                map.put(r.nextInt(), new Fraction(dd));            } catch (FractionConversionException e) {                throw new IllegalStateException("Invalid :"+dd, e);            }        return map;    }    private OpenIntToFieldHashMap<Fraction> createFromJavaMap(Field<Fraction> field) {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());        }        return map;    }        public void testPutAndGetWith0ExpectedSize() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field,0);        assertPutAndGet(map);    }        public void testPutAndGetWithExpectedSize() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field,500);        assertPutAndGet(map);    }    public void testPutAndGet() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);        assertPutAndGet(map);    }    private void assertPutAndGet(OpenIntToFieldHashMap<Fraction> map) {        assertPutAndGet(map, 0, new HashSet<Integer>());    }    private void assertPutAndGet(OpenIntToFieldHashMap<Fraction> map, int mapSize,            Set<Integer> keysInMap) {        assertEquals(mapSize, map.size());        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            if (!keysInMap.contains(mapEntry.getKey()))                ++mapSize;            assertEquals(mapSize, map.size());            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));        }    }    public void testPutAbsentOnExisting() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        int size = javaMap.size();        for (Map.Entry<Integer, Fraction> mapEntry : generateAbsent().entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            assertEquals(++size, map.size());            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));        }    }    public void testPutOnExisting() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            assertEquals(javaMap.size(), map.size());            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));        }    }    public void testGetAbsent() {        Map<Integer, Fraction> generated = generateAbsent();        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);                for (Map.Entry<Integer, Fraction> mapEntry : generated.entrySet())            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));    }    public void testGetFromEmpty() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);        assertTrue(field.getZero().equals(map.get(5)));        assertTrue(field.getZero().equals(map.get(0)));        assertTrue(field.getZero().equals(map.get(50)));    }    public void testRemove() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        int mapSize = javaMap.size();        assertEquals(mapSize, map.size());        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            map.remove(mapEntry.getKey());            assertEquals(--mapSize, map.size());            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));        }        /* Ensure that put and get still work correctly after removals */        assertPutAndGet(map);    }    /* This time only remove some entries */    public void testRemove2() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        int mapSize = javaMap.size();        int count = 0;        Set<Integer> keysInMap = new HashSet<Integer>(javaMap.keySet());        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            keysInMap.remove(mapEntry.getKey());            map.remove(mapEntry.getKey());            assertEquals(--mapSize, map.size());            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));            if (count++ > 5)                break;        }        /* Ensure that put and get still work correctly after removals */        assertPutAndGet(map, mapSize, keysInMap);    }    public void testRemoveFromEmpty() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);        assertTrue(field.getZero().equals(map.remove(50)));    }    public void testRemoveAbsent() {        Map<Integer, Fraction> generated = generateAbsent();        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        int mapSize = map.size();                for (Map.Entry<Integer, Fraction> mapEntry : generated.entrySet()) {            map.remove(mapEntry.getKey());            assertEquals(mapSize, map.size());            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));        }    }    /**     * Returns a map with at least 100 elements where each element is absent from javaMap.     */    private Map<Integer, Fraction> generateAbsent() {        Map<Integer, Fraction> generated = new HashMap<Integer, Fraction>();        do {            generated.putAll(generate());            for (Integer key : javaMap.keySet())                generated.remove(key);        } while (generated.size() < 100);        return generated;    }    public void testCopy() {        OpenIntToFieldHashMap<Fraction> copy =            new OpenIntToFieldHashMap<Fraction>(createFromJavaMap(field));        assertEquals(javaMap.size(), copy.size());        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet())            assertEquals(mapEntry.getValue(), copy.get(mapEntry.getKey()));    }    public void testContainsKey() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        for (Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            assertTrue(map.containsKey(mapEntry.getKey()));        }        for (Map.Entry<Integer, Fraction> mapEntry : generateAbsent().entrySet()) {            assertFalse(map.containsKey(mapEntry.getKey()));        }        for (Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            int key = mapEntry.getKey();            assertTrue(map.containsKey(key));            map.remove(key);            assertFalse(map.containsKey(key));        }    }    public void testIterator() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        OpenIntToFieldHashMap<Fraction>.Iterator iterator = map.iterator();        for (int i = 0; i < map.size(); ++i) {            assertTrue(iterator.hasNext());            iterator.advance();            int key = iterator.key();            assertTrue(map.containsKey(key));            assertEquals(javaMap.get(key), map.get(key));            assertEquals(javaMap.get(key), iterator.value());            assertTrue(javaMap.containsKey(key));        }        assertFalse(iterator.hasNext());        try {            iterator.advance();            fail("an exception should have been thrown");        } catch (NoSuchElementException nsee) {            // expected        }    }    public void testConcurrentModification() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        OpenIntToFieldHashMap<Fraction>.Iterator iterator = map.iterator();        map.put(3, new Fraction(3));        try {            iterator.advance();            fail("an exception should have been thrown");        } catch (ConcurrentModificationException cme) {            // expected        }    }    /**     * Regression test for a bug in findInsertionIndex where the hashing in the second probing     * loop was inconsistent with the first causing duplicate keys after the right sequence     * of puts and removes.     */    public void testPutKeysWithCollisions() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);        int key1 = -1996012590;        Fraction value1 = new Fraction(1);        map.put(key1, value1);        int key2 = 835099822;        map.put(key2, value1);        int key3 = 1008859686;        map.put(key3, value1);        assertEquals(value1, map.get(key3));        assertEquals(3, map.size());                map.remove(key2);        Fraction value2 = new Fraction(2);        map.put(key3, value2);        assertEquals(value2, map.get(key3));        assertEquals(2, map.size());    }        /**     * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly     * different manner.     */    public void testPutKeysWithCollision2() {        OpenIntToFieldHashMap<Fraction>map = new OpenIntToFieldHashMap<Fraction>(field);        int key1 = 837989881;        Fraction value1 = new Fraction(1);        map.put(key1, value1);        int key2 = 476463321;        map.put(key2, value1);        assertEquals(2, map.size());        assertEquals(value1, map.get(key2));                map.remove(key1);        Fraction value2 = new Fraction(2);        map.put(key2, value2);        assertEquals(1, map.size());        assertEquals(value2, map.get(key2));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.random.RandomDataImpl;import org.apache.commons.math.random.RandomData;/** * This class contains test cases for the ResizableDoubleArray. *  * @version $Revision$ $Date$ */public class ResizableDoubleArrayTest extends DoubleArrayAbstractTest {        public ResizableDoubleArrayTest(String name) {        super( name );    }    @Override    protected void tearDown() throws Exception {        da = null;        ra = null;    }           @Override    protected void setUp() throws Exception {        da = new ResizableDoubleArray();        ra = new ResizableDoubleArray();    }        public void testConstructors() {        float defaultExpansionFactor = 2.0f;        float defaultContractionCriteria = 2.5f;        int defaultMode = ResizableDoubleArray.MULTIPLICATIVE_MODE;                ResizableDoubleArray testDa = new ResizableDoubleArray(2);        assertEquals(0, testDa.getNumElements());        assertEquals(2, testDa.getInternalLength());        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);        assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);        assertEquals(defaultMode, testDa.getExpansionMode());        try {            da = new ResizableDoubleArray(-1);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                testDa = new ResizableDoubleArray(2, 2.0f);        assertEquals(0, testDa.getNumElements());        assertEquals(2, testDa.getInternalLength());        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);        assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);        assertEquals(defaultMode, testDa.getExpansionMode());                try {            da = new ResizableDoubleArray(2, 0.5f);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                testDa = new ResizableDoubleArray(2, 3.0f);        assertEquals(3.0f, testDa.getExpansionFactor(), 0);        assertEquals(3.5f, testDa.getContractionCriteria(), 0);                testDa = new ResizableDoubleArray(2, 2.0f, 3.0f);        assertEquals(0, testDa.getNumElements());        assertEquals(2, testDa.getInternalLength());        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);        assertEquals(3.0f, testDa.getContractionCriteria(), 0);        assertEquals(defaultMode, testDa.getExpansionMode());                try {            da = new ResizableDoubleArray(2, 2.0f, 1.5f);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                testDa = new ResizableDoubleArray(2, 2.0f, 3.0f,                 ResizableDoubleArray.ADDITIVE_MODE);        assertEquals(0, testDa.getNumElements());        assertEquals(2, testDa.getInternalLength());        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);        assertEquals(3.0f, testDa.getContractionCriteria(), 0);        assertEquals(ResizableDoubleArray.ADDITIVE_MODE,                 testDa.getExpansionMode());                try {            da = new ResizableDoubleArray(2, 2.0f, 2.5f, -1);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                // Copy constructor        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f,                 ResizableDoubleArray.ADDITIVE_MODE);        testDa.addElement(2.0);        testDa.addElement(3.2);        ResizableDoubleArray copyDa = new ResizableDoubleArray(testDa);        assertEquals(copyDa, testDa);        assertEquals(testDa, copyDa);       }            public void testSetElementArbitraryExpansion() {                // MULTIPLICATIVE_MODE         da.addElement(2.0);        da.addElement(4.0);        da.addElement(6.0);        da.setElement(1, 3.0);                // Expand the array arbitrarily to 1000 items        da.setElement(1000, 3.4);                assertEquals( "The number of elements should now be 1001, it isn't",                 da.getNumElements(), 1001);                assertEquals( "Uninitialized Elements are default value of 0.0, index 766 wasn't", 0.0,                da.getElement( 760 ), Double.MIN_VALUE );                assertEquals( "The 1000th index should be 3.4, it isn't", 3.4, da.getElement(1000),                 Double.MIN_VALUE );        assertEquals( "The 0th index should be 2.0, it isn't", 2.0, da.getElement(0),                 Double.MIN_VALUE);                 // Make sure numElements and expansion work correctly for expansion boundary cases        da.clear();        da.addElement(2.0);        da.addElement(4.0);        da.addElement(6.0);        assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());        assertEquals(3, da.getNumElements());        da.setElement(3, 7.0);        assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());        assertEquals(4, da.getNumElements());        da.setElement(10, 10.0);        assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());        assertEquals(11, da.getNumElements());        da.setElement(9, 10.0);        assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());        assertEquals(11, da.getNumElements());                try {            da.setElement(-2, 3);            fail("Expecting ArrayIndexOutOfBoundsException for negative index");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected        }                // ADDITIVE_MODE                ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 3.0f,                 ResizableDoubleArray.ADDITIVE_MODE);        assertEquals(2, testDa.getInternalLength());        testDa.addElement(1d);        testDa.addElement(1d);        assertEquals(2, testDa.getInternalLength());        testDa.addElement(1d);        assertEquals(4, testDa.getInternalLength());             }    @Override    public void testAdd1000() {        super.testAdd1000();        assertEquals("Internal Storage length should be 1024 if we started out with initial capacity of " +                "16 and an expansion factor of 2.0",                1024, ((ResizableDoubleArray) da).getInternalLength());    }    @Override    public void testAddElementRolling() {        super.testAddElementRolling();                // MULTIPLICATIVE_MODE        da.clear();        da.addElement(1);        da.addElement(2);        da.addElementRolling(3);        assertEquals(3, da.getElement(1), 0);        da.addElementRolling(4);        assertEquals(3, da.getElement(0), 0);        assertEquals(4, da.getElement(1), 0);        da.addElement(5);        assertEquals(5, da.getElement(2), 0);        da.addElementRolling(6);        assertEquals(4, da.getElement(0), 0);        assertEquals(5, da.getElement(1), 0);        assertEquals(6, da.getElement(2), 0);                   // ADDITIVE_MODE  (x's are occupied storage locations, 0's are open)        ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 2.5f,                 ResizableDoubleArray.ADDITIVE_MODE);        assertEquals(2, testDa.getInternalLength());        testDa.addElement(1d); // x,0        testDa.addElement(2d); // x,x        testDa.addElement(3d); // x,x,x,0 -- expanded        assertEquals(1d, testDa.getElement(0), 0);        assertEquals(2d, testDa.getElement(1), 0);        assertEquals(3d, testDa.getElement(2), 0);           assertEquals(4, testDa.getInternalLength());  // x,x,x,0         assertEquals(3, testDa.getNumElements());        testDa.addElementRolling(4d);        assertEquals(2d, testDa.getElement(0), 0);        assertEquals(3d, testDa.getElement(1), 0);        assertEquals(4d, testDa.getElement(2), 0);           assertEquals(4, testDa.getInternalLength());  // 0,x,x,x        assertEquals(3, testDa.getNumElements());        testDa.addElementRolling(5d);   // 0,0,x,x,x,0 -- time to contract        assertEquals(3d, testDa.getElement(0), 0);        assertEquals(4d, testDa.getElement(1), 0);        assertEquals(5d, testDa.getElement(2), 0);           assertEquals(4, testDa.getInternalLength());  // contracted -- x,x,x,0             assertEquals(3, testDa.getNumElements());        try {            testDa.getElement(4);            fail("Expecting ArrayIndexOutOfBoundsException");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected        }          try {            testDa.getElement(-1);            fail("Expecting ArrayIndexOutOfBoundsException");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected        }    }        public void testSetNumberOfElements() {        da.addElement( 1.0 );        da.addElement( 1.0 );        da.addElement( 1.0 );        da.addElement( 1.0 );        da.addElement( 1.0 );        da.addElement( 1.0 );        assertEquals( "Number of elements should equal 6", da.getNumElements(), 6);                ((ResizableDoubleArray) da).setNumElements( 3 );        assertEquals( "Number of elements should equal 3", da.getNumElements(), 3);                try {            ((ResizableDoubleArray) da).setNumElements( -3 );            fail( "Setting number of elements to negative should've thrown an exception");        } catch( IllegalArgumentException iae ) {        }                ((ResizableDoubleArray) da).setNumElements(1024);        assertEquals( "Number of elements should now be 1024", da.getNumElements(), 1024);        assertEquals( "Element 453 should be a default double", da.getElement( 453 ), 0.0, Double.MIN_VALUE);            }        public void testWithInitialCapacity() {                ResizableDoubleArray eDA2 = new ResizableDoubleArray(2);        assertEquals("Initial number of elements should be 0", 0, eDA2.getNumElements());                RandomData randomData = new RandomDataImpl();        int iterations = randomData.nextInt(100, 1000);                for( int i = 0; i < iterations; i++) {            eDA2.addElement( i );        }                assertEquals("Number of elements should be equal to " + iterations, iterations, eDA2.getNumElements());                eDA2.addElement( 2.0 );                assertEquals("Number of elements should be equals to " + (iterations +1),                iterations + 1 , eDA2.getNumElements() );    }        public void testWithInitialCapacityAndExpansionFactor() {                ResizableDoubleArray eDA3 = new ResizableDoubleArray(3, 3.0f, 3.5f);        assertEquals("Initial number of elements should be 0", 0, eDA3.getNumElements() );                RandomData randomData = new RandomDataImpl();        int iterations = randomData.nextInt(100, 3000);                for( int i = 0; i < iterations; i++) {            eDA3.addElement( i );        }                assertEquals("Number of elements should be equal to " + iterations, iterations,eDA3.getNumElements());                eDA3.addElement( 2.0 );                assertEquals("Number of elements should be equals to " + (iterations +1),                iterations +1, eDA3.getNumElements() );                assertEquals("Expansion factor should equal 3.0", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);    }        public void testDiscard() {        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        assertEquals( "Number of elements should be 11", 11, da.getNumElements());                ((ResizableDoubleArray)da).discardFrontElements(5);        assertEquals( "Number of elements should be 6", 6, da.getNumElements());        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        assertEquals( "Number of elements should be 10", 10, da.getNumElements());        ((ResizableDoubleArray)da).discardMostRecentElements(2);        assertEquals( "Number of elements should be 8", 8, da.getNumElements());                try {            ((ResizableDoubleArray)da).discardFrontElements(-1);            fail( "Trying to discard a negative number of element is not allowed");        } catch( Exception e ){        }        try {            ((ResizableDoubleArray)da).discardMostRecentElements(-1);            fail( "Trying to discard a negative number of element is not allowed");        } catch( Exception e ){        }        try {            ((ResizableDoubleArray)da).discardFrontElements( 10000 );            fail( "You can't discard more elements than the array contains");        } catch( Exception e ){        }        try {            ((ResizableDoubleArray)da).discardMostRecentElements( 10000 );            fail( "You can't discard more elements than the array contains");        } catch( Exception e ){        }    }    public void testSubstitute() {            da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        assertEquals( "Number of elements should be 11", 11, da.getNumElements());                ((ResizableDoubleArray)da).substituteMostRecentElement(24);        assertEquals( "Number of elements should be 11", 11, da.getNumElements());        try {            ((ResizableDoubleArray)da).discardMostRecentElements(10);        } catch( Exception e ){            fail( "Trying to discard a negative number of element is not allowed");        }        ((ResizableDoubleArray)da).substituteMostRecentElement(24);        assertEquals( "Number of elements should be 1", 1, da.getNumElements());    }        public void testMutators() {        ((ResizableDoubleArray)da).setContractionCriteria(10f);        assertEquals(10f, ((ResizableDoubleArray)da).getContractionCriteria(), 0);        ((ResizableDoubleArray)da).setExpansionFactor(8f);          assertEquals(8f, ((ResizableDoubleArray)da).getExpansionFactor(), 0);        try {            ((ResizableDoubleArray)da).setExpansionFactor(11f);  // greater than contractionCriteria            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        ((ResizableDoubleArray)da).setExpansionMode(                ResizableDoubleArray.ADDITIVE_MODE);        assertEquals(ResizableDoubleArray.ADDITIVE_MODE,                 ((ResizableDoubleArray)da).getExpansionMode());        try {            ((ResizableDoubleArray)da).setExpansionMode(-1);            fail ("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }        public void testEqualsAndHashCode() throws Exception {                // Wrong type        ResizableDoubleArray first = new ResizableDoubleArray();        Double other = new Double(2);        assertFalse(first.equals(other));                // Null        other = null;        assertFalse(first.equals(other));                // Reflexive        assertTrue(first.equals(first));                // Argumentless constructor        ResizableDoubleArray second = new ResizableDoubleArray();        verifyEquality(first, second);                // Equals iff same data, same properties        ResizableDoubleArray third = new ResizableDoubleArray(3, 2.0f, 2.0f);        verifyInequality(third, first);        ResizableDoubleArray fourth = new ResizableDoubleArray(3, 2.0f, 2.0f);        ResizableDoubleArray fifth = new ResizableDoubleArray(2, 2.0f, 2.0f);        verifyEquality(third, fourth);        verifyInequality(third, fifth);        third.addElement(4.1);        third.addElement(4.2);        third.addElement(4.3);        fourth.addElement(4.1);        fourth.addElement(4.2);        fourth.addElement(4.3);        verifyEquality(third, fourth);                // expand        fourth.addElement(4.4);        verifyInequality(third, fourth);        third.addElement(4.4);        verifyEquality(third, fourth);        fourth.addElement(4.4);        verifyInequality(third, fourth);        third.addElement(4.4);        verifyEquality(third, fourth);        fourth.addElementRolling(4.5);        third.addElementRolling(4.5);        verifyEquality(third, fourth);                // discard        third.discardFrontElements(1);        verifyInequality(third, fourth);        fourth.discardFrontElements(1);        verifyEquality(third, fourth);                // discard recent        third.discardMostRecentElements(2);        fourth.discardMostRecentElements(2);        verifyEquality(third, fourth);                // wrong order        third.addElement(18);        fourth.addElement(17);        third.addElement(17);        fourth.addElement(18);        verifyInequality(third, fourth);                // copy        ResizableDoubleArray.copy(fourth, fifth);        verifyEquality(fourth, fifth);                // Copy constructor        verifyEquality(fourth, new ResizableDoubleArray(fourth));                // Instance copy        verifyEquality(fourth, fourth.copy());                    }        private void verifyEquality(ResizableDoubleArray a, ResizableDoubleArray b) {        assertTrue(b.equals(a));        assertTrue(a.equals(b));        assertEquals(a.hashCode(), b.hashCode());        }        private void verifyInequality(ResizableDoubleArray a, ResizableDoubleArray b) {        assertFalse(b.equals(a));        assertFalse(a.equals(b));        assertFalse(a.hashCode() == b.hashCode());    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.util;import java.math.BigDecimal;import java.math.BigInteger;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.random.RandomDataImpl;import org.apache.commons.math.TestUtils;/** * Test cases for the MathUtils class. * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug *          2007) $ */public final class MathUtilsTest extends TestCase {    public MathUtilsTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(MathUtilsTest.class);        suite.setName("MathUtils Tests");        return suite;    }    /** cached binomial coefficients */    private static final List<Map<Integer, Long>> binomialCache = new ArrayList<Map<Integer, Long>>();    /**     * Exact (caching) recursive implementation to test against     */    private long binomialCoefficient(int n, int k) throws ArithmeticException {        if (binomialCache.size() > n) {            Long cachedResult = binomialCache.get(n).get(new Integer(k));            if (cachedResult != null) {                return cachedResult.longValue();            }        }        long result = -1;        if ((n == k) || (k == 0)) {            result = 1;        } else if ((k == 1) || (k == n - 1)) {            result = n;        } else {            // Reduce stack depth for larger values of n            if (k < n - 100) {                binomialCoefficient(n - 100, k);            }            if (k > 100) {                binomialCoefficient(n - 100, k - 100);            }            result = MathUtils.addAndCheck(binomialCoefficient(n - 1, k - 1),                binomialCoefficient(n - 1, k));        }        if (result == -1) {            throw new ArithmeticException(                "error computing binomial coefficient");        }        for (int i = binomialCache.size(); i < n + 1; i++) {            binomialCache.add(new HashMap<Integer, Long>());        }        binomialCache.get(n).put(new Integer(k), new Long(result));        return result;    }    /**     * Exact direct multiplication implementation to test against     */    private long factorial(int n) {        long result = 1;        for (int i = 2; i <= n; i++) {            result *= i;        }        return result;    }    /** Verify that b(0,0) = 1 */    public void test0Choose0() {        assertEquals(MathUtils.binomialCoefficientDouble(0, 0), 1d, 0);        assertEquals(MathUtils.binomialCoefficientLog(0, 0), 0d, 0);        assertEquals(MathUtils.binomialCoefficient(0, 0), 1);    }    public void testAddAndCheck() {        int big = Integer.MAX_VALUE;        int bigNeg = Integer.MIN_VALUE;        assertEquals(big, MathUtils.addAndCheck(big, 0));        try {            MathUtils.addAndCheck(big, 1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {        }        try {            MathUtils.addAndCheck(bigNeg, -1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {        }    }    public void testAddAndCheckLong() {        long max = Long.MAX_VALUE;        long min = Long.MIN_VALUE;        assertEquals(max, MathUtils.addAndCheck(max, 0L));        assertEquals(min, MathUtils.addAndCheck(min, 0L));        assertEquals(max, MathUtils.addAndCheck(0L, max));        assertEquals(min, MathUtils.addAndCheck(0L, min));        assertEquals(1, MathUtils.addAndCheck(-1L, 2L));        assertEquals(1, MathUtils.addAndCheck(2L, -1L));        assertEquals(-3, MathUtils.addAndCheck(-2L, -1L));        assertEquals(min, MathUtils.addAndCheck(min + 1, -1L));        testAddAndCheckLongFailure(max, 1L);        testAddAndCheckLongFailure(min, -1L);        testAddAndCheckLongFailure(1L, max);        testAddAndCheckLongFailure(-1L, min);    }    private void testAddAndCheckLongFailure(long a, long b) {        try {            MathUtils.addAndCheck(a, b);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // success        }    }    public void testBinomialCoefficient() {        long[] bcoef5 = {            1,            5,            10,            10,            5,            1 };        long[] bcoef6 = {            1,            6,            15,            20,            15,            6,            1 };        for (int i = 0; i < 6; i++) {            assertEquals("5 choose " + i, bcoef5[i], MathUtils.binomialCoefficient(5, i));        }        for (int i = 0; i < 7; i++) {            assertEquals("6 choose " + i, bcoef6[i], MathUtils.binomialCoefficient(6, i));        }        for (int n = 1; n < 10; n++) {            for (int k = 0; k <= n; k++) {                assertEquals(n + " choose " + k, binomialCoefficient(n, k), MathUtils.binomialCoefficient(n, k));                assertEquals(n + " choose " + k, binomialCoefficient(n, k), MathUtils.binomialCoefficientDouble(n, k), Double.MIN_VALUE);                assertEquals(n + " choose " + k, Math.log(binomialCoefficient(n, k)), MathUtils.binomialCoefficientLog(n, k), 10E-12);            }        }        int[] n = { 34, 66, 100, 1500, 1500 };        int[] k = { 17, 33, 10, 1500 - 4, 4 };        for (int i = 0; i < n.length; i++) {            long expected = binomialCoefficient(n[i], k[i]);            assertEquals(n[i] + " choose " + k[i], expected,                MathUtils.binomialCoefficient(n[i], k[i]));            assertEquals(n[i] + " choose " + k[i], expected,                MathUtils.binomialCoefficientDouble(n[i], k[i]), 0.0);            assertEquals("log(" + n[i] + " choose " + k[i] + ")", Math.log(expected),                MathUtils.binomialCoefficientLog(n[i], k[i]), 0.0);        }    }    /**     * Tests correctness for large n and sharpness of upper bound in API doc     * JIRA: MATH-241     */    public void testBinomialCoefficientLarge() throws Exception {        // This tests all legal and illegal values for n <= 200.        for (int n = 0; n <= 200; n++) {            for (int k = 0; k <= n; k++) {                long ourResult = -1;                long exactResult = -1;                boolean shouldThrow = false;                boolean didThrow = false;                try {                    ourResult = MathUtils.binomialCoefficient(n, k);                } catch (ArithmeticException ex) {                    didThrow = true;                }                try {                    exactResult = binomialCoefficient(n, k);                } catch (ArithmeticException ex) {                    shouldThrow = true;                }                assertEquals(n + " choose " + k, exactResult, ourResult);                assertEquals(n + " choose " + k, shouldThrow, didThrow);                assertTrue(n + " choose " + k, (n > 66 || !didThrow));                if (!shouldThrow && exactResult > 1) {                    assertEquals(n + " choose " + k, 1.,                        MathUtils.binomialCoefficientDouble(n, k) / exactResult, 1e-10);                    assertEquals(n + " choose " + k, 1,                        MathUtils.binomialCoefficientLog(n, k) / Math.log(exactResult), 1e-10);                }            }        }        long ourResult = MathUtils.binomialCoefficient(300, 3);        long exactResult = binomialCoefficient(300, 3);        assertEquals(exactResult, ourResult);        ourResult = MathUtils.binomialCoefficient(700, 697);        exactResult = binomialCoefficient(700, 697);        assertEquals(exactResult, ourResult);        // This one should throw        try {            MathUtils.binomialCoefficient(700, 300);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // Expected        }        int n = 10000;        ourResult = MathUtils.binomialCoefficient(n, 3);        exactResult = binomialCoefficient(n, 3);        assertEquals(exactResult, ourResult);        assertEquals(1, MathUtils.binomialCoefficientDouble(n, 3) / exactResult, 1e-10);        assertEquals(1, MathUtils.binomialCoefficientLog(n, 3) / Math.log(exactResult), 1e-10);    }    public void testBinomialCoefficientFail() {        try {            MathUtils.binomialCoefficient(4, 5);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficientDouble(4, 5);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficientLog(4, 5);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficient(-1, -2);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficientDouble(-1, -2);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficientLog(-1, -2);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficient(67, 30);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {            // ignored        }        try {            MathUtils.binomialCoefficient(67, 34);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {            // ignored        }        double x = MathUtils.binomialCoefficientDouble(1030, 515);        assertTrue("expecting infinite binomial coefficient", Double            .isInfinite(x));    }    public void testCompareTo() {      assertEquals(0, MathUtils.compareTo(152.33, 152.32, .011));      assertTrue(MathUtils.compareTo(152.308, 152.32, .011) < 0);      assertTrue(MathUtils.compareTo(152.33, 152.318, .011) > 0);    }        public void testCosh() {        double x = 3.0;        double expected = 10.06766;        assertEquals(expected, MathUtils.cosh(x), 1.0e-5);    }    public void testCoshNaN() {        assertTrue(Double.isNaN(MathUtils.cosh(Double.NaN)));    }    public void testEquals() {        double[] testArray = {            Double.NaN,            Double.POSITIVE_INFINITY,            Double.NEGATIVE_INFINITY,            1d,            0d };        for (int i = 0; i < testArray.length; i++) {            for (int j = 0; j < testArray.length; j++) {                if (i == j) {                    assertTrue(MathUtils.equals(testArray[i], testArray[j]));                    assertTrue(MathUtils.equals(testArray[j], testArray[i]));                } else {                    assertTrue(!MathUtils.equals(testArray[i], testArray[j]));                    assertTrue(!MathUtils.equals(testArray[j], testArray[i]));                }            }        }    }    public void testEqualsWithAllowedDelta() {        assertTrue(MathUtils.equals(153.0000, 153.0000, .0625));        assertTrue(MathUtils.equals(153.0000, 153.0625, .0625));        assertTrue(MathUtils.equals(152.9375, 153.0000, .0625));        assertTrue(MathUtils.equals(Double.NaN, Double.NaN, 1.0));        assertTrue(MathUtils.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));        assertTrue(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0));        assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));        assertFalse(MathUtils.equals(153.0000, 153.0625, .0624));        assertFalse(MathUtils.equals(152.9374, 153.0000, .0625));    }    public void testEqualsWithAllowedUlps() {        assertTrue(MathUtils.equals(153, 153, 1));        assertTrue(MathUtils.equals(153, 153.00000000000003, 1));        assertFalse(MathUtils.equals(153, 153.00000000000006, 1));        assertTrue(MathUtils.equals(153, 152.99999999999997, 1));        assertFalse(MathUtils.equals(153, 152.99999999999994, 1));                assertTrue(MathUtils.equals(-128, -127.99999999999999, 1));        assertFalse(MathUtils.equals(-128, -127.99999999999997, 1));        assertTrue(MathUtils.equals(-128, -128.00000000000003, 1));        assertFalse(MathUtils.equals(-128, -128.00000000000006, 1));        assertTrue(MathUtils.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1));        assertTrue(MathUtils.equals(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));        assertTrue(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1));        assertTrue(MathUtils.equals(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1));        assertTrue(MathUtils.equals(Double.NaN, Double.NaN, 1));        assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));    }        public void testArrayEquals() {        assertFalse(MathUtils.equals(new double[] { 1d }, null));        assertFalse(MathUtils.equals(null, new double[] { 1d }));        assertTrue(MathUtils.equals((double[]) null, (double[]) null));        assertFalse(MathUtils.equals(new double[] { 1d }, new double[0]));        assertTrue(MathUtils.equals(new double[] { 1d }, new double[] { 1d }));        assertTrue(MathUtils.equals(new double[] {                                      Double.NaN, Double.POSITIVE_INFINITY,                                      Double.NEGATIVE_INFINITY, 1d, 0d                                    }, new double[] {                                      Double.NaN, Double.POSITIVE_INFINITY,                                      Double.NEGATIVE_INFINITY, 1d, 0d                                    }));        assertFalse(MathUtils.equals(new double[] { Double.POSITIVE_INFINITY },                                     new double[] { Double.NEGATIVE_INFINITY }));        assertFalse(MathUtils.equals(new double[] { 1d },                                     new double[] { MathUtils.nextAfter(1d, 2d) }));    }    public void testFactorial() {        for (int i = 1; i < 21; i++) {            assertEquals(i + "! ", factorial(i), MathUtils.factorial(i));            assertEquals(i + "! ", factorial(i), MathUtils.factorialDouble(i), Double.MIN_VALUE);            assertEquals(i + "! ", Math.log(factorial(i)), MathUtils.factorialLog(i), 10E-12);        }                assertEquals("0", 1, MathUtils.factorial(0));        assertEquals("0", 1.0d, MathUtils.factorialDouble(0), 1E-14);        assertEquals("0", 0.0d, MathUtils.factorialLog(0), 1E-14);    }    public void testFactorialFail() {        try {            MathUtils.factorial(-1);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.factorialDouble(-1);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.factorialLog(-1);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.factorial(21);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {            // ignored        }        assertTrue("expecting infinite factorial value", Double.isInfinite(MathUtils.factorialDouble(171)));    }    public void testGcd() {        int a = 30;        int b = 50;        int c = 77;        assertEquals(0, MathUtils.gcd(0, 0));        assertEquals(b, MathUtils.gcd(0, b));        assertEquals(a, MathUtils.gcd(a, 0));        assertEquals(b, MathUtils.gcd(0, -b));        assertEquals(a, MathUtils.gcd(-a, 0));        assertEquals(10, MathUtils.gcd(a, b));        assertEquals(10, MathUtils.gcd(-a, b));        assertEquals(10, MathUtils.gcd(a, -b));        assertEquals(10, MathUtils.gcd(-a, -b));        assertEquals(1, MathUtils.gcd(a, c));        assertEquals(1, MathUtils.gcd(-a, c));        assertEquals(1, MathUtils.gcd(a, -c));        assertEquals(1, MathUtils.gcd(-a, -c));        assertEquals(3 * (1<<15), MathUtils.gcd(3 * (1<<20), 9 * (1<<15)));        assertEquals(Integer.MAX_VALUE, MathUtils.gcd(Integer.MAX_VALUE, 0));        assertEquals(Integer.MAX_VALUE, MathUtils.gcd(-Integer.MAX_VALUE, 0));        assertEquals(1<<30, MathUtils.gcd(1<<30, -Integer.MIN_VALUE));        try {            // gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE            MathUtils.gcd(Integer.MIN_VALUE, 0);            fail("expecting ArithmeticException");        } catch (ArithmeticException expected) {            // expected        }        try {            // gcd(0, Integer.MIN_VALUE) > Integer.MAX_VALUE            MathUtils.gcd(0, Integer.MIN_VALUE);            fail("expecting ArithmeticException");        } catch (ArithmeticException expected) {            // expected        }        try {            // gcd(Integer.MIN_VALUE, Integer.MIN_VALUE) > Integer.MAX_VALUE            MathUtils.gcd(Integer.MIN_VALUE, Integer.MIN_VALUE);            fail("expecting ArithmeticException");        } catch (ArithmeticException expected) {            // expected        }    }    public void testHash() {        double[] testArray = {            Double.NaN,            Double.POSITIVE_INFINITY,            Double.NEGATIVE_INFINITY,            1d,            0d,            1E-14,            (1 + 1E-14),            Double.MIN_VALUE,            Double.MAX_VALUE };        for (int i = 0; i < testArray.length; i++) {            for (int j = 0; j < testArray.length; j++) {                if (i == j) {                    assertEquals(MathUtils.hash(testArray[i]), MathUtils.hash(testArray[j]));                    assertEquals(MathUtils.hash(testArray[j]), MathUtils.hash(testArray[i]));                } else {                    assertTrue(MathUtils.hash(testArray[i]) != MathUtils.hash(testArray[j]));                    assertTrue(MathUtils.hash(testArray[j]) != MathUtils.hash(testArray[i]));                }            }        }    }    public void testArrayHash() {        assertEquals(0, MathUtils.hash((double[]) null));        assertEquals(MathUtils.hash(new double[] {                                      Double.NaN, Double.POSITIVE_INFINITY,                                      Double.NEGATIVE_INFINITY, 1d, 0d                                    }),                     MathUtils.hash(new double[] {                                      Double.NaN, Double.POSITIVE_INFINITY,                                      Double.NEGATIVE_INFINITY, 1d, 0d                                    }));        assertFalse(MathUtils.hash(new double[] { 1d }) ==                    MathUtils.hash(new double[] { MathUtils.nextAfter(1d, 2d) }));        assertFalse(MathUtils.hash(new double[] { 1d }) ==                    MathUtils.hash(new double[] { 1d, 1d }));    }        /**     * Make sure that permuted arrays do not hash to the same value.     */    public void testPermutedArrayHash() {        double[] original = new double[10];        double[] permuted = new double[10];        RandomDataImpl random = new RandomDataImpl();                // Generate 10 distinct random values        for (int i = 0; i < 10; i++) {            original[i] = random.nextUniform(i + 0.5, i + 0.75);        }                // Generate a random permutation, making sure it is not the identity        boolean isIdentity = true;        do {            int[] permutation = random.nextPermutation(10, 10);            for (int i = 0; i < 10; i++) {                if (i != permutation[i]) {                    isIdentity = false;                }                permuted[i] = original[permutation[i]];            }        } while (isIdentity);                // Verify that permuted array has different hash        assertFalse(MathUtils.hash(original) == MathUtils.hash(permuted));    }    public void testIndicatorByte() {        assertEquals((byte)1, MathUtils.indicator((byte)2));        assertEquals((byte)1, MathUtils.indicator((byte)0));        assertEquals((byte)(-1), MathUtils.indicator((byte)(-2)));    }    public void testIndicatorDouble() {        double delta = 0.0;        assertEquals(1.0, MathUtils.indicator(2.0), delta);        assertEquals(1.0, MathUtils.indicator(0.0), delta);        assertEquals(-1.0, MathUtils.indicator(-2.0), delta);        assertEquals(Double.NaN, MathUtils.indicator(Double.NaN));    }    public void testIndicatorFloat() {        float delta = 0.0F;        assertEquals(1.0F, MathUtils.indicator(2.0F), delta);        assertEquals(1.0F, MathUtils.indicator(0.0F), delta);        assertEquals(-1.0F, MathUtils.indicator(-2.0F), delta);    }    public void testIndicatorInt() {        assertEquals(1, MathUtils.indicator((2)));        assertEquals(1, MathUtils.indicator((0)));        assertEquals((-1), MathUtils.indicator((-2)));    }    public void testIndicatorLong() {        assertEquals(1L, MathUtils.indicator(2L));        assertEquals(1L, MathUtils.indicator(0L));        assertEquals(-1L, MathUtils.indicator(-2L));    }    public void testIndicatorShort() {        assertEquals((short)1, MathUtils.indicator((short)2));        assertEquals((short)1, MathUtils.indicator((short)0));        assertEquals((short)(-1), MathUtils.indicator((short)(-2)));    }    public void testLcm() {        int a = 30;        int b = 50;        int c = 77;        assertEquals(0, MathUtils.lcm(0, b));        assertEquals(0, MathUtils.lcm(a, 0));        assertEquals(b, MathUtils.lcm(1, b));        assertEquals(a, MathUtils.lcm(a, 1));        assertEquals(150, MathUtils.lcm(a, b));        assertEquals(150, MathUtils.lcm(-a, b));        assertEquals(150, MathUtils.lcm(a, -b));        assertEquals(150, MathUtils.lcm(-a, -b));        assertEquals(2310, MathUtils.lcm(a, c));        // Assert that no intermediate value overflows:        // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)        assertEquals((1<<20)*15, MathUtils.lcm((1<<20)*3, (1<<20)*5));        // Special case        assertEquals(0, MathUtils.lcm(0, 0));        try {            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int            MathUtils.lcm(Integer.MIN_VALUE, 1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected        }                try {            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int            MathUtils.lcm(Integer.MIN_VALUE, 1<<20);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected        }        try {            MathUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected        }    }    public void testLog() {        assertEquals(2.0, MathUtils.log(2, 4), 0);        assertEquals(3.0, MathUtils.log(2, 8), 0);        assertTrue(Double.isNaN(MathUtils.log(-1, 1)));        assertTrue(Double.isNaN(MathUtils.log(1, -1)));        assertTrue(Double.isNaN(MathUtils.log(0, 0)));        assertEquals(0, MathUtils.log(0, 10), 0);        assertEquals(Double.NEGATIVE_INFINITY, MathUtils.log(10, 0), 0);    }    public void testMulAndCheck() {        int big = Integer.MAX_VALUE;        int bigNeg = Integer.MIN_VALUE;        assertEquals(big, MathUtils.mulAndCheck(big, 1));        try {            MathUtils.mulAndCheck(big, 2);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {        }        try {            MathUtils.mulAndCheck(bigNeg, 2);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {        }    }    public void testMulAndCheckLong() {        long max = Long.MAX_VALUE;        long min = Long.MIN_VALUE;        assertEquals(max, MathUtils.mulAndCheck(max, 1L));        assertEquals(min, MathUtils.mulAndCheck(min, 1L));        assertEquals(0L, MathUtils.mulAndCheck(max, 0L));        assertEquals(0L, MathUtils.mulAndCheck(min, 0L));        assertEquals(max, MathUtils.mulAndCheck(1L, max));        assertEquals(min, MathUtils.mulAndCheck(1L, min));        assertEquals(0L, MathUtils.mulAndCheck(0L, max));        assertEquals(0L, MathUtils.mulAndCheck(0L, min));        assertEquals(1L, MathUtils.mulAndCheck(-1L, -1L));        assertEquals(min, MathUtils.mulAndCheck(min / 2, 2));        testMulAndCheckLongFailure(max, 2L);        testMulAndCheckLongFailure(2L, max);        testMulAndCheckLongFailure(min, 2L);        testMulAndCheckLongFailure(2L, min);        testMulAndCheckLongFailure(min, -1L);        testMulAndCheckLongFailure(-1L, min);    }    private void testMulAndCheckLongFailure(long a, long b) {        try {            MathUtils.mulAndCheck(a, b);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // success        }    }    public void testNextAfter() {        // 0x402fffffffffffff 0x404123456789abcd -> 4030000000000000        assertEquals(16.0, MathUtils.nextAfter(15.999999999999998, 34.27555555555555), 0.0);        // 0xc02fffffffffffff 0x404123456789abcd -> c02ffffffffffffe        assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 34.27555555555555), 0.0);        // 0x402fffffffffffff 0x400123456789abcd -> 402ffffffffffffe        assertEquals(15.999999999999996, MathUtils.nextAfter(15.999999999999998, 2.142222222222222), 0.0);        // 0xc02fffffffffffff 0x400123456789abcd -> c02ffffffffffffe        assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 2.142222222222222), 0.0);        // 0x4020000000000000 0x404123456789abcd -> 4020000000000001        assertEquals(8.000000000000002, MathUtils.nextAfter(8.0, 34.27555555555555), 0.0);        // 0xc020000000000000 0x404123456789abcd -> c01fffffffffffff        assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 34.27555555555555), 0.0);        // 0x4020000000000000 0x400123456789abcd -> 401fffffffffffff        assertEquals(7.999999999999999, MathUtils.nextAfter(8.0, 2.142222222222222), 0.0);        // 0xc020000000000000 0x400123456789abcd -> c01fffffffffffff        assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 2.142222222222222), 0.0);        // 0x3f2e43753d36a223 0x3f2e43753d36a224 -> 3f2e43753d36a224        assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0);        // 0x3f2e43753d36a223 0x3f2e43753d36a223 -> 3f2e43753d36a224        assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);        // 0x3f2e43753d36a223 0x3f2e43753d36a222 -> 3f2e43753d36a222        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);        // 0x3f2e43753d36a223 0xbf2e43753d36a224 -> 3f2e43753d36a222        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0);        // 0x3f2e43753d36a223 0xbf2e43753d36a223 -> 3f2e43753d36a222        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);        // 0x3f2e43753d36a223 0xbf2e43753d36a222 -> 3f2e43753d36a222        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);        // 0xbf2e43753d36a223 0x3f2e43753d36a224 -> bf2e43753d36a222        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0);        // 0xbf2e43753d36a223 0x3f2e43753d36a223 -> bf2e43753d36a222        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);        // 0xbf2e43753d36a223 0x3f2e43753d36a222 -> bf2e43753d36a222        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);        // 0xbf2e43753d36a223 0xbf2e43753d36a224 -> bf2e43753d36a224        assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0);        // 0xbf2e43753d36a223 0xbf2e43753d36a223 -> bf2e43753d36a224        assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);        // 0xbf2e43753d36a223 0xbf2e43753d36a222 -> bf2e43753d36a222        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);    }    public void testNextAfterSpecialCases() {        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.NEGATIVE_INFINITY, 0)));        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.POSITIVE_INFINITY, 0)));        assertTrue(Double.isNaN(MathUtils.nextAfter(Double.NaN, 0)));        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.MAX_VALUE, Double.POSITIVE_INFINITY)));        assertTrue(Double.isInfinite(MathUtils.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY)));        assertEquals(Double.MIN_VALUE, MathUtils.nextAfter(0, 1), 0);        assertEquals(-Double.MIN_VALUE, MathUtils.nextAfter(0, -1), 0);        assertEquals(0, MathUtils.nextAfter(Double.MIN_VALUE, -1), 0);        assertEquals(0, MathUtils.nextAfter(-Double.MIN_VALUE, 1), 0);    }    public void testScalb() {        assertEquals( 0.0, MathUtils.scalb(0.0, 5), 1.0e-15);        assertEquals(32.0, MathUtils.scalb(1.0, 5), 1.0e-15);        assertEquals(1.0 / 32.0, MathUtils.scalb(1.0,  -5), 1.0e-15);        assertEquals(Math.PI, MathUtils.scalb(Math.PI, 0), 1.0e-15);        assertTrue(Double.isInfinite(MathUtils.scalb(Double.POSITIVE_INFINITY, 1)));        assertTrue(Double.isInfinite(MathUtils.scalb(Double.NEGATIVE_INFINITY, 1)));        assertTrue(Double.isNaN(MathUtils.scalb(Double.NaN, 1)));    }    public void testNormalizeAngle() {        for (double a = -15.0; a <= 15.0; a += 0.1) {            for (double b = -15.0; b <= 15.0; b += 0.2) {                double c = MathUtils.normalizeAngle(a, b);                assertTrue((b - Math.PI) <= c);                assertTrue(c <= (b + Math.PI));                double twoK = Math.rint((a - c) / Math.PI);                assertEquals(c, a - twoK * Math.PI, 1.0e-14);            }        }    }    public void testRoundDouble() {        double x = 1.234567890;        assertEquals(1.23, MathUtils.round(x, 2), 0.0);        assertEquals(1.235, MathUtils.round(x, 3), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4), 0.0);        // JIRA MATH-151        assertEquals(39.25, MathUtils.round(39.245, 2), 0.0);        assertEquals(39.24, MathUtils.round(39.245, 2, BigDecimal.ROUND_DOWN), 0.0);        double xx = 39.0;        xx = xx + 245d / 1000d;        assertEquals(39.25, MathUtils.round(xx, 2), 0.0);        // BZ 35904        assertEquals(30.1d, MathUtils.round(30.095d, 2), 0.0d);        assertEquals(30.1d, MathUtils.round(30.095d, 1), 0.0d);        assertEquals(33.1d, MathUtils.round(33.095d, 1), 0.0d);        assertEquals(33.1d, MathUtils.round(33.095d, 2), 0.0d);        assertEquals(50.09d, MathUtils.round(50.085d, 2), 0.0d);        assertEquals(50.19d, MathUtils.round(50.185d, 2), 0.0d);        assertEquals(50.01d, MathUtils.round(50.005d, 2), 0.0d);        assertEquals(30.01d, MathUtils.round(30.005d, 2), 0.0d);        assertEquals(30.65d, MathUtils.round(30.645d, 2), 0.0d);        assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.236, MathUtils.round(1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.236, MathUtils.round(-1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.235, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.235, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.23, MathUtils.round(-1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);        assertEquals(1.23, MathUtils.round(1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);        try {            MathUtils.round(1.234, 2, BigDecimal.ROUND_UNNECESSARY);            fail();        } catch (ArithmeticException ex) {            // success        }        assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);        try {            MathUtils.round(1.234, 2, 1923);            fail();        } catch (IllegalArgumentException ex) {            // success        }        // MATH-151        assertEquals(39.25, MathUtils.round(39.245, 2, BigDecimal.ROUND_HALF_UP), 0.0);        // special values        TestUtils.assertEquals(Double.NaN, MathUtils.round(Double.NaN, 2), 0.0);        assertEquals(0.0, MathUtils.round(0.0, 2), 0.0);        assertEquals(Double.POSITIVE_INFINITY, MathUtils.round(Double.POSITIVE_INFINITY, 2), 0.0);        assertEquals(Double.NEGATIVE_INFINITY, MathUtils.round(Double.NEGATIVE_INFINITY, 2), 0.0);    }    public void testRoundFloat() {        float x = 1.234567890f;        assertEquals(1.23f, MathUtils.round(x, 2), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4), 0.0);        // BZ 35904        assertEquals(30.1f, MathUtils.round(30.095f, 2), 0.0f);        assertEquals(30.1f, MathUtils.round(30.095f, 1), 0.0f);        assertEquals(50.09f, MathUtils.round(50.085f, 2), 0.0f);        assertEquals(50.19f, MathUtils.round(50.185f, 2), 0.0f);        assertEquals(50.01f, MathUtils.round(50.005f, 2), 0.0f);        assertEquals(30.01f, MathUtils.round(30.005f, 2), 0.0f);        assertEquals(30.65f, MathUtils.round(30.645f, 2), 0.0f);        assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.236f, MathUtils.round(1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.236f, MathUtils.round(-1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.235f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.235f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.23f, MathUtils.round(-1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);        assertEquals(1.23f, MathUtils.round(1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);        try {            MathUtils.round(1.234f, 2, BigDecimal.ROUND_UNNECESSARY);            fail();        } catch (ArithmeticException ex) {            // success        }        assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);        try {            MathUtils.round(1.234f, 2, 1923);            fail();        } catch (IllegalArgumentException ex) {            // success        }        // special values        TestUtils.assertEquals(Float.NaN, MathUtils.round(Float.NaN, 2), 0.0f);        assertEquals(0.0f, MathUtils.round(0.0f, 2), 0.0f);        assertEquals(Float.POSITIVE_INFINITY, MathUtils.round(Float.POSITIVE_INFINITY, 2), 0.0f);        assertEquals(Float.NEGATIVE_INFINITY, MathUtils.round(Float.NEGATIVE_INFINITY, 2), 0.0f);    }    public void testSignByte() {        assertEquals((byte) 1, MathUtils.sign((byte) 2));        assertEquals((byte) 0, MathUtils.sign((byte) 0));        assertEquals((byte) (-1), MathUtils.sign((byte) (-2)));    }    public void testSignDouble() {        double delta = 0.0;        assertEquals(1.0, MathUtils.sign(2.0), delta);        assertEquals(0.0, MathUtils.sign(0.0), delta);        assertEquals(-1.0, MathUtils.sign(-2.0), delta);        TestUtils.assertSame(-0. / 0., MathUtils.sign(Double.NaN));    }    public void testSignFloat() {        float delta = 0.0F;        assertEquals(1.0F, MathUtils.sign(2.0F), delta);        assertEquals(0.0F, MathUtils.sign(0.0F), delta);        assertEquals(-1.0F, MathUtils.sign(-2.0F), delta);        TestUtils.assertSame(Float.NaN, MathUtils.sign(Float.NaN));    }    public void testSignInt() {        assertEquals(1, MathUtils.sign(2));        assertEquals(0, MathUtils.sign(0));        assertEquals((-1), MathUtils.sign((-2)));    }    public void testSignLong() {        assertEquals(1L, MathUtils.sign(2L));        assertEquals(0L, MathUtils.sign(0L));        assertEquals(-1L, MathUtils.sign(-2L));    }    public void testSignShort() {        assertEquals((short) 1, MathUtils.sign((short) 2));        assertEquals((short) 0, MathUtils.sign((short) 0));        assertEquals((short) (-1), MathUtils.sign((short) (-2)));    }    public void testSinh() {        double x = 3.0;        double expected = 10.01787;        assertEquals(expected, MathUtils.sinh(x), 1.0e-5);    }    public void testSinhNaN() {        assertTrue(Double.isNaN(MathUtils.sinh(Double.NaN)));    }    public void testSubAndCheck() {        int big = Integer.MAX_VALUE;        int bigNeg = Integer.MIN_VALUE;        assertEquals(big, MathUtils.subAndCheck(big, 0));        assertEquals(bigNeg + 1, MathUtils.subAndCheck(bigNeg, -1));        assertEquals(-1, MathUtils.subAndCheck(bigNeg, -big));        try {            MathUtils.subAndCheck(big, -1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {        }        try {            MathUtils.subAndCheck(bigNeg, 1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {        }    }    public void testSubAndCheckErrorMessage() {        int big = Integer.MAX_VALUE;        try {            MathUtils.subAndCheck(big, -1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            assertEquals("overflow: subtract", ex.getMessage());        }    }    public void testSubAndCheckLong() {        long max = Long.MAX_VALUE;        long min = Long.MIN_VALUE;        assertEquals(max, MathUtils.subAndCheck(max, 0));        assertEquals(min, MathUtils.subAndCheck(min, 0));        assertEquals(-max, MathUtils.subAndCheck(0, max));        assertEquals(min + 1, MathUtils.subAndCheck(min, -1));        // min == -1-max        assertEquals(-1, MathUtils.subAndCheck(-max - 1, -max));        assertEquals(max, MathUtils.subAndCheck(-1, -1 - max));        testSubAndCheckLongFailure(0L, min);        testSubAndCheckLongFailure(max, -1L);        testSubAndCheckLongFailure(min, 1L);    }    private void testSubAndCheckLongFailure(long a, long b) {        try {            MathUtils.subAndCheck(a, b);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // success        }    }    public void testPow() {        assertEquals(1801088541, MathUtils.pow(21, 7));        assertEquals(1, MathUtils.pow(21, 0));        try {            MathUtils.pow(21, -7);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected behavior        }        assertEquals(1801088541, MathUtils.pow(21, 7l));        assertEquals(1, MathUtils.pow(21, 0l));        try {            MathUtils.pow(21, -7l);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected behavior        }        assertEquals(1801088541l, MathUtils.pow(21l, 7));        assertEquals(1l, MathUtils.pow(21l, 0));        try {            MathUtils.pow(21l, -7);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected behavior        }        assertEquals(1801088541l, MathUtils.pow(21l, 7l));        assertEquals(1l, MathUtils.pow(21l, 0l));        try {            MathUtils.pow(21l, -7l);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected behavior        }        BigInteger twentyOne = BigInteger.valueOf(21l);        assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, 7));        assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, 0));        try {            MathUtils.pow(twentyOne, -7);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected behavior        }        assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, 7l));        assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, 0l));        try {            MathUtils.pow(twentyOne, -7l);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected behavior        }        assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, BigInteger.valueOf(7l)));        assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, BigInteger.ZERO));        try {            MathUtils.pow(twentyOne, BigInteger.valueOf(-7l));            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected behavior        }        BigInteger bigOne =            new BigInteger("1543786922199448028351389769265814882661837148" +                           "4763915343722775611762713982220306372888519211" +                           "560905579993523402015636025177602059044911261");        assertEquals(bigOne, MathUtils.pow(twentyOne, 103));        assertEquals(bigOne, MathUtils.pow(twentyOne, 103l));        assertEquals(bigOne, MathUtils.pow(twentyOne, BigInteger.valueOf(103l)));            }    public void testL1DistanceDouble() {        double[] p1 = { 2.5,  0.0 };        double[] p2 = { -0.5, 4.0 };        assertEquals(7.0, MathUtils.distance1(p1, p2));    }    public void testL1DistanceInt() {        int[] p1 = { 3, 0 };        int[] p2 = { 0, 4 };        assertEquals(7, MathUtils.distance1(p1, p2));    }    public void testL2DistanceDouble() {        double[] p1 = { 2.5,  0.0 };        double[] p2 = { -0.5, 4.0 };        assertEquals(5.0, MathUtils.distance(p1, p2));    }    public void testL2DistanceInt() {        int[] p1 = { 3, 0 };        int[] p2 = { 0, 4 };        assertEquals(5.0, MathUtils.distance(p1, p2));    }    public void testLInfDistanceDouble() {        double[] p1 = { 2.5,  0.0 };        double[] p2 = { -0.5, 4.0 };        assertEquals(4.0, MathUtils.distanceInf(p1, p2));    }    public void testLInfDistanceInt() {        int[] p1 = { 3, 0 };        int[] p2 = { 0, 4 };        assertEquals(4, MathUtils.distanceInf(p1, p2));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import java.math.BigDecimal;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class DefaultTransformerTest extends TestCase {    /**     *      */    public void testTransformDouble() throws Exception {        double expected = 1.0;        Double input = Double.valueOf(expected);        DefaultTransformer t = new DefaultTransformer();        assertEquals(expected, t.transform(input), 1.0e-4);    }        /**     *      */    public void testTransformNull(){        DefaultTransformer t = new DefaultTransformer();        try {            t.transform(null);            fail("Expection MathException");        } catch (MathException e) {            // expected        }    }        /**     *      */    public void testTransformInteger() throws Exception {        double expected = 1.0;        Integer input = Integer.valueOf(1);        DefaultTransformer t = new DefaultTransformer();        assertEquals(expected, t.transform(input), 1.0e-4);    }                /**     *      */    public void testTransformBigDecimal() throws Exception {        double expected = 1.0;        BigDecimal input = new BigDecimal("1.0");        DefaultTransformer t = new DefaultTransformer();        assertEquals(expected, t.transform(input), 1.0e-4);    }                /**     *      */    public void testTransformString() throws Exception {        double expected = 1.0;        String input = "1.0";        DefaultTransformer t = new DefaultTransformer();        assertEquals(expected, t.transform(input), 1.0e-4);    }        /**     *      */    public void testTransformObject(){        Boolean input = Boolean.TRUE;        DefaultTransformer t = new DefaultTransformer();        try {            t.transform(input);            fail("Expecting MathException");        } catch (MathException e) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import java.util.ConcurrentModificationException;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.NoSuchElementException;import java.util.Random;import java.util.Set;import junit.framework.TestCase;/** * Test cases for the {@link OpenIntToDoubleHashMap}. */public class OpenIntToDoubleHashMapTest extends TestCase {    private Map<Integer, Double> javaMap = new HashMap<Integer, Double>();    @Override    protected void setUp() throws Exception {        javaMap.put(50, 100.0);        javaMap.put(75, 75.0);        javaMap.put(25, 500.0);        javaMap.put(Integer.MAX_VALUE, Double.MAX_VALUE);        javaMap.put(0, -1.0);        javaMap.put(1, 0.0);        javaMap.put(33, -0.1);        javaMap.put(23234234, -242343.0);        javaMap.put(23321, Double.MIN_VALUE);        javaMap.put(-4444, 332.0);        javaMap.put(-1, -2323.0);        javaMap.put(Integer.MIN_VALUE, 44.0);        /* Add a few more to cause the table to rehash */        javaMap.putAll(generate());    }    private Map<Integer, Double> generate() {        Map<Integer, Double> map = new HashMap<Integer, Double>();        Random r = new Random();        for (int i = 0; i < 2000; ++i)            map.put(r.nextInt(), r.nextDouble());        return map;    }    private OpenIntToDoubleHashMap createFromJavaMap() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());        }        return map;    }        public void testPutAndGetWith0ExpectedSize() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(0);        assertPutAndGet(map);    }        public void testPutAndGetWithExpectedSize() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(500);        assertPutAndGet(map);    }    public void testPutAndGet() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        assertPutAndGet(map);    }    private void assertPutAndGet(OpenIntToDoubleHashMap map) {        assertPutAndGet(map, 0, new HashSet<Integer>());    }    private void assertPutAndGet(OpenIntToDoubleHashMap map, int mapSize,            Set<Integer> keysInMap) {        assertEquals(mapSize, map.size());        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            if (!keysInMap.contains(mapEntry.getKey()))                ++mapSize;            assertEquals(mapSize, map.size());            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));        }    }    public void testPutAbsentOnExisting() {        OpenIntToDoubleHashMap map = createFromJavaMap();        int size = javaMap.size();        for (Map.Entry<Integer, Double> mapEntry : generateAbsent().entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            assertEquals(++size, map.size());            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));        }    }    public void testPutOnExisting() {        OpenIntToDoubleHashMap map = createFromJavaMap();        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            assertEquals(javaMap.size(), map.size());            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));        }    }    public void testGetAbsent() {        Map<Integer, Double> generated = generateAbsent();        OpenIntToDoubleHashMap map = createFromJavaMap();                for (Map.Entry<Integer, Double> mapEntry : generated.entrySet())            assertTrue(Double.isNaN(map.get(mapEntry.getKey())));    }    public void testGetFromEmpty() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        assertTrue(Double.isNaN(map.get(5)));        assertTrue(Double.isNaN(map.get(0)));        assertTrue(Double.isNaN(map.get(50)));    }    public void testRemove() {        OpenIntToDoubleHashMap map = createFromJavaMap();        int mapSize = javaMap.size();        assertEquals(mapSize, map.size());        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            map.remove(mapEntry.getKey());            assertEquals(--mapSize, map.size());            assertTrue(Double.isNaN(map.get(mapEntry.getKey())));        }        /* Ensure that put and get still work correctly after removals */        assertPutAndGet(map);    }    /* This time only remove some entries */    public void testRemove2() {        OpenIntToDoubleHashMap map = createFromJavaMap();        int mapSize = javaMap.size();        int count = 0;        Set<Integer> keysInMap = new HashSet<Integer>(javaMap.keySet());        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            keysInMap.remove(mapEntry.getKey());            map.remove(mapEntry.getKey());            assertEquals(--mapSize, map.size());            assertTrue(Double.isNaN(map.get(mapEntry.getKey())));            if (count++ > 5)                break;        }        /* Ensure that put and get still work correctly after removals */        assertPutAndGet(map, mapSize, keysInMap);    }    public void testRemoveFromEmpty() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        assertTrue(Double.isNaN(map.remove(50)));    }    public void testRemoveAbsent() {        Map<Integer, Double> generated = generateAbsent();        OpenIntToDoubleHashMap map = createFromJavaMap();        int mapSize = map.size();                for (Map.Entry<Integer, Double> mapEntry : generated.entrySet()) {            map.remove(mapEntry.getKey());            assertEquals(mapSize, map.size());            assertTrue(Double.isNaN(map.get(mapEntry.getKey())));        }    }    /**     * Returns a map with at least 100 elements where each element is absent from javaMap.     */    private Map<Integer, Double> generateAbsent() {        Map<Integer, Double> generated = new HashMap<Integer, Double>();        do {            generated.putAll(generate());            for (Integer key : javaMap.keySet())                generated.remove(key);        } while (generated.size() < 100);        return generated;    }    public void testCopy() {        OpenIntToDoubleHashMap copy =            new OpenIntToDoubleHashMap(createFromJavaMap());        assertEquals(javaMap.size(), copy.size());        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet())            assertEquals(mapEntry.getValue(), copy.get(mapEntry.getKey()));    }    public void testContainsKey() {        OpenIntToDoubleHashMap map = createFromJavaMap();        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            assertTrue(map.containsKey(mapEntry.getKey()));        }        for (Map.Entry<Integer, Double> mapEntry : generateAbsent().entrySet()) {            assertFalse(map.containsKey(mapEntry.getKey()));        }        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            int key = mapEntry.getKey();            assertTrue(map.containsKey(key));            map.remove(key);            assertFalse(map.containsKey(key));        }    }    public void testIterator() {        OpenIntToDoubleHashMap map = createFromJavaMap();        OpenIntToDoubleHashMap.Iterator iterator = map.iterator();        for (int i = 0; i < map.size(); ++i) {            assertTrue(iterator.hasNext());            iterator.advance();            int key = iterator.key();            assertTrue(map.containsKey(key));            assertEquals(javaMap.get(key), map.get(key), 0);            assertEquals(javaMap.get(key), iterator.value(), 0);            assertTrue(javaMap.containsKey(key));        }        assertFalse(iterator.hasNext());        try {            iterator.advance();            fail("an exception should have been thrown");        } catch (NoSuchElementException nsee) {            // expected        }    }    public void testConcurrentModification() {        OpenIntToDoubleHashMap map = createFromJavaMap();        OpenIntToDoubleHashMap.Iterator iterator = map.iterator();        map.put(3, 3);        try {            iterator.advance();            fail("an exception should have been thrown");        } catch (ConcurrentModificationException cme) {            // expected        }    }    /**     * Regression test for a bug in findInsertionIndex where the hashing in the second probing     * loop was inconsistent with the first causing duplicate keys after the right sequence     * of puts and removes.     */    public void testPutKeysWithCollisions() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        int key1 = -1996012590;        double value1 = 1.0;        map.put(key1, value1);        int key2 = 835099822;        map.put(key2, value1);        int key3 = 1008859686;        map.put(key3, value1);        assertEquals(value1, map.get(key3));        assertEquals(3, map.size());                map.remove(key2);        double value2 = 2.0;        map.put(key3, value2);        assertEquals(value2, map.get(key3));        assertEquals(2, map.size());    }        /**     * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly     * different manner.     */    public void testPutKeysWithCollision2() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        int key1 = 837989881;        double value1 = 1.0;        map.put(key1, value1);        int key2 = 476463321;        map.put(key2, value1);        assertEquals(2, map.size());        assertEquals(value1, map.get(key2));                map.remove(key1);        double value2 = 2.0;        map.put(key2, value2);        assertEquals(1, map.size());        assertEquals(value2, map.get(key2));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class TransformerMapTest extends TestCase {    /**     *      */    public void testPutTransformer(){        NumberTransformer expected = new DefaultTransformer();                TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertEquals(expected, map.getTransformer(TransformerMapTest.class));    }        /**     *      */    public void testContainsClass(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.containsClass(TransformerMapTest.class));    }        /**     *      */    public void testContainsTransformer(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.containsTransformer(expected));    }    /**     *      */    public void testRemoveTransformer(){        NumberTransformer expected = new DefaultTransformer();                TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.containsClass(TransformerMapTest.class));        assertTrue(map.containsTransformer(expected));        map.removeTransformer(TransformerMapTest.class);        assertFalse(map.containsClass(TransformerMapTest.class));        assertFalse(map.containsTransformer(expected));    }    /**     *      */    public void testClear(){        NumberTransformer expected = new DefaultTransformer();                TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.containsClass(TransformerMapTest.class));        map.clear();        assertFalse(map.containsClass(TransformerMapTest.class));    }        /**     *      */    public void testClasses(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.classes().contains(TransformerMapTest.class));    }        /**     *      */    public void testTransformers(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.transformers().contains(expected));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.MathRuntimeException;/** * @version $Revision$ $Date$ */public class TestBean {    private Double x = Double.valueOf(1.0);    private String y = "1.0";    /**     *      */    public Double getX() {        return x;    }    /**     *      */    public String getY() {        return y;    }    /**     *      */    public void setX(Double double1) {        x = double1;    }    /**     *      */    public void setY(String string) {        y = string;    }        /**     *      */    public Double getZ() {        throw new MathRuntimeException("?");    }    /**     *      */    public void setZ(Double double1) {    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.transform;import junit.framework.TestCase;/** * JUnit Test for HadamardTransformerTest * @see org.apache.commons.math.transform.FastHadamardTransformer */public final class FastHadamardTransformerTest extends TestCase {    /**     * Test of transformer for the a 8-point FHT (means n=8)     */    public void test8Points() {        checkAllTransforms(new int[] { 1, 4, -2, 3, 0, 1, 4, -1 },                       new int[] { 10, -4, 2, -4, 2, -12, 6, 8 });    }    /**     * Test of transformer for the a 4-points FHT (means n=4)     */    public void test4Points() {        checkAllTransforms(new int[] { 1, 2, 3, 4 },                           new int[] { 10, -2, -4, 0 });    }    /**     * Test the inverse transform of an integer vector is not always an integer vector     */    public void testNoIntInverse() {        FastHadamardTransformer transformer = new FastHadamardTransformer();        double[] x = transformer.inversetransform(new double[] { 0, 1, 0, 1});        assertEquals( 0.5, x[0], 0);        assertEquals(-0.5, x[1], 0);        assertEquals( 0.0, x[2], 0);        assertEquals( 0.0, x[3], 0);    }    /**     * Test of transformer for wrong number of points     */    public void test3Points() {        try {            new FastHadamardTransformer().transform(new double[3]);            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected        }    }    private void checkAllTransforms(int[]x, int[] y) {        checkDoubleTransform(x, y);        checkInverseDoubleTransform(x, y);        checkIntTransform(x, y);    }    private void checkDoubleTransform(int[]x, int[] y) {        // Initiate the transformer        FastHadamardTransformer transformer = new FastHadamardTransformer();        // check double transform        double[] dX = new double[x.length];        for (int i = 0; i < dX.length; ++i) {            dX[i] = x[i];        }        double dResult[] = transformer.transform(dX);        for (int i = 0; i < dResult.length; i++) {            // compare computed results to precomputed results            assertEquals((double) y[i], dResult[i]);        }    }    private void checkIntTransform(int[]x, int[] y) {        // Initiate the transformer        FastHadamardTransformer transformer = new FastHadamardTransformer();        // check integer transform        int iResult[] = transformer.transform(x);        for (int i = 0; i < iResult.length; i++) {            // compare computed results to precomputed results            assertEquals(y[i], iResult[i]);        }    }        private void checkInverseDoubleTransform(int[]x, int[] y) {        // Initiate the transformer        FastHadamardTransformer transformer = new FastHadamardTransformer();        // check double transform        double[] dY = new double[y.length];        for (int i = 0; i < dY.length; ++i) {            dY[i] = y[i];        }        double dResult[] = transformer.inversetransform(dY);        for (int i = 0; i < dResult.length; i++) {            // compare computed results to precomputed results            assertEquals((double) x[i], dResult[i]);        }    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.transform;import org.apache.commons.math.analysis.*;import org.apache.commons.math.complex.*;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for fast Fourier transformer. * <p> * FFT algorithm is exact, the small tolerance number is used only * to account for round-off errors. *  * @version $Revision$ $Date$  */public final class FastFourierTransformerTest extends TestCase {    /**     * Test of transformer for the ad hoc data taken from Mathematica.     */    public void testAdHocData() {        FastFourierTransformer transformer = new FastFourierTransformer();        Complex result[]; double tolerance = 1E-12;        double x[] = {1.3, 2.4, 1.7, 4.1, 2.9, 1.7, 5.1, 2.7};        Complex y[] = {            new Complex(21.9, 0.0),            new Complex(-2.09497474683058, 1.91507575950825),            new Complex(-2.6, 2.7),            new Complex(-1.10502525316942, -4.88492424049175),            new Complex(0.1, 0.0),            new Complex(-1.10502525316942, 4.88492424049175),            new Complex(-2.6, -2.7),            new Complex(-2.09497474683058, -1.91507575950825)};        result = transformer.transform(x);        for (int i = 0; i < result.length; i++) {            assertEquals(y[i].getReal(), result[i].getReal(), tolerance);            assertEquals(y[i].getImaginary(), result[i].getImaginary(), tolerance);        }        result = transformer.inversetransform(y);        for (int i = 0; i < result.length; i++) {            assertEquals(x[i], result[i].getReal(), tolerance);            assertEquals(0.0, result[i].getImaginary(), tolerance);        }        double x2[] = {10.4, 21.6, 40.8, 13.6, 23.2, 32.8, 13.6, 19.2};        FastFourierTransformer.scaleArray(x2, 1.0 / Math.sqrt(x2.length));        Complex y2[] = y;        result = transformer.transform2(y2);        for (int i = 0; i < result.length; i++) {            assertEquals(x2[i], result[i].getReal(), tolerance);            assertEquals(0.0, result[i].getImaginary(), tolerance);        }        result = transformer.inversetransform2(x2);        for (int i = 0; i < result.length; i++) {            assertEquals(y2[i].getReal(), result[i].getReal(), tolerance);            assertEquals(y2[i].getImaginary(), result[i].getImaginary(), tolerance);        }    }        public void test2DData() {        FastFourierTransformer transformer = new FastFourierTransformer();        double tolerance = 1E-12;        Complex[][] input = new Complex[][] {new Complex[] {new Complex(1, 0),                                                            new Complex(2, 0)},                                             new Complex[] {new Complex(3, 1),                                                            new Complex(4, 2)}};        Complex[][] goodOutput = new Complex[][] {new Complex[] {new Complex(5,                1.5), new Complex(-1, -.5)}, new Complex[] {new Complex(-2,                -1.5), new Complex(0, .5)}};        Complex[][] output = (Complex[][])transformer.mdfft(input, true);        Complex[][] output2 = (Complex[][])transformer.mdfft(output, false);                assertEquals(input.length, output.length);        assertEquals(input.length, output2.length);        assertEquals(input[0].length, output[0].length);        assertEquals(input[0].length, output2[0].length);        assertEquals(input[1].length, output[1].length);        assertEquals(input[1].length, output2[1].length);                for (int i = 0; i < input.length; i++) {            for (int j = 0; j < input[0].length; j++) {                assertEquals(input[i][j].getImaginary(), output2[i][j].getImaginary(),                             tolerance);                assertEquals(input[i][j].getReal(), output2[i][j].getReal(), tolerance);                assertEquals(goodOutput[i][j].getImaginary(), output[i][j].getImaginary(),                             tolerance);                assertEquals(goodOutput[i][j].getReal(), output[i][j].getReal(), tolerance);            }        }    }        /**     * Test of transformer for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        FastFourierTransformer transformer = new FastFourierTransformer();        Complex result[]; int N = 1 << 8;        double min, max, tolerance = 1E-12;        min = 0.0; max = 2.0 * Math.PI;        result = transformer.transform(f, min, max, N);        assertEquals(0.0, result[1].getReal(), tolerance);        assertEquals(-(N >> 1), result[1].getImaginary(), tolerance);        assertEquals(0.0, result[N-1].getReal(), tolerance);        assertEquals(N >> 1, result[N-1].getImaginary(), tolerance);        for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {            assertEquals(0.0, result[i].getReal(), tolerance);            assertEquals(0.0, result[i].getImaginary(), tolerance);        }        min = -Math.PI; max = Math.PI;        result = transformer.inversetransform(f, min, max, N);        assertEquals(0.0, result[1].getReal(), tolerance);        assertEquals(-0.5, result[1].getImaginary(), tolerance);        assertEquals(0.0, result[N-1].getReal(), tolerance);        assertEquals(0.5, result[N-1].getImaginary(), tolerance);        for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {            assertEquals(0.0, result[i].getReal(), tolerance);            assertEquals(0.0, result[i].getImaginary(), tolerance);        }    }    /**     * Test of parameters for the transformer.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        FastFourierTransformer transformer = new FastFourierTransformer();        try {            // bad interval            transformer.transform(f, 1, -1, 64);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 0);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 100);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.transform;import org.apache.commons.math.analysis.*;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for fast cosine transformer. * <p> * FCT algorithm is exact, the small tolerance number is used only * to account for round-off errors. *  * @version $Revision$ $Date$  */public final class FastCosineTransformerTest extends TestCase {    /**     * Test of transformer for the ad hoc data.     */    public void testAdHocData() {        FastCosineTransformer transformer = new FastCosineTransformer();        double result[], tolerance = 1E-12;        double x[] = { 0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0 };        double y[] = { 172.0, -105.096569476353, 27.3137084989848,                      -12.9593152353742, 8.0, -5.78585076868676,                       4.68629150101524, -4.15826451958632, 4.0 };        result = transformer.transform(x);        for (int i = 0; i < result.length; i++) {            assertEquals(y[i], result[i], tolerance);        }        result = transformer.inversetransform(y);        for (int i = 0; i < result.length; i++) {            assertEquals(x[i], result[i], tolerance);        }        FastFourierTransformer.scaleArray(x, Math.sqrt(0.5 * (x.length-1)));        result = transformer.transform2(y);        for (int i = 0; i < result.length; i++) {            assertEquals(x[i], result[i], tolerance);        }        result = transformer.inversetransform2(x);        for (int i = 0; i < result.length; i++) {            assertEquals(y[i], result[i], tolerance);        }    }    /**     * Test of transformer for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        FastCosineTransformer transformer = new FastCosineTransformer();        double min, max, result[], tolerance = 1E-12; int N = 9;        double expected[] = { 0.0, 3.26197262739567, 0.0,                             -2.17958042710327, 0.0, -0.648846697642915,                              0.0, -0.433545502649478, 0.0 };        min = 0.0; max = 2.0 * Math.PI * N / (N-1);        result = transformer.transform(f, min, max, N);        for (int i = 0; i < N; i++) {            assertEquals(expected[i], result[i], tolerance);        }        min = -Math.PI; max = Math.PI * (N+1) / (N-1);        result = transformer.transform(f, min, max, N);        for (int i = 0; i < N; i++) {            assertEquals(-expected[i], result[i], tolerance);        }    }    /**     * Test of parameters for the transformer.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        FastCosineTransformer transformer = new FastCosineTransformer();        try {            // bad interval            transformer.transform(f, 1, -1, 65);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 1);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 64);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.transform;import org.apache.commons.math.analysis.*;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for fast sine transformer. * <p> * FST algorithm is exact, the small tolerance number is used only * to account for round-off errors. *  * @version $Revision$ $Date$  */public final class FastSineTransformerTest extends TestCase {    /**     * Test of transformer for the ad hoc data.     */    public void testAdHocData() {        FastSineTransformer transformer = new FastSineTransformer();        double result[], tolerance = 1E-12;        double x[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 };        double y[] = { 0.0, 20.1093579685034, -9.65685424949238,                       5.98642305066196, -4.0, 2.67271455167720,                      -1.65685424949238, 0.795649469518633 };        result = transformer.transform(x);        for (int i = 0; i < result.length; i++) {            assertEquals(y[i], result[i], tolerance);        }        result = transformer.inversetransform(y);        for (int i = 0; i < result.length; i++) {            assertEquals(x[i], result[i], tolerance);        }        FastFourierTransformer.scaleArray(x, Math.sqrt(x.length / 2.0));        result = transformer.transform2(y);        for (int i = 0; i < result.length; i++) {            assertEquals(x[i], result[i], tolerance);        }        result = transformer.inversetransform2(x);        for (int i = 0; i < result.length; i++) {            assertEquals(y[i], result[i], tolerance);        }    }    /**     * Test of transformer for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        FastSineTransformer transformer = new FastSineTransformer();        double min, max, result[], tolerance = 1E-12; int N = 1 << 8;        min = 0.0; max = 2.0 * Math.PI;        result = transformer.transform(f, min, max, N);        assertEquals(N >> 1, result[2], tolerance);        for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {            assertEquals(0.0, result[i], tolerance);        }        min = -Math.PI; max = Math.PI;        result = transformer.transform(f, min, max, N);        assertEquals(-(N >> 1), result[2], tolerance);        for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {            assertEquals(0.0, result[i], tolerance);        }    }    /**     * Test of parameters for the transformer.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        FastSineTransformer transformer = new FastSineTransformer();        try {            // bad interval            transformer.transform(f, 1, -1, 64);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 0);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 100);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.special;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class BetaTest extends TestCase {    /**     * Constructor for BetaTest.     * @param name     */    public BetaTest(String name) {        super(name);    }    private void testRegularizedBeta(double expected, double x, double a,        double b)    {        try {            double actual = Beta.regularizedBeta(x, a, b);            TestUtils.assertEquals(expected, actual, 10e-15);        } catch(MathException ex){            fail(ex.getMessage());        }    }    private void testLogBeta(double expected, double a, double b) {        double actual = Beta.logBeta(a, b);        TestUtils.assertEquals(expected, actual, 10e-15);    }    public void testRegularizedBetaNanPositivePositive() {        testRegularizedBeta(Double.NaN, Double.NaN, 1.0, 1.0);    }    public void testRegularizedBetaPositiveNanPositive() {        testRegularizedBeta(Double.NaN, 0.5, Double.NaN, 1.0);    }    public void testRegularizedBetaPositivePositiveNan() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, Double.NaN);    }        public void testRegularizedBetaNegativePositivePositive() {        testRegularizedBeta(Double.NaN, -0.5, 1.0, 2.0);    }        public void testRegularizedBetaPositiveNegativePositive() {        testRegularizedBeta(Double.NaN, 0.5, -1.0, 2.0);    }        public void testRegularizedBetaPositivePositiveNegative() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, -2.0);    }        public void testRegularizedBetaZeroPositivePositive() {        testRegularizedBeta(0.0, 0.0, 1.0, 2.0);    }        public void testRegularizedBetaPositiveZeroPositive() {        testRegularizedBeta(Double.NaN, 0.5, 0.0, 2.0);    }        public void testRegularizedBetaPositivePositiveZero() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, 0.0);    }        public void testRegularizedBetaPositivePositivePositive() {        testRegularizedBeta(0.75, 0.5, 1.0, 2.0);    }        public void testLogBetaNanPositive() {        testLogBeta(Double.NaN, Double.NaN, 2.0);    }        public void testLogBetaPositiveNan() {        testLogBeta(Double.NaN, 1.0, Double.NaN);    }        public void testLogBetaNegativePositive() {        testLogBeta(Double.NaN, -1.0, 2.0);    }        public void testLogBetaPositiveNegative() {        testLogBeta(Double.NaN, 1.0, -2.0);    }        public void testLogBetaZeroPositive() {        testLogBeta(Double.NaN, 0.0, 2.0);    }        public void testLogBetaPositiveZero() {        testLogBeta(Double.NaN, 1.0, 0.0);    }        public void testLogBetaPositivePositive() {        testLogBeta(-0.693147180559945, 1.0, 2.0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.special;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class GammaTest extends TestCase {         public GammaTest(String name) {        super(name);    }    private void testRegularizedGamma(double expected, double a, double x) {        try {            double actualP = Gamma.regularizedGammaP(a, x);            double actualQ = Gamma.regularizedGammaQ(a, x);            TestUtils.assertEquals(expected, actualP, 10e-15);            TestUtils.assertEquals(actualP, 1.0 - actualQ, 10e-15);        } catch(MathException ex){            fail(ex.getMessage());        }    }    private void testLogGamma(double expected, double x) {        double actual = Gamma.logGamma(x);        TestUtils.assertEquals(expected, actual, 10e-15);    }    public void testRegularizedGammaNanPositive() {        testRegularizedGamma(Double.NaN, Double.NaN, 1.0);    }    public void testRegularizedGammaPositiveNan() {        testRegularizedGamma(Double.NaN, 1.0, Double.NaN);    }        public void testRegularizedGammaNegativePositive() {        testRegularizedGamma(Double.NaN, -1.5, 1.0);    }        public void testRegularizedGammaPositiveNegative() {        testRegularizedGamma(Double.NaN, 1.0, -1.0);    }        public void testRegularizedGammaZeroPositive() {        testRegularizedGamma(Double.NaN, 0.0, 1.0);    }        public void testRegularizedGammaPositiveZero() {        testRegularizedGamma(0.0, 1.0, 0.0);    }        public void testRegularizedGammaPositivePositive() {        testRegularizedGamma(0.632120558828558, 1.0, 1.0);    }        public void testLogGammaNan() {        testLogGamma(Double.NaN, Double.NaN);    }        public void testLogGammaNegative() {        testLogGamma(Double.NaN, -1.0);    }        public void testLogGammaZero() {        testLogGamma(Double.NaN, 0.0);    }        public void testLogGammaPositive() {        testLogGamma(0.6931471805599457, 3.0);    }    public void testDigammaLargeArgs() {        double eps = 1e-8;        assertEquals(4.6001618527380874002, Gamma.digamma(100), eps);        assertEquals(3.9019896734278921970, Gamma.digamma(50), eps);        assertEquals(2.9705239922421490509, Gamma.digamma(20), eps);        assertEquals(2.9958363947076465821, Gamma.digamma(20.5), eps);        assertEquals(2.2622143570941481605, Gamma.digamma(10.1), eps);        assertEquals(2.1168588189004379233, Gamma.digamma(8.8), eps);        assertEquals(1.8727843350984671394, Gamma.digamma(7), eps);        assertEquals(0.42278433509846713939, Gamma.digamma(2), eps);        assertEquals(-100.56088545786867450, Gamma.digamma(0.01), eps);        assertEquals(-4.0390398965921882955, Gamma.digamma(-0.8), eps);        assertEquals(4.2003210041401844726, Gamma.digamma(-6.3), eps);    }    public void testDigammaSmallArgs() {        // values for negative powers of 10 from 1 to 30 as computed by webMathematica with 20 digits        // see functions.wolfram.com        double[] expected = {-10.423754940411076795, -100.56088545786867450, -1000.5755719318103005,                -10000.577051183514335, -100000.57719921568107, -1.0000005772140199687e6, -1.0000000577215500408e7,                -1.0000000057721564845e8, -1.0000000005772156633e9, -1.0000000000577215665e10, -1.0000000000057721566e11,                -1.0000000000005772157e12, -1.0000000000000577216e13, -1.0000000000000057722e14, -1.0000000000000005772e15, -1e+16,                -1e+17, -1e+18, -1e+19, -1e+20, -1e+21, -1e+22, -1e+23, -1e+24, -1e+25, -1e+26,                -1e+27, -1e+28, -1e+29, -1e+30};        for (double n = 1; n < 30; n++) {            checkRelativeError(String.format("Test %.0f: ", n), expected[(int) (n - 1)], Gamma.digamma(Math.pow(10.0, -n)), 1e-8);        }    }    public void testTrigamma() {        double eps = 1e-8;        // computed using webMathematica.  For example, to compute trigamma($i) = Polygamma(1, $i), use        //        // http://functions.wolfram.com/webMathematica/Evaluated.jsp?name=PolyGamma2&plottype=0&vars={%221%22,%22$i%22}&digits=20        double[] data = {                1e-4, 1.0000000164469368793e8,                1e-3, 1.0000016425331958690e6,                1e-2, 10001.621213528313220,                1e-1, 101.43329915079275882,                1, 1.6449340668482264365,                2, 0.64493406684822643647,                3, 0.39493406684822643647,                4, 0.28382295573711532536,                5, 0.22132295573711532536,                10, 0.10516633568168574612,                20, 0.051270822935203119832,                50, 0.020201333226697125806,                100, 0.010050166663333571395        };        for (int i = data.length - 2; i >= 0; i -= 2) {            assertEquals(String.format("trigamma %.0f", data[i]), data[i + 1], Gamma.trigamma(data[i]), eps);        }    }    private void checkRelativeError(String msg, double expected, double actual, double tolerance) {        assertEquals(msg, expected, actual, Math.abs(tolerance * actual));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.apache.commons.math.special;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class ErfTest extends TestCase {    public void testErf0() throws MathException {        double actual = Erf.erf(0.0);        double expected = 0.0;        assertEquals(expected, actual, 1.0e-5);    }    public void testErf1960() throws MathException {        double x = 1.960 / Math.sqrt(2.0);        double actual = Erf.erf(x);        double expected = 0.95;        assertEquals(expected, actual, 1.0e-5);        actual = Erf.erf(-x);        expected = -expected;        assertEquals(expected, actual, 1.0e-5);    }    public void testErf2576() throws MathException {        double x = 2.576 / Math.sqrt(2.0);        double actual = Erf.erf(x);        double expected = 0.99;        assertEquals(expected, actual, 1.0e-5);            actual = Erf.erf(-x);        expected = -expected;        assertEquals(expected, actual, 1.0e-5);    }    public void testErf2807() throws MathException {        double x = 2.807 / Math.sqrt(2.0);        double actual = Erf.erf(x);        double expected = 0.995;        assertEquals(expected, actual, 1.0e-5);                actual = Erf.erf(-x);        expected = -expected;        assertEquals(expected, actual, 1.0e-5);    }    public void testErf3291() throws MathException {        double x = 3.291 / Math.sqrt(2.0);        double actual = Erf.erf(x);        double expected = 0.999;        assertEquals(expected, actual, 1.0e-5);                actual = Erf.erf(-x);        expected = -expected;        assertEquals(expected, actual, 1.0e-5);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import org.junit.Test;public class RandomKeyMutationTest {    @Test    public void testMutate() {        MutationPolicy mutation = new RandomKeyMutation();        int l=10;        for (int i=0; i<20; i++) {            DummyRandomKey origRk = new DummyRandomKey(RandomKey.randomPermutation(l));            Chromosome mutated = mutation.mutate(origRk);            DummyRandomKey mutatedRk = (DummyRandomKey) mutated;                        int changes = 0;            for (int j=0; j<origRk.getLength(); j++) {                if (origRk.getRepresentation().get(j) != mutatedRk.getRepresentation().get(j)) {                    changes++;                }            }            assertEquals(1,changes);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import java.util.Arrays;import java.util.Comparator;import java.util.List;import org.junit.Test;public class RandomKeyTest {    @Test(expected=IllegalArgumentException.class)    public void testConstructor1() {        @SuppressWarnings("unused")        DummyRandomKey drk = new DummyRandomKey(new Double[] {0.2, 0.3, 1.2});    }        @Test(expected=IllegalArgumentException.class)    public void testConstructor2() {        @SuppressWarnings("unused")        DummyRandomKey drk = new DummyRandomKey(new Double[] {0.2, 0.3, -0.2});    }    @Test    public void testIsSame() {        DummyRandomKey drk1 = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});        DummyRandomKey drk2 = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});        DummyRandomKey drk3 = new DummyRandomKey(new Double[] {0.4, 0.15, 0.5, 0.8, 0.2});        DummyRandomKey drk4 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2});        DummyRandomKey drk5 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2, 0.5});                assertTrue(drk1.isSame(drk2));        assertTrue(drk2.isSame(drk3));        assertFalse(drk3.isSame(drk4));        assertFalse(drk4.isSame(drk5));    }    @Test    public void testDecode() {        DummyRandomKey drk = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});        List<String> decoded = drk.decode(Arrays.asList(new String[] {"a", "b", "c", "d", "e"}));                assertEquals("b", decoded.get(0));        assertEquals("e", decoded.get(1));        assertEquals("a", decoded.get(2));        assertEquals("c", decoded.get(3));        assertEquals("d", decoded.get(4));    }    @Test    public void testRandomPermutation() {        // never generate an invalid one        for (int i=0; i<10; i++) {            @SuppressWarnings("unused")            DummyRandomKey drk = new DummyRandomKey(RandomKey.randomPermutation(20));        }    }    @Test    public void testIdentityPermutation() {        DummyRandomKey drk = new DummyRandomKey(RandomKey.identityPermutation(5));        List<String> decoded = drk.decode(Arrays.asList(new String[] {"a", "b", "c", "d", "e"}));                assertEquals("a", decoded.get(0));        assertEquals("b", decoded.get(1));        assertEquals("c", decoded.get(2));        assertEquals("d", decoded.get(3));        assertEquals("e", decoded.get(4));    }    @Test    public void testComparatorPermutation() {        List<String> data = Arrays.asList(new String[] {"x", "b", "c", "z", "b"});                List<Double> permutation = RandomKey.comparatorPermutation(data, new Comparator<String>() {            public int compare(String o1, String o2) {                return o1.compareTo(o2);            }        });        Double[] permArr = new Double[data.size()];        permArr = permutation.toArray(permArr);        assertArrayEquals(new Double[] {0.6,0.0,0.4,0.8,0.2}, permArr);        List<String> decodedData = new DummyRandomKey(permutation).decode(data);        assertEquals("b", decodedData.get(0));        assertEquals("b", decodedData.get(1));        assertEquals("c", decodedData.get(2));        assertEquals("x", decodedData.get(3));        assertEquals("z", decodedData.get(4));                permutation = RandomKey.comparatorPermutation(data, new Comparator<String>() {            public int compare(String o1, String o2) {                return o2.compareTo(o1);            }        });        permArr = new Double[data.size()];        permArr = permutation.toArray(permArr);        assertArrayEquals(new Double[] {0.2,0.6,0.4,0.0,0.8}, permArr);        decodedData = new DummyRandomKey(permutation).decode(data);        assertEquals("z", decodedData.get(0));        assertEquals("x", decodedData.get(1));        assertEquals("c", decodedData.get(2));        assertEquals("b", decodedData.get(3));        assertEquals("b", decodedData.get(4));    }        @Test    public void testInducedPermutation() {        List<String> origData = Arrays.asList(new String[] {"a", "b", "c", "d", "d"});        List<String> permutedData = Arrays.asList(new String[] {"d", "b", "c", "a", "d"});                DummyRandomKey drk = new DummyRandomKey(RandomKey.inducedPermutation(origData, permutedData));        List<String> decoded = drk.decode(origData);                assertEquals("d", decoded.get(0));        assertEquals("b", decoded.get(1));        assertEquals("c", decoded.get(2));        assertEquals("a", decoded.get(3));        assertEquals("d", decoded.get(4));        try {            RandomKey.inducedPermutation(                    Arrays.asList(new String[] {"a", "b", "c", "d", "d"}),                    Arrays.asList(new String[] {"a", "b", "c", "d"})            );            fail("Uncaught exception");        } catch (IllegalArgumentException e) {            // no-op        }        try {            RandomKey.inducedPermutation(                    Arrays.asList(new String[] {"a", "b", "c", "d", "d"}),                    Arrays.asList(new String[] {"a", "b", "c", "d", "f"})            );            fail("Uncaught exception");        } catch (IllegalArgumentException e) {            // no-op        }    }    @Test    public void testEqualRepr() {        DummyRandomKey drk = new DummyRandomKey(new Double[] {0.2, 0.2, 0.5});        List<String> decodedData = drk.decode(Arrays.asList(new String[] {"a", "b", "c"}));        assertEquals("a", decodedData.get(0));        assertEquals("b", decodedData.get(1));        assertEquals("c", decodedData.get(2));    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import org.junit.Test;public class TournamentSelectionTest {        private static int counter = 0;    @Test    public void testSelect() {        TournamentSelection ts = new TournamentSelection(2);        ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203);                for (int i=0; i<pop.getPopulationLimit(); i++) {            pop.addChromosome(new DummyChromosome());        }        // how to write a test for stochastic method?        for (int i=0; i<20; i++) {            ChromosomePair pair = ts.select(pop);            // the worst chromosome should NEVER be selected            assertTrue(pair.getFirst().getFitness() > 0);            assertTrue(pair.getSecond().getFitness() > 0);        }    }        private static class DummyChromosome extends Chromosome {        private final int fitness;                public DummyChromosome() {            this.fitness = counter;            counter++;        }                public double fitness() {                        return this.fitness;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import java.util.Iterator;import org.junit.Test;public class FixedGenerationCountTest {    @Test    public void testIsSatisfied() {        FixedGenerationCount fgc = new FixedGenerationCount(20);                int cnt = 0;        Population pop = new Population() {            public void addChromosome(Chromosome chromosome) {                // unimportant            }            public Chromosome getFittestChromosome() {                // unimportant                return null;            }            public int getPopulationLimit() {                // unimportant                return 0;            }            public int getPopulationSize() {                // unimportant                return 0;            }            public Population nextGeneration() {                // unimportant                return null;            }            public Iterator<Chromosome> iterator() {                // unimportant                return null;            }        };                while (!fgc.isSatisfied(pop))            cnt++;        assertEquals(20, cnt);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import java.util.ArrayList;import java.util.List;import org.junit.Test;public class ChromosomeTest {    @Test    public void testCompareTo() {        Chromosome c1 = new Chromosome() {            public double fitness() {                                return 0;            }        };        Chromosome c2 = new Chromosome() {            public double fitness() {                                return 10;            }        };        Chromosome c3 = new Chromosome() {            public double fitness() {                                return 10;            }        };                assertTrue(c1.compareTo(c2) < 0);        assertTrue(c2.compareTo(c1) > 0);        assertEquals(0,c3.compareTo(c2));        assertEquals(0,c2.compareTo(c3));    }        private abstract static class DummyChromosome extends Chromosome {        private final int repr;        public DummyChromosome(final int repr) {            this.repr = repr;        }        @Override        protected boolean isSame(Chromosome another) {            return ((DummyChromosome) another).repr == repr;        }    }        @Test    public void testFindSameChromosome() {        Chromosome c1 = new DummyChromosome(1) {            public double fitness() {                return 1;            }        };        Chromosome c2 = new DummyChromosome(2) {            public double fitness() {                return 2;            }        };        Chromosome c3 = new DummyChromosome(3) {            public double fitness() {                return 3;            }        };        Chromosome c4 = new DummyChromosome(1) {            public double fitness() {                return 5;            }        };        Chromosome c5 = new DummyChromosome(15) {            public double fitness() {                return 15;            }        };                List<Chromosome> popChr = new ArrayList<Chromosome>();        popChr.add(c1);        popChr.add(c2);        popChr.add(c3);        Population pop = new ListPopulation(popChr,3) {            public Population nextGeneration() {                // not important                return null;            }        };                assertNull(c5.findSameChromosome(pop));        assertEquals(c1, c4.findSameChromosome(pop));                c4.searchForFitnessUpdate(pop);        assertEquals(1, c4.getFitness(),0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import org.junit.Test;public class OnePointCrossoverTest {    @Test    public void testCrossover() {        Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};        Integer[] p2 = new Integer[] {0,1,1,0,1,0,1,1,1};                BinaryChromosome p1c = new DummyBinaryChromosome(p1);        BinaryChromosome p2c = new DummyBinaryChromosome(p2);                OnePointCrossover<Integer> opc = new OnePointCrossover<Integer>();                // how to test a stochastic method?        for (int i=0; i<20; i++) {            ChromosomePair pair = opc.crossover(p1c,p2c);                        Integer[] c1 = new Integer[p1.length];            Integer[] c2 = new Integer[p2.length];                        c1 = ((BinaryChromosome) pair.getFirst()).getRepresentation().toArray(c1);            c2 = ((BinaryChromosome) pair.getSecond()).getRepresentation().toArray(c2);                        // first and last values will be the same            assertEquals((int) p1[0], (int) c1[0]);            assertEquals((int) p2[0], (int) c2[0]);            assertEquals((int) p1[p1.length-1], (int) c1[c1.length-1]);            assertEquals((int) p2[p2.length-1], (int) c2[c2.length-1]);            // moreover, in the above setting, the 2nd, 3rd and 7th values will be the same            assertEquals((int) p1[2], (int) c1[2]);            assertEquals((int) p2[2], (int) c2[2]);            assertEquals((int) p1[3], (int) c1[3]);            assertEquals((int) p2[3], (int) c2[3]);            assertEquals((int) p1[7], (int) c1[7]);            assertEquals((int) p2[7], (int) c2[7]);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import java.util.LinkedList;import java.util.List;import org.junit.Test;public class FitnessCachingTest {        // parameters for the GA    private static final int DIMENSION = 50;     private static final double CROSSOVER_RATE = 1;    private static final double MUTATION_RATE = 0.1;    private static final int TOURNAMENT_ARITY = 5;        private static final int POPULATION_SIZE = 10;    private static final int NUM_GENERATIONS = 50;    private static final double ELITISM_RATE = 0.2;    // how many times was the fitness computed    public static int fitnessCalls = 0;    @Test    public void testFitnessCaching() {        // initialize a new genetic algorithm        GeneticAlgorithm ga = new GeneticAlgorithm(                new OnePointCrossover<Integer>(),                CROSSOVER_RATE, // all selected chromosomes will be recombined (=crosssover)                new BinaryMutation(),                MUTATION_RATE, // no mutation                new TournamentSelection(TOURNAMENT_ARITY)        );                // initial population        Population initial = randomPopulation();        // stopping conditions        StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);                // run the algorithm        ga.evolve(initial, stopCond);                int neededCalls =            POPULATION_SIZE /*initial population*/ +            (NUM_GENERATIONS - 1) /*for each population*/ * (int)(POPULATION_SIZE * (1.0 - ELITISM_RATE)) /*some chromosomes are copied*/            ;        assertTrue(fitnessCalls <= neededCalls); // some chromosomes after crossover may be the same os old ones    }    /**     * Initializes a random population.     */    private static ElitisticListPopulation randomPopulation() {        List<Chromosome> popList = new LinkedList<Chromosome>();                for (int i=0; i<POPULATION_SIZE; i++) {            BinaryChromosome randChrom = new DummyCountingBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(DIMENSION));            popList.add(randChrom);        }                return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE);    }        private static class DummyCountingBinaryChromosome extends DummyBinaryChromosome {        public DummyCountingBinaryChromosome(List<Integer> representation) {            super(representation);        }                @Override        public double fitness() {            fitnessCalls++;            return 0;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import java.util.ArrayList;import org.junit.Test;public class ListPopulationTest {    @Test    public void testGetFittestChromosome() {        Chromosome c1 = new Chromosome() {            public double fitness() {                                return 0;            }        };        Chromosome c2 = new Chromosome() {            public double fitness() {                                return 10;            }        };        Chromosome c3 = new Chromosome() {            public double fitness() {                                return 15;            }        };                ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome> ();        chromosomes.add(c1);        chromosomes.add(c2);        chromosomes.add(c3);                ListPopulation population = new ListPopulation(chromosomes,10) {            public Population nextGeneration() {                // not important                return null;            }        };                assertEquals(c3, population.getFittestChromosome());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import org.junit.Test;public class BinaryChromosomeTest {        @Test    public void testInvalidConstructor() {                Integer[][] reprs = new Integer[][] {                new Integer[] {0,1,0,1,2},                new Integer[] {0,1,0,1,-1}        };                for (Integer[] repr : reprs) {            try {                new DummyBinaryChromosome(repr);                fail("Exception not caught");            } catch (IllegalArgumentException e) {                            }        }    }        @Test    public void testRandomConstructor() {        for (int i=0; i<20; i++) {            new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10));        }    }        @Test    public void testIsSame() {        Chromosome c1 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1});        Chromosome c2 = new DummyBinaryChromosome(new Integer[] {0,1,1,0,1});        Chromosome c3 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1,1});        Chromosome c4 = new DummyBinaryChromosome(new Integer[] {1,1,0,1,0,1});        Chromosome c5 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,0});        Chromosome c6 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1});                assertFalse(c1.isSame(c2));        assertFalse(c1.isSame(c3));        assertFalse(c1.isSame(c4));        assertFalse(c1.isSame(c5));        assertTrue(c1.isSame(c6));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import org.junit.Test;public class ElitisticListPopulationTest {        private static int counter = 0;    @Test    public void testNextGeneration() {        ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203);                for (int i=0; i<pop.getPopulationLimit(); i++) {            pop.addChromosome(new DummyChromosome());        }                Population nextGeneration = pop.nextGeneration();                assertEquals(20, nextGeneration.getPopulationSize());    }        private static class DummyChromosome extends Chromosome {        private final int fitness;                public DummyChromosome() {            this.fitness = counter;            counter++;        }                public double fitness() {                        return this.fitness;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import org.junit.Test;public class BinaryMutationTest {    @Test    public void testMutate() {        BinaryMutation mutation = new BinaryMutation();                // stochastic testing :)        for (int i=0; i<20; i++) {            DummyBinaryChromosome original = new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10));                        DummyBinaryChromosome mutated = (DummyBinaryChromosome) mutation.mutate(original);                        // one gene should be different            int numDifferent = 0;            for (int j=0; j<original.getRepresentation().size(); j++) {                if (original.getRepresentation().get(j) != mutated.getRepresentation().get(j))                    numDifferent++;            }            assertEquals(1, numDifferent);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.Expm1Function;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import junit.framework.TestCase;/** * Testcase for Muller solver. * <p> * Muller's method converges almost quadratically near roots, but it can * be very slow in regions far away from zeros. Test runs show that for * reasonably good initial values, for a default absolute accuracy of 1E-6, * it generally takes 5 to 10 iterations for the solver to converge. * <p> * Tests for the exponential function illustrate the situations where * Muller solver performs poorly. *  * @version $Revision$ $Date$  */public final class MullerSolverTest extends TestCase {    /**     * Test deprecated APIs.     */    @Deprecated    public void testDeprecated() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new MullerSolver(f);        double min, max, expected, result, tolerance;        min = 3.0; max = 4.0; expected = Math.PI;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);        min = -1.0; max = 1.5; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test deprecated APIs.     */    @Deprecated    public void testDeprecated2() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        MullerSolver solver = new MullerSolver(f);        double min, max, expected, result, tolerance;        min = -0.4; max = 0.2; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(min, max);        assertEquals(expected, result, tolerance);        min = 0.75; max = 1.5; expected = 1.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(min, max);        assertEquals(expected, result, tolerance);        min = -0.9; max = -0.2; expected = -0.5;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new MullerSolver();        double min, max, expected, result, tolerance;        min = 3.0; max = 4.0; expected = Math.PI;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -1.0; max = 1.5; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the sine function using solve2().     */    public void testSinFunction2() throws MathException {        UnivariateRealFunction f = new SinFunction();        MullerSolver solver = new MullerSolver();        double min, max, expected, result, tolerance;        min = 3.0; max = 4.0; expected = Math.PI;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(f, min, max);        assertEquals(expected, result, tolerance);        min = -1.0; max = 1.5; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function.     */    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new MullerSolver();        double min, max, expected, result, tolerance;        min = -0.4; max = 0.2; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = 0.75; max = 1.5; expected = 1.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -0.9; max = -0.2; expected = -0.5;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function using solve2().     */    public void testQuinticFunction2() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        MullerSolver solver = new MullerSolver();        double min, max, expected, result, tolerance;        min = -0.4; max = 0.2; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(f, min, max);        assertEquals(expected, result, tolerance);        min = 0.75; max = 1.5; expected = 1.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(f, min, max);        assertEquals(expected, result, tolerance);        min = -0.9; max = -0.2; expected = -0.5;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the exponential function.     * <p>     * It takes 10 to 15 iterations for the last two tests to converge.     * In fact, if not for the bisection alternative, the solver would     * exceed the default maximal iteration of 100.     */    public void testExpm1Function() throws MathException {        UnivariateRealFunction f = new Expm1Function();        UnivariateRealSolver solver = new MullerSolver();        double min, max, expected, result, tolerance;        min = -1.0; max = 2.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -20.0; max = 10.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -50.0; max = 100.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the exponential function using solve2().     * <p>     * It takes 25 to 50 iterations for the last two tests to converge.     */    public void testExpm1Function2() throws MathException {        UnivariateRealFunction f = new Expm1Function();        MullerSolver solver = new MullerSolver();        double min, max, expected, result, tolerance;        min = -1.0; max = 2.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(f, min, max);        assertEquals(expected, result, tolerance);        min = -20.0; max = 10.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(f, min, max);        assertEquals(expected, result, tolerance);        min = -50.0; max = 100.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the solver.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new MullerSolver();        try {            // bad interval            solver.solve(f, 1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // no bracketing            solver.solve(f, 2, 3);            fail("Expecting IllegalArgumentException - no bracketing");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * * Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.apache.commons.math.analysis.solvers;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class UnivariateRealSolverFactoryImplTest extends TestCase {        /** solver factory */    private UnivariateRealSolverFactory factory;        /**     * @throws java.lang.Exception     * @see junit.framework.TestCase#tearDown()     */    @Override    protected void setUp() throws Exception {        super.setUp();        factory = new UnivariateRealSolverFactoryImpl();    }        /**     * @throws java.lang.Exception     * @see junit.framework.TestCase#tearDown()     */    @Override    protected void tearDown() throws Exception {        factory = null;        super.tearDown();    }    public void testNewBisectionSolverValid() {        UnivariateRealSolver solver = factory.newBisectionSolver();        assertNotNull(solver);        assertTrue(solver instanceof BisectionSolver);    }    public void testNewNewtonSolverValid() {        UnivariateRealSolver solver = factory.newNewtonSolver();        assertNotNull(solver);        assertTrue(solver instanceof NewtonSolver);    }    public void testNewBrentSolverValid() {        UnivariateRealSolver solver = factory.newBrentSolver();        assertNotNull(solver);        assertTrue(solver instanceof BrentSolver);    }    public void testNewSecantSolverValid() {        UnivariateRealSolver solver = factory.newSecantSolver();        assertNotNull(solver);        assertTrue(solver instanceof SecantSolver);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.ConvergenceException;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class UnivariateRealSolverUtilsTest extends TestCase {        protected UnivariateRealFunction sin = new SinFunction();        public void testSolveNull() throws MathException {        try {            UnivariateRealSolverUtils.solve(null, 0.0, 4.0);            fail();        } catch(IllegalArgumentException ex){            // success        }    }        public void testSolveBadParameters() throws MathException {        try { // bad endpoints            UnivariateRealSolverUtils.solve(sin,0.0, 4.0, 4.0);         } catch (IllegalArgumentException ex) {            // expected        }            try { // bad accuracy            UnivariateRealSolverUtils.solve(sin, 0.0, 4.0, 0.0);         } catch (IllegalArgumentException ex) {            // expected        }            }        public void testSolveSin() throws MathException {             double x = UnivariateRealSolverUtils.solve(sin, 1.0, 4.0);        assertEquals(Math.PI, x, 1.0e-4);    }        public void testSolveAccuracyNull()  throws MathException {        try {            double accuracy = 1.0e-6;            UnivariateRealSolverUtils.solve(null, 0.0, 4.0, accuracy);            fail();        } catch(IllegalArgumentException ex){            // success        }    }        public void testSolveAccuracySin() throws MathException {        double accuracy = 1.0e-6;        double x = UnivariateRealSolverUtils.solve(sin, 1.0,                4.0, accuracy);        assertEquals(Math.PI, x, accuracy);    }        public void testSolveNoRoot() throws MathException {        try {            UnivariateRealSolverUtils.solve(sin, 1.0, 1.5);              fail("Expecting IllegalArgumentException ");          } catch (IllegalArgumentException ex) {            // expected        }    }        public void testBracketSin() throws MathException {        double[] result = UnivariateRealSolverUtils.bracket(sin,                 0.0, -2.0, 2.0);        assertTrue(sin.value(result[0]) < 0);        assertTrue(sin.value(result[1]) > 0);    }        public void testBracketCornerSolution() throws MathException {        try {            UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0);             fail("Expecting ConvergenceException");        } catch (ConvergenceException ex) {            // expected        }    }        public void testBadParameters() throws MathException {        try { // null function            UnivariateRealSolverUtils.bracket(null, 1.5, 0, 2.0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try { // initial not between endpoints            UnivariateRealSolverUtils.bracket(sin, 2.5, 0, 2.0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try { // endpoints not valid            UnivariateRealSolverUtils.bracket(sin, 1.5, 2.0, 1.0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try { // bad maximum iterations            UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0, 0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }            }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.polynomials.PolynomialFunction;import org.apache.commons.math.complex.Complex;import junit.framework.TestCase;/** * Testcase for Laguerre solver. * <p> * Laguerre's method is very efficient in solving polynomials. Test runs * show that for a default absolute accuracy of 1E-6, it generally takes * less than 5 iterations to find one root, provided solveAll() is not * invoked, and 15 to 20 iterations to find all roots for quintic function. *  * @version $Revision$ $Date$  */public final class LaguerreSolverTest extends TestCase {    /**     * Test deprecated APIs.     */    @Deprecated    public void testDeprecated() throws MathException {        double min, max, expected, result, tolerance;        // p(x) = 4x - 1        double coefficients[] = { -1.0, 4.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        UnivariateRealSolver solver = new LaguerreSolver(f);        min = 0.0; max = 1.0; expected = 0.25;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the linear function.     */    public void testLinearFunction() throws MathException {        double min, max, expected, result, tolerance;        // p(x) = 4x - 1        double coefficients[] = { -1.0, 4.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        UnivariateRealSolver solver = new LaguerreSolver();        min = 0.0; max = 1.0; expected = 0.25;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quadratic function.     */    public void testQuadraticFunction() throws MathException {        double min, max, expected, result, tolerance;        // p(x) = 2x^2 + 5x - 3 = (x+3)(2x-1)        double coefficients[] = { -3.0, 5.0, 2.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        UnivariateRealSolver solver = new LaguerreSolver();        min = 0.0; max = 2.0; expected = 0.5;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -4.0; max = -1.0; expected = -3.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function.     */    public void testQuinticFunction() throws MathException {        double min, max, expected, result, tolerance;        // p(x) = x^5 - x^4 - 12x^3 + x^2 - x - 12 = (x+1)(x+3)(x-4)(x^2-x+1)        double coefficients[] = { -12.0, -1.0, 1.0, -12.0, -1.0, 1.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        UnivariateRealSolver solver = new LaguerreSolver();        min = -2.0; max = 2.0; expected = -1.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -5.0; max = -2.5; expected = -3.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = 3.0; max = 6.0; expected = 4.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function using solveAll().     */    public void testQuinticFunction2() throws MathException {        double initial = 0.0, tolerance;        Complex expected, result[];        // p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4)        double coefficients[] = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 };        LaguerreSolver solver = new LaguerreSolver();        result = solver.solveAll(coefficients, initial);        expected = new Complex(0.0, -2.0);        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));        TestUtils.assertContains(result, expected, tolerance);        expected = new Complex(0.0, 2.0);        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));        TestUtils.assertContains(result, expected, tolerance);        expected = new Complex(0.5, 0.5 * Math.sqrt(3.0));        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));        TestUtils.assertContains(result, expected, tolerance);        expected = new Complex(-1.0, 0.0);        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));        TestUtils.assertContains(result, expected, tolerance);                expected = new Complex(0.5, -0.5 * Math.sqrt(3.0));        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));        TestUtils.assertContains(result, expected, tolerance);    }    /**     * Test of parameters for the solver.     */    public void testParameters() throws Exception {        double coefficients[] = { -3.0, 5.0, 2.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        UnivariateRealSolver solver = new LaguerreSolver();        try {            // bad interval            solver.solve(f, 1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // no bracketing            solver.solve(f, 2, 3);            fail("Expecting IllegalArgumentException - no bracketing");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad function            solver.solve(new SinFunction(), -1, 1);            fail("Expecting IllegalArgumentException - bad function");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.MonitoredFunction;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Testcase for UnivariateRealSolver. * Because Brent-Dekker is guaranteed to converge in less than the default * maximum iteration count due to bisection fallback, it is quite hard to * debug. I include measured iteration counts plus one in order to detect * regressions. On average Brent-Dekker should use 4..5 iterations for the * default absolute accuracy of 10E-8 for sinus and the quintic function around * zero, and 5..10 iterations for the other zeros. *  * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $  */public final class BrentSolverTest extends TestCase {    public BrentSolverTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(BrentSolverTest.class);        suite.setName("UnivariateRealSolver Tests");        return suite;    }    @Deprecated    public void testDeprecated() throws MathException {        // The sinus function is behaved well around the root at #pi. The second        // order derivative is zero, which means linar approximating methods will        // still converge quadratically.         UnivariateRealFunction f = new SinFunction();        double result;        UnivariateRealSolver solver = new BrentSolver(f);        // Somewhat benign interval. The function is monotone.        result = solver.solve(3, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        // 4 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 5);        // Larger and somewhat less benign interval. The function is grows first.        result = solver.solve(1, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        solver = new SecantSolver(f);        result = solver.solve(3, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        // 4 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 5);        result = solver.solve(1, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        assertEquals(result, solver.getResult(), 0);    }    public void testSinZero() throws MathException {        // The sinus function is behaved well around the root at #pi. The second        // order derivative is zero, which means linar approximating methods will        // still converge quadratically.         UnivariateRealFunction f = new SinFunction();        double result;        UnivariateRealSolver solver = new BrentSolver();        // Somewhat benign interval. The function is monotone.        result = solver.solve(f, 3, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        // 4 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 5);        // Larger and somewhat less benign interval. The function is grows first.        result = solver.solve(f, 1, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        solver = new SecantSolver();        result = solver.solve(f, 3, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        // 4 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 5);        result = solver.solve(f, 1, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        assertEquals(result, solver.getResult(), 0);    }   public void testQuinticZero() throws MathException {        // The quintic function has zeros at 0, +-0.5 and +-1.        // Around the root of 0 the function is well behaved, with a second derivative        // of zero a 0.        // The other roots are less well to find, in particular the root at 1, because        // the function grows fast for x>1.        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,        // intervals containing these values are harder for the solvers.        UnivariateRealFunction f = new QuinticFunction();        double result;        // Brent-Dekker solver.        UnivariateRealSolver solver = new BrentSolver();        // Symmetric bracket around 0. Test whether solvers can handle hitting        // the root in the first iteration.        result = solver.solve(f, -0.2, 0.2);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        assertTrue(solver.getIterationCount() <= 2);        // 1 iterations on i586 JDK 1.4.1.        // Asymmetric bracket around 0, just for fun. Contains extremum.        result = solver.solve(f, -0.1, 0.3);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        // Large bracket around 0. Contains two extrema.        result = solver.solve(f, -0.3, 0.45);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        // Benign bracket around 0.5, function is monotonous.        result = solver.solve(f, 0.3, 0.7);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        // Less benign bracket around 0.5, contains one extremum.        result = solver.solve(f, 0.2, 0.6);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        // Large, less benign bracket around 0.5, contains both extrema.        result = solver.solve(f, 0.05, 0.95);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        // Relatively benign bracket around 1, function is monotonous. Fast growth for x>1        // is still a problem.        result = solver.solve(f, 0.85, 1.25);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        // Less benign bracket around 1 with extremum.        result = solver.solve(f, 0.8, 1.2);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        // Large bracket around 1. Monotonous.        result = solver.solve(f, 0.85, 1.75);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 10 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 11);        // Large bracket around 1. Interval contains extremum.        result = solver.solve(f, 0.55, 1.45);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 7 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 8);        // Very large bracket around 1 for testing fast growth behaviour.        result = solver.solve(f, 0.85, 5);        //System.out.println(       //     "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 12 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 13);        // Secant solver.        solver = new SecantSolver();        result = solver.solve(f, -0.2, 0.2);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 1 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 2);        result = solver.solve(f, -0.1, 0.3);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        result = solver.solve(f, -0.3, 0.45);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        result = solver.solve(f, 0.3, 0.7);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 7 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 8);        result = solver.solve(f, 0.2, 0.6);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        result = solver.solve(f, 0.05, 0.95);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        result = solver.solve(f, 0.85, 1.25);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 10 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 11);        result = solver.solve(f, 0.8, 1.2);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        result = solver.solve(f, 0.85, 1.75);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 14 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 15);        // The followig is especially slow because the solver first has to reduce        // the bracket to exclude the extremum. After that, convergence is rapide.        result = solver.solve(f, 0.55, 1.45);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 7 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 8);        result = solver.solve(f, 0.85, 5);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 14 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 15);        // Static solve method        result = UnivariateRealSolverUtils.solve(f, -0.2, 0.2);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = UnivariateRealSolverUtils.solve(f, -0.1, 0.3);        assertEquals(result, 0, 1E-8);        result = UnivariateRealSolverUtils.solve(f, -0.3, 0.45);        assertEquals(result, 0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.3, 0.7);        assertEquals(result, 0.5, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.2, 0.6);        assertEquals(result, 0.5, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.05, 0.95);        assertEquals(result, 0.5, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.25);        assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.8, 1.2);        assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.75);        assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.55, 1.45);        assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.85, 5);        assertEquals(result, 1.0, 1E-6);    }        public void testRootEndpoints() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new BrentSolver();                // endpoint is root        double result = solver.solve(f, Math.PI, 4);        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        result = solver.solve(f, 3, Math.PI);        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());    }        public void testBadEndpoints() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new BrentSolver();        try {  // bad interval            solver.solve(f, 1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {  // no bracket            solver.solve(f, 1, 1.5);            fail("Expecting IllegalArgumentException - non-bracketing");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testInitialGuess() throws MathException {        MonitoredFunction f = new MonitoredFunction(new QuinticFunction());        UnivariateRealSolver solver = new BrentSolver();        double result;        // no guess        result = solver.solve(f, 0.6, 7.0);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        int referenceCallsCount = f.getCallsCount();        assertTrue(referenceCallsCount >= 13);         // invalid guess (it *is* a root, but outside of the range)        try {          result = solver.solve(f, 0.6, 7.0, 0.0);          fail("an IllegalArgumentException was expected");        } catch (IllegalArgumentException iae) {            // expected behaviour        } catch (Exception e) {            fail("wrong exception caught: " + e.getMessage());        }         // bad guess        f.setCallsCount(0);        result = solver.solve(f, 0.6, 7.0, 0.61);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        assertTrue(f.getCallsCount() > referenceCallsCount);         // good guess        f.setCallsCount(0);        result = solver.solve(f, 0.6, 7.0, 0.999999);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        assertTrue(f.getCallsCount() < referenceCallsCount);        // perfect guess        f.setCallsCount(0);        result = solver.solve(f, 0.6, 7.0, 1.0);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        assertEquals(0, solver.getIterationCount());        assertEquals(1, f.getCallsCount());     }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.Expm1Function;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import junit.framework.TestCase;/** * Testcase for Ridders solver. * <p> * Ridders' method converges superlinearly, more specific, its rate of * convergence is sqrt(2). Test runs show that for a default absolute * accuracy of 1E-6, it generally takes less than 5 iterations for close * initial bracket and 5 to 10 iterations for distant initial bracket * to converge. *  * @version $Revision$ $Date$  */public final class RiddersSolverTest extends TestCase {    /**     * Test the deprecated APIs.     */    @Deprecated    public void testDeprecated() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new RiddersSolver(f);        double min, max, expected, result, tolerance;        min = 3.0; max = 4.0; expected = Math.PI;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);        min = -1.0; max = 1.5; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new RiddersSolver();        double min, max, expected, result, tolerance;        min = 3.0; max = 4.0; expected = Math.PI;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -1.0; max = 1.5; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function.     */    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new RiddersSolver();        double min, max, expected, result, tolerance;        min = -0.4; max = 0.2; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = 0.75; max = 1.5; expected = 1.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -0.9; max = -0.2; expected = -0.5;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the exponential function.     */    public void testExpm1Function() throws MathException {        UnivariateRealFunction f = new Expm1Function();        UnivariateRealSolver solver = new RiddersSolver();        double min, max, expected, result, tolerance;        min = -1.0; max = 2.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -20.0; max = 10.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -50.0; max = 100.0; expected = 0.0;        tolerance = Math.max(solver.getAbsoluteAccuracy(),                    Math.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the solver.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new RiddersSolver();        try {            // bad interval            solver.solve(f, 1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // no bracketing            solver.solve(f, 2, 3);            fail("Expecting IllegalArgumentException - no bracketing");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public final class BisectionSolverTest extends TestCase {    @Deprecated    public void testDeprecated() throws MathException {        UnivariateRealFunction f = new SinFunction();        double result;                UnivariateRealSolver solver = new BisectionSolver(f);        result = solver.solve(3, 4);        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        result = solver.solve(1, 4);        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());    }    public void testSinZero() throws MathException {        UnivariateRealFunction f = new SinFunction();        double result;                UnivariateRealSolver solver = new BisectionSolver();        result = solver.solve(f, 3, 4);        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        result = solver.solve(f, 1, 4);        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());    }   public void testQuinticZero() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        double result;        UnivariateRealSolver solver = new BisectionSolver();        result = solver.solve(f, -0.2, 0.2);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(f, -0.1, 0.3);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(f, -0.3, 0.45);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.3, 0.7);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.2, 0.6);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.05, 0.95);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.85, 1.25);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.8, 1.2);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.85, 1.75);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.55, 1.45);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.85, 5);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());                assertEquals(result, solver.getResult(), 0);        assertTrue(solver.getIterationCount() > 0);    }        /**     *      */    public void testSetFunctionValueAccuracy(){        double expected = 1.0e-2;            UnivariateRealSolver solver = new BisectionSolver();        solver.setFunctionValueAccuracy(expected);        assertEquals(expected, solver.getFunctionValueAccuracy(), 1.0e-2);    }                /**     *      */    public void testResetFunctionValueAccuracy(){        double newValue = 1.0e-2;            UnivariateRealSolver solver = new BisectionSolver();        double oldValue = solver.getFunctionValueAccuracy();        solver.setFunctionValueAccuracy(newValue);        solver.resetFunctionValueAccuracy();        assertEquals(oldValue, solver.getFunctionValueAccuracy(), 1.0e-2);    }                /**     *      */    public void testSetAbsoluteAccuracy(){        double expected = 1.0e-2;         UnivariateRealSolver solver = new BisectionSolver();        solver.setAbsoluteAccuracy(expected);        assertEquals(expected, solver.getAbsoluteAccuracy(), 1.0e-2);     }                /**     *      */    public void testResetAbsoluteAccuracy(){        double newValue = 1.0e-2;               UnivariateRealSolver solver = new BisectionSolver();        double oldValue = solver.getAbsoluteAccuracy();        solver.setAbsoluteAccuracy(newValue);        solver.resetAbsoluteAccuracy();        assertEquals(oldValue, solver.getAbsoluteAccuracy(), 1.0e-2);    }                /**     *      */    public void testSetMaximalIterationCount(){        int expected = 100;        UnivariateRealSolver solver = new BisectionSolver();        solver.setMaximalIterationCount(expected);        assertEquals(expected, solver.getMaximalIterationCount());    }                /**     *      */    public void testResetMaximalIterationCount(){        int newValue = 10000;        UnivariateRealSolver solver = new BisectionSolver();        int oldValue = solver.getMaximalIterationCount();        solver.setMaximalIterationCount(newValue);        solver.resetMaximalIterationCount();        assertEquals(oldValue, solver.getMaximalIterationCount());    }                /**     *      */    public void testSetRelativeAccuracy(){        double expected = 1.0e-2;        UnivariateRealSolver solver = new BisectionSolver();        solver.setRelativeAccuracy(expected);        assertEquals(expected, solver.getRelativeAccuracy(), 1.0e-2);    }                /**     *      */    public void testResetRelativeAccuracy(){        double newValue = 1.0e-2;                UnivariateRealSolver solver = new BisectionSolver();        double oldValue = solver.getRelativeAccuracy();        solver.setRelativeAccuracy(newValue);        solver.resetRelativeAccuracy();        assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);    }                /**     * Test Serialization and Recovery     */   public void testSerialization() throws MathException {       UnivariateRealFunction f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction());       double result;              BisectionSolver solver = new BisectionSolver();       UnivariateRealSolver solver2 = (UnivariateRealSolver)TestUtils.serializeAndRecover(solver);              result = solver.solve(f, -0.2, 0.2);       assertEquals(result, 0, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(f, -0.2, 0.2), result, solver2.getAbsoluteAccuracy());              result = solver.solve(f, -0.1, 0.3);       assertEquals(result, 0, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(f, -0.1, 0.3), result, solver2.getAbsoluteAccuracy());              result = solver.solve(f, -0.3, 0.45);       assertEquals(result, 0, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(f, -0.3, 0.45), result, solver2.getAbsoluteAccuracy());              result = solver.solve(f, 0.3, 0.7);       assertEquals(result, 0.5, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(f, 0.3, 0.7), result, solver2.getAbsoluteAccuracy());              result = solver.solve(f, 0.2, 0.6);       assertEquals(result, 0.5, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(f, 0.2, 0.6), result, solver2.getAbsoluteAccuracy());              result = solver.solve(f, 0.05, 0.95);       assertEquals(result, 0.5, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(f, 0.05, 0.95), result, solver2.getAbsoluteAccuracy());              result = solver.solve(f, 0.85, 1.25);       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(f, 0.85, 1.25), result, solver2.getAbsoluteAccuracy());              result = solver.solve(f, 0.8, 1.2);       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(f, 0.8, 1.2), result, solver2.getAbsoluteAccuracy());              result = solver.solve(f, 0.85, 1.75);       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(f, 0.85, 1.75), result, solver2.getAbsoluteAccuracy());              result = solver.solve(f, 0.55, 1.45);       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(f, 0.55, 1.45), result, solver2.getAbsoluteAccuracy());              result = solver.solve(f, 0.85, 5);       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());       assertEquals(solver2.solve(f, 0.85, 5), result, solver2.getAbsoluteAccuracy());              /* Test Reset */       double newValue = 1.0e-2;       f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction());       solver = new BisectionSolver();              double oldValue = solver.getRelativeAccuracy();       solver.setRelativeAccuracy(newValue);       solver.resetRelativeAccuracy();       assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);              solver2 = (UnivariateRealSolver)TestUtils.serializeAndRecover(solver);               assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);              solver2.setRelativeAccuracy(newValue);       solver2.resetRelativeAccuracy();              assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);          }   }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public final class NewtonSolverTest extends TestCase {    @Deprecated    public void testDeprecated() throws MathException {        DifferentiableUnivariateRealFunction f = new SinFunction();        double result;                UnivariateRealSolver solver = new NewtonSolver(f);        result = solver.solve(3, 4);        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        result = solver.solve(1, 4);        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());                //TODO:  create abstract solver test class, move these there        assertEquals(result, solver.getResult(), 0);        assertTrue(solver.getIterationCount() > 0);    }    /**    *    */   public void testSinZero() throws MathException {       DifferentiableUnivariateRealFunction f = new SinFunction();       double result;              UnivariateRealSolver solver = new NewtonSolver();       result = solver.solve(f, 3, 4);       assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());       result = solver.solve(f, 1, 4);       assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());              //TODO:  create abstract solver test class, move these there       assertEquals(result, solver.getResult(), 0);       assertTrue(solver.getIterationCount() > 0);   }   /**     *     */    public void testQuinticZero() throws MathException {        DifferentiableUnivariateRealFunction f = new QuinticFunction();        double result;        UnivariateRealSolver solver = new NewtonSolver();        result = solver.solve(f, -0.2, 0.2);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(f, -0.1, 0.3);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(f, -0.3, 0.45);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.3, 0.7);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.2, 0.6);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.05, 0.95);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.85, 1.25);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.8, 1.2);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.85, 1.75);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.55, 1.45);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.85, 5);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());    }        /**     * Test Serialization and Recovery     */    public void testSerialization() throws MathException {        DifferentiableUnivariateRealFunction f = new QuinticFunction();        double result;                NewtonSolver solver = new NewtonSolver();        NewtonSolver solver2 = (NewtonSolver)TestUtils.serializeAndRecover(solver);                result = solver.solve(f, -0.2, 0.2);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(f, -0.2, 0.2), result, solver2.getAbsoluteAccuracy());                result = solver.solve(f, -0.1, 0.3);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(f, -0.1, 0.3), result, solver2.getAbsoluteAccuracy());                result = solver.solve(f, -0.3, 0.45);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(f, -0.3, 0.45), result, solver2.getAbsoluteAccuracy());                result = solver.solve(f, 0.3, 0.7);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(f, 0.3, 0.7), result, solver2.getAbsoluteAccuracy());                result = solver.solve(f, 0.2, 0.6);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(f, 0.2, 0.6), result, solver2.getAbsoluteAccuracy());                result = solver.solve(f, 0.05, 0.95);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(f, 0.05, 0.95), result, solver2.getAbsoluteAccuracy());                result = solver.solve(f, 0.85, 1.25);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(f, 0.85, 1.25), result, solver2.getAbsoluteAccuracy());                result = solver.solve(f, 0.8, 1.2);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(f, 0.8, 1.2), result, solver2.getAbsoluteAccuracy());                result = solver.solve(f, 0.85, 1.75);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(f, 0.85, 1.75), result, solver2.getAbsoluteAccuracy());                result = solver.solve(f, 0.55, 1.45);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(f, 0.55, 1.45), result, solver2.getAbsoluteAccuracy());                result = solver.solve(f, 0.85, 5);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        assertEquals(solver2.solve(f, 0.85, 5), result, solver2.getAbsoluteAccuracy());                /* Test Reset */        double newValue = 1.0e-2;        f = new QuinticFunction();        solver = new NewtonSolver();                double oldValue = solver.getRelativeAccuracy();        solver.setRelativeAccuracy(newValue);        solver.resetRelativeAccuracy();        assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);                solver2 = (NewtonSolver)TestUtils.serializeAndRecover(solver);                 assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);                solver2.setRelativeAccuracy(newValue);        solver2.resetRelativeAccuracy();                assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);            }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.integration;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import junit.framework.TestCase;/** * Testcase for Romberg integrator. * <p> * Romberg algorithm is very fast for good behavior integrand. Test runs * show that for a default relative accuracy of 1E-6, it generally takes * takes less than 5 iterations for the integral to converge. *  * @version $Revision$ $Date$  */public final class RombergIntegratorTest extends TestCase {    /**     * Test of integrator for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new RombergIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = Math.PI; expected = 2;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = -Math.PI/3; max = 0; expected = -0.5;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of integrator for the quintic function.     */    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealIntegrator integrator = new RombergIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = 1; expected = -1.0/48;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = 0; max = 0.5; expected = 11.0/768;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the integrator.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new RombergIntegrator();        try {            // bad interval            integrator.integrate(f, 1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(5);            integrator.setMaximalIterationCount(4);            integrator.integrate(f, -1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(10);            integrator.setMaximalIterationCount(50);            integrator.integrate(f, -1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.integration;import java.util.Random;import org.apache.commons.math.ConvergenceException;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.analysis.polynomials.PolynomialFunction;import junit.framework.*;public class LegendreGaussIntegratorTestextends TestCase {    public LegendreGaussIntegratorTest(String name) {        super(name);    }    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new LegendreGaussIntegrator(5, 64);        integrator.setAbsoluteAccuracy(1.0e-10);        integrator.setRelativeAccuracy(1.0e-14);        integrator.setMinimalIterationCount(2);        integrator.setMaximalIterationCount(15);        double min, max, expected, result, tolerance;        min = 0; max = Math.PI; expected = 2;        tolerance = Math.max(integrator.getAbsoluteAccuracy(),                             Math.abs(expected * integrator.getRelativeAccuracy()));        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = -Math.PI/3; max = 0; expected = -0.5;        tolerance = Math.max(integrator.getAbsoluteAccuracy(),                Math.abs(expected * integrator.getRelativeAccuracy()));        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);    }    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealIntegrator integrator = new LegendreGaussIntegrator(3, 64);        double min, max, expected, result;        min = 0; max = 1; expected = -1.0/48;        result = integrator.integrate(f, min, max);        assertEquals(expected, result, 1.0e-16);        min = 0; max = 0.5; expected = 11.0/768;        result = integrator.integrate(f, min, max);        assertEquals(expected, result, 1.0e-16);        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;        result = integrator.integrate(f, min, max);        assertEquals(expected, result, 1.0e-16);    }    public void testExactIntegration()        throws ConvergenceException, FunctionEvaluationException {        Random random = new Random(86343623467878363l);        for (int n = 2; n < 6; ++n) {            LegendreGaussIntegrator integrator =                new LegendreGaussIntegrator(n, 64);            // an n points Gauss-Legendre integrator integrates 2n-1 degree polynoms exactly            for (int degree = 0; degree <= 2 * n - 1; ++degree) {                for (int i = 0; i < 10; ++i) {                    double[] coeff = new double[degree + 1];                    for (int k = 0; k < coeff.length; ++k) {                        coeff[k] = 2 * random.nextDouble() - 1;                    }                    PolynomialFunction p = new PolynomialFunction(coeff);                    double result    = integrator.integrate(p, -5.0, 15.0);                    double reference = exactIntegration(p, -5.0, 15.0);                    assertEquals(n + " " + degree + " " + i, reference, result, 1.0e-12 * (1.0 + Math.abs(reference)));                }            }        }    }    private double exactIntegration(PolynomialFunction p, double a, double b) {        final double[] coeffs = p.getCoefficients();        double yb = coeffs[coeffs.length - 1] / coeffs.length;        double ya = yb;        for (int i = coeffs.length - 2; i >= 0; --i) {            yb = yb * b + coeffs[i] / (i + 1);            ya = ya * a + coeffs[i] / (i + 1);        }        return yb * b - ya * a;    }    public static Test suite() {        return new TestSuite(LegendreGaussIntegratorTest.class);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.integration;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import junit.framework.TestCase;/** * Testcase for trapezoid integrator. * <p> * Test runs show that for a default relative accuracy of 1E-6, it * generally takes 10 to 15 iterations for the integral to converge. *  * @version $Revision$ $Date$  */public final class TrapezoidIntegratorTest extends TestCase {    /**     * Test of integrator for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new TrapezoidIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = Math.PI; expected = 2;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = -Math.PI/3; max = 0; expected = -0.5;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of integrator for the quintic function.     */    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealIntegrator integrator = new TrapezoidIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = 1; expected = -1.0/48;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = 0; max = 0.5; expected = 11.0/768;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the integrator.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new TrapezoidIntegrator();        try {            // bad interval            integrator.integrate(f, 1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(5);            integrator.setMaximalIterationCount(4);            integrator.integrate(f, -1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(10);            integrator.setMaximalIterationCount(99);            integrator.integrate(f, -1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.integration;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import junit.framework.TestCase;/** * Testcase for Simpson integrator. * <p> * Test runs show that for a default relative accuracy of 1E-6, it * generally takes 5 to 10 iterations for the integral to converge. *  * @version $Revision$ $Date$  */public final class SimpsonIntegratorTest extends TestCase {    /**     * Test of integrator for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new SimpsonIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = Math.PI; expected = 2;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = -Math.PI/3; max = 0; expected = -0.5;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of integrator for the quintic function.     */    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealIntegrator integrator = new SimpsonIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = 1; expected = -1.0/48;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = 0; max = 0.5; expected = 11.0/768;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the integrator.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new SimpsonIntegrator();        try {            // bad interval            integrator.integrate(f, 1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(5);            integrator.setMaximalIterationCount(4);            integrator.integrate(f, -1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(10);            integrator.setMaximalIterationCount(99);            integrator.integrate(f, -1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import org.apache.commons.math.MathException;import org.junit.Test;/** * Test of the LoessInterpolator class. */public class LoessInterpolatorTest {    @Test    public void testOnOnePoint() throws MathException {        double[] xval = {0.5};        double[] yval = {0.7};        double[] res = new LoessInterpolator().smooth(xval, yval);        assertEquals(1, res.length);        assertEquals(0.7, res[0], 0.0);    }    @Test    public void testOnTwoPoints() throws MathException {        double[] xval = {0.5, 0.6};        double[] yval = {0.7, 0.8};        double[] res = new LoessInterpolator().smooth(xval, yval);        assertEquals(2, res.length);        assertEquals(0.7, res[0], 0.0);        assertEquals(0.8, res[1], 0.0);    }    @Test    public void testOnStraightLine() throws MathException {        double[] xval = {1,2,3,4,5};        double[] yval = {2,4,6,8,10};        LoessInterpolator li = new LoessInterpolator(0.6, 2);        double[] res = li.smooth(xval, yval);        assertEquals(5, res.length);        for(int i = 0; i < 5; ++i) {            assertEquals(yval[i], res[i], 1e-8);        }    }    @Test    public void testOnDistortedSine() throws MathException {        int numPoints = 100;        double[] xval = new double[numPoints];        double[] yval = new double[numPoints];        double xnoise = 0.1;        double ynoise = 0.2;        generateSineData(xval, yval, xnoise, ynoise);        LoessInterpolator li = new LoessInterpolator(0.3, 4);        double[] res = li.smooth(xval, yval);        // Check that the resulting curve differs from        // the "real" sine less than the jittered one        double noisyResidualSum = 0;        double fitResidualSum = 0;        System.out.println();        for(int i = 0; i < numPoints; ++i) {            double expected = Math.sin(xval[i]);            double noisy = yval[i];            double fit = res[i];            noisyResidualSum += Math.pow(noisy - expected, 2);            fitResidualSum += Math.pow(fit - expected, 2);        }        assertTrue(fitResidualSum < noisyResidualSum);    }    @Test    public void testIncreasingBandwidthIncreasesSmoothness() throws MathException {        int numPoints = 100;        double[] xval = new double[numPoints];        double[] yval = new double[numPoints];        double xnoise = 0.1;        double ynoise = 0.1;        generateSineData(xval, yval, xnoise, ynoise);        // Check that variance decreases as bandwidth increases        double[] bandwidths = {0.1, 0.5, 1.0};        double[] variances = new double[bandwidths.length];        for (int i = 0; i < bandwidths.length; i++) {            double bw = bandwidths[i];            LoessInterpolator li = new LoessInterpolator(bw, 4);            double[] res = li.smooth(xval, yval);            for (int j = 1; j < res.length; ++j) {                variances[i] += Math.pow(res[j] - res[j-1], 2);            }        }        for(int i = 1; i < variances.length; ++i) {            assertTrue(variances[i] < variances[i-1]);        }    }    @Test    public void testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers() throws MathException {        int numPoints = 100;        double[] xval = new double[numPoints];        double[] yval = new double[numPoints];        double xnoise = 0.1;        double ynoise = 0.1;        generateSineData(xval, yval, xnoise, ynoise);        // Introduce a couple of outliers        yval[numPoints/3] *= 100;        yval[2 * numPoints/3] *= -100;        // Check that variance decreases as the number of robustness        // iterations increases        double[] variances = new double[4];        for (int i = 0; i < 4; i++) {            LoessInterpolator li = new LoessInterpolator(0.3, i);            double[] res = li.smooth(xval, yval);            for (int j = 1; j < res.length; ++j) {                variances[i] += Math.abs(res[j] - res[j-1]);            }        }        for(int i = 1; i < variances.length; ++i) {            assertTrue(variances[i] < variances[i-1]);        }    }    @Test    public void testUnequalSizeArguments() {        try {            new LoessInterpolator().smooth(new double[] {1,2,3}, new double[] {1,2,3,4});            fail();        } catch(MathException e) {            // Expected        }    }    @Test    public void testEmptyData() {        try {            new LoessInterpolator().smooth(new double[] {}, new double[] {});            fail();        } catch(MathException e) {            // Expected        }    }    @Test    public void testNonStrictlyIncreasing() {        try {            new LoessInterpolator().smooth(new double[] {4,3,1,2}, new double[] {3,4,5,6});            fail();        } catch(MathException e) {            // Expected        }        try {            new LoessInterpolator().smooth(new double[] {1,2,2,3}, new double[] {3,4,5,6});            fail();        } catch(MathException e) {            // Expected        }    }    @Test    public void testNotAllFiniteReal() {        try {            new LoessInterpolator().smooth(new double[] {1,2,Double.NaN}, new double[] {3,4,5});            fail();        } catch(MathException e) {            // Expected        }        try {            new LoessInterpolator().smooth(new double[] {1,2,Double.POSITIVE_INFINITY}, new double[] {3,4,5});            fail();        } catch(MathException e) {            // Expected        }        try {            new LoessInterpolator().smooth(new double[] {1,2,Double.NEGATIVE_INFINITY}, new double[] {3,4,5});            fail();        } catch(MathException e) {            // Expected        }        try {            new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.NaN});            fail();        } catch(MathException e) {            // Expected        }        try {            new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.POSITIVE_INFINITY});            fail();        } catch(MathException e) {            // Expected        }        try {            new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.NEGATIVE_INFINITY});            fail();        } catch(MathException e) {            // Expected        }    }    @Test    public void testInsufficientBandwidth() {        try {            LoessInterpolator li = new LoessInterpolator(0.1, 3);            li.smooth(new double[] {1,2,3,4,5,6,7,8,9,10,11,12}, new double[] {1,2,3,4,5,6,7,8,9,10,11,12});            fail();        } catch(MathException e) {            // Expected        }    }    @Test    public void testCompletelyIncorrectBandwidth() {        try {            new LoessInterpolator(-0.2, 3);            fail();        } catch(MathException e) {            // Expected        }        try {            new LoessInterpolator(1.1, 3);            fail();        } catch(MathException e) {            // Expected        }    }    private void generateSineData(double[] xval, double[] yval, double xnoise, double ynoise) {        double dx = 2 * Math.PI / xval.length;        double x = 0;        for(int i = 0; i < xval.length; ++i) {            xval[i] = x;            yval[i] = Math.sin(x) + (2 * Math.random() - 1) * ynoise;            x += dx * (1 + (2 * Math.random() - 1) * xnoise);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.Expm1Function;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import junit.framework.TestCase;/** * Testcase for Divided Difference interpolator. * <p> * The error of polynomial interpolation is *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n! * where f^(n) is the n-th derivative of the approximated function and * zeta is some point in the interval determined by x[] and z. * <p> * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound * it and use the absolute value upper bound for estimates. For reference, * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2. *  * @version $Revision$ $Date$  */public final class DividedDifferenceInterpolatorTest extends TestCase {    /**     * Test of interpolator for the sine function.     * <p>     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();        double x[], y[], z, expected, result, tolerance;        // 6 interpolating points on interval [0, 2*PI]        int n = 6;        double min = 0.0, max = 2 * Math.PI;        x = new double[n];        y = new double[n];        for (int i = 0; i < n; i++) {            x[i] = min + i * (max - min) / n;            y[i] = f.value(x[i]);        }        double derivativebound = 1.0;        UnivariateRealFunction p = interpolator.interpolate(x, y);        z = Math.PI / 4; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);    }    /**     * Test of interpolator for the exponential function.     * <p>     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]     */    public void testExpm1Function() throws MathException {        UnivariateRealFunction f = new Expm1Function();        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();        double x[], y[], z, expected, result, tolerance;        // 5 interpolating points on interval [-1, 1]        int n = 5;        double min = -1.0, max = 1.0;        x = new double[n];        y = new double[n];        for (int i = 0; i < n; i++) {            x[i] = min + i * (max - min) / n;            y[i] = f.value(x[i]);        }        double derivativebound = Math.E;        UnivariateRealFunction p = interpolator.interpolate(x, y);        z = 0.0; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = 0.5; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = -0.5; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the interpolator.     */    public void testParameters() throws Exception {        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();        try {            // bad abscissas array            double x[] = { 1.0, 2.0, 2.0, 4.0 };            double y[] = { 0.0, 4.0, 4.0, 2.5 };            UnivariateRealFunction p = interpolator.interpolate(x, y);            p.value(0.0);            fail("Expecting MathException - bad abscissas array");        } catch (MathException ex) {            // expected        }    }    /**     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!     */    protected double partialerror(double x[], double z) throws        IllegalArgumentException {        if (x.length < 1) {            throw new IllegalArgumentException                ("Interpolation array cannot be empty.");        }        double out = 1;        for (int i = 0; i < x.length; i++) {            out *= (z - x[i]) / (i + 1);        }        return out;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.analysis.polynomials.PolynomialFunction;import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test the SplineInterpolator. * * @version $Revision$ $Date$  */public class SplineInterpolatorTest extends TestCase {        /** error tolerance for spline interpolator value at knot points */    protected double knotTolerance = 1E-12;       /** error tolerance for interpolating polynomial coefficients */    protected double coefficientTolerance = 1E-6;        /** error tolerance for interpolated values -- high value is from sin test */    protected double interpolationTolerance = 1E-2;    public SplineInterpolatorTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SplineInterpolatorTest.class);        suite.setName("UnivariateRealInterpolator Tests");        return suite;    }    public void testInterpolateLinearDegenerateTwoSegment()        throws Exception {        double x[] = { 0.0, 0.5, 1.0 };        double y[] = { 0.0, 0.5, 1.0 };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        verifyConsistency((PolynomialSplineFunction) f, x);                // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 1d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);                // Check interpolation        assertEquals(0.0,f.value(0.0), interpolationTolerance);        assertEquals(0.4,f.value(0.4), interpolationTolerance);        assertEquals(1.0,f.value(1.0), interpolationTolerance);    }    public void testInterpolateLinearDegenerateThreeSegment()        throws Exception {        double x[] = { 0.0, 0.5, 1.0, 1.5 };        double y[] = { 0.0, 0.5, 1.0, 1.5 };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);                // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 1d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[2], 1d};        TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);                // Check interpolation        assertEquals(0,f.value(0), interpolationTolerance);        assertEquals(1.4,f.value(1.4), interpolationTolerance);        assertEquals(1.5,f.value(1.5), interpolationTolerance);    }    public void testInterpolateLinear() throws Exception {        double x[] = { 0.0, 0.5, 1.0 };        double y[] = { 0.0, 0.5, 0.0 };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        verifyConsistency((PolynomialSplineFunction) f, x);                // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1.5d, 0d, -2d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 0d, -3d, 2d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        }        public void testInterpolateSin() throws Exception {        double x[] =            {                0.0,                Math.PI / 6d,                Math.PI / 2d,                5d * Math.PI / 6d,                Math.PI,                7d * Math.PI / 6d,                3d * Math.PI / 2d,                11d * Math.PI / 6d,                2.d * Math.PI };        double y[] = { 0d, 0.5d, 1d, 0.5d, 0d, -0.5d, -1d, -0.5d, 0d };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        verifyConsistency((PolynomialSplineFunction) f, x);                /* Check coefficients against values computed using R (version 1.8.1, Red Hat Linux 9)         *          * To replicate in R:         *     x[1] <- 0         *     x[2] <- pi / 6, etc, same for y[] (could use y <- scan() for y values)         *     g <- splinefun(x, y, "natural")         *     splinecoef <- eval(expression(z), envir = environment(g))         *     print(splinecoef)          */        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1.002676d, 0d, -0.17415829d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 8.594367e-01, -2.735672e-01, -0.08707914};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[2], 1.471804e-17,-5.471344e-01, 0.08707914};        TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[3], -8.594367e-01, -2.735672e-01, 0.17415829};        TestUtils.assertEquals(polynomials[3].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[4], -1.002676, 6.548562e-17, 0.17415829};        TestUtils.assertEquals(polynomials[4].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[5], -8.594367e-01, 2.735672e-01, 0.08707914};        TestUtils.assertEquals(polynomials[5].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[6], 3.466465e-16, 5.471344e-01, -0.08707914};        TestUtils.assertEquals(polynomials[6].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[7], 8.594367e-01, 2.735672e-01, -0.17415829};        TestUtils.assertEquals(polynomials[7].getCoefficients(), target, coefficientTolerance);                 //Check interpolation        assertEquals(Math.sqrt(2d) / 2d,f.value(Math.PI/4d),interpolationTolerance);        assertEquals(Math.sqrt(2d) / 2d,f.value(3d*Math.PI/4d),interpolationTolerance);         }        public void testIllegalArguments() throws MathException {        // Data set arrays of different size.        UnivariateRealInterpolator i = new SplineInterpolator();        try {            double xval[] = { 0.0, 1.0 };            double yval[] = { 0.0, 1.0, 2.0 };            i.interpolate(xval, yval);            fail("Failed to detect data set array with different sizes.");        } catch (IllegalArgumentException iae) {        }        // X values not sorted.        try {            double xval[] = { 0.0, 1.0, 0.5 };            double yval[] = { 0.0, 1.0, 2.0 };            i.interpolate(xval, yval);            fail("Failed to detect unsorted arguments.");        } catch (IllegalArgumentException iae) {        }    }        /**     * verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length.     */    protected void verifyInterpolation(UnivariateRealFunction f, double x[], double y[])          throws Exception{        for (int i = 0; i < x.length; i++) {            assertEquals(f.value(x[i]), y[i], knotTolerance);        }         }        /**     * Verifies that interpolating polynomials satisfy consistency requirement:     *    adjacent polynomials must agree through two derivatives at knot points     */    protected void verifyConsistency(PolynomialSplineFunction f, double x[])         throws Exception {        PolynomialFunction polynomials[] = f.getPolynomials();        for (int i = 1; i < x.length - 2; i++) {            // evaluate polynomials and derivatives at x[i + 1]              assertEquals(polynomials[i].value(x[i +1] - x[i]), polynomials[i + 1].value(0), 0.1);             assertEquals(polynomials[i].derivative().value(x[i +1] - x[i]),                     polynomials[i + 1].derivative().value(0), 0.5);             assertEquals(polynomials[i].polynomialDerivative().derivative().value(x[i +1] - x[i]),                     polynomials[i + 1].polynomialDerivative().derivative().value(0), 0.5);         }    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.Expm1Function;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import junit.framework.TestCase;/** * Testcase for Neville interpolator. * <p> * The error of polynomial interpolation is *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n! * where f^(n) is the n-th derivative of the approximated function and * zeta is some point in the interval determined by x[] and z. * <p> * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound * it and use the absolute value upper bound for estimates. For reference, * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2. *  * @version $Revision$ $Date$  */public final class NevilleInterpolatorTest extends TestCase {    /**     * Test of interpolator for the sine function.     * <p>     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealInterpolator interpolator = new NevilleInterpolator();        double x[], y[], z, expected, result, tolerance;        // 6 interpolating points on interval [0, 2*PI]        int n = 6;        double min = 0.0, max = 2 * Math.PI;        x = new double[n];        y = new double[n];        for (int i = 0; i < n; i++) {            x[i] = min + i * (max - min) / n;            y[i] = f.value(x[i]);        }        double derivativebound = 1.0;        UnivariateRealFunction p = interpolator.interpolate(x, y);        z = Math.PI / 4; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);    }    /**     * Test of interpolator for the exponential function.     * <p>     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]     */    public void testExpm1Function() throws MathException {        UnivariateRealFunction f = new Expm1Function();        UnivariateRealInterpolator interpolator = new NevilleInterpolator();        double x[], y[], z, expected, result, tolerance;        // 5 interpolating points on interval [-1, 1]        int n = 5;        double min = -1.0, max = 1.0;        x = new double[n];        y = new double[n];        for (int i = 0; i < n; i++) {            x[i] = min + i * (max - min) / n;            y[i] = f.value(x[i]);        }        double derivativebound = Math.E;        UnivariateRealFunction p = interpolator.interpolate(x, y);        z = 0.0; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = 0.5; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = -0.5; expected = f.value(z); result = p.value(z);        tolerance = Math.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the interpolator.     */    public void testParameters() throws Exception {        UnivariateRealInterpolator interpolator = new NevilleInterpolator();        try {            // bad abscissas array            double x[] = { 1.0, 2.0, 2.0, 4.0 };            double y[] = { 0.0, 4.0, 4.0, 2.5 };            UnivariateRealFunction p = interpolator.interpolate(x, y);            p.value(0.0);            fail("Expecting MathException - bad abscissas array");        } catch (MathException ex) {            // expected        }    }    /**     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!     */    protected double partialerror(double x[], double z) throws        IllegalArgumentException {        if (x.length < 1) {            throw new IllegalArgumentException                ("Interpolation array cannot be empty.");        }        double out = 1;        for (int i = 0; i < x.length; i++) {            out *= (z - x[i]) / (i + 1);        }        return out;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.polynomials;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for Lagrange form of polynomial function. * <p> * We use n+1 points to interpolate a polynomial of degree n. This should * give us the exact same polynomial as result. Thus we can use a very * small tolerance to account only for round-off errors. * * @version $Revision$ $Date$  */public final class PolynomialFunctionLagrangeFormTest extends TestCase {    /**     * Test of polynomial for the linear function.     */    public void testLinearFunction() throws MathException {        PolynomialFunctionLagrangeForm p;        double c[], z, expected, result, tolerance = 1E-12;        // p(x) = 1.5x - 4        double x[] = { 0.0, 3.0 };        double y[] = { -4.0, 0.5 };        p = new PolynomialFunctionLagrangeForm(x, y);        z = 2.0; expected = -1.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 4.5; expected = 2.75; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 6.0; expected = 5.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(1, p.degree());        c = p.getCoefficients();        assertEquals(2, c.length);        assertEquals(-4.0, c[0], tolerance);        assertEquals(1.5, c[1], tolerance);    }    /**     * Test of polynomial for the quadratic function.     */    public void testQuadraticFunction() throws MathException {        PolynomialFunctionLagrangeForm p;        double c[], z, expected, result, tolerance = 1E-12;        // p(x) = 2x^2 + 5x - 3 = (2x - 1)(x + 3)        double x[] = { 0.0, -1.0, 0.5 };        double y[] = { -3.0, -6.0, 0.0 };        p = new PolynomialFunctionLagrangeForm(x, y);        z = 1.0; expected = 4.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 2.5; expected = 22.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = -2.0; expected = -5.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(2, p.degree());        c = p.getCoefficients();        assertEquals(3, c.length);        assertEquals(-3.0, c[0], tolerance);        assertEquals(5.0, c[1], tolerance);        assertEquals(2.0, c[2], tolerance);    }    /**     * Test of polynomial for the quintic function.     */    public void testQuinticFunction() throws MathException {        PolynomialFunctionLagrangeForm p;        double c[], z, expected, result, tolerance = 1E-12;        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x = x(x^2 - 1)(x + 2)(x - 3)        double x[] = { 1.0, -1.0, 2.0, 3.0, -3.0, 0.5 };        double y[] = { 0.0, 0.0, -24.0, 0.0, -144.0, 2.34375 };        p = new PolynomialFunctionLagrangeForm(x, y);        z = 0.0; expected = 0.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = -2.0; expected = 0.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 4.0; expected = 360.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(5, p.degree());        c = p.getCoefficients();        assertEquals(6, c.length);        assertEquals(0.0, c[0], tolerance);        assertEquals(6.0, c[1], tolerance);        assertEquals(1.0, c[2], tolerance);        assertEquals(-7.0, c[3], tolerance);        assertEquals(-1.0, c[4], tolerance);        assertEquals(1.0, c[5], tolerance);    }    /**     * Test of parameters for the polynomial.     */    public void testParameters() throws Exception {        try {            // bad input array length            double x[] = { 1.0 };            double y[] = { 2.0 };            new PolynomialFunctionLagrangeForm(x, y);            fail("Expecting IllegalArgumentException - bad input array length");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // mismatch input arrays            double x[] = { 1.0, 2.0, 3.0, 4.0 };            double y[] = { 0.0, -4.0, -24.0 };            new PolynomialFunctionLagrangeForm(x, y);            fail("Expecting IllegalArgumentException - mismatch input arrays");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.polynomials;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for Newton form of polynomial function. * <p> * The small tolerance number is used only to account for round-off errors. * * @version $Revision$ $Date$  */public final class PolynomialFunctionNewtonFormTest extends TestCase {    /**     * Test of polynomial for the linear function.     */    public void testLinearFunction() throws MathException {        PolynomialFunctionNewtonForm p;        double coefficients[], z, expected, result, tolerance = 1E-12;        // p(x) = 1.5x - 4 = 2 + 1.5(x-4)        double a[] = { 2.0, 1.5 };        double c[] = { 4.0 };        p = new PolynomialFunctionNewtonForm(a, c);        z = 2.0; expected = -1.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 4.5; expected = 2.75; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 6.0; expected = 5.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(1, p.degree());        coefficients = p.getCoefficients();        assertEquals(2, coefficients.length);        assertEquals(-4.0, coefficients[0], tolerance);        assertEquals(1.5, coefficients[1], tolerance);    }    /**     * Test of polynomial for the quadratic function.     */    public void testQuadraticFunction() throws MathException {        PolynomialFunctionNewtonForm p;        double coefficients[], z, expected, result, tolerance = 1E-12;        // p(x) = 2x^2 + 5x - 3 = 4 + 3(x-1) + 2(x-1)(x+2)        double a[] = { 4.0, 3.0, 2.0 };        double c[] = { 1.0, -2.0 };        p = new PolynomialFunctionNewtonForm(a, c);        z = 1.0; expected = 4.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 2.5; expected = 22.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = -2.0; expected = -5.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(2, p.degree());        coefficients = p.getCoefficients();        assertEquals(3, coefficients.length);        assertEquals(-3.0, coefficients[0], tolerance);        assertEquals(5.0, coefficients[1], tolerance);        assertEquals(2.0, coefficients[2], tolerance);    }    /**     * Test of polynomial for the quintic function.     */    public void testQuinticFunction() throws MathException {        PolynomialFunctionNewtonForm p;        double coefficients[], z, expected, result, tolerance = 1E-12;        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x        //      = 6x - 6x^2 -6x^2(x-1) + x^2(x-1)(x+1) + x^2(x-1)(x+1)(x-2)        double a[] = { 0.0, 6.0, -6.0, -6.0, 1.0, 1.0 };        double c[] = { 0.0, 0.0, 1.0, -1.0, 2.0 };        p = new PolynomialFunctionNewtonForm(a, c);        z = 0.0; expected = 0.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = -2.0; expected = 0.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 4.0; expected = 360.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(5, p.degree());        coefficients = p.getCoefficients();        assertEquals(6, coefficients.length);        assertEquals(0.0, coefficients[0], tolerance);        assertEquals(6.0, coefficients[1], tolerance);        assertEquals(1.0, coefficients[2], tolerance);        assertEquals(-7.0, coefficients[3], tolerance);        assertEquals(-1.0, coefficients[4], tolerance);        assertEquals(1.0, coefficients[5], tolerance);    }    /**     * Test of parameters for the polynomial.     */    public void testParameters() throws Exception {        try {            // bad input array length            double a[] = { 1.0 };            double c[] = { 2.0 };            new PolynomialFunctionNewtonForm(a, c);            fail("Expecting IllegalArgumentException - bad input array length");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // mismatch input arrays            double a[] = { 1.0, 2.0, 3.0, 4.0 };            double c[] = { 4.0, 3.0, 2.0, 1.0 };            new PolynomialFunctionNewtonForm(a, c);            fail("Expecting IllegalArgumentException - mismatch input arrays");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.polynomials;// commons-mathimport org.apache.commons.math.MathException;// junitimport junit.framework.TestCase;/** * Tests the PolynomialFunction implementation of a UnivariateRealFunction. * * @version $Revision$ * @author Matt Cliff <matt@mattcliff.com> */public final class PolynomialFunctionTest extends TestCase {    /** Error tolerance for tests */    protected double tolerance = 1.0e-12;    /**     * tests the value of a constant polynomial.     *     * <p>value of this is 2.5 everywhere.</p>     */    public void testConstants() throws MathException {        double[] c = { 2.5 };        PolynomialFunction f = new PolynomialFunction( c );        // verify that we are equal to c[0] at several (nonsymmetric) places        assertEquals( f.value( 0.0), c[0], tolerance );        assertEquals( f.value( -1.0), c[0], tolerance );        assertEquals( f.value( -123.5), c[0], tolerance );        assertEquals( f.value( 3.0), c[0], tolerance );        assertEquals( f.value( 456.89), c[0], tolerance );                assertEquals(f.degree(), 0);        assertEquals(f.derivative().value(0), 0, tolerance);                assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);    }    /**     * tests the value of a linear polynomial.     *     * <p>This will test the function f(x) = 3*x - 1.5</p>     * <p>This will have the values      *  <tt>f(0.0) = -1.5, f(-1.0) = -4.5, f(-2.5) = -9.0,     *      f(0.5) = 0.0, f(1.5) = 3.0</tt> and <tt>f(3.0) = 7.5</tt>     * </p>     */    public void testLinear() throws MathException {        double[] c = { -1.5, 3.0 };        PolynomialFunction f = new PolynomialFunction( c );        // verify that we are equal to c[0] when x=0        assertEquals( f.value( 0.0), c[0], tolerance );        // now check a few other places        assertEquals( -4.5, f.value( -1.0), tolerance );        assertEquals( -9.0, f.value( -2.5), tolerance );        assertEquals( 0.0, f.value( 0.5), tolerance );        assertEquals( 3.0, f.value( 1.5), tolerance );        assertEquals( 7.5, f.value( 3.0), tolerance );                assertEquals(f.degree(), 1);                assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);        }    /**     * Tests a second order polynomial.     * <p> This will test the function f(x) = 2x^2 - 3x -2 = (2x+1)(x-2)</p>     *     */    public void testQuadratic() {        double[] c = { -2.0, -3.0, 2.0 };        PolynomialFunction f = new PolynomialFunction( c );        // verify that we are equal to c[0] when x=0        assertEquals( f.value( 0.0), c[0], tolerance );        // now check a few other places        assertEquals( 0.0, f.value( -0.5), tolerance );        assertEquals( 0.0, f.value( 2.0), tolerance );        assertEquals( -2.0, f.value( 1.5), tolerance );        assertEquals( 7.0, f.value( -1.5), tolerance );        assertEquals( 265.5312, f.value( 12.34), tolerance );        }        /**      * This will test the quintic function      *   f(x) = x^2(x-5)(x+3)(x-1) = x^5 - 3x^4 -13x^3 + 15x^2</p>     *     */    public void testQuintic() {        double[] c = { 0.0, 0.0, 15.0, -13.0, -3.0, 1.0 };        PolynomialFunction f = new PolynomialFunction( c );        // verify that we are equal to c[0] when x=0        assertEquals( f.value( 0.0), c[0], tolerance );        // now check a few other places        assertEquals( 0.0, f.value( 5.0), tolerance );        assertEquals( 0.0, f.value( 1.0), tolerance );        assertEquals( 0.0, f.value( -3.0), tolerance );        assertEquals( 54.84375, f.value( -1.5), tolerance );        assertEquals( -8.06637, f.value( 1.3), tolerance );                assertEquals(f.degree(), 5);        }        /**     * tests the firstDerivative function by comparison     *     * <p>This will test the functions      * <tt>f(x) = x^3 - 2x^2 + 6x + 3, g(x) = 3x^2 - 4x + 6</tt>     * and <tt>h(x) = 6x - 4</tt>     */    public void testfirstDerivativeComparison() throws MathException {        double[] f_coeff = { 3.0, 6.0, -2.0, 1.0 };        double[] g_coeff = { 6.0, -4.0, 3.0 };        double[] h_coeff = { -4.0, 6.0 };        PolynomialFunction f = new PolynomialFunction( f_coeff );        PolynomialFunction g = new PolynomialFunction( g_coeff );        PolynomialFunction h = new PolynomialFunction( h_coeff );        // compare f' = g        assertEquals( f.derivative().value(0.0), g.value(0.0), tolerance );        assertEquals( f.derivative().value(1.0), g.value(1.0), tolerance );        assertEquals( f.derivative().value(100.0), g.value(100.0), tolerance );        assertEquals( f.derivative().value(4.1), g.value(4.1), tolerance );        assertEquals( f.derivative().value(-3.25), g.value(-3.25), tolerance );        // compare g' = h        assertEquals( g.derivative().value(Math.PI), h.value(Math.PI), tolerance );        assertEquals( g.derivative().value(Math.E),  h.value(Math.E),  tolerance );    }    public void testString() {        PolynomialFunction p = new PolynomialFunction(new double[] { -5.0, 3.0, 1.0 });        checkPolynomial(p, "-5.0 + 3.0 x + x^2");        checkPolynomial(new PolynomialFunction(new double[] { 0.0, -2.0, 3.0 }),                        "-2.0 x + 3.0 x^2");        checkPolynomial(new PolynomialFunction(new double[] { 1.0, -2.0, 3.0 }),                      "1.0 - 2.0 x + 3.0 x^2");        checkPolynomial(new PolynomialFunction(new double[] { 0.0,  2.0, 3.0 }),                       "2.0 x + 3.0 x^2");        checkPolynomial(new PolynomialFunction(new double[] { 1.0,  2.0, 3.0 }),                     "1.0 + 2.0 x + 3.0 x^2");        checkPolynomial(new PolynomialFunction(new double[] { 1.0,  0.0, 3.0 }),                     "1.0 + 3.0 x^2");        checkPolynomial(new PolynomialFunction(new double[] { 0.0 }),                     "0");    }    public void testAddition() {        PolynomialFunction p1 = new PolynomialFunction(new double[] { -2.0, 1.0 });        PolynomialFunction p2 = new PolynomialFunction(new double[] { 2.0, -1.0, 0.0 });        checkNullPolynomial(p1.add(p2));        p2 = p1.add(p1);        checkPolynomial(p2, "-4.0 + 2.0 x");        p1 = new PolynomialFunction(new double[] { 1.0, -4.0, 2.0 });        p2 = new PolynomialFunction(new double[] { -1.0, 3.0, -2.0 });        p1 = p1.add(p2);        assertEquals(1, p1.degree());        checkPolynomial(p1, "-x");    }    public void testSubtraction() {        PolynomialFunction p1 = new PolynomialFunction(new double[] { -2.0, 1.0 });        checkNullPolynomial(p1.subtract(p1));        PolynomialFunction p2 = new PolynomialFunction(new double[] { -2.0, 6.0 });        p2 = p2.subtract(p1);        checkPolynomial(p2, "5.0 x");        p1 = new PolynomialFunction(new double[] { 1.0, -4.0, 2.0 });        p2 = new PolynomialFunction(new double[] { -1.0, 3.0, 2.0 });        p1 = p1.subtract(p2);        assertEquals(1, p1.degree());        checkPolynomial(p1, "2.0 - 7.0 x");    }    public void testMultiplication() {        PolynomialFunction p1 = new PolynomialFunction(new double[] { -3.0, 2.0 });        PolynomialFunction p2 = new PolynomialFunction(new double[] { 3.0, 2.0, 1.0 });        checkPolynomial(p1.multiply(p2), "-9.0 + x^2 + 2.0 x^3");        p1 = new PolynomialFunction(new double[] { 0.0, 1.0 });        p2 = p1;        for (int i = 2; i < 10; ++i) {            p2 = p2.multiply(p1);            checkPolynomial(p2, "x^" + i);        }    }    public void checkPolynomial(PolynomialFunction p, String reference) {        assertEquals(reference, p.toString());    }    private void checkNullPolynomial(PolynomialFunction p) {        for (double coefficient : p.getCoefficients()) {            assertEquals(0.0, coefficient, 1.0e-15);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.polynomials;import junit.framework.TestCase;/** * Tests the PolynomialsUtils class. * * @version $Revision$ $Date$ */public class PolynomialsUtilsTest extends TestCase {    public void testFirstChebyshevPolynomials() {        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(3), "-3.0 x + 4.0 x^3");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(2), "-1.0 + 2.0 x^2");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(1), "x");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(0), "1.0");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(7), "-7.0 x + 56.0 x^3 - 112.0 x^5 + 64.0 x^7");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(6), "-1.0 + 18.0 x^2 - 48.0 x^4 + 32.0 x^6");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(5), "5.0 x - 20.0 x^3 + 16.0 x^5");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(4), "1.0 - 8.0 x^2 + 8.0 x^4");    }    public void testChebyshevBounds() {        for (int k = 0; k < 12; ++k) {            PolynomialFunction Tk = PolynomialsUtils.createChebyshevPolynomial(k);            for (double x = -1.0; x <= 1.0; x += 0.02) {                assertTrue(k + " " + Tk.value(x), Math.abs(Tk.value(x)) < (1.0 + 1.0e-12));            }        }    }    public void testChebyshevDifferentials() {        for (int k = 0; k < 12; ++k) {            PolynomialFunction Tk0 = PolynomialsUtils.createChebyshevPolynomial(k);            PolynomialFunction Tk1 = Tk0.polynomialDerivative();            PolynomialFunction Tk2 = Tk1.polynomialDerivative();            PolynomialFunction g0 = new PolynomialFunction(new double[] { k * k });            PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -1});            PolynomialFunction g2 = new PolynomialFunction(new double[] { 1, 0, -1 });            PolynomialFunction Tk0g0 = Tk0.multiply(g0);            PolynomialFunction Tk1g1 = Tk1.multiply(g1);            PolynomialFunction Tk2g2 = Tk2.multiply(g2);            checkNullPolynomial(Tk0g0.add(Tk1g1.add(Tk2g2)));        }    }    public void testFirstHermitePolynomials() {        checkPolynomial(PolynomialsUtils.createHermitePolynomial(3), "-12.0 x + 8.0 x^3");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(2), "-2.0 + 4.0 x^2");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(1), "2.0 x");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(0), "1.0");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(7), "-1680.0 x + 3360.0 x^3 - 1344.0 x^5 + 128.0 x^7");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(6), "-120.0 + 720.0 x^2 - 480.0 x^4 + 64.0 x^6");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(5), "120.0 x - 160.0 x^3 + 32.0 x^5");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(4), "12.0 - 48.0 x^2 + 16.0 x^4");    }    public void testHermiteDifferentials() {        for (int k = 0; k < 12; ++k) {            PolynomialFunction Hk0 = PolynomialsUtils.createHermitePolynomial(k);            PolynomialFunction Hk1 = Hk0.polynomialDerivative();            PolynomialFunction Hk2 = Hk1.polynomialDerivative();            PolynomialFunction g0 = new PolynomialFunction(new double[] { 2 * k });            PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -2 });            PolynomialFunction g2 = new PolynomialFunction(new double[] { 1 });            PolynomialFunction Hk0g0 = Hk0.multiply(g0);            PolynomialFunction Hk1g1 = Hk1.multiply(g1);            PolynomialFunction Hk2g2 = Hk2.multiply(g2);            checkNullPolynomial(Hk0g0.add(Hk1g1.add(Hk2g2)));        }    }    public void testFirstLaguerrePolynomials() {        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(3), 6l, "6.0 - 18.0 x + 9.0 x^2 - x^3");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(2), 2l, "2.0 - 4.0 x + x^2");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(1), 1l, "1.0 - x");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(0), 1l, "1.0");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(7), 5040l,                "5040.0 - 35280.0 x + 52920.0 x^2 - 29400.0 x^3"                + " + 7350.0 x^4 - 882.0 x^5 + 49.0 x^6 - x^7");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(6),  720l,                "720.0 - 4320.0 x + 5400.0 x^2 - 2400.0 x^3 + 450.0 x^4"                + " - 36.0 x^5 + x^6");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(5),  120l,        "120.0 - 600.0 x + 600.0 x^2 - 200.0 x^3 + 25.0 x^4 - x^5");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(4),   24l,        "24.0 - 96.0 x + 72.0 x^2 - 16.0 x^3 + x^4");    }    public void testLaguerreDifferentials() {        for (int k = 0; k < 12; ++k) {            PolynomialFunction Lk0 = PolynomialsUtils.createLaguerrePolynomial(k);            PolynomialFunction Lk1 = Lk0.polynomialDerivative();            PolynomialFunction Lk2 = Lk1.polynomialDerivative();            PolynomialFunction g0 = new PolynomialFunction(new double[] { k });            PolynomialFunction g1 = new PolynomialFunction(new double[] { 1, -1 });            PolynomialFunction g2 = new PolynomialFunction(new double[] { 0, 1 });            PolynomialFunction Lk0g0 = Lk0.multiply(g0);            PolynomialFunction Lk1g1 = Lk1.multiply(g1);            PolynomialFunction Lk2g2 = Lk2.multiply(g2);            checkNullPolynomial(Lk0g0.add(Lk1g1.add(Lk2g2)));        }    }    public void testFirstLegendrePolynomials() {        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(3),  2l, "-3.0 x + 5.0 x^3");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(2),  2l, "-1.0 + 3.0 x^2");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(1),  1l, "x");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(0),  1l, "1.0");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(7), 16l, "-35.0 x + 315.0 x^3 - 693.0 x^5 + 429.0 x^7");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(6), 16l, "-5.0 + 105.0 x^2 - 315.0 x^4 + 231.0 x^6");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(5),  8l, "15.0 x - 70.0 x^3 + 63.0 x^5");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(4),  8l, "3.0 - 30.0 x^2 + 35.0 x^4");    }    public void testLegendreDifferentials() {        for (int k = 0; k < 12; ++k) {            PolynomialFunction Pk0 = PolynomialsUtils.createLegendrePolynomial(k);            PolynomialFunction Pk1 = Pk0.polynomialDerivative();            PolynomialFunction Pk2 = Pk1.polynomialDerivative();            PolynomialFunction g0 = new PolynomialFunction(new double[] { k * (k + 1) });            PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -2 });            PolynomialFunction g2 = new PolynomialFunction(new double[] { 1, 0, -1 });            PolynomialFunction Pk0g0 = Pk0.multiply(g0);            PolynomialFunction Pk1g1 = Pk1.multiply(g1);            PolynomialFunction Pk2g2 = Pk2.multiply(g2);            checkNullPolynomial(Pk0g0.add(Pk1g1.add(Pk2g2)));        }    }    public void testHighDegreeLegendre() {        PolynomialsUtils.createLegendrePolynomial(40);        double[] l40 = PolynomialsUtils.createLegendrePolynomial(40).getCoefficients();        double denominator = 274877906944.0;        double[] numerators = new double[] {                          +34461632205.0,            -28258538408100.0,          +3847870979902950.0,        -207785032914759300.0,                  +5929294332103310025.0,     -103301483474866556880.0,    +1197358103913226000200.0,    -9763073770369381232400.0,              +58171647881784229843050.0,  -260061484647976556945400.0,  +888315281771246239250340.0, -2345767627188139419665400.0,            +4819022625419112503443050.0, -7710436200670580005508880.0, +9566652323054238154983240.0, -9104813935044723209570256.0,            +6516550296251767619752905.0, -3391858621221953912598660.0, +1211378079007840683070950.0,  -265365894974690562152100.0,              +26876802183334044115405.0        };        for (int i = 0; i < l40.length; ++i) {            if (i % 2 == 0) {                double ci = numerators[i / 2] / denominator;                assertEquals(ci, l40[i], Math.abs(ci) * 1.0e-15);            } else {                assertEquals(0.0, l40[i], 0.0);            }        }    }    private void checkPolynomial(PolynomialFunction p, long denominator, String reference) {        PolynomialFunction q = new PolynomialFunction(new double[] { denominator});        assertEquals(reference, p.multiply(q).toString());    }    private void checkPolynomial(PolynomialFunction p, String reference) {        assertEquals(reference, p.toString());    }    private void checkNullPolynomial(PolynomialFunction p) {        for (double coefficient : p.getCoefficients()) {            assertEquals(0.0, coefficient, 1.0e-13);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.polynomials;import java.util.Arrays;import junit.framework.TestCase;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.analysis.UnivariateRealFunction;/** * Tests the PolynomialSplineFunction implementation. * * @version $Revision$ */public class PolynomialSplineFunctionTest extends TestCase {    /** Error tolerance for tests */    protected double tolerance = 1.0e-12;        /**      * Quadratic polynomials used in tests:      *      * x^2 + x            [-1, 0)     * x^2 + x + 2        [0, 1)     * x^2 + x + 4        [1, 2)     *      * Defined so that evaluation using PolynomialSplineFunction evaluation     * algorithm agrees at knot point boundaries.     */    protected PolynomialFunction[] polynomials = {        new PolynomialFunction(new double[] {0d, 1d, 1d}),         new PolynomialFunction(new double[] {2d, 1d, 1d}),        new PolynomialFunction(new double[] {4d, 1d, 1d})    };        /** Knot points  */    protected double[] knots = {-1, 0, 1, 2};        /** Derivative of test polynomials -- 2x + 1  */    protected PolynomialFunction dp =         new PolynomialFunction(new double[] {1d, 2d});            public void testConstructor() {        PolynomialSplineFunction spline =             new PolynomialSplineFunction(knots, polynomials);        assertTrue(Arrays.equals(knots, spline.getKnots()));        assertEquals(1d, spline.getPolynomials()[0].getCoefficients()[2], 0);        assertEquals(3, spline.getN());                try { // too few knots            new PolynomialSplineFunction(new double[] {0}, polynomials);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                try { // too many knots            new PolynomialSplineFunction(new double[] {0,1,2,3,4}, polynomials);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                try { // knots not increasing            new PolynomialSplineFunction(new double[] {0,1, 3, 2}, polynomials);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }        public void testValues() throws Exception {        PolynomialSplineFunction spline =             new PolynomialSplineFunction(knots, polynomials);        UnivariateRealFunction dSpline = spline.derivative();                /**         * interior points -- spline value at x should equal p(x - knot)         * where knot is the largest knot point less than or equal to x and p          * is the polynomial defined over the knot segment to which x belongs.         */        double x = -1;        int index = 0;        for (int i = 0; i < 10; i++) {           x+=0.25;           index = findKnot(knots, x);           assertEquals("spline function evaluation failed for x=" + x,                    polynomials[index].value(x - knots[index]), spline.value(x), tolerance);           assertEquals("spline derivative evaluation failed for x=" + x,                   dp.value(x - knots[index]), dSpline.value(x), tolerance);        }                // knot points -- centering should zero arguments        for (int i = 0; i < 3; i++) {            assertEquals("spline function evaluation failed for knot=" + knots[i],                    polynomials[i].value(0), spline.value(knots[i]), tolerance);            assertEquals("spline function evaluation failed for knot=" + knots[i],                    dp.value(0), dSpline.value(knots[i]), tolerance);        }                try { //outside of domain -- under min            x = spline.value(-1.5);            fail("Expecting IllegalArgumentException");        } catch (FunctionEvaluationException ex) {            // expected        }                try { //outside of domain -- over max            x = spline.value(2.5);            fail("Expecting IllegalArgumentException");        } catch (FunctionEvaluationException ex) {            // expected        }             }          /**     *  Do linear search to find largest knot point less than or equal to x.     *  Implementation does binary search.     */     protected int findKnot(double[] knots, double x) {         if (x < knots[0] || x >= knots[knots.length -1]) {             throw new IllegalArgumentException("x is out of range");         }         for (int i = 0; i < knots.length; i++) {             if (knots[i] > x) {                 return i -1;             }         }         throw new IllegalArgumentException("x is out of range");     }}    
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.rank;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class MaxTest extends StorelessUnivariateStatisticAbstractTest{    protected Max stat;        /**     * @param name     */    public MaxTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(MaxTest.class);        suite.setName("Max  Tests");        return suite;    }        /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Max();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.max;    }        public void testSpecialValues() {        double[] testArray = {0d, Double.NaN, Double.NEGATIVE_INFINITY,                 Double.POSITIVE_INFINITY};        Max max = new Max();        assertTrue(Double.isNaN(max.getResult()));        max.increment(testArray[0]);        assertEquals(0d, max.getResult(), 0);        max.increment(testArray[1]);        assertEquals(0d, max.getResult(), 0);        max.increment(testArray[2]);        assertEquals(0d, max.getResult(), 0);        max.increment(testArray[3]);        assertEquals(Double.POSITIVE_INFINITY, max.getResult(), 0);        assertEquals(Double.POSITIVE_INFINITY, max.evaluate(testArray), 0);         }    public void testNaNs() {        Max max = new Max();        double nan = Double.NaN;        assertEquals(3d, max.evaluate(new double[]{nan, 2d, 3d}), 0);             assertEquals(3d, max.evaluate(new double[]{1d, nan, 3d}), 0);             assertEquals(2d, max.evaluate(new double[]{1d, 2d, nan}), 0);             assertTrue(Double.isNaN(max.evaluate(new double[]{nan, nan, nan})));         }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.rank;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class PercentileTest extends UnivariateStatisticAbstractTest{    protected Percentile stat;        /**     * @param name     */    public PercentileTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(PercentileTest.class);        suite.setName("Percentile Tests");        return suite;    }        /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {           return new Percentile(95.0);    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.percentile95;    }    public void testHighPercentile(){        double[] d = new double[]{1, 2, 3};        Percentile p = new Percentile(75);        assertEquals(3.0, p.evaluate(d), 1.0e-5);    }        public void testPercentile() {        double[] d = new double[] {1, 3, 2, 4};        Percentile p = new Percentile(30);        assertEquals(1.5, p.evaluate(d), 1.0e-5);        p.setQuantile(25);        assertEquals(1.25, p.evaluate(d), 1.0e-5);        p.setQuantile(75);        assertEquals(3.75, p.evaluate(d), 1.0e-5);        p.setQuantile(50);        assertEquals(2.5, p.evaluate(d), 1.0e-5);                // invalid percentiles        try {            p.evaluate(d, 0, d.length, -1.0);            fail();        } catch (IllegalArgumentException ex) {            // success        }        try {            p.evaluate(d, 0, d.length, 101.0);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }        public void testNISTExample() {        double[] d = new double[] {95.1772, 95.1567, 95.1937, 95.1959,                 95.1442, 95.0610,  95.1591, 95.1195, 95.1772, 95.0925, 95.1990, 95.1682        };        Percentile p = new Percentile(90);         assertEquals(95.1981, p.evaluate(d), 1.0e-4);        assertEquals(95.1990, p.evaluate(d,0,d.length, 100d), 0);    }        public void test5() {        Percentile percentile = new Percentile(5);        assertEquals(this.percentile5, percentile.evaluate(testArray), getTolerance());    }        public void testNullEmpty() {        Percentile percentile = new Percentile(50);        double[] nullArray = null;        double[] emptyArray = new double[] {};        try {            percentile.evaluate(nullArray);            fail("Expecting IllegalArgumentException for null array");        } catch (IllegalArgumentException ex) {            // expected        }          assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));            }        public void testSingleton() {        Percentile percentile = new Percentile(50);        double[] singletonArray = new double[] {1d};        assertEquals(1d, percentile.evaluate(singletonArray), 0);        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 5), 0);        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 100), 0);         assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0)));         }        public void testSpecialValues() {        Percentile percentile = new Percentile(50);        double[] specialValues = new double[] {0d, 1d, 2d, 3d, 4d,  Double.NaN};        assertEquals(2.5d, percentile.evaluate(specialValues), 0);        specialValues =  new double[] {Double.NEGATIVE_INFINITY, 1d, 2d, 3d,                Double.NaN, Double.POSITIVE_INFINITY};        assertEquals(2.5d, percentile.evaluate(specialValues), 0);        specialValues = new double[] {1d, 1d, Double.POSITIVE_INFINITY,                 Double.POSITIVE_INFINITY};        assertTrue(Double.isInfinite(percentile.evaluate(specialValues)));        specialValues = new double[] {1d, 1d, Double.NaN,                 Double.NaN};        assertTrue(Double.isNaN(percentile.evaluate(specialValues)));        specialValues = new double[] {1d, 1d, Double.NEGATIVE_INFINITY,                 Double.NEGATIVE_INFINITY};        // Interpolation results in NEGATIVE_INFINITY + POSITIVE_INFINITY        assertTrue(Double.isNaN(percentile.evaluate(specialValues)));       }        public void testSetQuantile() {        Percentile percentile = new Percentile(10);        percentile.setQuantile(100); // OK        assertEquals(100, percentile.getQuantile(), 0);              try {            percentile.setQuantile(0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            new Percentile(0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }            }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.rank;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class MedianTest extends UnivariateStatisticAbstractTest{    protected Median stat;        /**     * @param name     */    public MedianTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(MedianTest.class);        suite.setName("Median  Tests");        return suite;    }        /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {          return new Median();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.median;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.rank;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class MinTest extends StorelessUnivariateStatisticAbstractTest{    protected Min stat;        /**     * @param name     */    public MinTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(MinTest.class);        suite.setName("Min  Tests");        return suite;    }        /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Min();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.min;    }        public void testSpecialValues() {        double[] testArray = {0d, Double.NaN, Double.POSITIVE_INFINITY,                 Double.NEGATIVE_INFINITY};        Min min = new Min();        assertTrue(Double.isNaN(min.getResult()));        min.increment(testArray[0]);        assertEquals(0d, min.getResult(), 0);        min.increment(testArray[1]);        assertEquals(0d, min.getResult(), 0);        min.increment(testArray[2]);        assertEquals(0d, min.getResult(), 0);        min.increment(testArray[3]);        assertEquals(Double.NEGATIVE_INFINITY, min.getResult(), 0);        assertEquals(Double.NEGATIVE_INFINITY, min.evaluate(testArray), 0);         }    public void testNaNs() {        Min min = new Min();        double nan = Double.NaN;        assertEquals(2d, min.evaluate(new double[]{nan, 2d, 3d}), 0);             assertEquals(1d, min.evaluate(new double[]{1d, nan, 3d}), 0);             assertEquals(1d, min.evaluate(new double[]{1d, 2d, nan}), 0);             assertTrue(Double.isNaN(min.evaluate(new double[]{nan, nan, nan})));         }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. *  * @version $Revision$ $Date$ */public class StandardDeviationTest extends StorelessUnivariateStatisticAbstractTest{    protected StandardDeviation stat;        /**     * @param name     */    public StandardDeviationTest(String name) {        super(name);    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new StandardDeviation();    }    public static Test suite() {        TestSuite suite = new TestSuite(StandardDeviationTest.class);        suite.setName("StandardDeviation Tests");        return suite;    }        /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.std;    }        /**     * Make sure Double.NaN is returned iff n = 0     *     */    public void testNaN() {        StandardDeviation std = new StandardDeviation();        assertTrue(Double.isNaN(std.getResult()));        std.increment(1d);        assertEquals(0d, std.getResult(), 0);    }        /**     * Test population version of variance     */     public void testPopulation() {        double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};        double sigma = populationStandardDeviation(values);        SecondMoment m = new SecondMoment();        m.evaluate(values);  // side effect is to add values        StandardDeviation s1 = new StandardDeviation();        s1.setBiasCorrected(false);        assertEquals(sigma, s1.evaluate(values), 1E-14);        s1.incrementAll(values);        assertEquals(sigma, s1.getResult(), 1E-14);        s1 = new StandardDeviation(false, m);        assertEquals(sigma, s1.getResult(), 1E-14);             s1 = new StandardDeviation(false);        assertEquals(sigma, s1.evaluate(values), 1E-14);        s1.incrementAll(values);        assertEquals(sigma, s1.getResult(), 1E-14);         }        /**     * Definitional formula for population standard deviation     */    protected double populationStandardDeviation(double[] v) {        double mean = new Mean().evaluate(v);        double sum = 0;        for (int i = 0; i < v.length; i++) {            sum += (v[i] - mean) * (v[i] - mean);         }        return Math.sqrt(sum / v.length);    }}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.DimensionMismatchException;import org.apache.commons.math.TestUtils;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;public class VectorialMeanTestextends TestCase {    public VectorialMeanTest(String name) {        super(name);        points = null;    }    public void testMismatch() {        try {            new VectorialMean(8).increment(new double[5]);            fail("an exception should have been thrown");        } catch (DimensionMismatchException dme) {            assertEquals(5, dme.getDimension1());            assertEquals(8, dme.getDimension2());        } catch (Exception e) {            fail("wrong exception type caught: " + e.getClass().getName());        }    }    public void testSimplistic() throws DimensionMismatchException {        VectorialMean stat = new VectorialMean(2);        stat.increment(new double[] {-1.0,  1.0});        stat.increment(new double[] { 1.0, -1.0});        double[] mean = stat.getResult();        assertEquals(0.0, mean[0], 1.0e-12);        assertEquals(0.0, mean[1], 1.0e-12);    }    public void testBasicStats() throws DimensionMismatchException {        VectorialMean stat = new VectorialMean(points[0].length);        for (int i = 0; i < points.length; ++i) {            stat.increment(points[i]);        }        assertEquals(points.length, stat.getN());        double[] mean = stat.getResult();        double[]   refMean = new double[] { 1.78, 1.62,  3.12};        for (int i = 0; i < mean.length; ++i) {            assertEquals(refMean[i], mean[i], 1.0e-12);        }    }    public void testSerial() throws DimensionMismatchException {        VectorialMean stat = new VectorialMean(points[0].length);        for (int i = 0; i < points.length; ++i) {            stat.increment(points[i]);        }        assertEquals(stat, TestUtils.serializeAndRecover(stat));    }    @Override    public void setUp() {        points = new double[][] {                { 1.2, 2.3,  4.5},                {-0.7, 2.3,  5.0},                { 3.1, 0.0, -3.1},                { 6.0, 1.2,  4.2},                {-0.7, 2.3,  5.0}        };    }    @Override    public void tearDown() {        points = null;    }    public static Test suite() {        return new TestSuite(VectorialMeanTest.class);    }    private double [][] points;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link FourthMoment} class. * @version $Revision$ $Date$ */public class FourthMomentTest extends StorelessUnivariateStatisticAbstractTest{    /** descriptive statistic. */    protected FourthMoment stat;        /**     * @param name     */    public FourthMomentTest(String name) {        super(name);    }        /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new FourthMoment();    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    @Override    public double expectedValue() {       return this.fourthMoment;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link ThirdMoment} class. * @version $Revision$ $Date$ */public class ThirdMomentTest extends StorelessUnivariateStatisticAbstractTest{    /** descriptive statistic. */    protected ThirdMoment stat;        /**     * @param name     */    public ThirdMomentTest(String name) {        super(name);    }        /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new ThirdMoment();    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    @Override    public double expectedValue() {      return this.thirdMoment;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class KurtosisTest extends StorelessUnivariateStatisticAbstractTest{    protected Kurtosis stat;        /**     * @param name     */    public KurtosisTest(String name) {        super(name);    }        public static Test suite() {        TestSuite suite = new TestSuite(KurtosisTest.class);        suite.setName("Kurtosis  Tests");        return suite;    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Kurtosis();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.kurt;    }        /**     * Make sure Double.NaN is returned iff n < 4     *     */    public void testNaN() {        Kurtosis kurt = new Kurtosis();        assertTrue(Double.isNaN(kurt.getResult()));        kurt.increment(1d);        assertTrue(Double.isNaN(kurt.getResult()));        kurt.increment(1d);        assertTrue(Double.isNaN(kurt.getResult()));        kurt.increment(1d);        assertTrue(Double.isNaN(kurt.getResult()));        kurt.increment(1d);        assertFalse(Double.isNaN(kurt.getResult()));          }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. *  * @version $Revision$ $Date$ */public class SkewnessTest extends StorelessUnivariateStatisticAbstractTest{    protected Skewness stat;        /**     * @param name     */    public SkewnessTest(String name) {        super(name);    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Skewness();    }    public static Test suite() {        TestSuite suite = new TestSuite(SkewnessTest.class);        suite.setName("Skewness Tests");        return suite;    }        /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.skew;    }        /**     * Make sure Double.NaN is returned iff n < 3     *     */    public void testNaN() {        Skewness skew = new Skewness();        assertTrue(Double.isNaN(skew.getResult()));        skew.increment(1d);        assertTrue(Double.isNaN(skew.getResult()));        skew.increment(1d);        assertTrue(Double.isNaN(skew.getResult()));        skew.increment(1d);        assertFalse(Double.isNaN(skew.getResult()));          }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. *  * @version $Revision$ $Date$ */public class VarianceTest extends StorelessUnivariateStatisticAbstractTest{    protected Variance stat;        /**     * @param name     */    public VarianceTest(String name) {        super(name);    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Variance();    }    public static Test suite() {        TestSuite suite = new TestSuite(VarianceTest.class);        suite.setName("Variance Tests");        return suite;    }        /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.var;    }        /**     * Make sure Double.NaN is returned iff n = 0     *     */    public void testNaN() {        StandardDeviation std = new StandardDeviation();        assertTrue(Double.isNaN(std.getResult()));        std.increment(1d);        assertEquals(0d, std.getResult(), 0);    }        /**     * Test population version of variance     */     public void testPopulation() {        double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};        SecondMoment m = new SecondMoment();        m.evaluate(values);  // side effect is to add values        Variance v1 = new Variance();        v1.setBiasCorrected(false);        assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);        v1.incrementAll(values);        assertEquals(populationVariance(values), v1.getResult(), 1E-14);        v1 = new Variance(false, m);        assertEquals(populationVariance(values), v1.getResult(), 1E-14);             v1 = new Variance(false);        assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);        v1.incrementAll(values);        assertEquals(populationVariance(values), v1.getResult(), 1E-14);         }        /**     * Definitional formula for population variance     */    protected double populationVariance(double[] v) {        double mean = new Mean().evaluate(v);        double sum = 0;        for (int i = 0; i < v.length; i++) {           sum += (v[i] - mean) * (v[i] - mean);         }        return sum / v.length;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link FirstMoment} class. * @version $Revision$ $Date$ */public class FirstMomentTest extends StorelessUnivariateStatisticAbstractTest{    /** descriptive statistic. */    protected FirstMoment stat;        /**     * @param name     */    public FirstMomentTest(String name) {        super(name);    }        /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new FirstMoment();    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    @Override    public double expectedValue() {        return this.mean;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class GeometricMeanTest extends StorelessUnivariateStatisticAbstractTest{    protected GeometricMean stat;        /**     * @param name     */    public GeometricMeanTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(GeometricMeanTest.class);        suite.setName("Mean  Tests");        return suite;    }        /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new GeometricMean();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.geoMean;    }        public void testSpecialValues() {        GeometricMean mean = new GeometricMean();        // empty        assertTrue(Double.isNaN(mean.getResult()));                // finite data        mean.increment(1d);        assertFalse(Double.isNaN(mean.getResult()));                // add 0 -- makes log sum blow to minus infinity, should make 0        mean.increment(0d);        assertEquals(0d, mean.getResult(), 0);                // add positive infinity - note the minus infinity above        mean.increment(Double.POSITIVE_INFINITY);        assertTrue(Double.isNaN(mean.getResult()));                // clear        mean.clear();        assertTrue(Double.isNaN(mean.getResult()));                // positive infinity by itself        mean.increment(Double.POSITIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, mean.getResult(), 0);                // negative value -- should make NaN        mean.increment(-2d);        assertTrue(Double.isNaN(mean.getResult()));    }}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.DimensionMismatchException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.linear.RealMatrix;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;public class VectorialCovarianceTestextends TestCase {    public VectorialCovarianceTest(String name) {        super(name);        points = null;    }    public void testMismatch() {        try {            new VectorialCovariance(8, true).increment(new double[5]);            fail("an exception should have been thrown");        } catch (DimensionMismatchException dme) {            assertEquals(5, dme.getDimension1());            assertEquals(8, dme.getDimension2());        } catch (Exception e) {            fail("wrong exception type caught: " + e.getClass().getName());        }    }    public void testSimplistic() throws DimensionMismatchException {        VectorialCovariance stat = new VectorialCovariance(2, true);        stat.increment(new double[] {-1.0,  1.0});        stat.increment(new double[] { 1.0, -1.0});        RealMatrix c = stat.getResult();        assertEquals( 2.0, c.getEntry(0, 0), 1.0e-12);        assertEquals(-2.0, c.getEntry(1, 0), 1.0e-12);        assertEquals( 2.0, c.getEntry(1, 1), 1.0e-12);    }    public void testBasicStats() throws DimensionMismatchException {        VectorialCovariance stat = new VectorialCovariance(points[0].length, true);        for (int i = 0; i < points.length; ++i) {            stat.increment(points[i]);        }        assertEquals(points.length, stat.getN());        RealMatrix c = stat.getResult();        double[][] refC    = new double[][] {                { 8.0470, -1.9195, -3.4445},                {-1.9195,  1.0470,  3.2795},                {-3.4445,  3.2795, 12.2070}        };        for (int i = 0; i < c.getRowDimension(); ++i) {            for (int j = 0; j <= i; ++j) {                assertEquals(refC[i][j], c.getEntry(i, j), 1.0e-12);            }        }    }    public void testSerial(){        VectorialCovariance stat = new VectorialCovariance(points[0].length, true);        assertEquals(stat, TestUtils.serializeAndRecover(stat));    }        @Override    public void setUp() {        points = new double[][] {                { 1.2, 2.3,  4.5},                {-0.7, 2.3,  5.0},                { 3.1, 0.0, -3.1},                { 6.0, 1.2,  4.2},                {-0.7, 2.3,  5.0}        };    }    @Override    public void tearDown() {        points = null;    }    public static Test suite() {        return new TestSuite(VectorialCovarianceTest.class);    }    private double [][] points;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link SecondMoment} class. * @version $Revision$ $Date$ */public class SecondMomentTest extends StorelessUnivariateStatisticAbstractTest {    /** descriptive statistic. */    protected SecondMoment stat;        /**     * @param name     */    public SecondMomentTest(String name) {        super(name);    }        /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new SecondMoment();    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    @Override    public double expectedValue() {        return this.secondMoment;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class MeanTest extends StorelessUnivariateStatisticAbstractTest{    protected Mean stat;        /**     * @param name     */    public MeanTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(MeanTest.class);        suite.setName("Mean  Tests");        return suite;    }        /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Mean();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.mean;    }        public void testSmallSamples() {        Mean mean = new Mean();        assertTrue(Double.isNaN(mean.getResult()));        mean.increment(1d);        assertEquals(1d, mean.getResult(), 0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.summary;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link Sum} class. * @version $Revision$ $Date$ */public class SumTest extends StorelessUnivariateStatisticAbstractTest{    protected Sum stat;        /**     * @param name     */    public SumTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SumTest.class);        suite.setName("Sum Tests");        return suite;    }        /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Sum();          }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.sum;    }        public void testSpecialValues() {        Sum sum = new Sum();        assertTrue(Double.isNaN(sum.getResult()));        sum.increment(1);        assertEquals(1, sum.getResult(), 0);        sum.increment(Double.POSITIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);        sum.increment(Double.NEGATIVE_INFINITY);        assertTrue(Double.isNaN(sum.getResult()));        sum.increment(1);        assertTrue(Double.isNaN(sum.getResult()));     }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.summary;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class SumLogTest extends StorelessUnivariateStatisticAbstractTest{    protected SumOfLogs stat;        /**     * @param name     */    public SumLogTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SumLogTest.class);        suite.setName("SumLog Tests");        return suite;    }        /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {                return new SumOfLogs();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.sumLog;    }        public void testSpecialValues() {        SumOfLogs sum = new SumOfLogs();        // empty        assertTrue(Double.isNaN(sum.getResult()));                // finite data        sum.increment(1d);        assertFalse(Double.isNaN(sum.getResult()));                // add negative infinity        sum.increment(0d);        assertEquals(Double.NEGATIVE_INFINITY, sum.getResult(), 0);                // add positive infinity -- should make NaN        sum.increment(Double.POSITIVE_INFINITY);        assertTrue(Double.isNaN(sum.getResult()));                // clear        sum.clear();        assertTrue(Double.isNaN(sum.getResult()));                // positive infinity by itself        sum.increment(Double.POSITIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);                // negative value -- should make NaN        sum.increment(-2d);        assertTrue(Double.isNaN(sum.getResult()));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.summary;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class ProductTest extends StorelessUnivariateStatisticAbstractTest{    protected Product stat;        /**     * @param name     */    public ProductTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(ProductTest.class);        suite.setName("Product Tests");        return suite;    }        /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Product();    }    /**     * {@inheritDoc}     */    @Override    public double getTolerance() {        return 10E8;    //sic -- big absolute error due to only 15 digits of accuracy in double    }        /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.product;    }        public void testSpecialValues() {        Product product = new Product();        assertTrue(Double.isNaN(product.getResult()));        product.increment(1);        assertEquals(1, product.getResult(), 0);        product.increment(Double.POSITIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, product.getResult(), 0);        product.increment(Double.NEGATIVE_INFINITY);        assertEquals(Double.NEGATIVE_INFINITY, product.getResult(), 0);        product.increment(Double.NaN);        assertTrue(Double.isNaN(product.getResult()));         product.increment(1);        assertTrue(Double.isNaN(product.getResult()));     }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.summary;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link SumOfSquares} class. *  * @version $Revision$ $Date$ */public class SumSqTest extends StorelessUnivariateStatisticAbstractTest{    protected SumOfSquares stat;        /**     * @param name     */    public SumSqTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SumSqTest.class);        suite.setName("SumSq Tests");        return suite;    }        /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new SumOfSquares();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.sumSq;    }        public void testSpecialValues() {        SumOfSquares sumSq = new SumOfSquares();        assertTrue(Double.isNaN(sumSq.getResult()));        sumSq.increment(2d);        assertEquals(4d, sumSq.getResult(), 0);        sumSq.increment(Double.POSITIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);        sumSq.increment(Double.NEGATIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);        sumSq.increment(Double.NaN);        assertTrue(Double.isNaN(sumSq.getResult()));         sumSq.increment(1);        assertTrue(Double.isNaN(sumSq.getResult()));     }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import java.io.Serializable;import java.util.ArrayList;import java.util.List;import org.apache.commons.math.util.NumberTransformer;import org.apache.commons.math.util.TransformerMap;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link ListUnivariateImpl} class. * * @version $Revision$ $Date$ */public final class MixedListUnivariateImplTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double tolerance = 10E-15;    private TransformerMap transformers = new TransformerMap();        public MixedListUnivariateImplTest(String name) {        super(name);        transformers = new TransformerMap();        transformers.putTransformer(Foo.class, new FooTransformer());        transformers.putTransformer(Bar.class, new BarTransformer());    }    public static Test suite() {        TestSuite suite = new TestSuite(MixedListUnivariateImplTest.class);        suite.setName("Mixed List Tests");        return suite;    }    /** test stats */    public void testStats() {        List<Object> externalList = new ArrayList<Object>();        DescriptiveStatistics u = new ListUnivariateImpl(externalList,transformers);        assertEquals("total count", 0, u.getN(), tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        assertEquals("N", n, u.getN(), tolerance);        assertEquals("sum", sum, u.getSum(), tolerance);        assertEquals("sumsq", sumSq, u.getSumsq(), tolerance);        assertEquals("var", var, u.getVariance(), tolerance);        assertEquals("std", std, u.getStandardDeviation(), tolerance);        assertEquals("mean", mean, u.getMean(), tolerance);        assertEquals("min", min, u.getMin(), tolerance);        assertEquals("max", max, u.getMax(), tolerance);        u.clear();        assertEquals("total count", 0, u.getN(), tolerance);    }    public void testN0andN1Conditions() throws Exception {        DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);        assertTrue(            "Mean of n = 0 set should be NaN",            Double.isNaN(u.getMean()));        assertTrue(            "Standard Deviation of n = 0 set should be NaN",            Double.isNaN(u.getStandardDeviation()));        assertTrue(            "Variance of n = 0 set should be NaN",            Double.isNaN(u.getVariance()));        u.addValue(one);        assertTrue(            "Mean of n = 1 set should be value of single item n1, instead it is " + u.getMean() ,            u.getMean() == one);                    assertTrue(            "StdDev of n = 1 set should be zero, instead it is: "                + u.getStandardDeviation(),            u.getStandardDeviation() == 0);        assertTrue(            "Variance of n = 1 set should be zero",            u.getVariance() == 0);    }    public void testSkewAndKurtosis() {        ListUnivariateImpl u =            new ListUnivariateImpl(new ArrayList<Object>(), transformers);        u.addObject("12.5");        u.addObject(Integer.valueOf(12));        u.addObject("11.8");        u.addObject("14.2");        u.addObject(new Foo());        u.addObject("14.5");        u.addObject(Long.valueOf(21));        u.addObject("8.2");        u.addObject("10.3");        u.addObject("11.3");        u.addObject(Float.valueOf(14.1f));        u.addObject("9.9");        u.addObject("12.2");        u.addObject(new Bar());        u.addObject("12.1");        u.addObject("11");        u.addObject(Double.valueOf(19.8));        u.addObject("11");        u.addObject("10");        u.addObject("8.8");        u.addObject("9");        u.addObject("12.3");        assertEquals("mean", 12.40455, u.getMean(), 0.0001);        assertEquals("variance", 10.00236, u.getVariance(), 0.0001);        assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);        assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);        u.setWindowSize(10);        u.addValue(1.0);        u.addValue(2.0);        u.addValue(3.0);        u.addValue(4.0);        assertEquals(            "Geometric mean not expected",            2.213364,            u.getGeometricMean(),            0.00001);        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution        // of a discarded element        for (int i = 0; i < 10; i++) {            u.addValue(i + 2);        }        // Values should be (2,3,4,5,6,7,8,9,10,11)        assertEquals(            "Geometric mean not expected",            5.755931,            u.getGeometricMean(),            0.00001);    }    public static final class Foo {        public String heresFoo() {            return "14.9";        }    }    public static final class FooTransformer implements NumberTransformer, Serializable {        private static final long serialVersionUID = -4252248129291326127L;        public double transform(Object o) {            return Double.parseDouble(((Foo) o).heresFoo());        }    }    public static final class Bar {        public String heresBar() {            return "12.0";        }    }    public static final class BarTransformer implements NumberTransformer, Serializable {        private static final long serialVersionUID = -1768345377764262043L;        public double transform(Object o) {            return Double.parseDouble(((Bar) o).heresBar());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.Test;import junit.framework.TestSuite;/** * Test cases for the {@link SynchronizedDescriptiveStatisticsTest} class. * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug *          2007) $ */public final class SynchronizedDescriptiveStatisticsTest extends DescriptiveStatisticsTest {    public SynchronizedDescriptiveStatisticsTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SynchronizedDescriptiveStatisticsTest.class);        suite.setName("SynchronizedDescriptiveStatistics Tests");        return suite;    }    protected DescriptiveStatistics createDescriptiveStatistics() {        return new SynchronizedDescriptiveStatistics();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;/** * Test cases for the {@link StatisticalSummaryValues} class. * * @version $Revision$ $Date$ */public final class StatisticalSummaryValuesTest extends TestCase {            public StatisticalSummaryValuesTest(String name) {        super(name);    }        public static Test suite() {        TestSuite suite = new TestSuite(StatisticalSummaryValuesTest.class);        suite.setName("StatisticalSummaryValues Tests");        return suite;    }          public void testSerialization() {        StatisticalSummaryValues u = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);        TestUtils.checkSerializedEquality(u);         StatisticalSummaryValues t = (StatisticalSummaryValues) TestUtils.serializeAndRecover(u);        verifyEquality(u, t);    }        public void testEqualsAndHashCode() {        StatisticalSummaryValues u  = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);        StatisticalSummaryValues t = null;        assertTrue("reflexive", u.equals(u));        assertFalse("non-null compared to null", u.equals(t));        assertFalse("wrong type", u.equals(Double.valueOf(0)));        t = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);        assertTrue("instances with same data should be equal", t.equals(u));        assertEquals("hash code", u.hashCode(), t.hashCode());                u = new StatisticalSummaryValues(Double.NaN, 2, 3, 4, 5, 6);        t = new StatisticalSummaryValues(1, Double.NaN, 3, 4, 5, 6);        assertFalse("instances based on different data should be different",                 (u.equals(t) ||t.equals(u)));    }        private void verifyEquality(StatisticalSummaryValues s, StatisticalSummaryValues u) {        assertEquals("N",s.getN(),u.getN());        TestUtils.assertEquals("sum",s.getSum(),u.getSum(), 0);        TestUtils.assertEquals("var",s.getVariance(),u.getVariance(), 0);        TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(), 0);        TestUtils.assertEquals("mean",s.getMean(),u.getMean(), 0);        TestUtils.assertEquals("min",s.getMin(),u.getMin(), 0);        TestUtils.assertEquals("max",s.getMax(),u.getMax(), 0);       }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.TestCase;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public abstract class UnivariateStatisticAbstractTest extends TestCase {    protected double mean = 12.404545454545455d;    protected double geoMean = 12.070589161633011d;    protected double var = 10.00235930735931d;    protected double std = Math.sqrt(var);    protected double skew = 1.437423729196190d;    protected double kurt = 2.377191264804700d;    protected double min = 8.2d;    protected double max = 21d;    protected double median = 12d;    protected double percentile5 = 8.29d;    protected double percentile95 = 20.82d;    protected double product = 628096400563833396009676.9200400128d;    protected double sumLog = 54.7969806116451507d;    protected double sumSq = 3595.250d;    protected double sum = 272.90d;    protected double secondMoment = 210.04954545454547d;    protected double thirdMoment = 868.0906859504136;    protected double fourthMoment = 9244.080993773481;    protected double tolerance = 10E-12;    protected double[] testArray =        {12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3,          14.1, 9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10,  8.8,           9, 12.3 };    public UnivariateStatisticAbstractTest(String name) {        super(name);    }    public abstract UnivariateStatistic getUnivariateStatistic();    public abstract double expectedValue();    public double getTolerance() {        return tolerance;    }    public void testEvaluation() throws Exception {           assertEquals(            expectedValue(),            getUnivariateStatistic().evaluate(testArray),            getTolerance());    }        public void testCopy() throws Exception {        UnivariateStatistic original = getUnivariateStatistic();        UnivariateStatistic copy = original.copy();        assertEquals(                expectedValue(),                copy.evaluate(testArray),                getTolerance());    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.rank.Percentile;import org.apache.commons.math.util.MathUtils;/** * Test cases for the DescriptiveStatistics class. *  * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug *          2007) $ */public class DescriptiveStatisticsTest extends TestCase {    public DescriptiveStatisticsTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(DescriptiveStatisticsTest.class);        suite.setName("DescriptiveStatistics Tests");        return suite;    }        public void testSetterInjection() throws Exception {        DescriptiveStatistics stats = new DescriptiveStatistics();        stats.addValue(1);        stats.addValue(3);        assertEquals(2, stats.getMean(), 1E-10);        // Now lets try some new math        stats.setMeanImpl(new deepMean());        assertEquals(42, stats.getMean(), 1E-10);    }        public void testPercentileSetter() throws Exception {        DescriptiveStatistics stats = new DescriptiveStatistics();        stats.addValue(1);        stats.addValue(2);        stats.addValue(3);        assertEquals(2, stats.getPercentile(50.0), 1E-10);                // Inject wrapped Percentile impl        stats.setPercentileImpl(new goodPercentile());        assertEquals(2, stats.getPercentile(50.0), 1E-10);                // Try "new math" impl        stats.setPercentileImpl(new subPercentile());        assertEquals(10.0, stats.getPercentile(10.0), 1E-10);                // Try to set bad impl        try {            stats.setPercentileImpl(new badPercentile());             fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testRemoval() {        final DescriptiveStatistics dstat = new DescriptiveStatistics();        checkremoval(dstat, 1, 6.0, 0.0, Double.NaN);        checkremoval(dstat, 3, 5.0, 3.0, 4.5);        checkremoval(dstat, 6, 3.5, 2.5, 3.0);        checkremoval(dstat, 9, 3.5, 2.5, 3.0);        checkremoval(dstat, DescriptiveStatistics.INFINITE_WINDOW, 3.5, 2.5, 3.0);    }    public void checkremoval(DescriptiveStatistics dstat, int wsize,                             double mean1, double mean2, double mean3) {        dstat.setWindowSize(wsize);        dstat.clear();        for (int i = 1 ; i <= 6 ; ++i) {            dstat.addValue(i);        }        assertTrue(MathUtils.equals(mean1, dstat.getMean()));        dstat.replaceMostRecentValue(0);        assertTrue(MathUtils.equals(mean2, dstat.getMean()));        dstat.removeMostRecentValue();        assertTrue(MathUtils.equals(mean3, dstat.getMean()));    }        // Test UnivariateStatistics impls for setter injection tests        /**     * A new way to compute the mean      */    static class deepMean implements UnivariateStatistic {        public double evaluate(double[] values, int begin, int length) {            return 42;        }        public double evaluate(double[] values) {            return 42;        }          public UnivariateStatistic copy() {            return new deepMean();        }    }        /**     * Test percentile implementation - wraps a Percentile     */    static class goodPercentile implements UnivariateStatistic {        private Percentile percentile = new Percentile();        public void setQuantile(double quantile) {            percentile.setQuantile(quantile);        }        public double evaluate(double[] values, int begin, int length) {            return percentile.evaluate(values, begin, length);        }        public double evaluate(double[] values) {            return percentile.evaluate(values);        }          public UnivariateStatistic copy() {            goodPercentile result = new goodPercentile();            result.setQuantile(percentile.getQuantile());            return result;        }    }        /**     * Test percentile subclass - another "new math" impl     * Always returns currently set quantile     */    static class subPercentile extends Percentile {        @Override        public double evaluate(double[] values, int begin, int length) {            return getQuantile();        }        @Override        public double evaluate(double[] values) {            return getQuantile();        }          private static final long serialVersionUID = 8040701391045914979L;        @Override        public Percentile copy() {            subPercentile result = new subPercentile();            return result;        }    }        /**     * "Bad" test percentile implementation - no setQuantile     */    static class badPercentile implements UnivariateStatistic {        private Percentile percentile = new Percentile();        public double evaluate(double[] values, int begin, int length) {            return percentile.evaluate(values, begin, length);        }        public double evaluate(double[] values) {            return percentile.evaluate(values);        }        public UnivariateStatistic copy() {            return new badPercentile();        }    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.moment.Mean;/** * Tests for AbstractUnivariateStatistic  * * @version $Revision$ $Date$ */public class AbstractUnivariateStatisticTest extends TestCase {        public AbstractUnivariateStatisticTest(String name) {        super(name);    }        public static Test suite() {        TestSuite suite = new TestSuite(AbstractUnivariateStatisticTest.class);        suite.setName("AbstractUnivariateStatistic Tests");        return suite;    }        protected double[] testArray = {0, 1, 2, 3, 4, 5};    protected double[] nullArray = null;    protected double[] singletonArray = {0};    protected Mean testStatistic = new Mean();        public void testTestPositive() {        for (int j = 0; j < 6; j++) {            for (int i = 1; i < (7 - j); i++) {                assertTrue(testStatistic.test(testArray, 0, i));            }          }        assertTrue(testStatistic.test(singletonArray, 0, 1));    }        public void testTestNegative() {        assertFalse(testStatistic.test(singletonArray, 0, 0));        assertFalse(testStatistic.test(testArray, 0, 0));        try {            testStatistic.test(singletonArray, 2, 1);  // start past end            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, 0, 7);  // end past end            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, -1, 1);  // start negative            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, 0, -1);  // length negative            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(nullArray, 0, 1);  // null array            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }          } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import java.util.ArrayList;import java.util.List;import org.apache.commons.math.TestUtils;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link ListUnivariateImpl} class. * * @version $Revision$ $Date$ */public final class ListUnivariateImplTest extends TestCase {        private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double tolerance = 10E-15;        public ListUnivariateImplTest(String name) {        super(name);    }        public static Test suite() {        TestSuite suite = new TestSuite(ListUnivariateImplTest.class);        suite.setName("Frequency Tests");        return suite;    }        /** test stats */    public void testStats() {        List<Object> externalList = new ArrayList<Object>();                DescriptiveStatistics u = new ListUnivariateImpl( externalList );         assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }             public void testN0andN1Conditions() throws Exception {        List<Object> list = new ArrayList<Object>();                DescriptiveStatistics u = new ListUnivariateImpl( list );                        assertTrue("Mean of n = 0 set should be NaN", Double.isNaN( u.getMean() ) );        assertTrue("Standard Deviation of n = 0 set should be NaN", Double.isNaN( u.getStandardDeviation() ) );        assertTrue("Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance() ) );        list.add( Double.valueOf(one));        assertTrue( "Mean of n = 1 set should be value of single item n1", u.getMean() == one);        assertTrue( "StdDev of n = 1 set should be zero, instead it is: " + u.getStandardDeviation(), u.getStandardDeviation() == 0);        assertTrue( "Variance of n = 1 set should be zero", u.getVariance() == 0);      }        public void testSkewAndKurtosis() {        DescriptiveStatistics u = new DescriptiveStatistics();                double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,                                             9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };        for( int i = 0; i < testArray.length; i++) {            u.addValue( testArray[i]);        }                assertEquals("mean", 12.40455, u.getMean(), 0.0001);        assertEquals("variance", 10.00236, u.getVariance(), 0.0001);        assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);        assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>());        u.setWindowSize(10);                        u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001 );        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution        // of a discarded element        for( int i = 0; i < 10; i++ ) {            u.addValue( i + 2 );        }        // Values should be (2,3,4,5,6,7,8,9,10,11)                assertEquals( "Geometric mean not expected", 5.755931, u.getGeometricMean(), 0.00001 );    }        /** test stats */    public void testSerialization() {                DescriptiveStatistics u = new ListUnivariateImpl();                assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);                DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u);          u2.addValue(two);        u2.addValue(three);                assertEquals("N",n,u2.getN(),tolerance);        assertEquals("sum",sum,u2.getSum(),tolerance);        assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance);        assertEquals("var",var,u2.getVariance(),tolerance);        assertEquals("std",std,u2.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u2.getMean(),tolerance);        assertEquals("min",min,u2.getMin(),tolerance);        assertEquals("max",max,u2.getMax(),tolerance);        u2.clear();        assertEquals("total count",0,u2.getN(),tolerance);        }       }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.Test;import junit.framework.TestSuite;/** * Test cases for the {@link SynchronizedSummaryStatisticsTest} class. * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug *          2007) $ */public final class SynchronizedSummaryStatisticsTest extends SummaryStatisticsTest {    public SynchronizedSummaryStatisticsTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SynchronizedSummaryStatisticsTest.class);        suite.setName("SynchronizedSummaryStatistics Tests");        return suite;    }    @Override    protected SummaryStatistics createSummaryStatistics() {        return new SynchronizedSummaryStatistics();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.moment.Mean;import org.apache.commons.math.stat.descriptive.summary.Sum;/** * Test cases for the {@link SummaryStatistics} class. * * @version $Revision$ $Date$ */public class SummaryStatisticsTest extends TestCase {    private double one = 1;    private float twoF = 2;    private long twoL = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double tolerance = 10E-15;    public static Test suite() {        TestSuite suite = new TestSuite(SummaryStatisticsTest.class);        suite.setName("SummaryStatistics tests");        return suite;    }    public SummaryStatisticsTest(String name) {        super(name);    }        protected SummaryStatistics createSummaryStatistics() {        return new SummaryStatistics();    }    /** test stats */    public void testStats() {        SummaryStatistics u = createSummaryStatistics();        assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(twoF);        u.addValue(twoL);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }         public void testN0andN1Conditions() throws Exception {        SummaryStatistics u = createSummaryStatistics();        assertTrue("Mean of n = 0 set should be NaN",                 Double.isNaN( u.getMean() ) );        assertTrue("Standard Deviation of n = 0 set should be NaN",                 Double.isNaN( u.getStandardDeviation() ) );        assertTrue("Variance of n = 0 set should be NaN",                 Double.isNaN(u.getVariance() ) );        /* n=1 */        u.addValue(one);        assertTrue("mean should be one (n = 1)",                 u.getMean() == one);        assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(),                 u.getGeometricMean() == one);        assertTrue("Std should be zero (n = 1)",                 u.getStandardDeviation() == 0.0);        assertTrue("variance should be zero (n = 1)",                 u.getVariance() == 0.0);        /* n=2 */                       u.addValue(twoF);        assertTrue("Std should not be zero (n = 2)",                 u.getStandardDeviation() != 0.0);        assertTrue("variance should not be zero (n = 2)",                 u.getVariance() != 0.0);    }    public void testProductAndGeometricMean() throws Exception {        SummaryStatistics u = createSummaryStatistics();        u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        assertEquals( "Geometric mean not expected", 2.213364,                 u.getGeometricMean(), 0.00001 );    }    public void testNaNContracts() {        SummaryStatistics u = createSummaryStatistics();        assertTrue("mean not NaN",Double.isNaN(u.getMean()));         assertTrue("min not NaN",Double.isNaN(u.getMin()));         assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation()));         assertTrue("var not NaN",Double.isNaN(u.getVariance()));         assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));        u.addValue(1.0);        assertEquals( "mean not expected", 1.0,                 u.getMean(), Double.MIN_VALUE);        assertEquals( "variance not expected", 0.0,                 u.getVariance(), Double.MIN_VALUE);        assertEquals( "geometric mean not expected", 1.0,                 u.getGeometricMean(), Double.MIN_VALUE);        u.addValue(-1.0);        assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));        u.addValue(0.0);        assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));        //FiXME: test all other NaN contract specs    }    public void testGetSummary() {        SummaryStatistics u = createSummaryStatistics();        StatisticalSummary summary = u.getSummary();        verifySummary(u, summary);        u.addValue(1d);        summary = u.getSummary();        verifySummary(u, summary);        u.addValue(2d);        summary = u.getSummary();        verifySummary(u, summary);        u.addValue(2d);        summary = u.getSummary();        verifySummary(u, summary);         }    public void testSerialization() {        SummaryStatistics u = createSummaryStatistics();        // Empty test        TestUtils.checkSerializedEquality(u);        SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);        StatisticalSummary summary = s.getSummary();        verifySummary(u, summary);        // Add some data        u.addValue(2d);        u.addValue(1d);        u.addValue(3d);        u.addValue(4d);        u.addValue(5d);        // Test again        TestUtils.checkSerializedEquality(u);        s = (SummaryStatistics) TestUtils.serializeAndRecover(u);        summary = s.getSummary();        verifySummary(u, summary);    }    public void testEqualsAndHashCode() {        SummaryStatistics u = createSummaryStatistics();        SummaryStatistics t = null;        int emptyHash = u.hashCode();        assertTrue("reflexive", u.equals(u));        assertFalse("non-null compared to null", u.equals(t));        assertFalse("wrong type", u.equals(Double.valueOf(0)));        t = createSummaryStatistics();        assertTrue("empty instances should be equal", t.equals(u));        assertTrue("empty instances should be equal", u.equals(t));        assertEquals("empty hash code", emptyHash, t.hashCode());        // Add some data to u        u.addValue(2d);        u.addValue(1d);        u.addValue(3d);        u.addValue(4d);        assertFalse("different n's should make instances not equal", t.equals(u));        assertFalse("different n's should make instances not equal", u.equals(t));        assertTrue("different n's should make hashcodes different",                 u.hashCode() != t.hashCode());        //Add data in same order to t        t.addValue(2d);        t.addValue(1d);        t.addValue(3d);        t.addValue(4d);        assertTrue("summaries based on same data should be equal", t.equals(u));        assertTrue("summaries based on same data should be equal", u.equals(t));        assertEquals("summaries based on same data should have same hashcodes",                 u.hashCode(), t.hashCode());           // Clear and make sure summaries are indistinguishable from empty summary        u.clear();        t.clear();        assertTrue("empty instances should be equal", t.equals(u));        assertTrue("empty instances should be equal", u.equals(t));        assertEquals("empty hash code", emptyHash, t.hashCode());        assertEquals("empty hash code", emptyHash, u.hashCode());    }        public void testCopy() throws Exception {        SummaryStatistics u = createSummaryStatistics();        u.addValue(2d);        u.addValue(1d);        u.addValue(3d);        u.addValue(4d);        SummaryStatistics v = new SummaryStatistics(u);        assertEquals(u, v);        assertEquals(v, u);        assertTrue(v.geoMean == v.getGeoMeanImpl());        assertTrue(v.mean == v.getMeanImpl());        assertTrue(v.min == v.getMinImpl());        assertTrue(v.max == v.getMaxImpl());        assertTrue(v.sum == v.getSumImpl());        assertTrue(v.sumsq == v.getSumsqImpl());        assertTrue(v.sumLog == v.getSumLogImpl());        assertTrue(v.variance == v.getVarianceImpl());                // Make sure both behave the same with additional values added        u.addValue(7d);        u.addValue(9d);        u.addValue(11d);        u.addValue(23d);        v.addValue(7d);        v.addValue(9d);        v.addValue(11d);        v.addValue(23d);        assertEquals(u, v);        assertEquals(v, u);                // Check implementation pointers are preserved        u.clear();        u.setSumImpl(new Sum());        SummaryStatistics.copy(u,v);        assertEquals(u.sum, v.sum);        assertEquals(u.getSumImpl(), v.getSumImpl());            }    private void verifySummary(SummaryStatistics u, StatisticalSummary s) {        assertEquals("N",s.getN(),u.getN());        TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);        TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);        TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);        TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);        TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);        TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);       }    public void testSetterInjection() throws Exception {        SummaryStatistics u = createSummaryStatistics();        u.setMeanImpl(new Sum());        u.setSumLogImpl(new Sum());        u.addValue(1);        u.addValue(3);        assertEquals(4, u.getMean(), 1E-14);        assertEquals(4, u.getSumOfLogs(), 1E-14);        assertEquals(Math.exp(2), u.getGeometricMean(), 1E-14);        u.clear();        u.addValue(1);        u.addValue(2);        assertEquals(3, u.getMean(), 1E-14);        u.clear();        u.setMeanImpl(new Mean()); // OK after clear    }        public void testSetterIllegalState() throws Exception {        SummaryStatistics u = createSummaryStatistics();        u.addValue(1);        u.addValue(3);        try {            u.setMeanImpl(new Sum());            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for {@link AggregateSummaryStatistics} * */public class AggregateSummaryStatisticsTest extends TestCase {        /**     * Tests the standard aggregation behavior     */    public void testAggregation() {        AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();        SummaryStatistics setOneStats = aggregate.createContributingStatistics();        SummaryStatistics setTwoStats = aggregate.createContributingStatistics();                assertNotNull("The set one contributing stats are null", setOneStats);        assertNotNull("The set two contributing stats are null", setTwoStats);        assertNotSame("Contributing stats objects are the same", setOneStats, setTwoStats);                setOneStats.addValue(2);        setOneStats.addValue(3);        setOneStats.addValue(5);        setOneStats.addValue(7);        setOneStats.addValue(11);        assertEquals("Wrong number of set one values", 5, setOneStats.getN());        assertEquals("Wrong sum of set one values", 28.0, setOneStats.getSum());                setTwoStats.addValue(2);        setTwoStats.addValue(4);        setTwoStats.addValue(8);        assertEquals("Wrong number of set two values", 3, setTwoStats.getN());        assertEquals("Wrong sum of set two values", 14.0, setTwoStats.getSum());                assertEquals("Wrong number of aggregate values", 8, aggregate.getN());        assertEquals("Wrong aggregate sum", 42.0, aggregate.getSum());    }    /**     * Creates and returns a {@code Test} representing all the test cases in this     * class     *     * @return a {@code Test} representing all the test cases in this class     */    public static Test suite() {        TestSuite suite = new TestSuite(AggregateSummaryStatisticsTest.class);        suite.setName("AggregateSummaryStatistics tests");        return suite;    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.DimensionMismatchException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.moment.Mean;/** * Test cases for the {@link MultivariateSummaryStatistics} class. * * @version $Revision$ $Date$ */public class MultivariateSummaryStatisticsTest extends TestCase {    public MultivariateSummaryStatisticsTest(String name) {        super(name);    }        public static Test suite() {        TestSuite suite = new TestSuite(MultivariateSummaryStatisticsTest.class);        suite.setName("MultivariateSummaryStatistics tests");        return suite;    }    public void testSetterInjection() throws Exception {        MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(2, true);        u.setMeanImpl(new StorelessUnivariateStatistic[] {                        new sumMean(), new sumMean()                      });        u.addValue(new double[] { 1, 2 });        u.addValue(new double[] { 3, 4 });        assertEquals(4, u.getMean()[0], 1E-14);        assertEquals(6, u.getMean()[1], 1E-14);        u.clear();        u.addValue(new double[] { 1, 2 });        u.addValue(new double[] { 3, 4 });        assertEquals(4, u.getMean()[0], 1E-14);        assertEquals(6, u.getMean()[1], 1E-14);        u.clear();        u.setMeanImpl(new StorelessUnivariateStatistic[] {                        new Mean(), new Mean()                      }); // OK after clear        u.addValue(new double[] { 1, 2 });        u.addValue(new double[] { 3, 4 });        assertEquals(2, u.getMean()[0], 1E-14);        assertEquals(3, u.getMean()[1], 1E-14);    }        public void testSetterIllegalState() throws Exception {        MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(2, true);        u.addValue(new double[] { 1, 2 });        u.addValue(new double[] { 3, 4 });        try {            u.setMeanImpl(new StorelessUnivariateStatistic[] {                            new sumMean(), new sumMean()                          });            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {            // expected        }    }        /**     * Bogus mean implementation to test setter injection.     * Returns the sum instead of the mean.     */    static class sumMean implements StorelessUnivariateStatistic {           private double sum = 0;        private long n = 0;        public double evaluate(double[] values, int begin, int length) {            return 0;        }        public double evaluate(double[] values) {            return 0;        }        public void clear() {          sum = 0;           n = 0;        }        public long getN() {            return n;        }        public double getResult() {            return sum;        }        public void increment(double d) {            sum += d;            n++;        }        public void incrementAll(double[] values, int start, int length) {        }        public void incrementAll(double[] values) {        }           public StorelessUnivariateStatistic copy() {            return new sumMean();        }    }    public void testDimension() {        try {            new MultivariateSummaryStatistics(2, true).addValue(new double[3]);        } catch (DimensionMismatchException dme) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test stats */    public void testStats() throws DimensionMismatchException {        MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(2, true);        assertEquals(0, u.getN());        u.addValue(new double[] { 1, 2 });        u.addValue(new double[] { 2, 3 });        u.addValue(new double[] { 2, 3 });        u.addValue(new double[] { 3, 4 });        assertEquals( 4, u.getN());        assertEquals( 8, u.getSum()[0], 1.0e-10);        assertEquals(12, u.getSum()[1], 1.0e-10);        assertEquals(18, u.getSumSq()[0], 1.0e-10);        assertEquals(38, u.getSumSq()[1], 1.0e-10);        assertEquals( 1, u.getMin()[0], 1.0e-10);        assertEquals( 2, u.getMin()[1], 1.0e-10);        assertEquals( 3, u.getMax()[0], 1.0e-10);        assertEquals( 4, u.getMax()[1], 1.0e-10);        assertEquals(2.4849066497880003102, u.getSumLog()[0], 1.0e-10);        assertEquals( 4.276666119016055311, u.getSumLog()[1], 1.0e-10);        assertEquals( 1.8612097182041991979, u.getGeometricMean()[0], 1.0e-10);        assertEquals( 2.9129506302439405217, u.getGeometricMean()[1], 1.0e-10);        assertEquals( 2, u.getMean()[0], 1.0e-10);        assertEquals( 3, u.getMean()[1], 1.0e-10);        assertEquals(Math.sqrt(2.0 / 3.0), u.getStandardDeviation()[0], 1.0e-10);        assertEquals(Math.sqrt(2.0 / 3.0), u.getStandardDeviation()[1], 1.0e-10);        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 0), 1.0e-10);        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 1), 1.0e-10);        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 0), 1.0e-10);        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 1), 1.0e-10);        u.clear();        assertEquals(0, u.getN());        }         public void testN0andN1Conditions() throws Exception {        MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(1, true);        assertTrue(Double.isNaN(u.getMean()[0]));        assertTrue(Double.isNaN(u.getStandardDeviation()[0]));        /* n=1 */        u.addValue(new double[] { 1 });        assertEquals(1.0, u.getMean()[0], 1.0e-10);        assertEquals(1.0, u.getGeometricMean()[0], 1.0e-10);        assertEquals(0.0, u.getStandardDeviation()[0], 1.0e-10);        /* n=2 */                       u.addValue(new double[] { 2 });        assertTrue(u.getStandardDeviation()[0] > 0);    }    public void testNaNContracts() throws DimensionMismatchException {        MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(1, true);        assertTrue(Double.isNaN(u.getMean()[0]));         assertTrue(Double.isNaN(u.getMin()[0]));         assertTrue(Double.isNaN(u.getStandardDeviation()[0]));         assertTrue(Double.isNaN(u.getGeometricMean()[0]));        u.addValue(new double[] { 1.0 });        assertFalse(Double.isNaN(u.getMean()[0]));         assertFalse(Double.isNaN(u.getMin()[0]));         assertFalse(Double.isNaN(u.getStandardDeviation()[0]));         assertFalse(Double.isNaN(u.getGeometricMean()[0]));    }    public void testSerialization() throws DimensionMismatchException {        MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(2, true);        // Empty test        TestUtils.checkSerializedEquality(u);        MultivariateSummaryStatistics s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u);        assertEquals(u, s);        // Add some data        u.addValue(new double[] { 2d, 1d });        u.addValue(new double[] { 1d, 1d });        u.addValue(new double[] { 3d, 1d });        u.addValue(new double[] { 4d, 1d });        u.addValue(new double[] { 5d, 1d });        // Test again        TestUtils.checkSerializedEquality(u);        s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u);        assertEquals(u, s);    }    public void testEqualsAndHashCode() throws DimensionMismatchException {        MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(2, true);        MultivariateSummaryStatistics t = null;        int emptyHash = u.hashCode();        assertTrue(u.equals(u));        assertFalse(u.equals(t));        assertFalse(u.equals(Double.valueOf(0)));        t = new MultivariateSummaryStatistics(2, true);        assertTrue(t.equals(u));        assertTrue(u.equals(t));        assertEquals(emptyHash, t.hashCode());        // Add some data to u        u.addValue(new double[] { 2d, 1d });        u.addValue(new double[] { 1d, 1d });        u.addValue(new double[] { 3d, 1d });        u.addValue(new double[] { 4d, 1d });        u.addValue(new double[] { 5d, 1d });        assertFalse(t.equals(u));        assertFalse(u.equals(t));        assertTrue(u.hashCode() != t.hashCode());        //Add data in same order to t        t.addValue(new double[] { 2d, 1d });        t.addValue(new double[] { 1d, 1d });        t.addValue(new double[] { 3d, 1d });        t.addValue(new double[] { 4d, 1d });        t.addValue(new double[] { 5d, 1d });        assertTrue(t.equals(u));        assertTrue(u.equals(t));        assertEquals(u.hashCode(), t.hashCode());           // Clear and make sure summaries are indistinguishable from empty summary        u.clear();        t.clear();        assertTrue(t.equals(u));        assertTrue(u.equals(t));        assertEquals(emptyHash, t.hashCode());        assertEquals(emptyHash, u.hashCode());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import org.apache.commons.math.stat.descriptive.moment.FourthMoment;import org.apache.commons.math.stat.descriptive.moment.Kurtosis;import org.apache.commons.math.stat.descriptive.moment.Mean;import org.apache.commons.math.stat.descriptive.moment.Skewness;import org.apache.commons.math.stat.descriptive.moment.Variance;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class InteractionTest extends TestCase {    protected double mean = 12.40454545454550;    protected double var = 10.00235930735930;    protected double skew = 1.437423729196190;    protected double kurt = 2.377191264804700;    protected double tolerance = 10E-12;    protected double[] testArray =        {            12.5,            12,            11.8,            14.2,            14.9,            14.5,            21,            8.2,            10.3,            11.3,            14.1,            9.9,            12.2,            12,            12.1,            11,            19.8,            11,            10,            8.8,            9,            12.3 };    public InteractionTest(String name) {        super(name);    }    public void testInteraction() {                FourthMoment m4 = new FourthMoment();        Mean m = new Mean(m4);        Variance v = new Variance(m4);        Skewness s= new Skewness(m4);        Kurtosis k = new Kurtosis(m4);        for (int i = 0; i < testArray.length; i++){            m4.increment(testArray[i]);        }                assertEquals(mean,m.getResult(),tolerance);        assertEquals(var,v.getResult(),tolerance);        assertEquals(skew ,s.getResult(),tolerance);        assertEquals(kurt,k.getResult(),tolerance);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.moment.SecondMoment;/** * Test cases for {@link StorelessUnivariateStatistic} classes. * @version $Revision$ $Date$ */public abstract class StorelessUnivariateStatisticAbstractTest    extends UnivariateStatisticAbstractTest {    public StorelessUnivariateStatisticAbstractTest(String name) {        super(name);    }        /** Small sample arrays */    protected double[][] smallSamples = {{}, {1}, {1,2}, {1,2,3}, {1,2,3,4}};    /** Return a new instance of the statistic */    @Override    public abstract UnivariateStatistic getUnivariateStatistic();    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */    @Override    public abstract double expectedValue();        /**      *  Verifies that increment() and incrementAll work properly.      */    public void testIncrementation() throws Exception {        StorelessUnivariateStatistic statistic =            (StorelessUnivariateStatistic) getUnivariateStatistic();                // Add testArray one value at a time and check result        for (int i = 0; i < testArray.length; i++) {            statistic.increment(testArray[i]);        }                assertEquals(expectedValue(), statistic.getResult(), getTolerance());        assertEquals(testArray.length, statistic.getN());        statistic.clear();                // Add testArray all at once and check again        statistic.incrementAll(testArray);        assertEquals(expectedValue(), statistic.getResult(), getTolerance());        assertEquals(testArray.length, statistic.getN());                statistic.clear();                // Cleared        assertTrue(Double.isNaN(statistic.getResult()));        assertEquals(0, statistic.getN());    }    public void testSerialization() throws Exception {        StorelessUnivariateStatistic statistic =            (StorelessUnivariateStatistic) getUnivariateStatistic();                TestUtils.checkSerializedEquality(statistic);        statistic.clear();        for (int i = 0; i < testArray.length; i++) {            statistic.increment(testArray[i]);            if(i % 5 == 0)                statistic = (StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);         }                TestUtils.checkSerializedEquality(statistic);                assertEquals(expectedValue(), statistic.getResult(), getTolerance());        statistic.clear();        assertTrue(Double.isNaN(statistic.getResult()));    }        public void testEqualsAndHashCode() {        StorelessUnivariateStatistic statistic =            (StorelessUnivariateStatistic) getUnivariateStatistic();        StorelessUnivariateStatistic statistic2 = null;                assertTrue("non-null, compared to null", !statistic.equals(statistic2));        assertTrue("reflexive, non-null", statistic.equals(statistic));                int emptyHash = statistic.hashCode();        statistic2 = (StorelessUnivariateStatistic) getUnivariateStatistic();        assertTrue("empty stats should be equal", statistic.equals(statistic2));        assertEquals("empty stats should have the same hashcode",                 emptyHash, statistic2.hashCode());                statistic.increment(1d);        assertTrue("reflexive, non-empty", statistic.equals(statistic));        assertTrue("non-empty, compared to empty", !statistic.equals(statistic2));        assertTrue("non-empty, compared to empty", !statistic2.equals(statistic));        assertTrue("non-empty stat should have different hashcode from empty stat",                statistic.hashCode() != emptyHash);                statistic2.increment(1d);        assertTrue("stats with same data should be equal", statistic.equals(statistic2));        assertEquals("stats with same data should have the same hashcode",                 statistic.hashCode(), statistic2.hashCode());                statistic.increment(Double.POSITIVE_INFINITY);        assertTrue("stats with different n's should not be equal", !statistic2.equals(statistic));        assertTrue("stats with different n's should have different hashcodes",                statistic.hashCode() != statistic2.hashCode());                statistic2.increment(Double.POSITIVE_INFINITY);        assertTrue("stats with same data should be equal", statistic.equals(statistic2));        assertEquals("stats with same data should have the same hashcode",                 statistic.hashCode(), statistic2.hashCode());                 statistic.clear();        statistic2.clear();        assertTrue("cleared stats should be equal", statistic.equals(statistic2));        assertEquals("cleared stats should have thashcode of empty stat",                 emptyHash, statistic2.hashCode());        assertEquals("cleared stats should have thashcode of empty stat",                 emptyHash, statistic.hashCode());            }        public void testMomentSmallSamples() {        UnivariateStatistic stat = getUnivariateStatistic();        if (stat instanceof SecondMoment) {            SecondMoment moment = (SecondMoment) getUnivariateStatistic();            assertTrue(Double.isNaN(moment.getResult()));            moment.increment(1d);            assertEquals(0d, moment.getResult(), 0);        }    }        /**      * Make sure that evaluate(double[]) and inrementAll(double[]),      * getResult() give same results.     */    public void testConsistency() {        StorelessUnivariateStatistic stat = (StorelessUnivariateStatistic) getUnivariateStatistic();        stat.incrementAll(testArray);        assertEquals(stat.getResult(), stat.evaluate(testArray), getTolerance());        for (int i = 0; i < smallSamples.length; i++) {            stat.clear();            for (int j =0; j < smallSamples[i].length; j++) {                stat.increment(smallSamples[i][j]);            }            TestUtils.assertEquals(stat.getResult(), stat.evaluate(smallSamples[i]), getTolerance());        }    }        /**     * Verifies that copied statistics remain equal to originals when     * incremented the same way.     *     */    public void testCopyConsistency() {                StorelessUnivariateStatistic master =            (StorelessUnivariateStatistic) getUnivariateStatistic();                StorelessUnivariateStatistic replica = null;                // Randomly select a portion of testArray to load first        long index = Math.round((Math.random()) * testArray.length);                // Put first half in master and copy master to replica        master.incrementAll(testArray, 0, (int) index);        replica = master.copy();                // Check same        assertTrue(replica.equals(master));        assertTrue(master.equals(replica));                // Now add second part to both and check again        master.incrementAll(testArray,                 (int) index, (int) (testArray.length - index));        replica.incrementAll(testArray,                 (int) index, (int) (testArray.length - index));        assertTrue(replica.equals(master));        assertTrue(master.equals(replica));    }        public void testSerial() {        StorelessUnivariateStatistic s =            (StorelessUnivariateStatistic) getUnivariateStatistic();        assertEquals(s, TestUtils.serializeAndRecover(s));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.SummaryStatistics;/** * Test cases for the TTestImpl class. * * @version $Revision$ $Date$ */public class TTestTest extends TestCase {    protected TTest testStatistic = new TTestImpl();        private double[] tooShortObs = { 1.0 };    private double[] emptyObs = {};    private SummaryStatistics emptyStats = new SummaryStatistics();     SummaryStatistics tooShortStats = null;      public TTestTest(String name) {        super(name);    }    @Override    public void setUp() {        tooShortStats = new SummaryStatistics();        tooShortStats.addValue(0d);    }    public static Test suite() {        TestSuite suite = new TestSuite(TTestTest.class);        suite.setName("TestStatistic Tests");        return suite;    }    public void testOneSampleT() throws Exception {        double[] observed =            {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0,  88.0, 98.0, 94.0, 101.0, 92.0, 95.0 };        double mu = 100.0;        SummaryStatistics sampleStats = null;        sampleStats = new SummaryStatistics();        for (int i = 0; i < observed.length; i++) {            sampleStats.addValue(observed[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("t statistic",  -2.81976445346,                testStatistic.t(mu, observed), 10E-10);        assertEquals("t statistic",  -2.81976445346,                testStatistic.t(mu, sampleStats), 10E-10);        assertEquals("p value", 0.0136390585873,                testStatistic.tTest(mu, observed), 10E-10);        assertEquals("p value", 0.0136390585873,                testStatistic.tTest(mu, sampleStats), 10E-10);        try {            testStatistic.t(mu, (double[]) null);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(mu, (SummaryStatistics) null);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(mu, emptyObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }         try {            testStatistic.t(mu, emptyStats);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(mu, tooShortObs);            fail("insufficient data to compute t statistic, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.tTest(mu, tooShortObs);            fail("insufficient data to perform t test, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {           // expected        }          try {            testStatistic.t(mu, tooShortStats);            fail("insufficient data to compute t statistic, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.tTest(mu, tooShortStats);            fail("insufficient data to perform t test, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }      }        public void testOneSampleTTest() throws Exception {        double[] oneSidedP =            {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d };        SummaryStatistics oneSidedPStats = new SummaryStatistics();            for (int i = 0; i < oneSidedP.length; i++) {            oneSidedPStats.addValue(oneSidedP[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("one sample t stat", 3.86485535541,                 testStatistic.t(0d, oneSidedP), 10E-10);        assertEquals("one sample t stat", 3.86485535541,                 testStatistic.t(0d, oneSidedPStats),1E-10);        assertEquals("one sample p value", 0.000521637019637,                testStatistic.tTest(0d, oneSidedP) / 2d, 10E-10);        assertEquals("one sample p value", 0.000521637019637,                testStatistic.tTest(0d, oneSidedPStats) / 2d, 10E-5);        assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedP, 0.01));        assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedPStats, 0.01));        assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedP, 0.0001));        assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedPStats, 0.0001));                 try {            testStatistic.tTest(0d, oneSidedP, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            testStatistic.tTest(0d, oneSidedPStats, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }              }        public void testTwoSampleTHeterscedastic() throws Exception {        double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };        double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };        SummaryStatistics sampleStats1 = new SummaryStatistics();          for (int i = 0; i < sample1.length; i++) {            sampleStats1.addValue(sample1[i]);        }        SummaryStatistics sampleStats2 = new SummaryStatistics();            for (int i = 0; i < sample2.length; i++) {            sampleStats2.addValue(sample2[i]);        }                 // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("two sample heteroscedastic t stat", 1.60371728768,                 testStatistic.t(sample1, sample2), 1E-10);        assertEquals("two sample heteroscedastic t stat", 1.60371728768,                 testStatistic.t(sampleStats1, sampleStats2), 1E-10);        assertEquals("two sample heteroscedastic p value", 0.128839369622,                 testStatistic.tTest(sample1, sample2), 1E-10);        assertEquals("two sample heteroscedastic p value", 0.128839369622,                 testStatistic.tTest(sampleStats1, sampleStats2), 1E-10);             assertTrue("two sample heteroscedastic t-test reject",                 testStatistic.tTest(sample1, sample2, 0.2));        assertTrue("two sample heteroscedastic t-test reject",                 testStatistic.tTest(sampleStats1, sampleStats2, 0.2));        assertTrue("two sample heteroscedastic t-test accept",                 !testStatistic.tTest(sample1, sample2, 0.1));        assertTrue("two sample heteroscedastic t-test accept",                 !testStatistic.tTest(sampleStats1, sampleStats2, 0.1));             try {            testStatistic.tTest(sample1, sample2, .95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                 try {            testStatistic.tTest(sampleStats1, sampleStats2, .95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected         }                  try {            testStatistic.tTest(sample1, tooShortObs, .01);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            testStatistic.tTest(sampleStats1, tooShortStats, .01);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            testStatistic.tTest(sample1, tooShortObs);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {           // expected        }                  try {            testStatistic.tTest(sampleStats1, tooShortStats);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            testStatistic.t(sample1, tooShortObs);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                try {            testStatistic.t(sampleStats1, tooShortStats);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {           // expected        }    }    public void testTwoSampleTHomoscedastic() throws Exception {        double[] sample1 ={2, 4, 6, 8, 10, 97};        double[] sample2 = {4, 6, 8, 10, 16};        SummaryStatistics sampleStats1 = new SummaryStatistics();          for (int i = 0; i < sample1.length; i++) {            sampleStats1.addValue(sample1[i]);        }        SummaryStatistics sampleStats2 = new SummaryStatistics();            for (int i = 0; i < sample2.length; i++) {            sampleStats2.addValue(sample2[i]);        }                // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("two sample homoscedastic t stat", 0.73096310086,               testStatistic.homoscedasticT(sample1, sample2), 10E-11);        assertEquals("two sample homoscedastic p value", 0.4833963785,                 testStatistic.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);             assertTrue("two sample homoscedastic t-test reject",                 testStatistic.homoscedasticTTest(sample1, sample2, 0.49));        assertTrue("two sample homoscedastic t-test accept",                 !testStatistic.homoscedasticTTest(sample1, sample2, 0.48));    }        public void testSmallSamples() throws Exception {        double[] sample1 = {1d, 3d};        double[] sample2 = {4d, 5d};                        // Target values computed using R, version 1.8.1 (linux version)        assertEquals(-2.2360679775, testStatistic.t(sample1, sample2),                1E-10);        assertEquals(0.198727388935, testStatistic.tTest(sample1, sample2),                1E-10);    }        public void testPaired() throws Exception {        double[] sample1 = {1d, 3d, 5d, 7d};        double[] sample2 = {0d, 6d, 11d, 2d};        double[] sample3 = {5d, 7d, 8d, 10d};        // Target values computed using R, version 1.8.1 (linux version)        assertEquals(-0.3133, testStatistic.pairedT(sample1, sample2), 1E-4);        assertEquals(0.774544295819, testStatistic.pairedTTest(sample1, sample2), 1E-10);        assertEquals(0.001208, testStatistic.pairedTTest(sample1, sample3), 1E-6);        assertFalse(testStatistic.pairedTTest(sample1, sample3, .001));        assertTrue(testStatistic.pairedTTest(sample1, sample3, .002));        }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import java.util.ArrayList;import java.util.List;/** * Test cases for the OneWayAnovaImpl class. * * @version $Revision$ $Date$ */public class OneWayAnovaTest extends TestCase {    protected OneWayAnova testStatistic = new OneWayAnovaImpl();        private double[] emptyArray = {};    private double[] classA =            {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };    private double[] classB =            {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };    private double[] classC =            {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };    public OneWayAnovaTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(OneWayAnovaTest.class);        suite.setName("TestStatistic Tests");        return suite;    }    public void testAnovaFValue() throws Exception {        // Target comparison values computed using R version 2.6.0 (Linux version)        List<double[]> threeClasses = new ArrayList<double[]>();        threeClasses.add(classA);        threeClasses.add(classB);        threeClasses.add(classC);        assertEquals("ANOVA F-value",  24.67361709460624,                 testStatistic.anovaFValue(threeClasses), 1E-12);        List<double[]> twoClasses = new ArrayList<double[]>();        twoClasses.add(classA);        twoClasses.add(classB);                assertEquals("ANOVA F-value",  0.0150579150579,                 testStatistic.anovaFValue(twoClasses), 1E-12);        List<double[]> emptyContents = new ArrayList<double[]>();        emptyContents.add(emptyArray);        emptyContents.add(classC);        try {            testStatistic.anovaFValue(emptyContents);            fail("empty array for key classX, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }          List<double[]> tooFew = new ArrayList<double[]>();        tooFew.add(classA);        try {            testStatistic.anovaFValue(tooFew);            fail("less than two classes, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }      }        public void testAnovaPValue() throws Exception {        // Target comparison values computed using R version 2.6.0 (Linux version)        List<double[]> threeClasses = new ArrayList<double[]>();        threeClasses.add(classA);        threeClasses.add(classB);        threeClasses.add(classC);        assertEquals("ANOVA P-value", 6.959446E-06,                 testStatistic.anovaPValue(threeClasses), 1E-12);        List<double[]> twoClasses = new ArrayList<double[]>();        twoClasses.add(classA);        twoClasses.add(classB);                assertEquals("ANOVA P-value",  0.904212960464,                 testStatistic.anovaPValue(twoClasses), 1E-12);    }    public void testAnovaTest() throws Exception {        // Target comparison values computed using R version 2.3.1 (Linux version)        List<double[]> threeClasses = new ArrayList<double[]>();        threeClasses.add(classA);        threeClasses.add(classB);        threeClasses.add(classC);        assertTrue("ANOVA Test P<0.01", testStatistic.anovaTest(threeClasses, 0.01));        List<double[]> twoClasses = new ArrayList<double[]>();        twoClasses.add(classA);        twoClasses.add(classB);                assertFalse("ANOVA Test P>0.01", testStatistic.anovaTest(twoClasses, 0.01));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import junit.framework.Test;import junit.framework.TestSuite;/** * Test cases for the ChiSquareTestFactory. * * @version $Revision$ $Date$ */public class ChiSquareFactoryTest extends ChiSquareTestTest {    public ChiSquareFactoryTest(String name) {        super(name);    }    @Override    public void setUp() throws Exception {    super.setUp();        testStatistic = TestUtils.getUnknownDistributionChiSquareTest();    }    public static Test suite() {        TestSuite suite = new TestSuite(ChiSquareFactoryTest.class);        suite.setName("ChiSquareTestFactory Tests");        return suite;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import junit.framework.Test;import junit.framework.TestSuite;/** * Test cases for the TTestTestFactory. * * @version $Revision$ $Date$ */public class TTestFactoryTest extends TTestTest {    public TTestFactoryTest(String name) {        super(name);    }    @Override    public void setUp() {    super.setUp();        testStatistic = TestUtils.getTTest();    }    public static Test suite() {        TestSuite suite = new TestSuite(TTestFactoryTest.class);        suite.setName("TTestFactory Tests");        return suite;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the ChiSquareTestImpl class. * * @version $Revision$ $Date$ */public class ChiSquareTestTest extends TestCase {    protected UnknownDistributionChiSquareTest testStatistic = new ChiSquareTestImpl();    public ChiSquareTestTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(ChiSquareTestTest.class);        suite.setName("TestStatistic Tests");        return suite;    }    public void testChiSquare() throws Exception {         // Target values computed using R version 1.8.1         // Some assembly required ;-)          //      Use sum((obs - exp)^2/exp) for the chi-square statistic and        //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value                long[] observed = {10, 9, 11};        double[] expected = {10, 10, 10};        assertEquals("chi-square statistic", 0.2,  testStatistic.chiSquare(expected, observed), 10E-12);        assertEquals("chi-square p-value", 0.904837418036, testStatistic.chiSquareTest(expected, observed), 1E-10);                long[] observed1 = { 500, 623, 72, 70, 31 };        double[] expected1 = { 485, 541, 82, 61, 37 };        assertEquals( "chi-square test statistic", 9.023307936427388, testStatistic.chiSquare(expected1, observed1), 1E-10);        assertEquals("chi-square p-value", 0.06051952647453607, testStatistic.chiSquareTest(expected1, observed1), 1E-9);        assertTrue("chi-square test reject", testStatistic.chiSquareTest(expected1, observed1, 0.08));        assertTrue("chi-square test accept", !testStatistic.chiSquareTest(expected1, observed1, 0.05));        try {            testStatistic.chiSquareTest(expected1, observed1, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  long[] tooShortObs = { 0 };        double[] tooShortEx = { 1 };        try {            testStatistic.chiSquare(tooShortEx, tooShortObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        // unmatched arrays        long[] unMatchedObs = { 0, 1, 2, 3 };        double[] unMatchedEx = { 1, 1, 2 };        try {            testStatistic.chiSquare(unMatchedEx, unMatchedObs);            fail("arrays have different lengths, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                // 0 expected count        expected[0] = 0;        try {            testStatistic.chiSquareTest(expected, observed, .01);            fail("bad expected count, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                 // negative observed count        expected[0] = 1;        observed[0] = -1;        try {            testStatistic.chiSquareTest(expected, observed, .01);            fail("bad expected count, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }             }    public void testChiSquareIndependence() throws Exception {                // Target values computed using R version 1.8.1                 long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};        assertEquals( "chi-square test statistic", 22.709027688, testStatistic.chiSquare(counts), 1E-9);        assertEquals("chi-square p-value", 0.000144751460134, testStatistic.chiSquareTest(counts), 1E-9);        assertTrue("chi-square test reject", testStatistic.chiSquareTest(counts, 0.0002));        assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts, 0.0001));                    long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };        assertEquals( "chi-square test statistic", 0.168965517241, testStatistic.chiSquare(counts2), 1E-9);        assertEquals("chi-square p-value",0.918987499852, testStatistic.chiSquareTest(counts2), 1E-9);        assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts2, 0.1));                 // ragged input array        long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};        try {            testStatistic.chiSquare(counts3);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                // insufficient data        long[][] counts4 = {{40, 22, 43}};        try {            testStatistic.chiSquare(counts4);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }         long[][] counts5 = {{40}, {40}, {30}, {10}};        try {            testStatistic.chiSquare(counts5);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                 // negative counts        long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };        try {            testStatistic.chiSquare(counts6);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                 // bad alpha        try {            testStatistic.chiSquareTest(counts, 0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }     }        public void testChiSquareLargeTestStatistic() throws Exception {        double[] exp = new double[] {            3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0,             232921.0, 437665.75        };        long[] obs = new long[] {            2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899        };        org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =            new org.apache.commons.math.stat.inference.ChiSquareTestImpl();         double cst = csti.chiSquareTest(exp, obs);         assertEquals("chi-square p-value", 0.0, cst, 1E-3);        assertEquals( "chi-square test statistic",                 114875.90421929007, testStatistic.chiSquare(exp, obs), 1E-9);    }        /** Contingency table containing zeros - PR # 32531 */    public void testChiSquareZeroCount() throws Exception {        // Target values computed using R version 1.8.1         long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};        assertEquals( "chi-square test statistic", 9.67444662263,                testStatistic.chiSquare(counts), 1E-9);        assertEquals("chi-square p-value", 0.0462835770603,                testStatistic.chiSquareTest(counts), 1E-9);           }        /** Target values verified using DATAPLOT version 2006.3 */    public void testChiSquareDataSetsComparisonEqualCounts()    throws Exception {        long[] observed1 = {10, 12, 12, 10};        long[] observed2 = {5, 15, 14, 10};            assertEquals("chi-square p value", 0.541096,                 testStatistic.chiSquareTestDataSetsComparison(                observed1, observed2), 1E-6);        assertEquals("chi-square test statistic", 2.153846,                testStatistic.chiSquareDataSetsComparison(                observed1, observed2), 1E-6);        assertFalse("chi-square test result",                 testStatistic.chiSquareTestDataSetsComparison(                observed1, observed2, 0.4));    }        /** Target values verified using DATAPLOT version 2006.3 */    public void testChiSquareDataSetsComparisonUnEqualCounts()    throws Exception {        long[] observed1 = {10, 12, 12, 10, 15};        long[] observed2 = {15, 10, 10, 15, 5};            assertEquals("chi-square p value", 0.124115,                 testStatistic.chiSquareTestDataSetsComparison(                observed1, observed2), 1E-6);        assertEquals("chi-square test statistic", 7.232189,                testStatistic.chiSquareDataSetsComparison(                observed1, observed2), 1E-6);        assertTrue("chi-square test result",                 testStatistic.chiSquareTestDataSetsComparison(                observed1, observed2, 0.13));        assertFalse("chi-square test result",                 testStatistic.chiSquareTestDataSetsComparison(                observed1, observed2, 0.12));    }        public void testChiSquareDataSetsComparisonBadCounts()    throws Exception {        long[] observed1 = {10, -1, 12, 10, 15};        long[] observed2 = {15, 10, 10, 15, 5};        try {            testStatistic.chiSquareTestDataSetsComparison(                    observed1, observed2);            fail("Expecting IllegalArgumentException - negative count");        } catch (IllegalArgumentException ex) {            // expected        }        long[] observed3 = {10, 0, 12, 10, 15};        long[] observed4 = {15, 0, 10, 15, 5};        try {            testStatistic.chiSquareTestDataSetsComparison(                    observed3, observed4);            fail("Expecting IllegalArgumentException - double 0's");        } catch (IllegalArgumentException ex) {            // expected        }        long[] observed5 = {10, 10, 12, 10, 15};        long[] observed6 = {0, 0, 0, 0, 0};        try {            testStatistic.chiSquareTestDataSetsComparison(                    observed5, observed6);            fail("Expecting IllegalArgumentException - vanishing counts");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import java.util.ArrayList;import java.util.List;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.stat.descriptive.SummaryStatistics;/** * Test cases for the TestUtils class. * * @version $Revision$ $Date$ */public class TestUtilsTest extends TestCase {    public TestUtilsTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(TestUtilsTest.class);        suite.setName("TestUtils Tests");        return suite;    }    public void testChiSquare() throws Exception {                // Target values computed using R version 1.8.1         // Some assembly required ;-)          //      Use sum((obs - exp)^2/exp) for the chi-square statistic and        //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value                long[] observed = {10, 9, 11};        double[] expected = {10, 10, 10};        assertEquals("chi-square statistic", 0.2,  TestUtils.chiSquare(expected, observed), 10E-12);        assertEquals("chi-square p-value", 0.904837418036, TestUtils.chiSquareTest(expected, observed), 1E-10);                long[] observed1 = { 500, 623, 72, 70, 31 };        double[] expected1 = { 485, 541, 82, 61, 37 };        assertEquals( "chi-square test statistic", 9.023307936427388, TestUtils.chiSquare(expected1, observed1), 1E-10);        assertEquals("chi-square p-value", 0.06051952647453607, TestUtils.chiSquareTest(expected1, observed1), 1E-9);        assertTrue("chi-square test reject", TestUtils.chiSquareTest(expected1, observed1, 0.07));        assertTrue("chi-square test accept", !TestUtils.chiSquareTest(expected1, observed1, 0.05));        try {            TestUtils.chiSquareTest(expected1, observed1, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  long[] tooShortObs = { 0 };        double[] tooShortEx = { 1 };        try {            TestUtils.chiSquare(tooShortEx, tooShortObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        // unmatched arrays        long[] unMatchedObs = { 0, 1, 2, 3 };        double[] unMatchedEx = { 1, 1, 2 };        try {            TestUtils.chiSquare(unMatchedEx, unMatchedObs);            fail("arrays have different lengths, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                // 0 expected count        expected[0] = 0;        try {            TestUtils.chiSquareTest(expected, observed, .01);            fail("bad expected count, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                 // negative observed count        expected[0] = 1;        observed[0] = -1;        try {            TestUtils.chiSquareTest(expected, observed, .01);            fail("bad expected count, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }             }    public void testChiSquareIndependence() throws Exception {                // Target values computed using R version 1.8.1                 long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};        assertEquals( "chi-square test statistic", 22.709027688, TestUtils.chiSquare(counts), 1E-9);        assertEquals("chi-square p-value", 0.000144751460134, TestUtils.chiSquareTest(counts), 1E-9);        assertTrue("chi-square test reject", TestUtils.chiSquareTest(counts, 0.0002));        assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts, 0.0001));                    long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };        assertEquals( "chi-square test statistic", 0.168965517241, TestUtils.chiSquare(counts2), 1E-9);        assertEquals("chi-square p-value",0.918987499852, TestUtils.chiSquareTest(counts2), 1E-9);        assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts2, 0.1));                 // ragged input array        long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};        try {            TestUtils.chiSquare(counts3);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                // insufficient data        long[][] counts4 = {{40, 22, 43}};        try {            TestUtils.chiSquare(counts4);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }         long[][] counts5 = {{40}, {40}, {30}, {10}};        try {            TestUtils.chiSquare(counts5);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                 // negative counts        long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };        try {            TestUtils.chiSquare(counts6);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                 // bad alpha        try {            TestUtils.chiSquareTest(counts, 0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }     }        public void testChiSquareLargeTestStatistic() throws Exception {        double[] exp = new double[] {                3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0,                 232921.0, 437665.75        };        long[] obs = new long[] {                2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899        };        org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =            new org.apache.commons.math.stat.inference.ChiSquareTestImpl();         double cst = csti.chiSquareTest(exp, obs);         assertEquals("chi-square p-value", 0.0, cst, 1E-3);        assertEquals( "chi-square test statistic",                 114875.90421929007, TestUtils.chiSquare(exp, obs), 1E-9);    }        /** Contingency table containing zeros - PR # 32531 */    public void testChiSquareZeroCount() throws Exception {        // Target values computed using R version 1.8.1         long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};        assertEquals( "chi-square test statistic", 9.67444662263,                TestUtils.chiSquare(counts), 1E-9);        assertEquals("chi-square p-value", 0.0462835770603,                TestUtils.chiSquareTest(counts), 1E-9);           }        private double[] tooShortObs = { 1.0 };    private double[] emptyObs = {};    private SummaryStatistics emptyStats = new SummaryStatistics();      public void testOneSampleT() throws Exception {        double[] observed =            {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0,  88.0, 98.0, 94.0, 101.0, 92.0, 95.0 };        double mu = 100.0;        SummaryStatistics sampleStats = null;        sampleStats = new SummaryStatistics();        for (int i = 0; i < observed.length; i++) {            sampleStats.addValue(observed[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("t statistic",  -2.81976445346,                TestUtils.t(mu, observed), 10E-10);        assertEquals("t statistic",  -2.81976445346,                TestUtils.t(mu, sampleStats), 10E-10);        assertEquals("p value", 0.0136390585873,                TestUtils.tTest(mu, observed), 10E-10);        assertEquals("p value", 0.0136390585873,                TestUtils.tTest(mu, sampleStats), 10E-10);        try {            TestUtils.t(mu, (double[]) null);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(mu, (SummaryStatistics) null);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(mu, emptyObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                try {            TestUtils.t(mu, emptyStats);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(mu, tooShortObs);            fail("insufficient data to compute t statistic, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(mu, tooShortObs);            fail("insufficient data to perform t test, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }          try {            TestUtils.t(mu, (SummaryStatistics) null);            fail("insufficient data to compute t statistic, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(mu, (SummaryStatistics) null);            fail("insufficient data to perform t test, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }      }        public void testOneSampleTTest() throws Exception {        double[] oneSidedP =            {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d };        SummaryStatistics oneSidedPStats = new SummaryStatistics();            for (int i = 0; i < oneSidedP.length; i++) {            oneSidedPStats.addValue(oneSidedP[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("one sample t stat", 3.86485535541,                 TestUtils.t(0d, oneSidedP), 10E-10);        assertEquals("one sample t stat", 3.86485535541,                 TestUtils.t(0d, oneSidedPStats),1E-10);        assertEquals("one sample p value", 0.000521637019637,                TestUtils.tTest(0d, oneSidedP) / 2d, 10E-10);        assertEquals("one sample p value", 0.000521637019637,                TestUtils.tTest(0d, oneSidedPStats) / 2d, 10E-5);        assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedP, 0.01));        assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedPStats, 0.01));        assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedP, 0.0001));        assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedPStats, 0.0001));                try {            TestUtils.tTest(0d, oneSidedP, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            TestUtils.tTest(0d, oneSidedPStats, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }              }        public void testTwoSampleTHeterscedastic() throws Exception {        double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };        double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };        SummaryStatistics sampleStats1 = new SummaryStatistics();          for (int i = 0; i < sample1.length; i++) {            sampleStats1.addValue(sample1[i]);        }        SummaryStatistics sampleStats2 = new SummaryStatistics();            for (int i = 0; i < sample2.length; i++) {            sampleStats2.addValue(sample2[i]);        }                // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("two sample heteroscedastic t stat", 1.60371728768,                 TestUtils.t(sample1, sample2), 1E-10);        assertEquals("two sample heteroscedastic t stat", 1.60371728768,                 TestUtils.t(sampleStats1, sampleStats2), 1E-10);        assertEquals("two sample heteroscedastic p value", 0.128839369622,                 TestUtils.tTest(sample1, sample2), 1E-10);        assertEquals("two sample heteroscedastic p value", 0.128839369622,                 TestUtils.tTest(sampleStats1, sampleStats2), 1E-10);             assertTrue("two sample heteroscedastic t-test reject",                 TestUtils.tTest(sample1, sample2, 0.2));        assertTrue("two sample heteroscedastic t-test reject",                 TestUtils.tTest(sampleStats1, sampleStats2, 0.2));        assertTrue("two sample heteroscedastic t-test accept",                 !TestUtils.tTest(sample1, sample2, 0.1));        assertTrue("two sample heteroscedastic t-test accept",                 !TestUtils.tTest(sampleStats1, sampleStats2, 0.1));                try {            TestUtils.tTest(sample1, sample2, .95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                 try {            TestUtils.tTest(sampleStats1, sampleStats2, .95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected         }                  try {            TestUtils.tTest(sample1, tooShortObs, .01);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            TestUtils.tTest(sampleStats1, (SummaryStatistics) null, .01);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            TestUtils.tTest(sample1, tooShortObs);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            TestUtils.tTest(sampleStats1, (SummaryStatistics) null);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            TestUtils.t(sample1, tooShortObs);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                try {            TestUtils.t(sampleStats1, (SummaryStatistics) null);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testTwoSampleTHomoscedastic() throws Exception {        double[] sample1 ={2, 4, 6, 8, 10, 97};        double[] sample2 = {4, 6, 8, 10, 16};        SummaryStatistics sampleStats1 = new SummaryStatistics();          for (int i = 0; i < sample1.length; i++) {            sampleStats1.addValue(sample1[i]);        }        SummaryStatistics sampleStats2 = new SummaryStatistics();            for (int i = 0; i < sample2.length; i++) {            sampleStats2.addValue(sample2[i]);        }                // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("two sample homoscedastic t stat", 0.73096310086,                 TestUtils.homoscedasticT(sample1, sample2), 10E-11);        assertEquals("two sample homoscedastic p value", 0.4833963785,                 TestUtils.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);             assertTrue("two sample homoscedastic t-test reject",                 TestUtils.homoscedasticTTest(sample1, sample2, 0.49));        assertTrue("two sample homoscedastic t-test accept",                 !TestUtils.homoscedasticTTest(sample1, sample2, 0.48));    }        public void testSmallSamples() throws Exception {        double[] sample1 = {1d, 3d};        double[] sample2 = {4d, 5d};                        // Target values computed using R, version 1.8.1 (linux version)        assertEquals(-2.2360679775, TestUtils.t(sample1, sample2),                1E-10);        assertEquals(0.198727388935, TestUtils.tTest(sample1, sample2),                1E-10);    }        public void testPaired() throws Exception {        double[] sample1 = {1d, 3d, 5d, 7d};        double[] sample2 = {0d, 6d, 11d, 2d};        double[] sample3 = {5d, 7d, 8d, 10d};        // Target values computed using R, version 1.8.1 (linux version)        assertEquals(-0.3133, TestUtils.pairedT(sample1, sample2), 1E-4);        assertEquals(0.774544295819, TestUtils.pairedTTest(sample1, sample2), 1E-10);        assertEquals(0.001208, TestUtils.pairedTTest(sample1, sample3), 1E-6);        assertFalse(TestUtils.pairedTTest(sample1, sample3, .001));        assertTrue(TestUtils.pairedTTest(sample1, sample3, .002));        }        private double[] classA =      {93.0, 103.0, 95.0, 101.0};    private double[] classB =      {99.0, 92.0, 102.0, 100.0, 102.0};    private double[] classC =      {110.0, 115.0, 111.0, 117.0, 128.0};        private List<double[]> classes = new ArrayList<double[]>();    private OneWayAnova oneWayAnova = new OneWayAnovaImpl();        public void testOneWayAnovaUtils() throws Exception {        classes.add(classA);        classes.add(classB);        classes.add(classC);        assertEquals(oneWayAnova.anovaFValue(classes),                 TestUtils.oneWayAnovaFValue(classes), 10E-12);        assertEquals(oneWayAnova.anovaPValue(classes),                 TestUtils.oneWayAnovaPValue(classes), 10E-12);        assertEquals(oneWayAnova.anovaTest(classes, 0.01),                 TestUtils.oneWayAnovaTest(classes, 0.01));       } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.clustering;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.Arrays;import java.util.List;import java.util.Random;import org.junit.Test;public class KMeansPlusPlusClustererTest {    @Test    public void dimension2() {        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer =            new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(new Random(1746432956321l));        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {                // first expected cluster                new EuclideanIntegerPoint(new int[] { -15,  3 }),                new EuclideanIntegerPoint(new int[] { -15,  4 }),                new EuclideanIntegerPoint(new int[] { -15,  5 }),                new EuclideanIntegerPoint(new int[] { -14,  3 }),                new EuclideanIntegerPoint(new int[] { -14,  5 }),                new EuclideanIntegerPoint(new int[] { -13,  3 }),                new EuclideanIntegerPoint(new int[] { -13,  4 }),                new EuclideanIntegerPoint(new int[] { -13,  5 }),                // second expected cluster                new EuclideanIntegerPoint(new int[] { -1,  0 }),                new EuclideanIntegerPoint(new int[] { -1, -1 }),                new EuclideanIntegerPoint(new int[] {  0, -1 }),                new EuclideanIntegerPoint(new int[] {  1, -1 }),                new EuclideanIntegerPoint(new int[] {  1, -2 }),                // third expected cluster                new EuclideanIntegerPoint(new int[] { 13,  3 }),                new EuclideanIntegerPoint(new int[] { 13,  4 }),                new EuclideanIntegerPoint(new int[] { 14,  4 }),                new EuclideanIntegerPoint(new int[] { 14,  7 }),                new EuclideanIntegerPoint(new int[] { 16,  5 }),                new EuclideanIntegerPoint(new int[] { 16,  6 }),                new EuclideanIntegerPoint(new int[] { 17,  4 }),                new EuclideanIntegerPoint(new int[] { 17,  7 })        };        List<Cluster<EuclideanIntegerPoint>> clusters =            transformer.cluster(Arrays.asList(points), 3, 10);        assertEquals(3, clusters.size());        boolean cluster1Found = false;        boolean cluster2Found = false;        boolean cluster3Found = false;        for (Cluster<EuclideanIntegerPoint> cluster : clusters) {            int[] center = cluster.getCenter().getPoint();            if (center[0] < 0) {                cluster1Found = true;                assertEquals(8, cluster.getPoints().size());                assertEquals(-14, center[0]);                assertEquals( 4, center[1]);            } else if (center[1] < 0) {                cluster2Found = true;                assertEquals(5, cluster.getPoints().size());                assertEquals( 0, center[0]);                assertEquals(-1, center[1]);            } else {                cluster3Found = true;                assertEquals(8, cluster.getPoints().size());                assertEquals(15, center[0]);                assertEquals(5, center[1]);            }        }        assertTrue(cluster1Found);        assertTrue(cluster2Found);        assertTrue(cluster3Found);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.regression;import static org.junit.Assert.assertEquals;import org.apache.commons.math.TestUtils;import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.MatrixVisitorException;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.Array2DRowRealMatrix;import org.junit.Before;import org.junit.Test;public class OLSMultipleLinearRegressionTest extends MultipleLinearRegressionAbstractTest {    private double[] y;    private double[][] x;        @Before    @Override    public void setUp(){        y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};        x = new double[6][];        x[0] = new double[]{1.0, 0, 0, 0, 0, 0};        x[1] = new double[]{1.0, 2.0, 0, 0, 0, 0};        x[2] = new double[]{1.0, 0, 3.0, 0, 0, 0};        x[3] = new double[]{1.0, 0, 0, 4.0, 0, 0};        x[4] = new double[]{1.0, 0, 0, 0, 5.0, 0};        x[5] = new double[]{1.0, 0, 0, 0, 0, 6.0};        super.setUp();    }    @Override    protected OLSMultipleLinearRegression createRegression() {        OLSMultipleLinearRegression regression = new OLSMultipleLinearRegression();        regression.newSampleData(y, x);        return regression;    }    @Override    protected int getNumberOfRegressors() {        return x[0].length;    }    @Override    protected int getSampleSize() {        return y.length;    }        @Test(expected=IllegalArgumentException.class)    public void cannotAddXSampleData() {        createRegression().newSampleData(new double[]{}, null);    }    @Test(expected=IllegalArgumentException.class)    public void cannotAddNullYSampleData() {        createRegression().newSampleData(null, new double[][]{});    }        @Test(expected=IllegalArgumentException.class)    public void cannotAddSampleDataWithSizeMismatch() {        double[] y = new double[]{1.0, 2.0};        double[][] x = new double[1][];        x[0] = new double[]{1.0, 0};        createRegression().newSampleData(y, x);    }        @Test    public void testPerfectFit() {        double[] betaHat = regression.estimateRegressionParameters();        TestUtils.assertEquals(betaHat,                                new double[]{ 11.0, 1.0 / 2.0, 2.0 / 3.0, 3.0 / 4.0, 4.0 / 5.0, 5.0 / 6.0 },                               1e-14);        double[] residuals = regression.estimateResiduals();        TestUtils.assertEquals(residuals, new double[]{0d,0d,0d,0d,0d,0d},                               1e-14);        RealMatrix errors =            new Array2DRowRealMatrix(regression.estimateRegressionParametersVariance(), false);        final double[] s = { 1.0, -1.0 /  2.0, -1.0 /  3.0, -1.0 /  4.0, -1.0 /  5.0, -1.0 /  6.0 };        RealMatrix referenceVariance = new Array2DRowRealMatrix(s.length, s.length);        referenceVariance.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {            @Override            public double visit(int row, int column, double value)                throws MatrixVisitorException {                if (row == 0) {                    return s[column];                }                double x = s[row] * s[column];                return (row == column) ? 2 * x : x;            }        });       assertEquals(0.0,                     errors.subtract(referenceVariance).getNorm(),                     5.0e-16 * referenceVariance.getNorm());    }            /**     * Test Longley dataset against certified values provided by NIST.     * Data Source: J. Longley (1967) "An Appraisal of Least Squares     * Programs for the Electronic Computer from the Point of View of the User"     * Journal of the American Statistical Association, vol. 62. September,     * pp. 819-841.     *      * Certified values (and data) are from NIST:     * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat     */    @Test    public void testLongly() {        // Y values are first, then independent vars        // Each row is one observation        double[] design = new double[] {            60323,83.0,234289,2356,1590,107608,1947,            61122,88.5,259426,2325,1456,108632,1948,            60171,88.2,258054,3682,1616,109773,1949,            61187,89.5,284599,3351,1650,110929,1950,            63221,96.2,328975,2099,3099,112075,1951,            63639,98.1,346999,1932,3594,113270,1952,            64989,99.0,365385,1870,3547,115094,1953,            63761,100.0,363112,3578,3350,116219,1954,            66019,101.2,397469,2904,3048,117388,1955,            67857,104.6,419180,2822,2857,118734,1956,            68169,108.4,442769,2936,2798,120445,1957,            66513,110.8,444546,4681,2637,121950,1958,            68655,112.6,482704,3813,2552,123366,1959,            69564,114.2,502601,3931,2514,125368,1960,            69331,115.7,518173,4806,2572,127852,1961,            70551,116.9,554894,4007,2827,130081,1962        };                // Transform to Y and X required by interface        int nobs = 16;        int nvars = 6;                // Estimate the model        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();        model.newSampleData(design, nobs, nvars);                // Check expected beta values from NIST        double[] betaHat = model.estimateRegressionParameters();        TestUtils.assertEquals(betaHat,           new double[]{-3482258.63459582, 15.0618722713733,                -0.358191792925910E-01,-2.02022980381683,                -1.03322686717359,-0.511041056535807E-01,                 1829.15146461355}, 2E-8); //                 // Check expected residuals from R        double[] residuals = model.estimateResiduals();        TestUtils.assertEquals(residuals, new double[]{                267.340029759711,-94.0139423988359,46.28716775752924,                -410.114621930906,309.7145907602313,-249.3112153297231,                -164.0489563956039,-13.18035686637081,14.30477260005235,                 455.394094551857,-17.26892711483297,-39.0550425226967,                -155.5499735953195,-85.6713080421283,341.9315139607727,                -206.7578251937366},                      1E-8);                // Check standard errors from NIST        double[] errors = model.estimateRegressionParametersStandardErrors();        TestUtils.assertEquals(new double[] {890420.383607373,                       84.9149257747669,                       0.334910077722432E-01,                       0.488399681651699,                       0.214274163161675,                       0.226073200069370,                       455.478499142212}, errors, 1E-6);     }        /**     * Test R Swiss fertility dataset against R.     * Data Source: R datasets package     */    @Test    public void testSwissFertility() {        double[] design = new double[] {            80.2,17.0,15,12,9.96,            83.1,45.1,6,9,84.84,            92.5,39.7,5,5,93.40,            85.8,36.5,12,7,33.77,            76.9,43.5,17,15,5.16,            76.1,35.3,9,7,90.57,            83.8,70.2,16,7,92.85,            92.4,67.8,14,8,97.16,            82.4,53.3,12,7,97.67,            82.9,45.2,16,13,91.38,            87.1,64.5,14,6,98.61,            64.1,62.0,21,12,8.52,            66.9,67.5,14,7,2.27,            68.9,60.7,19,12,4.43,            61.7,69.3,22,5,2.82,            68.3,72.6,18,2,24.20,            71.7,34.0,17,8,3.30,            55.7,19.4,26,28,12.11,            54.3,15.2,31,20,2.15,            65.1,73.0,19,9,2.84,            65.5,59.8,22,10,5.23,            65.0,55.1,14,3,4.52,            56.6,50.9,22,12,15.14,            57.4,54.1,20,6,4.20,            72.5,71.2,12,1,2.40,            74.2,58.1,14,8,5.23,            72.0,63.5,6,3,2.56,            60.5,60.8,16,10,7.72,            58.3,26.8,25,19,18.46,            65.4,49.5,15,8,6.10,            75.5,85.9,3,2,99.71,            69.3,84.9,7,6,99.68,            77.3,89.7,5,2,100.00,            70.5,78.2,12,6,98.96,            79.4,64.9,7,3,98.22,            65.0,75.9,9,9,99.06,            92.2,84.6,3,3,99.46,            79.3,63.1,13,13,96.83,            70.4,38.4,26,12,5.62,            65.7,7.7,29,11,13.79,            72.7,16.7,22,13,11.22,            64.4,17.6,35,32,16.92,            77.6,37.6,15,7,4.97,            67.6,18.7,25,7,8.65,            35.0,1.2,37,53,42.34,            44.7,46.6,16,29,50.43,            42.8,27.7,22,29,58.33        };        // Transform to Y and X required by interface        int nobs = 47;        int nvars = 4;        // Estimate the model        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();        model.newSampleData(design, nobs, nvars);        // Check expected beta values from R        double[] betaHat = model.estimateRegressionParameters();        TestUtils.assertEquals(betaHat,                 new double[]{91.05542390271397,                -0.22064551045715,                -0.26058239824328,                -0.96161238456030,                 0.12441843147162}, 1E-12);        // Check expected residuals from R        double[] residuals = model.estimateResiduals();        TestUtils.assertEquals(residuals, new double[]{                7.1044267859730512,1.6580347433531366,                4.6944952770029644,8.4548022690166160,13.6547432343186212,               -9.3586864458500774,7.5822446330520386,15.5568995563859289,                0.8113090736598980,7.1186762732484308,7.4251378771228724,                2.6761316873234109,0.8351584810309354,7.1769991119615177,               -3.8746753206299553,-3.1337779476387251,-0.1412575244091504,                1.1186809170469780,-6.3588097346816594,3.4039270429434074,                2.3374058329820175,-7.9272368576900503,-7.8361010968497959,               -11.2597369269357070,0.9445333697827101,6.6544245101380328,               -0.9146136301118665,-4.3152449403848570,-4.3536932047009183,               -3.8907885169304661,-6.3027643926302188,-7.8308982189289091,               -3.1792280015332750,-6.7167298771158226,-4.8469946718041754,               -10.6335664353633685,11.1031134362036958,6.0084032641811733,                5.4326230830188482,-7.2375578629692230,2.1671550814448222,                15.0147574652763112,4.8625103516321015,-7.1597256413907706,                -0.4515205619767598,-10.2916870903837587,-15.7812984571900063},                1E-12);                 // Check standard errors from R        double[] errors = model.estimateRegressionParametersStandardErrors();        TestUtils.assertEquals(new double[] {6.94881329475087,                0.07360008972340,                0.27410957467466,                0.19454551679325,                0.03726654773803}, errors, 1E-10);     }        /**     * Test hat matrix computation     *      * @throws Exception     */    @Test    public void testHat() throws Exception {                /*         * This example is from "The Hat Matrix in Regression and ANOVA",          * David C. Hoaglin and Roy E. Welsch,          * The American Statistician, Vol. 32, No. 1 (Feb., 1978), pp. 17-22.         *          */        double[] design = new double[] {                11.14, .499, 11.1,                12.74, .558, 8.9,                13.13, .604, 8.8,                11.51, .441, 8.9,                12.38, .550, 8.8,                12.60, .528, 9.9,                11.13, .418, 10.7,                11.7, .480, 10.5,                11.02, .406, 10.5,                11.41, .467, 10.7        };                int nobs = 10;        int nvars = 2;                // Estimate the model        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();        model.newSampleData(design, nobs, nvars);                RealMatrix hat = model.calculateHat();                // Reference data is upper half of symmetric hat matrix        double[] referenceData = new double[] {                .418, -.002,  .079, -.274, -.046,  .181,  .128,  .222,  .050,  .242,                       .242,  .292,  .136,  .243,  .128, -.041,  .033, -.035,  .004,                              .417, -.019,  .273,  .187, -.126,  .044, -.153,  .004,                                     .604,  .197, -.038,  .168, -.022,  .275, -.028,                                            .252,  .111, -.030,  .019, -.010, -.010,                                                   .148,  .042,  .117,  .012,  .111,                                                          .262,  .145,  .277,  .174,                                                                 .154,  .120,  .168,                                                                        .315,  .148,                                                                               .187        };                // Check against reference data and verify symmetry        int k = 0;        for (int i = 0; i < 10; i++) {            for (int j = i; j < 10; j++) {                assertEquals(referenceData[k], hat.getEntry(i, j), 10e-3);                assertEquals(hat.getEntry(i, j), hat.getEntry(j, i), 10e-12);                k++;              }        }                /*          * Verify that residuals computed using the hat matrix are close to          * what we get from direct computation, i.e. r = (I - H) y         */        double[] residuals = model.estimateResiduals();        RealMatrix I = MatrixUtils.createRealIdentityMatrix(10);        double[] hatResiduals = I.subtract(hat).operate(model.Y).getData();        TestUtils.assertEquals(residuals, hatResiduals, 10e-12);        }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.regression;import java.util.Random;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the TestStatistic class. * * @version $Revision$ $Date$ */public final class SimpleRegressionTest extends TestCase {    /*      * NIST "Norris" refernce data set from      * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat     * Strangely, order is {y,x}     */    private double[][] data = { { 0.1, 0.2 }, {338.8, 337.4 }, {118.1, 118.2 },             {888.0, 884.6 }, {9.2, 10.1 }, {228.1, 226.5 }, {668.5, 666.3 }, {998.5, 996.3 },             {449.1, 448.6 }, {778.9, 777.0 }, {559.2, 558.2 }, {0.3, 0.4 }, {0.1, 0.6 }, {778.1, 775.5 },             {668.8, 666.9 }, {339.3, 338.0 }, {448.9, 447.5 }, {10.8, 11.6 }, {557.7, 556.0 },             {228.3, 228.1 }, {998.0, 995.8 }, {888.8, 887.6 }, {119.6, 120.2 }, {0.3, 0.3 },             {0.6, 0.3 }, {557.6, 556.8 }, {339.3, 339.1 }, {888.0, 887.2 }, {998.5, 999.0 },             {778.9, 779.0 }, {10.2, 11.1 }, {117.6, 118.3 }, {228.9, 229.2 }, {668.4, 669.1 },             {449.2, 448.9 }, {0.2, 0.5 }    };    /*      * Correlation example from      * http://www.xycoon.com/correlation.htm     */    private double[][] corrData = { { 101.0, 99.2 }, {100.1, 99.0 }, {100.0, 100.0 },             {90.6, 111.6 }, {86.5, 122.2 }, {89.7, 117.6 }, {90.6, 121.1 }, {82.8, 136.0 },             {70.1, 154.2 }, {65.4, 153.6 }, {61.3, 158.5 }, {62.5, 140.6 }, {63.6, 136.2 },             {52.6, 168.0 }, {59.7, 154.3 }, {59.5, 149.0 }, {61.3, 165.5 }    };    /*     * From Moore and Mcabe, "Introduction to the Practice of Statistics"     * Example 10.3      */    private double[][] infData = { { 15.6, 5.2 }, {26.8, 6.1 }, {37.8, 8.7 }, {36.4, 8.5 },            {35.5, 8.8 }, {18.6, 4.9 }, {15.3, 4.5 }, {7.9, 2.5 }, {0.0, 1.1 }    };        /*     * Points to remove in the remove tests     */    private double[][] removeSingle = {infData[1]};    private double[][] removeMultiple = { infData[1], infData[2] };    private double removeX = infData[0][0];    private double removeY = infData[0][1];                    /*     * Data with bad linear fit     */    private double[][] infData2 = { { 1, 1 }, {2, 0 }, {3, 5 }, {4, 2 },            {5, -1 }, {6, 12 }    };    public SimpleRegressionTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SimpleRegressionTest.class);        suite.setName("BivariateRegression Tests");        return suite;    }    public void testNorris() {        SimpleRegression regression = new SimpleRegression();        for (int i = 0; i < data.length; i++) {            regression.addData(data[i][1], data[i][0]);        }        // Tests against certified values from          // http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat        assertEquals("slope", 1.00211681802045, regression.getSlope(), 10E-12);        assertEquals("slope std err", 0.429796848199937E-03,                regression.getSlopeStdErr(),10E-12);        assertEquals("number of observations", 36, regression.getN());        assertEquals( "intercept", -0.262323073774029,            regression.getIntercept(),10E-12);        assertEquals("std err intercept", 0.232818234301152,            regression.getInterceptStdErr(),10E-12);        assertEquals("r-square", 0.999993745883712,            regression.getRSquare(), 10E-12);        assertEquals("SSR", 4255954.13232369,            regression.getRegressionSumSquares(), 10E-9);        assertEquals("MSE", 0.782864662630069,            regression.getMeanSquareError(), 10E-10);        assertEquals("SSE", 26.6173985294224,            regression.getSumSquaredErrors(),10E-9);        // ------------  End certified data tests                  assertEquals( "predict(0)",  -0.262323073774029,            regression.predict(0), 10E-12);        assertEquals("predict(1)", 1.00211681802045 - 0.262323073774029,            regression.predict(1), 10E-12);    }    public void testCorr() {        SimpleRegression regression = new SimpleRegression();        regression.addData(corrData);        assertEquals("number of observations", 17, regression.getN());        assertEquals("r-square", .896123, regression.getRSquare(), 10E-6);        assertEquals("r", -0.94663767742, regression.getR(), 1E-10);    }    public void testNaNs() {        SimpleRegression regression = new SimpleRegression();        assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept()));        assertTrue("slope not NaN", Double.isNaN(regression.getSlope()));        assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));        assertTrue("e not NaN", Double.isNaN(regression.getR()));        assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare()));        assertTrue( "RSS not NaN", Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE not NaN",Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("SSTO not NaN", Double.isNaN(regression.getTotalSumSquares()));        assertTrue("predict not NaN", Double.isNaN(regression.predict(0)));        regression.addData(1, 2);        regression.addData(1, 3);        // No x variation, so these should still blow...        assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept()));        assertTrue("slope not NaN", Double.isNaN(regression.getSlope()));        assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));        assertTrue("e not NaN", Double.isNaN(regression.getR()));        assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare()));        assertTrue("RSS not NaN", Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE not NaN", Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("predict not NaN", Double.isNaN(regression.predict(0)));        // but SSTO should be OK        assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares()));        regression = new SimpleRegression();        regression.addData(1, 2);        regression.addData(3, 3);        // All should be OK except MSE, s(b0), s(b1) which need one more df         assertTrue("interceptNaN", !Double.isNaN(regression.getIntercept()));        assertTrue("slope NaN", !Double.isNaN(regression.getSlope()));        assertTrue ("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));        assertTrue("r NaN", !Double.isNaN(regression.getR()));        assertTrue("r-square NaN", !Double.isNaN(regression.getRSquare()));        assertTrue("RSS NaN", !Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE NaN", !Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares()));        assertTrue("predict NaN", !Double.isNaN(regression.predict(0)));        regression.addData(1, 4);        // MSE, MSE, s(b0), s(b1) should all be OK now        assertTrue("MSE NaN", !Double.isNaN(regression.getMeanSquareError()));        assertTrue("slope std err NaN", !Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err NaN", !Double.isNaN(regression.getInterceptStdErr()));    }    public void testClear() {        SimpleRegression regression = new SimpleRegression();        regression.addData(corrData);        assertEquals("number of observations", 17, regression.getN());        regression.clear();        assertEquals("number of observations", 0, regression.getN());        regression.addData(corrData);        assertEquals("r-square", .896123, regression.getRSquare(), 10E-6);        regression.addData(data);        assertEquals("number of observations", 53, regression.getN());    }    public void testInference() throws Exception {        //----------  verified against R, version 1.8.1 -----        // infData        SimpleRegression regression = new SimpleRegression();        regression.addData(infData);        assertEquals("slope std err", 0.011448491,                regression.getSlopeStdErr(), 1E-10);        assertEquals("std err intercept", 0.286036932,                regression.getInterceptStdErr(),1E-8);        assertEquals("significance", 4.596e-07,                regression.getSignificance(),1E-8);            assertEquals("slope conf interval half-width", 0.0270713794287,                 regression.getSlopeConfidenceInterval(),1E-8);        // infData2        regression = new SimpleRegression();        regression.addData(infData2);        assertEquals("slope std err", 1.07260253,                regression.getSlopeStdErr(), 1E-8);        assertEquals("std err intercept",4.17718672,                regression.getInterceptStdErr(),1E-8);        assertEquals("significance", 0.261829133982,                regression.getSignificance(),1E-11);            assertEquals("slope conf interval half-width", 2.97802204827,                 regression.getSlopeConfidenceInterval(),1E-8);        //------------- End R-verified tests -------------------------------                //FIXME: get a real example to test against with alpha = .01        assertTrue("tighter means wider",                regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01));             try {            regression.getSlopeConfidenceInterval(1);            fail("expecting IllegalArgumentException for alpha = 1");        } catch (IllegalArgumentException ex) {            // ignored        }      }    public void testPerfect() throws Exception {        SimpleRegression regression = new SimpleRegression();        int n = 100;        for (int i = 0; i < n; i++) {            regression.addData(((double) i) / (n - 1), i);        }        assertEquals(0.0, regression.getSignificance(), 1.0e-5);        assertTrue(regression.getSlope() > 0.0);        assertTrue(regression.getSumSquaredErrors() >= 0.0);    }    public void testPerfectNegative() throws Exception {        SimpleRegression regression = new SimpleRegression();        int n = 100;        for (int i = 0; i < n; i++) {            regression.addData(- ((double) i) / (n - 1), i);        }           assertEquals(0.0, regression.getSignificance(), 1.0e-5);        assertTrue(regression.getSlope() < 0.0);       }    public void testRandom() throws Exception {        SimpleRegression regression = new SimpleRegression();        Random random = new Random(1);        int n = 100;        for (int i = 0; i < n; i++) {            regression.addData(((double) i) / (n - 1), random.nextDouble());        }        assertTrue( 0.0 < regression.getSignificance()                    && regression.getSignificance() < 1.0);           }            // Jira MATH-85 = Bugzilla 39432    public void testSSENonNegative() {        double[] y = { 8915.102, 8919.302, 8923.502 };        double[] x = { 1.107178495E2, 1.107264895E2, 1.107351295E2 };        SimpleRegression reg = new SimpleRegression();        for (int i = 0; i < x.length; i++) {            reg.addData(x[i], y[i]);        }        assertTrue(reg.getSumSquaredErrors() >= 0.0);    }         // Test remove X,Y (single observation)    public void testRemoveXY() throws Exception {        // Create regression with inference data then remove to test        SimpleRegression regression = new SimpleRegression();        regression.addData(infData);        regression.removeData(removeX, removeY);        regression.addData(removeX, removeY);        // Use the inference assertions to make sure that everything worked        assertEquals("slope std err", 0.011448491,                regression.getSlopeStdErr(), 1E-10);        assertEquals("std err intercept", 0.286036932,                regression.getInterceptStdErr(),1E-8);        assertEquals("significance", 4.596e-07,                regression.getSignificance(),1E-8);            assertEquals("slope conf interval half-width", 0.0270713794287,                 regression.getSlopeConfidenceInterval(),1E-8);     }            // Test remove single observation in array    public void testRemoveSingle() throws Exception {        // Create regression with inference data then remove to test        SimpleRegression regression = new SimpleRegression();        regression.addData(infData);        regression.removeData(removeSingle);        regression.addData(removeSingle);        // Use the inference assertions to make sure that everything worked        assertEquals("slope std err", 0.011448491,                regression.getSlopeStdErr(), 1E-10);        assertEquals("std err intercept", 0.286036932,                regression.getInterceptStdErr(),1E-8);        assertEquals("significance", 4.596e-07,                regression.getSignificance(),1E-8);            assertEquals("slope conf interval half-width", 0.0270713794287,                 regression.getSlopeConfidenceInterval(),1E-8);     }        // Test remove multiple observations    public void testRemoveMultiple() throws Exception {        // Create regression with inference data then remove to test        SimpleRegression regression = new SimpleRegression();        regression.addData(infData);        regression.removeData(removeMultiple);        regression.addData(removeMultiple);        // Use the inference assertions to make sure that everything worked        assertEquals("slope std err", 0.011448491,                regression.getSlopeStdErr(), 1E-10);        assertEquals("std err intercept", 0.286036932,                regression.getInterceptStdErr(),1E-8);        assertEquals("significance", 4.596e-07,                regression.getSignificance(),1E-8);            assertEquals("slope conf interval half-width", 0.0270713794287,                 regression.getSlopeConfidenceInterval(),1E-8);     }        // Remove observation when empty    public void testRemoveObsFromEmpty() {        SimpleRegression regression = new SimpleRegression();        regression.removeData(removeX, removeY);        assertEquals(regression.getN(), 0);    }        // Remove single observation to empty    public void testRemoveObsFromSingle() {        SimpleRegression regression = new SimpleRegression();        regression.addData(removeX, removeY);        regression.removeData(removeX, removeY);        assertEquals(regression.getN(), 0);    }        // Remove multiple observations to empty    public void testRemoveMultipleToEmpty() {        SimpleRegression regression = new SimpleRegression();        regression.addData(removeMultiple);        regression.removeData(removeMultiple);        assertEquals(regression.getN(), 0);    }        // Remove multiple observations past empty (i.e. size of array > n)    public void testRemoveMultiplePastEmpty() {        SimpleRegression regression = new SimpleRegression();        regression.addData(removeX, removeY);        regression.removeData(removeMultiple);        assertEquals(regression.getN(), 0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.regression;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import org.junit.Before;import org.junit.Test;public abstract class MultipleLinearRegressionAbstractTest {    protected MultipleLinearRegression regression;    @Before    public void setUp(){        regression = createRegression();    }    protected abstract MultipleLinearRegression createRegression();        protected abstract int getNumberOfRegressors();        protected abstract int getSampleSize();    @Test    public void canEstimateRegressionParameters(){        double[] beta = regression.estimateRegressionParameters();                assertEquals(getNumberOfRegressors(), beta.length);    }    @Test    public void canEstimateResiduals(){        double[] e = regression.estimateResiduals();        assertEquals(getSampleSize(), e.length);    }        @Test    public void canEstimateRegressionParametersVariance(){        double[][] variance = regression.estimateRegressionParametersVariance();        assertEquals(getNumberOfRegressors(), variance.length);    }    @Test    public void canEstimateRegressandVariance(){        if (getSampleSize() > getNumberOfRegressors()) {            double variance = regression.estimateRegressandVariance();            assertTrue(variance > 0.0);        }    }   }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.regression;import org.junit.Before;import org.junit.Test;public class GLSMultipleLinearRegressionTest extends MultipleLinearRegressionAbstractTest {    private double[] y;    private double[][] x;    private double[][] omega;    @Before    @Override    public void setUp(){        y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};        x = new double[6][];        x[0] = new double[]{1.0, 0, 0, 0, 0, 0};        x[1] = new double[]{1.0, 2.0, 0, 0, 0, 0};        x[2] = new double[]{1.0, 0, 3.0, 0, 0, 0};        x[3] = new double[]{1.0, 0, 0, 4.0, 0, 0};        x[4] = new double[]{1.0, 0, 0, 0, 5.0, 0};        x[5] = new double[]{1.0, 0, 0, 0, 0, 6.0};        omega = new double[6][];        omega[0] = new double[]{1.0, 0, 0, 0, 0, 0};        omega[1] = new double[]{0, 2.0, 0, 0, 0, 0};        omega[2] = new double[]{0, 0, 3.0, 0, 0, 0};        omega[3] = new double[]{0, 0, 0, 4.0, 0, 0};        omega[4] = new double[]{0, 0, 0, 0, 5.0, 0};        omega[5] = new double[]{0, 0, 0, 0, 0, 6.0};        super.setUp();    }       @Test(expected=IllegalArgumentException.class)    public void cannotAddXSampleData() {        createRegression().newSampleData(new double[]{}, null, null);    }    @Test(expected=IllegalArgumentException.class)    public void cannotAddNullYSampleData() {        createRegression().newSampleData(null, new double[][]{}, null);    }        @Test(expected=IllegalArgumentException.class)    public void cannotAddSampleDataWithSizeMismatch() {        double[] y = new double[]{1.0, 2.0};        double[][] x = new double[1][];        x[0] = new double[]{1.0, 0};        createRegression().newSampleData(y, x, null);    }        @Test(expected=IllegalArgumentException.class)    public void cannotAddNullCovarianceData() {        createRegression().newSampleData(new double[]{}, new double[][]{}, null);    }        @Test(expected=IllegalArgumentException.class)    public void cannotAddCovarianceDataWithSampleSizeMismatch() {        double[] y = new double[]{1.0, 2.0};        double[][] x = new double[2][];        x[0] = new double[]{1.0, 0};        x[1] = new double[]{0, 1.0};        double[][] omega = new double[1][];        omega[0] = new double[]{1.0, 0};        createRegression().newSampleData(y, x, omega);    }    @Test(expected=IllegalArgumentException.class)    public void cannotAddCovarianceDataThatIsNotSquare() {        double[] y = new double[]{1.0, 2.0};        double[][] x = new double[2][];        x[0] = new double[]{1.0, 0};        x[1] = new double[]{0, 1.0};        double[][] omega = new double[3][];        omega[0] = new double[]{1.0, 0};        omega[1] = new double[]{0, 1.0};        omega[2] = new double[]{0, 2.0};        createRegression().newSampleData(y, x, omega);    }    @Override    protected GLSMultipleLinearRegression createRegression() {        GLSMultipleLinearRegression regression = new GLSMultipleLinearRegression();        regression.newSampleData(y, x, omega);        return regression;    }    @Override    protected int getNumberOfRegressors() {        return x[0].length;    }    @Override    protected int getSampleSize() {        return y.length;    }        }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.correlation;import org.apache.commons.math.TestUtils;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.linear.RealMatrix;/** * Test cases for Spearman's rank correlation *  * @since 2.0 * @version $Revision:$ $Date:$ */public class SpearmansRankCorrelationTest extends PearsonsCorrelationTest {    @Override    protected void setUp() throws Exception {        super.setUp();    }    @Override    protected void tearDown() throws Exception {        super.tearDown();    }        /**     * Test Longley dataset against R.     */    @Override    public void testLongly() throws Exception {          RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);         RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();        double[] rData = new double[] {                1, 0.982352941176471, 0.985294117647059, 0.564705882352941, 0.2264705882352941, 0.976470588235294,                0.976470588235294, 0.982352941176471, 1, 0.997058823529412, 0.664705882352941, 0.2205882352941176,                0.997058823529412, 0.997058823529412, 0.985294117647059, 0.997058823529412, 1, 0.638235294117647,                0.2235294117647059, 0.9941176470588236, 0.9941176470588236, 0.564705882352941, 0.664705882352941,                0.638235294117647, 1, -0.3411764705882353, 0.685294117647059, 0.685294117647059, 0.2264705882352941,                0.2205882352941176, 0.2235294117647059, -0.3411764705882353, 1, 0.2264705882352941, 0.2264705882352941,                0.976470588235294, 0.997058823529412, 0.9941176470588236, 0.685294117647059, 0.2264705882352941, 1, 1,                0.976470588235294, 0.997058823529412, 0.9941176470588236, 0.685294117647059, 0.2264705882352941, 1, 1        };         TestUtils.assertEquals("Spearman's correlation matrix", createRealMatrix(rData, 7, 7), correlationMatrix, 10E-15);    }        /**     * Test R swiss fertility dataset.     */    public void testSwiss() throws Exception {          RealMatrix matrix = createRealMatrix(swissData, 47, 5);        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);         RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();        double[] rData = new double[] {                1, 0.2426642769364176, -0.660902996352354, -0.443257690360988, 0.4136455623012432,                0.2426642769364176, 1, -0.598859938748963, -0.650463814145816, 0.2886878090882852,               -0.660902996352354, -0.598859938748963, 1, 0.674603831406147, -0.4750575257171745,               -0.443257690360988, -0.650463814145816, 0.674603831406147, 1, -0.1444163088302244,                0.4136455623012432, 0.2886878090882852, -0.4750575257171745, -0.1444163088302244, 1        };         TestUtils.assertEquals("Spearman's correlation matrix", createRealMatrix(rData, 5, 5), correlationMatrix, 10E-15);    }        /**     * Constant column     */    @Override    public void testConstant() {        double[] noVariance = new double[] {1, 1, 1, 1};        double[] values = new double[] {1, 2, 3, 4};        assertTrue(Double.isNaN(new SpearmansCorrelation().correlation(noVariance, values)));    }        /**     * Insufficient data     */     @Override    public void testInsufficientData() {        double[] one = new double[] {1};        double[] two = new double[] {2};        try {            new SpearmansCorrelation().correlation(one, two);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }        RealMatrix matrix = new BlockRealMatrix(new double[][] {{0},{1}});        try {            new SpearmansCorrelation(matrix);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }    }        @Override    public void testConsistency() {        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);         double[][] data = matrix.getData();        double[] x = matrix.getColumn(0);        double[] y = matrix.getColumn(1);        assertEquals(new SpearmansCorrelation().correlation(x, y),                 corrInstance.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE);        TestUtils.assertEquals("Correlation matrix", corrInstance.getCorrelationMatrix(),                new SpearmansCorrelation().computeCorrelationMatrix(data), Double.MIN_VALUE);    }        // Not relevant here    @Override    public void testStdErrorConsistency() throws Exception {}    @Override    public void testCovarianceConsistency() throws Exception {}     }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.correlation;import org.apache.commons.math.TestUtils;import org.apache.commons.math.distribution.TDistribution;import org.apache.commons.math.distribution.TDistributionImpl;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.BlockRealMatrix;import junit.framework.TestCase;public class PearsonsCorrelationTest extends TestCase {        protected final double[] longleyData = new double[] {            60323,83.0,234289,2356,1590,107608,1947,            61122,88.5,259426,2325,1456,108632,1948,            60171,88.2,258054,3682,1616,109773,1949,            61187,89.5,284599,3351,1650,110929,1950,            63221,96.2,328975,2099,3099,112075,1951,            63639,98.1,346999,1932,3594,113270,1952,            64989,99.0,365385,1870,3547,115094,1953,            63761,100.0,363112,3578,3350,116219,1954,            66019,101.2,397469,2904,3048,117388,1955,            67857,104.6,419180,2822,2857,118734,1956,            68169,108.4,442769,2936,2798,120445,1957,            66513,110.8,444546,4681,2637,121950,1958,            68655,112.6,482704,3813,2552,123366,1959,            69564,114.2,502601,3931,2514,125368,1960,            69331,115.7,518173,4806,2572,127852,1961,            70551,116.9,554894,4007,2827,130081,1962        };        protected final double[] swissData = new double[] {            80.2,17.0,15,12,9.96,            83.1,45.1,6,9,84.84,            92.5,39.7,5,5,93.40,            85.8,36.5,12,7,33.77,            76.9,43.5,17,15,5.16,            76.1,35.3,9,7,90.57,            83.8,70.2,16,7,92.85,            92.4,67.8,14,8,97.16,            82.4,53.3,12,7,97.67,            82.9,45.2,16,13,91.38,            87.1,64.5,14,6,98.61,            64.1,62.0,21,12,8.52,            66.9,67.5,14,7,2.27,            68.9,60.7,19,12,4.43,            61.7,69.3,22,5,2.82,            68.3,72.6,18,2,24.20,            71.7,34.0,17,8,3.30,            55.7,19.4,26,28,12.11,            54.3,15.2,31,20,2.15,            65.1,73.0,19,9,2.84,            65.5,59.8,22,10,5.23,            65.0,55.1,14,3,4.52,            56.6,50.9,22,12,15.14,            57.4,54.1,20,6,4.20,            72.5,71.2,12,1,2.40,            74.2,58.1,14,8,5.23,            72.0,63.5,6,3,2.56,            60.5,60.8,16,10,7.72,            58.3,26.8,25,19,18.46,            65.4,49.5,15,8,6.10,            75.5,85.9,3,2,99.71,            69.3,84.9,7,6,99.68,            77.3,89.7,5,2,100.00,            70.5,78.2,12,6,98.96,            79.4,64.9,7,3,98.22,            65.0,75.9,9,9,99.06,            92.2,84.6,3,3,99.46,            79.3,63.1,13,13,96.83,            70.4,38.4,26,12,5.62,            65.7,7.7,29,11,13.79,            72.7,16.7,22,13,11.22,            64.4,17.6,35,32,16.92,            77.6,37.6,15,7,4.97,            67.6,18.7,25,7,8.65,            35.0,1.2,37,53,42.34,            44.7,46.6,16,29,50.43,            42.8,27.7,22,29,58.33        };         /**     * Test Longley dataset against R.     */    public void testLongly() throws Exception {          RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);         RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();        double[] rData = new double[] {                1.000000000000000, 0.9708985250610560, 0.9835516111796693, 0.5024980838759942,                0.4573073999764817, 0.960390571594376, 0.9713294591921188,                0.970898525061056, 1.0000000000000000, 0.9915891780247822, 0.6206333925590966,                0.4647441876006747, 0.979163432977498, 0.9911491900672053,                0.983551611179669, 0.9915891780247822, 1.0000000000000000, 0.6042609398895580,                0.4464367918926265, 0.991090069458478, 0.9952734837647849,                0.502498083875994, 0.6206333925590966, 0.6042609398895580, 1.0000000000000000,                -0.1774206295018783, 0.686551516365312, 0.6682566045621746,                0.457307399976482, 0.4647441876006747, 0.4464367918926265, -0.1774206295018783,                1.0000000000000000, 0.364416267189032, 0.4172451498349454,                0.960390571594376, 0.9791634329774981, 0.9910900694584777, 0.6865515163653120,                0.3644162671890320, 1.000000000000000, 0.9939528462329257,                0.971329459192119, 0.9911491900672053, 0.9952734837647849, 0.6682566045621746,                0.4172451498349454, 0.993952846232926, 1.0000000000000000        };         TestUtils.assertEquals("correlation matrix", createRealMatrix(rData, 7, 7), correlationMatrix, 10E-15);                double[] rPvalues = new double[] {                4.38904690369668e-10,                8.36353208910623e-12, 7.8159700933611e-14,                0.0472894097790304, 0.01030636128354301, 0.01316878049026582,                 0.0749178049642416, 0.06971758330341182, 0.0830166169296545, 0.510948586323452,                3.693245043123738e-09, 4.327782576751815e-11, 1.167954621905665e-13, 0.00331028281967516, 0.1652293725106684,                 3.95834476307755e-10, 1.114663916723657e-13, 1.332267629550188e-15, 0.00466039138541463, 0.1078477071581498, 7.771561172376096e-15        };        RealMatrix rPMatrix = createLowerTriangularRealMatrix(rPvalues, 7);        fillUpper(rPMatrix, 0d);        TestUtils.assertEquals("correlation p values", rPMatrix, corrInstance.getCorrelationPValues(), 10E-15);    }        /**     * Test R Swiss fertility dataset against R.     */    public void testSwissFertility() throws Exception {         RealMatrix matrix = createRealMatrix(swissData, 47, 5);         PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);          RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();         double[] rData = new double[] {               1.0000000000000000, 0.3530791836199747, -0.6458827064572875, -0.6637888570350691,  0.4636847006517939,                 0.3530791836199747, 1.0000000000000000,-0.6865422086171366, -0.6395225189483201, 0.4010950530487398,                -0.6458827064572875, -0.6865422086171366, 1.0000000000000000, 0.6984152962884830, -0.5727418060641666,                -0.6637888570350691, -0.6395225189483201, 0.6984152962884830, 1.0000000000000000, -0.1538589170909148,                 0.4636847006517939, 0.4010950530487398, -0.5727418060641666, -0.1538589170909148, 1.0000000000000000         };         TestUtils.assertEquals("correlation matrix", createRealMatrix(rData, 5, 5), correlationMatrix, 10E-15);                  double[] rPvalues = new double[] {                 0.01491720061472623,                 9.45043734069043e-07, 9.95151527133974e-08,                 3.658616965962355e-07, 1.304590105694471e-06, 4.811397236181847e-08,                 0.001028523190118147, 0.005204433539191644, 2.588307925380906e-05, 0.301807756132683         };         RealMatrix rPMatrix = createLowerTriangularRealMatrix(rPvalues, 5);         fillUpper(rPMatrix, 0d);         TestUtils.assertEquals("correlation p values", rPMatrix, corrInstance.getCorrelationPValues(), 10E-15);    }        /**     * Constant column     */    public void testConstant() {        double[] noVariance = new double[] {1, 1, 1, 1};        double[] values = new double[] {1, 2, 3, 4};        assertTrue(Double.isNaN(new PearsonsCorrelation().correlation(noVariance, values)));    }            /**     * Insufficient data     */         public void testInsufficientData() {        double[] one = new double[] {1};        double[] two = new double[] {2};        try {            new PearsonsCorrelation().correlation(one, two);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }        RealMatrix matrix = new BlockRealMatrix(new double[][] {{0},{1}});        try {            new PearsonsCorrelation(matrix);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }    }        /**     * Verify that direct t-tests using standard error estimates are consistent     * with reported p-values     */    public void testStdErrorConsistency() throws Exception {        TDistribution tDistribution = new TDistributionImpl(45);        RealMatrix matrix = createRealMatrix(swissData, 47, 5);        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);         RealMatrix rValues = corrInstance.getCorrelationMatrix();        RealMatrix pValues = corrInstance.getCorrelationPValues();        RealMatrix stdErrors = corrInstance.getCorrelationStandardErrors();        for (int i = 0; i < 5; i++) {            for (int j = 0; j < i; j++) {                double t = Math.abs(rValues.getEntry(i, j)) / stdErrors.getEntry(i, j);                double p = 2 * (1 - tDistribution.cumulativeProbability(t));                assertEquals(p, pValues.getEntry(i, j), 10E-15);            }        }    }        /**     * Verify that creating correlation from covariance gives same results as     * direct computation from the original matrix     */    public void testCovarianceConsistency() throws Exception {        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);         Covariance covInstance = new Covariance(matrix);        PearsonsCorrelation corrFromCovInstance = new PearsonsCorrelation(covInstance);        TestUtils.assertEquals("correlation values", corrInstance.getCorrelationMatrix(),                corrFromCovInstance.getCorrelationMatrix(), 10E-15);        TestUtils.assertEquals("p values", corrInstance.getCorrelationPValues(),                corrFromCovInstance.getCorrelationPValues(), 10E-15);        TestUtils.assertEquals("standard errors", corrInstance.getCorrelationStandardErrors(),                corrFromCovInstance.getCorrelationStandardErrors(), 10E-15);                PearsonsCorrelation corrFromCovInstance2 =             new PearsonsCorrelation(covInstance.getCovarianceMatrix(), 16);        TestUtils.assertEquals("correlation values", corrInstance.getCorrelationMatrix(),                corrFromCovInstance2.getCorrelationMatrix(), 10E-15);        TestUtils.assertEquals("p values", corrInstance.getCorrelationPValues(),                corrFromCovInstance2.getCorrelationPValues(), 10E-15);        TestUtils.assertEquals("standard errors", corrInstance.getCorrelationStandardErrors(),                corrFromCovInstance2.getCorrelationStandardErrors(), 10E-15);    }             public void testConsistency() {        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);         double[][] data = matrix.getData();        double[] x = matrix.getColumn(0);        double[] y = matrix.getColumn(1);        assertEquals(new PearsonsCorrelation().correlation(x, y),                 corrInstance.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE);        TestUtils.assertEquals("Correlation matrix", corrInstance.getCorrelationMatrix(),                new PearsonsCorrelation().computeCorrelationMatrix(data), Double.MIN_VALUE);    }        protected RealMatrix createRealMatrix(double[] data, int nRows, int nCols) {        double[][] matrixData = new double[nRows][nCols];        int ptr = 0;        for (int i = 0; i < nRows; i++) {            System.arraycopy(data, ptr, matrixData[i], 0, nCols);            ptr += nCols;        }        return new BlockRealMatrix(matrixData);     }        protected RealMatrix createLowerTriangularRealMatrix(double[] data, int dimension) {        int ptr = 0;        RealMatrix result = new BlockRealMatrix(dimension, dimension);        for (int i = 1; i < dimension; i++) {            for (int j = 0; j < i; j++) {                result.setEntry(i, j, data[ptr]);                ptr++;            }        }        return result;    }        protected void fillUpper(RealMatrix matrix, double diagonalValue) {        int dimension = matrix.getColumnDimension();        for (int i = 0; i < dimension; i++) {            matrix.setEntry(i, i, diagonalValue);            for (int j = i+1; j < dimension; j++) {                matrix.setEntry(i, j, matrix.getEntry(j, i));            }        }      }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.correlation;import org.apache.commons.math.TestUtils;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.Array2DRowRealMatrix;import org.apache.commons.math.stat.descriptive.moment.Variance;import junit.framework.TestCase;public class CovarianceTest extends TestCase {        protected final double[] longleyData = new double[] {            60323,83.0,234289,2356,1590,107608,1947,            61122,88.5,259426,2325,1456,108632,1948,            60171,88.2,258054,3682,1616,109773,1949,            61187,89.5,284599,3351,1650,110929,1950,            63221,96.2,328975,2099,3099,112075,1951,            63639,98.1,346999,1932,3594,113270,1952,            64989,99.0,365385,1870,3547,115094,1953,            63761,100.0,363112,3578,3350,116219,1954,            66019,101.2,397469,2904,3048,117388,1955,            67857,104.6,419180,2822,2857,118734,1956,            68169,108.4,442769,2936,2798,120445,1957,            66513,110.8,444546,4681,2637,121950,1958,            68655,112.6,482704,3813,2552,123366,1959,            69564,114.2,502601,3931,2514,125368,1960,            69331,115.7,518173,4806,2572,127852,1961,            70551,116.9,554894,4007,2827,130081,1962        };        protected final double[] swissData = new double[] {            80.2,17.0,15,12,9.96,            83.1,45.1,6,9,84.84,            92.5,39.7,5,5,93.40,            85.8,36.5,12,7,33.77,            76.9,43.5,17,15,5.16,            76.1,35.3,9,7,90.57,            83.8,70.2,16,7,92.85,            92.4,67.8,14,8,97.16,            82.4,53.3,12,7,97.67,            82.9,45.2,16,13,91.38,            87.1,64.5,14,6,98.61,            64.1,62.0,21,12,8.52,            66.9,67.5,14,7,2.27,            68.9,60.7,19,12,4.43,            61.7,69.3,22,5,2.82,            68.3,72.6,18,2,24.20,            71.7,34.0,17,8,3.30,            55.7,19.4,26,28,12.11,            54.3,15.2,31,20,2.15,            65.1,73.0,19,9,2.84,            65.5,59.8,22,10,5.23,            65.0,55.1,14,3,4.52,            56.6,50.9,22,12,15.14,            57.4,54.1,20,6,4.20,            72.5,71.2,12,1,2.40,            74.2,58.1,14,8,5.23,            72.0,63.5,6,3,2.56,            60.5,60.8,16,10,7.72,            58.3,26.8,25,19,18.46,            65.4,49.5,15,8,6.10,            75.5,85.9,3,2,99.71,            69.3,84.9,7,6,99.68,            77.3,89.7,5,2,100.00,            70.5,78.2,12,6,98.96,            79.4,64.9,7,3,98.22,            65.0,75.9,9,9,99.06,            92.2,84.6,3,3,99.46,            79.3,63.1,13,13,96.83,            70.4,38.4,26,12,5.62,            65.7,7.7,29,11,13.79,            72.7,16.7,22,13,11.22,            64.4,17.6,35,32,16.92,            77.6,37.6,15,7,4.97,            67.6,18.7,25,7,8.65,            35.0,1.2,37,53,42.34,            44.7,46.6,16,29,50.43,            42.8,27.7,22,29,58.33        };         /**     * Test Longley dataset against R.     * Data Source: J. Longley (1967) "An Appraisal of Least Squares     * Programs for the Electronic Computer from the Point of View of the User"     * Journal of the American Statistical Association, vol. 62. September,     * pp. 819-841.     *      * Data are from NIST:     * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat     */    public void testLongly() {          RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();        double[] rData = new double[] {         12333921.73333333246, 3.679666000000000e+04, 343330206.333333313,         1649102.666666666744, 1117681.066666666651, 23461965.733333334, 16240.93333333333248,         36796.66000000000, 1.164576250000000e+02, 1063604.115416667,         6258.666250000000, 3490.253750000000, 73503.000000000, 50.92333333333334,         343330206.33333331347, 1.063604115416667e+06, 9879353659.329166412,         56124369.854166664183, 30880428.345833335072, 685240944.600000024, 470977.90000000002328,         1649102.66666666674, 6.258666250000000e+03, 56124369.854166664,         873223.429166666698, -115378.762499999997, 4462741.533333333, 2973.03333333333330,         1117681.06666666665, 3.490253750000000e+03, 30880428.345833335,         -115378.762499999997, 484304.095833333326, 1764098.133333333, 1382.43333333333339,         23461965.73333333433, 7.350300000000000e+04, 685240944.600000024,         4462741.533333333209, 1764098.133333333302, 48387348.933333330, 32917.40000000000146,         16240.93333333333, 5.092333333333334e+01, 470977.900000000,         2973.033333333333, 1382.433333333333, 32917.40000000, 22.66666666666667        };                TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 7, 7), covarianceMatrix, 10E-9);    }        /**     * Test R Swiss fertility dataset against R.     * Data Source: R datasets package     */    public void testSwissFertility() {         RealMatrix matrix = createRealMatrix(swissData, 47, 5);         RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();         double[] rData = new double[] {           156.0424976873265, 100.1691489361702, -64.36692876965772, -79.7295097132285, 241.5632030527289,           100.169148936170251, 515.7994172062905, -124.39283071230344, -139.6574005550416, 379.9043755781684,           -64.3669287696577, -124.3928307123034, 63.64662349676226, 53.5758556891767, -190.5606105457909,           -79.7295097132285, -139.6574005550416, 53.57585568917669, 92.4560592044403, -61.6988297872340,            241.5632030527289, 379.9043755781684, -190.56061054579092, -61.6988297872340, 1739.2945371877890         };                  TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 5, 5), covarianceMatrix, 10E-13);    }        /**     * Constant column     */    public void testConstant() {        double[] noVariance = new double[] {1, 1, 1, 1};        double[] values = new double[] {1, 2, 3, 4};        assertEquals(0d, new Covariance().covariance(noVariance, values, true), Double.MIN_VALUE);        assertEquals(0d, new Covariance().covariance(noVariance, noVariance, true), Double.MIN_VALUE);    }            /**     * Insufficient data     */    public void testInsufficientData() {        double[] one = new double[] {1};        double[] two = new double[] {2};        try {            new Covariance().covariance(one, two, false);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }        RealMatrix matrix = new Array2DRowRealMatrix(new double[][] {{0},{1}});        try {            new Covariance(matrix);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }    }        /**     * Verify that diagonal entries are consistent with Variance computation and matrix matches     * column-by-column covariances     */    public void testConsistency() {        final RealMatrix matrix = createRealMatrix(swissData, 47, 5);        final RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();                // Variances on the diagonal        Variance variance = new Variance();        for (int i = 0; i < 5; i++) {            assertEquals(variance.evaluate(matrix.getColumn(i)), covarianceMatrix.getEntry(i,i), 10E-14);        }                // Symmetry, column-consistency        assertEquals(covarianceMatrix.getEntry(2, 3),                 new Covariance().covariance(matrix.getColumn(2), matrix.getColumn(3), true), 10E-14);        assertEquals(covarianceMatrix.getEntry(2, 3), covarianceMatrix.getEntry(3, 2), Double.MIN_VALUE);                // All columns same -> all entries = column variance        RealMatrix repeatedColumns = new Array2DRowRealMatrix(47, 3);        for (int i = 0; i < 3; i++) {            repeatedColumns.setColumnMatrix(i, matrix.getColumnMatrix(0));        }        RealMatrix repeatedCovarianceMatrix = new Covariance(repeatedColumns).getCovarianceMatrix();        double columnVariance = variance.evaluate(matrix.getColumn(0));        for (int i = 0; i < 3; i++) {            for (int j = 0; j < 3; j++) {                assertEquals(columnVariance, repeatedCovarianceMatrix.getEntry(i, j), 10E-14);            }        }                // Check bias-correction defaults        double[][] data = matrix.getData();        TestUtils.assertEquals("Covariances",                 covarianceMatrix, new Covariance().computeCovarianceMatrix(data),Double.MIN_VALUE);        TestUtils.assertEquals("Covariances",                 covarianceMatrix, new Covariance().computeCovarianceMatrix(data, true),Double.MIN_VALUE);                double[] x = data[0];        double[] y = data[1];        assertEquals(new Covariance().covariance(x, y),                 new Covariance().covariance(x, y, true), Double.MIN_VALUE);     }        protected RealMatrix createRealMatrix(double[] data, int nRows, int nCols) {        double[][] matrixData = new double[nRows][nCols];        int ptr = 0;        for (int i = 0; i < nRows; i++) {            System.arraycopy(data, ptr, matrixData[i], 0, nCols);            ptr += nCols;        }        return new Array2DRowRealMatrix(matrixData);     }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.data;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.net.URL;import java.util.HashMap;import java.util.Map;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;import org.apache.commons.math.stat.descriptive.SummaryStatistics;/** * @version $Revision$ $Date$ */public abstract class CertifiedDataAbstractTest extends TestCase {        private DescriptiveStatistics descriptives;        private SummaryStatistics summaries;        private Map<String, Double> certifiedValues;    @Override    protected void setUp() throws Exception {        descriptives = new DescriptiveStatistics();        summaries = new SummaryStatistics();        certifiedValues = new HashMap<String, Double>();                loadData();    }    private void loadData() throws IOException {        BufferedReader in = null;        try {            URL resourceURL = getClass().getClassLoader().getResource(getResourceName());            in = new BufferedReader(new InputStreamReader(resourceURL.openStream()));                        String line = in.readLine();            while (line != null) {                                /* this call to StringUtils did little for the                  * following conditional structure                  */                line = line.trim();                // not empty line or comment                if (!("".equals(line) || line.startsWith("#"))) {                    int n = line.indexOf('=');                    if (n == -1) {                        // data value                        double value = Double.parseDouble(line);                        descriptives.addValue(value);                        summaries.addValue(value);                    } else {                        // certified value                        String name = line.substring(0, n).trim();                        String valueString = line.substring(n + 1).trim();                        Double value = Double.valueOf(valueString);                        certifiedValues.put(name, value);                    }                }                line = in.readLine();            }        } finally {            if (in != null) {                in.close();            }        }    }    protected abstract String getResourceName();    protected double getMaximumAbsoluteError() {        return 1.0e-5;    }    @Override    protected void tearDown() throws Exception {        descriptives.clear();        descriptives = null;                summaries.clear();        summaries = null;                certifiedValues.clear();        certifiedValues = null;    }        public void testCertifiedValues() {        for (String name : certifiedValues.keySet()) {            Double expectedValue = certifiedValues.get(name);            Double summariesValue = getProperty(summaries, name);            if (summariesValue != null) {                TestUtils.assertEquals("summary value for " + name + " is incorrect.",                                       summariesValue.doubleValue(), expectedValue.doubleValue(),                                       getMaximumAbsoluteError());            }            Double descriptivesValue = getProperty(descriptives, name);            if (descriptivesValue != null) {                TestUtils.assertEquals("descriptive value for " + name + " is incorrect.",                                       descriptivesValue.doubleValue(), expectedValue.doubleValue(),                                       getMaximumAbsoluteError());            }        }    }            protected Double getProperty(Object bean, String name) {        try {            // Get the value of prop            String prop = "get" + name.substring(0,1).toUpperCase() + name.substring(1);             Method meth = bean.getClass().getMethod(prop, new Class[0]);            Object property = meth.invoke(bean, new Object[0]);            if (meth.getReturnType().equals(Double.TYPE)) {                return (Double) property;            } else if (meth.getReturnType().equals(Long.TYPE)) {                return Double.valueOf(((Long) property).doubleValue());            } else {                fail("wrong type: " + meth.getReturnType().getName());            }        } catch (NoSuchMethodException nsme) {            // ignored        } catch (InvocationTargetException ite) {            fail(ite.getMessage());        } catch (IllegalAccessException iae) {            fail(iae.getMessage());        }        return null;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.data;/** * @version $Revision$ $Date$ */public class LotteryTest extends CertifiedDataAbstractTest {    @Override    protected String getResourceName() {        return "org/apache/commons/math/stat/data/Lottery.txt";    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.data;/** * @version $Revision$ $Date$ */public class LewTest extends CertifiedDataAbstractTest {    @Override    protected String getResourceName() {        return "org/apache/commons/math/stat/data/Lew.txt";    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.ranking;import org.apache.commons.math.TestUtils;import org.apache.commons.math.random.JDKRandomGenerator;import org.apache.commons.math.random.RandomGenerator;import junit.framework.TestCase;/** * Test cases for NaturalRanking class *  * @since 2.0 * @version $Revision:$ $Date:$ */public class NaturalRankingTest extends TestCase {    private final double[] exampleData = { 20, 17, 30, 42.3, 17, 50,            Double.NaN, Double.NEGATIVE_INFINITY, 17 };    private final double[] tiesFirst = { 0, 0, 2, 1, 4 };    private final double[] tiesLast = { 4, 4, 1, 0 };    private final double[] multipleNaNs = { 0, 1, Double.NaN, Double.NaN };    private final double[] multipleTies = { 3, 2, 5, 5, 6, 6, 1 };    private final double[] allSame = { 0, 0, 0, 0 };    public NaturalRankingTest(String arg0) {        super(arg0);    }    @Override    protected void setUp() throws Exception {        super.setUp();    }    @Override    protected void tearDown() throws Exception {        super.tearDown();    }    public void testDefault() { // Ties averaged, NaNs maximal        NaturalRanking ranking = new NaturalRanking();        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 5, 3, 6, 7, 3, 8, 9, 1, 3 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 1.5, 1.5, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 3.5, 3.5, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 1, 2, 3.5, 3.5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 4.5, 4.5, 6.5, 6.5, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 2.5, 2.5, 2.5, 2.5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    public void testNaNsMaximalTiesMinimum() {        NaturalRanking ranking = new NaturalRanking(TiesStrategy.MINIMUM);        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 5, 2, 6, 7, 2, 8, 9, 1, 2 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 1, 1, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 3, 3, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 1, 2, 3, 3 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 4, 4, 6, 6, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 1, 1, 1, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    public void testNaNsRemovedTiesSequential() {        NaturalRanking ranking = new NaturalRanking(NaNStrategy.REMOVED,                TiesStrategy.SEQUENTIAL);        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 5, 2, 6, 7, 3, 8, 1, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 1, 2, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 3, 4, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 1, 2 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 4, 5, 6, 7, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 1, 2, 3, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    public void testNaNsMinimalTiesMaximum() {        NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL,                TiesStrategy.MAXIMUM);        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 6, 5, 7, 8, 5, 9, 2, 2, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 2, 2, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 4, 4, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 3, 4, 2, 2 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 5, 5, 7, 7, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 4, 4, 4, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    public void testNaNsMinimalTiesAverage() {        NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL);        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 6, 4, 7, 8, 4, 9, 1.5, 1.5, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 1.5, 1.5, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 3.5, 3.5, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 3, 4, 1.5, 1.5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 4.5, 4.5, 6.5, 6.5, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 2.5, 2.5, 2.5, 2.5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    public void testNaNsFixedTiesRandom() {        RandomGenerator randomGenerator = new JDKRandomGenerator();        randomGenerator.setSeed(1000);        NaturalRanking ranking = new NaturalRanking(NaNStrategy.FIXED,                randomGenerator);        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 5, 4, 6, 7, 3, 8, Double.NaN, 1, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 1, 1, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 3, 4, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 1, 2, Double.NaN, Double.NaN };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 5, 5, 7, 6, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 1, 3, 4, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    public void testNaNsAndInfs() {        double[] data = { 0, Double.POSITIVE_INFINITY, Double.NaN,                Double.NEGATIVE_INFINITY };        NaturalRanking ranking = new NaturalRanking(NaNStrategy.MAXIMAL);        double[] ranks = ranking.rank(data);        double[] correctRanks = new double[] { 2, 3.5, 3.5, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranking = new NaturalRanking(NaNStrategy.MINIMAL);        ranks = ranking.rank(data);        correctRanks = new double[] { 3, 4, 1.5, 1.5 };    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import java.io.BufferedReader;import java.io.InputStreamReader;import org.apache.commons.math.stat.descriptive.SummaryStatistics;import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;/** * Certified data test cases. * @version $Revision$ $Date$ */public class CertifiedDataTest extends TestCase  {    protected double mean = Double.NaN;    protected double std = Double.NaN;    /**     * Certified Data Test Constructor     * @param name     */    public CertifiedDataTest(String name) {        super(name);    }    /**     * @return The test suite     */    public static Test suite() {        TestSuite suite = new TestSuite(CertifiedDataTest.class);        suite.setName("Certified Tests");        return suite;    }    /**     * Test SummaryStatistics - implementations that do not store the data     * and use single pass algorithms to compute statistics    */    public void testSummaryStatistics() throws Exception {        SummaryStatistics u = new SummaryStatistics();        loadStats("data/PiDigits.txt", u);        assertEquals("PiDigits: std", std, u.getStandardDeviation(), 1E-13);        assertEquals("PiDigits: mean", mean, u.getMean(), 1E-13);          loadStats("data/Mavro.txt", u);        assertEquals("Mavro: std", std, u.getStandardDeviation(), 1E-14);        assertEquals("Mavro: mean", mean, u.getMean(), 1E-14);                loadStats("data/Michelso.txt", u);        assertEquals("Michelso: std", std, u.getStandardDeviation(), 1E-13);        assertEquals("Michelso: mean", mean, u.getMean(), 1E-13);                                                   loadStats("data/NumAcc1.txt", u);        assertEquals("NumAcc1: std", std, u.getStandardDeviation(), 1E-14);        assertEquals("NumAcc1: mean", mean, u.getMean(), 1E-14);                loadStats("data/NumAcc2.txt", u);        assertEquals("NumAcc2: std", std, u.getStandardDeviation(), 1E-14);        assertEquals("NumAcc2: mean", mean, u.getMean(), 1E-14);    }    /**     * Test DescriptiveStatistics - implementations that store full array of     * values and execute multi-pass algorithms     */    public void testDescriptiveStatistics() throws Exception {        DescriptiveStatistics u = new DescriptiveStatistics();                loadStats("data/PiDigits.txt", u);        assertEquals("PiDigits: std", std, u.getStandardDeviation(), 1E-14);        assertEquals("PiDigits: mean", mean, u.getMean(), 1E-14);                loadStats("data/Mavro.txt", u);        assertEquals("Mavro: std", std, u.getStandardDeviation(), 1E-14);        assertEquals("Mavro: mean", mean, u.getMean(), 1E-14);                        loadStats("data/Michelso.txt", u);        assertEquals("Michelso: std", std, u.getStandardDeviation(), 1E-14);        assertEquals("Michelso: mean", mean, u.getMean(), 1E-14);           loadStats("data/NumAcc1.txt", u);        assertEquals("NumAcc1: std", std, u.getStandardDeviation(), 1E-14);        assertEquals("NumAcc1: mean", mean, u.getMean(), 1E-14);                loadStats("data/NumAcc2.txt", u);        assertEquals("NumAcc2: std", std, u.getStandardDeviation(), 1E-14);        assertEquals("NumAcc2: mean", mean, u.getMean(), 1E-14);    }    /**     * loads a DescriptiveStatistics off of a test file     * @param file     * @param statistical summary     */    private void loadStats(String resource, Object u) throws Exception {                DescriptiveStatistics d = null;        SummaryStatistics s = null;        if (u instanceof DescriptiveStatistics) {            d = (DescriptiveStatistics) u;        } else {            s = (SummaryStatistics) u;        }        u.getClass().getDeclaredMethod(                "clear", new Class[]{}).invoke(u, new Object[]{});        mean = Double.NaN;        std = Double.NaN;                BufferedReader in =            new BufferedReader(                    new InputStreamReader(                            CertifiedDataTest.class.getResourceAsStream(resource)));                String line = null;                for (int j = 0; j < 60; j++) {            line = in.readLine();            if (j == 40) {                mean =                    Double.parseDouble(                            line.substring(line.lastIndexOf(":") + 1).trim());            }            if (j == 41) {                std =                    Double.parseDouble(                            line.substring(line.lastIndexOf(":") + 1).trim());            }        }                line = in.readLine();                while (line != null) {            if (d != null) {                d.addValue(Double.parseDouble(line.trim()));            }  else {                s.addValue(Double.parseDouble(line.trim()));            }            line = in.readLine();        }                in.close();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat;import java.io.BufferedReader;import java.io.IOException;import java.io.StringReader;import java.util.Iterator;import org.apache.commons.math.TestUtils;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link Frequency} class. * * @version $Revision$ $Date$ */public final class FrequencyTest extends TestCase {    private long oneL = 1;    private long twoL = 2;    private long threeL = 3;    private int oneI = 1;    private int twoI = 2;    private int threeI=3;    private double tolerance = 10E-15;    private Frequency f = null;        public FrequencyTest(String name) {        super(name);    }    @Override    public void setUp() {          f = new Frequency();    }        public static Test suite() {        TestSuite suite = new TestSuite(FrequencyTest.class);        suite.setName("Frequency Tests");        return suite;    }        /** test freq counts */    public void testCounts() {        assertEquals("total count",0,f.getSumFreq());        f.addValue(oneL);        f.addValue(twoL);        f.addValue(1);        f.addValue(oneI);        assertEquals("one frequency count",3,f.getCount(1));        assertEquals("two frequency count",1,f.getCount(2));        assertEquals("three frequency count",0,f.getCount(3));        assertEquals("total count",4,f.getSumFreq());        assertEquals("zero cumulative frequency", 0, f.getCumFreq(0));        assertEquals("one cumulative frequency", 3,  f.getCumFreq(1));        assertEquals("two cumulative frequency", 4,  f.getCumFreq(2));        assertEquals("Integer argument cum freq",4, f.getCumFreq(Integer.valueOf(2)));        assertEquals("five cumulative frequency", 4,  f.getCumFreq(5));        assertEquals("foo cumulative frequency", 0,  f.getCumFreq("foo"));                f.clear();        assertEquals("total count",0,f.getSumFreq());                // userguide examples -------------------------------------------------------------------        f.addValue("one");        f.addValue("One");        f.addValue("oNe");        f.addValue("Z");        assertEquals("one cumulative frequency", 1 ,  f.getCount("one"));        assertEquals("Z cumulative pct", 0.5,  f.getCumPct("Z"), tolerance);        assertEquals("z cumulative pct", 1.0,  f.getCumPct("z"), tolerance);        assertEquals("Ot cumulative pct", 0.25,  f.getCumPct("Ot"), tolerance);        f.clear();                f = null;        Frequency f = new Frequency();        f.addValue(1);        f.addValue(Integer.valueOf(1));        f.addValue(Long.valueOf(1));        f.addValue(2);        f.addValue(Integer.valueOf(-1));        assertEquals("1 count", 3, f.getCount(1));        assertEquals("1 count", 3, f.getCount(Integer.valueOf(1)));        assertEquals("0 cum pct", 0.2, f.getCumPct(0), tolerance);        assertEquals("1 pct", 0.6, f.getPct(Integer.valueOf(1)), tolerance);        assertEquals("-2 cum pct", 0, f.getCumPct(-2), tolerance);        assertEquals("10 cum pct", 1, f.getCumPct(10), tolerance);                   f = null;        f = new Frequency(String.CASE_INSENSITIVE_ORDER);        f.addValue("one");        f.addValue("One");        f.addValue("oNe");        f.addValue("Z");        assertEquals("one count", 3 ,  f.getCount("one"));        assertEquals("Z cumulative pct -- case insensitive", 1 ,  f.getCumPct("Z"), tolerance);        assertEquals("z cumulative pct -- case insensitive", 1 ,  f.getCumPct("z"), tolerance);        f = null;        f = new Frequency();        assertEquals(0L, f.getCount('a'));        assertEquals(0L, f.getCumFreq('b'));        TestUtils.assertEquals(Double.NaN, f.getPct('a'), 0.0);        TestUtils.assertEquals(Double.NaN, f.getCumPct('b'), 0.0);        f.addValue('a');        f.addValue('b');        f.addValue('c');        f.addValue('d');        assertEquals(1L, f.getCount('a'));        assertEquals(2L, f.getCumFreq('b'));        assertEquals(0.25, f.getPct('a'), 0.0);        assertEquals(0.5, f.getCumPct('b'), 0.0);        assertEquals(1.0, f.getCumPct('e'), 0.0);    }             /** test pcts */    public void testPcts() {        f.addValue(oneL);        f.addValue(twoL);        f.addValue(oneI);        f.addValue(twoI);        f.addValue(threeL);        f.addValue(threeL);        f.addValue(3);        f.addValue(threeI);        assertEquals("one pct",0.25,f.getPct(1),tolerance);        assertEquals("two pct",0.25,f.getPct(Long.valueOf(2)),tolerance);        assertEquals("three pct",0.5,f.getPct(threeL),tolerance);        assertEquals("five pct",0,f.getPct(5),tolerance);        assertEquals("foo pct",0,f.getPct("foo"),tolerance);        assertEquals("one cum pct",0.25,f.getCumPct(1),tolerance);        assertEquals("two cum pct",0.50,f.getCumPct(Long.valueOf(2)),tolerance);        assertEquals("Integer argument",0.50,f.getCumPct(Integer.valueOf(2)),tolerance);        assertEquals("three cum pct",1.0,f.getCumPct(threeL),tolerance);        assertEquals("five cum pct",1.0,f.getCumPct(5),tolerance);        assertEquals("zero cum pct",0.0,f.getCumPct(0),tolerance);        assertEquals("foo cum pct",0,f.getCumPct("foo"),tolerance);    }        /** test adding incomparable values */    public void testAdd() {        char aChar = 'a';        char bChar = 'b';        String aString = "a";        f.addValue(aChar);        f.addValue(bChar);        try {            f.addValue(aString);                fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            f.addValue(2);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        assertEquals("a pct",0.5,f.getPct(aChar),tolerance);        assertEquals("b cum pct",1.0,f.getCumPct(bChar),tolerance);        assertEquals("a string pct",0.0,f.getPct(aString),tolerance);        assertEquals("a string cum pct",0.0,f.getCumPct(aString),tolerance);                f = new Frequency();        f.addValue("One");        try {            f.addValue(new Integer("One"));             fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }        // Check what happens when non-Comparable objects are added    @SuppressWarnings("deprecation")    public void testAddNonComparable(){        try {            f.addValue(new Object()); // This was previously OK            fail("Expected IllegalArgumentException");        } catch (IllegalArgumentException expected) {        }        f.clear();        f.addValue(1);        try {            f.addValue(new Object());            fail("Expected IllegalArgumentException");        } catch (IllegalArgumentException expected) {        }    }    /** test empty table */    public void testEmptyTable() {        assertEquals("freq sum, empty table", 0, f.getSumFreq());        assertEquals("count, empty table", 0, f.getCount(0));        assertEquals("count, empty table",0, f.getCount(Integer.valueOf(0)));        assertEquals("cum freq, empty table", 0, f.getCumFreq(0));        assertEquals("cum freq, empty table", 0, f.getCumFreq("x"));        assertTrue("pct, empty table", Double.isNaN(f.getPct(0)));        assertTrue("pct, empty table", Double.isNaN(f.getPct(Integer.valueOf(0))));        assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(0)));        assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(Integer.valueOf(0))));       }        /**     * Tests toString()      */    public void testToString(){        f.addValue(oneL);        f.addValue(twoL);        f.addValue(oneI);        f.addValue(twoI);                String s = f.toString();        //System.out.println(s);        assertNotNull(s);        BufferedReader reader = new BufferedReader(new StringReader(s));        try {            String line = reader.readLine(); // header line            assertNotNull(line);                        line = reader.readLine(); // one's or two's line            assertNotNull(line);                                    line = reader.readLine(); // one's or two's line            assertNotNull(line);            line = reader.readLine(); // no more elements            assertNull(line);        } catch(IOException ex){            fail(ex.getMessage());        }            }    public void testIntegerValues() {        Comparable<?> obj1 = null;        obj1 = Integer.valueOf(1);        Integer int1 = Integer.valueOf(1);        f.addValue(obj1);        f.addValue(int1);        f.addValue(2);        f.addValue(Long.valueOf(2));        assertEquals("Integer 1 count", 2, f.getCount(1));        assertEquals("Integer 1 count", 2, f.getCount(Integer.valueOf(1)));        assertEquals("Integer 1 count", 2, f.getCount(Long.valueOf(1)));        assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(1), tolerance);        assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(Long.valueOf(1)), tolerance);        assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(Integer.valueOf(1)), tolerance);        Iterator<?> it = f.valuesIterator();        while (it.hasNext()) {            assertTrue(it.next() instanceof Long);        }         }        public void testSerial() {        f.addValue(oneL);        f.addValue(twoL);        f.addValue(oneI);        f.addValue(twoI);        assertEquals(f, TestUtils.serializeAndRecover(f));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;/** * Test cases for the {@link StatUtils} class. * @version $Revision$ $Date$ */public final class StatUtilsTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double min = 1;    private double max = 3;    private double tolerance = 10E-15;    private double nan = Double.NaN;    public StatUtilsTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(StatUtilsTest.class);        suite.setName("StatUtil Tests");        return suite;    }    /** test stats */    public void testStats() {        double[] values = new double[] { one, two, two, three };        assertEquals("sum", sum, StatUtils.sum(values), tolerance);        assertEquals("sumsq", sumSq, StatUtils.sumSq(values), tolerance);        assertEquals("var", var, StatUtils.variance(values), tolerance);        assertEquals("var with mean", var, StatUtils.variance(values, mean), tolerance);        assertEquals("mean", mean, StatUtils.mean(values), tolerance);        assertEquals("min", min, StatUtils.min(values), tolerance);        assertEquals("max", max, StatUtils.max(values), tolerance);    }    public void testN0andN1Conditions() throws Exception {        double[] values = new double[0];        assertTrue(            "Mean of n = 0 set should be NaN",            Double.isNaN(StatUtils.mean(values)));        assertTrue(            "Variance of n = 0 set should be NaN",            Double.isNaN(StatUtils.variance(values)));        values = new double[] { one };        assertTrue(            "Mean of n = 1 set should be value of single item n1",            StatUtils.mean(values) == one);        assertTrue(            "Variance of n = 1 set should be zero",            StatUtils.variance(values) == 0);    }    public void testArrayIndexConditions() throws Exception {        double[] values = { 1.0, 2.0, 3.0, 4.0 };        assertEquals(            "Sum not expected",            5.0,            StatUtils.sum(values, 1, 2),            Double.MIN_VALUE);        assertEquals(            "Sum not expected",            3.0,            StatUtils.sum(values, 0, 2),            Double.MIN_VALUE);        assertEquals(            "Sum not expected",            7.0,            StatUtils.sum(values, 2, 2),            Double.MIN_VALUE);        try {            StatUtils.sum(values, 2, 3);            assertTrue("Didn't throw exception", false);        } catch (Exception e) {            assertTrue(true);        }        try {            StatUtils.sum(values, -1, 2);            assertTrue("Didn't throw exception", false);        } catch (Exception e) {            assertTrue(true);        }    }        public void testSumSq() {        double[] x = null;                // test null        try {            StatUtils.sumSq(x);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                try {            StatUtils.sumSq(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x), tolerance);        TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(4, StatUtils.sumSq(x), tolerance);        TestUtils.assertEquals(4, StatUtils.sumSq(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(18, StatUtils.sumSq(x), tolerance);        TestUtils.assertEquals(8, StatUtils.sumSq(x, 1, 2), tolerance);    }        public void testProduct() {        double[] x = null;                // test null        try {            StatUtils.product(x);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                try {            StatUtils.product(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.product(x), tolerance);        TestUtils.assertEquals(Double.NaN, StatUtils.product(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.product(x), tolerance);        TestUtils.assertEquals(two, StatUtils.product(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(12, StatUtils.product(x), tolerance);        TestUtils.assertEquals(4, StatUtils.product(x, 1, 2), tolerance);    }        public void testSumLog() {        double[] x = null;                // test null        try {            StatUtils.sumLog(x);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                try {            StatUtils.sumLog(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x), tolerance);        TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x), tolerance);        TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(Math.log(one) + 2.0 * Math.log(two) + Math.log(three), StatUtils.sumLog(x), tolerance);        TestUtils.assertEquals(2.0 * Math.log(two), StatUtils.sumLog(x, 1, 2), tolerance);    }        public void testMean() {        double[] x = null;                try {            StatUtils.mean(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.mean(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.mean(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(2.5, StatUtils.mean(x, 2, 2), tolerance);    }        public void testVariance() {        double[] x = null;                try {            StatUtils.variance(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.variance(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(0.0, StatUtils.variance(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(0.5, StatUtils.variance(x, 2, 2), tolerance);                // test precomputed mean        x = new double[] {one, two, two, three};        TestUtils.assertEquals(0.5, StatUtils.variance(x,2.5, 2, 2), tolerance);    }        public void testMax() {        double[] x = null;                try {            StatUtils.max(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.max(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.max(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(three, StatUtils.max(x, 1, 3), tolerance);        // test first nan is ignored        x = new double[] {nan, two, three};        TestUtils.assertEquals(three, StatUtils.max(x), tolerance);        // test middle nan is ignored        x = new double[] {one, nan, three};        TestUtils.assertEquals(three, StatUtils.max(x), tolerance);                // test last nan is ignored        x = new double[] {one, two, nan};        TestUtils.assertEquals(two, StatUtils.max(x), tolerance);        // test all nan returns nan        x = new double[] {nan, nan, nan};        TestUtils.assertEquals(nan, StatUtils.max(x), tolerance);    }        public void testMin() {        double[] x = null;                try {            StatUtils.min(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.min(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.min(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(two, StatUtils.min(x, 1, 3), tolerance);        // test first nan is ignored        x = new double[] {nan, two, three};        TestUtils.assertEquals(two, StatUtils.min(x), tolerance);        // test middle nan is ignored        x = new double[] {one, nan, three};        TestUtils.assertEquals(one, StatUtils.min(x), tolerance);                // test last nan is ignored        x = new double[] {one, two, nan};        TestUtils.assertEquals(one, StatUtils.min(x), tolerance);        // test all nan returns nan        x = new double[] {nan, nan, nan};        TestUtils.assertEquals(nan, StatUtils.min(x), tolerance);    }        public void testPercentile() {        double[] x = null;                // test null        try {            StatUtils.percentile(x, .25);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                try {            StatUtils.percentile(x, 0, 4, 0.25);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 25), tolerance);        TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 0, 0, 25), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.percentile(x, 25), tolerance);        TestUtils.assertEquals(two, StatUtils.percentile(x, 0, 1, 25), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(2.5, StatUtils.percentile(x, 70), tolerance);        TestUtils.assertEquals(2.5, StatUtils.percentile(x, 1, 3, 62.5), tolerance);    }        public void testDifferenceStats() throws Exception {        double sample1[] = {1d, 2d, 3d, 4d};        double sample2[] = {1d, 3d, 4d, 2d};        double diff[] = {0d, -1d, -1d, 2d};        double small[] = {1d, 4d};        double meanDifference = StatUtils.meanDifference(sample1, sample2);        assertEquals(StatUtils.sumDifference(sample1, sample2), StatUtils.sum(diff), tolerance);        assertEquals(meanDifference, StatUtils.mean(diff), tolerance);        assertEquals(StatUtils.varianceDifference(sample1, sample2, meanDifference),                 StatUtils.variance(diff), tolerance);        try {            StatUtils.meanDifference(sample1, small);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            StatUtils.varianceDifference(sample1, small, meanDifference);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            double[] single = {1.0};            StatUtils.varianceDifference(single, single, meanDifference);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }        public void testGeometricMean() throws Exception {        double[] test = null;        try {            StatUtils.geometricMean(test);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        test = new double[] {2, 4, 6, 8};        assertEquals(Math.exp(0.25d * StatUtils.sumLog(test)),                 StatUtils.geometricMean(test), Double.MIN_VALUE);        assertEquals(Math.exp(0.5 * StatUtils.sumLog(test, 0, 2)),                 StatUtils.geometricMean(test, 0, 2), Double.MIN_VALUE);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry;import org.apache.commons.math.geometry.CardanEulerSingularityException;import org.apache.commons.math.geometry.NotARotationMatrixException;import org.apache.commons.math.geometry.Rotation;import org.apache.commons.math.geometry.RotationOrder;import org.apache.commons.math.geometry.Vector3D;import org.apache.commons.math.util.MathUtils;import junit.framework.*;public class RotationTest  extends TestCase {  public RotationTest(String name) {    super(name);  }  public void testIdentity() {    Rotation r = Rotation.IDENTITY;    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);    checkAngle(r.getAngle(), 0);    r = new Rotation(-1, 0, 0, 0, false);    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);    checkAngle(r.getAngle(), 0);    r = new Rotation(42, 0, 0, 0, true);    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);    checkAngle(r.getAngle(), 0);  }  public void testAxisAngle() {    Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * Math.PI / 3);    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_J);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_K);    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_I);    double s = 1 / Math.sqrt(3);    checkVector(r.getAxis(), new Vector3D(s, s, s));    checkAngle(r.getAngle(), 2 * Math.PI / 3);    try {      new Rotation(new Vector3D(0, 0, 0), 2 * Math.PI / 3);      fail("an exception should have been thrown");    } catch (ArithmeticException e) {    } catch (Exception e) {      fail("unexpected exception");    }    r = new Rotation(Vector3D.PLUS_K, 1.5 * Math.PI);    checkVector(r.getAxis(), new Vector3D(0, 0, -1));    checkAngle(r.getAngle(), 0.5 * Math.PI);    r = new Rotation(Vector3D.PLUS_J, Math.PI);    checkVector(r.getAxis(), Vector3D.PLUS_J);    checkAngle(r.getAngle(), Math.PI);    checkVector(Rotation.IDENTITY.getAxis(), Vector3D.PLUS_I);  }  public void testRevert() {    Rotation r = new Rotation(0.001, 0.36, 0.48, 0.8, true);    Rotation reverted = r.revert();    checkRotation(r.applyTo(reverted), 1, 0, 0, 0);    checkRotation(reverted.applyTo(r), 1, 0, 0, 0);    assertEquals(r.getAngle(), reverted.getAngle(), 1.0e-12);    assertEquals(-1, Vector3D.dotProduct(r.getAxis(), reverted.getAxis()), 1.0e-12);  }  public void testVectorOnePair() {    Vector3D u = new Vector3D(3, 2, 1);    Vector3D v = new Vector3D(-4, 2, 2);    Rotation r = new Rotation(u, v);    checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm()));    checkAngle(new Rotation(u, u.negate()).getAngle(), Math.PI);    try {        new Rotation(u, Vector3D.ZERO);        fail("an exception should have been thrown");      } catch (IllegalArgumentException e) {        // expected behavior      } catch (Exception e) {        fail("unexpected exception");    }  }  public void testVectorTwoPairs() {    Vector3D u1 = new Vector3D(3, 0, 0);    Vector3D u2 = new Vector3D(0, 5, 0);    Vector3D v1 = new Vector3D(0, 0, 2);    Vector3D v2 = new Vector3D(-2, 0, 2);    Rotation r = new Rotation(u1, u2, v1, v2);    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.MINUS_I);    r = new Rotation(u1, u2, u1.negate(), u2.negate());    Vector3D axis = r.getAxis();    if (Vector3D.dotProduct(axis, Vector3D.PLUS_K) > 0) {      checkVector(axis, Vector3D.PLUS_K);    } else {      checkVector(axis, Vector3D.MINUS_K);    }    checkAngle(r.getAngle(), Math.PI);    double sqrt = Math.sqrt(2) / 2;    r = new Rotation(Vector3D.PLUS_I,  Vector3D.PLUS_J,                     new Vector3D(0.5, 0.5,  sqrt),                     new Vector3D(0.5, 0.5, -sqrt));    checkRotation(r, sqrt, 0.5, 0.5, 0);    r = new Rotation(u1, u2, u1, Vector3D.crossProduct(u1, u2));    checkRotation(r, sqrt, -sqrt, 0, 0);    checkRotation(new Rotation(u1, u2, u1, u2), 1, 0, 0, 0);    try {        new Rotation(u1, u2, Vector3D.ZERO, v2);        fail("an exception should have been thrown");    } catch (IllegalArgumentException e) {      // expected behavior    } catch (Exception e) {        fail("unexpected exception");    }  }  public void testMatrix()    throws NotARotationMatrixException {    try {      new Rotation(new double[][] {                     { 0.0, 1.0, 0.0 },                     { 1.0, 0.0, 0.0 }                   }, 1.0e-7);    } catch (NotARotationMatrixException nrme) {      // expected behavior    } catch (Exception e) {      fail("wrong exception caught: " + e.getMessage());    }    try {      new Rotation(new double[][] {                     {  0.445888,  0.797184, -0.407040 },                     {  0.821760, -0.184320,  0.539200 },                     { -0.354816,  0.574912,  0.737280 }                   }, 1.0e-7);    } catch (NotARotationMatrixException nrme) {      // expected behavior    } catch (Exception e) {      fail("wrong exception caught: " + e.getMessage());    }    try {        new Rotation(new double[][] {                       {  0.4,  0.8, -0.4 },                       { -0.4,  0.6,  0.7 },                       {  0.8, -0.2,  0.5 }                     }, 1.0e-15);      } catch (NotARotationMatrixException nrme) {        // expected behavior      } catch (Exception e) {        fail("wrong exception caught: " + e.getMessage());      }    checkRotation(new Rotation(new double[][] {                                 {  0.445888,  0.797184, -0.407040 },                                 { -0.354816,  0.574912,  0.737280 },                                 {  0.821760, -0.184320,  0.539200 }                               }, 1.0e-10),                  0.8, 0.288, 0.384, 0.36);    checkRotation(new Rotation(new double[][] {                                 {  0.539200,  0.737280,  0.407040 },                                 {  0.184320, -0.574912,  0.797184 },                                 {  0.821760, -0.354816, -0.445888 }                              }, 1.0e-10),                  0.36, 0.8, 0.288, 0.384);    checkRotation(new Rotation(new double[][] {                                 { -0.445888,  0.797184, -0.407040 },                                 {  0.354816,  0.574912,  0.737280 },                                 {  0.821760,  0.184320, -0.539200 }                               }, 1.0e-10),                  0.384, 0.36, 0.8, 0.288);    checkRotation(new Rotation(new double[][] {                                 { -0.539200,  0.737280,  0.407040 },                                 { -0.184320, -0.574912,  0.797184 },                                 {  0.821760,  0.354816,  0.445888 }                               }, 1.0e-10),                  0.288, 0.384, 0.36, 0.8);    double[][] m1 = { { 0.0, 1.0, 0.0 },                      { 0.0, 0.0, 1.0 },                      { 1.0, 0.0, 0.0 } };    Rotation r = new Rotation(m1, 1.0e-7);    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_I);    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_J);    double[][] m2 = { { 0.83203, -0.55012, -0.07139 },                      { 0.48293,  0.78164, -0.39474 },                      { 0.27296,  0.29396,  0.91602 } };    r = new Rotation(m2, 1.0e-12);    double[][] m3 = r.getMatrix();    double d00 = m2[0][0] - m3[0][0];    double d01 = m2[0][1] - m3[0][1];    double d02 = m2[0][2] - m3[0][2];    double d10 = m2[1][0] - m3[1][0];    double d11 = m2[1][1] - m3[1][1];    double d12 = m2[1][2] - m3[1][2];    double d20 = m2[2][0] - m3[2][0];    double d21 = m2[2][1] - m3[2][1];    double d22 = m2[2][2] - m3[2][2];    assertTrue(Math.abs(d00) < 6.0e-6);    assertTrue(Math.abs(d01) < 6.0e-6);    assertTrue(Math.abs(d02) < 6.0e-6);    assertTrue(Math.abs(d10) < 6.0e-6);    assertTrue(Math.abs(d11) < 6.0e-6);    assertTrue(Math.abs(d12) < 6.0e-6);    assertTrue(Math.abs(d20) < 6.0e-6);    assertTrue(Math.abs(d21) < 6.0e-6);    assertTrue(Math.abs(d22) < 6.0e-6);    assertTrue(Math.abs(d00) > 4.0e-7);    assertTrue(Math.abs(d01) > 4.0e-7);    assertTrue(Math.abs(d02) > 4.0e-7);    assertTrue(Math.abs(d10) > 4.0e-7);    assertTrue(Math.abs(d11) > 4.0e-7);    assertTrue(Math.abs(d12) > 4.0e-7);    assertTrue(Math.abs(d20) > 4.0e-7);    assertTrue(Math.abs(d21) > 4.0e-7);    assertTrue(Math.abs(d22) > 4.0e-7);    for (int i = 0; i < 3; ++i) {      for (int j = 0; j < 3; ++j) {        double m3tm3 = m3[i][0] * m3[j][0]                     + m3[i][1] * m3[j][1]                     + m3[i][2] * m3[j][2];        if (i == j) {          assertTrue(Math.abs(m3tm3 - 1.0) < 1.0e-10);        } else {          assertTrue(Math.abs(m3tm3) < 1.0e-10);        }      }    }    checkVector(r.applyTo(Vector3D.PLUS_I),                new Vector3D(m3[0][0], m3[1][0], m3[2][0]));    checkVector(r.applyTo(Vector3D.PLUS_J),                new Vector3D(m3[0][1], m3[1][1], m3[2][1]));    checkVector(r.applyTo(Vector3D.PLUS_K),                new Vector3D(m3[0][2], m3[1][2], m3[2][2]));    double[][] m4 = { { 1.0,  0.0,  0.0 },                      { 0.0, -1.0,  0.0 },                      { 0.0,  0.0, -1.0 } };    r = new Rotation(m4, 1.0e-7);    checkAngle(r.getAngle(), Math.PI);    try {      double[][] m5 = { { 0.0, 0.0, 1.0 },                        { 0.0, 1.0, 0.0 },                        { 1.0, 0.0, 0.0 } };      r = new Rotation(m5, 1.0e-7);      fail("got " + r + ", should have caught an exception");    } catch (NotARotationMatrixException e) {      // expected    } catch (Exception e) {      fail("wrong exception caught");    }  }  public void testAngles()    throws CardanEulerSingularityException {    RotationOrder[] CardanOrders = {      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX    };    for (int i = 0; i < CardanOrders.length; ++i) {      for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {        for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) {          for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {            Rotation r = new Rotation(CardanOrders[i], alpha1, alpha2, alpha3);            double[] angles = r.getAngles(CardanOrders[i]);            checkAngle(angles[0], alpha1);            checkAngle(angles[1], alpha2);            checkAngle(angles[2], alpha3);          }        }      }    }    RotationOrder[] EulerOrders = {            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ          };    for (int i = 0; i < EulerOrders.length; ++i) {      for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {        for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.3) {          for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {            Rotation r = new Rotation(EulerOrders[i],                                      alpha1, alpha2, alpha3);            double[] angles = r.getAngles(EulerOrders[i]);            checkAngle(angles[0], alpha1);            checkAngle(angles[1], alpha2);            checkAngle(angles[2], alpha3);          }        }      }    }  }  public void testSingularities() {    RotationOrder[] CardanOrders = {      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX    };    double[] singularCardanAngle = { Math.PI / 2, -Math.PI / 2 };    for (int i = 0; i < CardanOrders.length; ++i) {      for (int j = 0; j < singularCardanAngle.length; ++j) {        Rotation r = new Rotation(CardanOrders[i], 0.1, singularCardanAngle[j], 0.3);        try {          r.getAngles(CardanOrders[i]);          fail("an exception should have been caught");        } catch (CardanEulerSingularityException cese) {          // expected behavior        } catch (Exception e) {          fail("wrong exception caught: " + e.getMessage());        }      }    }    RotationOrder[] EulerOrders = {            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ          };    double[] singularEulerAngle = { 0, Math.PI };    for (int i = 0; i < EulerOrders.length; ++i) {      for (int j = 0; j < singularEulerAngle.length; ++j) {        Rotation r = new Rotation(EulerOrders[i], 0.1, singularEulerAngle[j], 0.3);        try {          r.getAngles(EulerOrders[i]);          fail("an exception should have been caught");        } catch (CardanEulerSingularityException cese) {          // expected behavior        } catch (Exception e) {          fail("wrong exception caught: " + e.getMessage());        }      }    }  }  public void testQuaternion() {    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);    double n = 23.5;    Rotation r2 = new Rotation(n * r1.getQ0(), n * r1.getQ1(),                               n * r1.getQ2(), n * r1.getQ3(),                               true);    for (double x = -0.9; x < 0.9; x += 0.2) {      for (double y = -0.9; y < 0.9; y += 0.2) {        for (double z = -0.9; z < 0.9; z += 0.2) {          Vector3D u = new Vector3D(x, y, z);          checkVector(r2.applyTo(u), r1.applyTo(u));        }      }    }    r1 = new Rotation( 0.288,  0.384,  0.36,  0.8, false);    checkRotation(r1, -r1.getQ0(), -r1.getQ1(), -r1.getQ2(), -r1.getQ3());  }  public void testCompose() {    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);    Rotation r3 = r2.applyTo(r1);    for (double x = -0.9; x < 0.9; x += 0.2) {      for (double y = -0.9; y < 0.9; y += 0.2) {        for (double z = -0.9; z < 0.9; z += 0.2) {          Vector3D u = new Vector3D(x, y, z);          checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));        }      }    }  }  public void testComposeInverse() {    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);    Rotation r3 = r2.applyInverseTo(r1);    for (double x = -0.9; x < 0.9; x += 0.2) {      for (double y = -0.9; y < 0.9; y += 0.2) {        for (double z = -0.9; z < 0.9; z += 0.2) {          Vector3D u = new Vector3D(x, y, z);          checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));        }      }    }  }  public void testApplyInverseTo() {    Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7);    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {      for (double phi = -1.55; phi < 1.55; phi += 0.2) {          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),                                    Math.sin(lambda) * Math.cos(phi),                                    Math.sin(phi));          r.applyInverseTo(r.applyTo(u));          checkVector(u, r.applyInverseTo(r.applyTo(u)));          checkVector(u, r.applyTo(r.applyInverseTo(u)));      }    }    r = Rotation.IDENTITY;    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {      for (double phi = -1.55; phi < 1.55; phi += 0.2) {          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),                                    Math.sin(lambda) * Math.cos(phi),                                    Math.sin(phi));          checkVector(u, r.applyInverseTo(r.applyTo(u)));          checkVector(u, r.applyTo(r.applyInverseTo(u)));      }    }    r = new Rotation(Vector3D.PLUS_K, Math.PI);    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {      for (double phi = -1.55; phi < 1.55; phi += 0.2) {          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),                                    Math.sin(lambda) * Math.cos(phi),                                    Math.sin(phi));          checkVector(u, r.applyInverseTo(r.applyTo(u)));          checkVector(u, r.applyTo(r.applyInverseTo(u)));      }    }  }  private void checkVector(Vector3D v1, Vector3D v2) {    assertTrue(v1.subtract(v2).getNorm() < 1.0e-10);  }  private void checkAngle(double a1, double a2) {    assertEquals(a1, MathUtils.normalizeAngle(a2, a1), 1.0e-10);  }  private void checkRotation(Rotation r, double q0, double q1, double q2, double q3) {    assertEquals(0, Rotation.distance(r, new Rotation(q0, q1, q2, q3, false)), 1.0e-12);  }  public static Test suite() {    return new TestSuite(RotationTest.class);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry;import org.apache.commons.math.geometry.Vector3D;import junit.framework.*;public class Vector3DTest  extends TestCase {  public Vector3DTest(String name) {    super(name);  }  public void testConstructors() {      double r = Math.sqrt(2) /2;      checkVector(new Vector3D(2, new Vector3D(Math.PI / 3, -Math.PI / 4)),                  r, r * Math.sqrt(3), -2 * r);      checkVector(new Vector3D(2, Vector3D.PLUS_I,                              -3, Vector3D.MINUS_K),                  2, 0, 3);      checkVector(new Vector3D(2, Vector3D.PLUS_I,                               5, Vector3D.PLUS_J,                              -3, Vector3D.MINUS_K),                  2, 5, 3);      checkVector(new Vector3D(2, Vector3D.PLUS_I,                               5, Vector3D.PLUS_J,                               5, Vector3D.MINUS_J,                               -3, Vector3D.MINUS_K),                  2, 0, 3);  }  public void testCoordinates() {    Vector3D v = new Vector3D(1, 2, 3);    assertTrue(Math.abs(v.getX() - 1) < 1.0e-12);    assertTrue(Math.abs(v.getY() - 2) < 1.0e-12);    assertTrue(Math.abs(v.getZ() - 3) < 1.0e-12);  }    public void testNorm1() {    assertEquals(0.0, Vector3D.ZERO.getNorm1());    assertEquals(6.0, new Vector3D(1, -2, 3).getNorm1(), 0);  }  public void testNorm() {      assertEquals(0.0, Vector3D.ZERO.getNorm());      assertEquals(Math.sqrt(14), new Vector3D(1, 2, 3).getNorm(), 1.0e-12);    }  public void testNormInf() {      assertEquals(0.0, Vector3D.ZERO.getNormInf());      assertEquals(3.0, new Vector3D(1, -2, 3).getNormInf(), 0);    }  public void testDistance1() {      Vector3D v1 = new Vector3D(1, -2, 3);      Vector3D v2 = new Vector3D(-4, 2, 0);      assertEquals(0.0, Vector3D.distance1(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);      assertEquals(12.0, Vector3D.distance1(v1, v2), 1.0e-12);      assertEquals(v1.subtract(v2).getNorm1(), Vector3D.distance1(v1, v2), 1.0e-12);  }  public void testDistance() {      Vector3D v1 = new Vector3D(1, -2, 3);      Vector3D v2 = new Vector3D(-4, 2, 0);      assertEquals(0.0, Vector3D.distance(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);      assertEquals(Math.sqrt(50), Vector3D.distance(v1, v2), 1.0e-12);      assertEquals(v1.subtract(v2).getNorm(), Vector3D.distance(v1, v2), 1.0e-12);  }  public void testDistanceSq() {      Vector3D v1 = new Vector3D(1, -2, 3);      Vector3D v2 = new Vector3D(-4, 2, 0);      assertEquals(0.0, Vector3D.distanceSq(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);      assertEquals(50.0, Vector3D.distanceSq(v1, v2), 1.0e-12);      assertEquals(Vector3D.distance(v1, v2) * Vector3D.distance(v1, v2),                   Vector3D.distanceSq(v1, v2), 1.0e-12);  }  public void testDistanceInf() {      Vector3D v1 = new Vector3D(1, -2, 3);      Vector3D v2 = new Vector3D(-4, 2, 0);      assertEquals(0.0, Vector3D.distanceInf(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);      assertEquals(5.0, Vector3D.distanceInf(v1, v2), 1.0e-12);      assertEquals(v1.subtract(v2).getNormInf(), Vector3D.distanceInf(v1, v2), 1.0e-12);  }  public void testSubtract() {    Vector3D v1 = new Vector3D(1, 2, 3);    Vector3D v2 = new Vector3D(-3, -2, -1);    v1 = v1.subtract(v2);    checkVector(v1, 4, 4, 4);    checkVector(v2.subtract(v1), -7, -6, -5);    checkVector(v2.subtract(3, v1), -15, -14, -13);  }  public void testAdd() {    Vector3D v1 = new Vector3D(1, 2, 3);    Vector3D v2 = new Vector3D(-3, -2, -1);    v1 = v1.add(v2);    checkVector(v1, -2, 0, 2);    checkVector(v2.add(v1), -5, -2, 1);    checkVector(v2.add(3, v1), -9, -2, 5);  }  public void testScalarProduct() {    Vector3D v = new Vector3D(1, 2, 3);    v = v.scalarMultiply(3);    checkVector(v, 3, 6, 9);    checkVector(v.scalarMultiply(0.5), 1.5, 3, 4.5);  }  public void testVectorialProducts() {    Vector3D v1 = new Vector3D(2, 1, -4);    Vector3D v2 = new Vector3D(3, 1, -1);    assertTrue(Math.abs(Vector3D.dotProduct(v1, v2) - 11) < 1.0e-12);    Vector3D v3 = Vector3D.crossProduct(v1, v2);    checkVector(v3, 3, -10, -1);    assertTrue(Math.abs(Vector3D.dotProduct(v1, v3)) < 1.0e-12);    assertTrue(Math.abs(Vector3D.dotProduct(v2, v3)) < 1.0e-12);  }  public void testAngular() {    assertEquals(0,           Vector3D.PLUS_I.getAlpha(), 1.0e-10);    assertEquals(0,           Vector3D.PLUS_I.getDelta(), 1.0e-10);    assertEquals(Math.PI / 2, Vector3D.PLUS_J.getAlpha(), 1.0e-10);    assertEquals(0,           Vector3D.PLUS_J.getDelta(), 1.0e-10);    assertEquals(0,           Vector3D.PLUS_K.getAlpha(), 1.0e-10);    assertEquals(Math.PI / 2, Vector3D.PLUS_K.getDelta(), 1.0e-10);    Vector3D u = new Vector3D(-1, 1, -1);    assertEquals(3 * Math.PI /4, u.getAlpha(), 1.0e-10);    assertEquals(-1.0 / Math.sqrt(3), Math.sin(u.getDelta()), 1.0e-10);  }  public void testAngularSeparation() {    Vector3D v1 = new Vector3D(2, -1, 4);    Vector3D  k = v1.normalize();    Vector3D  i = k.orthogonal();    Vector3D v2 = k.scalarMultiply(Math.cos(1.2)).add(i.scalarMultiply(Math.sin(1.2)));    assertTrue(Math.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12);  }  public void testNormalize() {    assertEquals(1.0, new Vector3D(5, -4, 2).normalize().getNorm(), 1.0e-12);    try {        Vector3D.ZERO.normalize();        fail("an exception should have been thrown");    } catch (ArithmeticException ae) {        // expected behavior    } catch (Exception e) {        fail("wrong exception caught: " + e.getMessage());    }  }  public void testOrthogonal() {      Vector3D v1 = new Vector3D(0.1, 2.5, 1.3);      assertEquals(0.0, Vector3D.dotProduct(v1, v1.orthogonal()), 1.0e-12);      Vector3D v2 = new Vector3D(2.3, -0.003, 7.6);      assertEquals(0.0, Vector3D.dotProduct(v2, v2.orthogonal()), 1.0e-12);      Vector3D v3 = new Vector3D(-1.7, 1.4, 0.2);      assertEquals(0.0, Vector3D.dotProduct(v3, v3.orthogonal()), 1.0e-12);      try {          new Vector3D(0, 0, 0).orthogonal();          fail("an exception should have been thrown");      } catch (ArithmeticException ae) {          // expected behavior      } catch (Exception e) {          fail("wrong exception caught: " + e.getMessage());      }  }  public void testAngle() {     assertEquals(0.22572612855273393616,                   Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(4, 5, 6)),                  1.0e-12);     assertEquals(7.98595620686106654517199e-8,                   Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(2, 4, 6.000001)),                  1.0e-12);     assertEquals(3.14159257373023116985197793156,                   Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(-2, -4, -6.000001)),                  1.0e-12);     try {         Vector3D.angle(Vector3D.ZERO, Vector3D.PLUS_I);         fail("an exception should have been thrown");     } catch (ArithmeticException ae) {         // expected behavior     } catch (Exception e) {         fail("wrong exception caught: " + e.getMessage());     }  }  private void checkVector(Vector3D v, double x, double y, double z) {      assertEquals(x, v.getX(), 1.0e-12);      assertEquals(y, v.getY(), 1.0e-12);      assertEquals(z, v.getZ(), 1.0e-12);  }    public static Test suite() {    return new TestSuite(Vector3DTest.class);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry;import java.util.Locale;public class Vector3DFormatTest extends Vector3DFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return '.';    }    @Override    protected Locale getLocale() {        return Locale.US;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry;import java.text.NumberFormat;import java.text.ParseException;import java.text.ParsePosition;import java.util.Locale;import junit.framework.TestCase;import org.apache.commons.math.util.CompositeFormat;public abstract class Vector3DFormatAbstractTest extends TestCase {     Vector3DFormat vector3DFormat = null;    Vector3DFormat vector3DFormatSquare = null;    protected abstract Locale getLocale();    protected abstract char getDecimalCharacter();    @Override    protected void setUp() throws Exception {        vector3DFormat = Vector3DFormat.getInstance(getLocale());        final NumberFormat nf = NumberFormat.getInstance(getLocale());        nf.setMaximumFractionDigits(2);        vector3DFormatSquare = new Vector3DFormat("[", "]", " : ", nf);    }       public void testSimpleNoDecimals() {        Vector3D c = new Vector3D(1, 1, 1);        String expected = "{1; 1; 1}";        String actual = vector3DFormat.format(c);         assertEquals(expected, actual);    }    public void testSimpleWithDecimals() {        Vector3D c = new Vector3D(1.23, 1.43, 1.63);        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = vector3DFormat.format(c);         assertEquals(expected, actual);    }    public void testSimpleWithDecimalsTrunc() {        Vector3D c = new Vector3D(1.2323, 1.4343, 1.6333);        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = vector3DFormat.format(c);         assertEquals(expected, actual);    }    public void testNegativeX() {        Vector3D c = new Vector3D(-1.2323, 1.4343, 1.6333);        String expected =            "{-1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = vector3DFormat.format(c);         assertEquals(expected, actual);    }    public void testNegativeY() {        Vector3D c = new Vector3D(1.2323, -1.4343, 1.6333);        String expected =            "{1"    + getDecimalCharacter() +            "23; -1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = vector3DFormat.format(c);         assertEquals(expected, actual);    }    public void testNegativeZ() {        Vector3D c = new Vector3D(1.2323, 1.4343, -1.6333);        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; -1" + getDecimalCharacter() +            "63}";        String actual = vector3DFormat.format(c);         assertEquals(expected, actual);    }    public void testNonDefaultSetting() {        Vector3D c = new Vector3D(1, 1, 1);        String expected = "[1 : 1 : 1]";        String actual = vector3DFormatSquare.format(c);         assertEquals(expected, actual);    }        public void testStaticFormatVector3D() {        Locale defaultLocal = Locale.getDefault();        Locale.setDefault(getLocale());                Vector3D c = new Vector3D(232.222, -342.33, 432.444);        String expected =            "{232"    + getDecimalCharacter() +            "22; -342" + getDecimalCharacter() +            "33; 432" + getDecimalCharacter() +            "44}";        String actual = Vector3DFormat.formatVector3D(c);         assertEquals(expected, actual);                Locale.setDefault(defaultLocal);    }    public void testNan() {        Vector3D c = Vector3D.NaN;        String expected = "{(NaN); (NaN); (NaN)}";        String actual = vector3DFormat.format(c);         assertEquals(expected, actual);    }    public void testPositiveInfinity() {        Vector3D c = Vector3D.POSITIVE_INFINITY;        String expected = "{(Infinity); (Infinity); (Infinity)}";        String actual = vector3DFormat.format(c);         assertEquals(expected, actual);    }    public void tesNegativeInfinity() {        Vector3D c = Vector3D.NEGATIVE_INFINITY;        String expected = "{(-Infinity); (-Infinity); (-Infinity)}";        String actual = vector3DFormat.format(c);         assertEquals(expected, actual);    }    public void testParseSimpleNoDecimals() {        String source = "{1; 1; 1}";        Vector3D expected = new Vector3D(1, 1, 1);        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseIgnoredWhitespace() {        Vector3D expected = new Vector3D(1, 1, 1);        ParsePosition pos1 = new ParsePosition(0);        String source1 = "{1;1;1}";        assertEquals(expected, vector3DFormat.parseObject(source1, pos1));        assertEquals(source1.length(), pos1.getIndex());        ParsePosition pos2 = new ParsePosition(0);        String source2 = " { 1 ; 1 ; 1 } ";        assertEquals(expected, vector3DFormat.parseObject(source2, pos2));        assertEquals(source2.length() - 1, pos2.getIndex());    }    public void testParseSimpleWithDecimals() {        String source =            "{1" + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        Vector3D expected = new Vector3D(1.23, 1.43, 1.63);        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseSimpleWithDecimalsTrunc() {        String source =            "{1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeX() {        String source =            "{-1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(-1.2323, 1.4343, 1.6333);        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeY() {        String source =            "{1" + getDecimalCharacter() +            "2323; -1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(1.2323, -1.4343, 1.6333);        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeZ() {        String source =            "{1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; -1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(1.2323, 1.4343, -1.6333);        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeAll() {        String source =            "{-1" + getDecimalCharacter() +            "2323; -1" + getDecimalCharacter() +            "4343; -1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(-1.2323, -1.4343, -1.6333);        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseZeroX() {        String source =            "{0" + getDecimalCharacter() +            "0; -1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(0.0, -1.4343, 1.6333);        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNonDefaultSetting() {        String source =            "[1" + getDecimalCharacter() +            "2323 : 1" + getDecimalCharacter() +            "4343 : 1" + getDecimalCharacter() +            "6333]";        Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);        try {            Vector3D actual = (Vector3D) vector3DFormatSquare.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }        public void testParseNan() {        String source = "{(NaN); (NaN); (NaN)}";        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);             assertEquals(Vector3D.NaN, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParsePositiveInfinity() {        String source = "{(Infinity); (Infinity); (Infinity)}";        try {            Vector3D actual = (Vector3D)vector3DFormat.parseObject(source);             assertEquals(Vector3D.POSITIVE_INFINITY, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeInfinity() {        String source = "{(-Infinity); (-Infinity); (-Infinity)}";        try {            Vector3D actual = (Vector3D)vector3DFormat.parseObject(source);             assertEquals(Vector3D.NEGATIVE_INFINITY, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testConstructorSingleFormat() {        NumberFormat nf = NumberFormat.getInstance();        Vector3DFormat cf = new Vector3DFormat(nf);        assertNotNull(cf);        assertEquals(nf, cf.getFormat());    }        public void testFormatObject() {        try {            CompositeFormat cf = new Vector3DFormat();            Object object = new Object();            cf.format(object);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }    public void testForgottenPrefix() {        ParsePosition pos = new ParsePosition(0);        assertNull(new Vector3DFormat().parse("1; 1; 1}", pos));        assertEquals(0, pos.getErrorIndex());    }    public void testForgottenSeparator() {        ParsePosition pos = new ParsePosition(0);        assertNull(new Vector3DFormat().parse("{1; 1 1}", pos));        assertEquals(6, pos.getErrorIndex());    }    public void testForgottenSuffix() {        ParsePosition pos = new ParsePosition(0);        assertNull(new Vector3DFormat().parse("{1; 1; 1 ", pos));        assertEquals(8, pos.getErrorIndex());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry;import java.util.Locale;public class FrenchVector3DFormatTest extends Vector3DFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return ',';    }    @Override    protected Locale getLocale() {        return Locale.FRENCH;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry;import java.lang.reflect.Field;import org.apache.commons.math.geometry.RotationOrder;import junit.framework.*;public class RotationOrderTest  extends TestCase {  public RotationOrderTest(String name) {    super(name);  }  public void testName() {    RotationOrder[] orders = {      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX,      RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,      RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ    };    for (int i = 0; i < orders.length; ++i) {      assertEquals(getFieldName(orders[i]), orders[i].toString());    }  }  private String getFieldName(RotationOrder order) {    try {      Field[] fields = RotationOrder.class.getFields();      for (int i = 0; i < fields.length; ++i) {        if (fields[i].get(null) == order) {          return fields[i].getName();        }      }    } catch (IllegalAccessException iae) {      // ignored    }    return "unknown";  }  public static Test suite() {    return new TestSuite(RotationOrderTest.class);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.estimation;import org.apache.commons.math.estimation.EstimatedParameter;import junit.framework.*;@Deprecatedpublic class EstimatedParameterTest  extends TestCase {  public EstimatedParameterTest(String name) {    super(name);  }  public void testConstruction() {    EstimatedParameter p1 = new EstimatedParameter("p1", 1.0);    assertTrue(p1.getName().equals("p1"));    checkValue(p1.getEstimate(), 1.0);    assertTrue(! p1.isBound());    EstimatedParameter p2 = new EstimatedParameter("p2", 2.0, true);    assertTrue(p2.getName().equals("p2"));    checkValue(p2.getEstimate(), 2.0);    assertTrue(p2.isBound());  }  public void testBound() {    EstimatedParameter p = new EstimatedParameter("p", 0.0);    assertTrue(! p.isBound());    p.setBound(true);    assertTrue(p.isBound());    p.setBound(false);    assertTrue(! p.isBound());  }  public void testEstimate() {    EstimatedParameter p = new EstimatedParameter("p", 0.0);    checkValue(p.getEstimate(), 0.0);    for (double e = 0.0; e < 10.0; e += 0.5) {      p.setEstimate(e);      checkValue(p.getEstimate(), e);    }  }  public static Test suite() {    return new TestSuite(EstimatedParameterTest.class);  }  private void checkValue(double value, double expected) {    assertTrue(Math.abs(value - expected) < 1.0e-10);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.estimation;import java.util.ArrayList;import java.util.HashSet;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files.  * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */@Deprecatedpublic class GaussNewtonEstimatorTest  extends TestCase {  public GaussNewtonEstimatorTest(String name) {    super(name);  }  public void testTrivial() throws EstimationException {    LinearProblem problem =      new LinearProblem(new LinearMeasurement[] {        new LinearMeasurement(new double[] {2},                              new EstimatedParameter[] {                                 new EstimatedParameter("p0", 0)                              }, 3.0)      });    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(1.5,                 problem.getUnboundParameters()[0].getEstimate(),                 1.0e-10);   }  public void testQRColumnsPermutation() throws EstimationException {    EstimatedParameter[] x = {       new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 0)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, -1.0 },                            new EstimatedParameter[] { x[0], x[1] },                            4.0),      new LinearMeasurement(new double[] { 2.0 },                            new EstimatedParameter[] { x[1] },                            6.0),      new LinearMeasurement(new double[] { 1.0, -2.0 },                            new EstimatedParameter[] { x[0], x[1] },                            1.0)    });    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(7.0, x[0].getEstimate(), 1.0e-10);    assertEquals(3.0, x[1].getEstimate(), 1.0e-10);  }  public void testNoDependency() throws EstimationException {    EstimatedParameter[] p = new EstimatedParameter[] {      new EstimatedParameter("p0", 0),      new EstimatedParameter("p1", 0),      new EstimatedParameter("p2", 0),      new EstimatedParameter("p3", 0),      new EstimatedParameter("p4", 0),      new EstimatedParameter("p5", 0)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[0] }, 0.0),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[1] }, 1.1),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[2] }, 2.2),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[3] }, 3.3),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[4] }, 4.4),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[5] }, 5.5)    });  GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);  estimator.estimate(problem);  assertEquals(0, estimator.getRMS(problem), 1.0e-10);  for (int i = 0; i < p.length; ++i) {    assertEquals(0.55 * i, p[i].getEstimate(), 1.0e-10);  }}  public void testOneSet() throws EstimationException {    EstimatedParameter[] p = {       new EstimatedParameter("p0", 0),       new EstimatedParameter("p1", 0),       new EstimatedParameter("p2", 0)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0 },                            new EstimatedParameter[] { p[0] },                            1.0),      new LinearMeasurement(new double[] { -1.0, 1.0 },                            new EstimatedParameter[] { p[0], p[1] },                            1.0),      new LinearMeasurement(new double[] { -1.0, 1.0 },                            new EstimatedParameter[] { p[1], p[2] },                            1.0)    });    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(1.0, p[0].getEstimate(), 1.0e-10);    assertEquals(2.0, p[1].getEstimate(), 1.0e-10);    assertEquals(3.0, p[2].getEstimate(), 1.0e-10);  }  public void testTwoSets() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 0),      new EstimatedParameter("p1", 1),      new EstimatedParameter("p2", 2),      new EstimatedParameter("p3", 3),      new EstimatedParameter("p4", 4),      new EstimatedParameter("p5", 5)    };    double epsilon = 1.0e-7;    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      // 4 elements sub-problem      new LinearMeasurement(new double[] {  2.0,  1.0,  4.0 },                            new EstimatedParameter[] { p[0], p[1], p[3] },                            2.0),      new LinearMeasurement(new double[] { -4.0, -2.0,   3.0, -7.0 },                           new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                           -9.0),      new LinearMeasurement(new double[] {  4.0,  1.0,  -2.0,  8.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            2.0),      new LinearMeasurement(new double[] { -3.0, -12.0, -1.0 },                           new EstimatedParameter[] { p[1], p[2], p[3] },                           2.0),      // 2 elements sub-problem      new LinearMeasurement(new double[] { epsilon, 1.0 },                            new EstimatedParameter[] { p[4], p[5] },                            1.0 + epsilon * epsilon),      new LinearMeasurement(new double[] {  1.0, 1.0 },                            new EstimatedParameter[] { p[4], p[5] },                            2.0)    });    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals( 3.0, p[0].getEstimate(), 1.0e-10);    assertEquals( 4.0, p[1].getEstimate(), 1.0e-10);    assertEquals(-1.0, p[2].getEstimate(), 1.0e-10);    assertEquals(-2.0, p[3].getEstimate(), 1.0e-10);    assertEquals( 1.0 + epsilon, p[4].getEstimate(), 1.0e-10);    assertEquals( 1.0 - epsilon, p[5].getEstimate(), 1.0e-10);  }  public void testNonInversible() {    EstimatedParameter[] p = {       new EstimatedParameter("p0", 0),       new EstimatedParameter("p1", 0),       new EstimatedParameter("p2", 0)    };    LinearMeasurement[] m = new LinearMeasurement[] {      new LinearMeasurement(new double[] {  1.0, 2.0, -3.0 },                            new EstimatedParameter[] { p[0], p[1], p[2] },                            1.0),      new LinearMeasurement(new double[] {  2.0, 1.0,  3.0 },                            new EstimatedParameter[] { p[0], p[1], p[2] },                            1.0),      new LinearMeasurement(new double[] { -3.0, -9.0 },                            new EstimatedParameter[] { p[0], p[2] },                            1.0)    };    LinearProblem problem = new LinearProblem(m);    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    try {      estimator.estimate(problem);      fail("an exception should have been caught");    } catch (EstimationException ee) {      // expected behavior    } catch (Exception e) {      fail("wrong exception type caught");    }  }  public void testIllConditioned() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 0),      new EstimatedParameter("p1", 1),      new EstimatedParameter("p2", 2),      new EstimatedParameter("p3", 3)    };    LinearProblem problem1 = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 10.0, 7.0,  8.0,  7.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            32.0),      new LinearMeasurement(new double[] {  7.0, 5.0,  6.0,  5.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            23.0),      new LinearMeasurement(new double[] {  8.0, 6.0, 10.0,  9.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            33.0),      new LinearMeasurement(new double[] {  7.0, 5.0,  9.0, 10.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            31.0)    });    GaussNewtonEstimator estimator1 = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    estimator1.estimate(problem1);    assertEquals(0, estimator1.getRMS(problem1), 1.0e-10);    assertEquals(1.0, p[0].getEstimate(), 1.0e-10);    assertEquals(1.0, p[1].getEstimate(), 1.0e-10);    assertEquals(1.0, p[2].getEstimate(), 1.0e-10);    assertEquals(1.0, p[3].getEstimate(), 1.0e-10);    LinearProblem problem2 = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 10.0, 7.0,  8.1,  7.2 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            32.0),      new LinearMeasurement(new double[] {  7.08, 5.04,  6.0,  5.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            23.0),      new LinearMeasurement(new double[] {  8.0, 5.98, 9.89,  9.0 },                             new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            33.0),      new LinearMeasurement(new double[] {  6.99, 4.99,  9.0, 9.98 },                             new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            31.0)    });    GaussNewtonEstimator estimator2 = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    estimator2.estimate(problem2);    assertEquals(0, estimator2.getRMS(problem2), 1.0e-10);    assertEquals(-81.0, p[0].getEstimate(), 1.0e-8);    assertEquals(137.0, p[1].getEstimate(), 1.0e-8);    assertEquals(-34.0, p[2].getEstimate(), 1.0e-8);    assertEquals( 22.0, p[3].getEstimate(), 1.0e-8);  }  public void testMoreEstimatedParametersSimple() {    EstimatedParameter[] p = {       new EstimatedParameter("p0", 7),       new EstimatedParameter("p1", 6),       new EstimatedParameter("p2", 5),       new EstimatedParameter("p3", 4)     };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 3.0, 2.0 },                             new EstimatedParameter[] { p[0], p[1] },                             7.0),      new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },                             new EstimatedParameter[] { p[1], p[2], p[3] },                             3.0),      new LinearMeasurement(new double[] { 2.0, 1.0 },                             new EstimatedParameter[] { p[0], p[2] },                             5.0)    });    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    try {        estimator.estimate(problem);        fail("an exception should have been caught");    } catch (EstimationException ee) {        // expected behavior    } catch (Exception e) {        fail("wrong exception type caught");    }  }  public void testMoreEstimatedParametersUnsorted() {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 2),      new EstimatedParameter("p1", 2),      new EstimatedParameter("p2", 2),      new EstimatedParameter("p3", 2),      new EstimatedParameter("p4", 2),      new EstimatedParameter("p5", 2)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, 1.0 },                           new EstimatedParameter[] { p[0], p[1] },                           3.0),      new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 },                           new EstimatedParameter[] { p[2], p[3], p[4] },                           12.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                           new EstimatedParameter[] { p[4], p[5] },                           -1.0),      new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },                           new EstimatedParameter[] { p[3], p[2], p[5] },                           7.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                           new EstimatedParameter[] { p[4], p[3] },                           1.0)    });    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    try {        estimator.estimate(problem);        fail("an exception should have been caught");    } catch (EstimationException ee) {        // expected behavior    } catch (Exception e) {        fail("wrong exception type caught");    }  }  public void testRedundantEquations() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 1),      new EstimatedParameter("p1", 1)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, 1.0 },                             new EstimatedParameter[] { p[0], p[1] },                             3.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                             new EstimatedParameter[] { p[0], p[1] },                             1.0),      new LinearMeasurement(new double[] { 1.0, 3.0 },                             new EstimatedParameter[] { p[0], p[1] },                             5.0)    });    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    EstimatedParameter[] all = problem.getAllParameters();    for (int i = 0; i < all.length; ++i) {        assertEquals(all[i].getName().equals("p0") ? 2.0 : 1.0,                     all[i].getEstimate(), 1.0e-10);    }  }  public void testInconsistentEquations() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 1),      new EstimatedParameter("p1", 1)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, 1.0 },                            new EstimatedParameter[] { p[0], p[1] },                            3.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                            new EstimatedParameter[] { p[0], p[1] },                            1.0),      new LinearMeasurement(new double[] { 1.0, 3.0 },                            new EstimatedParameter[] { p[0], p[1] },                            4.0)    });    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    estimator.estimate(problem);    assertTrue(estimator.getRMS(problem) > 0.1);  }  public void testBoundParameters() throws EstimationException {      EstimatedParameter[] p = {        new EstimatedParameter("unbound0", 2, false),        new EstimatedParameter("unbound1", 2, false),        new EstimatedParameter("bound",    2, true)      };      LinearProblem problem = new LinearProblem(new LinearMeasurement[] {        new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 },                              new EstimatedParameter[] { p[0], p[1], p[2] },                              3.0),        new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },                              new EstimatedParameter[] { p[0], p[1], p[2] },                              1.0),        new LinearMeasurement(new double[] { 1.0, 3.0, 2.0 },                              new EstimatedParameter[] { p[0], p[1], p[2] },                              7.0)      });      GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);      estimator.estimate(problem);      assertTrue(estimator.getRMS(problem) < 1.0e-10);      double[][] covariances = estimator.getCovariances(problem);      int i0 = 0, i1 = 1;      if (problem.getUnboundParameters()[0].getName().endsWith("1")) {          i0 = 1;          i1 = 0;      }      assertEquals(11.0 / 24, covariances[i0][i0], 1.0e-10);      assertEquals(-3.0 / 24, covariances[i0][i1], 1.0e-10);      assertEquals(-3.0 / 24, covariances[i1][i0], 1.0e-10);      assertEquals( 3.0 / 24, covariances[i1][i1], 1.0e-10);      double[] errors = estimator.guessParametersErrors(problem);      assertEquals(0, errors[i0], 1.0e-10);      assertEquals(0, errors[i1], 1.0e-10);  }  public void testMaxIterations() {      Circle circle = new Circle(98.680, 47.345);      circle.addPoint( 30.0,  68.0);      circle.addPoint( 50.0,  -6.0);      circle.addPoint(110.0, -20.0);      circle.addPoint( 35.0,  15.0);      circle.addPoint( 45.0,  97.0);      try {        GaussNewtonEstimator estimator = new GaussNewtonEstimator(4, 1.0e-14, 1.0e-14);        estimator.estimate(circle);        fail("an exception should have been caught");      } catch (EstimationException ee) {        // expected behavior      } catch (Exception e) {        fail("wrong exception type caught");      }    }  public void testCircleFitting() throws EstimationException {      Circle circle = new Circle(98.680, 47.345);      circle.addPoint( 30.0,  68.0);      circle.addPoint( 50.0,  -6.0);      circle.addPoint(110.0, -20.0);      circle.addPoint( 35.0,  15.0);      circle.addPoint( 45.0,  97.0);      GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-10, 1.0e-10);      estimator.estimate(circle);      double rms = estimator.getRMS(circle);      assertEquals(1.768262623567235,  Math.sqrt(circle.getM()) * rms,  1.0e-10);      assertEquals(69.96016176931406, circle.getRadius(), 1.0e-10);      assertEquals(96.07590211815305, circle.getX(),      1.0e-10);      assertEquals(48.13516790438953, circle.getY(),      1.0e-10);    }  public void testCircleFittingBadInit() {    Circle circle = new Circle(-12, -12);    double[][] points = new double[][] {      {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},      {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},      {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},      {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},      { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},      { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},      {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},      {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},      {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},      {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},      {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},      { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},      { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},      {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},      {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},      {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},      {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},      {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},      { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},      { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},      { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},      {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},      {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},      {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},      {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},      {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},      { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},      { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},      {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}    };    for (int i = 0; i < points.length; ++i) {      circle.addPoint(points[i][0], points[i][1]);    }    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    try {        estimator.estimate(circle);        fail("an exception should have been caught");    } catch (EstimationException ee) {        // expected behavior    } catch (Exception e) {        fail("wrong exception type caught");    }}  private static class LinearProblem extends SimpleEstimationProblem {    public LinearProblem(LinearMeasurement[] measurements) {      HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>();      for (int i = 0; i < measurements.length; ++i) {        addMeasurement(measurements[i]);        EstimatedParameter[] parameters = measurements[i].getParameters();        for (int j = 0; j < parameters.length; ++j) {          set.add(parameters[j]);        }      }      for (EstimatedParameter p : set) {        addParameter(p);      }    }  }  private static class LinearMeasurement extends WeightedMeasurement {    public LinearMeasurement(double[] factors, EstimatedParameter[] parameters,                             double setPoint) {      super(1.0, setPoint, true);      this.factors = factors;      this.parameters = parameters;      setIgnored(false);    }    @Override    public double getTheoreticalValue() {      double v = 0;      for (int i = 0; i < factors.length; ++i) {        v += factors[i] * parameters[i].getEstimate();      }      return v;    }    @Override    public double getPartial(EstimatedParameter parameter) {      for (int i = 0; i < parameters.length; ++i) {        if (parameters[i] == parameter) {          return factors[i];        }      }      return 0;    }    public EstimatedParameter[] getParameters() {      return parameters;    }    private double[] factors;    private EstimatedParameter[] parameters;    private static final long serialVersionUID = -3922448707008868580L;  }  private static class Circle implements EstimationProblem {    public Circle(double cx, double cy) {      this.cx = new EstimatedParameter("cx", cx);      this.cy = new EstimatedParameter(new EstimatedParameter("cy", cy));      points  = new ArrayList<PointModel>();    }    public void addPoint(double px, double py) {      points.add(new PointModel(px, py));    }    public int getM() {      return points.size();    }    public WeightedMeasurement[] getMeasurements() {      return points.toArray(new PointModel[points.size()]);    }    public EstimatedParameter[] getAllParameters() {      return new EstimatedParameter[] { cx, cy };    }    public EstimatedParameter[] getUnboundParameters() {      return new EstimatedParameter[] { cx, cy };    }    public double getPartialRadiusX() {      double dRdX = 0;      for (PointModel point : points) {        dRdX += point.getPartialDiX();      }      return dRdX / points.size();    }    public double getPartialRadiusY() {      double dRdY = 0;      for (PointModel point : points) {        dRdY += point.getPartialDiY();      }      return dRdY / points.size();    }   public double getRadius() {      double r = 0;      for (PointModel point : points) {        r += point.getCenterDistance();      }      return r / points.size();    }    public double getX() {      return cx.getEstimate();    }    public double getY() {      return cy.getEstimate();    }    private class PointModel extends WeightedMeasurement {      public PointModel(double px, double py) {        super(1.0, 0.0);        this.px = px;        this.py = py;      }      @Override      public double getPartial(EstimatedParameter parameter) {        if (parameter == cx) {          return getPartialDiX() - getPartialRadiusX();        } else if (parameter == cy) {          return getPartialDiY() - getPartialRadiusY();        }        return 0;      }      public double getCenterDistance() {        double dx = px - cx.getEstimate();        double dy = py - cy.getEstimate();        return Math.sqrt(dx * dx + dy * dy);      }      public double getPartialDiX() {        return (cx.getEstimate() - px) / getCenterDistance();      }      public double getPartialDiY() {        return (cy.getEstimate() - py) / getCenterDistance();      }      @Override      public double getTheoreticalValue() {        return getCenterDistance() - getRadius();      }      private double px;      private double py;      private static final long serialVersionUID = 1L;    }    private EstimatedParameter cx;    private EstimatedParameter cy;    private ArrayList<PointModel> points;  }  public static Test suite() {    return new TestSuite(GaussNewtonEstimatorTest.class);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.estimation;import java.util.ArrayList;import java.util.HashSet;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files.  * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */@Deprecatedpublic class LevenbergMarquardtEstimatorTest  extends TestCase {  public LevenbergMarquardtEstimatorTest(String name) {    super(name);  }  public void testTrivial() throws EstimationException {    LinearProblem problem =      new LinearProblem(new LinearMeasurement[] {        new LinearMeasurement(new double[] {2},                              new EstimatedParameter[] {                                 new EstimatedParameter("p0", 0)                              }, 3.0)      });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    try {        estimator.guessParametersErrors(problem);        fail("an exception should have been thrown");    } catch (EstimationException ee) {        // expected behavior    } catch (Exception e) {        fail("wrong exception caught");    }    assertEquals(1.5,                 problem.getUnboundParameters()[0].getEstimate(),                 1.0e-10);   }  public void testQRColumnsPermutation() throws EstimationException {    EstimatedParameter[] x = {       new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 0)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, -1.0 },                            new EstimatedParameter[] { x[0], x[1] },                            4.0),      new LinearMeasurement(new double[] { 2.0 },                            new EstimatedParameter[] { x[1] },                            6.0),      new LinearMeasurement(new double[] { 1.0, -2.0 },                            new EstimatedParameter[] { x[0], x[1] },                            1.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(7.0, x[0].getEstimate(), 1.0e-10);    assertEquals(3.0, x[1].getEstimate(), 1.0e-10);  }  public void testNoDependency() throws EstimationException {    EstimatedParameter[] p = new EstimatedParameter[] {      new EstimatedParameter("p0", 0),      new EstimatedParameter("p1", 0),      new EstimatedParameter("p2", 0),      new EstimatedParameter("p3", 0),      new EstimatedParameter("p4", 0),      new EstimatedParameter("p5", 0)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[0] }, 0.0),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[1] }, 1.1),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[2] }, 2.2),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[3] }, 3.3),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[4] }, 4.4),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[5] }, 5.5)    });  LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();  estimator.estimate(problem);  assertEquals(0, estimator.getRMS(problem), 1.0e-10);  for (int i = 0; i < p.length; ++i) {    assertEquals(0.55 * i, p[i].getEstimate(), 1.0e-10);  }}  public void testOneSet() throws EstimationException {    EstimatedParameter[] p = {       new EstimatedParameter("p0", 0),       new EstimatedParameter("p1", 0),       new EstimatedParameter("p2", 0)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0 },                            new EstimatedParameter[] { p[0] },                            1.0),      new LinearMeasurement(new double[] { -1.0, 1.0 },                            new EstimatedParameter[] { p[0], p[1] },                            1.0),      new LinearMeasurement(new double[] { -1.0, 1.0 },                            new EstimatedParameter[] { p[1], p[2] },                            1.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(1.0, p[0].getEstimate(), 1.0e-10);    assertEquals(2.0, p[1].getEstimate(), 1.0e-10);    assertEquals(3.0, p[2].getEstimate(), 1.0e-10);  }  public void testTwoSets() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 0),      new EstimatedParameter("p1", 1),      new EstimatedParameter("p2", 2),      new EstimatedParameter("p3", 3),      new EstimatedParameter("p4", 4),      new EstimatedParameter("p5", 5)    };    double epsilon = 1.0e-7;    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      // 4 elements sub-problem      new LinearMeasurement(new double[] {  2.0,  1.0,  4.0 },                            new EstimatedParameter[] { p[0], p[1], p[3] },                            2.0),      new LinearMeasurement(new double[] { -4.0, -2.0,   3.0, -7.0 },                           new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                           -9.0),      new LinearMeasurement(new double[] {  4.0,  1.0,  -2.0,  8.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            2.0),      new LinearMeasurement(new double[] { -3.0, -12.0, -1.0 },                           new EstimatedParameter[] { p[1], p[2], p[3] },                           2.0),      // 2 elements sub-problem      new LinearMeasurement(new double[] { epsilon, 1.0 },                            new EstimatedParameter[] { p[4], p[5] },                            1.0 + epsilon * epsilon),      new LinearMeasurement(new double[] {  1.0, 1.0 },                            new EstimatedParameter[] { p[4], p[5] },                            2.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals( 3.0, p[0].getEstimate(), 1.0e-10);    assertEquals( 4.0, p[1].getEstimate(), 1.0e-10);    assertEquals(-1.0, p[2].getEstimate(), 1.0e-10);    assertEquals(-2.0, p[3].getEstimate(), 1.0e-10);    assertEquals( 1.0 + epsilon, p[4].getEstimate(), 1.0e-10);    assertEquals( 1.0 - epsilon, p[5].getEstimate(), 1.0e-10);  }  public void testNonInversible() throws EstimationException {    EstimatedParameter[] p = {       new EstimatedParameter("p0", 0),       new EstimatedParameter("p1", 0),       new EstimatedParameter("p2", 0)    };    LinearMeasurement[] m = new LinearMeasurement[] {      new LinearMeasurement(new double[] {  1.0, 2.0, -3.0 },                            new EstimatedParameter[] { p[0], p[1], p[2] },                            1.0),      new LinearMeasurement(new double[] {  2.0, 1.0,  3.0 },                            new EstimatedParameter[] { p[0], p[1], p[2] },                            1.0),      new LinearMeasurement(new double[] { -3.0, -9.0 },                            new EstimatedParameter[] { p[0], p[2] },                            1.0)    };    LinearProblem problem = new LinearProblem(m);    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    double initialCost = estimator.getRMS(problem);    estimator.estimate(problem);    assertTrue(estimator.getRMS(problem) < initialCost);    assertTrue(Math.sqrt(m.length) * estimator.getRMS(problem) > 0.6);    try {        estimator.getCovariances(problem);        fail("an exception should have been thrown");    } catch (EstimationException ee) {        // expected behavior    } catch (Exception e) {        fail("wrong exception caught");    }   double dJ0 = 2 * (m[0].getResidual() * m[0].getPartial(p[0])                    + m[1].getResidual() * m[1].getPartial(p[0])                    + m[2].getResidual() * m[2].getPartial(p[0]));    double dJ1 = 2 * (m[0].getResidual() * m[0].getPartial(p[1])                    + m[1].getResidual() * m[1].getPartial(p[1]));    double dJ2 = 2 * (m[0].getResidual() * m[0].getPartial(p[2])                    + m[1].getResidual() * m[1].getPartial(p[2])                    + m[2].getResidual() * m[2].getPartial(p[2]));    assertEquals(0, dJ0, 1.0e-10);    assertEquals(0, dJ1, 1.0e-10);    assertEquals(0, dJ2, 1.0e-10);  }  public void testIllConditioned() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 0),      new EstimatedParameter("p1", 1),      new EstimatedParameter("p2", 2),      new EstimatedParameter("p3", 3)    };    LinearProblem problem1 = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 10.0, 7.0,  8.0,  7.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            32.0),      new LinearMeasurement(new double[] {  7.0, 5.0,  6.0,  5.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            23.0),      new LinearMeasurement(new double[] {  8.0, 6.0, 10.0,  9.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            33.0),      new LinearMeasurement(new double[] {  7.0, 5.0,  9.0, 10.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            31.0)    });    LevenbergMarquardtEstimator estimator1 = new LevenbergMarquardtEstimator();    estimator1.estimate(problem1);    assertEquals(0, estimator1.getRMS(problem1), 1.0e-10);    assertEquals(1.0, p[0].getEstimate(), 1.0e-10);    assertEquals(1.0, p[1].getEstimate(), 1.0e-10);    assertEquals(1.0, p[2].getEstimate(), 1.0e-10);    assertEquals(1.0, p[3].getEstimate(), 1.0e-10);    LinearProblem problem2 = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 10.0, 7.0,  8.1,  7.2 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            32.0),      new LinearMeasurement(new double[] {  7.08, 5.04,  6.0,  5.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            23.0),      new LinearMeasurement(new double[] {  8.0, 5.98, 9.89,  9.0 },                             new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            33.0),      new LinearMeasurement(new double[] {  6.99, 4.99,  9.0, 9.98 },                             new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            31.0)    });    LevenbergMarquardtEstimator estimator2 = new LevenbergMarquardtEstimator();    estimator2.estimate(problem2);    assertEquals(0, estimator2.getRMS(problem2), 1.0e-10);    assertEquals(-81.0, p[0].getEstimate(), 1.0e-8);    assertEquals(137.0, p[1].getEstimate(), 1.0e-8);    assertEquals(-34.0, p[2].getEstimate(), 1.0e-8);    assertEquals( 22.0, p[3].getEstimate(), 1.0e-8);  }  public void testMoreEstimatedParametersSimple() throws EstimationException {    EstimatedParameter[] p = {       new EstimatedParameter("p0", 7),       new EstimatedParameter("p1", 6),       new EstimatedParameter("p2", 5),       new EstimatedParameter("p3", 4)     };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 3.0, 2.0 },                             new EstimatedParameter[] { p[0], p[1] },                             7.0),      new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },                             new EstimatedParameter[] { p[1], p[2], p[3] },                             3.0),      new LinearMeasurement(new double[] { 2.0, 1.0 },                             new EstimatedParameter[] { p[0], p[2] },                             5.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);  }  public void testMoreEstimatedParametersUnsorted() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 2),      new EstimatedParameter("p1", 2),      new EstimatedParameter("p2", 2),      new EstimatedParameter("p3", 2),      new EstimatedParameter("p4", 2),      new EstimatedParameter("p5", 2)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, 1.0 },                           new EstimatedParameter[] { p[0], p[1] },                           3.0),      new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 },                           new EstimatedParameter[] { p[2], p[3], p[4] },                           12.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                           new EstimatedParameter[] { p[4], p[5] },                           -1.0),      new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },                           new EstimatedParameter[] { p[3], p[2], p[5] },                           7.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                           new EstimatedParameter[] { p[4], p[3] },                           1.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(3.0, p[2].getEstimate(), 1.0e-10);    assertEquals(4.0, p[3].getEstimate(), 1.0e-10);    assertEquals(5.0, p[4].getEstimate(), 1.0e-10);    assertEquals(6.0, p[5].getEstimate(), 1.0e-10);  }  public void testRedundantEquations() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 1),      new EstimatedParameter("p1", 1)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, 1.0 },                             new EstimatedParameter[] { p[0], p[1] },                             3.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                             new EstimatedParameter[] { p[0], p[1] },                             1.0),      new LinearMeasurement(new double[] { 1.0, 3.0 },                             new EstimatedParameter[] { p[0], p[1] },                             5.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(2.0, p[0].getEstimate(), 1.0e-10);    assertEquals(1.0, p[1].getEstimate(), 1.0e-10);  }  public void testInconsistentEquations() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 1),      new EstimatedParameter("p1", 1)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, 1.0 },                            new EstimatedParameter[] { p[0], p[1] },                            3.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                            new EstimatedParameter[] { p[0], p[1] },                            1.0),      new LinearMeasurement(new double[] { 1.0, 3.0 },                            new EstimatedParameter[] { p[0], p[1] },                            4.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertTrue(estimator.getRMS(problem) > 0.1);  }  public void testControlParameters() {      Circle circle = new Circle(98.680, 47.345);      circle.addPoint( 30.0,  68.0);      circle.addPoint( 50.0,  -6.0);      circle.addPoint(110.0, -20.0);      circle.addPoint( 35.0,  15.0);      circle.addPoint( 45.0,  97.0);      checkEstimate(circle, 0.1, 10, 1.0e-14, 1.0e-16, 1.0e-10, false);      checkEstimate(circle, 0.1, 10, 1.0e-15, 1.0e-17, 1.0e-10, true);      checkEstimate(circle, 0.1,  5, 1.0e-15, 1.0e-16, 1.0e-10, true);      circle.addPoint(300, -300);      checkEstimate(circle, 0.1, 20, 1.0e-18, 1.0e-16, 1.0e-10, true);  }  private void checkEstimate(EstimationProblem problem,                             double initialStepBoundFactor, int maxCostEval,                             double costRelativeTolerance, double parRelativeTolerance,                             double orthoTolerance, boolean shouldFail) {      try {        LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();        estimator.setInitialStepBoundFactor(initialStepBoundFactor);        estimator.setMaxCostEval(maxCostEval);        estimator.setCostRelativeTolerance(costRelativeTolerance);        estimator.setParRelativeTolerance(parRelativeTolerance);        estimator.setOrthoTolerance(orthoTolerance);        estimator.estimate(problem);        assertTrue(! shouldFail);      } catch (EstimationException ee) {        assertTrue(shouldFail);      } catch (Exception e) {        fail("wrong exception type caught");      }    }  public void testCircleFitting() throws EstimationException {      Circle circle = new Circle(98.680, 47.345);      circle.addPoint( 30.0,  68.0);      circle.addPoint( 50.0,  -6.0);      circle.addPoint(110.0, -20.0);      circle.addPoint( 35.0,  15.0);      circle.addPoint( 45.0,  97.0);      LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();      estimator.estimate(circle);      assertTrue(estimator.getCostEvaluations() < 10);      assertTrue(estimator.getJacobianEvaluations() < 10);      double rms = estimator.getRMS(circle);      assertEquals(1.768262623567235,  Math.sqrt(circle.getM()) * rms,  1.0e-10);      assertEquals(69.96016176931406, circle.getRadius(), 1.0e-10);      assertEquals(96.07590211815305, circle.getX(),      1.0e-10);      assertEquals(48.13516790438953, circle.getY(),      1.0e-10);      double[][] cov = estimator.getCovariances(circle);      assertEquals(1.839, cov[0][0], 0.001);      assertEquals(0.731, cov[0][1], 0.001);      assertEquals(cov[0][1], cov[1][0], 1.0e-14);      assertEquals(0.786, cov[1][1], 0.001);      double[] errors = estimator.guessParametersErrors(circle);      assertEquals(1.384, errors[0], 0.001);      assertEquals(0.905, errors[1], 0.001);        // add perfect measurements and check errors are reduced      double cx = circle.getX();      double cy = circle.getY();      double  r = circle.getRadius();      for (double d= 0; d < 2 * Math.PI; d += 0.01) {          circle.addPoint(cx + r * Math.cos(d), cy + r * Math.sin(d));      }      estimator = new LevenbergMarquardtEstimator();      estimator.estimate(circle);      cov = estimator.getCovariances(circle);      assertEquals(0.004, cov[0][0], 0.001);      assertEquals(6.40e-7, cov[0][1], 1.0e-9);      assertEquals(cov[0][1], cov[1][0], 1.0e-14);      assertEquals(0.003, cov[1][1], 0.001);      errors = estimator.guessParametersErrors(circle);      assertEquals(0.004, errors[0], 0.001);      assertEquals(0.004, errors[1], 0.001);  }  public void testCircleFittingBadInit() throws EstimationException {    Circle circle = new Circle(-12, -12);    double[][] points = new double[][] {      {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},      {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},      {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},      {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},      { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},      { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},      {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},      {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},      {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},      {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},      {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},      { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},      { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},      {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},      {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},      {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},      {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},      {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},      { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},      { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},      { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},      {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},      {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},      {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},      {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},      {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},      { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},      { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},      {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}    };    for (int i = 0; i < points.length; ++i) {      circle.addPoint(points[i][0], points[i][1]);    }    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(circle);    assertTrue(estimator.getCostEvaluations() < 15);    assertTrue(estimator.getJacobianEvaluations() < 10);    assertEquals( 0.030184491196225207, estimator.getRMS(circle), 1.0e-9);    assertEquals( 0.2922350065939634,   circle.getRadius(), 1.0e-9);    assertEquals(-0.15173845023862165,  circle.getX(),      1.0e-8);    assertEquals( 0.20750021499570379,  circle.getY(),      1.0e-8);  }  public void testMath199() {      try {          QuadraticProblem problem = new QuadraticProblem();          problem.addPoint (0, -3.182591015485607, 0.0);          problem.addPoint (1, -2.5581184967730577, 4.4E-323);          problem.addPoint (2, -2.1488478161387325, 1.0);          problem.addPoint (3, -1.9122489313410047, 4.4E-323);          problem.addPoint (4, 1.7785661310051026, 0.0);          new LevenbergMarquardtEstimator().estimate(problem);          fail("an exception should have been thrown");      } catch (EstimationException ee) {          // expected behavior      }  }  private static class LinearProblem implements EstimationProblem {    public LinearProblem(LinearMeasurement[] measurements) {      this.measurements = measurements;    }    public WeightedMeasurement[] getMeasurements() {      return measurements;    }    public EstimatedParameter[] getUnboundParameters() {      return getAllParameters();    }    public EstimatedParameter[] getAllParameters() {      HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>();      for (int i = 0; i < measurements.length; ++i) {        EstimatedParameter[] parameters = measurements[i].getParameters();        for (int j = 0; j < parameters.length; ++j) {          set.add(parameters[j]);        }      }      return set.toArray(new EstimatedParameter[set.size()]);    }      private LinearMeasurement[] measurements;  }  private static class LinearMeasurement extends WeightedMeasurement {    public LinearMeasurement(double[] factors, EstimatedParameter[] parameters,                             double setPoint) {      super(1.0, setPoint);      this.factors = factors;      this.parameters = parameters;    }    @Override    public double getTheoreticalValue() {      double v = 0;      for (int i = 0; i < factors.length; ++i) {        v += factors[i] * parameters[i].getEstimate();      }      return v;    }    @Override    public double getPartial(EstimatedParameter parameter) {      for (int i = 0; i < parameters.length; ++i) {        if (parameters[i] == parameter) {          return factors[i];        }      }      return 0;    }    public EstimatedParameter[] getParameters() {      return parameters;    }    private double[] factors;    private EstimatedParameter[] parameters;    private static final long serialVersionUID = -3922448707008868580L;  }  private static class Circle implements EstimationProblem {    public Circle(double cx, double cy) {      this.cx = new EstimatedParameter("cx", cx);      this.cy = new EstimatedParameter("cy", cy);      points  = new ArrayList<PointModel>();    }    public void addPoint(double px, double py) {      points.add(new PointModel(px, py));    }    public int getM() {      return points.size();    }    public WeightedMeasurement[] getMeasurements() {      return points.toArray(new PointModel[points.size()]);    }    public EstimatedParameter[] getAllParameters() {      return new EstimatedParameter[] { cx, cy };    }    public EstimatedParameter[] getUnboundParameters() {      return new EstimatedParameter[] { cx, cy };    }    public double getPartialRadiusX() {      double dRdX = 0;      for (PointModel point : points) {        dRdX += point.getPartialDiX();      }      return dRdX / points.size();    }    public double getPartialRadiusY() {      double dRdY = 0;      for (PointModel point : points) {        dRdY += point.getPartialDiY();      }      return dRdY / points.size();    }   public double getRadius() {      double r = 0;      for (PointModel point : points) {        r += point.getCenterDistance();      }      return r / points.size();    }    public double getX() {      return cx.getEstimate();    }    public double getY() {      return cy.getEstimate();    }    private class PointModel extends WeightedMeasurement {      public PointModel(double px, double py) {        super(1.0, 0.0);        this.px = px;        this.py = py;      }      @Override      public double getPartial(EstimatedParameter parameter) {        if (parameter == cx) {          return getPartialDiX() - getPartialRadiusX();        } else if (parameter == cy) {          return getPartialDiY() - getPartialRadiusY();        }        return 0;      }      public double getCenterDistance() {        double dx = px - cx.getEstimate();        double dy = py - cy.getEstimate();        return Math.sqrt(dx * dx + dy * dy);      }      public double getPartialDiX() {        return (cx.getEstimate() - px) / getCenterDistance();      }      public double getPartialDiY() {        return (cy.getEstimate() - py) / getCenterDistance();      }      @Override      public double getTheoreticalValue() {        return getCenterDistance() - getRadius();      }      private double px;      private double py;      private static final long serialVersionUID = 1L;    }    private EstimatedParameter cx;    private EstimatedParameter cy;    private ArrayList<PointModel> points;  }  private static class QuadraticProblem extends SimpleEstimationProblem {      private EstimatedParameter a;      private EstimatedParameter b;      private EstimatedParameter c;      public QuadraticProblem() {          a = new EstimatedParameter("a", 0.0);          b = new EstimatedParameter("b", 0.0);          c = new EstimatedParameter("c", 0.0);          addParameter(a);          addParameter(b);          addParameter(c);      }      public void addPoint(double x, double y, double w) {          addMeasurement(new LocalMeasurement(x, y, w));      }      public double getA() {          return a.getEstimate();      }      public double getB() {          return b.getEstimate();      }      public double getC() {          return c.getEstimate();      }      public double theoreticalValue(double x) {          return ( (a.getEstimate() * x + b.getEstimate() ) * x + c.getEstimate());      }      private double partial(double x, EstimatedParameter parameter) {          if (parameter == a) {              return x * x;          } else if (parameter == b) {              return x;          } else {              return 1.0;          }      }      private class LocalMeasurement extends WeightedMeasurement {        private static final long serialVersionUID = 1555043155023729130L;        private final double x;          // constructor          public LocalMeasurement(double x, double y, double w) {              super(w, y);              this.x = x;          }          @Override          public double getTheoreticalValue() {              return theoreticalValue(x);          }          @Override          public double getPartial(EstimatedParameter parameter) {              return partial(x, parameter);          }      }  }  public static Test suite() {    return new TestSuite(LevenbergMarquardtEstimatorTest.class);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.estimation;import org.apache.commons.math.estimation.EstimatedParameter;import org.apache.commons.math.estimation.WeightedMeasurement;import junit.framework.*;@Deprecatedpublic class WeightedMeasurementTest  extends TestCase {  public WeightedMeasurementTest(String name) {    super(name);    p1 = null;    p2 = null;  }  public void testConstruction() {    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);    checkValue(m.getWeight(), 3.0);    checkValue(m.getMeasuredValue(), theoretical() + 0.1);  }  public void testIgnored() {    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);    assertTrue(!m.isIgnored());    m.setIgnored(true);    assertTrue(m.isIgnored());    m.setIgnored(false);    assertTrue(!m.isIgnored());  }  public void testTheory() {    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);    checkValue(m.getTheoreticalValue(), theoretical());    checkValue(m.getResidual(), 0.1);    double oldP1 = p1.getEstimate();    p1.setEstimate(oldP1 + m.getResidual() / m.getPartial(p1));    checkValue(m.getResidual(), 0.0);    p1.setEstimate(oldP1);    checkValue(m.getResidual(), 0.1);    double oldP2 = p2.getEstimate();    p2.setEstimate(oldP2 + m.getResidual() / m.getPartial(p2));    checkValue(m.getResidual(), 0.0);    p2.setEstimate(oldP2);    checkValue(m.getResidual(), 0.1);  }  public static Test suite() {    return new TestSuite(WeightedMeasurementTest.class);  }  @Override  public void setUp() {    p1 = new EstimatedParameter("p1", 1.0);    p2 = new EstimatedParameter("p2", 2.0);  }  @Override  public void tearDown() {    p1 = null;    p2 = null;  }  private void checkValue(double value, double expected) {   assertTrue(Math.abs(value - expected) < 1.0e-10);  }  private double theoretical() {   return 3 * p1.getEstimate() - p2.getEstimate();  }  private double partial(EstimatedParameter p) {    if (p == p1) {      return 3.0;    } else if (p == p2) {      return -1.0;    } else {      return 0.0;    }  }  private static class MyMeasurement    extends WeightedMeasurement {    public MyMeasurement(double weight, double measuredValue,                         WeightedMeasurementTest testInstance) {      super(weight, measuredValue);      this.testInstance = testInstance;    }    @Override    public double getTheoreticalValue() {      return testInstance.theoretical();    }    @Override    public double getPartial(EstimatedParameter p) {      return testInstance.partial(p);    }    private transient WeightedMeasurementTest testInstance;    private static final long serialVersionUID = -246712922500792332L;  }  private EstimatedParameter p1;  private EstimatedParameter p2;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.estimation;import java.util.Arrays;import org.apache.commons.math.estimation.EstimatedParameter;import org.apache.commons.math.estimation.EstimationException;import org.apache.commons.math.estimation.EstimationProblem;import org.apache.commons.math.estimation.LevenbergMarquardtEstimator;import org.apache.commons.math.estimation.WeightedMeasurement;import junit.framework.*;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files.  * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */@Deprecatedpublic class MinpackTest  extends TestCase {  public MinpackTest(String name) {    super(name);  }  public void testMinpackLinearFullRank() {    minpackTest(new LinearFullRankFunction(10, 5, 1.0,                                           5.0, 2.23606797749979), false);    minpackTest(new LinearFullRankFunction(50, 5, 1.0,                                           8.06225774829855, 6.70820393249937), false);  }  public void testMinpackLinearRank1() {    minpackTest(new LinearRank1Function(10, 5, 1.0,                                        291.521868819476, 1.4638501094228), false);    minpackTest(new LinearRank1Function(50, 5, 1.0,                                        3101.60039334535, 3.48263016573496), false);  }  public void testMinpackLinearRank1ZeroColsAndRows() {    minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false);    minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false);  }  public void testMinpackRosenbrok() {    minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },                                       Math.sqrt(24.2)), false);    minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 },                                       Math.sqrt(1795769.0)), false);    minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 },                                       11.0 * Math.sqrt(169000121.0)), false);  }  public void testMinpackHelicalValley() {    minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 },                                          50.0), false);    minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 },                                          102.95630140987), false);    minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0},                                          991.261822123701), false);  }      public void testMinpackPowellSingular() {    minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },                                           14.6628782986152), false);    minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 },                                           1270.9838708654), false);    minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 },                                           126887.903284750), false);  }      public void testMinpackFreudensteinRoth() {    minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },                                             20.0124960961895, 6.99887517584575,                                             new double[] {                                               11.4124844654993,                                               -0.896827913731509                                             }), false);    minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },                                             12432.833948863, 6.9988751744895,                                             new double[] {                                               11.4130046614746,                                               -0.896796038685958                                             }), false);    minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },                                             11426454.595762, 6.99887517242903,                                             new double[] {                                               11.4127817857886,                                               -0.89680510749204                                             }), false);  }      public void testMinpackBard() {    minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,                                 new double[] {                                   0.0824105765758334,                                   1.1330366534715,                                   2.34369463894115                                 }), false);    minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539,                                 new double[] {                                   0.840666673818329,                                   -158848033.259565,                                   -164378671.653535                                 }), false);    minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969,                                 new double[] {                                   0.840666673867645,                                   -158946167.205518,                                   -164464906.857771                                 }), false);  }      public void testMinpackKowalikOsborne() {    minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },                                           0.0728915102882945,                                           0.017535837721129,                                           new double[] {                                             0.192807810476249,                                             0.191262653354071,                                             0.123052801046931,                                             0.136053221150517                                           }), false);    minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 },                                           2.97937007555202,                                           0.032052192917937,                                           new double[] {                                             728675.473768287,                                             -14.0758803129393,                                             -32977797.7841797,                                             -20571594.1977912                                           }), false);    minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 },                                           29.9590617016037,                                           0.0175364017658228,                                           new double[] {                                             0.192948328597594,                                             0.188053165007911,                                             0.122430604321144,                                             0.134575665392506                                           }), true);  }      public void testMinpackMeyer() {    minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },                                  41153.4665543031, 9.37794514651874,                                  new double[] {                                    0.00560963647102661,                                    6181.34634628659,                                    345.223634624144                                  }), false);    minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 },                                  4168216.89130846, 792.917871779501,                                  new double[] {                                    1.42367074157994e-11,                                    33695.7133432541,                                    901.268527953801                                  }), true);  }      public void testMinpackWatson() {      minpackTest(new WatsonFunction(6, 0.0,                                   5.47722557505166, 0.0478295939097601,                                   new double[] {                                     -0.0157249615083782, 1.01243488232965,                                     -0.232991722387673,  1.26043101102818,                                     -1.51373031394421,   0.99299727291842                                   }), false);    minpackTest(new WatsonFunction(6, 10.0,                                   6433.12578950026, 0.0478295939096951,                                   new double[] {                                     -0.0157251901386677, 1.01243485860105,                                     -0.232991545843829,  1.26042932089163,                                     -1.51372776706575,   0.99299573426328                                   }), false);    minpackTest(new WatsonFunction(6, 100.0,                                   674256.040605213, 0.047829593911544,                                   new double[] {                                    -0.0157247019712586, 1.01243490925658,                                    -0.232991922761641,  1.26043292929555,                                    -1.51373320452707,   0.99299901922322                                   }), false);    minpackTest(new WatsonFunction(9, 0.0,                                   5.47722557505166, 0.00118311459212420,                                   new double[] {                                    -0.153070644166722e-4, 0.999789703934597,                                     0.0147639634910978,   0.146342330145992,                                     1.00082109454817,    -2.61773112070507,                                     4.10440313943354,    -3.14361226236241,                                     1.05262640378759                                   }), false);    minpackTest(new WatsonFunction(9, 10.0,                                   12088.127069307, 0.00118311459212513,                                   new double[] {                                   -0.153071334849279e-4, 0.999789703941234,                                    0.0147639629786217,   0.146342334818836,                                    1.00082107321386,    -2.61773107084722,                                    4.10440307655564,    -3.14361222178686,                                    1.05262639322589                                   }), false);    minpackTest(new WatsonFunction(9, 100.0,                                   1269109.29043834, 0.00118311459212384,                                   new double[] {                                    -0.153069523352176e-4, 0.999789703958371,                                     0.0147639625185392,   0.146342341096326,                                     1.00082104729164,    -2.61773101573645,                                     4.10440301427286,    -3.14361218602503,                                     1.05262638516774                                   }), false);    minpackTest(new WatsonFunction(12, 0.0,                                   5.47722557505166, 0.217310402535861e-4,                                   new double[] {                                    -0.660266001396382e-8, 1.00000164411833,                                    -0.000563932146980154, 0.347820540050756,                                    -0.156731500244233,    1.05281515825593,                                    -3.24727109519451,     7.2884347837505,                                   -10.271848098614,       9.07411353715783,                                    -4.54137541918194,     1.01201187975044                                   }), false);    minpackTest(new WatsonFunction(12, 10.0,                                   19220.7589790951, 0.217310402518509e-4,                                   new double[] {                                    -0.663710223017410e-8, 1.00000164411787,                                    -0.000563932208347327, 0.347820540486998,                                    -0.156731503955652,    1.05281517654573,                                    -3.2472711515214,      7.28843489430665,                                   -10.2718482369638,      9.07411364383733,                                    -4.54137546533666,     1.01201188830857                                   }), false);    minpackTest(new WatsonFunction(12, 100.0,                                   2018918.04462367, 0.217310402539845e-4,                                   new double[] {                                    -0.663806046485249e-8, 1.00000164411786,                                    -0.000563932210324959, 0.347820540503588,                                    -0.156731504091375,    1.05281517718031,                                    -3.24727115337025,     7.28843489775302,                                   -10.2718482410813,      9.07411364688464,                                    -4.54137546660822,     1.0120118885369                                   }), false);  }      public void testMinpackBox3Dimensional() {    minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },                                            32.1115837449572), false);  }      public void testMinpackJennrichSampson() {    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },                                            64.5856498144943, 11.1517793413499,                                            new double[] {                                             0.257819926636811, 0.257829976764542                                            }), false);  }  public void testMinpackBrownDennis() {    minpackTest(new BrownDennisFunction(20,                                        new double[] { 25.0, 5.0, -5.0, -1.0 },                                        2815.43839161816, 292.954288244866,                                        new double[] {                                         -11.59125141003, 13.2024883984741,                                         -0.403574643314272, 0.236736269844604                                        }), false);    minpackTest(new BrownDennisFunction(20,                                        new double[] { 250.0, 50.0, -50.0, -10.0 },                                        555073.354173069, 292.954270581415,                                        new double[] {                                         -11.5959274272203, 13.2041866926242,                                         -0.403417362841545, 0.236771143410386                                       }), false);    minpackTest(new BrownDennisFunction(20,                                        new double[] { 2500.0, 500.0, -500.0, -100.0 },                                        61211252.2338581, 292.954306151134,                                        new double[] {                                         -11.5902596937374, 13.2020628854665,                                         -0.403688070279258, 0.236665033746463                                        }), false);  }      public void testMinpackChebyquad() {    minpackTest(new ChebyquadFunction(1, 8, 1.0,                                      1.88623796907732, 1.88623796907732,                                      new double[] { 0.5 }), false);    minpackTest(new ChebyquadFunction(1, 8, 10.0,                                      5383344372.34005, 1.88424820499951,                                      new double[] { 0.9817314924684 }), false);    minpackTest(new ChebyquadFunction(1, 8, 100.0,                                      0.118088726698392e19, 1.88424820499347,                                      new double[] { 0.9817314852934 }), false);    minpackTest(new ChebyquadFunction(8, 8, 1.0,                                      0.196513862833975, 0.0593032355046727,                                      new double[] {                                        0.0431536648587336, 0.193091637843267,                                        0.266328593812698,  0.499999334628884,                                        0.500000665371116,  0.733671406187302,                                        0.806908362156733,  0.956846335141266                                      }), false);    minpackTest(new ChebyquadFunction(9, 9, 1.0,                                      0.16994993465202, 0.0,                                      new double[] {                                        0.0442053461357828, 0.199490672309881,                                        0.23561910847106,   0.416046907892598,                                        0.5,                0.583953092107402,                                        0.764380891528940,  0.800509327690119,                                        0.955794653864217                                      }), false);    minpackTest(new ChebyquadFunction(10, 10, 1.0,                                      0.183747831178711, 0.0806471004038253,                                      new double[] {                                        0.0596202671753563, 0.166708783805937,                                        0.239171018813509,  0.398885290346268,                                        0.398883667870681,  0.601116332129320,                                        0.60111470965373,   0.760828981186491,                                        0.833291216194063,  0.940379732824644                                      }), false);  }      public void testMinpackBrownAlmostLinear() {    minpackTest(new BrownAlmostLinearFunction(10, 0.5,                                              16.5302162063499, 0.0,                                              new double[] {                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 1.20569696650138                                              }), false);    minpackTest(new BrownAlmostLinearFunction(10, 5.0,                                              9765624.00089211, 0.0,                                              new double[] {                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 1.20569696650135                                              }), false);      minpackTest(new BrownAlmostLinearFunction(10, 50.0,                                              0.9765625e17, 0.0,                                              new double[] {                                                1.0, 1.0, 1.0, 1.0, 1.0,                                                1.0, 1.0, 1.0, 1.0, 1.0                                              }), false);    minpackTest(new BrownAlmostLinearFunction(30, 0.5,                                              83.476044467848, 0.0,                                              new double[] {                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 1.06737350671578                                              }), false);    minpackTest(new BrownAlmostLinearFunction(40, 0.5,                                              128.026364472323, 0.0,                                              new double[] {                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                0.999999999999121                                              }), false);    }      public void testMinpackOsborne1() {      minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },                                       0.937564021037838, 0.00739249260904843,                                       new double[] {                                         0.375410049244025, 1.93584654543108,                                        -1.46468676748716, 0.0128675339110439,                                         0.0221227011813076                                       }), false);    }      public void testMinpackOsborne2() {          minpackTest(new Osborne2Function(new double[] {                                       1.3, 0.65, 0.65, 0.7, 0.6,                                       3.0, 5.0, 7.0, 2.0, 4.5, 5.5                                     },                                     1.44686540984712, 0.20034404483314,                                     new double[] {                                       1.30997663810096,  0.43155248076,                                       0.633661261602859, 0.599428560991695,                                       0.754179768272449, 0.904300082378518,                                       1.36579949521007, 4.82373199748107,                                       2.39868475104871, 4.56887554791452,                                       5.67534206273052                                     }), false);  }  private void minpackTest(MinpackFunction function, boolean exceptionExpected) {    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.setMaxCostEval(100 * (function.getN() + 1));    estimator.setCostRelativeTolerance(Math.sqrt(2.22044604926e-16));    estimator.setParRelativeTolerance(Math.sqrt(2.22044604926e-16));    estimator.setOrthoTolerance(2.22044604926e-16);    assertTrue(function.checkTheoreticalStartCost(estimator.getRMS(function)));    try {      estimator.estimate(function);      assertFalse(exceptionExpected);    } catch (EstimationException lsse) {      assertTrue(exceptionExpected);    }    assertTrue(function.checkTheoreticalMinCost(estimator.getRMS(function)));    assertTrue(function.checkTheoreticalMinParams());  }  private static abstract class MinpackFunction implements EstimationProblem {     protected MinpackFunction(int m,                              double[] startParams,                              double   theoreticalStartCost,                              double   theoreticalMinCost,                              double[] theoreticalMinParams) {      this.m = m;      this.n = startParams.length;      parameters = new EstimatedParameter[n];      for (int i = 0; i < n; ++i) {        parameters[i] = new EstimatedParameter("p" + i, startParams[i]);      }      this.theoreticalStartCost = theoreticalStartCost;      this.theoreticalMinCost   = theoreticalMinCost;      this.theoreticalMinParams = theoreticalMinParams;      this.costAccuracy         = 1.0e-8;      this.paramsAccuracy       = 1.0e-5;    }    protected static double[] buildArray(int n, double x) {      double[] array = new double[n];      Arrays.fill(array, x);      return array;    }    protected void setCostAccuracy(double costAccuracy) {      this.costAccuracy = costAccuracy;    }    protected void setParamsAccuracy(double paramsAccuracy) {      this.paramsAccuracy = paramsAccuracy;    }    public int getN() {      return parameters.length;    }    public boolean checkTheoreticalStartCost(double rms) {      double threshold = costAccuracy * (1.0 + theoreticalStartCost);      return Math.abs(Math.sqrt(m) * rms - theoreticalStartCost) <= threshold;    }    public boolean checkTheoreticalMinCost(double rms) {      double threshold = costAccuracy * (1.0 + theoreticalMinCost);     return Math.abs(Math.sqrt(m) * rms - theoreticalMinCost) <= threshold;    }    public boolean checkTheoreticalMinParams() {      if (theoreticalMinParams != null) {        for (int i = 0; i < theoreticalMinParams.length; ++i) {          double mi = theoreticalMinParams[i];          double vi = parameters[i].getEstimate();          if (Math.abs(mi - vi) > (paramsAccuracy * (1.0 + Math.abs(mi)))) {            return false;          }        }      }      return true;    }     public WeightedMeasurement[] getMeasurements() {      WeightedMeasurement[] measurements = new WeightedMeasurement[m];      for (int i = 0; i < m; ++i) {        measurements[i] = new MinpackMeasurement(i);      }      return measurements;    }    public EstimatedParameter[] getUnboundParameters() {      return parameters;    }    public EstimatedParameter[] getAllParameters() {      return parameters;    }    protected abstract double[][] getJacobian();    protected abstract double[] getResiduals();    private class MinpackMeasurement extends WeightedMeasurement {      public MinpackMeasurement(int index) {        super(1.0, 0.0);        this.index = index;      }      @Override      public double getTheoreticalValue() {        // this is obviously NOT efficient as we recompute the whole vector        // each time we need only one element, but it is only for test        // purposes and is simpler to check.        // This implementation should NOT be taken as an example, it is ugly!        return getResiduals()[index];      }      @Override      public double getPartial(EstimatedParameter parameter) {        // this is obviously NOT efficient as we recompute the whole jacobian        // each time we need only one element, but it is only for test        // purposes and is simpler to check.        // This implementation should NOT be taken as an example, it is ugly!        for (int j = 0; j < n; ++j) {          if (parameter == parameters[j]) {            return getJacobian()[index][j];          }        }        return 0;      }      private int index;      private static final long serialVersionUID = 1L;    }    protected int                  n;    protected int                  m;    protected EstimatedParameter[] parameters;    protected double               theoreticalStartCost;    protected double               theoreticalMinCost;    protected double[]             theoreticalMinParams;    protected double               costAccuracy;    protected double               paramsAccuracy;  }  private static class LinearFullRankFunction extends MinpackFunction {    public LinearFullRankFunction(int m, int n, double x0,                                  double theoreticalStartCost,                                  double theoreticalMinCost) {      super(m, buildArray(n, x0), theoreticalStartCost,            theoreticalMinCost, buildArray(n, -1.0));    }    @Override    protected double[][] getJacobian() {      double t = 2.0 / m;      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = (i == j) ? (1 - t) : -t;        }      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double sum = 0;      for (int i = 0; i < n; ++i) {        sum += parameters[i].getEstimate();      }      double t  = 1 + 2 * sum / m;      double[] f = new double[m];      for (int i = 0; i < n; ++i) {        f[i] = parameters[i].getEstimate() - t;      }      Arrays.fill(f, n, m, -t);      return f;    }  }  private static class LinearRank1Function extends MinpackFunction {    public LinearRank1Function(int m, int n, double x0,                                  double theoreticalStartCost,                                  double theoreticalMinCost) {      super(m, buildArray(n, x0), theoreticalStartCost, theoreticalMinCost, null);    }    @Override    protected double[][] getJacobian() {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = (i + 1) * (j + 1);        }      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double[] f = new double[m];      double sum = 0;      for (int i = 0; i < n; ++i) {        sum += (i + 1) * parameters[i].getEstimate();      }      for (int i = 0; i < m; ++i) {        f[i] = (i + 1) * sum - 1;      }      return f;    }  }  private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction {    public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {      super(m, buildArray(n, x0),            Math.sqrt(m + (n+1)*(n-2)*(m-2)*(m-1) * ((n+1)*(n-2)*(2*m-3) - 12) / 24.0),            Math.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),            null);    }    @Override    protected double[][] getJacobian() {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        jacobian[i][0] = 0;        for (int j = 1; j < (n - 1); ++j) {          if (i == 0) {            jacobian[i][j] = 0;          } else if (i != (m - 1)) {            jacobian[i][j] = i * (j + 1);          } else {            jacobian[i][j] = 0;          }        }        jacobian[i][n - 1] = 0;      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double[] f = new double[m];      double sum = 0;      for (int i = 1; i < (n - 1); ++i) {        sum += (i + 1) * parameters[i].getEstimate();      }      for (int i = 0; i < (m - 1); ++i) {        f[i] = i * sum - 1;      }      f[m - 1] = -1;      return f;    }  }  private static class RosenbrockFunction extends MinpackFunction {    public RosenbrockFunction(double[] startParams, double theoreticalStartCost) {      super(2, startParams, theoreticalStartCost, 0.0, buildArray(2, 1.0));    }    @Override    protected double[][] getJacobian() {      double x1 = parameters[0].getEstimate();      return new double[][] { { -20 * x1, 10 }, { -1, 0 } };    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      return new double[] { 10 * (x2 - x1 * x1), 1 - x1 };    }  }  private static class HelicalValleyFunction extends MinpackFunction {    public HelicalValleyFunction(double[] startParams,                                 double theoreticalStartCost) {      super(3, startParams, theoreticalStartCost, 0.0,            new double[] { 1.0, 0.0, 0.0 });    }    @Override    protected double[][] getJacobian() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double tmpSquare = x1 * x1 + x2 * x2;      double tmp1 = twoPi * tmpSquare;      double tmp2 = Math.sqrt(tmpSquare);      return new double[][] {        {  100 * x2 / tmp1, -100 * x1 / tmp1, 10 },        { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 },        { 0, 0, 1 }      };    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double tmp1;      if (x1 == 0) {        tmp1 = (x2 >= 0) ? 0.25 : -0.25;      } else {        tmp1 = Math.atan(x2 / x1) / twoPi;        if (x1 < 0) {          tmp1 += 0.5;        }      }      double tmp2 = Math.sqrt(x1 * x1 + x2 * x2);      return new double[] {        10.0 * (x3 - 10 * tmp1),        10.0 * (tmp2 - 1),        x3      };    }    private static final double twoPi = 2.0 * Math.PI;  }  private static class PowellSingularFunction extends MinpackFunction {    public PowellSingularFunction(double[] startParams,                                  double theoreticalStartCost) {      super(4, startParams, theoreticalStartCost, 0.0, buildArray(4, 0.0));    }    @Override    protected double[][] getJacobian() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double x4 = parameters[3].getEstimate();      return new double[][] {        { 1, 10, 0, 0 },        { 0, 0, sqrt5, -sqrt5 },        { 0, 2 * (x2 - 2 * x3), -4 * (x2 - 2 * x3), 0 },        { 2 * sqrt10 * (x1 - x4), 0, 0, -2 * sqrt10 * (x1 - x4) }      };    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double x4 = parameters[3].getEstimate();      return new double[] {        x1 + 10 * x2,        sqrt5 * (x3 - x4),        (x2 - 2 * x3) * (x2 - 2 * x3),        sqrt10 * (x1 - x4) * (x1 - x4)      };    }    private static final double sqrt5  = Math.sqrt( 5.0);    private static final double sqrt10 = Math.sqrt(10.0);  }  private static class FreudensteinRothFunction extends MinpackFunction {    public FreudensteinRothFunction(double[] startParams,                                    double theoreticalStartCost,                                    double theoreticalMinCost,                                    double[] theoreticalMinParams) {      super(2, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    @Override    protected double[][] getJacobian() {      double x2 = parameters[1].getEstimate();      return new double[][] {        { 1, x2 * (10 - 3 * x2) -  2 },        { 1, x2 * ( 2 + 3 * x2) - 14, }      };    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      return new double[] {       -13.0 + x1 + ((5.0 - x2) * x2 -  2.0) * x2,       -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2      };    }  }  private static class BardFunction extends MinpackFunction {    public BardFunction(double x0,                        double theoreticalStartCost,                        double theoreticalMinCost,                        double[] theoreticalMinParams) {      super(15, buildArray(3, x0), theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    @Override    protected double[][] getJacobian() {      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp1 = i  + 1;        double tmp2 = 15 - i;        double tmp3 = (i <= 7) ? tmp1 : tmp2;        double tmp4 = x2 * tmp2 + x3 * tmp3;        tmp4 *= tmp4;        jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 };      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double tmp1 = i + 1;        double tmp2 = 15 - i;        double tmp3 = (i <= 7) ? tmp1 : tmp2;        f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3));      }      return f;    }    private static final double[] y = {      0.14, 0.18, 0.22, 0.25, 0.29,      0.32, 0.35, 0.39, 0.37, 0.58,      0.73, 0.96, 1.34, 2.10, 4.39    };  }  private static class KowalikOsborneFunction extends MinpackFunction {    public KowalikOsborneFunction(double[] startParams,                                  double theoreticalStartCost,                                  double theoreticalMinCost,                                  double[] theoreticalMinParams) {      super(11, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);      if (theoreticalStartCost > 20.0) {        setCostAccuracy(2.0e-4);        setParamsAccuracy(5.0e-3);      }    }    @Override    protected double[][] getJacobian() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double   x4 = parameters[3].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp = v[i] * (v[i] + x3) + x4;        double j1  = -v[i] * (v[i] + x2) / tmp;        double j2  = -v[i] * x1 / tmp;        double j3  = j1 * j2;        double j4  = j3 / v[i];        jacobian[i] = new double[] { j1, j2, j3, j4 };      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double x4 = parameters[3].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4);      }      return f;    }    private static final double[] v = {      4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625    };    private static final double[] y = {      0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627,      0.0456, 0.0342, 0.0323, 0.0235, 0.0246    };  }  private static class MeyerFunction extends MinpackFunction {    public MeyerFunction(double[] startParams,                         double theoreticalStartCost,                         double theoreticalMinCost,                         double[] theoreticalMinParams) {      super(16, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);      if (theoreticalStartCost > 1.0e6) {        setCostAccuracy(7.0e-3);        setParamsAccuracy(2.0e-2);      }    }    @Override    protected double[][] getJacobian() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = 5.0 * (i + 1) + 45.0 + x3;        double tmp1 = x2 / temp;        double tmp2 = Math.exp(tmp1);        double tmp3 = x1 * tmp2 / temp;        jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 };      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        f[i] = x1 * Math.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];      }     return f;    }    private static final double[] y = {      34780.0, 28610.0, 23650.0, 19630.0,      16370.0, 13720.0, 11540.0,  9744.0,       8261.0,  7030.0,  6005.0,  5147.0,       4427.0,  3820.0,  3307.0,  2872.0                      };  }  private static class WatsonFunction extends MinpackFunction {    public WatsonFunction(int n, double x0,                          double theoreticalStartCost,                          double theoreticalMinCost,                          double[] theoreticalMinParams) {      super(31, buildArray(n, x0), theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    @Override    protected double[][] getJacobian() {      double[][] jacobian = new double[m][];      for (int i = 0; i < (m - 2); ++i) {        double div = (i + 1) / 29.0;        double s2  = 0.0;        double dx  = 1.0;        for (int j = 0; j < n; ++j) {          s2 += dx * parameters[j].getEstimate();          dx *= div;        }        double temp= 2 * div * s2;        dx = 1.0 / div;        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = dx * (j - temp);          dx *= div;        }      }      jacobian[m - 2]    = new double[n];      jacobian[m - 2][0] = 1;      jacobian[m - 1]   = new double[n];      jacobian[m - 1][0]= -2 * parameters[0].getEstimate();      jacobian[m - 1][1]= 1;      return jacobian;    }    @Override    protected double[] getResiduals() {     double[] f = new double[m];     for (int i = 0; i < (m - 2); ++i) {       double div = (i + 1) / 29.0;       double s1 = 0;       double dx = 1;       for (int j = 1; j < n; ++j) {         s1 += j * dx * parameters[j].getEstimate();         dx *= div;       }       double s2 =0;       dx =1;       for (int j = 0; j < n; ++j) {         s2 += dx * parameters[j].getEstimate();         dx *= div;       }       f[i] = s1 - s2 * s2 - 1;     }     double x1 = parameters[0].getEstimate();     double x2 = parameters[1].getEstimate();     f[m - 2] = x1;     f[m - 1] = x2 - x1 * x1 - 1;     return f;    }  }  private static class Box3DimensionalFunction extends MinpackFunction {    public Box3DimensionalFunction(int m, double[] startParams,                                   double theoreticalStartCost) {      super(m, startParams, theoreticalStartCost,            0.0, new double[] { 1.0, 10.0, 1.0 });   }    @Override    protected double[][] getJacobian() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp = (i + 1) / 10.0;        jacobian[i] = new double[] {          -tmp * Math.exp(-tmp * x1),           tmp * Math.exp(-tmp * x2),          Math.exp(-i - 1) - Math.exp(-tmp)        };      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double tmp = (i + 1) / 10.0;        f[i] = Math.exp(-tmp * x1) - Math.exp(-tmp * x2)             + (Math.exp(-i - 1) - Math.exp(-tmp)) * x3;      }      return f;    }  }  private static class JennrichSampsonFunction extends MinpackFunction {    public JennrichSampsonFunction(int m, double[] startParams,                                   double theoreticalStartCost,                                   double theoreticalMinCost,                                   double[] theoreticalMinParams) {      super(m, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    @Override    protected double[][] getJacobian() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double t = i + 1;        jacobian[i] = new double[] { -t * Math.exp(t * x1), -t * Math.exp(t * x2) };      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = i + 1;        f[i] = 2 + 2 * temp - Math.exp(temp * x1) - Math.exp(temp * x2);      }      return f;    }  }  private static class BrownDennisFunction extends MinpackFunction {    public BrownDennisFunction(int m, double[] startParams,                               double theoreticalStartCost,                               double theoreticalMinCost,                               double[] theoreticalMinParams) {      super(m, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    @Override    protected double[][] getJacobian() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double   x4 = parameters[3].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = (i + 1) / 5.0;        double ti   = Math.sin(temp);        double tmp1 = x1 + temp * x2 - Math.exp(temp);        double tmp2 = x3 + ti   * x4 - Math.cos(temp);        jacobian[i] = new double[] {          2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2        };      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double x4 = parameters[3].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = (i + 1) / 5.0;        double tmp1 = x1 + temp * x2 - Math.exp(temp);        double tmp2 = x3 + Math.sin(temp) * x4 - Math.cos(temp);        f[i] = tmp1 * tmp1 + tmp2 * tmp2;      }      return f;    }  }  private static class ChebyquadFunction extends MinpackFunction {    private static double[] buildChebyquadArray(int n, double factor) {      double[] array = new double[n];      double inv = factor / (n + 1);      for (int i = 0; i < n; ++i) {        array[i] = (i + 1) * inv;      }      return array;    }    public ChebyquadFunction(int n, int m, double factor,                             double theoreticalStartCost,                             double theoreticalMinCost,                             double[] theoreticalMinParams) {      super(m, buildChebyquadArray(n, factor), theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    @Override    protected double[][] getJacobian() {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];      }      double dx = 1.0 / n;      for (int j = 0; j < n; ++j) {        double tmp1 = 1;        double tmp2 = 2 * parameters[j].getEstimate() - 1;        double temp = 2 * tmp2;        double tmp3 = 0;        double tmp4 = 2;        for (int i = 0; i < m; ++i) {          jacobian[i][j] = dx * tmp4;          double ti = 4 * tmp2 + temp * tmp4 - tmp3;          tmp3 = tmp4;          tmp4 = ti;          ti   = temp * tmp2 - tmp1;          tmp1 = tmp2;          tmp2 = ti;        }      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double[] f = new double[m];      for (int j = 0; j < n; ++j) {        double tmp1 = 1;        double tmp2 = 2 * parameters[j].getEstimate() - 1;        double temp = 2 * tmp2;        for (int i = 0; i < m; ++i) {          f[i] += tmp2;          double ti = temp * tmp2 - tmp1;          tmp1 = tmp2;          tmp2 = ti;        }      }      double dx = 1.0 / n;      boolean iev = false;      for (int i = 0; i < m; ++i) {        f[i] *= dx;        if (iev) {          f[i] += 1.0 / (i * (i + 2));        }        iev = ! iev;      }      return f;    }  }  private static class BrownAlmostLinearFunction extends MinpackFunction {    public BrownAlmostLinearFunction(int m, double factor,                                     double theoreticalStartCost,                                     double theoreticalMinCost,                                     double[] theoreticalMinParams) {      super(m, buildArray(m, factor), theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    @Override    protected double[][] getJacobian() {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];      }      double prod = 1;      for (int j = 0; j < n; ++j) {        prod *= parameters[j].getEstimate();        for (int i = 0; i < n; ++i) {          jacobian[i][j] = 1;        }        jacobian[j][j] = 2;      }      for (int j = 0; j < n; ++j) {        EstimatedParameter vj = parameters[j];        double temp = vj.getEstimate();        if (temp == 0) {          temp = 1;          prod = 1;          for (int k = 0; k < n; ++k) {            if (k != j) {              prod *= parameters[k].getEstimate();            }          }        }        jacobian[n - 1][j] = prod / temp;      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double[] f = new double[m];      double sum  = -(n + 1);      double prod = 1;      for (int j = 0; j < n; ++j) {        sum  += parameters[j].getEstimate();        prod *= parameters[j].getEstimate();      }      for (int i = 0; i < n; ++i) {        f[i] = parameters[i].getEstimate() + sum;      }      f[n - 1] = prod - 1;      return f;    }  }  private static class Osborne1Function extends MinpackFunction {    public Osborne1Function(double[] startParams,                            double theoreticalStartCost,                            double theoreticalMinCost,                            double[] theoreticalMinParams) {      super(33, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    @Override    protected double[][] getJacobian() {      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double   x4 = parameters[3].getEstimate();      double   x5 = parameters[4].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = 10.0 * i;        double tmp1 = Math.exp(-temp * x4);        double tmp2 = Math.exp(-temp * x5);        jacobian[i] = new double[] {          -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2        };      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double x4 = parameters[3].getEstimate();      double x5 = parameters[4].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = 10.0 * i;        double tmp1 = Math.exp(-temp * x4);        double tmp2 = Math.exp(-temp * x5);        f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2);      }      return f;    }    private static final double[] y = {      0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751,      0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490,      0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406    };  }  private static class Osborne2Function extends MinpackFunction {    public Osborne2Function(double[] startParams,                            double theoreticalStartCost,                            double theoreticalMinCost,                            double[] theoreticalMinParams) {      super(65, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    @Override    protected double[][] getJacobian() {      double   x01 = parameters[0].getEstimate();      double   x02 = parameters[1].getEstimate();      double   x03 = parameters[2].getEstimate();      double   x04 = parameters[3].getEstimate();      double   x05 = parameters[4].getEstimate();      double   x06 = parameters[5].getEstimate();      double   x07 = parameters[6].getEstimate();      double   x08 = parameters[7].getEstimate();      double   x09 = parameters[8].getEstimate();      double   x10 = parameters[9].getEstimate();      double   x11 = parameters[10].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = i / 10.0;        double tmp1 = Math.exp(-x05 * temp);        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));        jacobian[i] = new double[] {          -tmp1,          -tmp2,          -tmp3,          -tmp4,          temp * x01 * tmp1,          x02 * (temp - x09) * (temp - x09) * tmp2,          x03 * (temp - x10) * (temp - x10) * tmp3,          x04 * (temp - x11) * (temp - x11) * tmp4,          -2 * x02 * x06 * (temp - x09) * tmp2,          -2 * x03 * x07 * (temp - x10) * tmp3,          -2 * x04 * x08 * (temp - x11) * tmp4        };      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double x01 = parameters[0].getEstimate();      double x02 = parameters[1].getEstimate();      double x03 = parameters[2].getEstimate();      double x04 = parameters[3].getEstimate();      double x05 = parameters[4].getEstimate();      double x06 = parameters[5].getEstimate();      double x07 = parameters[6].getEstimate();      double x08 = parameters[7].getEstimate();      double x09 = parameters[8].getEstimate();      double x10 = parameters[9].getEstimate();      double x11 = parameters[10].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = i / 10.0;        double tmp1 = Math.exp(-x05 * temp);        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));        f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4);      }      return f;    }    private static final double[] y = {      1.366, 1.191, 1.112, 1.013, 0.991,      0.885, 0.831, 0.847, 0.786, 0.725,      0.746, 0.679, 0.608, 0.655, 0.616,      0.606, 0.602, 0.626, 0.651, 0.724,      0.649, 0.649, 0.694, 0.644, 0.624,      0.661, 0.612, 0.558, 0.533, 0.495,      0.500, 0.423, 0.395, 0.375, 0.372,      0.391, 0.396, 0.405, 0.428, 0.429,      0.523, 0.562, 0.607, 0.653, 0.672,      0.708, 0.633, 0.668, 0.645, 0.632,      0.591, 0.559, 0.597, 0.625, 0.739,      0.710, 0.729, 0.720, 0.636, 0.581,      0.428, 0.292, 0.162, 0.098, 0.054    };  }  public static Test suite() {    return new TestSuite(MinpackTest.class);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class InvalidMatrixExceptionTest extends TestCase {        public void testConstructorMessage(){        String msg = "message";        InvalidMatrixException ex = new InvalidMatrixException(msg);        assertEquals(msg, ex.getMessage());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Random;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.linear.DecompositionSolver;import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.linear.InvalidMatrixException;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.MatrixVisitorException;import org.apache.commons.math.linear.QRDecomposition;import org.apache.commons.math.linear.QRDecompositionImpl;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.RealVector;import org.apache.commons.math.linear.ArrayRealVector;public class QRSolverTest extends TestCase {    double[][] testData3x3NonSingular = {             { 12, -51,   4 },             {  6, 167, -68 },            { -4,  24, -41 }    };    double[][] testData3x3Singular = {             { 1, 2,  2 },             { 2, 4,  6 },            { 4, 8, 12 }    };    double[][] testData3x4 = {             { 12, -51,   4, 1 },             {  6, 167, -68, 2 },            { -4,  24, -41, 3 }    };    double[][] testData4x3 = {             { 12, -51,   4 },             {  6, 167, -68 },            { -4,  24, -41 },             { -5,  34,   7 }    };    public QRSolverTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(QRSolverTest.class);        suite.setName("QRSolver Tests");        return suite;    }    /** test rank */    public void testRank() {        DecompositionSolver solver =            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();        assertTrue(solver.isNonSingular());        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();        assertFalse(solver.isNonSingular());        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x4)).getSolver();        assertTrue(solver.isNonSingular());        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData4x3)).getSolver();        assertTrue(solver.isNonSingular());    }    /** test solve dimension errors */    public void testSolveDimensionErrors() {        DecompositionSolver solver =            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);        try {            solver.solve(b);            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumn(0));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumnVector(0));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test solve rank errors */    public void testSolveRankErrors() {        DecompositionSolver solver =            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);        try {            solver.solve(b);            fail("an exception should have been thrown");        } catch (InvalidMatrixException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumn(0));            fail("an exception should have been thrown");        } catch (InvalidMatrixException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumnVector(0));            fail("an exception should have been thrown");        } catch (InvalidMatrixException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test solve */    public void testSolve() {        QRDecomposition decomposition =            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular));        DecompositionSolver solver = decomposition.getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                { -102, 12250 }, { 544, 24500 }, { 167, -36750 }        });        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                { 1, 2515 }, { 2, 422 }, { -3, 898 }        });        // using RealMatrix        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 2.0e-16 * xRef.getNorm());        // using double[]        for (int i = 0; i < b.getColumnDimension(); ++i) {            final double[] x = solver.solve(b.getColumn(i));            final double error = new ArrayRealVector(x).subtract(xRef.getColumnVector(i)).getNorm();            assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());        }        // using ArrayRealVector        for (int i = 0; i < b.getColumnDimension(); ++i) {            final RealVector x = solver.solve(b.getColumnVector(i));            final double error = x.subtract(xRef.getColumnVector(i)).getNorm();            assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());        }        // using RealVector with an alternate implementation        for (int i = 0; i < b.getColumnDimension(); ++i) {            ArrayRealVectorTest.RealVectorTestImpl v =                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));            final RealVector x = solver.solve(v);            final double error = x.subtract(xRef.getColumnVector(i)).getNorm();            assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());        }    }    public void testOverdetermined() {        final Random r    = new Random(5559252868205245l);        int          p    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        int          q    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        RealMatrix   a    = createTestMatrix(r, p, q);        RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);        // build a perturbed system: A.X + noise = B        RealMatrix b = a.multiply(xRef);        final double noise = 0.001;        b.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {            @Override            public double visit(int row, int column, double value) {                return value * (1.0 + noise * (2 * r.nextDouble() - 1));            }        });        // despite perturbation, the least square solution should be pretty good        RealMatrix x = new QRDecompositionImpl(a).getSolver().solve(b);        assertEquals(0, x.subtract(xRef).getNorm(), 0.01 * noise * p * q);    }    public void testUnderdetermined() {        final Random r    = new Random(42185006424567123l);        int          p    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int          q    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        RealMatrix   a    = createTestMatrix(r, p, q);        RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);        RealMatrix   b    = a.multiply(xRef);        RealMatrix   x = new QRDecompositionImpl(a).getSolver().solve(b);        // too many equations, the system cannot be solved at all        assertTrue(x.subtract(xRef).getNorm() / (p * q) > 0.01);        // the last unknown should have been set to 0        assertEquals(0.0, x.getSubMatrix(p, q - 1, 0, x.getColumnDimension() - 1).getNorm());    }    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {        RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);        m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){            @Override            public double visit(int row, int column, double value)                throws MatrixVisitorException {                return 2.0 * r.nextDouble() - 1.0;            }        });        return m;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.apache.commons.math.linear.BiDiagonalTransformer;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.RealMatrix;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;public class BiDiagonalTransformerTest extends TestCase {    private double[][] testSquare = {            { 24.0 / 25.0, 43.0 / 25.0 },            { 57.0 / 25.0, 24.0 / 25.0 }    };    private double[][] testNonSquare = {        {  -540.0 / 625.0,  963.0 / 625.0, -216.0 / 625.0 },        { -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 },        {  -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 },        {  -360.0 / 625.0,  192.0 / 625.0, 1756.0 / 625.0 },    };    public BiDiagonalTransformerTest(String name) {        super(name);    }    public void testDimensions() {        checkdimensions(MatrixUtils.createRealMatrix(testSquare));        checkdimensions(MatrixUtils.createRealMatrix(testNonSquare));        checkdimensions(MatrixUtils.createRealMatrix(testNonSquare).transpose());    }    private void checkdimensions(RealMatrix matrix) {        final int m = matrix.getRowDimension();        final int n = matrix.getColumnDimension();        BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix);        assertEquals(m, transformer.getU().getRowDimension());        assertEquals(m, transformer.getU().getColumnDimension());        assertEquals(m, transformer.getB().getRowDimension());        assertEquals(n, transformer.getB().getColumnDimension());        assertEquals(n, transformer.getV().getRowDimension());        assertEquals(n, transformer.getV().getColumnDimension());    }    public void testAEqualUSVt() {        checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare));        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare));        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare).transpose());    }    private void checkAEqualUSVt(RealMatrix matrix) {        BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix);        RealMatrix u = transformer.getU();        RealMatrix b = transformer.getB();        RealMatrix v = transformer.getV();        double norm = u.multiply(b).multiply(v.transpose()).subtract(matrix).getNorm();        assertEquals(0, norm, 1.0e-14);    }    public void testUOrthogonal() {        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getU());        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getU());        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getU());    }    public void testVOrthogonal() {        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getV());        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getV());        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getV());    }    private void checkOrthogonal(RealMatrix m) {        RealMatrix mTm = m.transpose().multiply(m);        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());        assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14);            }    public void testBBiDiagonal() {        checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getB());        checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getB());        checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getB());    }    private void checkBiDiagonal(RealMatrix m) {        final int rows = m.getRowDimension();        final int cols = m.getColumnDimension();        for (int i = 0; i < rows; ++i) {            for (int j = 0; j < cols; ++j) {                if (rows < cols) {                    if ((i < j) || (i > j + 1)) {                        assertEquals(0, m.getEntry(i, j), 1.0e-16);                    }                                    } else {                    if ((i < j - 1) || (i > j)) {                        assertEquals(0, m.getEntry(i, j), 1.0e-16);                    }                }            }        }    }    public void testMatricesValues() {       BiDiagonalTransformer transformer =            new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare));       final double s17 = Math.sqrt(17.0);        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {                {  -8 / (5 * s17), 19 / (5 * s17) },                { -19 / (5 * s17), -8 / (5 * s17) }        });        RealMatrix bRef = MatrixUtils.createRealMatrix(new double[][] {                { -3 * s17 / 5, 32 * s17 / 85 },                {      0.0,     -5 * s17 / 17 }        });        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {                { 1.0,  0.0 },                { 0.0, -1.0 }        });        // check values against known references        RealMatrix u = transformer.getU();        assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-14);        RealMatrix b = transformer.getB();        assertEquals(0, b.subtract(bRef).getNorm(), 1.0e-14);        RealMatrix v = transformer.getV();        assertEquals(0, v.subtract(vRef).getNorm(), 1.0e-14);        // check the same cached instance is returned the second time        assertTrue(u == transformer.getU());        assertTrue(b == transformer.getB());        assertTrue(v == transformer.getV());            }    public void testUpperOrLower() {        assertTrue(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).isUpperBiDiagonal());        assertTrue(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).isUpperBiDiagonal());        assertFalse(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).isUpperBiDiagonal());    }    public static Test suite() {        return new TestSuite(BiDiagonalTransformerTest.class);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.text.NumberFormat;import java.text.ParseException;import java.text.ParsePosition;import java.util.Locale;import junit.framework.TestCase;import org.apache.commons.math.util.CompositeFormat;public abstract class RealVectorFormatAbstractTest extends TestCase {     RealVectorFormat realVectorFormat = null;    RealVectorFormat realVectorFormatSquare = null;    protected abstract Locale getLocale();    protected abstract char getDecimalCharacter();    @Override    public void setUp() throws Exception {        realVectorFormat = RealVectorFormat.getInstance(getLocale());        final NumberFormat nf = NumberFormat.getInstance(getLocale());        nf.setMaximumFractionDigits(2);        realVectorFormatSquare = new RealVectorFormat("[", "]", " : ", nf);    }       public void testSimpleNoDecimals() {        ArrayRealVector c = new ArrayRealVector(new double[] {1, 1, 1});        String expected = "{1; 1; 1}";        String actual = realVectorFormat.format(c);         assertEquals(expected, actual);    }    public void testSimpleWithDecimals() {        ArrayRealVector c = new ArrayRealVector(new double[] {1.23, 1.43, 1.63});        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = realVectorFormat.format(c);         assertEquals(expected, actual);    }    public void testSimpleWithDecimalsTrunc() {        ArrayRealVector c = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = realVectorFormat.format(c);         assertEquals(expected, actual);    }    public void testNegativeX() {        ArrayRealVector c = new ArrayRealVector(new double[] {-1.2323, 1.4343, 1.6333});        String expected =            "{-1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = realVectorFormat.format(c);         assertEquals(expected, actual);    }    public void testNegativeY() {        ArrayRealVector c = new ArrayRealVector(new double[] {1.2323, -1.4343, 1.6333});        String expected =            "{1"    + getDecimalCharacter() +            "23; -1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = realVectorFormat.format(c);         assertEquals(expected, actual);    }    public void testNegativeZ() {        ArrayRealVector c = new ArrayRealVector(new double[] {1.2323, 1.4343, -1.6333});        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; -1" + getDecimalCharacter() +            "63}";        String actual = realVectorFormat.format(c);         assertEquals(expected, actual);    }    public void testNonDefaultSetting() {        ArrayRealVector c = new ArrayRealVector(new double[] {1, 1, 1});        String expected = "[1 : 1 : 1]";        String actual = realVectorFormatSquare.format(c);         assertEquals(expected, actual);    }        public void testStaticFormatRealVectorImpl() {        Locale defaultLocal = Locale.getDefault();        Locale.setDefault(getLocale());                ArrayRealVector c = new ArrayRealVector(new double[] {232.222, -342.33, 432.444});        String expected =            "{232"    + getDecimalCharacter() +            "22; -342" + getDecimalCharacter() +            "33; 432" + getDecimalCharacter() +            "44}";        String actual = RealVectorFormat.formatRealVector(c);         assertEquals(expected, actual);                Locale.setDefault(defaultLocal);    }    public void testNan() {        ArrayRealVector c = new ArrayRealVector(new double[] {Double.NaN, Double.NaN, Double.NaN});        String expected = "{(NaN); (NaN); (NaN)}";        String actual = realVectorFormat.format(c);         assertEquals(expected, actual);    }    public void testPositiveInfinity() {        ArrayRealVector c = new ArrayRealVector(new double[] {                Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY        });        String expected = "{(Infinity); (Infinity); (Infinity)}";        String actual = realVectorFormat.format(c);         assertEquals(expected, actual);    }    public void tesNegativeInfinity() {        ArrayRealVector c = new ArrayRealVector(new double[] {                Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY        });        String expected = "{(-Infinity); (-Infinity); (-Infinity)}";        String actual = realVectorFormat.format(c);         assertEquals(expected, actual);    }    public void testParseSimpleNoDecimals() {        String source = "{1; 1; 1}";        ArrayRealVector expected = new ArrayRealVector(new double[] {1, 1, 1});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseIgnoredWhitespace() {        ArrayRealVector expected = new ArrayRealVector(new double[] {1, 1, 1});        ParsePosition pos1 = new ParsePosition(0);        String source1 = "{1;1;1}";        assertEquals(expected, realVectorFormat.parseObject(source1, pos1));        assertEquals(source1.length(), pos1.getIndex());        ParsePosition pos2 = new ParsePosition(0);        String source2 = " { 1 ; 1 ; 1 } ";        assertEquals(expected, realVectorFormat.parseObject(source2, pos2));        assertEquals(source2.length() - 1, pos2.getIndex());    }    public void testParseSimpleWithDecimals() {        String source =            "{1" + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        ArrayRealVector expected = new ArrayRealVector(new double[] {1.23, 1.43, 1.63});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseSimpleWithDecimalsTrunc() {        String source =            "{1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeX() {        String source =            "{-1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {-1.2323, 1.4343, 1.6333});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeY() {        String source =            "{1" + getDecimalCharacter() +            "2323; -1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, -1.4343, 1.6333});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeZ() {        String source =            "{1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; -1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, -1.6333});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeAll() {        String source =            "{-1" + getDecimalCharacter() +            "2323; -1" + getDecimalCharacter() +            "4343; -1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {-1.2323, -1.4343, -1.6333});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseZeroX() {        String source =            "{0" + getDecimalCharacter() +            "0; -1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {0.0, -1.4343, 1.6333});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNonDefaultSetting() {        String source =            "[1" + getDecimalCharacter() +            "2323 : 1" + getDecimalCharacter() +            "4343 : 1" + getDecimalCharacter() +            "6333]";        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormatSquare.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }        public void testParseNan() {        String source = "{(NaN); (NaN); (NaN)}";        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);             assertEquals(new ArrayRealVector(new double[] {Double.NaN, Double.NaN, Double.NaN}), actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParsePositiveInfinity() {        String source = "{(Infinity); (Infinity); (Infinity)}";        try {            ArrayRealVector actual = (ArrayRealVector)realVectorFormat.parseObject(source);             assertEquals(new ArrayRealVector(new double[] {                    Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY            }), actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeInfinity() {        String source = "{(-Infinity); (-Infinity); (-Infinity)}";        try {            ArrayRealVector actual = (ArrayRealVector)realVectorFormat.parseObject(source);             assertEquals(new ArrayRealVector(new double[] {                    Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY            }), actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNoComponents() {        try {            realVectorFormat.parseObject("{ }");        } catch (ParseException pe) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testParseManyComponents() throws ParseException {        ArrayRealVector parsed =            (ArrayRealVector) realVectorFormat.parseObject("{0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0}");        assertEquals(24, parsed.getDimension());    }    public void testConstructorSingleFormat() {        NumberFormat nf = NumberFormat.getInstance();        RealVectorFormat cf = new RealVectorFormat(nf);        assertNotNull(cf);        assertEquals(nf, cf.getFormat());    }        public void testFormatObject() {        try {            CompositeFormat cf = new RealVectorFormat();            Object object = new Object();            cf.format(object);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }    public void testForgottenPrefix() {        ParsePosition pos = new ParsePosition(0);        assertNull(new RealVectorFormat().parse("1; 1; 1}", pos));        assertEquals(0, pos.getErrorIndex());    }    public void testForgottenSeparator() {        ParsePosition pos = new ParsePosition(0);        assertNull(new RealVectorFormat().parse("{1; 1 1}", pos));        assertEquals(6, pos.getErrorIndex());    }    public void testForgottenSuffix() {        ParsePosition pos = new ParsePosition(0);        assertNull(new RealVectorFormat().parse("{1; 1; 1 ", pos));        assertEquals(8, pos.getErrorIndex());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Locale;public class RealVectorFormatTest extends RealVectorFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return '.';    }    @Override    protected Locale getLocale() {        return Locale.US;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class MatrixIndexExceptionTest extends TestCase {        /**     *      */    public void testConstructorMessage(){        String msg = "message";        MatrixIndexException ex = new MatrixIndexException(msg);        assertEquals(msg, ex.getMessage());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.MathException;import org.apache.commons.math.linear.CholeskyDecompositionImpl;import org.apache.commons.math.linear.DecompositionSolver;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.ArrayRealVector;public class CholeskySolverTest extends TestCase {    private double[][] testData = new double[][] {            {  1,  2,   4,   7,  11 },            {  2, 13,  23,  38,  58 },            {  4, 23,  77, 122, 182 },            {  7, 38, 122, 294, 430 },            { 11, 58, 182, 430, 855 }    };    public CholeskySolverTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(CholeskySolverTest.class);        suite.setName("LUSolver Tests");        return suite;    }    /** test solve dimension errors */    public void testSolveDimensionErrors() throws MathException {        DecompositionSolver solver =            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);        try {            solver.solve(b);            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumn(0));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test solve */    public void testSolve() throws MathException {        DecompositionSolver solver =            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                {   78,  -13,    1 },                {  414,  -62,   -1 },                { 1312, -202,  -37 },                { 2989, -542,  145 },                { 5510, -1465, 201 }        });        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                { 1,  0,  1 },                { 0,  1,  1 },                { 2,  1, -4 },                { 2,  2,  2 },                { 5, -3,  0 }        });        // using RealMatrix        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);        // using double[]        for (int i = 0; i < b.getColumnDimension(); ++i) {            assertEquals(0,                         new ArrayRealVector(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }        // using ArrayRealVector        for (int i = 0; i < b.getColumnDimension(); ++i) {            assertEquals(0,                         solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }        // using RealVector with an alternate implementation        for (int i = 0; i < b.getColumnDimension(); ++i) {            ArrayRealVectorTest.RealVectorTestImpl v =                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));            assertEquals(0,                         solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }    }    /** test determinant */    public void testDeterminant() throws MathException {        assertEquals(7290000.0, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15);    }    private double getDeterminant(RealMatrix m) throws MathException {        return new CholeskyDecompositionImpl(m).getDeterminant();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Arrays;import java.util.Random;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionField;/** * Test cases for the {@link BlockFieldMatrix} class. * * @version $Revision$ $Date$ */public final class BlockFieldMatrixTest extends TestCase {        // 3 x 3 identity matrix    protected Fraction[][] id = {            {new Fraction(1),new Fraction(0),new Fraction(0)},            {new Fraction(0),new Fraction(1),new Fraction(0)},            {new Fraction(0),new Fraction(0),new Fraction(1)}    };        // Test data for group operations    protected Fraction[][] testData = {            {new Fraction(1),new Fraction(2),new Fraction(3)},            {new Fraction(2),new Fraction(5),new Fraction(3)},            {new Fraction(1),new Fraction(0),new Fraction(8)}    };    protected Fraction[][] testDataLU = {            {new Fraction(2), new Fraction(5), new Fraction(3)},            {new Fraction(1, 2), new Fraction(-5, 2), new Fraction(13, 2)},            {new Fraction(1, 2), new Fraction(1, 5), new Fraction(1, 5)}    };    protected Fraction[][] testDataPlus2 = {            {new Fraction(3),new Fraction(4),new Fraction(5)},            {new Fraction(4),new Fraction(7),new Fraction(5)},            {new Fraction(3),new Fraction(2),new Fraction(10)}    };    protected Fraction[][] testDataMinus = {            {new Fraction(-1),new Fraction(-2),new Fraction(-3)},            {new Fraction(-2),new Fraction(-5),new Fraction(-3)},             {new Fraction(-1),new Fraction(0),new Fraction(-8)}    };    protected Fraction[] testDataRow1 = {new Fraction(1),new Fraction(2),new Fraction(3)};    protected Fraction[] testDataCol3 = {new Fraction(3),new Fraction(3),new Fraction(8)};    protected Fraction[][] testDataInv = {            {new Fraction(-40),new Fraction(16),new Fraction(9)},            {new Fraction(13),new Fraction(-5),new Fraction(-3)},            {new Fraction(5),new Fraction(-2),new Fraction(-1)}    };    protected Fraction[] preMultTest = {new Fraction(8), new Fraction(12), new Fraction(33)};    protected Fraction[][] testData2 = {            {new Fraction(1),new Fraction(2),new Fraction(3)},            {new Fraction(2),new Fraction(5),new Fraction(3)}    };    protected Fraction[][] testData2T = {            {new Fraction(1),new Fraction(2)},            {new Fraction(2),new Fraction(5)},            {new Fraction(3),new Fraction(3)}    };    protected Fraction[][] testDataPlusInv = {            {new Fraction(-39),new Fraction(18),new Fraction(12)},            {new Fraction(15),new Fraction(0),new Fraction(0)},            {new Fraction(6),new Fraction(-2),new Fraction(7)}    };        // lu decomposition tests    protected Fraction[][] luData = {            {new Fraction(2),new Fraction(3),new Fraction(3)},            {new Fraction(0),new Fraction(5),new Fraction(7)},            {new Fraction(6),new Fraction(9),new Fraction(8)}    };    protected Fraction[][] luDataLUDecomposition = {            {new Fraction(6),new Fraction(9),new Fraction(8)},            {new Fraction(0),new Fraction(5),new Fraction(7)},            {new Fraction(1, 3),new Fraction(0),new Fraction(1, 3)}    };        // singular matrices    protected Fraction[][] singular = { {new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(3)} };    protected Fraction[][] bigSingular = {            {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},            {new Fraction(2),new Fraction(5),new Fraction(3),new Fraction(4)},            {new Fraction(7),new Fraction(3),new Fraction(256),new Fraction(1930)},            {new Fraction(3),new Fraction(7),new Fraction(6),new Fraction(8)}    }; // 4th row = 1st + 2nd    protected Fraction[][] detData = {            {new Fraction(1),new Fraction(2),new Fraction(3)},            {new Fraction(4),new Fraction(5),new Fraction(6)},            {new Fraction(7),new Fraction(8),new Fraction(10)}    };    protected Fraction[][] detData2 = { {new Fraction(1), new Fraction(3)}, {new Fraction(2), new Fraction(4)}};        // vectors    protected Fraction[] testVector = {new Fraction(1),new Fraction(2),new Fraction(3)};    protected Fraction[] testVector2 = {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)};        // submatrix accessor tests    protected Fraction[][] subTestData = {            {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)},            {new Fraction(3, 2), new Fraction(5, 2), new Fraction(7, 2), new Fraction(9, 2)},            {new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8)},            {new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7)}    };     // array selections    protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4)}, {new Fraction(4), new Fraction(8)}};    protected Fraction[][] subRows03Cols12 = { {new Fraction(2), new Fraction(3)}, {new Fraction(5), new Fraction(6)}};    protected Fraction[][] subRows03Cols123 = {            {new Fraction(2), new Fraction(3), new Fraction(4)},            {new Fraction(5), new Fraction(6), new Fraction(7)}    };    // effective permutations    protected Fraction[][] subRows20Cols123 = {            {new Fraction(4), new Fraction(6), new Fraction(8)},            {new Fraction(2), new Fraction(3), new Fraction(4)}    };    protected Fraction[][] subRows31Cols31 = {{new Fraction(7), new Fraction(5)}, {new Fraction(9, 2), new Fraction(5, 2)}};    // contiguous ranges    protected Fraction[][] subRows01Cols23 = {{new Fraction(3),new Fraction(4)} , {new Fraction(7, 2), new Fraction(9, 2)}};    protected Fraction[][] subRows23Cols00 = {{new Fraction(2)} , {new Fraction(4)}};    protected Fraction[][] subRows00Cols33 = {{new Fraction(4)}};    // row matrices    protected Fraction[][] subRow0 = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}};    protected Fraction[][] subRow3 = {{new Fraction(4),new Fraction(5),new Fraction(6),new Fraction(7)}};    // column matrices    protected Fraction[][] subColumn1 = {{new Fraction(2)}, {new Fraction(5, 2)}, {new Fraction(4)}, {new Fraction(5)}};    protected Fraction[][] subColumn3 = {{new Fraction(4)}, {new Fraction(9, 2)}, {new Fraction(8)}, {new Fraction(7)}};        // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;        public BlockFieldMatrixTest(String name) {        super(name);    }        public static Test suite() {        TestSuite suite = new TestSuite(BlockFieldMatrixTest.class);        suite.setName("BlockFieldMatrix<Fraction> Tests");        return suite;    }        /** test dimensions */    public void testDimensions() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());    }         /** test copy functions */    public void testCopyFunctions() {        Random r = new Random(66636328996002l);        BlockFieldMatrix<Fraction> m1 = createRandomMatrix(r, 47, 83);        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(m1.getData());        assertEquals(m1, m2);        BlockFieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(m3.getData());        assertEquals(m3, m4);    }                   /** test add */    public void testAdd() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);        FieldMatrix<Fraction> mPlusMInv = m.add(mInv);        Fraction[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);            }        }        }        /** test add failure */    public void testAddFail() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);        try {            m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }    }         /** test m-n = m + -n */    public void testPlusMinus() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testDataInv);        TestUtils.assertEquals(m.subtract(m2), m2.scalarMultiply(new Fraction(-1)).add(m));                try {            m.subtract(new BlockFieldMatrix<Fraction>(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }       /** test multiply */     public void testMultiply() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);        BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id);        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);        TestUtils.assertEquals(m.multiply(mInv), identity);        TestUtils.assertEquals(mInv.multiply(m), identity);        TestUtils.assertEquals(m.multiply(identity), m);        TestUtils.assertEquals(identity.multiply(mInv), mInv);        TestUtils.assertEquals(m2.multiply(identity), m2);         try {            m.multiply(new BlockFieldMatrix<Fraction>(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }          }    public void testSeveralBlocks() {        FieldMatrix<Fraction> m =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), 37, 41);        for (int i = 0; i < m.getRowDimension(); ++i) {            for (int j = 0; j < m.getColumnDimension(); ++j) {                m.setEntry(i, j, new Fraction(i * 11 + j, 11));            }        }        FieldMatrix<Fraction> mT = m.transpose();        assertEquals(m.getRowDimension(), mT.getColumnDimension());        assertEquals(m.getColumnDimension(), mT.getRowDimension());        for (int i = 0; i < mT.getRowDimension(); ++i) {            for (int j = 0; j < mT.getColumnDimension(); ++j) {                assertEquals(m.getEntry(j, i), mT.getEntry(i, j));            }        }        FieldMatrix<Fraction> mPm = m.add(m);        for (int i = 0; i < mPm.getRowDimension(); ++i) {            for (int j = 0; j < mPm.getColumnDimension(); ++j) {                assertEquals(m.getEntry(i, j).multiply(new Fraction(2)), mPm.getEntry(i, j));            }        }        FieldMatrix<Fraction> mPmMm = mPm.subtract(m);        for (int i = 0; i < mPmMm.getRowDimension(); ++i) {            for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {                assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j));            }        }        FieldMatrix<Fraction> mTm = mT.multiply(m);        for (int i = 0; i < mTm.getRowDimension(); ++i) {            for (int j = 0; j < mTm.getColumnDimension(); ++j) {                Fraction sum = Fraction.ZERO;                for (int k = 0; k < mT.getColumnDimension(); ++k) {                    sum = sum.add(new Fraction(k * 11 + i, 11).multiply(new Fraction(k * 11 + j, 11)));                }                assertEquals(sum, mTm.getEntry(i, j));            }        }        FieldMatrix<Fraction> mmT = m.multiply(mT);        for (int i = 0; i < mmT.getRowDimension(); ++i) {            for (int j = 0; j < mmT.getColumnDimension(); ++j) {                Fraction sum = Fraction.ZERO;                for (int k = 0; k < m.getColumnDimension(); ++k) {                    sum = sum.add(new Fraction(i * 11 + k, 11).multiply(new Fraction(j * 11 + k, 11)));                }                assertEquals(sum, mmT.getEntry(i, j));            }        }        FieldMatrix<Fraction> sub1 = m.getSubMatrix(2, 9, 5, 20);        for (int i = 0; i < sub1.getRowDimension(); ++i) {            for (int j = 0; j < sub1.getColumnDimension(); ++j) {                assertEquals(new Fraction((i + 2) * 11 + (j + 5), 11), sub1.getEntry(i, j));            }        }        FieldMatrix<Fraction> sub2 = m.getSubMatrix(10, 12, 3, 40);        for (int i = 0; i < sub2.getRowDimension(); ++i) {            for (int j = 0; j < sub2.getColumnDimension(); ++j) {                assertEquals(new Fraction((i + 10) * 11 + (j + 3), 11), sub2.getEntry(i, j));            }        }        FieldMatrix<Fraction> sub3 = m.getSubMatrix(30, 34, 0, 5);        for (int i = 0; i < sub3.getRowDimension(); ++i) {            for (int j = 0; j < sub3.getColumnDimension(); ++j) {                assertEquals(new Fraction((i + 30) * 11 + (j + 0), 11), sub3.getEntry(i, j));            }        }        FieldMatrix<Fraction> sub4 = m.getSubMatrix(30, 32, 32, 35);        for (int i = 0; i < sub4.getRowDimension(); ++i) {            for (int j = 0; j < sub4.getColumnDimension(); ++j) {                assertEquals(new Fraction((i + 30) * 11 + (j + 32), 11), sub4.getEntry(i, j));            }        }    }    //Additional Test for BlockFieldMatrix<Fraction>Test.testMultiply    private Fraction[][] d3 = new Fraction[][] {            {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},            {new Fraction(5),new Fraction(6),new Fraction(7),new Fraction(8)}    };    private Fraction[][] d4 = new Fraction[][] {            {new Fraction(1)},            {new Fraction(2)},            {new Fraction(3)},            {new Fraction(4)}    };    private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}};         public void testMultiply2() {        FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);          FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4);       FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5);       TestUtils.assertEquals(m3.multiply(m4), m5);   }              /** test trace */    public void testTrace() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id);        assertEquals(new Fraction(3),m.getTrace());        m = new BlockFieldMatrix<Fraction>(testData2);        try {            m.getTrace();            fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }          }        /** test scalarAdd */    public void testScalarAdd() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(new BlockFieldMatrix<Fraction>(testDataPlus2),                               m.scalarAdd(new Fraction(2)));    }                        /** test operate */    public void testOperate() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id);        TestUtils.assertEquals(testVector, m.operate(testVector));        TestUtils.assertEquals(testVector, m.operate(new ArrayFieldVector<Fraction>(testVector)).getData());        m = new BlockFieldMatrix<Fraction>(bigSingular);        try {            m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }    public void testOperateLarge() {        int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;        int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;        int r =  BlockFieldMatrix.BLOCK_SIZE / 2;        Random random = new Random(111007463902334l);        FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q);        FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r);        FieldMatrix<Fraction> m1m2 = m1.multiply(m2);        for (int i = 0; i < r; ++i) {            TestUtils.assertEquals(m1m2.getColumn(i), m1.operate(m2.getColumn(i)));        }    }    public void testOperatePremultiplyLarge() {        int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;        int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;        int r =  BlockFieldMatrix.BLOCK_SIZE / 2;        Random random = new Random(111007463902334l);        FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q);        FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r);        FieldMatrix<Fraction> m1m2 = m1.multiply(m2);        for (int i = 0; i < p; ++i) {            TestUtils.assertEquals(m1m2.getRow(i), m2.preMultiply(m1.getRow(i)));        }    }    /** test issue MATH-209 */    public void testMath209() {        FieldMatrix<Fraction> a = new BlockFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(1), new Fraction(2) },                { new Fraction(3), new Fraction(4) },                { new Fraction(5), new Fraction(6) }        });        Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });        assertEquals(a.getRowDimension(), b.length);        assertEquals( new Fraction(3), b[0]);        assertEquals( new Fraction(7), b[1]);        assertEquals(new Fraction(11), b[2]);    }        /** test transpose */    public void testTranspose() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);         FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();        TestUtils.assertEquals(mIT, mTI);        m = new BlockFieldMatrix<Fraction>(testData2);        FieldMatrix<Fraction> mt = new BlockFieldMatrix<Fraction>(testData2T);        TestUtils.assertEquals(mt, m.transpose());    }        /** test preMultiply by vector */    public void testPremultiplyVector() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(m.preMultiply(testVector), preMultTest);        TestUtils.assertEquals(m.preMultiply(new ArrayFieldVector<Fraction>(testVector).getData()),                               preMultTest);        m = new BlockFieldMatrix<Fraction>(bigSingular);        try {            m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }        public void testPremultiply() {        FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);           FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4);        FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5);        TestUtils.assertEquals(m4.preMultiply(m3), m5);                BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);        BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id);        TestUtils.assertEquals(m.preMultiply(mInv), identity);        TestUtils.assertEquals(mInv.preMultiply(m), identity);        TestUtils.assertEquals(m.preMultiply(identity), m);        TestUtils.assertEquals(identity.preMultiply(mInv), mInv);        try {            m.preMultiply(new BlockFieldMatrix<Fraction>(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }        public void testGetVectors() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(m.getRow(0), testDataRow1);        TestUtils.assertEquals(m.getColumn(2), testDataCol3);        try {            m.getRow(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }        try {            m.getColumn(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }    }        public void testGetEntry() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        assertEquals(m.getEntry(0,1),new Fraction(2));        try {            m.getEntry(10, 4);            fail ("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }            /** test examples in user guide */    public void testExamples() {        // Create a real matrix with two rows and three columns        Fraction[][] matrixData = {                {new Fraction(1),new Fraction(2),new Fraction(3)},                {new Fraction(2),new Fraction(5),new Fraction(3)}        };        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(matrixData);        // One more with three rows, two columns        Fraction[][] matrixData2 = {                {new Fraction(1),new Fraction(2)},                {new Fraction(2),new Fraction(5)},                {new Fraction(1), new Fraction(7)}        };        FieldMatrix<Fraction> n = new BlockFieldMatrix<Fraction>(matrixData2);        // Now multiply m by n        FieldMatrix<Fraction> p = m.multiply(n);        assertEquals(2, p.getRowDimension());        assertEquals(2, p.getColumnDimension());        // Invert p        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();         assertEquals(2, pInverse.getRowDimension());        assertEquals(2, pInverse.getColumnDimension());                // Solve example        Fraction[][] coefficientsData = {                {new Fraction(2), new Fraction(3), new Fraction(-2)},                {new Fraction(-1), new Fraction(7), new Fraction(6)},                {new Fraction(4), new Fraction(-3), new Fraction(-5)}        };        FieldMatrix<Fraction> coefficients = new BlockFieldMatrix<Fraction>(coefficientsData);        Fraction[] constants = {new Fraction(1), new Fraction(-2), new Fraction(1)};        Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);        assertEquals(new Fraction(2).multiply(solution[0]).                     add(new Fraction(3).multiply(solution[1])).                     subtract(new Fraction(2).multiply(solution[2])),                     constants[0]);        assertEquals(new Fraction(-1).multiply(solution[0]).                     add(new Fraction(7).multiply(solution[1])).                     add(new Fraction(6).multiply(solution[2])),                     constants[1]);        assertEquals(new Fraction(4).multiply(solution[0]).                     subtract(new Fraction(3).multiply(solution[1])).                     subtract(new Fraction(5).multiply(solution[2])),                     constants[2]);               }        // test submatrix accessors    public void testGetSubMatrix() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);           checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);          checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);          checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);         checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,                                   int startRow, int endRow, int startColumn, int endColumn,                                   boolean mustFail) {        try {            FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);            assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }        private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,                                   int[] selectedRows, int[] selectedColumns,                                   boolean mustFail) {        try {            FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);            assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    public void testGetSetMatrixLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        FieldMatrix<Fraction> sub =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n - 4, n - 4).scalarAdd(new Fraction(1));        m.setSubMatrix(sub.getData(), 2, 2);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {                    assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));    }    public void testCopySubMatrix() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);           checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);          checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);          checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);         checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);                 checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, -1, 1, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,                           int startRow, int endRow, int startColumn, int endColumn,                           boolean mustFail) {        try {            Fraction[][] sub = (reference == null) ?                             new Fraction[1][1] :                             new Fraction[reference.length][reference[0].length];            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);            assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }        private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,                           int[] selectedRows, int[] selectedColumns,                           boolean mustFail) {        try {            Fraction[][] sub = (reference == null) ?                    new Fraction[1][1] :                    new Fraction[reference.length][reference[0].length];            m.copySubMatrix(selectedRows, selectedColumns, sub);            assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    public void testGetRowMatrix() {        FieldMatrix<Fraction> m     = new BlockFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mRow0 = new BlockFieldMatrix<Fraction>(subRow0);        FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3);        assertEquals("Row0", mRow0, m.getRowMatrix(0));        assertEquals("Row3", mRow3, m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowMatrix() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowMatrix(0, mRow3);        assertEquals(mRow3, m.getRowMatrix(0));        try {            m.setRowMatrix(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowMatrix(0, m);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        public void testGetSetRowMatrixLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        FieldMatrix<Fraction> sub =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), 1, n).scalarAdd(new Fraction(1));        m.setRowMatrix(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        assertEquals(sub, m.getRowMatrix(2));    }        public void testGetColumnMatrix() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mColumn1 = new BlockFieldMatrix<Fraction>(subColumn1);        FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3);        assertEquals(mColumn1, m.getColumnMatrix(1));        assertEquals(mColumn3, m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnMatrix() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3);        assertNotSame(mColumn3, m.getColumnMatrix(1));        m.setColumnMatrix(1, mColumn3);        assertEquals(mColumn3, m.getColumnMatrix(1));        try {            m.setColumnMatrix(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnMatrix(0, m);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetSetColumnMatrixLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        FieldMatrix<Fraction> sub =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, 1).scalarAdd(new Fraction(1));        m.setColumnMatrix(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        assertEquals(sub, m.getColumnMatrix(2));    }        public void testGetRowVector() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);        assertEquals(mRow0, m.getRowVector(0));        assertEquals(mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowVector() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowVector(0, mRow3);        assertEquals(mRow3, m.getRowVector(0));        try {            m.setRowVector(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetSetRowVectorLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        FieldVector<Fraction> sub = new ArrayFieldVector<Fraction>(n, new Fraction(1));        m.setRowVector(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        assertEquals(sub, m.getRowVector(2));    }        public void testGetColumnVector() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);        assertEquals(mColumn1, m.getColumnVector(1));        assertEquals(mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnVector() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);        assertNotSame(mColumn3, m.getColumnVector(1));        m.setColumnVector(1, mColumn3);        assertEquals(mColumn3, m.getColumnVector(1));        try {            m.setColumnVector(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetSetColumnVectorLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        FieldVector<Fraction> sub = new ArrayFieldVector<Fraction>(n, new Fraction(1));        m.setColumnVector(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        assertEquals(sub, m.getColumnVector(2));    }        private FieldVector<Fraction> columnToVector(Fraction[][] column) {        Fraction[] data = new Fraction[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayFieldVector<Fraction>(data, false);    }    public void testGetRow() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        checkArrays(subRow0[0], m.getRow(0));        checkArrays(subRow3[0], m.getRow(3));        try {            m.getRow(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRow(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRow() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        assertTrue(subRow3[0][0] != m.getRow(0)[0]);        m.setRow(0, subRow3[0]);        checkArrays(subRow3[0], m.getRow(0));        try {            m.setRow(-1, subRow3[0]);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRow(0, new Fraction[5]);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetSetRowLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        Fraction[] sub = new Fraction[n];        Arrays.fill(sub, new Fraction(1));        m.setRow(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        checkArrays(sub, m.getRow(2));    }        public void testGetColumn() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        Fraction[] mColumn1 = columnToArray(subColumn1);        Fraction[] mColumn3 = columnToArray(subColumn3);        checkArrays(mColumn1, m.getColumn(1));        checkArrays(mColumn3, m.getColumn(3));        try {            m.getColumn(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumn(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumn() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        Fraction[] mColumn3 = columnToArray(subColumn3);        assertTrue(mColumn3[0] != m.getColumn(1)[0]);        m.setColumn(1, mColumn3);        checkArrays(mColumn3, m.getColumn(1));        try {            m.setColumn(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumn(0, new Fraction[5]);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetSetColumnLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        Fraction[] sub = new Fraction[n];        Arrays.fill(sub, new Fraction(1));        m.setColumn(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        checkArrays(sub, m.getColumn(2));    }        private Fraction[] columnToArray(Fraction[][] column) {        Fraction[] data = new Fraction[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return data;    }    private void checkArrays(Fraction[] expected, Fraction[] actual) {        assertEquals(expected.length, actual.length);        for (int i = 0; i < expected.length; ++i) {            assertEquals(expected[i], actual[i]);                    }    }        public void testEqualsAndHashCode() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> m1 = (BlockFieldMatrix<Fraction>) m.copy();        BlockFieldMatrix<Fraction> mt = (BlockFieldMatrix<Fraction>) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(new BlockFieldMatrix<Fraction>(bigSingular)));     }        public void testToString() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        assertEquals("BlockFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}", m.toString());    }        public void testSetSubMatrix() throws Exception {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        m.setSubMatrix(detData2,1,1);        FieldMatrix<Fraction> expected = new BlockFieldMatrix<Fraction>            (new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(2),new Fraction(1),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});        assertEquals(expected, m);                  m.setSubMatrix(detData2,0,0);        expected = new BlockFieldMatrix<Fraction>            (new Fraction[][] {{new Fraction(1),new Fraction(3),new Fraction(3)},{new Fraction(2),new Fraction(4),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});        assertEquals(expected, m);                  m.setSubMatrix(testDataPlus2,0,0);              expected = new BlockFieldMatrix<Fraction>            (new Fraction[][] {{new Fraction(3),new Fraction(4),new Fraction(5)},{new Fraction(4),new Fraction(7),new Fraction(5)},{new Fraction(3),new Fraction(2),new Fraction(10)}});        assertEquals(expected, m);                   // javadoc example        BlockFieldMatrix<Fraction> matrix =            new BlockFieldMatrix<Fraction>(new Fraction[][] {                    {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)},                    {new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8)},                    {new Fraction(9), new Fraction(0), new Fraction(1) , new Fraction(2)}            });        matrix.setSubMatrix(new Fraction[][] {                {new Fraction(3), new Fraction(4)},                {new Fraction(5), new Fraction(6)}        }, 1, 1);        expected =            new BlockFieldMatrix<Fraction>(new Fraction[][] {                    {new Fraction(1), new Fraction(2), new Fraction(3),new Fraction(4)},                    {new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8)},                    {new Fraction(9), new Fraction(5) ,new Fraction(6), new Fraction(2)}            });        assertEquals(expected, matrix);           // dimension overflow        try {              m.setSubMatrix(testData,1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // dimension underflow        try {              m.setSubMatrix(testData,-1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        try {              m.setSubMatrix(testData,1,-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }                // null        try {            m.setSubMatrix(null,1,1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }                // ragged        try {            m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }               // empty        try {            m.setSubMatrix(new Fraction[][] {{}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }            }    public void testWalk() {        int rows    = 150;        int columns = 75;        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInRowOrder(new SetVisitor());        GetVisitor getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(new Fraction(0), m.getEntry(i, 0));                                assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            assertEquals(new Fraction(0), m.getEntry(0, j));                                assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInColumnOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(new Fraction(0), m.getEntry(i, 0));                                assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            assertEquals(new Fraction(0), m.getEntry(0, j));                                assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(new Fraction(0), m.getEntry(i, 0));                                assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            assertEquals(new Fraction(0), m.getEntry(0, j));                                assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(new Fraction(0), m.getEntry(i, 0));                                assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            assertEquals(new Fraction(0), m.getEntry(0, j));                                assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }    }    public void testSerial()  {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        assertEquals(m,TestUtils.serializeAndRecover(m));    }    private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Fraction> {        public SetVisitor() {            super(Fraction.ZERO);        }        @Override        public Fraction visit(int i, int j, Fraction value) {            return new Fraction(i * 11 + j, 11);        }    }    private static class GetVisitor extends DefaultFieldMatrixPreservingVisitor<Fraction> {        private int count;        public GetVisitor() {            super(Fraction.ZERO);            count = 0;        }        @Override        public void visit(int i, int j, Fraction value) {            ++count;            assertEquals(new Fraction(i * 11 + j, 11), value);        }        public int getCount() {            return count;        }    }    private BlockFieldMatrix<Fraction> createRandomMatrix(Random r, int rows, int columns) {        BlockFieldMatrix<Fraction> m =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        for (int i = 0; i < rows; ++i) {            for (int j = 0; j < columns; ++j) {                int p = r.nextInt(20) - 10;                int q = r.nextInt(20) - 10;                if (q == 0) {                    q = 1;                }                m.setEntry(i, j, new Fraction(p, q));            }        }        return m;    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;/** * Test cases for the {@link Array2DRowRealMatrix} class. * * @version $Revision$ $Date$ */public final class Array2DRowRealMatrixTest extends TestCase {        // 3 x 3 identity matrix    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };        // Test data for group operations    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},        {-1d,0d,-8d} };    protected double[] testDataRow1 = {1d,2d,3d};    protected double[] testDataCol3 = {3d,3d,8d};    protected double[][] testDataInv =         { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };    protected double[] preMultTest = {8,12,33};    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};    protected double[][] testDataPlusInv =         { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };        // lu decomposition tests    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},            {0.33333333333333,0d,0.33333333333333} };        // singular matrices    protected double[][] singular = { {2d,3d}, {2d,3d} };    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};        // vectors    protected double[] testVector = {1,2,3};    protected double[] testVector2 = {1,2,3,4};        // submatrix accessor tests    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},            {2, 4, 6, 8}, {4, 5, 6, 7}};     // array selections    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};    // effective permutations    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};    // contiguous ranges    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};    protected double[][] subRows23Cols00 = {{2} , {4}};    protected double[][] subRows00Cols33 = {{4}};    // row matrices    protected double[][] subRow0 = {{1,2,3,4}};    protected double[][] subRow3 = {{4,5,6,7}};    // column matrices    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};        // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;        public Array2DRowRealMatrixTest(String name) {        super(name);    }        public static Test suite() {        TestSuite suite = new TestSuite(Array2DRowRealMatrixTest.class);        suite.setName("Array2DRowRealMatrix Tests");        return suite;    }        /** test dimensions */    public void testDimensions() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());    }         /** test copy functions */    public void testCopyFunctions() {        Array2DRowRealMatrix m1 = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(m1.getData());        assertEquals(m2,m1);        Array2DRowRealMatrix m3 = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m4 = new Array2DRowRealMatrix(m3.getData(), false);        assertEquals(m4,m3);    }                   /** test add */    public void testAdd() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);        RealMatrix mPlusMInv = m.add(mInv);        double[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                    testDataPlusInv[row][col],sumEntries[row][col],                        entryTolerance);            }        }        }        /** test add failure */    public void testAddFail() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);        try {            m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }    }        /** test norm */    public void testNorm() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);        assertEquals("testData norm",14d,m.getNorm(),entryTolerance);        assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);    }        /** test Frobenius norm */    public void testFrobeniusNorm() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);        assertEquals("testData Frobenius norm", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);        assertEquals("testData2 Frobenius norm", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);    }         /** test m-n = m + -n */    public void testPlusMinus() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testDataInv);        TestUtils.assertEquals("m-n = m + -n",m.subtract(m2),            m2.scalarMultiply(-1d).add(m),entryTolerance);                try {            m.subtract(new Array2DRowRealMatrix(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }       /** test multiply */     public void testMultiply() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);        Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);        TestUtils.assertEquals("inverse multiply",m.multiply(mInv),            identity,entryTolerance);        TestUtils.assertEquals("inverse multiply",mInv.multiply(m),            identity,entryTolerance);        TestUtils.assertEquals("identity multiply",m.multiply(identity),            m,entryTolerance);        TestUtils.assertEquals("identity multiply",identity.multiply(mInv),            mInv,entryTolerance);        TestUtils.assertEquals("identity multiply",m2.multiply(identity),            m2,entryTolerance);         try {            m.multiply(new Array2DRowRealMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }           //Additional Test for Array2DRowRealMatrixTest.testMultiply    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};    private double[][] d4 = new double[][] {{1},{2},{3},{4}};    private double[][] d5 = new double[][] {{30},{70}};         public void testMultiply2() {        RealMatrix m3 = new Array2DRowRealMatrix(d3);          RealMatrix m4 = new Array2DRowRealMatrix(d4);       RealMatrix m5 = new Array2DRowRealMatrix(d5);       TestUtils.assertEquals("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);   }              /** test trace */    public void testTrace() {        RealMatrix m = new Array2DRowRealMatrix(id);        assertEquals("identity trace",3d,m.getTrace(),entryTolerance);        m = new Array2DRowRealMatrix(testData2);        try {            m.getTrace();            fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }          }        /** test sclarAdd */    public void testScalarAdd() {        RealMatrix m = new Array2DRowRealMatrix(testData);        TestUtils.assertEquals("scalar add",new Array2DRowRealMatrix(testDataPlus2),            m.scalarAdd(2d),entryTolerance);    }                        /** test operate */    public void testOperate() {        RealMatrix m = new Array2DRowRealMatrix(id);        TestUtils.assertEquals("identity operate", testVector,                    m.operate(testVector), entryTolerance);        TestUtils.assertEquals("identity operate", testVector,                    m.operate(new ArrayRealVector(testVector)).getData(), entryTolerance);        m = new Array2DRowRealMatrix(bigSingular);        try {            m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }    /** test issue MATH-209 */    public void testMath209() {        RealMatrix a = new Array2DRowRealMatrix(new double[][] {                { 1, 2 }, { 3, 4 }, { 5, 6 }        }, false);        double[] b = a.operate(new double[] { 1, 1 });        assertEquals(a.getRowDimension(), b.length);        assertEquals( 3.0, b[0], 1.0e-12);        assertEquals( 7.0, b[1], 1.0e-12);        assertEquals(11.0, b[2], 1.0e-12);    }        /** test transpose */    public void testTranspose() {        RealMatrix m = new Array2DRowRealMatrix(testData);         RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();        TestUtils.assertEquals("inverse-transpose", mIT, mTI, normTolerance);        m = new Array2DRowRealMatrix(testData2);        RealMatrix mt = new Array2DRowRealMatrix(testData2T);        TestUtils.assertEquals("transpose",mt,m.transpose(),normTolerance);    }        /** test preMultiply by vector */    public void testPremultiplyVector() {        RealMatrix m = new Array2DRowRealMatrix(testData);        TestUtils.assertEquals("premultiply", m.preMultiply(testVector),                    preMultTest, normTolerance);        TestUtils.assertEquals("premultiply", m.preMultiply(new ArrayRealVector(testVector).getData()),                    preMultTest, normTolerance);        m = new Array2DRowRealMatrix(bigSingular);        try {            m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }        public void testPremultiply() {        RealMatrix m3 = new Array2DRowRealMatrix(d3);           RealMatrix m4 = new Array2DRowRealMatrix(d4);        RealMatrix m5 = new Array2DRowRealMatrix(d5);        TestUtils.assertEquals("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);                Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);        Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id);        TestUtils.assertEquals("inverse multiply",m.preMultiply(mInv),                identity,entryTolerance);        TestUtils.assertEquals("inverse multiply",mInv.preMultiply(m),                identity,entryTolerance);        TestUtils.assertEquals("identity multiply",m.preMultiply(identity),                m,entryTolerance);        TestUtils.assertEquals("identity multiply",identity.preMultiply(mInv),                mInv,entryTolerance);        try {            m.preMultiply(new Array2DRowRealMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }        public void testGetVectors() {        RealMatrix m = new Array2DRowRealMatrix(testData);        TestUtils.assertEquals("get row",m.getRow(0),testDataRow1,entryTolerance);        TestUtils.assertEquals("get col",m.getColumn(2),testDataCol3,entryTolerance);        try {            m.getRow(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }        try {            m.getColumn(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }    }        public void testGetEntry() {        RealMatrix m = new Array2DRowRealMatrix(testData);        assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);        try {            m.getEntry(10, 4);            fail ("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }            /** test examples in user guide */    public void testExamples() {        // Create a real matrix with two rows and three columns        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};        RealMatrix m = new Array2DRowRealMatrix(matrixData);        // One more with three rows, two columns        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};        RealMatrix n = new Array2DRowRealMatrix(matrixData2);        // Now multiply m by n        RealMatrix p = m.multiply(n);        assertEquals(2, p.getRowDimension());        assertEquals(2, p.getColumnDimension());        // Invert p        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();         assertEquals(2, pInverse.getRowDimension());        assertEquals(2, pInverse.getColumnDimension());                // Solve example        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};        RealMatrix coefficients = new Array2DRowRealMatrix(coefficientsData);        double[] constants = {1, -2, 1};        double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);               }        // test submatrix accessors    public void testGetSubMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);           checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);          checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);          checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);         checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int startRow, int endRow, int startColumn, int endColumn,                                   boolean mustFail) {        try {            RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);            assertEquals(new Array2DRowRealMatrix(reference), sub);            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }        private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int[] selectedRows, int[] selectedColumns,                                   boolean mustFail) {        try {            RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);            assertEquals(new Array2DRowRealMatrix(reference), sub);            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    public void testCopySubMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);           checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);          checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);          checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);         checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);                 checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, -1, 1, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkCopy(RealMatrix m, double[][] reference,                           int startRow, int endRow, int startColumn, int endColumn,                           boolean mustFail) {        try {            double[][] sub = (reference == null) ?                             new double[1][1] :                             new double[reference.length][reference[0].length];            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);            assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }        private void checkCopy(RealMatrix m, double[][] reference,                           int[] selectedRows, int[] selectedColumns,                           boolean mustFail) {        try {            double[][] sub = (reference == null) ?                    new double[1][1] :                    new double[reference.length][reference[0].length];            m.copySubMatrix(selectedRows, selectedColumns, sub);            assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    public void testGetRowMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealMatrix mRow0 = new Array2DRowRealMatrix(subRow0);        RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3);        assertEquals("Row0", mRow0,                 m.getRowMatrix(0));        assertEquals("Row3", mRow3,                 m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }        public void testSetRowMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowMatrix(0, mRow3);        assertEquals(mRow3, m.getRowMatrix(0));        try {            m.setRowMatrix(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowMatrix(0, m);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        public void testGetColumnMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealMatrix mColumn1 = new Array2DRowRealMatrix(subColumn1);        RealMatrix mColumn3 = new Array2DRowRealMatrix(subColumn3);        assertEquals("Column1", mColumn1,                 m.getColumnMatrix(1));        assertEquals("Column3", mColumn3,                 m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealMatrix mColumn3 = new Array2DRowRealMatrix(subColumn3);        assertNotSame(mColumn3, m.getColumnMatrix(1));        m.setColumnMatrix(1, mColumn3);        assertEquals(mColumn3, m.getColumnMatrix(1));        try {            m.setColumnMatrix(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnMatrix(0, m);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetRowVector() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealVector mRow0 = new ArrayRealVector(subRow0[0]);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        assertEquals("Row0", mRow0, m.getRowVector(0));        assertEquals("Row3", mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowVector() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowVector(0, mRow3);        assertEquals(mRow3, m.getRowVector(0));        try {            m.setRowVector(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowVector(0, new ArrayRealVector(5));            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        public void testGetColumnVector() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealVector mColumn1 = columnToVector(subColumn1);        RealVector mColumn3 = columnToVector(subColumn3);        assertEquals("Column1", mColumn1, m.getColumnVector(1));        assertEquals("Column3", mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnVector() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealVector mColumn3 = columnToVector(subColumn3);        assertNotSame(mColumn3, m.getColumnVector(1));        m.setColumnVector(1, mColumn3);        assertEquals(mColumn3, m.getColumnVector(1));        try {            m.setColumnVector(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnVector(0, new ArrayRealVector(5));            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    private RealVector columnToVector(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayRealVector(data, false);    }    public void testGetRow() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        checkArrays(subRow0[0], m.getRow(0));        checkArrays(subRow3[0], m.getRow(3));        try {            m.getRow(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRow(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRow() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        assertTrue(subRow3[0][0] != m.getRow(0)[0]);        m.setRow(0, subRow3[0]);        checkArrays(subRow3[0], m.getRow(0));        try {            m.setRow(-1, subRow3[0]);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRow(0, new double[5]);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        public void testGetColumn() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        double[] mColumn1 = columnToArray(subColumn1);        double[] mColumn3 = columnToArray(subColumn3);        checkArrays(mColumn1, m.getColumn(1));        checkArrays(mColumn3, m.getColumn(3));        try {            m.getColumn(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumn(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumn() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        double[] mColumn3 = columnToArray(subColumn3);        assertTrue(mColumn3[0] != m.getColumn(1)[0]);        m.setColumn(1, mColumn3);        checkArrays(mColumn3, m.getColumn(1));        try {            m.setColumn(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumn(0, new double[5]);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    private double[] columnToArray(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return data;    }    private void checkArrays(double[] expected, double[] actual) {        assertEquals(expected.length, actual.length);        for (int i = 0; i < expected.length; ++i) {            assertEquals(expected[i], actual[i]);                    }    }        public void testEqualsAndHashCode() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m1 = (Array2DRowRealMatrix) m.copy();        Array2DRowRealMatrix mt = (Array2DRowRealMatrix) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(new Array2DRowRealMatrix(bigSingular)));     }        public void testToString() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        assertEquals("Array2DRowRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",                m.toString());        m = new Array2DRowRealMatrix();        assertEquals("Array2DRowRealMatrix{}",                m.toString());    }        public void testSetSubMatrix() throws Exception {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        m.setSubMatrix(detData2,1,1);        RealMatrix expected = MatrixUtils.createRealMatrix            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);                  m.setSubMatrix(detData2,0,0);        expected = MatrixUtils.createRealMatrix            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);                  m.setSubMatrix(testDataPlus2,0,0);              expected = MatrixUtils.createRealMatrix            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});        assertEquals(expected, m);                   // dimension overflow        try {              m.setSubMatrix(testData,1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // dimension underflow        try {              m.setSubMatrix(testData,-1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        try {              m.setSubMatrix(testData,1,-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }                // null        try {            m.setSubMatrix(null,1,1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix();        try {            m2.setSubMatrix(testData,0,1);            fail("expecting IllegalStateException");        } catch (IllegalStateException e) {            // expected        }        try {            m2.setSubMatrix(testData,1,0);            fail("expecting IllegalStateException");        } catch (IllegalStateException e) {            // expected        }                // ragged        try {            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }               // empty        try {            m.setSubMatrix(new double[][] {{}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }            }    public void testWalk() {        int rows    = 150;        int columns = 75;        RealMatrix m = new Array2DRowRealMatrix(rows, columns);        m.walkInRowOrder(new SetVisitor());        GetVisitor getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowRealMatrix(rows, columns);        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);                                assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);                                assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new Array2DRowRealMatrix(rows, columns);        m.walkInColumnOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowRealMatrix(rows, columns);        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);                                assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);                                assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new Array2DRowRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);                                assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);                                assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new Array2DRowRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);                                assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);                                assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }    }    public void testSerial()  {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        assertEquals(m,TestUtils.serializeAndRecover(m));    }            private static class SetVisitor extends DefaultRealMatrixChangingVisitor {        @Override        public double visit(int i, int j, double value) {            return i + j / 1024.0;        }    }    private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {        private int count = 0;        @Override        public void visit(int i, int j, double value) {            ++count;            assertEquals(i + j / 1024.0, value, 0.0);        }        public int getCount() {            return count;        }    }    //--------------- -----------------Protected methods        /** extracts the l  and u matrices from compact lu representation */    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) throws InvalidMatrixException {           if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||                lowerData.length != upperData.length                || lowerData.length != lu.getRowDimension()) {            throw new InvalidMatrixException("incorrect dimensions");        }            int n = lu.getRowDimension();        for (int i = 0; i < n; i++) {            for (int j = 0; j < n; j++) {                if (j < i) {                    lowerData[i][j] = lu.getEntry(i, j);                    upperData[i][j] = 0d;                } else if (i == j) {                    lowerData[i][j] = 1d;                    upperData[i][j] = lu.getEntry(i, j);                } else {                    lowerData[i][j] = 0d;                    upperData[i][j] = lu.getEntry(i, j);                }               }        }    }        /** Returns the result of applying the given row permutation to the matrix */    protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) {        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {            throw new IllegalArgumentException("dimension mismatch");        }        int n = matrix.getRowDimension();        int m = matrix.getColumnDimension();        double out[][] = new double[m][n];        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                out[i][j] = matrix.getEntry(permutation[i], j);            }        }        return new Array2DRowRealMatrix(out);    }    //    /** Useful for debugging *///    private void dumpMatrix(RealMatrix m) {//          for (int i = 0; i < m.getRowDimension(); i++) {//              String os = "";//              for (int j = 0; j < m.getColumnDimension(); j++) {//                  os += m.getEntry(i, j) + " ";//              }//              System.out.println(os);//          }//    }        }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionConversionException;import org.apache.commons.math.fraction.FractionField;import junit.framework.TestCase;/** * Test cases for the {@link SparseFieldVector} class. * * @version $Revision: 728186 $ $Date: 2009-04-20 11:42:11 -0700 (Mon, 20 Apr 2009) $ */public class SparseFieldVectorTest extends TestCase {    //     protected Fraction[][] ma1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)}, {new Fraction(7), new Fraction(8), new Fraction(9)}};    protected Fraction[] vec1 = {new Fraction(1), new Fraction(2), new Fraction(3)};    protected Fraction[] vec2 = {new Fraction(4), new Fraction(5), new Fraction(6)};    protected Fraction[] vec3 = {new Fraction(7), new Fraction(8), new Fraction(9)};    protected Fraction[] vec4 = {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8), new Fraction(9)};    protected Fraction[] vec_null = {new Fraction(0), new Fraction(0), new Fraction(0)};    protected Fraction[] dvec1 = {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8),new Fraction(9)};    protected Fraction[][] mat1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)},{ new Fraction(7), new Fraction(8), new Fraction(9)}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    protected FractionField field = FractionField.getInstance();    public void testMapFunctions() throws FractionConversionException {         SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);        //octave =  v1 .+ 2.0        FieldVector<Fraction> v_mapAdd = v1.mapAdd(new Fraction(2));        Fraction[] result_mapAdd = {new Fraction(3), new Fraction(4), new Fraction(5)};        assertEquals("compare vectors" ,result_mapAdd,v_mapAdd.getData());        //octave =  v1 .+ 2.0        FieldVector<Fraction> v_mapAddToSelf = v1.copy();        v_mapAddToSelf.mapAddToSelf(new Fraction(2));        Fraction[] result_mapAddToSelf = {new Fraction(3), new Fraction(4), new Fraction(5)};        assertEquals("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData());        //octave =  v1 .- 2.0        FieldVector<Fraction> v_mapSubtract = v1.mapSubtract(new Fraction(2));        Fraction[] result_mapSubtract = {new Fraction(-1), new Fraction(0), new Fraction(1)};        assertEquals("compare vectors" ,result_mapSubtract,v_mapSubtract.getData());        //octave =  v1 .- 2.0        FieldVector<Fraction> v_mapSubtractToSelf = v1.copy();        v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));        Fraction[] result_mapSubtractToSelf = {new Fraction(-1), new Fraction(0), new Fraction(1)};        assertEquals("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData());        //octave =  v1 .* 2.0        FieldVector<Fraction> v_mapMultiply = v1.mapMultiply(new Fraction(2));        Fraction[] result_mapMultiply = {new Fraction(2), new Fraction(4), new Fraction(6)};        assertEquals("compare vectors" ,result_mapMultiply,v_mapMultiply.getData());        //octave =  v1 .* 2.0        FieldVector<Fraction> v_mapMultiplyToSelf = v1.copy();        v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));        Fraction[] result_mapMultiplyToSelf = {new Fraction(2), new Fraction(4), new Fraction(6)};        assertEquals("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());        //octave =  v1 ./ 2.0        FieldVector<Fraction> v_mapDivide = v1.mapDivide(new Fraction(2));        Fraction[] result_mapDivide = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)};        assertEquals("compare vectors" ,result_mapDivide,v_mapDivide.getData());        //octave =  v1 ./ 2.0        FieldVector<Fraction> v_mapDivideToSelf = v1.copy();        v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));        Fraction[] result_mapDivideToSelf = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)};        assertEquals("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData());        //octave =  v1 .^-1        FieldVector<Fraction> v_mapInv = v1.mapInv();        Fraction[] result_mapInv = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};        assertEquals("compare vectors" ,result_mapInv,v_mapInv.getData());        //octave =  v1 .^-1        FieldVector<Fraction> v_mapInvToSelf = v1.copy();        v_mapInvToSelf.mapInvToSelf();        Fraction[] result_mapInvToSelf = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};        assertEquals("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData());    }    public void testBasicFunctions() throws FractionConversionException {         SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);        SparseFieldVector<Fraction> v2 = new SparseFieldVector<Fraction>(field,vec2);        SparseFieldVector<Fraction> v2_t = new SparseFieldVector<Fraction>(field,vec2);         //octave =  v1 + v2        FieldVector<Fraction> v_add = v1.add(v2);        Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)};        assertEquals("compare vect" ,v_add.getData(),result_add);        SparseFieldVector<Fraction> vt2 = new SparseFieldVector<Fraction>(field,vec2);        FieldVector<Fraction> v_add_i = v1.add(vt2);        Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)};        assertEquals("compare vect" ,v_add_i.getData(),result_add_i);        //octave =  v1 - v2        SparseFieldVector<Fraction> v_subtract = v1.subtract(v2);        Fraction[] result_subtract = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};        assertClose("compare vect" ,v_subtract.getData(),result_subtract,normTolerance);        FieldVector<Fraction> v_subtract_i = v1.subtract(vt2);        Fraction[] result_subtract_i = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};        assertClose("compare vect" ,v_subtract_i.getData(),result_subtract_i,normTolerance);        // octave v1 .* v2        FieldVector<Fraction>  v_ebeMultiply = v1.ebeMultiply(v2);        Fraction[] result_ebeMultiply = {new Fraction(4), new Fraction(10), new Fraction(18)};        assertClose("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);        FieldVector<Fraction>  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);        Fraction[] result_ebeMultiply_2 = {new Fraction(4), new Fraction(10), new Fraction(18)};        assertClose("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);        // octave v1 ./ v2        FieldVector<Fraction>  v_ebeDivide = v1.ebeDivide(v2);        Fraction[] result_ebeDivide = {new Fraction(0.25d), new Fraction(0.4d), new Fraction(0.5d)};        assertClose("compare vect" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);        FieldVector<Fraction>  v_ebeDivide_2 = v1.ebeDivide(v2_t);        Fraction[] result_ebeDivide_2 = {new Fraction(0.25d), new Fraction(0.4d), new Fraction(0.5d)};        assertClose("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);        // octave  dot(v1,v2)        Fraction dot =  v1.dotProduct(v2);        assertEquals("compare val ",new Fraction(32), dot);        // octave  dot(v1,v2_t)        Fraction dot_2 =  v1.dotProduct(v2_t);        assertEquals("compare val ",new Fraction(32), dot_2);        FieldMatrix<Fraction> m_outerProduct = v1.outerProduct(v2);        assertEquals("compare val ",new Fraction(4), m_outerProduct.getEntry(0,0));        FieldMatrix<Fraction> m_outerProduct_2 = v1.outerProduct(v2_t);        assertEquals("compare val ",new Fraction(4), m_outerProduct_2.getEntry(0,0));    }    public void testMisc() {         SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);        String out1 = v1.toString();        assertTrue("some output ",  out1.length()!=0);        try {            v1.checkVectorDimensions(2);             fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }         }    public void testPredicates() {        SparseFieldVector<Fraction> v = new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) });        v.setEntry(0, field.getZero());        assertEquals(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) }));        assertNotSame(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2), new Fraction(3) }));    }    /** verifies that two vectors are close (sup norm) */    protected void assertEquals(String msg, Fraction[] m, Fraction[] n) {        if (m.length != n.length) {            fail("vectors have different lengths");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " +  i + " elements differ", m[i],n[i]);        }    }    /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, Fraction[] m, Fraction[] n, double tolerance) {        if (m.length != n.length) {            fail("vectors have different lengths");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " +  i + " elements differ", m[i].doubleValue(),n[i].doubleValue(), tolerance);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;/** * Test cases for the {@link OpenMapRealMatrix} class. *  * @version $Revision$ $Date: 2008-11-07 06:48:13 -0800 (Fri, 07 Nov *          2008) $ */public final class SparseRealMatrixTest extends TestCase {    // 3 x 3 identity matrix    protected double[][] id = { { 1d, 0d, 0d }, { 0d, 1d, 0d }, { 0d, 0d, 1d } };    // Test data for group operations    protected double[][] testData = { { 1d, 2d, 3d }, { 2d, 5d, 3d },            { 1d, 0d, 8d } };    protected double[][] testDataLU = { { 2d, 5d, 3d }, { .5d, -2.5d, 6.5d },            { 0.5d, 0.2d, .2d } };    protected double[][] testDataPlus2 = { { 3d, 4d, 5d }, { 4d, 7d, 5d },            { 3d, 2d, 10d } };    protected double[][] testDataMinus = { { -1d, -2d, -3d },            { -2d, -5d, -3d }, { -1d, 0d, -8d } };    protected double[] testDataRow1 = { 1d, 2d, 3d };    protected double[] testDataCol3 = { 3d, 3d, 8d };    protected double[][] testDataInv = { { -40d, 16d, 9d }, { 13d, -5d, -3d },            { 5d, -2d, -1d } };    protected double[] preMultTest = { 8, 12, 33 };    protected double[][] testData2 = { { 1d, 2d, 3d }, { 2d, 5d, 3d } };    protected double[][] testData2T = { { 1d, 2d }, { 2d, 5d }, { 3d, 3d } };    protected double[][] testDataPlusInv = { { -39d, 18d, 12d },            { 15d, 0d, 0d }, { 6d, -2d, 7d } };    // lu decomposition tests    protected double[][] luData = { { 2d, 3d, 3d }, { 0d, 5d, 7d }, { 6d, 9d, 8d } };    protected double[][] luDataLUDecomposition = { { 6d, 9d, 8d },            { 0d, 5d, 7d }, { 0.33333333333333, 0d, 0.33333333333333 } };    // singular matrices    protected double[][] singular = { { 2d, 3d }, { 2d, 3d } };    protected double[][] bigSingular = { { 1d, 2d, 3d, 4d },            { 2d, 5d, 3d, 4d }, { 7d, 3d, 256d, 1930d }, { 3d, 7d, 6d, 8d } }; // 4th    // row    // =    // 1st    // +    // 2nd    protected double[][] detData = { { 1d, 2d, 3d }, { 4d, 5d, 6d },            { 7d, 8d, 10d } };    protected double[][] detData2 = { { 1d, 3d }, { 2d, 4d } };    // vectors    protected double[] testVector = { 1, 2, 3 };    protected double[] testVector2 = { 1, 2, 3, 4 };    // submatrix accessor tests    protected double[][] subTestData = { { 1, 2, 3, 4 },            { 1.5, 2.5, 3.5, 4.5 }, { 2, 4, 6, 8 }, { 4, 5, 6, 7 } };    // array selections    protected double[][] subRows02Cols13 = { { 2, 4 }, { 4, 8 } };    protected double[][] subRows03Cols12 = { { 2, 3 }, { 5, 6 } };    protected double[][] subRows03Cols123 = { { 2, 3, 4 }, { 5, 6, 7 } };    // effective permutations    protected double[][] subRows20Cols123 = { { 4, 6, 8 }, { 2, 3, 4 } };    protected double[][] subRows31Cols31 = { { 7, 5 }, { 4.5, 2.5 } };    // contiguous ranges    protected double[][] subRows01Cols23 = { { 3, 4 }, { 3.5, 4.5 } };    protected double[][] subRows23Cols00 = { { 2 }, { 4 } };    protected double[][] subRows00Cols33 = { { 4 } };    // row matrices    protected double[][] subRow0 = { { 1, 2, 3, 4 } };    protected double[][] subRow3 = { { 4, 5, 6, 7 } };    // column matrices    protected double[][] subColumn1 = { { 2 }, { 2.5 }, { 4 }, { 5 } };    protected double[][] subColumn3 = { { 4 }, { 4.5 }, { 8 }, { 7 } };    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    public SparseRealMatrixTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SparseRealMatrixTest.class);        suite.setName("SparseRealMatrix Tests");        return suite;    }    /** test dimensions */    public void testDimensions() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix m2 = createSparseMatrix(testData2);        assertEquals("testData row dimension", 3, m.getRowDimension());        assertEquals("testData column dimension", 3, m.getColumnDimension());        assertTrue("testData is square", m.isSquare());        assertEquals("testData2 row dimension", m2.getRowDimension(), 2);        assertEquals("testData2 column dimension", m2.getColumnDimension(), 3);        assertTrue("testData2 is not square", !m2.isSquare());    }    /** test copy functions */    public void testCopyFunctions() {        OpenMapRealMatrix m1 = createSparseMatrix(testData);        RealMatrix m2 = m1.copy();        assertTrue(m2 instanceof OpenMapRealMatrix);        assertEquals((m2), m1);        OpenMapRealMatrix m3 = createSparseMatrix(testData);        RealMatrix m4 = m3.copy();        assertTrue(m4 instanceof OpenMapRealMatrix);        assertEquals((m4), m3);    }    /** test add */    public void testAdd() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix mInv = createSparseMatrix(testDataInv);        OpenMapRealMatrix mDataPlusInv = createSparseMatrix(testDataPlusInv);        RealMatrix mPlusMInv = m.add(mInv);        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                     mDataPlusInv.getEntry(row, col), mPlusMInv.getEntry(row, col),                     entryTolerance);            }        }    }    /** test add failure */    public void testAddFail() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix m2 = createSparseMatrix(testData2);        try {            m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test norm */    public void testNorm() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix m2 = createSparseMatrix(testData2);        assertEquals("testData norm", 14d, m.getNorm(), entryTolerance);        assertEquals("testData2 norm", 7d, m2.getNorm(), entryTolerance);    }    /** test m-n = m + -n */    public void testPlusMinus() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix n = createSparseMatrix(testDataInv);        assertClose("m-n = m + -n", m.subtract(n),            n.scalarMultiply(-1d).add(m), entryTolerance);        try {            m.subtract(createSparseMatrix(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test multiply */    public void testMultiply() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix mInv = createSparseMatrix(testDataInv);        OpenMapRealMatrix identity = createSparseMatrix(id);        OpenMapRealMatrix m2 = createSparseMatrix(testData2);        assertClose("inverse multiply", m.multiply(mInv), identity,                entryTolerance);        assertClose("inverse multiply", m.multiply(new BlockRealMatrix(testDataInv)), identity,                    entryTolerance);        assertClose("inverse multiply", mInv.multiply(m), identity,                entryTolerance);        assertClose("identity multiply", m.multiply(identity), m,                entryTolerance);        assertClose("identity multiply", identity.multiply(mInv), mInv,                entryTolerance);        assertClose("identity multiply", m2.multiply(identity), m2,                entryTolerance);        try {            m.multiply(createSparseMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    // Additional Test for Array2DRowRealMatrixTest.testMultiply    private double[][] d3 = new double[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };    private double[][] d4 = new double[][] { { 1 }, { 2 }, { 3 }, { 4 } };    private double[][] d5 = new double[][] { { 30 }, { 70 } };    public void testMultiply2() {        RealMatrix m3 = createSparseMatrix(d3);        RealMatrix m4 = createSparseMatrix(d4);        RealMatrix m5 = createSparseMatrix(d5);        assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);    }    /** test trace */    public void testTrace() {        RealMatrix m = createSparseMatrix(id);        assertEquals("identity trace", 3d, m.getTrace(), entryTolerance);        m = createSparseMatrix(testData2);        try {            m.getTrace();            fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }    }    /** test sclarAdd */    public void testScalarAdd() {        RealMatrix m = createSparseMatrix(testData);        assertClose("scalar add", createSparseMatrix(testDataPlus2),             m.scalarAdd(2d), entryTolerance);    }    /** test operate */    public void testOperate() {        RealMatrix m = createSparseMatrix(id);        assertClose("identity operate", testVector, m.operate(testVector),                entryTolerance);        assertClose("identity operate", testVector, m.operate(                new ArrayRealVector(testVector)).getData(), entryTolerance);        m = createSparseMatrix(bigSingular);        try {            m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test issue MATH-209 */    public void testMath209() {        RealMatrix a = createSparseMatrix(new double[][] {                { 1, 2 }, { 3, 4 }, { 5, 6 } });        double[] b = a.operate(new double[] { 1, 1 });        assertEquals(a.getRowDimension(), b.length);        assertEquals(3.0, b[0], 1.0e-12);        assertEquals(7.0, b[1], 1.0e-12);        assertEquals(11.0, b[2], 1.0e-12);    }    /** test transpose */    public void testTranspose() {                RealMatrix m = createSparseMatrix(testData);         RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();        assertClose("inverse-transpose", mIT, mTI, normTolerance);        m = createSparseMatrix(testData2);        RealMatrix mt = createSparseMatrix(testData2T);        assertClose("transpose",mt,m.transpose(),normTolerance);    }    /** test preMultiply by vector */    public void testPremultiplyVector() {        RealMatrix m = createSparseMatrix(testData);        assertClose("premultiply", m.preMultiply(testVector), preMultTest,            normTolerance);        assertClose("premultiply", m.preMultiply(            new ArrayRealVector(testVector).getData()), preMultTest, normTolerance);        m = createSparseMatrix(bigSingular);        try {            m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testPremultiply() {        RealMatrix m3 = createSparseMatrix(d3);        RealMatrix m4 = createSparseMatrix(d4);        RealMatrix m5 = createSparseMatrix(d5);        assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix mInv = createSparseMatrix(testDataInv);        OpenMapRealMatrix identity = createSparseMatrix(id);        assertClose("inverse multiply", m.preMultiply(mInv), identity,                entryTolerance);        assertClose("inverse multiply", mInv.preMultiply(m), identity,                entryTolerance);        assertClose("identity multiply", m.preMultiply(identity), m,                entryTolerance);        assertClose("identity multiply", identity.preMultiply(mInv), mInv,                entryTolerance);        try {            m.preMultiply(createSparseMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testGetVectors() {        RealMatrix m = createSparseMatrix(testData);        assertClose("get row", m.getRow(0), testDataRow1, entryTolerance);        assertClose("get col", m.getColumn(2), testDataCol3, entryTolerance);        try {            m.getRow(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }        try {            m.getColumn(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }    }    public void testGetEntry() {        RealMatrix m = createSparseMatrix(testData);        assertEquals("get entry", m.getEntry(0, 1), 2d, entryTolerance);        try {            m.getEntry(10, 4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    /** test examples in user guide */    public void testExamples() {        // Create a real matrix with two rows and three columns        double[][] matrixData = { { 1d, 2d, 3d }, { 2d, 5d, 3d } };        RealMatrix m = createSparseMatrix(matrixData);        // One more with three rows, two columns        double[][] matrixData2 = { { 1d, 2d }, { 2d, 5d }, { 1d, 7d } };        RealMatrix n = createSparseMatrix(matrixData2);        // Now multiply m by n        RealMatrix p = m.multiply(n);        assertEquals(2, p.getRowDimension());        assertEquals(2, p.getColumnDimension());        // Invert p        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();         assertEquals(2, pInverse.getRowDimension());        assertEquals(2, pInverse.getColumnDimension());        // Solve example        double[][] coefficientsData = { { 2, 3, -2 }, { -1, 7, 6 },                { 4, -3, -5 } };        RealMatrix coefficients = createSparseMatrix(coefficientsData);        double[] constants = { 1, -2, 1 };        double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);        assertEquals(2 * solution[0] + 3 * solution[1] - 2 * solution[2],                constants[0], 1E-12);        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2],                constants[1], 1E-12);        assertEquals(4 * solution[0] - 3 * solution[1] - 5 * solution[2],                constants[2], 1E-12);    }    // test submatrix accessors    public void testSubMatrix() {        RealMatrix m = createSparseMatrix(subTestData);        RealMatrix mRows23Cols00 = createSparseMatrix(subRows23Cols00);        RealMatrix mRows00Cols33 = createSparseMatrix(subRows00Cols33);        RealMatrix mRows01Cols23 = createSparseMatrix(subRows01Cols23);        RealMatrix mRows02Cols13 = createSparseMatrix(subRows02Cols13);        RealMatrix mRows03Cols12 = createSparseMatrix(subRows03Cols12);        RealMatrix mRows03Cols123 = createSparseMatrix(subRows03Cols123);        RealMatrix mRows20Cols123 = createSparseMatrix(subRows20Cols123);        RealMatrix mRows31Cols31 = createSparseMatrix(subRows31Cols31);        assertEquals("Rows23Cols00", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));        assertEquals("Rows00Cols33", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));        assertEquals("Rows01Cols23", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));        assertEquals("Rows02Cols13", mRows02Cols13,             m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 }));        assertEquals("Rows03Cols12", mRows03Cols12,             m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 }));        assertEquals("Rows03Cols123", mRows03Cols123,             m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 }));        assertEquals("Rows20Cols123", mRows20Cols123,             m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 }));        assertEquals("Rows31Cols31", mRows31Cols31,             m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));        assertEquals("Rows31Cols31", mRows31Cols31,             m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));        try {            m.getSubMatrix(1, 0, 2, 4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(-1, 1, 2, 2);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(1, 0, 2, 2);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(1, 0, 2, 4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(new int[] {}, new int[] { 0 });            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(new int[] { 0 }, new int[] { 4 });            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetRowMatrix() {        RealMatrix m = createSparseMatrix(subTestData);        RealMatrix mRow0 = createSparseMatrix(subRow0);        RealMatrix mRow3 = createSparseMatrix(subRow3);        assertEquals("Row0", mRow0, m.getRowMatrix(0));        assertEquals("Row3", mRow3, m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetColumnMatrix() {        RealMatrix m = createSparseMatrix(subTestData);        RealMatrix mColumn1 = createSparseMatrix(subColumn1);        RealMatrix mColumn3 = createSparseMatrix(subColumn3);        assertEquals("Column1", mColumn1, m.getColumnMatrix(1));        assertEquals("Column3", mColumn3, m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetRowVector() {        RealMatrix m = createSparseMatrix(subTestData);        RealVector mRow0 = new ArrayRealVector(subRow0[0]);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        assertEquals("Row0", mRow0, m.getRowVector(0));        assertEquals("Row3", mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetColumnVector() {        RealMatrix m = createSparseMatrix(subTestData);        RealVector mColumn1 = columnToVector(subColumn1);        RealVector mColumn3 = columnToVector(subColumn3);        assertEquals("Column1", mColumn1, m.getColumnVector(1));        assertEquals("Column3", mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    private RealVector columnToVector(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayRealVector(data, false);    }    public void testEqualsAndHashCode() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix m1 = (OpenMapRealMatrix) m.copy();        OpenMapRealMatrix mt = (OpenMapRealMatrix) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(createSparseMatrix(bigSingular)));    }    public void testToString() {        OpenMapRealMatrix m = createSparseMatrix(testData);        assertEquals("OpenMapRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",             m.toString());        m = new OpenMapRealMatrix(1, 1);        assertEquals("OpenMapRealMatrix{{0.0}}", m.toString());    }    public void testSetSubMatrix() throws Exception {        OpenMapRealMatrix m = createSparseMatrix(testData);        m.setSubMatrix(detData2, 1, 1);        RealMatrix expected = createSparseMatrix(new double[][] {                { 1.0, 2.0, 3.0 }, { 2.0, 1.0, 3.0 }, { 1.0, 2.0, 4.0 } });        assertEquals(expected, m);        m.setSubMatrix(detData2, 0, 0);        expected = createSparseMatrix(new double[][] {                { 1.0, 3.0, 3.0 }, { 2.0, 4.0, 3.0 }, { 1.0, 2.0, 4.0 } });        assertEquals(expected, m);        m.setSubMatrix(testDataPlus2, 0, 0);        expected = createSparseMatrix(new double[][] {                { 3.0, 4.0, 5.0 }, { 4.0, 7.0, 5.0 }, { 3.0, 2.0, 10.0 } });        assertEquals(expected, m);        // javadoc example        OpenMapRealMatrix matrix =             createSparseMatrix(new double[][] {         { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 0, 1, 2 } });        matrix.setSubMatrix(new double[][] { { 3, 4 }, { 5, 6 } }, 1, 1);        expected = createSparseMatrix(new double[][] {                { 1, 2, 3, 4 }, { 5, 3, 4, 8 }, { 9, 5, 6, 2 } });        assertEquals(expected, matrix);        // dimension overflow        try {            m.setSubMatrix(testData, 1, 1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // dimension underflow        try {            m.setSubMatrix(testData, -1, 1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        try {            m.setSubMatrix(testData, 1, -1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // null        try {            m.setSubMatrix(null, 1, 1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }        try {            new OpenMapRealMatrix(0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }        // ragged        try {            m.setSubMatrix(new double[][] { { 1 }, { 2, 3 } }, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }        // empty        try {            m.setSubMatrix(new double[][] { {} }, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }    }    public void testSerial()  {        OpenMapRealMatrix m = createSparseMatrix(testData);        assertEquals(m,TestUtils.serializeAndRecover(m));    }    // --------------- -----------------Protected methods    /** verifies that two matrices are close (1-norm) */    protected void assertClose(String msg, RealMatrix m, RealMatrix n,            double tolerance) {        assertTrue(msg, m.subtract(n).getNorm() < tolerance);    }    /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, double[] m, double[] n,            double tolerance) {        if (m.length != n.length) {            fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " + i + " elements differ", m[i], n[i],                    tolerance);        }    }        private OpenMapRealMatrix createSparseMatrix(double[][] data) {        OpenMapRealMatrix matrix = new OpenMapRealMatrix(data.length, data[0].length);        for (int row = 0; row < data.length; row++) {            for (int col = 0; col < data[row].length; col++) {                matrix.setEntry(row, col, data[row][col]);            }        }        return matrix;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.linear.DecompositionSolver;import org.apache.commons.math.linear.InvalidMatrixException;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.ArrayRealVector;import org.apache.commons.math.linear.SingularValueDecompositionImpl;public class SingularValueSolverTest extends TestCase {    private double[][] testSquare = {            { 24.0 / 25.0, 43.0 / 25.0 },            { 57.0 / 25.0, 24.0 / 25.0 }    };    private static final double normTolerance = 10e-14;    public SingularValueSolverTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SingularValueSolverTest.class);        suite.setName("SingularValueSolver Tests");        return suite;    }    /** test solve dimension errors */    public void testSolveDimensionErrors() {        DecompositionSolver solver =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);        try {            solver.solve(b);            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumn(0));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test solve singularity errors */    public void testSolveSingularityErrors() {        RealMatrix m =            MatrixUtils.createRealMatrix(new double[][] {                                   { 1.0, 0.0 },                                   { 0.0, 0.0 }                               });        DecompositionSolver solver = new SingularValueDecompositionImpl(m).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);        try {            solver.solve(b);            fail("an exception should have been thrown");        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumn(0));            fail("an exception should have been thrown");        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumnVector(0));            fail("an exception should have been thrown");        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));            fail("an exception should have been thrown");        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test solve */    public void testSolve() {        DecompositionSolver solver =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                { 1, 2, 3 }, { 0, -5, 1 }        });        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                { -8.0 / 25.0, -263.0 / 75.0, -29.0 / 75.0 },                { 19.0 / 25.0,   78.0 / 25.0,  49.0 / 25.0 }        });        // using RealMatrix        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), normTolerance);        // using double[]        for (int i = 0; i < b.getColumnDimension(); ++i) {            assertEquals(0,                         new ArrayRealVector(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }        // using Array2DRowRealMatrix        for (int i = 0; i < b.getColumnDimension(); ++i) {            assertEquals(0,                         solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }        // using RealMatrix with an alternate implementation        for (int i = 0; i < b.getColumnDimension(); ++i) {            ArrayRealVectorTest.RealVectorTestImpl v =                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));            assertEquals(0,                         solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }    }    /** test condition number */    public void testConditionNumber() {        SingularValueDecompositionImpl svd =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));        assertEquals(3.0, svd.getConditionNumber(), 1.0e-15);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.io.Serializable;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;/** * Test cases for the {@link OpenMapRealVector} class. * * @version $Revision: 728186 $ $Date$ */public class SparseRealVectorTest extends TestCase {    //     protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};    protected double[] vec1 = {1d, 2d, 3d};    protected double[] vec2 = {4d, 5d, 6d};    protected double[] vec3 = {7d, 8d, 9d};    protected double[] vec4 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};    protected double[] vec_null = {0d, 0d, 0d};    protected Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};    protected double[][] mat1 = {{1d, 2d, 3d}, {4d, 5d, 6d},{ 7d, 8d, 9d}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    // Testclass to test the RealVector interface     // only with enough content to support the test    public static class SparseRealVectorTestImpl implements RealVector, Serializable {        /** Serializable version identifier. */        private static final long serialVersionUID = 4715341047369582908L;        /** Entries of the vector. */        protected double data[];        public SparseRealVectorTestImpl(double[] d) {            data = d.clone();        }        private UnsupportedOperationException unsupported() {            return new UnsupportedOperationException("Not supported, unneeded for test purposes");        }        public RealVector copy() {            throw unsupported();        }        public RealVector add(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector add(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector subtract(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector subtract(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector mapAdd(double d) {            throw unsupported();        }        public RealVector mapAddToSelf(double d) {            throw unsupported();        }        public RealVector mapSubtract(double d) {            throw unsupported();        }        public RealVector mapSubtractToSelf(double d) {            throw unsupported();        }        public RealVector mapMultiply(double d) {            double[] out = new double[data.length];            for (int i = 0; i < data.length; i++) {                out[i] = data[i] * d;            }            return new OpenMapRealVector(out);        }        public RealVector mapMultiplyToSelf(double d) {            throw unsupported();        }        public RealVector mapDivide(double d) {            throw unsupported();        }        public RealVector mapDivideToSelf(double d) {            throw unsupported();        }        public RealVector mapPow(double d) {            throw unsupported();        }        public RealVector mapPowToSelf(double d) {            throw unsupported();        }        public RealVector mapExp() {            throw unsupported();        }        public RealVector mapExpToSelf() {            throw unsupported();        }        public RealVector mapExpm1() {            throw unsupported();        }        public RealVector mapExpm1ToSelf() {            throw unsupported();        }        public RealVector mapLog() {            throw unsupported();        }        public RealVector mapLogToSelf() {            throw unsupported();        }        public RealVector mapLog10() {            throw unsupported();        }        public RealVector mapLog10ToSelf() {            throw unsupported();        }        public RealVector mapLog1p() {            throw unsupported();        }        public RealVector mapLog1pToSelf() {            throw unsupported();        }        public RealVector mapCosh() {            throw unsupported();        }        public RealVector mapCoshToSelf() {            throw unsupported();        }        public RealVector mapSinh() {            throw unsupported();        }        public RealVector mapSinhToSelf() {            throw unsupported();        }        public RealVector mapTanh() {            throw unsupported();        }        public RealVector mapTanhToSelf() {            throw unsupported();        }        public RealVector mapCos() {            throw unsupported();        }        public RealVector mapCosToSelf() {            throw unsupported();        }        public RealVector mapSin() {            throw unsupported();        }        public RealVector mapSinToSelf() {            throw unsupported();        }        public RealVector mapTan() {            throw unsupported();        }        public RealVector mapTanToSelf() {            throw unsupported();        }        public RealVector mapAcos() {            throw unsupported();        }        public RealVector mapAcosToSelf() {            throw unsupported();        }        public RealVector mapAsin() {            throw unsupported();        }        public RealVector mapAsinToSelf() {            throw unsupported();        }        public RealVector mapAtan() {            throw unsupported();        }        public RealVector mapAtanToSelf() {            throw unsupported();        }        public RealVector mapInv() {            throw unsupported();        }        public RealVector mapInvToSelf() {            throw unsupported();        }        public RealVector mapAbs() {            throw unsupported();        }        public RealVector mapAbsToSelf() {            throw unsupported();        }        public RealVector mapSqrt() {            throw unsupported();        }        public RealVector mapSqrtToSelf() {            throw unsupported();        }        public RealVector mapCbrt() {            throw unsupported();        }        public RealVector mapCbrtToSelf() {            throw unsupported();        }        public RealVector mapCeil() {            throw unsupported();        }        public RealVector mapCeilToSelf() {            throw unsupported();        }        public RealVector mapFloor() {            throw unsupported();        }        public RealVector mapFloorToSelf() {            throw unsupported();        }        public RealVector mapRint() {            throw unsupported();        }        public RealVector mapRintToSelf() {            throw unsupported();        }        public RealVector mapSignum() {            throw unsupported();        }        public RealVector mapSignumToSelf() {            throw unsupported();        }        public RealVector mapUlp() {            throw unsupported();        }        public RealVector mapUlpToSelf() {            throw unsupported();        }        public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector ebeDivide(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public double[] getData() {            return data.clone();        }        public double dotProduct(RealVector v) throws IllegalArgumentException {            double dot = 0;            for (int i = 0; i < data.length; i++) {                dot += data[i] * v.getEntry(i);            }            return dot;        }        public double dotProduct(double[] v) throws IllegalArgumentException {            double dot = 0;            for (int i = 0; i < data.length; i++) {                dot += data[i] * v[i];            }            return dot;        }        public double getNorm() {            throw unsupported();        }        public double getL1Norm() {            throw unsupported();        }        public double getLInfNorm() {            throw unsupported();        }        public double getDistance(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public double getDistance(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public double getL1Distance(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public double getL1Distance(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public double getLInfDistance(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public double getLInfDistance(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector unitVector() {            throw unsupported();        }        public void unitize() {            throw unsupported();        }        public RealVector projection(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector projection(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public double getEntry(int index) throws MatrixIndexException {            return data[index];        }        public int getDimension() {            return data.length;        }        public RealVector append(RealVector v) {            throw unsupported();        }        public RealVector append(double d) {            throw unsupported();        }        public RealVector append(double[] a) {            throw unsupported();        }        public RealVector getSubVector(int index, int n) throws MatrixIndexException {            throw unsupported();        }        public void setEntry(int index, double value) throws MatrixIndexException {            throw unsupported();        }        public void setSubVector(int index, RealVector v) throws MatrixIndexException {            throw unsupported();        }        public void setSubVector(int index, double[] v) throws MatrixIndexException {            throw unsupported();        }        public void set(double value) {            throw unsupported();        }        public double[] toArray() {            throw unsupported();        }        public boolean isNaN() {            throw unsupported();        }        public boolean isInfinite() {            throw unsupported();        }    }    public static Test suite() {        TestSuite suite = new TestSuite(SparseRealVectorTest.class);        suite.setName("SparseRealVector Tests");        return suite;    }    public void testConstructors() {        OpenMapRealVector v0 = new OpenMapRealVector();        assertEquals("testData len", 0, v0.getDimension());        OpenMapRealVector v1 = new OpenMapRealVector(7);        assertEquals("testData len", 7, v1.getDimension());        assertEquals("testData is 0.0 ", 0.0, v1.getEntry(6));        OpenMapRealVector v3 = new OpenMapRealVector(vec1);        assertEquals("testData len", 3, v3.getDimension());        assertEquals("testData is 2.0 ", 2.0, v3.getEntry(1));        //SparseRealVector v4 = new SparseRealVector(vec4, 3, 2);        //assertEquals("testData len", 2, v4.getDimension());        //assertEquals("testData is 4.0 ", 4.0, v4.getEntry(0));        //try {        //    new SparseRealVector(vec4, 8, 3);        //    fail("IllegalArgumentException expected");        //} catch (IllegalArgumentException ex) {            // expected behavior        //} catch (Exception e) {        //    fail("wrong exception caught");        //}        RealVector v5_i = new OpenMapRealVector(dvec1);        assertEquals("testData len", 9, v5_i.getDimension());        assertEquals("testData is 9.0 ", 9.0, v5_i.getEntry(8));        OpenMapRealVector v5 = new OpenMapRealVector(dvec1);        assertEquals("testData len", 9, v5.getDimension());        assertEquals("testData is 9.0 ", 9.0, v5.getEntry(8));        OpenMapRealVector v7 = new OpenMapRealVector(v1);        assertEquals("testData len", 7, v7.getDimension());        assertEquals("testData is 0.0 ", 0.0, v7.getEntry(6));        SparseRealVectorTestImpl v7_i = new SparseRealVectorTestImpl(vec1);        OpenMapRealVector v7_2 = new OpenMapRealVector(v7_i);        assertEquals("testData len", 3, v7_2.getDimension());        assertEquals("testData is 0.0 ", 2.0d, v7_2.getEntry(1));        OpenMapRealVector v8 = new OpenMapRealVector(v1);        assertEquals("testData len", 7, v8.getDimension());        assertEquals("testData is 0.0 ", 0.0, v8.getEntry(6));    }    public void testDataInOut() {        OpenMapRealVector v1 = new OpenMapRealVector(vec1);        OpenMapRealVector v2 = new OpenMapRealVector(vec2);        OpenMapRealVector v4 = new OpenMapRealVector(vec4);        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2);         RealVector v_append_1 = v1.append(v2);        assertEquals("testData len", 6, v_append_1.getDimension());        assertEquals("testData is 4.0 ", 4.0, v_append_1.getEntry(3));        RealVector v_append_2 = v1.append(2.0);        assertEquals("testData len", 4, v_append_2.getDimension());        assertEquals("testData is 2.0 ", 2.0, v_append_2.getEntry(3));        RealVector v_append_3 = v1.append(vec2);        assertEquals("testData len", 6, v_append_3.getDimension());        assertEquals("testData is  ", 4.0, v_append_3.getEntry(3));    RealVector v_append_4 = v1.append(v2_t);        assertEquals("testData len", 6, v_append_4.getDimension());        assertEquals("testData is 4.0 ", 4.0, v_append_4.getEntry(3));                RealVector vout5 = v4.getSubVector(3, 3);        assertEquals("testData len", 3, vout5.getDimension());        assertEquals("testData is 4.0 ", 5.0, vout5.getEntry(1));        try {            v4.getSubVector(3, 7);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        OpenMapRealVector v_set1 = (OpenMapRealVector) v1.copy();        v_set1.setEntry(1, 11.0);        assertEquals("testData is 11.0 ", 11.0, v_set1.getEntry(1));        try {            v_set1.setEntry(3, 11.0);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        OpenMapRealVector v_set2 = (OpenMapRealVector) v4.copy();        v_set2.setSubVector(3, v1);        assertEquals("testData is 1.0 ", 1.0, v_set2.getEntry(3));        assertEquals("testData is 7.0 ", 7.0, v_set2.getEntry(6));        try {            v_set2.setSubVector(7, v1);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        OpenMapRealVector v_set3 = (OpenMapRealVector) v1.copy();        v_set3.set(13.0);        assertEquals("testData is 13.0 ", 13.0, v_set3.getEntry(2));        try {            v_set3.getEntry(23);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        OpenMapRealVector v_set4 = (OpenMapRealVector) v4.copy();        v_set4.setSubVector(3, v2_t);        assertEquals("testData is 1.0 ", 4.0, v_set4.getEntry(3));        assertEquals("testData is 7.0 ", 7.0, v_set4.getEntry(6));        try {            v_set4.setSubVector(7, v2_t);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testMapFunctions() {         OpenMapRealVector v1 = new OpenMapRealVector(vec1);        //octave =  v1 .+ 2.0        RealVector v_mapAdd = v1.mapAdd(2.0d);        double[] result_mapAdd = {3d, 4d, 5d};        assertClose("compare vectors" ,result_mapAdd,v_mapAdd.getData(),normTolerance);        //octave =  v1 .+ 2.0        RealVector v_mapAddToSelf = v1.copy();        v_mapAddToSelf.mapAddToSelf(2.0d);        double[] result_mapAddToSelf = {3d, 4d, 5d};        assertClose("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData(),normTolerance);        //octave =  v1 .- 2.0        RealVector v_mapSubtract = v1.mapSubtract(2.0d);        double[] result_mapSubtract = {-1d, 0d, 1d};        assertClose("compare vectors" ,result_mapSubtract,v_mapSubtract.getData(),normTolerance);        //octave =  v1 .- 2.0        RealVector v_mapSubtractToSelf = v1.copy();        v_mapSubtractToSelf.mapSubtractToSelf(2.0d);        double[] result_mapSubtractToSelf = {-1d, 0d, 1d};        assertClose("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData(),normTolerance);        //octave =  v1 .* 2.0        RealVector v_mapMultiply = v1.mapMultiply(2.0d);        double[] result_mapMultiply = {2d, 4d, 6d};        assertClose("compare vectors" ,result_mapMultiply,v_mapMultiply.getData(),normTolerance);        //octave =  v1 .* 2.0        RealVector v_mapMultiplyToSelf = v1.copy();        v_mapMultiplyToSelf.mapMultiplyToSelf(2.0d);        double[] result_mapMultiplyToSelf = {2d, 4d, 6d};        assertClose("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData(),normTolerance);        //octave =  v1 ./ 2.0        RealVector v_mapDivide = v1.mapDivide(2.0d);        double[] result_mapDivide = {.5d, 1d, 1.5d};        assertClose("compare vectors" ,result_mapDivide,v_mapDivide.getData(),normTolerance);        //octave =  v1 ./ 2.0        RealVector v_mapDivideToSelf = v1.copy();        v_mapDivideToSelf.mapDivideToSelf(2.0d);        double[] result_mapDivideToSelf = {.5d, 1d, 1.5d};        assertClose("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData(),normTolerance);        //octave =  v1 .^ 2.0        RealVector v_mapPow = v1.mapPow(2.0d);        double[] result_mapPow = {1d, 4d, 9d};        assertClose("compare vectors" ,result_mapPow,v_mapPow.getData(),normTolerance);        //octave =  v1 .^ 2.0        RealVector v_mapPowToSelf = v1.copy();        v_mapPowToSelf.mapPowToSelf(2.0d);        double[] result_mapPowToSelf = {1d, 4d, 9d};        assertClose("compare vectors" ,result_mapPowToSelf,v_mapPowToSelf.getData(),normTolerance);        //octave =  exp(v1)        RealVector v_mapExp = v1.mapExp();        double[] result_mapExp = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};        assertClose("compare vectors" ,result_mapExp,v_mapExp.getData(),normTolerance);        //octave =  exp(v1)        RealVector v_mapExpToSelf = v1.copy();        v_mapExpToSelf.mapExpToSelf();        double[] result_mapExpToSelf = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};        assertClose("compare vectors" ,result_mapExpToSelf,v_mapExpToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapExpm1 = v1.mapExpm1();        double[] result_mapExpm1 = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};        assertClose("compare vectors" ,result_mapExpm1,v_mapExpm1.getData(),normTolerance);        //octave =  ???        RealVector v_mapExpm1ToSelf = v1.copy();        v_mapExpm1ToSelf.mapExpm1ToSelf();        double[] result_mapExpm1ToSelf = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};        assertClose("compare vectors" ,result_mapExpm1ToSelf,v_mapExpm1ToSelf.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLog = v1.mapLog();        double[] result_mapLog = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};        assertClose("compare vectors" ,result_mapLog,v_mapLog.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLogToSelf = v1.copy();        v_mapLogToSelf.mapLogToSelf();        double[] result_mapLogToSelf = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};        assertClose("compare vectors" ,result_mapLogToSelf,v_mapLogToSelf.getData(),normTolerance);        //octave =  log10(v1)        RealVector v_mapLog10 = v1.mapLog10();        double[] result_mapLog10 = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};        assertClose("compare vectors" ,result_mapLog10,v_mapLog10.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLog10ToSelf = v1.copy();        v_mapLog10ToSelf.mapLog10ToSelf();        double[] result_mapLog10ToSelf = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};        assertClose("compare vectors" ,result_mapLog10ToSelf,v_mapLog10ToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapLog1p = v1.mapLog1p();        double[] result_mapLog1p = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};        assertClose("compare vectors" ,result_mapLog1p,v_mapLog1p.getData(),normTolerance);        //octave =  ???        RealVector v_mapLog1pToSelf = v1.copy();        v_mapLog1pToSelf.mapLog1pToSelf();        double[] result_mapLog1pToSelf = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};        assertClose("compare vectors" ,result_mapLog1pToSelf,v_mapLog1pToSelf.getData(),normTolerance);        //octave =  cosh(v1)        RealVector v_mapCosh = v1.mapCosh();        double[] result_mapCosh = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};        assertClose("compare vectors" ,result_mapCosh,v_mapCosh.getData(),normTolerance);        //octave =  cosh(v1)        RealVector v_mapCoshToSelf = v1.copy();        v_mapCoshToSelf.mapCoshToSelf();        double[] result_mapCoshToSelf = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};        assertClose("compare vectors" ,result_mapCoshToSelf,v_mapCoshToSelf.getData(),normTolerance);        //octave =  sinh(v1)        RealVector v_mapSinh = v1.mapSinh();        double[] result_mapSinh = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};        assertClose("compare vectors" ,result_mapSinh,v_mapSinh.getData(),normTolerance);        //octave =  sinh(v1)        RealVector v_mapSinhToSelf = v1.copy();        v_mapSinhToSelf.mapSinhToSelf();        double[] result_mapSinhToSelf = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};        assertClose("compare vectors" ,result_mapSinhToSelf,v_mapSinhToSelf.getData(),normTolerance);        //octave =  tanh(v1)        RealVector v_mapTanh = v1.mapTanh();        double[] result_mapTanh = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};        assertClose("compare vectors" ,result_mapTanh,v_mapTanh.getData(),normTolerance);        //octave =  tanh(v1)        RealVector v_mapTanhToSelf = v1.copy();        v_mapTanhToSelf.mapTanhToSelf();        double[] result_mapTanhToSelf = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};        assertClose("compare vectors" ,result_mapTanhToSelf,v_mapTanhToSelf.getData(),normTolerance);        //octave =  cos(v1)        RealVector v_mapCos = v1.mapCos();        double[] result_mapCos = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};        assertClose("compare vectors" ,result_mapCos,v_mapCos.getData(),normTolerance);        //octave =  cos(v1)        RealVector v_mapCosToSelf = v1.copy();        v_mapCosToSelf.mapCosToSelf();        double[] result_mapCosToSelf = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};        assertClose("compare vectors" ,result_mapCosToSelf,v_mapCosToSelf.getData(),normTolerance);        //octave =  sin(v1)        RealVector v_mapSin = v1.mapSin();        double[] result_mapSin = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};        assertClose("compare vectors" ,result_mapSin,v_mapSin.getData(),normTolerance);        //octave =  sin(v1)        RealVector v_mapSinToSelf = v1.copy();        v_mapSinToSelf.mapSinToSelf();        double[] result_mapSinToSelf = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};        assertClose("compare vectors" ,result_mapSinToSelf,v_mapSinToSelf.getData(),normTolerance);        //octave =  tan(v1)        RealVector v_mapTan = v1.mapTan();        double[] result_mapTan = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};        assertClose("compare vectors" ,result_mapTan,v_mapTan.getData(),normTolerance);        //octave =  tan(v1)        RealVector v_mapTanToSelf = v1.copy();        v_mapTanToSelf.mapTanToSelf();        double[] result_mapTanToSelf = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};        assertClose("compare vectors" ,result_mapTanToSelf,v_mapTanToSelf.getData(),normTolerance);        double[] vat_a = {0d, 0.5d, 1.0d};        OpenMapRealVector vat = new OpenMapRealVector(vat_a);        //octave =  acos(vat)        RealVector v_mapAcos = vat.mapAcos();        double[] result_mapAcos = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};        assertClose("compare vectors" ,result_mapAcos,v_mapAcos.getData(),normTolerance);        //octave =  acos(vat)        RealVector v_mapAcosToSelf = vat.copy();        v_mapAcosToSelf.mapAcosToSelf();        double[] result_mapAcosToSelf = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};        assertClose("compare vectors" ,result_mapAcosToSelf,v_mapAcosToSelf.getData(),normTolerance);        //octave =  asin(vat)        RealVector v_mapAsin = vat.mapAsin();        double[] result_mapAsin = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};        assertClose("compare vectors" ,result_mapAsin,v_mapAsin.getData(),normTolerance);        //octave =  asin(vat)        RealVector v_mapAsinToSelf = vat.copy();        v_mapAsinToSelf.mapAsinToSelf();                double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};        assertClose("compare vectors" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);        //octave =  atan(vat)        RealVector v_mapAtan = vat.mapAtan();        double[] result_mapAtan = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};        assertClose("compare vectors" ,result_mapAtan,v_mapAtan.getData(),normTolerance);        //octave =  atan(vat)        RealVector v_mapAtanToSelf = vat.copy();        v_mapAtanToSelf.mapAtanToSelf();        double[] result_mapAtanToSelf = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};        assertClose("compare vectors" ,result_mapAtanToSelf,v_mapAtanToSelf.getData(),normTolerance);        //octave =  v1 .^-1        RealVector v_mapInv = v1.mapInv();        double[] result_mapInv = {1d,0.5d,3.333333333333333e-01d};        assertClose("compare vectors" ,result_mapInv,v_mapInv.getData(),normTolerance);        //octave =  v1 .^-1        RealVector v_mapInvToSelf = v1.copy();        v_mapInvToSelf.mapInvToSelf();        double[] result_mapInvToSelf = {1d,0.5d,3.333333333333333e-01d};        assertClose("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData(),normTolerance);        double[] abs_a = {-1.0d, 0.0d, 1.0d};        OpenMapRealVector abs_v = new OpenMapRealVector(abs_a);        //octave =  abs(abs_v)        RealVector v_mapAbs = abs_v.mapAbs();        double[] result_mapAbs = {1d,0d,1d};        assertClose("compare vectors" ,result_mapAbs,v_mapAbs.getData(),normTolerance);        //octave = abs(abs_v)        RealVector v_mapAbsToSelf = abs_v.copy();        v_mapAbsToSelf.mapAbsToSelf();        double[] result_mapAbsToSelf = {1d,0d,1d};        assertClose("compare vectors" ,result_mapAbsToSelf,v_mapAbsToSelf.getData(),normTolerance);        //octave =   sqrt(v1)        RealVector v_mapSqrt = v1.mapSqrt();        double[] result_mapSqrt = {1d,1.414213562373095e+00d,1.732050807568877e+00d};        assertClose("compare vectors" ,result_mapSqrt,v_mapSqrt.getData(),normTolerance);        //octave =  sqrt(v1)        RealVector v_mapSqrtToSelf = v1.copy();        v_mapSqrtToSelf.mapSqrtToSelf();        double[] result_mapSqrtToSelf = {1d,1.414213562373095e+00d,1.732050807568877e+00d};        assertClose("compare vectors" ,result_mapSqrtToSelf,v_mapSqrtToSelf.getData(),normTolerance);        double[] cbrt_a = {-2.0d, 0.0d, 2.0d};        OpenMapRealVector cbrt_v = new OpenMapRealVector(cbrt_a);        //octave =  ???        RealVector v_mapCbrt = cbrt_v.mapCbrt();        double[] result_mapCbrt = {-1.2599210498948732d,0d,1.2599210498948732d};        assertClose("compare vectors" ,result_mapCbrt,v_mapCbrt.getData(),normTolerance);        //octave = ???        RealVector v_mapCbrtToSelf = cbrt_v.copy();        v_mapCbrtToSelf.mapCbrtToSelf();        double[] result_mapCbrtToSelf =  {-1.2599210498948732d,0d,1.2599210498948732d};        assertClose("compare vectors" ,result_mapCbrtToSelf,v_mapCbrtToSelf.getData(),normTolerance);        double[] ceil_a = {-1.1d, 0.9d, 1.1d};        OpenMapRealVector ceil_v = new OpenMapRealVector(ceil_a);        //octave =  ceil(ceil_v)        RealVector v_mapCeil = ceil_v.mapCeil();        double[] result_mapCeil = {-1d,1d,2d};        assertClose("compare vectors" ,result_mapCeil,v_mapCeil.getData(),normTolerance);        //octave = ceil(ceil_v)        RealVector v_mapCeilToSelf = ceil_v.copy();        v_mapCeilToSelf.mapCeilToSelf();        double[] result_mapCeilToSelf =  {-1d,1d,2d};        assertClose("compare vectors" ,result_mapCeilToSelf,v_mapCeilToSelf.getData(),normTolerance);        //octave =  floor(ceil_v)        RealVector v_mapFloor = ceil_v.mapFloor();        double[] result_mapFloor = {-2d,0d,1d};        assertClose("compare vectors" ,result_mapFloor,v_mapFloor.getData(),normTolerance);        //octave = floor(ceil_v)        RealVector v_mapFloorToSelf = ceil_v.copy();        v_mapFloorToSelf.mapFloorToSelf();        double[] result_mapFloorToSelf =  {-2d,0d,1d};        assertClose("compare vectors" ,result_mapFloorToSelf,v_mapFloorToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapRint = ceil_v.mapRint();        double[] result_mapRint = {-1d,1d,1d};        assertClose("compare vectors" ,result_mapRint,v_mapRint.getData(),normTolerance);        //octave = ???        RealVector v_mapRintToSelf = ceil_v.copy();        v_mapRintToSelf.mapRintToSelf();        double[] result_mapRintToSelf =  {-1d,1d,1d};        assertClose("compare vectors" ,result_mapRintToSelf,v_mapRintToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapSignum = ceil_v.mapSignum();        double[] result_mapSignum = {-1d,1d,1d};        assertClose("compare vectors" ,result_mapSignum,v_mapSignum.getData(),normTolerance);        //octave = ???        RealVector v_mapSignumToSelf = ceil_v.copy();        v_mapSignumToSelf.mapSignumToSelf();        double[] result_mapSignumToSelf =  {-1d,1d,1d};        assertClose("compare vectors" ,result_mapSignumToSelf,v_mapSignumToSelf.getData(),normTolerance);        // Is with the used resolutions of limited value as test        //octave =  ???        RealVector v_mapUlp = ceil_v.mapUlp();        double[] result_mapUlp = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};        assertClose("compare vectors" ,result_mapUlp,v_mapUlp.getData(),normTolerance);        //octave = ???        RealVector v_mapUlpToSelf = ceil_v.copy();        v_mapUlpToSelf.mapUlpToSelf();        double[] result_mapUlpToSelf = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};        assertClose("compare vectors" ,result_mapUlpToSelf,v_mapUlpToSelf.getData(),normTolerance);    }    public void testBasicFunctions() {         OpenMapRealVector v1 = new OpenMapRealVector(vec1);        OpenMapRealVector v2 = new OpenMapRealVector(vec2);        OpenMapRealVector v_null = new OpenMapRealVector(vec_null);        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2);         //octave =  sqrt(sumsq(v1))        double d_getNorm = v1.getNorm();        assertEquals("compare values  ", 3.7416573867739413,d_getNorm);        double d_getL1Norm = v1.getL1Norm();        assertEquals("compare values  ",6.0, d_getL1Norm);        double d_getLInfNorm = v1.getLInfNorm();        assertEquals("compare values  ",6.0, d_getLInfNorm);        //octave =  sqrt(sumsq(v1-v2))        double dist = v1.getDistance(v2);        assertEquals("compare values  ",v1.subtract(v2).getNorm(), dist );        //octave =  sqrt(sumsq(v1-v2))        double dist_2 = v1.getDistance(v2_t);        assertEquals("compare values  ", v1.subtract(v2).getNorm(),dist_2 );        //octave =  ???        double d_getL1Distance = v1. getL1Distance(v2);        assertEquals("compare values  ",9d, d_getL1Distance );        double d_getL1Distance_2 = v1. getL1Distance(v2_t);        assertEquals("compare values  ",9d, d_getL1Distance_2 );        //octave =  ???        double d_getLInfDistance = v1. getLInfDistance(v2);        assertEquals("compare values  ",3d, d_getLInfDistance );        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);        assertEquals("compare values  ",3d, d_getLInfDistance_2 );        //octave =  v1 + v2        OpenMapRealVector v_add = v1.add(v2);        double[] result_add = {5d, 7d, 9d};        assertClose("compare vect" ,v_add.getData(),result_add,normTolerance);        SparseRealVectorTestImpl vt2 = new SparseRealVectorTestImpl(vec2);        RealVector v_add_i = v1.add(vt2);        double[] result_add_i = {5d, 7d, 9d};        assertClose("compare vect" ,v_add_i.getData(),result_add_i,normTolerance);        //octave =  v1 - v2        OpenMapRealVector v_subtract = v1.subtract(v2);        double[] result_subtract = {-3d, -3d, -3d};        assertClose("compare vect" ,v_subtract.getData(),result_subtract,normTolerance);        RealVector v_subtract_i = v1.subtract(vt2);        double[] result_subtract_i = {-3d, -3d, -3d};        assertClose("compare vect" ,v_subtract_i.getData(),result_subtract_i,normTolerance);        // octave v1 .* v2        RealVector  v_ebeMultiply = v1.ebeMultiply(v2);        double[] result_ebeMultiply = {4d, 10d, 18d};        assertClose("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);        double[] result_ebeMultiply_2 = {4d, 10d, 18d};        assertClose("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);        // octave v1 ./ v2        RealVector  v_ebeDivide = v1.ebeDivide(v2);        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};        assertClose("compare vect" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};        assertClose("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);        // octave  dot(v1,v2)        double dot =  v1.dotProduct(v2);        assertEquals("compare val ",32d, dot);        // octave  dot(v1,v2_t)        double dot_2 =  v1.dotProduct(v2_t);        assertEquals("compare val ",32d, dot_2);        RealMatrix m_outerProduct = v1.outerProduct(v2);        assertEquals("compare val ",4d, m_outerProduct.getEntry(0,0));        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);        assertEquals("compare val ",4d, m_outerProduct_2.getEntry(0,0));        RealVector v_unitVector = v1.unitVector();        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());         assertClose("compare vect" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);        try {            v_null.unitVector();            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        OpenMapRealVector v_unitize = (OpenMapRealVector)v1.copy();        v_unitize.unitize();        assertClose("compare vect" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);        try {            v_null.unitize();            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        RealVector v_projection = v1.projection(v2);        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};        assertClose("compare vect", v_projection.getData(), result_projection, normTolerance);        RealVector v_projection_2 = v1.projection(v2_t);        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};        assertClose("compare vect", v_projection_2.getData(), result_projection_2, normTolerance);    }      public void testMisc() {         OpenMapRealVector v1 = new OpenMapRealVector(vec1);        String out1 = v1.toString();        assertTrue("some output ",  out1.length()!=0);        try {            v1.checkVectorDimensions(2);             fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }         }    public void testPredicates() {        OpenMapRealVector v = new OpenMapRealVector(new double[] { 0, 1, 2 });        assertFalse(v.isNaN());        v.setEntry(1, Double.NaN);        assertTrue(v.isNaN());        assertFalse(v.isInfinite());        v.setEntry(0, Double.POSITIVE_INFINITY);        assertFalse(v.isInfinite()); // NaN has higher priority than infinity        v.setEntry(1, 1);        assertTrue(v.isInfinite());        v.setEntry(0, 0);        assertEquals(v, new OpenMapRealVector(new double[] { 0, 1, 2 }));        assertNotSame(v, new OpenMapRealVector(new double[] { 0, 1, 2 + Math.ulp(2)}));        assertNotSame(v, new OpenMapRealVector(new double[] { 0, 1, 2, 3 }));    }    public void testSerial()  {        OpenMapRealVector v = new OpenMapRealVector(new double[] { 0, 1, 2 });        assertEquals(v,TestUtils.serializeAndRecover(v));    }        /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, double[] m, double[] n,            double tolerance) {        if (m.length != n.length) {            fail("vectors have different lengths");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " +  i + " elements differ", m[i],n[i],tolerance);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import java.math.BigDecimal;/** * Test cases for the {@link BigMatrixImpl} class. * * @version $Revision$ $Date$ */@Deprecatedpublic final class BigMatrixImplTest extends TestCase {        // Test data for String constructors    protected  String[][] testDataString = { {"1","2","3"}, {"2","5","3"}, {"1","0","8"} };        // 3 x 3 identity matrix    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };        // Test data for group operations    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},             {-1d,0d,-8d} };    protected double[] testDataRow1 = {1d,2d,3d};    protected double[] testDataCol3 = {3d,3d,8d};    protected double[][] testDataInv =         { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };    protected double[] preMultTest = {8,12,33};    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};    protected double[][] testDataPlusInv =         { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };        // lu decomposition tests    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},            {0.33333333333333,0d,0.33333333333333} };        // singular matrices    protected double[][] singular = { {2d,3d}, {2d,3d} };    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},            {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};        // vectors    protected double[] testVector = {1,2,3};    protected double[] testVector2 = {1,2,3,4};        // submatrix accessor tests    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},            {2, 4, 6, 8}, {4, 5, 6, 7}};     // array selections    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};    // effective permutations    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};    // contiguous ranges    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};    protected double[][] subRows23Cols00 = {{2} , {4}};    protected double[][] subRows00Cols33 = {{4}};    // row matrices    protected double[][] subRow0 = {{1,2,3,4}};    protected double[][] subRow3 = {{4,5,6,7}};    // column matrices    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};        // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;        public BigMatrixImplTest(String name) {        super(name);    }        public static Test suite() {        TestSuite suite = new TestSuite(BigMatrixImplTest.class);        suite.setName("BigMatrixImpl Tests");        return suite;    }    public static final double[] asDouble(BigDecimal[] data) {        double d[] = new double[data.length];        for (int i=0;i<d.length;i++) {            d[i] = data[i].doubleValue();        }        return d;    }    public static final double[][] asDouble(BigDecimal[][] data) {        double d[][] = new double[data.length][data[0].length];        for (int i=0;i<d.length;i++) {            for (int j=0;j<d[i].length;j++)            d[i][j] = data[i][j].doubleValue();        }        return d;    }    public static final BigDecimal[] asBigDecimal(double [] data) {        BigDecimal d[] = new BigDecimal[data.length];        for (int i=0;i<d.length;i++) {            d[i] = new BigDecimal(data[i]);        }        return d;    }    public static final BigDecimal[][] asBigDecimal(double [][] data) {        BigDecimal d[][] = new BigDecimal[data.length][data[0].length];        for (int i=0;i<d.length;i++) {            for (int j=0;j<data[i].length;j++) {                d[i][j] = new BigDecimal(data[i][j]);            }        }        return d;    }    /** test dimensions */    public void testDimensions() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl m2 = new BigMatrixImpl(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());    }          /** test copy functions */    public void testCopyFunctions() {        BigMatrixImpl m1 = new BigMatrixImpl(testData);        BigMatrixImpl m2 = new BigMatrixImpl(m1.getData());        assertEquals(m2,m1);        BigMatrixImpl m3 = new BigMatrixImpl(testData);        BigMatrixImpl m4 = new BigMatrixImpl(m3.getData(), false);        assertEquals(m4,m3);    }        /** test constructors */    public void testConstructors() {        BigMatrix m1 = new BigMatrixImpl(testData);        BigMatrix m2 = new BigMatrixImpl(testDataString);        BigMatrix m3 = new BigMatrixImpl(asBigDecimal(testData));        BigMatrix m4 = new BigMatrixImpl(asBigDecimal(testData), true);        BigMatrix m5 = new BigMatrixImpl(asBigDecimal(testData), false);        assertClose("double, string", m1, m2, Double.MIN_VALUE);        assertClose("double, BigDecimal", m1, m3, Double.MIN_VALUE);        assertClose("string, BigDecimal", m2, m3, Double.MIN_VALUE);        assertClose("double, BigDecimal/true", m1, m4, Double.MIN_VALUE);        assertClose("double, BigDecimal/false", m1, m5, Double.MIN_VALUE);        try {            new BigMatrixImpl(new String[][] {{"0", "hello", "1"}});            fail("Expecting NumberFormatException");        } catch (NumberFormatException ex) {            // expected        }        try {            new BigMatrixImpl(new String[][] {});            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            new BigMatrixImpl(new String[][] {{},{}});            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            new BigMatrixImpl(new String[][] {{"a", "b"},{"c"}});            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            new BigMatrixImpl(0, 1);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            new BigMatrixImpl(1, 0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }        /** test add */    public void testAdd() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);        BigMatrix mPlusMInv = m.add(mInv);        double[][] sumEntries = asDouble(mPlusMInv.getData());        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                    testDataPlusInv[row][col],sumEntries[row][col],                        entryTolerance);            }        }        }        /** test add failure */    public void testAddFail() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl m2 = new BigMatrixImpl(testData2);        try {            m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }    }        /** test norm */    public void testNorm() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl m2 = new BigMatrixImpl(testData2);        assertEquals("testData norm",14d,m.getNorm().doubleValue(),entryTolerance);        assertEquals("testData2 norm",7d,m2.getNorm().doubleValue(),entryTolerance);    }         /** test m-n = m + -n */    public void testPlusMinus() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl m2 = new BigMatrixImpl(testDataInv);        assertClose("m-n = m + -n",m.subtract(m2),            m2.scalarMultiply(new BigDecimal(-1d)).add(m),entryTolerance);        try {            m.subtract(new BigMatrixImpl(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }       /** test multiply */     public void testMultiply() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);        BigMatrixImpl identity = new BigMatrixImpl(id);        BigMatrixImpl m2 = new BigMatrixImpl(testData2);        assertClose("inverse multiply",m.multiply(mInv),            identity,entryTolerance);        assertClose("inverse multiply",mInv.multiply(m),            identity,entryTolerance);        assertClose("identity multiply",m.multiply(identity),            m,entryTolerance);        assertClose("identity multiply",identity.multiply(mInv),            mInv,entryTolerance);        assertClose("identity multiply",m2.multiply(identity),            m2,entryTolerance);         try {            m.multiply(new BigMatrixImpl(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }           //Additional Test for BigMatrixImplTest.testMultiply    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};    private double[][] d4 = new double[][] {{1},{2},{3},{4}};    private double[][] d5 = new double[][] {{30},{70}};         public void testMultiply2() {        BigMatrix m3 = new BigMatrixImpl(d3);       BigMatrix m4 = new BigMatrixImpl(d4);       BigMatrix m5 = new BigMatrixImpl(d5);       assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);   }              /** test isSingular */    public void testIsSingular() {        BigMatrixImpl m = new BigMatrixImpl(singular);        assertTrue("singular",m.isSingular());        m = new BigMatrixImpl(bigSingular);        assertTrue("big singular",m.isSingular());        m = new BigMatrixImpl(id);        assertTrue("identity nonsingular",!m.isSingular());        m = new BigMatrixImpl(testData);        assertTrue("testData nonsingular",!m.isSingular());    }            /** test inverse */    public void testInverse() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrix mInv = new BigMatrixImpl(testDataInv);        assertClose("inverse",mInv,m.inverse(),normTolerance);        assertClose("inverse^2",m,m.inverse().inverse(),10E-12);                // Not square        m = new BigMatrixImpl(testData2);        try {            m.inverse();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }                // Singular        m = new BigMatrixImpl(singular);        try {            m.inverse();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        /** test solve */    public void testSolve() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrix mInv = new BigMatrixImpl(testDataInv);        // being a bit slothful here -- actually testing that X = A^-1 * B        assertClose("inverse-operate",                    asDouble(mInv.operate(asBigDecimal(testVector))),                    asDouble(m.solve(asBigDecimal(testVector))),                    normTolerance);        try {            asDouble(m.solve(asBigDecimal(testVector2)));            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }               BigMatrix bs = new BigMatrixImpl(bigSingular);        try {            bs.solve(bs);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // ignored        }        try {            m.solve(bs);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            new BigMatrixImpl(testData2).solve(bs);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }         try {            (new BigMatrixImpl(testData2)).luDecompose();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // ignored        }      }        /** test determinant */    public void testDeterminant() {               BigMatrix m = new BigMatrixImpl(bigSingular);        assertEquals("singular determinant",0,m.getDeterminant().doubleValue(),0);        m = new BigMatrixImpl(detData);        assertEquals("nonsingular test",-3d,m.getDeterminant().doubleValue(),normTolerance);                // Examples verified against R (version 1.8.1, Red Hat Linux 9)        m = new BigMatrixImpl(detData2);        assertEquals("nonsingular R test 1",-2d,m.getDeterminant().doubleValue(),normTolerance);        m = new BigMatrixImpl(testData);        assertEquals("nonsingular  R test 2",-1d,m.getDeterminant().doubleValue(),normTolerance);        try {            new BigMatrixImpl(testData2).getDeterminant().doubleValue();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // ignored        }          }        /** test trace */    public void testTrace() {        BigMatrix m = new BigMatrixImpl(id);        assertEquals("identity trace",3d,m.getTrace().doubleValue(),entryTolerance);        m = new BigMatrixImpl(testData2);        try {            m.getTrace().doubleValue();            fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }          }        /** test sclarAdd */    public void testScalarAdd() {        BigMatrix m = new BigMatrixImpl(testData);        assertClose("scalar add",new BigMatrixImpl(testDataPlus2),            m.scalarAdd(new BigDecimal(2d)),entryTolerance);    }                        /** test operate */    public void testOperate() {        BigMatrix m = new BigMatrixImpl(id);        double[] x = asDouble(m.operate(asBigDecimal(testVector)));        assertClose("identity operate",testVector,x,entryTolerance);        m = new BigMatrixImpl(bigSingular);        try {            asDouble(m.operate(asBigDecimal(testVector)));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }    /** test issue MATH-209 */    public void testMath209() {        BigMatrix a = new BigMatrixImpl(new BigDecimal[][] {                { new BigDecimal(1), new BigDecimal(2) },                { new BigDecimal(3), new BigDecimal(4) },                { new BigDecimal(5), new BigDecimal(6) }        }, false);        BigDecimal[] b = a.operate(new BigDecimal[] { new BigDecimal(1), new BigDecimal(1) });        assertEquals(a.getRowDimension(), b.length);        assertEquals( 3.0, b[0].doubleValue(), 1.0e-12);        assertEquals( 7.0, b[1].doubleValue(), 1.0e-12);        assertEquals(11.0, b[2].doubleValue(), 1.0e-12);    }        /** test transpose */    public void testTranspose() {        BigMatrix m = new BigMatrixImpl(testData);        assertClose("inverse-transpose",m.inverse().transpose(),            m.transpose().inverse(),normTolerance);        m = new BigMatrixImpl(testData2);        BigMatrix mt = new BigMatrixImpl(testData2T);        assertClose("transpose",mt,m.transpose(),normTolerance);    }        /** test preMultiply by vector */    public void testPremultiplyVector() {        BigMatrix m = new BigMatrixImpl(testData);        assertClose("premultiply",asDouble(m.preMultiply(asBigDecimal(testVector))),preMultTest,normTolerance);        m = new BigMatrixImpl(bigSingular);        try {            m.preMultiply(asBigDecimal(testVector));            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }        public void testPremultiply() {        BigMatrix m3 = new BigMatrixImpl(d3);        BigMatrix m4 = new BigMatrixImpl(d4);        BigMatrix m5 = new BigMatrixImpl(d5);        assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);                BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);        BigMatrixImpl identity = new BigMatrixImpl(id);        new BigMatrixImpl(testData2);        assertClose("inverse multiply",m.preMultiply(mInv),                identity,entryTolerance);        assertClose("inverse multiply",mInv.preMultiply(m),                identity,entryTolerance);        assertClose("identity multiply",m.preMultiply(identity),                m,entryTolerance);        assertClose("identity multiply",identity.preMultiply(mInv),                mInv,entryTolerance);        try {            m.preMultiply(new BigMatrixImpl(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }        public void testGetVectors() {        BigMatrix m = new BigMatrixImpl(testData);        assertClose("get row",m.getRowAsDoubleArray(0),testDataRow1,entryTolerance);        assertClose("get col",m.getColumnAsDoubleArray(2),testDataCol3,entryTolerance);        try {            m.getRowAsDoubleArray(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }        try {            m.getColumnAsDoubleArray(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }    }          public void testLUDecomposition() throws Exception {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrix lu = m.getLUMatrix();        assertClose("LU decomposition", lu, new BigMatrixImpl(testDataLU), normTolerance);        verifyDecomposition(m, lu);        m = new BigMatrixImpl(luData);        lu = m.getLUMatrix();        assertClose("LU decomposition", lu, new BigMatrixImpl(luDataLUDecomposition), normTolerance);        verifyDecomposition(m, lu);        m = new BigMatrixImpl(testDataMinus);        lu = m.getLUMatrix();        verifyDecomposition(m, lu);        m = new BigMatrixImpl(id);        lu = m.getLUMatrix();        verifyDecomposition(m, lu);        try {            m = new BigMatrixImpl(bigSingular); // singular            lu = m.getLUMatrix();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }        try {            m = new BigMatrixImpl(testData2);  // not square            lu = m.getLUMatrix();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }       /**    * test submatrix accessors    */    public void testSubMatrix() {        BigMatrix m = new BigMatrixImpl(subTestData);        BigMatrix mRows23Cols00 = new BigMatrixImpl(subRows23Cols00);        BigMatrix mRows00Cols33 = new BigMatrixImpl(subRows00Cols33);        BigMatrix mRows01Cols23 = new BigMatrixImpl(subRows01Cols23);        BigMatrix mRows02Cols13 = new BigMatrixImpl(subRows02Cols13);        BigMatrix mRows03Cols12 = new BigMatrixImpl(subRows03Cols12);        BigMatrix mRows03Cols123 = new BigMatrixImpl(subRows03Cols123);        BigMatrix mRows20Cols123 = new BigMatrixImpl(subRows20Cols123);        BigMatrix mRows31Cols31 = new BigMatrixImpl(subRows31Cols31);        assertEquals("Rows23Cols00", mRows23Cols00,                 m.getSubMatrix(2 , 3 , 0, 0));        assertEquals("Rows00Cols33", mRows00Cols33,                 m.getSubMatrix(0 , 0 , 3, 3));        assertEquals("Rows01Cols23", mRows01Cols23,                m.getSubMatrix(0 , 1 , 2, 3));           assertEquals("Rows02Cols13", mRows02Cols13,                m.getSubMatrix(new int[] {0,2}, new int[] {1,3}));          assertEquals("Rows03Cols12", mRows03Cols12,                m.getSubMatrix(new int[] {0,3}, new int[] {1,2}));          assertEquals("Rows03Cols123", mRows03Cols123,                m.getSubMatrix(new int[] {0,3}, new int[] {1,2,3}));         assertEquals("Rows20Cols123", mRows20Cols123,                m.getSubMatrix(new int[] {2,0}, new int[] {1,2,3}));         assertEquals("Rows31Cols31", mRows31Cols31,                m.getSubMatrix(new int[] {3,1}, new int[] {3,1}));         assertEquals("Rows31Cols31", mRows31Cols31,                m.getSubMatrix(new int[] {3,1}, new int[] {3,1}));                 try {            m.getSubMatrix(1,0,2,4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(-1,1,2,2);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(1,0,2,2);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(1,0,2,4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(new int[] {}, new int[] {0});            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(new int[] {0}, new int[] {4});            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }        public void testGetColumnMatrix() {        BigMatrix m = new BigMatrixImpl(subTestData);        BigMatrix mColumn1 = new BigMatrixImpl(subColumn1);        BigMatrix mColumn3 = new BigMatrixImpl(subColumn3);        assertEquals("Column1", mColumn1,                 m.getColumnMatrix(1));        assertEquals("Column3", mColumn3,                 m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }        public void testGetRowMatrix() {        BigMatrix m = new BigMatrixImpl(subTestData);        BigMatrix mRow0 = new BigMatrixImpl(subRow0);        BigMatrix mRow3 = new BigMatrixImpl(subRow3);        assertEquals("Row0", mRow0,                 m.getRowMatrix(0));        assertEquals("Row3", mRow3,                 m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }        public void testEqualsAndHashCode() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl m1 = (BigMatrixImpl) m.copy();        BigMatrixImpl mt = (BigMatrixImpl) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(new BigMatrixImpl(bigSingular)));        // Different scales make BigDecimals, so matrices unequal        m = new BigMatrixImpl(new String[][] {{"2.0"}});        m1 = new BigMatrixImpl(new String[][] {{"2.00"}});        assertTrue(m.hashCode() != m1.hashCode());        assertFalse(m.equals(m1));    }        public void testToString() {        BigMatrixImpl m = new BigMatrixImpl(testData);        assertEquals("BigMatrixImpl{{1,2,3},{2,5,3},{1,0,8}}",                m.toString());        m = new BigMatrixImpl();        assertEquals("BigMatrixImpl{}",                m.toString());    }        public void testSetSubMatrix() throws Exception {        BigDecimal[][] detData3 =             MatrixUtils.createBigMatrix(detData2).getData();        BigMatrixImpl m = new BigMatrixImpl(testData);        m.setSubMatrix(detData3,1,1);        BigMatrix expected = MatrixUtils.createBigMatrix            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);                  m.setSubMatrix(detData3,0,0);        expected = MatrixUtils.createBigMatrix            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);                  BigDecimal[][] testDataPlus3 =             MatrixUtils.createBigMatrix(testDataPlus2).getData();        m.setSubMatrix(testDataPlus3,0,0);              expected = MatrixUtils.createBigMatrix        (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});        assertEquals(expected, m);                   // javadoc example        BigMatrixImpl matrix = (BigMatrixImpl) MatrixUtils.createBigMatrix            (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});        matrix.setSubMatrix(new BigDecimal[][] {{new BigDecimal(3),            new BigDecimal(4)}, {new BigDecimal(5), new BigDecimal(6)}}, 1, 1);        expected = MatrixUtils.createBigMatrix            (new BigDecimal[][] {{new BigDecimal(1), new BigDecimal(2),             new BigDecimal(3), new BigDecimal(4)}, {new BigDecimal(5),             new BigDecimal(3), new BigDecimal(4), new BigDecimal(8)},             {new BigDecimal(9), new BigDecimal(5) , new BigDecimal(6),              new BigDecimal(2)}});        assertEquals(expected, matrix);                   // dimension overflow        try {              m.setSubMatrix(matrix.getData(),1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }                // null        try {            m.setSubMatrix(null,1,1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }                // ragged        try {            m.setSubMatrix(new BigDecimal[][] {{new BigDecimal(1)},                    {new BigDecimal(2), new BigDecimal(3)}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }                // empty        try {            m.setSubMatrix(new BigDecimal[][] {{}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }            }        //--------------- -----------------Protected methods            /** verifies that two matrices are close (1-norm) */                  protected void assertClose(String msg, BigMatrix m, BigMatrix n,        double tolerance) {        assertTrue(msg,m.subtract(n).getNorm().doubleValue() < tolerance);    }        /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, double[] m, double[] n,        double tolerance) {        if (m.length != n.length) {            fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " +  i + " elements differ",                 m[i],n[i],tolerance);        }    }        /** extracts the l  and u matrices from compact lu representation */    protected void splitLU(BigMatrix lu, BigDecimal[][] lowerData, BigDecimal[][] upperData) throws InvalidMatrixException {        if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||                lowerData.length != upperData.length                || lowerData.length != lu.getRowDimension()) {            throw new InvalidMatrixException("incorrect dimensions");        }            int n = lu.getRowDimension();        for (int i = 0; i < n; i++) {            for (int j = 0; j < n; j++) {                if (j < i) {                    lowerData[i][j] = lu.getEntry(i, j);                    upperData[i][j] = new BigDecimal(0);                } else if (i == j) {                    lowerData[i][j] = new BigDecimal(1);                    upperData[i][j] = lu.getEntry(i, j);                } else {                    lowerData[i][j] = new BigDecimal(0);                    upperData[i][j] = lu.getEntry(i, j);                }               }        }    }        /** Returns the result of applying the given row permutation to the matrix */    protected BigMatrix permuteRows(BigMatrix matrix, int[] permutation) {        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {            throw new IllegalArgumentException("dimension mismatch");        }        int n = matrix.getRowDimension();        int m = matrix.getColumnDimension();        BigDecimal out[][] = new BigDecimal[m][n];        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                out[i][j] = matrix.getEntry(permutation[i], j);            }        }        return new BigMatrixImpl(out);    }        /** Extracts l and u matrices from lu and verifies that matrix = l times u modulo permutation */    protected void verifyDecomposition(BigMatrix matrix, BigMatrix lu) throws Exception{        int n = matrix.getRowDimension();        BigDecimal[][] lowerData = new BigDecimal[n][n];        BigDecimal[][] upperData = new BigDecimal[n][n];        splitLU(lu, lowerData, upperData);        BigMatrix lower =new BigMatrixImpl(lowerData);        BigMatrix upper = new BigMatrixImpl(upperData);        int[] permutation = ((BigMatrixImpl) matrix).getPermutation();        BigMatrix permuted = permuteRows(matrix, permutation);        assertClose("lu decomposition does not work", permuted,                lower.multiply(upper), normTolerance);    }         //    /** Useful for debugging *///    private void dumpMatrix(BigMatrix m) {//          for (int i = 0; i < m.getRowDimension(); i++) {//              String os = "";//              for (int j = 0; j < m.getColumnDimension(); j++) {//                  os += m.getEntry(i, j) + " ";//              }//              System.out.println(os);//          }//    }        }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Random;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.SingularValueDecomposition;import org.apache.commons.math.linear.SingularValueDecompositionImpl;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;public class SingularValueDecompositionImplTest extends TestCase {    private double[][] testSquare = {            { 24.0 / 25.0, 43.0 / 25.0 },            { 57.0 / 25.0, 24.0 / 25.0 }    };    private double[][] testNonSquare = {        {  -540.0 / 625.0,  963.0 / 625.0, -216.0 / 625.0 },        { -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 },        {  -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 },        {  -360.0 / 625.0,  192.0 / 625.0, 1756.0 / 625.0 },    };    private static final double normTolerance = 10e-14;    public SingularValueDecompositionImplTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SingularValueDecompositionImplTest.class);        suite.setName("SingularValueDecompositionImpl Tests");        return suite;    }    public void testMoreRows() {        final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };        final int rows    = singularValues.length + 2;        final int columns = singularValues.length;        Random r = new Random(15338437322523l);        SingularValueDecomposition svd =            new SingularValueDecompositionImpl(createTestMatrix(r, rows, columns, singularValues));        double[] computedSV = svd.getSingularValues();        assertEquals(singularValues.length, computedSV.length);        for (int i = 0; i < singularValues.length; ++i) {            assertEquals(singularValues[i], computedSV[i], 1.0e-10);        }    }    public void testMoreColumns() {        final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };        final int rows    = singularValues.length;        final int columns = singularValues.length + 2;        Random r = new Random(732763225836210l);        SingularValueDecomposition svd =            new SingularValueDecompositionImpl(createTestMatrix(r, rows, columns, singularValues));        double[] computedSV = svd.getSingularValues();        assertEquals(singularValues.length, computedSV.length);        for (int i = 0; i < singularValues.length; ++i) {            assertEquals(singularValues[i], computedSV[i], 1.0e-10);        }    }    /** test dimensions */    public void testDimensions() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testSquare);        final int m = matrix.getRowDimension();        final int n = matrix.getColumnDimension();        SingularValueDecomposition svd = new SingularValueDecompositionImpl(matrix);        assertEquals(m, svd.getU().getRowDimension());        assertEquals(m, svd.getU().getColumnDimension());        assertEquals(m, svd.getS().getColumnDimension());        assertEquals(n, svd.getS().getColumnDimension());        assertEquals(n, svd.getV().getRowDimension());        assertEquals(n, svd.getV().getColumnDimension());    }    /** test A = USVt */    public void testAEqualUSVt() {        checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare));        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare));        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare).transpose());    }    public void checkAEqualUSVt(final RealMatrix matrix) {        SingularValueDecomposition svd = new SingularValueDecompositionImpl(matrix);        RealMatrix u = svd.getU();        RealMatrix s = svd.getS();        RealMatrix v = svd.getV();        double norm = u.multiply(s).multiply(v.transpose()).subtract(matrix).getNorm();        assertEquals(0, norm, normTolerance);    }    /** test that U is orthogonal */    public void testUOrthogonal() {        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getU());        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare)).getU());        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getU());    }    /** test that V is orthogonal */    public void testVOrthogonal() {        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getV());        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare)).getV());        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getV());    }    public void checkOrthogonal(final RealMatrix m) {        RealMatrix mTm = m.transpose().multiply(m);        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());        assertEquals(0, mTm.subtract(id).getNorm(), normTolerance);    }    /** test matrices values */    public void testMatricesValues1() {       SingularValueDecomposition svd =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {                { 3.0 / 5.0, -4.0 / 5.0 },                { 4.0 / 5.0,  3.0 / 5.0 }        });        RealMatrix sRef = MatrixUtils.createRealMatrix(new double[][] {                { 3.0, 0.0 },                { 0.0, 1.0 }        });        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {                { 4.0 / 5.0,  3.0 / 5.0 },                { 3.0 / 5.0, -4.0 / 5.0 }        });        // check values against known references        RealMatrix u = svd.getU();        assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);        RealMatrix s = svd.getS();        assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);        RealMatrix v = svd.getV();        assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);        // check the same cached instance is returned the second time        assertTrue(u == svd.getU());        assertTrue(s == svd.getS());        assertTrue(v == svd.getV());            }    /** test matrices values */    public void testMatricesValues2() {        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {            {  0.0 / 5.0,  3.0 / 5.0,  0.0 / 5.0 },            { -4.0 / 5.0,  0.0 / 5.0, -3.0 / 5.0 },            {  0.0 / 5.0,  4.0 / 5.0,  0.0 / 5.0 },            { -3.0 / 5.0,  0.0 / 5.0,  4.0 / 5.0 }        });        RealMatrix sRef = MatrixUtils.createRealMatrix(new double[][] {            { 4.0, 0.0, 0.0 },            { 0.0, 3.0, 0.0 },            { 0.0, 0.0, 2.0 }        });        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {            {  80.0 / 125.0,  -60.0 / 125.0, 75.0 / 125.0 },            {  24.0 / 125.0,  107.0 / 125.0, 60.0 / 125.0 },            { -93.0 / 125.0,  -24.0 / 125.0, 80.0 / 125.0 }        });        // check values against known references        SingularValueDecomposition svd =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare));        RealMatrix u = svd.getU();        assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);        RealMatrix s = svd.getS();        assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);        RealMatrix v = svd.getV();        assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);        // check the same cached instance is returned the second time        assertTrue(u == svd.getU());        assertTrue(s == svd.getS());        assertTrue(v == svd.getV());    }    /** test condition number */    public void testConditionNumber() {        SingularValueDecompositionImpl svd =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));        assertEquals(3.0, svd.getConditionNumber(), 1.0e-15);    }    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns,                                        final double[] singularValues) {        final RealMatrix u =            EigenDecompositionImplTest.createOrthogonalMatrix(r, rows);        final RealMatrix d =            EigenDecompositionImplTest.createDiagonalMatrix(singularValues, rows, columns);        final RealMatrix v =            EigenDecompositionImplTest.createOrthogonalMatrix(r, columns);        return u.multiply(d).multiply(v);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionField;import org.apache.commons.math.linear.FieldLUDecomposition;import org.apache.commons.math.linear.FieldLUDecompositionImpl;import org.apache.commons.math.linear.FieldMatrix;import org.apache.commons.math.linear.Array2DRowFieldMatrix;import org.apache.commons.math.linear.InvalidMatrixException;public class FieldLUDecompositionImplTest extends TestCase {    private Fraction[][] testData = {            { new Fraction(1), new Fraction(2), new Fraction(3)},            { new Fraction(2), new Fraction(5), new Fraction(3)},            { new Fraction(1), new Fraction(0), new Fraction(8)}    };    private Fraction[][] testDataMinus = {            { new Fraction(-1), new Fraction(-2), new Fraction(-3)},            { new Fraction(-2), new Fraction(-5), new Fraction(-3)},            { new Fraction(-1),  new Fraction(0), new Fraction(-8)}    };    private Fraction[][] luData = {            { new Fraction(2), new Fraction(3), new Fraction(3) },            { new Fraction(2), new Fraction(3), new Fraction(7) },            { new Fraction(6), new Fraction(6), new Fraction(8) }    };        // singular matrices    private Fraction[][] singular = {            { new Fraction(2), new Fraction(3) },            { new Fraction(2), new Fraction(3) }    };    private Fraction[][] bigSingular = {            { new Fraction(1), new Fraction(2),   new Fraction(3),    new Fraction(4) },            { new Fraction(2), new Fraction(5),   new Fraction(3),    new Fraction(4) },            { new Fraction(7), new Fraction(3), new Fraction(256), new Fraction(1930) },            { new Fraction(3), new Fraction(7),   new Fraction(6),    new Fraction(8) }    }; // 4th row = 1st + 2nd    public FieldLUDecompositionImplTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(FieldLUDecompositionImplTest.class);        suite.setName("FieldLUDecompositionImpl Tests");        return suite;    }    /** test dimensions */    public void testDimensions() {        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);        FieldLUDecomposition<Fraction> LU = new FieldLUDecompositionImpl<Fraction>(matrix);        assertEquals(testData.length, LU.getL().getRowDimension());        assertEquals(testData.length, LU.getL().getColumnDimension());        assertEquals(testData.length, LU.getU().getRowDimension());        assertEquals(testData.length, LU.getU().getColumnDimension());        assertEquals(testData.length, LU.getP().getRowDimension());        assertEquals(testData.length, LU.getP().getColumnDimension());    }    /** test non-square matrix */    public void testNonSquare() {        try {            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                    { Fraction.ZERO, Fraction.ZERO },                    { Fraction.ZERO, Fraction.ZERO },                    { Fraction.ZERO, Fraction.ZERO }            }));        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test PA = LU */    public void testPAEqualLU() {        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);        FieldLUDecomposition<Fraction> lu = new FieldLUDecompositionImpl<Fraction>(matrix);        FieldMatrix<Fraction> l = lu.getL();        FieldMatrix<Fraction> u = lu.getU();        FieldMatrix<Fraction> p = lu.getP();        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));        matrix = new Array2DRowFieldMatrix<Fraction>(testDataMinus);        lu = new FieldLUDecompositionImpl<Fraction>(matrix);        l = lu.getL();        u = lu.getU();        p = lu.getP();        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), 17, 17);        for (int i = 0; i < matrix.getRowDimension(); ++i) {            matrix.setEntry(i, i, Fraction.ONE);        }        lu = new FieldLUDecompositionImpl<Fraction>(matrix);        l = lu.getL();        u = lu.getU();        p = lu.getP();        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));        matrix = new Array2DRowFieldMatrix<Fraction>(singular);        lu = new FieldLUDecompositionImpl<Fraction>(matrix);        assertFalse(lu.getSolver().isNonSingular());        assertNull(lu.getL());        assertNull(lu.getU());        assertNull(lu.getP());        matrix = new Array2DRowFieldMatrix<Fraction>(bigSingular);        lu = new FieldLUDecompositionImpl<Fraction>(matrix);        assertFalse(lu.getSolver().isNonSingular());        assertNull(lu.getL());        assertNull(lu.getU());        assertNull(lu.getP());    }    /** test that L is lower triangular with unit diagonal */    public void testLLowerTriangular() {        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);        FieldMatrix<Fraction> l = new FieldLUDecompositionImpl<Fraction>(matrix).getL();        for (int i = 0; i < l.getRowDimension(); i++) {            assertEquals(Fraction.ONE, l.getEntry(i, i));            for (int j = i + 1; j < l.getColumnDimension(); j++) {                assertEquals(Fraction.ZERO, l.getEntry(i, j));            }        }    }    /** test that U is upper triangular */    public void testUUpperTriangular() {        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);        FieldMatrix<Fraction> u = new FieldLUDecompositionImpl<Fraction>(matrix).getU();        for (int i = 0; i < u.getRowDimension(); i++) {            for (int j = 0; j < i; j++) {                assertEquals(Fraction.ZERO, u.getEntry(i, j));            }        }    }    /** test that P is a permutation matrix */    public void testPPermutation() {        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);        FieldMatrix<Fraction> p   = new FieldLUDecompositionImpl<Fraction>(matrix).getP();        FieldMatrix<Fraction> ppT = p.multiply(p.transpose());        FieldMatrix<Fraction> id  =            new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),                                          p.getRowDimension(), p.getRowDimension());        for (int i = 0; i < id.getRowDimension(); ++i) {            id.setEntry(i, i, Fraction.ONE);        }        TestUtils.assertEquals(id, ppT);        for (int i = 0; i < p.getRowDimension(); i++) {            int zeroCount  = 0;            int oneCount   = 0;            int otherCount = 0;            for (int j = 0; j < p.getColumnDimension(); j++) {                final Fraction e = p.getEntry(i, j);                if (e.equals(Fraction.ZERO)) {                    ++zeroCount;                } else if (e.equals(Fraction.ONE)) {                    ++oneCount;                } else {                    ++otherCount;                }            }            assertEquals(p.getColumnDimension() - 1, zeroCount);            assertEquals(1, oneCount);            assertEquals(0, otherCount);        }        for (int j = 0; j < p.getColumnDimension(); j++) {            int zeroCount  = 0;            int oneCount   = 0;            int otherCount = 0;            for (int i = 0; i < p.getRowDimension(); i++) {                final Fraction e = p.getEntry(i, j);                if (e.equals(Fraction.ZERO)) {                    ++zeroCount;                } else if (e.equals(Fraction.ONE)) {                    ++oneCount;                } else {                    ++otherCount;                }            }            assertEquals(p.getRowDimension() - 1, zeroCount);            assertEquals(1, oneCount);            assertEquals(0, otherCount);        }    }    /** test singular */    public void testSingular() {        FieldLUDecomposition<Fraction> lu =            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(testData));        assertTrue(lu.getSolver().isNonSingular());        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(singular));        assertFalse(lu.getSolver().isNonSingular());        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(bigSingular));        assertFalse(lu.getSolver().isNonSingular());    }    /** test matrices values */    public void testMatricesValues1() {       FieldLUDecomposition<Fraction> lu =            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(testData));        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(1), new Fraction(0), new Fraction(0) },                { new Fraction(2), new Fraction(1), new Fraction(0) },                { new Fraction(1), new Fraction(-2), new Fraction(1) }        });        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(1),  new Fraction(2), new Fraction(3) },                { new Fraction(0), new Fraction(1), new Fraction(-3) },                { new Fraction(0),  new Fraction(0), new Fraction(-1) }        });        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(1), new Fraction(0), new Fraction(0) },                { new Fraction(0), new Fraction(1), new Fraction(0) },                { new Fraction(0), new Fraction(0), new Fraction(1) }        });        int[] pivotRef = { 0, 1, 2 };        // check values against known references        FieldMatrix<Fraction> l = lu.getL();        TestUtils.assertEquals(lRef, l);        FieldMatrix<Fraction> u = lu.getU();        TestUtils.assertEquals(uRef, u);        FieldMatrix<Fraction> p = lu.getP();        TestUtils.assertEquals(pRef, p);        int[] pivot = lu.getPivot();        for (int i = 0; i < pivotRef.length; ++i) {            assertEquals(pivotRef[i], pivot[i]);        }        // check the same cached instance is returned the second time        assertTrue(l == lu.getL());        assertTrue(u == lu.getU());        assertTrue(p == lu.getP());            }    /** test matrices values */    public void testMatricesValues2() {       FieldLUDecomposition<Fraction> lu =            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(luData));        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(1), new Fraction(0), new Fraction(0) },                { new Fraction(3), new Fraction(1), new Fraction(0) },                { new Fraction(1), new Fraction(0), new Fraction(1) }        });        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(2), new Fraction(3), new Fraction(3)    },                { new Fraction(0), new Fraction(-3), new Fraction(-1)  },                { new Fraction(0), new Fraction(0), new Fraction(4) }        });        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(1), new Fraction(0), new Fraction(0) },                { new Fraction(0), new Fraction(0), new Fraction(1) },                { new Fraction(0), new Fraction(1), new Fraction(0) }        });        int[] pivotRef = { 0, 2, 1 };        // check values against known references        FieldMatrix<Fraction> l = lu.getL();        TestUtils.assertEquals(lRef, l);        FieldMatrix<Fraction> u = lu.getU();        TestUtils.assertEquals(uRef, u);        FieldMatrix<Fraction> p = lu.getP();        TestUtils.assertEquals(pRef, p);        int[] pivot = lu.getPivot();        for (int i = 0; i < pivotRef.length; ++i) {            assertEquals(pivotRef[i], pivot[i]);        }        // check the same cached instance is returned the second time        assertTrue(l == lu.getL());        assertTrue(u == lu.getU());        assertTrue(p == lu.getP());            }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.io.Serializable;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;/** * Test cases for the {@link ArrayRealVector} class. * * @version $Revision$ $Date$ */public class ArrayRealVectorTest extends TestCase {    //     protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};    protected double[] vec1 = {1d, 2d, 3d};    protected double[] vec2 = {4d, 5d, 6d};    protected double[] vec3 = {7d, 8d, 9d};    protected double[] vec4 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};    protected double[] vec_null = {0d, 0d, 0d};    protected Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};    protected double[][] mat1 = {{1d, 2d, 3d}, {4d, 5d, 6d},{ 7d, 8d, 9d}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    // Testclass to test the RealVector interface     // only with enough content to support the test    public static class RealVectorTestImpl implements RealVector, Serializable {        /** Serializable version identifier. */        private static final long serialVersionUID = 4715341047369582908L;        /** Entries of the vector. */        protected double data[];        public RealVectorTestImpl(double[] d) {            data = d.clone();        }        private UnsupportedOperationException unsupported() {            return new UnsupportedOperationException("Not supported, unneeded for test purposes");        }        public RealVector copy() {            throw unsupported();        }        public RealVector add(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector add(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector subtract(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector subtract(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector mapAdd(double d) {            throw unsupported();        }        public RealVector mapAddToSelf(double d) {            throw unsupported();        }        public RealVector mapSubtract(double d) {            throw unsupported();        }        public RealVector mapSubtractToSelf(double d) {            throw unsupported();        }        public RealVector mapMultiply(double d) {            double[] out = new double[data.length];            for (int i = 0; i < data.length; i++) {                out[i] = data[i] * d;            }            return new ArrayRealVector(out);        }        public RealVector mapMultiplyToSelf(double d) {            throw unsupported();        }        public RealVector mapDivide(double d) {            throw unsupported();        }        public RealVector mapDivideToSelf(double d) {            throw unsupported();        }        public RealVector mapPow(double d) {            throw unsupported();        }        public RealVector mapPowToSelf(double d) {            throw unsupported();        }        public RealVector mapExp() {            throw unsupported();        }        public RealVector mapExpToSelf() {            throw unsupported();        }        public RealVector mapExpm1() {            throw unsupported();        }        public RealVector mapExpm1ToSelf() {            throw unsupported();        }        public RealVector mapLog() {            throw unsupported();        }        public RealVector mapLogToSelf() {            throw unsupported();        }        public RealVector mapLog10() {            throw unsupported();        }        public RealVector mapLog10ToSelf() {            throw unsupported();        }        public RealVector mapLog1p() {            throw unsupported();        }        public RealVector mapLog1pToSelf() {            throw unsupported();        }        public RealVector mapCosh() {            throw unsupported();        }        public RealVector mapCoshToSelf() {            throw unsupported();        }        public RealVector mapSinh() {            throw unsupported();        }        public RealVector mapSinhToSelf() {            throw unsupported();        }        public RealVector mapTanh() {            throw unsupported();        }        public RealVector mapTanhToSelf() {            throw unsupported();        }        public RealVector mapCos() {            throw unsupported();        }        public RealVector mapCosToSelf() {            throw unsupported();        }        public RealVector mapSin() {            throw unsupported();        }        public RealVector mapSinToSelf() {            throw unsupported();        }        public RealVector mapTan() {            throw unsupported();        }        public RealVector mapTanToSelf() {            throw unsupported();        }        public RealVector mapAcos() {            throw unsupported();        }        public RealVector mapAcosToSelf() {            throw unsupported();        }        public RealVector mapAsin() {            throw unsupported();        }        public RealVector mapAsinToSelf() {            throw unsupported();        }        public RealVector mapAtan() {            throw unsupported();        }        public RealVector mapAtanToSelf() {            throw unsupported();        }        public RealVector mapInv() {            throw unsupported();        }        public RealVector mapInvToSelf() {            throw unsupported();        }        public RealVector mapAbs() {            throw unsupported();        }        public RealVector mapAbsToSelf() {            throw unsupported();        }        public RealVector mapSqrt() {            throw unsupported();        }        public RealVector mapSqrtToSelf() {            throw unsupported();        }        public RealVector mapCbrt() {            throw unsupported();        }        public RealVector mapCbrtToSelf() {            throw unsupported();        }        public RealVector mapCeil() {            throw unsupported();        }        public RealVector mapCeilToSelf() {            throw unsupported();        }        public RealVector mapFloor() {            throw unsupported();        }        public RealVector mapFloorToSelf() {            throw unsupported();        }        public RealVector mapRint() {            throw unsupported();        }        public RealVector mapRintToSelf() {            throw unsupported();        }        public RealVector mapSignum() {            throw unsupported();        }        public RealVector mapSignumToSelf() {            throw unsupported();        }        public RealVector mapUlp() {            throw unsupported();        }        public RealVector mapUlpToSelf() {            throw unsupported();        }        public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector ebeDivide(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public double[] getData() {            return data.clone();        }        public double dotProduct(RealVector v) throws IllegalArgumentException {            double dot = 0;            for (int i = 0; i < data.length; i++) {                dot += data[i] * v.getEntry(i);            }            return dot;        }        public double dotProduct(double[] v) throws IllegalArgumentException {            double dot = 0;            for (int i = 0; i < data.length; i++) {                dot += data[i] * v[i];            }            return dot;        }        public double getNorm() {            throw unsupported();        }        public double getL1Norm() {            throw unsupported();        }        public double getLInfNorm() {            throw unsupported();        }        public double getDistance(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public double getDistance(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public double getL1Distance(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public double getL1Distance(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public double getLInfDistance(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public double getLInfDistance(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector unitVector() {            throw unsupported();        }        public void unitize() {            throw unsupported();        }        public RealVector projection(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector projection(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public double getEntry(int index) throws MatrixIndexException {            return data[index];        }        public int getDimension() {            return data.length;        }        public RealVector append(RealVector v) {            throw unsupported();        }        public RealVector append(double d) {            throw unsupported();        }        public RealVector append(double[] a) {            throw unsupported();        }        public RealVector getSubVector(int index, int n) throws MatrixIndexException {            throw unsupported();        }        public void setEntry(int index, double value) throws MatrixIndexException {            throw unsupported();        }        public void setSubVector(int index, RealVector v) throws MatrixIndexException {            throw unsupported();        }        public void setSubVector(int index, double[] v) throws MatrixIndexException {            throw unsupported();        }        public void set(double value) {            throw unsupported();        }        public double[] toArray() {            throw unsupported();        }        public boolean isNaN() {            throw unsupported();        }        public boolean isInfinite() {            throw unsupported();        }    }    public static Test suite() {        TestSuite suite = new TestSuite(ArrayRealVectorTest.class);        suite.setName("ArrayRealVector Tests");        return suite;    }    public void testConstructors() {        ArrayRealVector v0 = new ArrayRealVector();        assertEquals("testData len", 0, v0.getDimension());        ArrayRealVector v1 = new ArrayRealVector(7);        assertEquals("testData len", 7, v1.getDimension());        assertEquals("testData is 0.0 ", 0.0, v1.getEntry(6));        ArrayRealVector v2 = new ArrayRealVector(5, 1.23);        assertEquals("testData len", 5, v2.getDimension());        assertEquals("testData is 1.23 ", 1.23, v2.getEntry(4));        ArrayRealVector v3 = new ArrayRealVector(vec1);        assertEquals("testData len", 3, v3.getDimension());        assertEquals("testData is 2.0 ", 2.0, v3.getEntry(1));        ArrayRealVector v4 = new ArrayRealVector(vec4, 3, 2);        assertEquals("testData len", 2, v4.getDimension());        assertEquals("testData is 4.0 ", 4.0, v4.getEntry(0));        try {            new ArrayRealVector(vec4, 8, 3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        RealVector v5_i = new ArrayRealVector(dvec1);        assertEquals("testData len", 9, v5_i.getDimension());        assertEquals("testData is 9.0 ", 9.0, v5_i.getEntry(8));        ArrayRealVector v5 = new ArrayRealVector(dvec1);        assertEquals("testData len", 9, v5.getDimension());        assertEquals("testData is 9.0 ", 9.0, v5.getEntry(8));        ArrayRealVector v6 = new ArrayRealVector(dvec1, 3, 2);        assertEquals("testData len", 2, v6.getDimension());        assertEquals("testData is 4.0 ", 4.0, v6.getEntry(0));        try {            new ArrayRealVector(dvec1, 8, 3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayRealVector v7 = new ArrayRealVector(v1);        assertEquals("testData len", 7, v7.getDimension());        assertEquals("testData is 0.0 ", 0.0, v7.getEntry(6));        RealVectorTestImpl v7_i = new RealVectorTestImpl(vec1);        ArrayRealVector v7_2 = new ArrayRealVector(v7_i);        assertEquals("testData len", 3, v7_2.getDimension());        assertEquals("testData is 0.0 ", 2.0d, v7_2.getEntry(1));        ArrayRealVector v8 = new ArrayRealVector(v1, true);        assertEquals("testData len", 7, v8.getDimension());        assertEquals("testData is 0.0 ", 0.0, v8.getEntry(6));        assertNotSame("testData not same object ", v1.data, v8.data);        ArrayRealVector v8_2 = new ArrayRealVector(v1, false);        assertEquals("testData len", 7, v8_2.getDimension());        assertEquals("testData is 0.0 ", 0.0, v8_2.getEntry(6));        assertEquals("testData same object ", v1.data, v8_2.data);        ArrayRealVector v9 = new ArrayRealVector(v1, v3);        assertEquals("testData len", 10, v9.getDimension());        assertEquals("testData is 1.0 ", 1.0, v9.getEntry(7));    }    public void testDataInOut() {        ArrayRealVector v1 = new ArrayRealVector(vec1);        ArrayRealVector v2 = new ArrayRealVector(vec2);        ArrayRealVector v4 = new ArrayRealVector(vec4);        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);         RealVector v_append_1 = v1.append(v2);        assertEquals("testData len", 6, v_append_1.getDimension());        assertEquals("testData is 4.0 ", 4.0, v_append_1.getEntry(3));        RealVector v_append_2 = v1.append(2.0);        assertEquals("testData len", 4, v_append_2.getDimension());        assertEquals("testData is 2.0 ", 2.0, v_append_2.getEntry(3));        RealVector v_append_3 = v1.append(vec2);        assertEquals("testData len", 6, v_append_3.getDimension());        assertEquals("testData is  ", 4.0, v_append_3.getEntry(3));        RealVector v_append_4 = v1.append(v2_t);        assertEquals("testData len", 6, v_append_4.getDimension());        assertEquals("testData is 4.0 ", 4.0, v_append_4.getEntry(3));        RealVector v_copy = v1.copy();        assertEquals("testData len", 3, v_copy.getDimension());        assertNotSame("testData not same object ", v1.data, v_copy.getData());        double[] a_double = v1.toArray();        assertEquals("testData len", 3, a_double.length);        assertNotSame("testData not same object ", v1.data, a_double);//      ArrayRealVector vout4 = (ArrayRealVector) v1.clone();//      assertEquals("testData len", 3, vout4.getDimension());//      assertEquals("testData not same object ", v1.data, vout4.data);        RealVector vout5 = v4.getSubVector(3, 3);        assertEquals("testData len", 3, vout5.getDimension());        assertEquals("testData is 4.0 ", 5.0, vout5.getEntry(1));        try {            v4.getSubVector(3, 7);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayRealVector v_set1 = (ArrayRealVector) v1.copy();        v_set1.setEntry(1, 11.0);        assertEquals("testData is 11.0 ", 11.0, v_set1.getEntry(1));        try {            v_set1.setEntry(3, 11.0);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayRealVector v_set2 = (ArrayRealVector) v4.copy();        v_set2.set(3, v1);        assertEquals("testData is 1.0 ", 1.0, v_set2.getEntry(3));        assertEquals("testData is 7.0 ", 7.0, v_set2.getEntry(6));        try {            v_set2.set(7, v1);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayRealVector v_set3 = (ArrayRealVector) v1.copy();        v_set3.set(13.0);        assertEquals("testData is 13.0 ", 13.0, v_set3.getEntry(2));        try {            v_set3.getEntry(23);            fail("ArrayIndexOutOfBoundsException expected");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayRealVector v_set4 = (ArrayRealVector) v4.copy();        v_set4.setSubVector(3, v2_t);        assertEquals("testData is 1.0 ", 4.0, v_set4.getEntry(3));        assertEquals("testData is 7.0 ", 7.0, v_set4.getEntry(6));        try {            v_set4.setSubVector(7, v2_t);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayRealVector vout10 = (ArrayRealVector) v1.copy();               ArrayRealVector vout10_2 = (ArrayRealVector) v1.copy();        assertEquals(vout10, vout10_2);        vout10_2.setEntry(0, 1.1);        assertNotSame(vout10, vout10_2);    }    public void testMapFunctions() {         ArrayRealVector v1 = new ArrayRealVector(vec1);        //octave =  v1 .+ 2.0        RealVector v_mapAdd = v1.mapAdd(2.0d);        double[] result_mapAdd = {3d, 4d, 5d};        assertClose("compare vectors" ,result_mapAdd,v_mapAdd.getData(),normTolerance);        //octave =  v1 .+ 2.0        RealVector v_mapAddToSelf = v1.copy();        v_mapAddToSelf.mapAddToSelf(2.0d);        double[] result_mapAddToSelf = {3d, 4d, 5d};        assertClose("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData(),normTolerance);        //octave =  v1 .- 2.0        RealVector v_mapSubtract = v1.mapSubtract(2.0d);        double[] result_mapSubtract = {-1d, 0d, 1d};        assertClose("compare vectors" ,result_mapSubtract,v_mapSubtract.getData(),normTolerance);        //octave =  v1 .- 2.0        RealVector v_mapSubtractToSelf = v1.copy();        v_mapSubtractToSelf.mapSubtractToSelf(2.0d);        double[] result_mapSubtractToSelf = {-1d, 0d, 1d};        assertClose("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData(),normTolerance);        //octave =  v1 .* 2.0        RealVector v_mapMultiply = v1.mapMultiply(2.0d);        double[] result_mapMultiply = {2d, 4d, 6d};        assertClose("compare vectors" ,result_mapMultiply,v_mapMultiply.getData(),normTolerance);        //octave =  v1 .* 2.0        RealVector v_mapMultiplyToSelf = v1.copy();        v_mapMultiplyToSelf.mapMultiplyToSelf(2.0d);        double[] result_mapMultiplyToSelf = {2d, 4d, 6d};        assertClose("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData(),normTolerance);        //octave =  v1 ./ 2.0        RealVector v_mapDivide = v1.mapDivide(2.0d);        double[] result_mapDivide = {.5d, 1d, 1.5d};        assertClose("compare vectors" ,result_mapDivide,v_mapDivide.getData(),normTolerance);        //octave =  v1 ./ 2.0        RealVector v_mapDivideToSelf = v1.copy();        v_mapDivideToSelf.mapDivideToSelf(2.0d);        double[] result_mapDivideToSelf = {.5d, 1d, 1.5d};        assertClose("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData(),normTolerance);        //octave =  v1 .^ 2.0        RealVector v_mapPow = v1.mapPow(2.0d);        double[] result_mapPow = {1d, 4d, 9d};        assertClose("compare vectors" ,result_mapPow,v_mapPow.getData(),normTolerance);        //octave =  v1 .^ 2.0        RealVector v_mapPowToSelf = v1.copy();        v_mapPowToSelf.mapPowToSelf(2.0d);        double[] result_mapPowToSelf = {1d, 4d, 9d};        assertClose("compare vectors" ,result_mapPowToSelf,v_mapPowToSelf.getData(),normTolerance);        //octave =  exp(v1)        RealVector v_mapExp = v1.mapExp();        double[] result_mapExp = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};        assertClose("compare vectors" ,result_mapExp,v_mapExp.getData(),normTolerance);        //octave =  exp(v1)        RealVector v_mapExpToSelf = v1.copy();        v_mapExpToSelf.mapExpToSelf();        double[] result_mapExpToSelf = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};        assertClose("compare vectors" ,result_mapExpToSelf,v_mapExpToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapExpm1 = v1.mapExpm1();        double[] result_mapExpm1 = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};        assertClose("compare vectors" ,result_mapExpm1,v_mapExpm1.getData(),normTolerance);        //octave =  ???        RealVector v_mapExpm1ToSelf = v1.copy();        v_mapExpm1ToSelf.mapExpm1ToSelf();        double[] result_mapExpm1ToSelf = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};        assertClose("compare vectors" ,result_mapExpm1ToSelf,v_mapExpm1ToSelf.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLog = v1.mapLog();        double[] result_mapLog = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};        assertClose("compare vectors" ,result_mapLog,v_mapLog.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLogToSelf = v1.copy();        v_mapLogToSelf.mapLogToSelf();        double[] result_mapLogToSelf = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};        assertClose("compare vectors" ,result_mapLogToSelf,v_mapLogToSelf.getData(),normTolerance);        //octave =  log10(v1)        RealVector v_mapLog10 = v1.mapLog10();        double[] result_mapLog10 = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};        assertClose("compare vectors" ,result_mapLog10,v_mapLog10.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLog10ToSelf = v1.copy();        v_mapLog10ToSelf.mapLog10ToSelf();        double[] result_mapLog10ToSelf = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};        assertClose("compare vectors" ,result_mapLog10ToSelf,v_mapLog10ToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapLog1p = v1.mapLog1p();        double[] result_mapLog1p = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};        assertClose("compare vectors" ,result_mapLog1p,v_mapLog1p.getData(),normTolerance);        //octave =  ???        RealVector v_mapLog1pToSelf = v1.copy();        v_mapLog1pToSelf.mapLog1pToSelf();        double[] result_mapLog1pToSelf = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};        assertClose("compare vectors" ,result_mapLog1pToSelf,v_mapLog1pToSelf.getData(),normTolerance);        //octave =  cosh(v1)        RealVector v_mapCosh = v1.mapCosh();        double[] result_mapCosh = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};        assertClose("compare vectors" ,result_mapCosh,v_mapCosh.getData(),normTolerance);        //octave =  cosh(v1)        RealVector v_mapCoshToSelf = v1.copy();        v_mapCoshToSelf.mapCoshToSelf();        double[] result_mapCoshToSelf = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};        assertClose("compare vectors" ,result_mapCoshToSelf,v_mapCoshToSelf.getData(),normTolerance);        //octave =  sinh(v1)        RealVector v_mapSinh = v1.mapSinh();        double[] result_mapSinh = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};        assertClose("compare vectors" ,result_mapSinh,v_mapSinh.getData(),normTolerance);        //octave =  sinh(v1)        RealVector v_mapSinhToSelf = v1.copy();        v_mapSinhToSelf.mapSinhToSelf();        double[] result_mapSinhToSelf = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};        assertClose("compare vectors" ,result_mapSinhToSelf,v_mapSinhToSelf.getData(),normTolerance);        //octave =  tanh(v1)        RealVector v_mapTanh = v1.mapTanh();        double[] result_mapTanh = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};        assertClose("compare vectors" ,result_mapTanh,v_mapTanh.getData(),normTolerance);        //octave =  tanh(v1)        RealVector v_mapTanhToSelf = v1.copy();        v_mapTanhToSelf.mapTanhToSelf();        double[] result_mapTanhToSelf = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};        assertClose("compare vectors" ,result_mapTanhToSelf,v_mapTanhToSelf.getData(),normTolerance);        //octave =  cos(v1)        RealVector v_mapCos = v1.mapCos();        double[] result_mapCos = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};        assertClose("compare vectors" ,result_mapCos,v_mapCos.getData(),normTolerance);        //octave =  cos(v1)        RealVector v_mapCosToSelf = v1.copy();        v_mapCosToSelf.mapCosToSelf();        double[] result_mapCosToSelf = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};        assertClose("compare vectors" ,result_mapCosToSelf,v_mapCosToSelf.getData(),normTolerance);        //octave =  sin(v1)        RealVector v_mapSin = v1.mapSin();        double[] result_mapSin = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};        assertClose("compare vectors" ,result_mapSin,v_mapSin.getData(),normTolerance);        //octave =  sin(v1)        RealVector v_mapSinToSelf = v1.copy();        v_mapSinToSelf.mapSinToSelf();        double[] result_mapSinToSelf = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};        assertClose("compare vectors" ,result_mapSinToSelf,v_mapSinToSelf.getData(),normTolerance);        //octave =  tan(v1)        RealVector v_mapTan = v1.mapTan();        double[] result_mapTan = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};        assertClose("compare vectors" ,result_mapTan,v_mapTan.getData(),normTolerance);        //octave =  tan(v1)        RealVector v_mapTanToSelf = v1.copy();        v_mapTanToSelf.mapTanToSelf();        double[] result_mapTanToSelf = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};        assertClose("compare vectors" ,result_mapTanToSelf,v_mapTanToSelf.getData(),normTolerance);        double[] vat_a = {0d, 0.5d, 1.0d};        ArrayRealVector vat = new ArrayRealVector(vat_a);        //octave =  acos(vat)        RealVector v_mapAcos = vat.mapAcos();        double[] result_mapAcos = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};        assertClose("compare vectors" ,result_mapAcos,v_mapAcos.getData(),normTolerance);        //octave =  acos(vat)        RealVector v_mapAcosToSelf = vat.copy();        v_mapAcosToSelf.mapAcosToSelf();        double[] result_mapAcosToSelf = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};        assertClose("compare vectors" ,result_mapAcosToSelf,v_mapAcosToSelf.getData(),normTolerance);        //octave =  asin(vat)        RealVector v_mapAsin = vat.mapAsin();        double[] result_mapAsin = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};        assertClose("compare vectors" ,result_mapAsin,v_mapAsin.getData(),normTolerance);        //octave =  asin(vat)        RealVector v_mapAsinToSelf = vat.copy();        v_mapAsinToSelf.mapAsinToSelf();                double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};        assertClose("compare vectors" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);        //octave =  atan(vat)        RealVector v_mapAtan = vat.mapAtan();        double[] result_mapAtan = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};        assertClose("compare vectors" ,result_mapAtan,v_mapAtan.getData(),normTolerance);        //octave =  atan(vat)        RealVector v_mapAtanToSelf = vat.copy();        v_mapAtanToSelf.mapAtanToSelf();        double[] result_mapAtanToSelf = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};        assertClose("compare vectors" ,result_mapAtanToSelf,v_mapAtanToSelf.getData(),normTolerance);        //octave =  v1 .^-1        RealVector v_mapInv = v1.mapInv();        double[] result_mapInv = {1d,0.5d,3.333333333333333e-01d};        assertClose("compare vectors" ,result_mapInv,v_mapInv.getData(),normTolerance);        //octave =  v1 .^-1        RealVector v_mapInvToSelf = v1.copy();        v_mapInvToSelf.mapInvToSelf();        double[] result_mapInvToSelf = {1d,0.5d,3.333333333333333e-01d};        assertClose("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData(),normTolerance);        double[] abs_a = {-1.0d, 0.0d, 1.0d};        ArrayRealVector abs_v = new ArrayRealVector(abs_a);        //octave =  abs(abs_v)        RealVector v_mapAbs = abs_v.mapAbs();        double[] result_mapAbs = {1d,0d,1d};        assertClose("compare vectors" ,result_mapAbs,v_mapAbs.getData(),normTolerance);        //octave = abs(abs_v)        RealVector v_mapAbsToSelf = abs_v.copy();        v_mapAbsToSelf.mapAbsToSelf();        double[] result_mapAbsToSelf = {1d,0d,1d};        assertClose("compare vectors" ,result_mapAbsToSelf,v_mapAbsToSelf.getData(),normTolerance);        //octave =   sqrt(v1)        RealVector v_mapSqrt = v1.mapSqrt();        double[] result_mapSqrt = {1d,1.414213562373095e+00d,1.732050807568877e+00d};        assertClose("compare vectors" ,result_mapSqrt,v_mapSqrt.getData(),normTolerance);        //octave =  sqrt(v1)        RealVector v_mapSqrtToSelf = v1.copy();        v_mapSqrtToSelf.mapSqrtToSelf();        double[] result_mapSqrtToSelf = {1d,1.414213562373095e+00d,1.732050807568877e+00d};        assertClose("compare vectors" ,result_mapSqrtToSelf,v_mapSqrtToSelf.getData(),normTolerance);        double[] cbrt_a = {-2.0d, 0.0d, 2.0d};        ArrayRealVector cbrt_v = new ArrayRealVector(cbrt_a);        //octave =  ???        RealVector v_mapCbrt = cbrt_v.mapCbrt();        double[] result_mapCbrt = {-1.2599210498948732d,0d,1.2599210498948732d};        assertClose("compare vectors" ,result_mapCbrt,v_mapCbrt.getData(),normTolerance);        //octave = ???        RealVector v_mapCbrtToSelf = cbrt_v.copy();        v_mapCbrtToSelf.mapCbrtToSelf();        double[] result_mapCbrtToSelf =  {-1.2599210498948732d,0d,1.2599210498948732d};        assertClose("compare vectors" ,result_mapCbrtToSelf,v_mapCbrtToSelf.getData(),normTolerance);        double[] ceil_a = {-1.1d, 0.9d, 1.1d};        ArrayRealVector ceil_v = new ArrayRealVector(ceil_a);        //octave =  ceil(ceil_v)        RealVector v_mapCeil = ceil_v.mapCeil();        double[] result_mapCeil = {-1d,1d,2d};        assertClose("compare vectors" ,result_mapCeil,v_mapCeil.getData(),normTolerance);        //octave = ceil(ceil_v)        RealVector v_mapCeilToSelf = ceil_v.copy();        v_mapCeilToSelf.mapCeilToSelf();        double[] result_mapCeilToSelf =  {-1d,1d,2d};        assertClose("compare vectors" ,result_mapCeilToSelf,v_mapCeilToSelf.getData(),normTolerance);        //octave =  floor(ceil_v)        RealVector v_mapFloor = ceil_v.mapFloor();        double[] result_mapFloor = {-2d,0d,1d};        assertClose("compare vectors" ,result_mapFloor,v_mapFloor.getData(),normTolerance);        //octave = floor(ceil_v)        RealVector v_mapFloorToSelf = ceil_v.copy();        v_mapFloorToSelf.mapFloorToSelf();        double[] result_mapFloorToSelf =  {-2d,0d,1d};        assertClose("compare vectors" ,result_mapFloorToSelf,v_mapFloorToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapRint = ceil_v.mapRint();        double[] result_mapRint = {-1d,1d,1d};        assertClose("compare vectors" ,result_mapRint,v_mapRint.getData(),normTolerance);        //octave = ???        RealVector v_mapRintToSelf = ceil_v.copy();        v_mapRintToSelf.mapRintToSelf();        double[] result_mapRintToSelf =  {-1d,1d,1d};        assertClose("compare vectors" ,result_mapRintToSelf,v_mapRintToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapSignum = ceil_v.mapSignum();        double[] result_mapSignum = {-1d,1d,1d};        assertClose("compare vectors" ,result_mapSignum,v_mapSignum.getData(),normTolerance);        //octave = ???        RealVector v_mapSignumToSelf = ceil_v.copy();        v_mapSignumToSelf.mapSignumToSelf();        double[] result_mapSignumToSelf =  {-1d,1d,1d};        assertClose("compare vectors" ,result_mapSignumToSelf,v_mapSignumToSelf.getData(),normTolerance);        // Is with the used resolutions of limited value as test        //octave =  ???        RealVector v_mapUlp = ceil_v.mapUlp();        double[] result_mapUlp = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};        assertClose("compare vectors" ,result_mapUlp,v_mapUlp.getData(),normTolerance);        //octave = ???        RealVector v_mapUlpToSelf = ceil_v.copy();        v_mapUlpToSelf.mapUlpToSelf();        double[] result_mapUlpToSelf = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};        assertClose("compare vectors" ,result_mapUlpToSelf,v_mapUlpToSelf.getData(),normTolerance);    }    public void testBasicFunctions() {         ArrayRealVector v1 = new ArrayRealVector(vec1);        ArrayRealVector v2 = new ArrayRealVector(vec2);        ArrayRealVector v_null = new ArrayRealVector(vec_null);        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);         //octave =  sqrt(sumsq(v1))        double d_getNorm = v1.getNorm();        assertEquals("compare values  ", 3.7416573867739413,d_getNorm);        double d_getL1Norm = v1.getL1Norm();        assertEquals("compare values  ",6.0, d_getL1Norm);        double d_getLInfNorm = v1.getLInfNorm();        assertEquals("compare values  ",6.0, d_getLInfNorm);        //octave =  sqrt(sumsq(v1-v2))        double dist = v1.getDistance(v2);        assertEquals("compare values  ",v1.subtract(v2).getNorm(), dist );        //octave =  sqrt(sumsq(v1-v2))        double dist_2 = v1.getDistance(v2_t);        assertEquals("compare values  ", v1.subtract(v2).getNorm(),dist_2 );        //octave =  ???        double d_getL1Distance = v1. getL1Distance(v2);        assertEquals("compare values  ",9d, d_getL1Distance );        double d_getL1Distance_2 = v1. getL1Distance(v2_t);        assertEquals("compare values  ",9d, d_getL1Distance_2 );        //octave =  ???        double d_getLInfDistance = v1. getLInfDistance(v2);        assertEquals("compare values  ",3d, d_getLInfDistance );        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);        assertEquals("compare values  ",3d, d_getLInfDistance_2 );        //octave =  v1 + v2        ArrayRealVector v_add = v1.add(v2);        double[] result_add = {5d, 7d, 9d};        assertClose("compare vect" ,v_add.getData(),result_add,normTolerance);        RealVectorTestImpl vt2 = new RealVectorTestImpl(vec2);        RealVector v_add_i = v1.add(vt2);        double[] result_add_i = {5d, 7d, 9d};        assertClose("compare vect" ,v_add_i.getData(),result_add_i,normTolerance);        //octave =  v1 - v2        ArrayRealVector v_subtract = v1.subtract(v2);        double[] result_subtract = {-3d, -3d, -3d};        assertClose("compare vect" ,v_subtract.getData(),result_subtract,normTolerance);        RealVector v_subtract_i = v1.subtract(vt2);        double[] result_subtract_i = {-3d, -3d, -3d};        assertClose("compare vect" ,v_subtract_i.getData(),result_subtract_i,normTolerance);        // octave v1 .* v2        ArrayRealVector  v_ebeMultiply = v1.ebeMultiply(v2);        double[] result_ebeMultiply = {4d, 10d, 18d};        assertClose("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);        double[] result_ebeMultiply_2 = {4d, 10d, 18d};        assertClose("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);        // octave v1 ./ v2        ArrayRealVector  v_ebeDivide = v1.ebeDivide(v2);        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};        assertClose("compare vect" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};        assertClose("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);        // octave  dot(v1,v2)        double dot =  v1.dotProduct(v2);        assertEquals("compare val ",32d, dot);        // octave  dot(v1,v2_t)        double dot_2 =  v1.dotProduct(v2_t);        assertEquals("compare val ",32d, dot_2);        RealMatrix m_outerProduct = v1.outerProduct(v2);        assertEquals("compare val ",4d, m_outerProduct.getEntry(0,0));        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);        assertEquals("compare val ",4d, m_outerProduct_2.getEntry(0,0));        RealVector v_unitVector = v1.unitVector();        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());         assertClose("compare vect" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);        try {            v_null.unitVector();            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayRealVector v_unitize = (ArrayRealVector)v1.copy();        v_unitize.unitize();        assertClose("compare vect" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);        try {            v_null.unitize();            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayRealVector v_projection = v1.projection(v2);        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};        assertClose("compare vect", v_projection.getData(), result_projection, normTolerance);        RealVector v_projection_2 = v1.projection(v2_t);        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};        assertClose("compare vect", v_projection_2.getData(), result_projection_2, normTolerance);    }      public void testMisc() {         ArrayRealVector v1 = new ArrayRealVector(vec1);        ArrayRealVector v4 = new ArrayRealVector(vec4);        RealVector v4_2 = new ArrayRealVector(vec4);        String out1 = v1.toString();        assertTrue("some output ",  out1.length()!=0);        /*             double[] dout1 = v1.copyOut();        assertEquals("testData len", 3, dout1.length);        assertNotSame("testData not same object ", v1.data, dout1);            */              try {            v1.checkVectorDimensions(2);             fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            v1.checkVectorDimensions(v4);             fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }                try {            v1.checkVectorDimensions(v4_2);             fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }            }    public void testPredicates() {        ArrayRealVector v = new ArrayRealVector(new double[] { 0, 1, 2 });        assertFalse(v.isNaN());        v.setEntry(1, Double.NaN);        assertTrue(v.isNaN());        assertFalse(v.isInfinite());        v.setEntry(0, Double.POSITIVE_INFINITY);        assertFalse(v.isInfinite());        v.setEntry(1, 1);        assertTrue(v.isInfinite());        v.setEntry(0, 0);        assertEquals(v, new ArrayRealVector(new double[] { 0, 1, 2 }));        assertNotSame(v, new ArrayRealVector(new double[] { 0, 1, 2 + Math.ulp(2)}));        assertNotSame(v, new ArrayRealVector(new double[] { 0, 1, 2, 3 }));        assertEquals(new ArrayRealVector(new double[] { Double.NaN, 1, 2 }).hashCode(),                     new ArrayRealVector(new double[] { 0, Double.NaN, 2 }).hashCode());        assertTrue(new ArrayRealVector(new double[] { Double.NaN, 1, 2 }).hashCode() !=                   new ArrayRealVector(new double[] { 0, 1, 2 }).hashCode());    }    public void testSerial()  {        ArrayRealVector v = new ArrayRealVector(new double[] { 0, 1, 2 });        assertEquals(v,TestUtils.serializeAndRecover(v));    }            /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, double[] m, double[] n,            double tolerance) {        if (m.length != n.length) {            fail("vectors have different lengths");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " +  i + " elements differ", m[i],n[i],tolerance);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Random;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.linear.DecompositionSolver;import org.apache.commons.math.linear.EigenDecompositionImpl;import org.apache.commons.math.linear.InvalidMatrixException;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.ArrayRealVector;import org.apache.commons.math.util.MathUtils;public class EigenSolverTest extends TestCase {    private double[] refValues;    private RealMatrix matrix;    public EigenSolverTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(EigenSolverTest.class);        suite.setName("EigenSolver Tests");        return suite;    }    /** test non invertible matrix */    public void testNonInvertible() {        Random r = new Random(9994100315209l);        RealMatrix m =            EigenDecompositionImplTest.createTestMatrix(r, new double[] { 1.0, 0.0, -1.0, -2.0, -3.0 });        DecompositionSolver es = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN).getSolver();        assertFalse(es.isNonSingular());        try {            es.getInverse();            fail("an exception should have been thrown");        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test invertible matrix */    public void testInvertible() {        Random r = new Random(9994100315209l);        RealMatrix m =            EigenDecompositionImplTest.createTestMatrix(r, new double[] { 1.0, 0.5, -1.0, -2.0, -3.0 });        DecompositionSolver es = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN).getSolver();        assertTrue(es.isNonSingular());        RealMatrix inverse = es.getInverse();        RealMatrix error =            m.multiply(inverse).subtract(MatrixUtils.createRealIdentityMatrix(m.getRowDimension()));        assertEquals(0, error.getNorm(), 4.0e-15);    }    /** test solve dimension errors */    public void testSolveDimensionErrors() {        DecompositionSolver es = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);        try {            es.solve(b);            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            es.solve(b.getColumn(0));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            es.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test solve */    public void testSolve() {        RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {                { 91,  5, 29, 32, 40, 14 },                {  5, 34, -1,  0,  2, -1 },                { 29, -1, 12,  9, 21,  8 },                { 32,  0,  9, 14,  9,  0 },                { 40,  2, 21,  9, 51, 19 },                { 14, -1,  8,  0, 19, 14 }        });        DecompositionSolver es = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                { 1561, 269, 188 },                {   69, -21,  70 },                {  739, 108,  63 },                {  324,  86,  59 },                { 1624, 194, 107 },                {  796,  69,  36 }        });        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                { 1,   2, 1 },                { 2,  -1, 2 },                { 4,   2, 3 },                { 8,  -1, 0 },                { 16,  2, 0 },                { 32, -1, 0 }        });        // using RealMatrix        assertEquals(0, es.solve(b).subtract(xRef).getNorm(), 2.0e-12);        // using double[]        for (int i = 0; i < b.getColumnDimension(); ++i) {            assertEquals(0,                         new ArrayRealVector(es.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),                         2.0e-11);        }        // using Array2DRowRealMatrix        for (int i = 0; i < b.getColumnDimension(); ++i) {            assertEquals(0,                         es.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),                         2.0e-11);        }        // using RealMatrix with an alternate implementation        for (int i = 0; i < b.getColumnDimension(); ++i) {            ArrayRealVectorTest.RealVectorTestImpl v =                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));            assertEquals(0,                         es.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),                         2.0e-11);        }    }    @Override    public void setUp() {        refValues = new double[] {                2.003, 2.002, 2.001, 1.001, 1.000, 0.001        };        matrix = EigenDecompositionImplTest.createTestMatrix(new Random(35992629946426l), refValues);    }    @Override    public void tearDown() {        refValues = null;        matrix    = null;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Locale;public class FrenchRealVectorFormatTest extends RealVectorFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return ',';    }    @Override    protected Locale getLocale() {        return Locale.FRENCH;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;/** * Test cases for the {@link RealMatrixImpl} class. * * @version $Revision$ $Date$ */@Deprecatedpublic final class RealMatrixImplTest extends TestCase {        // 3 x 3 identity matrix    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };        // Test data for group operations    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},        {-1d,0d,-8d} };    protected double[] testDataRow1 = {1d,2d,3d};    protected double[] testDataCol3 = {3d,3d,8d};    protected double[][] testDataInv =         { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };    protected double[] preMultTest = {8,12,33};    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};    protected double[][] testDataPlusInv =         { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };        // lu decomposition tests    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},            {0.33333333333333,0d,0.33333333333333} };        // singular matrices    protected double[][] singular = { {2d,3d}, {2d,3d} };    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};        // vectors    protected double[] testVector = {1,2,3};    protected double[] testVector2 = {1,2,3,4};        // submatrix accessor tests    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},            {2, 4, 6, 8}, {4, 5, 6, 7}};     // array selections    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};    // effective permutations    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};    // contiguous ranges    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};    protected double[][] subRows23Cols00 = {{2} , {4}};    protected double[][] subRows00Cols33 = {{4}};    // row matrices    protected double[][] subRow0 = {{1,2,3,4}};    protected double[][] subRow3 = {{4,5,6,7}};    // column matrices    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};        // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;        public RealMatrixImplTest(String name) {        super(name);    }        public static Test suite() {        TestSuite suite = new TestSuite(RealMatrixImplTest.class);        suite.setName("RealMatrixImpl Tests");        return suite;    }        /** test dimensions */    public void testDimensions() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());    }         /** test copy functions */    public void testCopyFunctions() {        RealMatrixImpl m1 = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(m1.getData());        assertEquals(m2,m1);        RealMatrixImpl m3 = new RealMatrixImpl(testData);        RealMatrixImpl m4 = new RealMatrixImpl(m3.getData(), false);        assertEquals(m4,m3);    }                   /** test add */    public void testAdd() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);        RealMatrix mPlusMInv = m.add(mInv);        double[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                    testDataPlusInv[row][col],sumEntries[row][col],                        entryTolerance);            }        }        }        /** test add failure */    public void testAddFail() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        try {            m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }    }        /** test norm */    public void testNorm() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertEquals("testData norm",14d,m.getNorm(),entryTolerance);        assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);    }        /** test Frobenius norm */    public void testFrobeniusNorm() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertEquals("testData Frobenius norm", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);        assertEquals("testData2 Frobenius norm", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);    }         /** test m-n = m + -n */    public void testPlusMinus() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testDataInv);        TestUtils.assertEquals("m-n = m + -n",m.subtract(m2),            m2.scalarMultiply(-1d).add(m),entryTolerance);                try {            m.subtract(new RealMatrixImpl(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }       /** test multiply */     public void testMultiply() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);        RealMatrixImpl identity = new RealMatrixImpl(id);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        TestUtils.assertEquals("inverse multiply",m.multiply(mInv),            identity,entryTolerance);        TestUtils.assertEquals("inverse multiply",mInv.multiply(m),            identity,entryTolerance);        TestUtils.assertEquals("identity multiply",m.multiply(identity),            m,entryTolerance);        TestUtils.assertEquals("identity multiply",identity.multiply(mInv),            mInv,entryTolerance);        TestUtils.assertEquals("identity multiply",m2.multiply(identity),            m2,entryTolerance);         try {            m.multiply(new RealMatrixImpl(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }           //Additional Test for RealMatrixImplTest.testMultiply    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};    private double[][] d4 = new double[][] {{1},{2},{3},{4}};    private double[][] d5 = new double[][] {{30},{70}};         public void testMultiply2() {        RealMatrix m3 = new RealMatrixImpl(d3);          RealMatrix m4 = new RealMatrixImpl(d4);       RealMatrix m5 = new RealMatrixImpl(d5);       TestUtils.assertEquals("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);   }              /** test trace */    public void testTrace() {        RealMatrix m = new RealMatrixImpl(id);        assertEquals("identity trace",3d,m.getTrace(),entryTolerance);        m = new RealMatrixImpl(testData2);        try {            m.getTrace();            fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }          }        /** test sclarAdd */    public void testScalarAdd() {        RealMatrix m = new RealMatrixImpl(testData);        TestUtils.assertEquals("scalar add",new RealMatrixImpl(testDataPlus2),            m.scalarAdd(2d),entryTolerance);    }                        /** test operate */    public void testOperate() {        RealMatrix m = new RealMatrixImpl(id);        TestUtils.assertEquals("identity operate", testVector,                    m.operate(testVector), entryTolerance);        TestUtils.assertEquals("identity operate", testVector,                    m.operate(new ArrayRealVector(testVector)).getData(), entryTolerance);        m = new RealMatrixImpl(bigSingular);        try {            m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }    /** test issue MATH-209 */    public void testMath209() {        RealMatrix a = new RealMatrixImpl(new double[][] {                { 1, 2 }, { 3, 4 }, { 5, 6 }        }, false);        double[] b = a.operate(new double[] { 1, 1 });        assertEquals(a.getRowDimension(), b.length);        assertEquals( 3.0, b[0], 1.0e-12);        assertEquals( 7.0, b[1], 1.0e-12);        assertEquals(11.0, b[2], 1.0e-12);    }        /** test transpose */    public void testTranspose() {        RealMatrix m = new RealMatrixImpl(testData);         RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();        TestUtils.assertEquals("inverse-transpose", mIT, mTI, normTolerance);        m = new RealMatrixImpl(testData2);        RealMatrix mt = new RealMatrixImpl(testData2T);        TestUtils.assertEquals("transpose",mt,m.transpose(),normTolerance);    }        /** test preMultiply by vector */    public void testPremultiplyVector() {        RealMatrix m = new RealMatrixImpl(testData);        TestUtils.assertEquals("premultiply", m.preMultiply(testVector),                    preMultTest, normTolerance);        TestUtils.assertEquals("premultiply", m.preMultiply(new ArrayRealVector(testVector).getData()),                    preMultTest, normTolerance);        m = new RealMatrixImpl(bigSingular);        try {            m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }        public void testPremultiply() {        RealMatrix m3 = new RealMatrixImpl(d3);           RealMatrix m4 = new RealMatrixImpl(d4);        RealMatrix m5 = new RealMatrixImpl(d5);        TestUtils.assertEquals("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);                RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);        RealMatrixImpl identity = new RealMatrixImpl(id);        TestUtils.assertEquals("inverse multiply",m.preMultiply(mInv),                identity,entryTolerance);        TestUtils.assertEquals("inverse multiply",mInv.preMultiply(m),                identity,entryTolerance);        TestUtils.assertEquals("identity multiply",m.preMultiply(identity),                m,entryTolerance);        TestUtils.assertEquals("identity multiply",identity.preMultiply(mInv),                mInv,entryTolerance);        try {            m.preMultiply(new RealMatrixImpl(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }        public void testGetVectors() {        RealMatrix m = new RealMatrixImpl(testData);        TestUtils.assertEquals("get row",m.getRow(0),testDataRow1,entryTolerance);        TestUtils.assertEquals("get col",m.getColumn(2),testDataCol3,entryTolerance);        try {            m.getRow(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }        try {            m.getColumn(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }    }        public void testGetEntry() {        RealMatrix m = new RealMatrixImpl(testData);        assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);        try {            m.getEntry(10, 4);            fail ("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }            /** test examples in user guide */    public void testExamples() {        // Create a real matrix with two rows and three columns        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};        RealMatrix m = new RealMatrixImpl(matrixData);        // One more with three rows, two columns        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};        RealMatrix n = new RealMatrixImpl(matrixData2);        // Now multiply m by n        RealMatrix p = m.multiply(n);        assertEquals(2, p.getRowDimension());        assertEquals(2, p.getColumnDimension());        // Invert p        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();         assertEquals(2, pInverse.getRowDimension());        assertEquals(2, pInverse.getColumnDimension());                // Solve example        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};        RealMatrix coefficients = new RealMatrixImpl(coefficientsData);        double[] constants = {1, -2, 1};        double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);               }        // test submatrix accessors    public void testGetSubMatrix() {        RealMatrix m = new RealMatrixImpl(subTestData);        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);           checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);          checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);          checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);         checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int startRow, int endRow, int startColumn, int endColumn,                                   boolean mustFail) {        try {            RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);            assertEquals(new RealMatrixImpl(reference), sub);            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }        private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int[] selectedRows, int[] selectedColumns,                                   boolean mustFail) {        try {            RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);            assertEquals(new RealMatrixImpl(reference), sub);            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    public void testCopySubMatrix() {        RealMatrix m = new RealMatrixImpl(subTestData);        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);           checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);          checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);          checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);         checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);                 checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, -1, 1, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkCopy(RealMatrix m, double[][] reference,                           int startRow, int endRow, int startColumn, int endColumn,                           boolean mustFail) {        try {            double[][] sub = (reference == null) ?                             new double[1][1] :                             new double[reference.length][reference[0].length];            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);            assertEquals(new RealMatrixImpl(reference), new RealMatrixImpl(sub));            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }        private void checkCopy(RealMatrix m, double[][] reference,                           int[] selectedRows, int[] selectedColumns,                           boolean mustFail) {        try {            double[][] sub = (reference == null) ?                    new double[1][1] :                    new double[reference.length][reference[0].length];            m.copySubMatrix(selectedRows, selectedColumns, sub);            assertEquals(new RealMatrixImpl(reference), new RealMatrixImpl(sub));            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    public void testGetRowMatrix() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealMatrix mRow0 = new RealMatrixImpl(subRow0);        RealMatrix mRow3 = new RealMatrixImpl(subRow3);        assertEquals("Row0", mRow0,                 m.getRowMatrix(0));        assertEquals("Row3", mRow3,                 m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }        public void testSetRowMatrix() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealMatrix mRow3 = new RealMatrixImpl(subRow3);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowMatrix(0, mRow3);        assertEquals(mRow3, m.getRowMatrix(0));        try {            m.setRowMatrix(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowMatrix(0, m);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        public void testGetColumnMatrix() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealMatrix mColumn1 = new RealMatrixImpl(subColumn1);        RealMatrix mColumn3 = new RealMatrixImpl(subColumn3);        assertEquals("Column1", mColumn1,                 m.getColumnMatrix(1));        assertEquals("Column3", mColumn3,                 m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnMatrix() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealMatrix mColumn3 = new RealMatrixImpl(subColumn3);        assertNotSame(mColumn3, m.getColumnMatrix(1));        m.setColumnMatrix(1, mColumn3);        assertEquals(mColumn3, m.getColumnMatrix(1));        try {            m.setColumnMatrix(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnMatrix(0, m);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetRowVector() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealVector mRow0 = new ArrayRealVector(subRow0[0]);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        assertEquals("Row0", mRow0, m.getRowVector(0));        assertEquals("Row3", mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowVector() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowVector(0, mRow3);        assertEquals(mRow3, m.getRowVector(0));        try {            m.setRowVector(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowVector(0, new ArrayRealVector(5));            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        public void testGetColumnVector() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealVector mColumn1 = columnToVector(subColumn1);        RealVector mColumn3 = columnToVector(subColumn3);        assertEquals("Column1", mColumn1, m.getColumnVector(1));        assertEquals("Column3", mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnVector() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealVector mColumn3 = columnToVector(subColumn3);        assertNotSame(mColumn3, m.getColumnVector(1));        m.setColumnVector(1, mColumn3);        assertEquals(mColumn3, m.getColumnVector(1));        try {            m.setColumnVector(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnVector(0, new ArrayRealVector(5));            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    private RealVector columnToVector(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayRealVector(data, false);    }    public void testGetRow() {        RealMatrix m = new RealMatrixImpl(subTestData);        checkArrays(subRow0[0], m.getRow(0));        checkArrays(subRow3[0], m.getRow(3));        try {            m.getRow(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRow(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRow() {        RealMatrix m = new RealMatrixImpl(subTestData);        assertTrue(subRow3[0][0] != m.getRow(0)[0]);        m.setRow(0, subRow3[0]);        checkArrays(subRow3[0], m.getRow(0));        try {            m.setRow(-1, subRow3[0]);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRow(0, new double[5]);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        public void testGetColumn() {        RealMatrix m = new RealMatrixImpl(subTestData);        double[] mColumn1 = columnToArray(subColumn1);        double[] mColumn3 = columnToArray(subColumn3);        checkArrays(mColumn1, m.getColumn(1));        checkArrays(mColumn3, m.getColumn(3));        try {            m.getColumn(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumn(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumn() {        RealMatrix m = new RealMatrixImpl(subTestData);        double[] mColumn3 = columnToArray(subColumn3);        assertTrue(mColumn3[0] != m.getColumn(1)[0]);        m.setColumn(1, mColumn3);        checkArrays(mColumn3, m.getColumn(1));        try {            m.setColumn(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumn(0, new double[5]);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    private double[] columnToArray(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return data;    }    private void checkArrays(double[] expected, double[] actual) {        assertEquals(expected.length, actual.length);        for (int i = 0; i < expected.length; ++i) {            assertEquals(expected[i], actual[i]);                    }    }        public void testEqualsAndHashCode() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m1 = (RealMatrixImpl) m.copy();        RealMatrixImpl mt = (RealMatrixImpl) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(new RealMatrixImpl(bigSingular)));     }        public void testToString() {        RealMatrixImpl m = new RealMatrixImpl(testData);        assertEquals("RealMatrixImpl{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",                m.toString());        m = new RealMatrixImpl();        assertEquals("RealMatrixImpl{}",                m.toString());    }        public void testSetSubMatrix() throws Exception {        RealMatrixImpl m = new RealMatrixImpl(testData);        m.setSubMatrix(detData2,1,1);        RealMatrix expected = MatrixUtils.createRealMatrix            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);                  m.setSubMatrix(detData2,0,0);        expected = MatrixUtils.createRealMatrix            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);                  m.setSubMatrix(testDataPlus2,0,0);              expected = MatrixUtils.createRealMatrix            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});        assertEquals(expected, m);                   // dimension overflow        try {              m.setSubMatrix(testData,1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // dimension underflow        try {              m.setSubMatrix(testData,-1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        try {              m.setSubMatrix(testData,1,-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }                // null        try {            m.setSubMatrix(null,1,1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }        RealMatrixImpl m2 = new RealMatrixImpl();        try {            m2.setSubMatrix(testData,0,1);            fail("expecting IllegalStateException");        } catch (IllegalStateException e) {            // expected        }        try {            m2.setSubMatrix(testData,1,0);            fail("expecting IllegalStateException");        } catch (IllegalStateException e) {            // expected        }                // ragged        try {            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }               // empty        try {            m.setSubMatrix(new double[][] {{}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }            }    public void testWalk() {        int rows    = 150;        int columns = 75;        RealMatrix m = new RealMatrixImpl(rows, columns);        m.walkInRowOrder(new SetVisitor());        GetVisitor getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new RealMatrixImpl(rows, columns);        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);                                assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);                                assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new RealMatrixImpl(rows, columns);        m.walkInColumnOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new RealMatrixImpl(rows, columns);        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);                                assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);                                assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new RealMatrixImpl(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new RealMatrixImpl(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);                                assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);                                assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new RealMatrixImpl(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new RealMatrixImpl(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);                                assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);                                assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }    }    public void testSerial()  {        RealMatrixImpl m = new RealMatrixImpl(testData);        assertEquals(m,TestUtils.serializeAndRecover(m));    }            private static class SetVisitor extends DefaultRealMatrixChangingVisitor {        @Override        public double visit(int i, int j, double value) {            return i + j / 1024.0;        }    }    private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {        private int count = 0;        @Override        public void visit(int i, int j, double value) {            ++count;            assertEquals(i + j / 1024.0, value, 0.0);        }        public int getCount() {            return count;        }    }    //--------------- -----------------Protected methods        /** extracts the l  and u matrices from compact lu representation */    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) throws InvalidMatrixException {           if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||                lowerData.length != upperData.length                || lowerData.length != lu.getRowDimension()) {            throw new InvalidMatrixException("incorrect dimensions");        }            int n = lu.getRowDimension();        for (int i = 0; i < n; i++) {            for (int j = 0; j < n; j++) {                if (j < i) {                    lowerData[i][j] = lu.getEntry(i, j);                    upperData[i][j] = 0d;                } else if (i == j) {                    lowerData[i][j] = 1d;                    upperData[i][j] = lu.getEntry(i, j);                } else {                    lowerData[i][j] = 0d;                    upperData[i][j] = lu.getEntry(i, j);                }               }        }    }        /** Returns the result of applying the given row permutation to the matrix */    protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) {        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {            throw new IllegalArgumentException("dimension mismatch");        }        int n = matrix.getRowDimension();        int m = matrix.getColumnDimension();        double out[][] = new double[m][n];        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                out[i][j] = matrix.getEntry(permutation[i], j);            }        }        return new RealMatrixImpl(out);    }    //    /** Useful for debugging *///    private void dumpMatrix(RealMatrix m) {//          for (int i = 0; i < m.getRowDimension(); i++) {//              String os = "";//              for (int j = 0; j < m.getColumnDimension(); j++) {//                  os += m.getEntry(i, j) + " ";//              }//              System.out.println(os);//          }//    }        }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.math.BigDecimal;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.fraction.BigFraction;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionConversionException;import org.apache.commons.math.fraction.FractionField;/** * Test cases for the {@link MatrixUtils} class. * * @version $Revision$ $Date$ */public final class MatrixUtilsTest extends TestCase {        protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    protected double[][] nullMatrix = null;    protected double[] row = {1,2,3};    protected BigDecimal[] bigRow =         {new BigDecimal(1),new BigDecimal(2),new BigDecimal(3)};    protected String[] stringRow = {"1", "2", "3"};    protected Fraction[] fractionRow =         {new Fraction(1),new Fraction(2),new Fraction(3)};    protected double[][] rowMatrix = {{1,2,3}};    protected BigDecimal[][] bigRowMatrix =         {{new BigDecimal(1), new BigDecimal(2), new BigDecimal(3)}};    protected String[][] stringRowMatrix = {{"1", "2", "3"}};    protected Fraction[][] fractionRowMatrix =         {{new Fraction(1), new Fraction(2), new Fraction(3)}};    protected double[] col = {0,4,6};    protected BigDecimal[] bigCol =         {new BigDecimal(0),new BigDecimal(4),new BigDecimal(6)};    protected String[] stringCol = {"0","4","6"};    protected Fraction[] fractionCol =         {new Fraction(0),new Fraction(4),new Fraction(6)};    protected double[] nullDoubleArray = null;    protected double[][] colMatrix = {{0},{4},{6}};    protected BigDecimal[][] bigColMatrix =         {{new BigDecimal(0)},{new BigDecimal(4)},{new BigDecimal(6)}};    protected String[][] stringColMatrix = {{"0"}, {"4"}, {"6"}};    protected Fraction[][] fractionColMatrix =         {{new Fraction(0)},{new Fraction(4)},{new Fraction(6)}};        public MatrixUtilsTest(String name) {        super(name);    }        public static Test suite() {        TestSuite suite = new TestSuite(MatrixUtilsTest.class);        suite.setName("MatrixUtils Tests");        return suite;    }        public void testCreateRealMatrix() {        assertEquals(new BlockRealMatrix(testData),                 MatrixUtils.createRealMatrix(testData));        try {            MatrixUtils.createRealMatrix(new double[][] {{1}, {1,2}});  // ragged            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }         try {            MatrixUtils.createRealMatrix(new double[][] {{}, {}});  // no columns            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createRealMatrix(null);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }     }    public void testcreateFieldMatrix() {        assertEquals(new Array2DRowFieldMatrix<Fraction>(asFraction(testData)),                      MatrixUtils.createFieldMatrix(asFraction(testData)));        assertEquals(new Array2DRowFieldMatrix<Fraction>(fractionColMatrix),                      MatrixUtils.createFieldMatrix(fractionColMatrix));        try {            MatrixUtils.createFieldMatrix(asFraction(new double[][] {{1}, {1,2}}));  // ragged            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }         try {            MatrixUtils.createFieldMatrix(asFraction(new double[][] {{}, {}}));  // no columns            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createFieldMatrix((Fraction[][])null);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }     }    @Deprecated    public void testCreateBigMatrix() {        assertEquals(new BigMatrixImpl(testData),                 MatrixUtils.createBigMatrix(testData));        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), true),                 MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), false));        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), false),                 MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), true));        assertEquals(new BigMatrixImpl(bigColMatrix),                 MatrixUtils.createBigMatrix(bigColMatrix));        assertEquals(new BigMatrixImpl(stringColMatrix),                 MatrixUtils.createBigMatrix(stringColMatrix));        try {            MatrixUtils.createBigMatrix(new double[][] {{1}, {1,2}});  // ragged            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }         try {            MatrixUtils.createBigMatrix(new double[][] {{}, {}});  // no columns            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createBigMatrix(nullMatrix);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }     }            public void testCreateRowRealMatrix() {        assertEquals(MatrixUtils.createRowRealMatrix(row),                     new BlockRealMatrix(rowMatrix));        try {            MatrixUtils.createRowRealMatrix(new double[] {});  // empty            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createRowRealMatrix(null);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }     }        public void testCreateRowFieldMatrix() {        assertEquals(MatrixUtils.createRowFieldMatrix(asFraction(row)),                     new Array2DRowFieldMatrix<Fraction>(asFraction(rowMatrix)));        assertEquals(MatrixUtils.createRowFieldMatrix(fractionRow),                     new Array2DRowFieldMatrix<Fraction>(fractionRowMatrix));        try {            MatrixUtils.createRowFieldMatrix(new Fraction[] {});  // empty            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createRowFieldMatrix((Fraction[]) null);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }     }    @Deprecated    public void testCreateRowBigMatrix() {        assertEquals(MatrixUtils.createRowBigMatrix(row),                new BigMatrixImpl(rowMatrix));        assertEquals(MatrixUtils.createRowBigMatrix(bigRow),                new BigMatrixImpl(bigRowMatrix));        assertEquals(MatrixUtils.createRowBigMatrix(stringRow),                new BigMatrixImpl(stringRowMatrix));        try {            MatrixUtils.createRowBigMatrix(new double[] {});  // empty            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createRowBigMatrix(nullDoubleArray);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }     }    public void testCreateColumnRealMatrix() {        assertEquals(MatrixUtils.createColumnRealMatrix(col),                     new BlockRealMatrix(colMatrix));        try {            MatrixUtils.createColumnRealMatrix(new double[] {});  // empty            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createColumnRealMatrix(null);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }     }        public void testCreateColumnFieldMatrix() {        assertEquals(MatrixUtils.createColumnFieldMatrix(asFraction(col)),                     new Array2DRowFieldMatrix<Fraction>(asFraction(colMatrix)));        assertEquals(MatrixUtils.createColumnFieldMatrix(fractionCol),                     new Array2DRowFieldMatrix<Fraction>(fractionColMatrix));        try {            MatrixUtils.createColumnFieldMatrix(new Fraction[] {});  // empty            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createColumnFieldMatrix((Fraction[]) null);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }     }    @Deprecated    public void testCreateColumnBigMatrix() {        assertEquals(MatrixUtils.createColumnBigMatrix(col),                new BigMatrixImpl(colMatrix));        assertEquals(MatrixUtils.createColumnBigMatrix(bigCol),                new BigMatrixImpl(bigColMatrix));        assertEquals(MatrixUtils.createColumnBigMatrix(stringCol),                new BigMatrixImpl(stringColMatrix));                  try {            MatrixUtils.createColumnBigMatrix(new double[] {});  // empty            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createColumnBigMatrix(nullDoubleArray);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }     }    /**     * Verifies that the matrix is an identity matrix     */    protected void checkIdentityMatrix(RealMatrix m) {        for (int i = 0; i < m.getRowDimension(); i++) {            for (int j =0; j < m.getColumnDimension(); j++) {                if (i == j) {                    assertEquals(m.getEntry(i, j), 1d, 0);                } else {                    assertEquals(m.getEntry(i, j), 0d, 0);                }            }        }       }        public void testCreateIdentityMatrix() {        checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(3));        checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(2));        checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(1));        try {            MatrixUtils.createRealIdentityMatrix(0);        } catch (IllegalArgumentException ex) {            // expected        }    }        /**     * Verifies that the matrix is an identity matrix     */    protected void checkIdentityFieldMatrix(FieldMatrix<Fraction> m) {        for (int i = 0; i < m.getRowDimension(); i++) {            for (int j =0; j < m.getColumnDimension(); j++) {                if (i == j) {                    assertEquals(m.getEntry(i, j), Fraction.ONE);                } else {                    assertEquals(m.getEntry(i, j), Fraction.ZERO);                }            }        }       }        public void testcreateFieldIdentityMatrix() {        checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 3));        checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 2));        checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 1));        try {            MatrixUtils.createRealIdentityMatrix(0);        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testBigFractionConverter() {        BigFraction[][] bfData = {                { new BigFraction(1), new BigFraction(2), new BigFraction(3) },                { new BigFraction(2), new BigFraction(5), new BigFraction(3) },                { new BigFraction(1), new BigFraction(0), new BigFraction(8) }        };        FieldMatrix<BigFraction> m = new Array2DRowFieldMatrix<BigFraction>(bfData, false);        RealMatrix converted = MatrixUtils.bigFractionMatrixToRealMatrix(m);        RealMatrix reference = new Array2DRowRealMatrix(testData, false);        assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0);    }    public void testFractionConverter() {        Fraction[][] fData = {                { new Fraction(1), new Fraction(2), new Fraction(3) },                { new Fraction(2), new Fraction(5), new Fraction(3) },                { new Fraction(1), new Fraction(0), new Fraction(8) }        };        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(fData, false);        RealMatrix converted = MatrixUtils.fractionMatrixToRealMatrix(m);        RealMatrix reference = new Array2DRowRealMatrix(testData, false);        assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0);    }    public static final Fraction[][] asFraction(double[][] data) {        Fraction d[][] = new Fraction[data.length][];        try {            for (int i = 0; i < data.length; ++i) {                double[] dataI = data[i];                Fraction[] dI  = new Fraction[dataI.length];                for (int j = 0; j < dataI.length; ++j) {                    dI[j] = new Fraction(dataI[j]);                }                d[i] = dI;            }        } catch (FractionConversionException fce) {            fail(fce.getMessage());        }        return d;    }    public static final Fraction[] asFraction(double[] data) {        Fraction d[] = new Fraction[data.length];        try {            for (int i = 0; i < data.length; ++i) {                d[i] = new Fraction(data[i]);            }        } catch (FractionConversionException fce) {            fail(fce.getMessage());        }        return d;    }    /**     * Verifies that the matrix is an identity matrix     */    @Deprecated    protected void checkIdentityBigMatrix(BigMatrix m) {        for (int i = 0; i < m.getRowDimension(); i++) {            for (int j =0; j < m.getColumnDimension(); j++) {                if (i == j) {                    assertEquals(m.getEntry(i, j), BigMatrixImpl.ONE);                } else {                    assertEquals(m.getEntry(i, j), BigMatrixImpl.ZERO);                }            }        }       }    @Deprecated    public void testCreateBigIdentityMatrix() {        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(3));        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(2));        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(1));        try {            MatrixUtils.createRealIdentityMatrix(0);        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.apache.commons.math.linear.InvalidMatrixException;import org.apache.commons.math.linear.LUDecomposition;import org.apache.commons.math.linear.LUDecompositionImpl;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.RealMatrix;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;public class LUDecompositionImplTest extends TestCase {    private double[][] testData = {            { 1.0, 2.0, 3.0},            { 2.0, 5.0, 3.0},            { 1.0, 0.0, 8.0}    };    private double[][] testDataMinus = {            { -1.0, -2.0, -3.0},            { -2.0, -5.0, -3.0},            { -1.0,  0.0, -8.0}    };    private double[][] luData = {            { 2.0, 3.0, 3.0 },            { 0.0, 5.0, 7.0 },            { 6.0, 9.0, 8.0 }    };        // singular matrices    private double[][] singular = {            { 2.0, 3.0 },            { 2.0, 3.0 }    };    private double[][] bigSingular = {            { 1.0, 2.0,   3.0,    4.0 },            { 2.0, 5.0,   3.0,    4.0 },            { 7.0, 3.0, 256.0, 1930.0 },            { 3.0, 7.0,   6.0,    8.0 }    }; // 4th row = 1st + 2nd    private static final double entryTolerance = 10e-16;    private static final double normTolerance = 10e-14;    public LUDecompositionImplTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(LUDecompositionImplTest.class);        suite.setName("LUDecompositionImpl Tests");        return suite;    }    /** test dimensions */    public void testDimensions() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        LUDecomposition LU = new LUDecompositionImpl(matrix);        assertEquals(testData.length, LU.getL().getRowDimension());        assertEquals(testData.length, LU.getL().getColumnDimension());        assertEquals(testData.length, LU.getU().getRowDimension());        assertEquals(testData.length, LU.getU().getColumnDimension());        assertEquals(testData.length, LU.getP().getRowDimension());        assertEquals(testData.length, LU.getP().getColumnDimension());    }    /** test non-square matrix */    public void testNonSquare() {        try {            new LUDecompositionImpl(MatrixUtils.createRealMatrix(new double[3][2]));        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test PA = LU */    public void testPAEqualLU() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        LUDecomposition lu = new LUDecompositionImpl(matrix);        RealMatrix l = lu.getL();        RealMatrix u = lu.getU();        RealMatrix p = lu.getP();        double norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();        assertEquals(0, norm, normTolerance);        matrix = MatrixUtils.createRealMatrix(testDataMinus);        lu = new LUDecompositionImpl(matrix);        l = lu.getL();        u = lu.getU();        p = lu.getP();        norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();        assertEquals(0, norm, normTolerance);        matrix = MatrixUtils.createRealIdentityMatrix(17);        lu = new LUDecompositionImpl(matrix);        l = lu.getL();        u = lu.getU();        p = lu.getP();        norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();        assertEquals(0, norm, normTolerance);        matrix = MatrixUtils.createRealMatrix(singular);        lu = new LUDecompositionImpl(matrix);        assertFalse(lu.getSolver().isNonSingular());        assertNull(lu.getL());        assertNull(lu.getU());        assertNull(lu.getP());        matrix = MatrixUtils.createRealMatrix(bigSingular);        lu = new LUDecompositionImpl(matrix);        assertFalse(lu.getSolver().isNonSingular());        assertNull(lu.getL());        assertNull(lu.getU());        assertNull(lu.getP());    }    /** test that L is lower triangular with unit diagonal */    public void testLLowerTriangular() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        RealMatrix l = new LUDecompositionImpl(matrix).getL();        for (int i = 0; i < l.getRowDimension(); i++) {            assertEquals(l.getEntry(i, i), 1, entryTolerance);            for (int j = i + 1; j < l.getColumnDimension(); j++) {                assertEquals(l.getEntry(i, j), 0, entryTolerance);            }        }    }    /** test that U is upper triangular */    public void testUUpperTriangular() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        RealMatrix u = new LUDecompositionImpl(matrix).getU();        for (int i = 0; i < u.getRowDimension(); i++) {            for (int j = 0; j < i; j++) {                assertEquals(u.getEntry(i, j), 0, entryTolerance);            }        }    }    /** test that P is a permutation matrix */    public void testPPermutation() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        RealMatrix p   = new LUDecompositionImpl(matrix).getP();        RealMatrix ppT = p.multiply(p.transpose());        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(p.getRowDimension());        assertEquals(0, ppT.subtract(id).getNorm(), normTolerance);        for (int i = 0; i < p.getRowDimension(); i++) {            int zeroCount  = 0;            int oneCount   = 0;            int otherCount = 0;            for (int j = 0; j < p.getColumnDimension(); j++) {                final double e = p.getEntry(i, j);                if (e == 0) {                    ++zeroCount;                } else if (e == 1) {                    ++oneCount;                } else {                    ++otherCount;                }            }            assertEquals(p.getColumnDimension() - 1, zeroCount);            assertEquals(1, oneCount);            assertEquals(0, otherCount);        }        for (int j = 0; j < p.getColumnDimension(); j++) {            int zeroCount  = 0;            int oneCount   = 0;            int otherCount = 0;            for (int i = 0; i < p.getRowDimension(); i++) {                final double e = p.getEntry(i, j);                if (e == 0) {                    ++zeroCount;                } else if (e == 1) {                    ++oneCount;                } else {                    ++otherCount;                }            }            assertEquals(p.getRowDimension() - 1, zeroCount);            assertEquals(1, oneCount);            assertEquals(0, otherCount);        }    }    /** test singular */    public void testSingular() {        LUDecomposition lu =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData));        assertTrue(lu.getSolver().isNonSingular());        lu = new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular));        assertFalse(lu.getSolver().isNonSingular());        lu = new LUDecompositionImpl(MatrixUtils.createRealMatrix(bigSingular));        assertFalse(lu.getSolver().isNonSingular());    }    /** test matrices values */    public void testMatricesValues1() {       LUDecomposition lu =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData));        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {                { 1.0, 0.0, 0.0 },                { 0.5, 1.0, 0.0 },                { 0.5, 0.2, 1.0 }        });        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {                { 2.0,  5.0, 3.0 },                { 0.0, -2.5, 6.5 },                { 0.0,  0.0, 0.2 }        });        RealMatrix pRef = MatrixUtils.createRealMatrix(new double[][] {                { 0.0, 1.0, 0.0 },                { 0.0, 0.0, 1.0 },                { 1.0, 0.0, 0.0 }        });        int[] pivotRef = { 1, 2, 0 };        // check values against known references        RealMatrix l = lu.getL();        assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);        RealMatrix u = lu.getU();        assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);        RealMatrix p = lu.getP();        assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);        int[] pivot = lu.getPivot();        for (int i = 0; i < pivotRef.length; ++i) {            assertEquals(pivotRef[i], pivot[i]);        }        // check the same cached instance is returned the second time        assertTrue(l == lu.getL());        assertTrue(u == lu.getU());        assertTrue(p == lu.getP());            }    /** test matrices values */    public void testMatricesValues2() {       LUDecomposition lu =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(luData));        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {                {    1.0,    0.0, 0.0 },                {    0.0,    1.0, 0.0 },                { 1.0 / 3.0, 0.0, 1.0 }        });        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {                { 6.0, 9.0,    8.0    },                { 0.0, 5.0,    7.0    },                { 0.0, 0.0, 1.0 / 3.0 }        });        RealMatrix pRef = MatrixUtils.createRealMatrix(new double[][] {                { 0.0, 0.0, 1.0 },                { 0.0, 1.0, 0.0 },                { 1.0, 0.0, 0.0 }        });        int[] pivotRef = { 2, 1, 0 };        // check values against known references        RealMatrix l = lu.getL();        assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);        RealMatrix u = lu.getU();        assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);        RealMatrix p = lu.getP();        assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);        int[] pivot = lu.getPivot();        for (int i = 0; i < pivotRef.length; ++i) {            assertEquals(pivotRef[i], pivot[i]);        }        // check the same cached instance is returned the second time        assertTrue(l == lu.getL());        assertTrue(u == lu.getU());        assertTrue(p == lu.getP());            }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.apache.commons.math.Field;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionConversionException;import org.apache.commons.math.fraction.FractionField;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link SparseFieldMatrix} class. * * @version $Revision: 728186 $ $Date: 2009-04-20 11:42:11 -0700 (Mon, 20 Apr 2009) $ */public class SparseFieldMatrixTest extends TestCase {    // 3 x 3 identity matrix    protected Fraction[][] id = { {new Fraction(1), new Fraction(0), new Fraction(0) }, { new Fraction(0), new Fraction(1), new Fraction(0) }, { new Fraction(0), new Fraction(0), new Fraction(1) } };    // Test data for group operations    protected Fraction[][] testData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) },            { new Fraction(1), new Fraction(0), new Fraction(8) } };    protected Fraction[][] testDataLU = null;    protected Fraction[][] testDataPlus2 = { { new Fraction(3), new Fraction(4), new Fraction(5) }, { new Fraction(4), new Fraction(7), new Fraction(5) },            { new Fraction(3), new Fraction(2), new Fraction(10) } };    protected Fraction[][] testDataMinus = { { new Fraction(-1), new Fraction(-2), new Fraction(-3) },            { new Fraction(-2), new Fraction(-5), new Fraction(-3) }, { new Fraction(-1), new Fraction(0), new Fraction(-8) } };    protected Fraction[] testDataRow1 = { new Fraction(1), new Fraction(2), new Fraction(3) };    protected Fraction[] testDataCol3 = { new Fraction(3), new Fraction(3), new Fraction(8) };    protected Fraction[][] testDataInv = { { new Fraction(-40), new Fraction(16), new Fraction(9) }, { new Fraction(13), new Fraction(-5), new Fraction(-3) },            { new Fraction(5), new Fraction(-2), new Fraction(-1) } };    protected Fraction[] preMultTest = { new Fraction(8), new Fraction(12), new Fraction(33) };    protected Fraction[][] testData2 = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) } };    protected Fraction[][] testData2T = { { new Fraction(1), new Fraction(2) }, { new Fraction(2), new Fraction(5) }, { new Fraction(3), new Fraction(3) } };    protected Fraction[][] testDataPlusInv = { { new Fraction(-39), new Fraction(18), new Fraction(12) },            { new Fraction(15), new Fraction(0), new Fraction(0) }, { new Fraction(6), new Fraction(-2), new Fraction(7) } };    // lu decomposition tests    protected Fraction[][] luData = { { new Fraction(2), new Fraction(3), new Fraction(3) }, { new Fraction(0), new Fraction(5), new Fraction(7) }, { new Fraction(6), new Fraction(9), new Fraction(8) } };    protected Fraction[][] luDataLUDecomposition = null;    // singular matrices    protected Fraction[][] singular = { { new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(3) } };    protected Fraction[][] bigSingular = { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) },            { new Fraction(2), new Fraction(5), new Fraction(3), new Fraction(4) }, { new Fraction(7), new Fraction(3), new Fraction(256), new Fraction(1930) }, { new Fraction(3), new Fraction(7), new Fraction(6), new Fraction(8) } }; // 4th    // row    // =    // 1st    // +    // 2nd    protected Fraction[][] detData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(4), new Fraction(5), new Fraction(6) },            { new Fraction(7), new Fraction(8), new Fraction(10) } };    protected Fraction[][] detData2 = { { new Fraction(1), new Fraction(3) }, { new Fraction(2), new Fraction(4) } };    // vectors    protected Fraction[] testVector = { new Fraction(1), new Fraction(2), new Fraction(3) };    protected Fraction[] testVector2 = { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) };    // submatrix accessor tests    protected Fraction[][] subTestData = null;    // array selections    protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4) }, { new Fraction(4), new Fraction(8) } };    protected Fraction[][] subRows03Cols12 = { { new Fraction(2), new Fraction(3) }, { new Fraction(5), new Fraction(6) } };    protected Fraction[][] subRows03Cols123 = { { new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7) } };    // effective permutations    protected Fraction[][] subRows20Cols123 = { { new Fraction(4), new Fraction(6), new Fraction(8) }, { new Fraction(2), new Fraction(3), new Fraction(4) } };    protected Fraction[][] subRows31Cols31 = null;    // contiguous ranges    protected Fraction[][] subRows01Cols23 = null;    protected Fraction[][] subRows23Cols00 = { { new Fraction(2) }, { new Fraction(4) } };    protected Fraction[][] subRows00Cols33 = { { new Fraction(4) } };    // row matrices    protected Fraction[][] subRow0 = { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) } };    protected Fraction[][] subRow3 = { { new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7) } };    // column matrices    protected Fraction[][] subColumn1 = null;    protected Fraction[][] subColumn3 = null;    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    protected Field<Fraction> field = FractionField.getInstance();    public SparseFieldMatrixTest(String name) {        super(name);        setupFractionArrays();    }    private void setupFractionArrays() {        try {            testDataLU = new Fraction[][]{ { new Fraction(2), new Fraction(5), new Fraction(3) }, { new Fraction(.5d), new Fraction(-2.5d), new Fraction(6.5d) },                    { new Fraction(0.5d), new Fraction(0.2d), new Fraction(.2d) } };            luDataLUDecomposition = new Fraction[][]{ { new Fraction(6), new Fraction(9), new Fraction(8) },                { new Fraction(0), new Fraction(5), new Fraction(7) }, { new Fraction(0.33333333333333), new Fraction(0), new Fraction(0.33333333333333) } };            subTestData = new Fraction [][]{ { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) },                    { new Fraction(1.5), new Fraction(2.5), new Fraction(3.5), new Fraction(4.5) }, { new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8) }, { new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7) } };            subRows31Cols31 = new Fraction[][]{ { new Fraction(7), new Fraction(5) }, { new Fraction(4.5), new Fraction(2.5) } };            subRows01Cols23 = new Fraction[][]{ { new Fraction(3), new Fraction(4) }, { new Fraction(3.5), new Fraction(4.5) } };            subColumn1 = new Fraction [][]{ { new Fraction(2) }, { new Fraction(2.5) }, { new Fraction(4) }, { new Fraction(5) } };            subColumn3 = new Fraction[][]{ { new Fraction(4) }, { new Fraction(4.5) }, { new Fraction(8) }, { new Fraction(7) } };        } catch (FractionConversionException e) {            // ignore, can't happen        }                            }    public static Test suite() {        TestSuite suite = new TestSuite(SparseFieldMatrixTest.class);        suite.setName("SparseFieldMatrix<Fraction> Tests");        return suite;    }    /** test dimensions */    public void testDimensions() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);        assertEquals("testData row dimension", 3, m.getRowDimension());        assertEquals("testData column dimension", 3, m.getColumnDimension());        assertTrue("testData is square", m.isSquare());        assertEquals("testData2 row dimension", m2.getRowDimension(), 2);        assertEquals("testData2 column dimension", m2.getColumnDimension(), 3);        assertTrue("testData2 is not square", !m2.isSquare());    }    /** test copy functions */    public void testCopyFunctions() {        SparseFieldMatrix<Fraction> m1 = createSparseMatrix(testData);        FieldMatrix<Fraction> m2 = m1.copy();        assertTrue(m2 instanceof SparseFieldMatrix);        assertEquals((m2), m1);        SparseFieldMatrix<Fraction> m3 = createSparseMatrix(testData);        FieldMatrix<Fraction> m4 = m3.copy();        assertTrue(m4 instanceof SparseFieldMatrix);        assertEquals((m4), m3);    }    /** test add */    public void testAdd() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv);        SparseFieldMatrix<Fraction> mDataPlusInv = createSparseMatrix(testDataPlusInv);        FieldMatrix<Fraction> mPlusMInv = m.add(mInv);        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                     mDataPlusInv.getEntry(row, col).doubleValue(), mPlusMInv.getEntry(row, col).doubleValue(),                     entryTolerance);            }        }    }    /** test add failure */    public void testAddFail() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);        try {            m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }    }        /** test m-n = m + -n */    public void testPlusMinus() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> n = createSparseMatrix(testDataInv);        assertClose("m-n = m + -n", m.subtract(n),            n.scalarMultiply(new Fraction(-1)).add(m), entryTolerance);        try {            m.subtract(createSparseMatrix(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test multiply */    public void testMultiply() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv);        SparseFieldMatrix<Fraction> identity = createSparseMatrix(id);        SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);        assertClose("inverse multiply", m.multiply(mInv), identity,                entryTolerance);        assertClose("inverse multiply", m.multiply(new Array2DRowFieldMatrix<Fraction>(testDataInv)), identity,                    entryTolerance);        assertClose("inverse multiply", mInv.multiply(m), identity,                entryTolerance);        assertClose("identity multiply", m.multiply(identity), m,                entryTolerance);        assertClose("identity multiply", identity.multiply(mInv), mInv,                entryTolerance);        assertClose("identity multiply", m2.multiply(identity), m2,                entryTolerance);        try {            m.multiply(createSparseMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    // Additional Test for Array2DRowRealMatrixTest.testMultiply    private Fraction[][] d3 = new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8) } };    private Fraction[][] d4 = new Fraction[][] { { new Fraction(1) }, { new Fraction(2) }, { new Fraction(3) }, { new Fraction(4) } };    private Fraction[][] d5 = new Fraction[][] { { new Fraction(30) }, { new Fraction(70) } };    public void testMultiply2() {        FieldMatrix<Fraction> m3 = createSparseMatrix(d3);        FieldMatrix<Fraction> m4 = createSparseMatrix(d4);        FieldMatrix<Fraction> m5 = createSparseMatrix(d5);        assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);    }    /** test trace */    public void testTrace() {        FieldMatrix<Fraction> m = createSparseMatrix(id);        assertEquals("identity trace", 3d, m.getTrace().doubleValue(), entryTolerance);        m = createSparseMatrix(testData2);        try {            m.getTrace();            fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }    }    /** test sclarAdd */    public void testScalarAdd() {        FieldMatrix<Fraction> m = createSparseMatrix(testData);        assertClose("scalar add", createSparseMatrix(testDataPlus2),             m.scalarAdd(new Fraction(2)), entryTolerance);    }    /** test operate */    public void testOperate() {        FieldMatrix<Fraction> m = createSparseMatrix(id);        assertClose("identity operate", testVector, m.operate(testVector),                entryTolerance);        assertClose("identity operate", testVector, m.operate(                new ArrayFieldVector<Fraction>(testVector)).getData(), entryTolerance);        m = createSparseMatrix(bigSingular);        try {            m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test issue MATH-209 */    public void testMath209() {        FieldMatrix<Fraction> a = createSparseMatrix(new Fraction[][] {                { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } });        Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });        assertEquals(a.getRowDimension(), b.length);        assertEquals(3.0, b[0].doubleValue(), 1.0e-12);        assertEquals(7.0, b[1].doubleValue(), 1.0e-12);        assertEquals(11.0, b[2].doubleValue(), 1.0e-12);    }    /** test transpose */    public void testTranspose() {                FieldMatrix<Fraction> m = createSparseMatrix(testData);         FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();        assertClose("inverse-transpose", mIT, mTI, normTolerance);        m = createSparseMatrix(testData2);        FieldMatrix<Fraction> mt = createSparseMatrix(testData2T);        assertClose("transpose",mt,m.transpose(),normTolerance);    }    /** test preMultiply by vector */    public void testPremultiplyVector() {        FieldMatrix<Fraction> m = createSparseMatrix(testData);        assertClose("premultiply", m.preMultiply(testVector), preMultTest,            normTolerance);        assertClose("premultiply", m.preMultiply(            new ArrayFieldVector<Fraction>(testVector).getData()), preMultTest, normTolerance);        m = createSparseMatrix(bigSingular);        try {            m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testPremultiply() {        FieldMatrix<Fraction> m3 = createSparseMatrix(d3);        FieldMatrix<Fraction> m4 = createSparseMatrix(d4);        FieldMatrix<Fraction> m5 = createSparseMatrix(d5);        assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv);        SparseFieldMatrix<Fraction> identity = createSparseMatrix(id);        assertClose("inverse multiply", m.preMultiply(mInv), identity,                entryTolerance);        assertClose("inverse multiply", mInv.preMultiply(m), identity,                entryTolerance);        assertClose("identity multiply", m.preMultiply(identity), m,                entryTolerance);        assertClose("identity multiply", identity.preMultiply(mInv), mInv,                entryTolerance);        try {            m.preMultiply(createSparseMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testGetVectors() {        FieldMatrix<Fraction> m = createSparseMatrix(testData);        assertClose("get row", m.getRow(0), testDataRow1, entryTolerance);        assertClose("get col", m.getColumn(2), testDataCol3, entryTolerance);        try {            m.getRow(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }        try {            m.getColumn(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }    }    public void testGetEntry() {        FieldMatrix<Fraction> m = createSparseMatrix(testData);        assertEquals("get entry", m.getEntry(0, 1).doubleValue(), 2d, entryTolerance);        try {            m.getEntry(10, 4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    /** test examples in user guide */    public void testExamples() {        // Create a real matrix with two rows and three columns        Fraction[][] matrixData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) } };        FieldMatrix<Fraction> m = createSparseMatrix(matrixData);        // One more with three rows, two columns        Fraction[][] matrixData2 = { { new Fraction(1), new Fraction(2) }, { new Fraction(2), new Fraction(5) }, { new Fraction(1), new Fraction(7) } };        FieldMatrix<Fraction> n = createSparseMatrix(matrixData2);        // Now multiply m by n        FieldMatrix<Fraction> p = m.multiply(n);        assertEquals(2, p.getRowDimension());        assertEquals(2, p.getColumnDimension());        // Invert p        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();         assertEquals(2, pInverse.getRowDimension());        assertEquals(2, pInverse.getColumnDimension());        // Solve example        Fraction[][] coefficientsData = { { new Fraction(2), new Fraction(3), new Fraction(-2) }, { new Fraction(-1), new Fraction(7), new Fraction(6) },                { new Fraction(4), new Fraction(-3), new Fraction(-5) } };        FieldMatrix<Fraction> coefficients = createSparseMatrix(coefficientsData);        Fraction[] constants = { new Fraction(1), new Fraction(-2), new Fraction(1) };        Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);        assertEquals((new Fraction(2).multiply((solution[0])).add(new Fraction(3).multiply(solution[1])).subtract(new Fraction(2).multiply(solution[2]))).doubleValue(),                constants[0].doubleValue(), 1E-12);        assertEquals(((new Fraction(-1).multiply(solution[0])).add(new Fraction(7).multiply(solution[1])).add(new Fraction(6).multiply(solution[2]))).doubleValue(),                constants[1].doubleValue(), 1E-12);        assertEquals(((new Fraction(4).multiply(solution[0])).subtract(new Fraction(3).multiply( solution[1])).subtract(new Fraction(5).multiply(solution[2]))).doubleValue(),                constants[2].doubleValue(), 1E-12);    }    // test submatrix accessors    public void testSubMatrix() {        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);        FieldMatrix<Fraction> mRows23Cols00 = createSparseMatrix(subRows23Cols00);        FieldMatrix<Fraction> mRows00Cols33 = createSparseMatrix(subRows00Cols33);        FieldMatrix<Fraction> mRows01Cols23 = createSparseMatrix(subRows01Cols23);        FieldMatrix<Fraction> mRows02Cols13 = createSparseMatrix(subRows02Cols13);        FieldMatrix<Fraction> mRows03Cols12 = createSparseMatrix(subRows03Cols12);        FieldMatrix<Fraction> mRows03Cols123 = createSparseMatrix(subRows03Cols123);        FieldMatrix<Fraction> mRows20Cols123 = createSparseMatrix(subRows20Cols123);        FieldMatrix<Fraction> mRows31Cols31 = createSparseMatrix(subRows31Cols31);        assertEquals("Rows23Cols00", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));        assertEquals("Rows00Cols33", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));        assertEquals("Rows01Cols23", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));        assertEquals("Rows02Cols13", mRows02Cols13,             m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 }));        assertEquals("Rows03Cols12", mRows03Cols12,             m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 }));        assertEquals("Rows03Cols123", mRows03Cols123,             m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 }));        assertEquals("Rows20Cols123", mRows20Cols123,             m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 }));        assertEquals("Rows31Cols31", mRows31Cols31,             m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));        assertEquals("Rows31Cols31", mRows31Cols31,             m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));        try {            m.getSubMatrix(1, 0, 2, 4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(-1, 1, 2, 2);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(1, 0, 2, 2);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(1, 0, 2, 4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(new int[] {}, new int[] { 0 });            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(new int[] { 0 }, new int[] { 4 });            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetRowMatrix() {        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);        FieldMatrix<Fraction> mRow0 = createSparseMatrix(subRow0);        FieldMatrix<Fraction> mRow3 = createSparseMatrix(subRow3);        assertEquals("Row0", mRow0, m.getRowMatrix(0));        assertEquals("Row3", mRow3, m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetColumnMatrix() {        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);        FieldMatrix<Fraction> mColumn1 = createSparseMatrix(subColumn1);        FieldMatrix<Fraction> mColumn3 = createSparseMatrix(subColumn3);        assertEquals("Column1", mColumn1, m.getColumnMatrix(1));        assertEquals("Column3", mColumn3, m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetRowVector() {        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);        FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);        assertEquals("Row0", mRow0, m.getRowVector(0));        assertEquals("Row3", mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetColumnVector() {        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);        FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);        assertEquals("Column1", mColumn1, m.getColumnVector(1));        assertEquals("Column3", mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    private FieldVector<Fraction> columnToVector(Fraction[][] column) {        Fraction[] data = new Fraction[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayFieldVector<Fraction>(data, false);    }    public void testEqualsAndHashCode() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> m1 = (SparseFieldMatrix<Fraction>) m.copy();        SparseFieldMatrix<Fraction> mt = (SparseFieldMatrix<Fraction>) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(createSparseMatrix(bigSingular)));    }    /* Disable for now    public void testToString() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        assertEquals("SparseFieldMatrix<Fraction>{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",             m.toString());        m = new SparseFieldMatrix<Fraction>(field, 1, 1);        assertEquals("SparseFieldMatrix<Fraction>{{0.0}}", m.toString());    }    */    public void testSetSubMatrix() throws Exception {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        m.setSubMatrix(detData2, 1, 1);        FieldMatrix<Fraction> expected = createSparseMatrix(new Fraction[][] {                { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(1), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } });        assertEquals(expected, m);        m.setSubMatrix(detData2, 0, 0);        expected = createSparseMatrix(new Fraction[][] {                { new Fraction(1), new Fraction(3), new Fraction(3) }, { new Fraction(2), new Fraction(4), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } });        assertEquals(expected, m);        m.setSubMatrix(testDataPlus2, 0, 0);        expected = createSparseMatrix(new Fraction[][] {                { new Fraction(3), new Fraction(4), new Fraction(5) }, { new Fraction(4), new Fraction(7), new Fraction(5) }, { new Fraction(3), new Fraction(2), new Fraction(10) } });        assertEquals(expected, m);        // javadoc example        SparseFieldMatrix<Fraction> matrix =             createSparseMatrix(new Fraction[][] {         { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8) }, { new Fraction(9), new Fraction(0), new Fraction(1), new Fraction(2) } });        matrix.setSubMatrix(new Fraction[][] { { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } }, 1, 1);        expected = createSparseMatrix(new Fraction[][] {                { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8) }, { new Fraction(9), new Fraction(5), new Fraction(6), new Fraction(2) } });        assertEquals(expected, matrix);        // dimension overflow        try {            m.setSubMatrix(testData, 1, 1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // dimension underflow        try {            m.setSubMatrix(testData, -1, 1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        try {            m.setSubMatrix(testData, 1, -1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // null        try {            m.setSubMatrix(null, 1, 1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }        try {            new SparseFieldMatrix<Fraction>(field, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }        // ragged        try {            m.setSubMatrix(new Fraction[][] { { new Fraction(1) }, { new Fraction(2), new Fraction(3) } }, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }        // empty        try {            m.setSubMatrix(new Fraction[][] { {} }, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }    }    // --------------- -----------------Protected methods    /** verifies that two matrices are close (1-norm) */    protected void assertClose(String msg, FieldMatrix<Fraction> m, FieldMatrix<Fraction> n,            double tolerance) {        for(int i=0; i < m.getRowDimension(); i++){            for(int j=0; j < m.getColumnDimension(); j++){                assertEquals(msg, m.getEntry(i,j).doubleValue(), n.getEntry(i,j).doubleValue(), tolerance);            }                    }    }    /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, Fraction[] m, Fraction[] n,            double tolerance) {        if (m.length != n.length) {            fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " + i + " elements differ", m[i].doubleValue(), n[i].doubleValue(),                    tolerance);        }    }        private SparseFieldMatrix<Fraction> createSparseMatrix(Fraction[][] data) {        SparseFieldMatrix<Fraction> matrix = new SparseFieldMatrix<Fraction>(field, data.length, data[0].length);        for (int row = 0; row < data.length; row++) {            for (int col = 0; col < data[row].length; col++) {                matrix.setEntry(row, col, data[row][col]);            }        }        return matrix;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Arrays;import org.apache.commons.math.linear.InvalidMatrixException;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.TriDiagonalTransformer;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;public class TriDiagonalTransformerTest extends TestCase {    private double[][] testSquare5 = {            { 1, 2, 3, 1, 1 },            { 2, 1, 1, 3, 1 },            { 3, 1, 1, 1, 2 },            { 1, 3, 1, 2, 1 },            { 1, 1, 2, 1, 3 }    };    private double[][] testSquare3 = {            { 1, 3, 4 },            { 3, 2, 2 },            { 4, 2, 0 }    };    public TriDiagonalTransformerTest(String name) {        super(name);    }    public void testNonSquare() {        try {            new TriDiagonalTransformer(MatrixUtils.createRealMatrix(new double[3][2]));            fail("an exception should have been thrown");        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testAEqualQTQt() {        checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare5));        checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare3));    }    private void checkAEqualQTQt(RealMatrix matrix) {        TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);        RealMatrix q  = transformer.getQ();        RealMatrix qT = transformer.getQT();        RealMatrix t  = transformer.getT();        double norm = q.multiply(t).multiply(qT).subtract(matrix).getNorm();        assertEquals(0, norm, 4.0e-15);    }    public void testNoAccessBelowDiagonal() {        checkNoAccessBelowDiagonal(testSquare5);        checkNoAccessBelowDiagonal(testSquare3);    }    private void checkNoAccessBelowDiagonal(double[][] data) {        double[][] modifiedData = new double[data.length][];        for (int i = 0; i < data.length; ++i) {            modifiedData[i] = data[i].clone();            Arrays.fill(modifiedData[i], 0, i, Double.NaN);        }        RealMatrix matrix = MatrixUtils.createRealMatrix(modifiedData);        TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);        RealMatrix q  = transformer.getQ();        RealMatrix qT = transformer.getQT();        RealMatrix t  = transformer.getT();        double norm = q.multiply(t).multiply(qT).subtract(MatrixUtils.createRealMatrix(data)).getNorm();        assertEquals(0, norm, 4.0e-15);    }    public void testQOrthogonal() {        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQ());        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQ());    }    public void testQTOrthogonal() {        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQT());        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQT());    }    private void checkOrthogonal(RealMatrix m) {        RealMatrix mTm = m.transpose().multiply(m);        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());        assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-15);            }    public void testTTriDiagonal() {        checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getT());        checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getT());    }    private void checkTriDiagonal(RealMatrix m) {        final int rows = m.getRowDimension();        final int cols = m.getColumnDimension();        for (int i = 0; i < rows; ++i) {            for (int j = 0; j < cols; ++j) {                if ((i < j - 1) || (i > j + 1)) {                    assertEquals(0, m.getEntry(i, j), 1.0e-16);                }                                }        }    }    public void testMatricesValues5() {        checkMatricesValues(testSquare5,                            new double[][] {                                { 1.0,  0.0,                 0.0,                  0.0,                   0.0 },                                { 0.0, -0.5163977794943222,  0.016748280772542083, 0.839800693771262,     0.16669620021405473 },                                { 0.0, -0.7745966692414833, -0.4354553000860955,  -0.44989322880603355,  -0.08930153582895772 },                                { 0.0, -0.2581988897471611,  0.6364346693566014,  -0.30263204032131164,   0.6608313651342882 },                                { 0.0, -0.2581988897471611,  0.6364346693566009,  -0.027289660803112598, -0.7263191580755246 }                            },                            new double[] { 1, 4.4, 1.433099579242636, -0.89537362758743, 2.062274048344794 },                            new double[] { -Math.sqrt(15), -3.0832882879592476, 0.6082710842351517, 1.1786086405912128 });    }    public void testMatricesValues3() {        checkMatricesValues(testSquare3,                            new double[][] {                                {  1.0,  0.0,  0.0 },                                {  0.0, -0.6,  0.8 },                                {  0.0, -0.8, -0.6 },                            },                            new double[] { 1, 2.64, -0.64 },                            new double[] { -5, -1.52 });    }    private void checkMatricesValues(double[][] matrix, double[][] qRef,                                     double[] mainDiagnonal,                                     double[] secondaryDiagonal) {        TriDiagonalTransformer transformer =            new TriDiagonalTransformer(MatrixUtils.createRealMatrix(matrix));        // check values against known references        RealMatrix q = transformer.getQ();        assertEquals(0, q.subtract(MatrixUtils.createRealMatrix(qRef)).getNorm(), 1.0e-14);        RealMatrix t = transformer.getT();        double[][] tData = new double[mainDiagnonal.length][mainDiagnonal.length];        for (int i = 0; i < mainDiagnonal.length; ++i) {            tData[i][i] = mainDiagnonal[i];            if (i > 0) {                tData[i][i - 1] = secondaryDiagonal[i - 1];            }            if (i < secondaryDiagonal.length) {                tData[i][i + 1] = secondaryDiagonal[i];            }        }        assertEquals(0, t.subtract(MatrixUtils.createRealMatrix(tData)).getNorm(), 1.0e-14);        // check the same cached instance is returned the second time        assertTrue(q == transformer.getQ());        assertTrue(t == transformer.getT());            }    public static Test suite() {        return new TestSuite(TriDiagonalTransformerTest.class);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Arrays;import java.util.Random;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;/** * Test cases for the {@link BlockRealMatrix} class. * * @version $Revision$ $Date$ */public final class BlockRealMatrixTest extends TestCase {        // 3 x 3 identity matrix    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };        // Test data for group operations    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},        {-1d,0d,-8d} };    protected double[] testDataRow1 = {1d,2d,3d};    protected double[] testDataCol3 = {3d,3d,8d};    protected double[][] testDataInv =         { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };    protected double[] preMultTest = {8,12,33};    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};    protected double[][] testDataPlusInv =         { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };        // lu decomposition tests    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},            {0.33333333333333,0d,0.33333333333333} };        // singular matrices    protected double[][] singular = { {2d,3d}, {2d,3d} };    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};        // vectors    protected double[] testVector = {1,2,3};    protected double[] testVector2 = {1,2,3,4};        // submatrix accessor tests    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},            {2, 4, 6, 8}, {4, 5, 6, 7}};     // array selections    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};    // effective permutations    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};    // contiguous ranges    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};    protected double[][] subRows23Cols00 = {{2} , {4}};    protected double[][] subRows00Cols33 = {{4}};    // row matrices    protected double[][] subRow0 = {{1,2,3,4}};    protected double[][] subRow3 = {{4,5,6,7}};    // column matrices    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};        // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;        public BlockRealMatrixTest(String name) {        super(name);    }        public static Test suite() {        TestSuite suite = new TestSuite(BlockRealMatrixTest.class);        suite.setName("BlockRealMatrix Tests");        return suite;    }        /** test dimensions */    public void testDimensions() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m2 = new BlockRealMatrix(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());    }         /** test copy functions */    public void testCopyFunctions() {        Random r = new Random(66636328996002l);        BlockRealMatrix m1 = createRandomMatrix(r, 47, 83);        BlockRealMatrix m2 = new BlockRealMatrix(m1.getData());        assertEquals(m1, m2);        BlockRealMatrix m3 = new BlockRealMatrix(testData);        BlockRealMatrix m4 = new BlockRealMatrix(m3.getData());        assertEquals(m3, m4);    }                   /** test add */    public void testAdd() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);        RealMatrix mPlusMInv = m.add(mInv);        double[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                    testDataPlusInv[row][col],sumEntries[row][col],                        entryTolerance);            }        }        }        /** test add failure */    public void testAddFail() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m2 = new BlockRealMatrix(testData2);        try {            m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }    }        /** test norm */    public void testNorm() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m2 = new BlockRealMatrix(testData2);        assertEquals("testData norm",14d,m.getNorm(),entryTolerance);        assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);    }        /** test Frobenius norm */    public void testFrobeniusNorm() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m2 = new BlockRealMatrix(testData2);        assertEquals("testData Frobenius norm", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);        assertEquals("testData2 Frobenius norm", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);    }         /** test m-n = m + -n */    public void testPlusMinus() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m2 = new BlockRealMatrix(testDataInv);        assertClose(m.subtract(m2), m2.scalarMultiply(-1d).add(m), entryTolerance);                try {            m.subtract(new BlockRealMatrix(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }       /** test multiply */     public void testMultiply() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);        BlockRealMatrix identity = new BlockRealMatrix(id);        BlockRealMatrix m2 = new BlockRealMatrix(testData2);        assertClose(m.multiply(mInv), identity, entryTolerance);        assertClose(mInv.multiply(m), identity, entryTolerance);        assertClose(m.multiply(identity), m, entryTolerance);        assertClose(identity.multiply(mInv), mInv, entryTolerance);        assertClose(m2.multiply(identity), m2, entryTolerance);         try {            m.multiply(new BlockRealMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }          }    public void testSeveralBlocks() {        RealMatrix m = new BlockRealMatrix(35, 71);        for (int i = 0; i < m.getRowDimension(); ++i) {            for (int j = 0; j < m.getColumnDimension(); ++j) {                m.setEntry(i, j, i + j / 1024.0);            }        }        RealMatrix mT = m.transpose();        assertEquals(m.getRowDimension(), mT.getColumnDimension());        assertEquals(m.getColumnDimension(), mT.getRowDimension());        for (int i = 0; i < mT.getRowDimension(); ++i) {            for (int j = 0; j < mT.getColumnDimension(); ++j) {                assertEquals(m.getEntry(j, i), mT.getEntry(i, j), 0);            }        }        RealMatrix mPm = m.add(m);        for (int i = 0; i < mPm.getRowDimension(); ++i) {            for (int j = 0; j < mPm.getColumnDimension(); ++j) {                assertEquals(2 * m.getEntry(i, j), mPm.getEntry(i, j), 0);            }        }        RealMatrix mPmMm = mPm.subtract(m);        for (int i = 0; i < mPmMm.getRowDimension(); ++i) {            for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {                assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j), 0);            }        }        RealMatrix mTm = mT.multiply(m);        for (int i = 0; i < mTm.getRowDimension(); ++i) {            for (int j = 0; j < mTm.getColumnDimension(); ++j) {                double sum = 0;                for (int k = 0; k < mT.getColumnDimension(); ++k) {                    sum += (k + i / 1024.0) * (k + j / 1024.0);                }                assertEquals(sum, mTm.getEntry(i, j), 0);            }        }        RealMatrix mmT = m.multiply(mT);        for (int i = 0; i < mmT.getRowDimension(); ++i) {            for (int j = 0; j < mmT.getColumnDimension(); ++j) {                double sum = 0;                for (int k = 0; k < m.getColumnDimension(); ++k) {                    sum += (i + k / 1024.0) * (j + k / 1024.0);                }                assertEquals(sum, mmT.getEntry(i, j), 0);            }        }        RealMatrix sub1 = m.getSubMatrix(2, 9, 5, 20);        for (int i = 0; i < sub1.getRowDimension(); ++i) {            for (int j = 0; j < sub1.getColumnDimension(); ++j) {                assertEquals((i + 2) + (j + 5) / 1024.0, sub1.getEntry(i, j), 0);            }        }        RealMatrix sub2 = m.getSubMatrix(10, 12, 3, 70);        for (int i = 0; i < sub2.getRowDimension(); ++i) {            for (int j = 0; j < sub2.getColumnDimension(); ++j) {                assertEquals((i + 10) + (j + 3) / 1024.0, sub2.getEntry(i, j), 0);            }        }        RealMatrix sub3 = m.getSubMatrix(30, 34, 0, 5);        for (int i = 0; i < sub3.getRowDimension(); ++i) {            for (int j = 0; j < sub3.getColumnDimension(); ++j) {                assertEquals((i + 30) + (j + 0) / 1024.0, sub3.getEntry(i, j), 0);            }        }        RealMatrix sub4 = m.getSubMatrix(30, 32, 62, 65);        for (int i = 0; i < sub4.getRowDimension(); ++i) {            for (int j = 0; j < sub4.getColumnDimension(); ++j) {                assertEquals((i + 30) + (j + 62) / 1024.0, sub4.getEntry(i, j), 0);            }        }    }    //Additional Test for BlockRealMatrixTest.testMultiply    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};    private double[][] d4 = new double[][] {{1},{2},{3},{4}};    private double[][] d5 = new double[][] {{30},{70}};         public void testMultiply2() {        RealMatrix m3 = new BlockRealMatrix(d3);          RealMatrix m4 = new BlockRealMatrix(d4);       RealMatrix m5 = new BlockRealMatrix(d5);       assertClose(m3.multiply(m4), m5, entryTolerance);   }              /** test trace */    public void testTrace() {        RealMatrix m = new BlockRealMatrix(id);        assertEquals("identity trace",3d,m.getTrace(),entryTolerance);        m = new BlockRealMatrix(testData2);        try {            m.getTrace();            fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }          }        /** test scalarAdd */    public void testScalarAdd() {        RealMatrix m = new BlockRealMatrix(testData);        assertClose(new BlockRealMatrix(testDataPlus2), m.scalarAdd(2d), entryTolerance);    }                        /** test operate */    public void testOperate() {        RealMatrix m = new BlockRealMatrix(id);        assertClose(testVector, m.operate(testVector), entryTolerance);        assertClose(testVector, m.operate(new ArrayRealVector(testVector)).getData(), entryTolerance);        m = new BlockRealMatrix(bigSingular);        try {            m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }    public void testOperateLarge() {        int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2;        int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2;        int r =  3 * BlockRealMatrix.BLOCK_SIZE;        Random random = new Random(111007463902334l);        RealMatrix m1 = createRandomMatrix(random, p, q);        RealMatrix m2 = createRandomMatrix(random, q, r);        RealMatrix m1m2 = m1.multiply(m2);        for (int i = 0; i < r; ++i) {            checkArrays(m1m2.getColumn(i), m1.operate(m2.getColumn(i)));        }    }    public void testOperatePremultiplyLarge() {        int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2;        int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2;        int r =  3 * BlockRealMatrix.BLOCK_SIZE;        Random random = new Random(111007463902334l);        RealMatrix m1 = createRandomMatrix(random, p, q);        RealMatrix m2 = createRandomMatrix(random, q, r);        RealMatrix m1m2 = m1.multiply(m2);        for (int i = 0; i < p; ++i) {            checkArrays(m1m2.getRow(i), m2.preMultiply(m1.getRow(i)));        }    }    /** test issue MATH-209 */    public void testMath209() {        RealMatrix a = new BlockRealMatrix(new double[][] {                { 1, 2 }, { 3, 4 }, { 5, 6 }        });        double[] b = a.operate(new double[] { 1, 1 });        assertEquals(a.getRowDimension(), b.length);        assertEquals( 3.0, b[0], 1.0e-12);        assertEquals( 7.0, b[1], 1.0e-12);        assertEquals(11.0, b[2], 1.0e-12);    }        /** test transpose */    public void testTranspose() {        RealMatrix m = new BlockRealMatrix(testData);         RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();        assertClose(mIT, mTI, normTolerance);        m = new BlockRealMatrix(testData2);        RealMatrix mt = new BlockRealMatrix(testData2T);        assertClose(mt, m.transpose(), normTolerance);    }        /** test preMultiply by vector */    public void testPremultiplyVector() {        RealMatrix m = new BlockRealMatrix(testData);        assertClose(m.preMultiply(testVector), preMultTest, normTolerance);        assertClose(m.preMultiply(new ArrayRealVector(testVector).getData()),                    preMultTest, normTolerance);        m = new BlockRealMatrix(bigSingular);        try {            m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }        public void testPremultiply() {        RealMatrix m3 = new BlockRealMatrix(d3);           RealMatrix m4 = new BlockRealMatrix(d4);        RealMatrix m5 = new BlockRealMatrix(d5);        assertClose(m4.preMultiply(m3), m5, entryTolerance);                BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);        BlockRealMatrix identity = new BlockRealMatrix(id);        assertClose(m.preMultiply(mInv), identity, entryTolerance);        assertClose(mInv.preMultiply(m), identity, entryTolerance);        assertClose(m.preMultiply(identity), m, entryTolerance);        assertClose(identity.preMultiply(mInv), mInv, entryTolerance);        try {            m.preMultiply(new BlockRealMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }        public void testGetVectors() {        RealMatrix m = new BlockRealMatrix(testData);        assertClose(m.getRow(0), testDataRow1, entryTolerance);        assertClose(m.getColumn(2), testDataCol3, entryTolerance);        try {            m.getRow(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }        try {            m.getColumn(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }    }        public void testGetEntry() {        RealMatrix m = new BlockRealMatrix(testData);        assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);        try {            m.getEntry(10, 4);            fail ("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }            /** test examples in user guide */    public void testExamples() {        // Create a real matrix with two rows and three columns        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};        RealMatrix m = new BlockRealMatrix(matrixData);        // One more with three rows, two columns        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};        RealMatrix n = new BlockRealMatrix(matrixData2);        // Now multiply m by n        RealMatrix p = m.multiply(n);        assertEquals(2, p.getRowDimension());        assertEquals(2, p.getColumnDimension());        // Invert p        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();         assertEquals(2, pInverse.getRowDimension());        assertEquals(2, pInverse.getColumnDimension());                // Solve example        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};        RealMatrix coefficients = new BlockRealMatrix(coefficientsData);        double[] constants = {1, -2, 1};        double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);               }        // test submatrix accessors    public void testGetSubMatrix() {        RealMatrix m = new BlockRealMatrix(subTestData);        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);           checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);          checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);          checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);         checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int startRow, int endRow, int startColumn, int endColumn,                                   boolean mustFail) {        try {            RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);            assertEquals(new BlockRealMatrix(reference), sub);            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }        private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int[] selectedRows, int[] selectedColumns,                                   boolean mustFail) {        try {            RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);            assertEquals(new BlockRealMatrix(reference), sub);            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    public void testGetSetMatrixLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        RealMatrix sub = new BlockRealMatrix(n - 4, n - 4).scalarAdd(1);        m.setSubMatrix(sub.getData(), 2, 2);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));    }    public void testCopySubMatrix() {        RealMatrix m = new BlockRealMatrix(subTestData);        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);           checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);          checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);          checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);         checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);                 checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, -1, 1, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkCopy(RealMatrix m, double[][] reference,                           int startRow, int endRow, int startColumn, int endColumn,                           boolean mustFail) {        try {            double[][] sub = (reference == null) ?                             new double[1][1] :                             new double[reference.length][reference[0].length];            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);            assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }        private void checkCopy(RealMatrix m, double[][] reference,                           int[] selectedRows, int[] selectedColumns,                           boolean mustFail) {        try {            double[][] sub = (reference == null) ?                    new double[1][1] :                    new double[reference.length][reference[0].length];            m.copySubMatrix(selectedRows, selectedColumns, sub);            assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    public void testGetRowMatrix() {        RealMatrix m     = new BlockRealMatrix(subTestData);        RealMatrix mRow0 = new BlockRealMatrix(subRow0);        RealMatrix mRow3 = new BlockRealMatrix(subRow3);        assertEquals("Row0", mRow0, m.getRowMatrix(0));        assertEquals("Row3", mRow3, m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowMatrix() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealMatrix mRow3 = new BlockRealMatrix(subRow3);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowMatrix(0, mRow3);        assertEquals(mRow3, m.getRowMatrix(0));        try {            m.setRowMatrix(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowMatrix(0, m);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        public void testGetSetRowMatrixLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        RealMatrix sub = new BlockRealMatrix(1, n).scalarAdd(1);        m.setRowMatrix(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        assertEquals(sub, m.getRowMatrix(2));    }        public void testGetColumnMatrix() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealMatrix mColumn1 = new BlockRealMatrix(subColumn1);        RealMatrix mColumn3 = new BlockRealMatrix(subColumn3);        assertEquals(mColumn1, m.getColumnMatrix(1));        assertEquals(mColumn3, m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnMatrix() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealMatrix mColumn3 = new BlockRealMatrix(subColumn3);        assertNotSame(mColumn3, m.getColumnMatrix(1));        m.setColumnMatrix(1, mColumn3);        assertEquals(mColumn3, m.getColumnMatrix(1));        try {            m.setColumnMatrix(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnMatrix(0, m);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetSetColumnMatrixLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        RealMatrix sub = new BlockRealMatrix(n, 1).scalarAdd(1);        m.setColumnMatrix(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        assertEquals(sub, m.getColumnMatrix(2));    }        public void testGetRowVector() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealVector mRow0 = new ArrayRealVector(subRow0[0]);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        assertEquals(mRow0, m.getRowVector(0));        assertEquals(mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowVector() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowVector(0, mRow3);        assertEquals(mRow3, m.getRowVector(0));        try {            m.setRowVector(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowVector(0, new ArrayRealVector(5));            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetSetRowVectorLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        RealVector sub = new ArrayRealVector(n, 1.0);        m.setRowVector(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        assertEquals(sub, m.getRowVector(2));    }        public void testGetColumnVector() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealVector mColumn1 = columnToVector(subColumn1);        RealVector mColumn3 = columnToVector(subColumn3);        assertEquals(mColumn1, m.getColumnVector(1));        assertEquals(mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnVector() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealVector mColumn3 = columnToVector(subColumn3);        assertNotSame(mColumn3, m.getColumnVector(1));        m.setColumnVector(1, mColumn3);        assertEquals(mColumn3, m.getColumnVector(1));        try {            m.setColumnVector(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnVector(0, new ArrayRealVector(5));            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetSetColumnVectorLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        RealVector sub = new ArrayRealVector(n, 1.0);        m.setColumnVector(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        assertEquals(sub, m.getColumnVector(2));    }        private RealVector columnToVector(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayRealVector(data, false);    }    public void testGetRow() {        RealMatrix m = new BlockRealMatrix(subTestData);        checkArrays(subRow0[0], m.getRow(0));        checkArrays(subRow3[0], m.getRow(3));        try {            m.getRow(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRow(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRow() {        RealMatrix m = new BlockRealMatrix(subTestData);        assertTrue(subRow3[0][0] != m.getRow(0)[0]);        m.setRow(0, subRow3[0]);        checkArrays(subRow3[0], m.getRow(0));        try {            m.setRow(-1, subRow3[0]);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRow(0, new double[5]);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetSetRowLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        double[] sub = new double[n];        Arrays.fill(sub, 1.0);        m.setRow(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        checkArrays(sub, m.getRow(2));    }        public void testGetColumn() {        RealMatrix m = new BlockRealMatrix(subTestData);        double[] mColumn1 = columnToArray(subColumn1);        double[] mColumn3 = columnToArray(subColumn3);        checkArrays(mColumn1, m.getColumn(1));        checkArrays(mColumn3, m.getColumn(3));        try {            m.getColumn(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumn(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumn() {        RealMatrix m = new BlockRealMatrix(subTestData);        double[] mColumn3 = columnToArray(subColumn3);        assertTrue(mColumn3[0] != m.getColumn(1)[0]);        m.setColumn(1, mColumn3);        checkArrays(mColumn3, m.getColumn(1));        try {            m.setColumn(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumn(0, new double[5]);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetSetColumnLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        double[] sub = new double[n];        Arrays.fill(sub, 1.0);        m.setColumn(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        checkArrays(sub, m.getColumn(2));    }        private double[] columnToArray(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return data;    }    private void checkArrays(double[] expected, double[] actual) {        assertEquals(expected.length, actual.length);        for (int i = 0; i < expected.length; ++i) {            assertEquals(expected[i], actual[i]);                    }    }        public void testEqualsAndHashCode() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m1 = (BlockRealMatrix) m.copy();        BlockRealMatrix mt = (BlockRealMatrix) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(new BlockRealMatrix(bigSingular)));     }        public void testToString() {        BlockRealMatrix m = new BlockRealMatrix(testData);        assertEquals("BlockRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",                m.toString());    }        public void testSetSubMatrix() throws Exception {        BlockRealMatrix m = new BlockRealMatrix(testData);        m.setSubMatrix(detData2,1,1);        RealMatrix expected = new BlockRealMatrix            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);                  m.setSubMatrix(detData2,0,0);        expected = new BlockRealMatrix            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);                  m.setSubMatrix(testDataPlus2,0,0);              expected = new BlockRealMatrix            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});        assertEquals(expected, m);                   // javadoc example        BlockRealMatrix matrix = new BlockRealMatrix            (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});        matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1);        expected = new BlockRealMatrix            (new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}});        assertEquals(expected, matrix);           // dimension overflow        try {              m.setSubMatrix(testData,1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // dimension underflow        try {              m.setSubMatrix(testData,-1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        try {              m.setSubMatrix(testData,1,-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }                // null        try {            m.setSubMatrix(null,1,1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }                // ragged        try {            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }               // empty        try {            m.setSubMatrix(new double[][] {{}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }            }    public void testWalk() {        int rows    = 150;        int columns = 75;        RealMatrix m = new BlockRealMatrix(rows, columns);        m.walkInRowOrder(new SetVisitor());        GetVisitor getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new BlockRealMatrix(rows, columns);        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);                                assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);                                assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new BlockRealMatrix(rows, columns);        m.walkInColumnOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new BlockRealMatrix(rows, columns);        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);                                assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);                                assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new BlockRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new BlockRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);                                assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);                                assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new BlockRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new BlockRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);                                assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);                                assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }    }        public void testSerial()  {        BlockRealMatrix m = new BlockRealMatrix(testData);        assertEquals(m,TestUtils.serializeAndRecover(m));    }    private static class SetVisitor extends DefaultRealMatrixChangingVisitor {        @Override        public double visit(int i, int j, double value) {            return i + j / 1024.0;        }    }    private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {        private int count = 0;        @Override        public void visit(int i, int j, double value) {            ++count;            assertEquals(i + j / 1024.0, value, 0.0);        }        public int getCount() {            return count;        }    }    //--------------- -----------------Protected methods            /** verifies that two matrices are close (1-norm) */                  protected void assertClose(RealMatrix m, RealMatrix n, double tolerance) {        assertTrue(m.subtract(n).getNorm() < tolerance);    }        /** verifies that two vectors are close (sup norm) */    protected void assertClose(double[] m, double[] n, double tolerance) {        if (m.length != n.length) {            fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            assertEquals(m[i], n[i], tolerance);        }    }    private BlockRealMatrix createRandomMatrix(Random r, int rows, int columns) {        BlockRealMatrix m = new BlockRealMatrix(rows, columns);        for (int i = 0; i < rows; ++i) {            for (int j = 0; j < columns; ++j) {                m.setEntry(i, j, 200 * r.nextDouble() - 100);            }        }        return m;    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.io.Serializable;import java.lang.reflect.Array;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.Field;import org.apache.commons.math.FieldElement;import org.apache.commons.math.TestUtils;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionField;/** * Test cases for the {@link ArrayFieldVector} class. * * @version $Revision$ $Date$ */public class ArrayFieldVectorTest extends TestCase {    //     protected Fraction[][] ma1 = {            {new Fraction(1), new Fraction(2), new Fraction(3)},            {new Fraction(4), new Fraction(5), new Fraction(6)},            {new Fraction(7), new Fraction(8), new Fraction(9)}    };    protected Fraction[] vec1 = {new Fraction(1), new Fraction(2), new Fraction(3)};    protected Fraction[] vec2 = {new Fraction(4), new Fraction(5), new Fraction(6)};    protected Fraction[] vec3 = {new Fraction(7), new Fraction(8), new Fraction(9)};    protected Fraction[] vec4 = { new Fraction(1), new Fraction(2), new Fraction(3),                                  new Fraction(4), new Fraction(5), new Fraction(6),                                  new Fraction(7), new Fraction(8), new Fraction(9)};    protected Fraction[] vec_null = {new Fraction(0), new Fraction(0), new Fraction(0)};    protected Fraction[] dvec1 = {new Fraction(1), new Fraction(2), new Fraction(3),                                  new Fraction(4), new Fraction(5), new Fraction(6),                                  new Fraction(7), new Fraction(8), new Fraction(9)};    protected Fraction[][] mat1 = {            {new Fraction(1), new Fraction(2), new Fraction(3)},            {new Fraction(4), new Fraction(5), new Fraction(6)},            {new Fraction(7), new Fraction(8), new Fraction(9)}    };    // Testclass to test the FieldVector<Fraction> interface     // only with enough content to support the test    public static class FieldVectorTestImpl<T extends FieldElement<T>>        implements FieldVector<T>, Serializable {        private static final long serialVersionUID = 3970959016014158539L;        private final Field<T> field;        /** Entries of the vector. */        protected T[] data;        /** Build an array of elements.         * @param length size of the array to build         * @return a new array         */        @SuppressWarnings("unchecked")        private T[] buildArray(final int length) {            return (T[]) Array.newInstance(field.getZero().getClass(), length);        }        public FieldVectorTestImpl(T[] d) {            field = d[0].getField();            data = d.clone();        }        public Field<T> getField() {            return field;        }        private UnsupportedOperationException unsupported() {            return new UnsupportedOperationException("Not supported, unneeded for test purposes");        }        public FieldVector<T> copy() {            throw unsupported();        }        public FieldVector<T> add(FieldVector<T> v) throws IllegalArgumentException {            throw unsupported();        }        public FieldVector<T> add(T[] v) throws IllegalArgumentException {            throw unsupported();        }        public FieldVector<T> subtract(FieldVector<T> v) throws IllegalArgumentException {            throw unsupported();        }        public FieldVector<T> subtract(T[] v) throws IllegalArgumentException {            throw unsupported();        }        public FieldVector<T> mapAdd(T d) {            throw unsupported();        }        public FieldVector<T> mapAddToSelf(T d) {            throw unsupported();        }        public FieldVector<T> mapSubtract(T d) {            throw unsupported();        }        public FieldVector<T> mapSubtractToSelf(T d) {            throw unsupported();        }        public FieldVector<T> mapMultiply(T d) {            T[] out = buildArray(data.length);            for (int i = 0; i < data.length; i++) {                out[i] = data[i].multiply(d);            }            return new FieldVectorTestImpl<T>(out);        }        public FieldVector<T> mapMultiplyToSelf(T d) {            throw unsupported();        }        public FieldVector<T> mapDivide(T d) {            throw unsupported();        }        public FieldVector<T> mapDivideToSelf(T d) {            throw unsupported();        }        public FieldVector<T> mapInv() {            throw unsupported();        }        public FieldVector<T> mapInvToSelf() {            throw unsupported();        }        public FieldVector<T> ebeMultiply(FieldVector<T> v) throws IllegalArgumentException {            throw unsupported();        }        public FieldVector<T> ebeMultiply(T[] v) throws IllegalArgumentException {            throw unsupported();        }        public FieldVector<T> ebeDivide(FieldVector<T> v) throws IllegalArgumentException {            throw unsupported();        }        public FieldVector<T> ebeDivide(T[] v) throws IllegalArgumentException {            throw unsupported();        }        public T[] getData() {            return data.clone();        }        public T dotProduct(FieldVector<T> v) throws IllegalArgumentException {            T dot = field.getZero();            for (int i = 0; i < data.length; i++) {                dot = dot.add(data[i].multiply(v.getEntry(i)));            }            return dot;        }        public T dotProduct(T[] v) throws IllegalArgumentException {            T dot = field.getZero();            for (int i = 0; i < data.length; i++) {                dot = dot.add(data[i].multiply(v[i]));            }            return dot;        }        public FieldVector<T> projection(FieldVector<T> v) throws IllegalArgumentException {            throw unsupported();        }        public FieldVector<T> projection(T[] v) throws IllegalArgumentException {            throw unsupported();        }        public FieldMatrix<T> outerProduct(FieldVector<T> v) throws IllegalArgumentException {            throw unsupported();        }        public FieldMatrix<T> outerProduct(T[] v) throws IllegalArgumentException {            throw unsupported();        }        public T getEntry(int index) throws MatrixIndexException {            return data[index];        }        public int getDimension() {            return data.length;        }        public FieldVector<T> append(FieldVector<T> v) {            throw unsupported();        }        public FieldVector<T> append(T d) {            throw unsupported();        }        public FieldVector<T> append(T[] a) {            throw unsupported();        }        public FieldVector<T> getSubVector(int index, int n) throws MatrixIndexException {            throw unsupported();        }        public void setEntry(int index, T value) throws MatrixIndexException {            throw unsupported();        }        public void setSubVector(int index, FieldVector<T> v) throws MatrixIndexException {            throw unsupported();        }        public void setSubVector(int index, T[] v) throws MatrixIndexException {            throw unsupported();        }        public void set(T value) {            throw unsupported();        }        public T[] toArray() {            throw unsupported();        }    }    public static Test suite() {        TestSuite suite = new TestSuite(ArrayFieldVectorTest.class);        suite.setName("ArrayFieldVector<Fraction> Tests");        return suite;    }    public void testConstructors() {        ArrayFieldVector<Fraction> v0 = new ArrayFieldVector<Fraction>(FractionField.getInstance());        assertEquals(0, v0.getDimension());        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(FractionField.getInstance(), 7);        assertEquals(7, v1.getDimension());        assertEquals(new Fraction(0), v1.getEntry(6));        ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(5, new Fraction(123, 100));        assertEquals(5, v2.getDimension());        assertEquals(new Fraction(123, 100), v2.getEntry(4));        ArrayFieldVector<Fraction> v3 = new ArrayFieldVector<Fraction>(vec1);        assertEquals(3, v3.getDimension());        assertEquals(new Fraction(2), v3.getEntry(1));        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4, 3, 2);        assertEquals(2, v4.getDimension());        assertEquals(new Fraction(4), v4.getEntry(0));        try {            new ArrayFieldVector<Fraction>(vec4, 8, 3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        FieldVector<Fraction> v5_i = new ArrayFieldVector<Fraction>(dvec1);        assertEquals(9, v5_i.getDimension());        assertEquals(new Fraction(9), v5_i.getEntry(8));        ArrayFieldVector<Fraction> v5 = new ArrayFieldVector<Fraction>(dvec1);        assertEquals(9, v5.getDimension());        assertEquals(new Fraction(9), v5.getEntry(8));        ArrayFieldVector<Fraction> v6 = new ArrayFieldVector<Fraction>(dvec1, 3, 2);        assertEquals(2, v6.getDimension());        assertEquals(new Fraction(4), v6.getEntry(0));        try {            new ArrayFieldVector<Fraction>(dvec1, 8, 3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayFieldVector<Fraction> v7 = new ArrayFieldVector<Fraction>(v1);        assertEquals(7, v7.getDimension());        assertEquals(new Fraction(0), v7.getEntry(6));        FieldVectorTestImpl<Fraction> v7_i = new FieldVectorTestImpl<Fraction>(vec1);        ArrayFieldVector<Fraction> v7_2 = new ArrayFieldVector<Fraction>(v7_i);        assertEquals(3, v7_2.getDimension());        assertEquals(new Fraction(2), v7_2.getEntry(1));        ArrayFieldVector<Fraction> v8 = new ArrayFieldVector<Fraction>(v1, true);        assertEquals(7, v8.getDimension());        assertEquals(new Fraction(0), v8.getEntry(6));        assertNotSame("testData not same object ", v1.data, v8.data);        ArrayFieldVector<Fraction> v8_2 = new ArrayFieldVector<Fraction>(v1, false);        assertEquals(7, v8_2.getDimension());        assertEquals(new Fraction(0), v8_2.getEntry(6));        assertEquals(v1.data, v8_2.data);        ArrayFieldVector<Fraction> v9 = new ArrayFieldVector<Fraction>(v1, v3);        assertEquals(10, v9.getDimension());        assertEquals(new Fraction(1), v9.getEntry(7));    }    public void testDataInOut() {        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);        ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(vec2);        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4);        FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2);         FieldVector<Fraction> v_append_1 = v1.append(v2);        assertEquals(6, v_append_1.getDimension());        assertEquals(new Fraction(4), v_append_1.getEntry(3));        FieldVector<Fraction> v_append_2 = v1.append(new Fraction(2));        assertEquals(4, v_append_2.getDimension());        assertEquals(new Fraction(2), v_append_2.getEntry(3));        FieldVector<Fraction> v_append_3 = v1.append(vec2);        assertEquals(6, v_append_3.getDimension());        assertEquals(new Fraction(4), v_append_3.getEntry(3));        FieldVector<Fraction> v_append_4 = v1.append(v2_t);        assertEquals(6, v_append_4.getDimension());        assertEquals(new Fraction(4), v_append_4.getEntry(3));        FieldVector<Fraction> v_copy = v1.copy();        assertEquals(3, v_copy.getDimension());        assertNotSame("testData not same object ", v1.data, v_copy.getData());        Fraction[] a_frac = v1.toArray();        assertEquals(3, a_frac.length);        assertNotSame("testData not same object ", v1.data, a_frac);//      ArrayFieldVector<Fraction> vout4 = (ArrayFieldVector<Fraction>) v1.clone();//      assertEquals(3, vout4.getDimension());//      assertEquals(v1.data, vout4.data);        FieldVector<Fraction> vout5 = v4.getSubVector(3, 3);        assertEquals(3, vout5.getDimension());        assertEquals(new Fraction(5), vout5.getEntry(1));        try {            v4.getSubVector(3, 7);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayFieldVector<Fraction> v_set1 = (ArrayFieldVector<Fraction>) v1.copy();        v_set1.setEntry(1, new Fraction(11));        assertEquals(new Fraction(11), v_set1.getEntry(1));        try {            v_set1.setEntry(3, new Fraction(11));            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayFieldVector<Fraction> v_set2 = (ArrayFieldVector<Fraction>) v4.copy();        v_set2.set(3, v1);        assertEquals(new Fraction(1), v_set2.getEntry(3));        assertEquals(new Fraction(7), v_set2.getEntry(6));        try {            v_set2.set(7, v1);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayFieldVector<Fraction> v_set3 = (ArrayFieldVector<Fraction>) v1.copy();        v_set3.set(new Fraction(13));        assertEquals(new Fraction(13), v_set3.getEntry(2));        try {            v_set3.getEntry(23);            fail("ArrayIndexOutOfBoundsException expected");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayFieldVector<Fraction> v_set4 = (ArrayFieldVector<Fraction>) v4.copy();        v_set4.setSubVector(3, v2_t);        assertEquals(new Fraction(4), v_set4.getEntry(3));        assertEquals(new Fraction(7), v_set4.getEntry(6));        try {            v_set4.setSubVector(7, v2_t);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayFieldVector<Fraction> vout10 = (ArrayFieldVector<Fraction>) v1.copy();               ArrayFieldVector<Fraction> vout10_2 = (ArrayFieldVector<Fraction>) v1.copy();        assertEquals(vout10, vout10_2);        vout10_2.setEntry(0, new Fraction(11, 10));        assertNotSame(vout10, vout10_2);    }    public void testMapFunctions() {         ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);        //octave =  v1 .+ 2.0        FieldVector<Fraction> v_mapAdd = v1.mapAdd(new Fraction(2));        Fraction[] result_mapAdd = {new Fraction(3), new Fraction(4), new Fraction(5)};        checkArray("compare vectors" ,result_mapAdd,v_mapAdd.getData());        //octave =  v1 .+ 2.0        FieldVector<Fraction> v_mapAddToSelf = v1.copy();        v_mapAddToSelf.mapAddToSelf(new Fraction(2));        Fraction[] result_mapAddToSelf = {new Fraction(3), new Fraction(4), new Fraction(5)};        checkArray("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData());        //octave =  v1 .- 2.0        FieldVector<Fraction> v_mapSubtract = v1.mapSubtract(new Fraction(2));        Fraction[] result_mapSubtract = {new Fraction(-1), new Fraction(0), new Fraction(1)};        checkArray("compare vectors" ,result_mapSubtract,v_mapSubtract.getData());        //octave =  v1 .- 2.0        FieldVector<Fraction> v_mapSubtractToSelf = v1.copy();        v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));        Fraction[] result_mapSubtractToSelf = {new Fraction(-1), new Fraction(0), new Fraction(1)};        checkArray("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData());        //octave =  v1 .* 2.0        FieldVector<Fraction> v_mapMultiply = v1.mapMultiply(new Fraction(2));        Fraction[] result_mapMultiply = {new Fraction(2), new Fraction(4), new Fraction(6)};        checkArray("compare vectors" ,result_mapMultiply,v_mapMultiply.getData());        //octave =  v1 .* 2.0        FieldVector<Fraction> v_mapMultiplyToSelf = v1.copy();        v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));        Fraction[] result_mapMultiplyToSelf = {new Fraction(2), new Fraction(4), new Fraction(6)};        checkArray("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());        //octave =  v1 ./ 2.0        FieldVector<Fraction> v_mapDivide = v1.mapDivide(new Fraction(2));        Fraction[] result_mapDivide = {new Fraction(1, 2), new Fraction(1), new Fraction(3, 2)};        checkArray("compare vectors" ,result_mapDivide,v_mapDivide.getData());        //octave =  v1 ./ 2.0        FieldVector<Fraction> v_mapDivideToSelf = v1.copy();        v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));        Fraction[] result_mapDivideToSelf = {new Fraction(1, 2), new Fraction(1), new Fraction(3, 2)};        checkArray("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData());        //octave =  v1 .^-1        FieldVector<Fraction> v_mapInv = v1.mapInv();        Fraction[] result_mapInv = {new Fraction(1),new Fraction(1, 2),new Fraction(1, 3)};        checkArray("compare vectors" ,result_mapInv,v_mapInv.getData());        //octave =  v1 .^-1        FieldVector<Fraction> v_mapInvToSelf = v1.copy();        v_mapInvToSelf.mapInvToSelf();        Fraction[] result_mapInvToSelf = {new Fraction(1),new Fraction(1, 2),new Fraction(1, 3)};        checkArray("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData());    }    public void testBasicFunctions() {         ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);        ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(vec2);        new ArrayFieldVector<Fraction>(vec_null);        FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2);         //octave =  v1 + v2        ArrayFieldVector<Fraction> v_add = v1.add(v2);        Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)};        checkArray("compare vect" ,v_add.getData(),result_add);        FieldVectorTestImpl<Fraction> vt2 = new FieldVectorTestImpl<Fraction>(vec2);        FieldVector<Fraction> v_add_i = v1.add(vt2);        Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)};        checkArray("compare vect" ,v_add_i.getData(),result_add_i);        //octave =  v1 - v2        ArrayFieldVector<Fraction> v_subtract = v1.subtract(v2);        Fraction[] result_subtract = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};        checkArray("compare vect" ,v_subtract.getData(),result_subtract);        FieldVector<Fraction> v_subtract_i = v1.subtract(vt2);        Fraction[] result_subtract_i = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};        checkArray("compare vect" ,v_subtract_i.getData(),result_subtract_i);        // octave v1 .* v2        ArrayFieldVector<Fraction>  v_ebeMultiply = v1.ebeMultiply(v2);        Fraction[] result_ebeMultiply = {new Fraction(4), new Fraction(10), new Fraction(18)};        checkArray("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply);        FieldVector<Fraction>  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);        Fraction[] result_ebeMultiply_2 = {new Fraction(4), new Fraction(10), new Fraction(18)};        checkArray("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2);        // octave v1 ./ v2        ArrayFieldVector<Fraction>  v_ebeDivide = v1.ebeDivide(v2);        Fraction[] result_ebeDivide = {new Fraction(1, 4), new Fraction(2, 5), new Fraction(1, 2)};        checkArray("compare vect" ,v_ebeDivide.getData(),result_ebeDivide);        FieldVector<Fraction>  v_ebeDivide_2 = v1.ebeDivide(v2_t);        Fraction[] result_ebeDivide_2 = {new Fraction(1, 4), new Fraction(2, 5), new Fraction(1, 2)};        checkArray("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2);        // octave  dot(v1,v2)        Fraction dot =  v1.dotProduct(v2);        assertEquals("compare val ",new Fraction(32), dot);        // octave  dot(v1,v2_t)        Fraction dot_2 =  v1.dotProduct(v2_t);        assertEquals("compare val ",new Fraction(32), dot_2);        FieldMatrix<Fraction> m_outerProduct = v1.outerProduct(v2);        assertEquals("compare val ",new Fraction(4), m_outerProduct.getEntry(0,0));        FieldMatrix<Fraction> m_outerProduct_2 = v1.outerProduct(v2_t);        assertEquals("compare val ",new Fraction(4), m_outerProduct_2.getEntry(0,0));        ArrayFieldVector<Fraction> v_projection = v1.projection(v2);        Fraction[] result_projection = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)};        checkArray("compare vect", v_projection.getData(), result_projection);        FieldVector<Fraction> v_projection_2 = v1.projection(v2_t);        Fraction[] result_projection_2 = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)};        checkArray("compare vect", v_projection_2.getData(), result_projection_2);    }      public void testMisc() {         ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4);        FieldVector<Fraction> v4_2 = new ArrayFieldVector<Fraction>(vec4);        String out1 = v1.toString();        assertTrue("some output ",  out1.length()!=0);        /*             Fraction[] dout1 = v1.copyOut();        assertEquals(3, dout1.length);        assertNotSame("testData not same object ", v1.data, dout1);            */              try {            v1.checkVectorDimensions(2);             fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            v1.checkVectorDimensions(v4);             fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }                try {            v1.checkVectorDimensions(v4_2);             fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }            }    public void testSerial()  {        ArrayFieldVector<Fraction> v = new ArrayFieldVector<Fraction>(vec1);        assertEquals(v,TestUtils.serializeAndRecover(v));    }      /** verifies that two vectors are equals */    protected void checkArray(String msg, Fraction[] m, Fraction[] n) {        if (m.length != n.length) {            fail("vectors have different lengths");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " +  i + " elements differ", m[i],n[i]);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionField;/** * Test cases for the {@link Array2DRowFieldMatrix} class. * * @version $Revision$ $Date$ */public final class FieldMatrixImplTest extends TestCase {        // 3 x 3 identity matrix    protected Fraction[][] id = { {new Fraction(1),new Fraction(0),new Fraction(0)}, {new Fraction(0),new Fraction(1),new Fraction(0)}, {new Fraction(0),new Fraction(0),new Fraction(1)} };        // Test data for group operations    protected Fraction[][] testData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)}, {new Fraction(1),new Fraction(0),new Fraction(8)} };    protected Fraction[][] testDataLU = {{new Fraction(2), new Fraction(5), new Fraction(3)}, {new Fraction(1, 2), new Fraction(-5, 2), new Fraction(13, 2)}, {new Fraction(1, 2), new Fraction(1, 5), new Fraction(1, 5)}};    protected Fraction[][] testDataPlus2 = { {new Fraction(3),new Fraction(4),new Fraction(5)}, {new Fraction(4),new Fraction(7),new Fraction(5)}, {new Fraction(3),new Fraction(2),new Fraction(10)} };    protected Fraction[][] testDataMinus = { {new Fraction(-1),new Fraction(-2),new Fraction(-3)}, {new Fraction(-2),new Fraction(-5),new Fraction(-3)},        {new Fraction(-1),new Fraction(0),new Fraction(-8)} };    protected Fraction[] testDataRow1 = {new Fraction(1),new Fraction(2),new Fraction(3)};    protected Fraction[] testDataCol3 = {new Fraction(3),new Fraction(3),new Fraction(8)};    protected Fraction[][] testDataInv =         { {new Fraction(-40),new Fraction(16),new Fraction(9)}, {new Fraction(13),new Fraction(-5),new Fraction(-3)}, {new Fraction(5),new Fraction(-2),new Fraction(-1)} };    protected Fraction[] preMultTest = {new Fraction(8),new Fraction(12),new Fraction(33)};    protected Fraction[][] testData2 ={ {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)}};    protected Fraction[][] testData2T = { {new Fraction(1),new Fraction(2)}, {new Fraction(2),new Fraction(5)}, {new Fraction(3),new Fraction(3)}};    protected Fraction[][] testDataPlusInv =         { {new Fraction(-39),new Fraction(18),new Fraction(12)}, {new Fraction(15),new Fraction(0),new Fraction(0)}, {new Fraction(6),new Fraction(-2),new Fraction(7)} };        // lu decomposition tests    protected Fraction[][] luData = { {new Fraction(2),new Fraction(3),new Fraction(3)}, {new Fraction(0),new Fraction(5),new Fraction(7)}, {new Fraction(6),new Fraction(9),new Fraction(8)} };    protected Fraction[][] luDataLUDecomposition = { {new Fraction(6),new Fraction(9),new Fraction(8)}, {new Fraction(0),new Fraction(5),new Fraction(7)},            {new Fraction(1, 3),new Fraction(0),new Fraction(1, 3)} };        // singular matrices    protected Fraction[][] singular = { {new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(3)} };    protected Fraction[][] bigSingular = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}, {new Fraction(2),new Fraction(5),new Fraction(3),new Fraction(4)},        {new Fraction(7),new Fraction(3),new Fraction(256),new Fraction(1930)}, {new Fraction(3),new Fraction(7),new Fraction(6),new Fraction(8)}}; // 4th row = 1st + 2nd    protected Fraction[][] detData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(4),new Fraction(5),new Fraction(6)}, {new Fraction(7),new Fraction(8),new Fraction(10)} };    protected Fraction[][] detData2 = { {new Fraction(1), new Fraction(3)}, {new Fraction(2), new Fraction(4)}};        // vectors    protected Fraction[] testVector = {new Fraction(1),new Fraction(2),new Fraction(3)};    protected Fraction[] testVector2 = {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)};        // submatrix accessor tests    protected Fraction[][] subTestData = {{new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)}, {new Fraction(3, 2), new Fraction(5, 2), new Fraction(7, 2), new Fraction(9, 2)},            {new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8)}, {new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7)}};     // array selections    protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4)}, {new Fraction(4), new Fraction(8)}};    protected Fraction[][] subRows03Cols12 = { {new Fraction(2), new Fraction(3)}, {new Fraction(5), new Fraction(6)}};    protected Fraction[][] subRows03Cols123 = { {new Fraction(2), new Fraction(3), new Fraction(4)} , {new Fraction(5), new Fraction(6), new Fraction(7)}};    // effective permutations    protected Fraction[][] subRows20Cols123 = { {new Fraction(4), new Fraction(6), new Fraction(8)} , {new Fraction(2), new Fraction(3), new Fraction(4)}};    protected Fraction[][] subRows31Cols31 = {{new Fraction(7), new Fraction(5)}, {new Fraction(9, 2), new Fraction(5, 2)}};    // contiguous ranges    protected Fraction[][] subRows01Cols23 = {{new Fraction(3),new Fraction(4)} , {new Fraction(7, 2), new Fraction(9, 2)}};    protected Fraction[][] subRows23Cols00 = {{new Fraction(2)} , {new Fraction(4)}};    protected Fraction[][] subRows00Cols33 = {{new Fraction(4)}};    // row matrices    protected Fraction[][] subRow0 = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}};    protected Fraction[][] subRow3 = {{new Fraction(4),new Fraction(5),new Fraction(6),new Fraction(7)}};    // column matrices    protected Fraction[][] subColumn1 = {{new Fraction(2)}, {new Fraction(5, 2)}, {new Fraction(4)}, {new Fraction(5)}};    protected Fraction[][] subColumn3 = {{new Fraction(4)}, {new Fraction(9, 2)}, {new Fraction(8)}, {new Fraction(7)}};        // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;        public FieldMatrixImplTest(String name) {        super(name);    }        public static Test suite() {        TestSuite suite = new TestSuite(FieldMatrixImplTest.class);        suite.setName("Array2DRowFieldMatrix<Fraction> Tests");        return suite;    }        /** test dimensions */    public void testDimensions() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());    }         /** test copy functions */    public void testCopyFunctions() {        Array2DRowFieldMatrix<Fraction> m1 = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(m1.getData());        assertEquals(m2,m1);        Array2DRowFieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(m3.getData(), false);        assertEquals(m4,m3);    }                   /** test add */    public void testAdd() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);        FieldMatrix<Fraction> mPlusMInv = m.add(mInv);        Fraction[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);            }        }        }        /** test add failure */    public void testAddFail() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);        try {            m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }    }         /** test m-n = m + -n */    public void testPlusMinus() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testDataInv);        TestUtils.assertEquals(m.subtract(m2),m2.scalarMultiply(new Fraction(-1)).add(m));                try {            m.subtract(new Array2DRowFieldMatrix<Fraction>(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }       /** test multiply */     public void testMultiply() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);        Array2DRowFieldMatrix<Fraction> identity = new Array2DRowFieldMatrix<Fraction>(id);        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);        TestUtils.assertEquals(m.multiply(mInv), identity);        TestUtils.assertEquals(mInv.multiply(m), identity);        TestUtils.assertEquals(m.multiply(identity), m);        TestUtils.assertEquals(identity.multiply(mInv), mInv);        TestUtils.assertEquals(m2.multiply(identity), m2);         try {            m.multiply(new Array2DRowFieldMatrix<Fraction>(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }           //Additional Test for Array2DRowFieldMatrix<Fraction>Test.testMultiply    private Fraction[][] d3 = new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},{new Fraction(5),new Fraction(6),new Fraction(7),new Fraction(8)}};    private Fraction[][] d4 = new Fraction[][] {{new Fraction(1)},{new Fraction(2)},{new Fraction(3)},{new Fraction(4)}};    private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}};         public void testMultiply2() {        FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3);          FieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(d4);       FieldMatrix<Fraction> m5 = new Array2DRowFieldMatrix<Fraction>(d5);       TestUtils.assertEquals(m3.multiply(m4), m5);   }              /** test trace */    public void testTrace() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(id);        assertEquals("identity trace",new Fraction(3),m.getTrace());        m = new Array2DRowFieldMatrix<Fraction>(testData2);        try {            m.getTrace();            fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }          }        /** test sclarAdd */    public void testScalarAdd() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(new Array2DRowFieldMatrix<Fraction>(testDataPlus2), m.scalarAdd(new Fraction(2)));    }                        /** test operate */    public void testOperate() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(id);        TestUtils.assertEquals(testVector, m.operate(testVector));        TestUtils.assertEquals(testVector, m.operate(new ArrayFieldVector<Fraction>(testVector)).getData());        m = new Array2DRowFieldMatrix<Fraction>(bigSingular);        try {            m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }    /** test issue MATH-209 */    public void testMath209() {        FieldMatrix<Fraction> a = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) }        }, false);        Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });        assertEquals(a.getRowDimension(), b.length);        assertEquals( new Fraction(3), b[0]);        assertEquals( new Fraction(7), b[1]);        assertEquals(new Fraction(11), b[2]);    }        /** test transpose */    public void testTranspose() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);         FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();        TestUtils.assertEquals(mIT, mTI);        m = new Array2DRowFieldMatrix<Fraction>(testData2);        FieldMatrix<Fraction> mt = new Array2DRowFieldMatrix<Fraction>(testData2T);        TestUtils.assertEquals(mt, m.transpose());    }        /** test preMultiply by vector */    public void testPremultiplyVector() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(m.preMultiply(testVector), preMultTest);        TestUtils.assertEquals(m.preMultiply(new ArrayFieldVector<Fraction>(testVector).getData()),                               preMultTest);        m = new Array2DRowFieldMatrix<Fraction>(bigSingular);        try {            m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }        public void testPremultiply() {        FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3);           FieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(d4);        FieldMatrix<Fraction> m5 = new Array2DRowFieldMatrix<Fraction>(d5);        TestUtils.assertEquals(m4.preMultiply(m3), m5);                Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);        Array2DRowFieldMatrix<Fraction> identity = new Array2DRowFieldMatrix<Fraction>(id);        TestUtils.assertEquals(m.preMultiply(mInv), identity);        TestUtils.assertEquals(mInv.preMultiply(m), identity);        TestUtils.assertEquals(m.preMultiply(identity), m);        TestUtils.assertEquals(identity.preMultiply(mInv), mInv);        try {            m.preMultiply(new Array2DRowFieldMatrix<Fraction>(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }          }        public void testGetVectors() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(m.getRow(0), testDataRow1);        TestUtils.assertEquals(m.getColumn(2), testDataCol3);        try {            m.getRow(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }        try {            m.getColumn(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }    }        public void testGetEntry() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        assertEquals("get entry",m.getEntry(0,1),new Fraction(2));        try {            m.getEntry(10, 4);            fail ("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }            /** test examples in user guide */    public void testExamples() {        // Create a real matrix with two rows and three columns        Fraction[][] matrixData = {                {new Fraction(1),new Fraction(2),new Fraction(3)},                {new Fraction(2),new Fraction(5),new Fraction(3)}        };        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(matrixData);        // One more with three rows, two columns        Fraction[][] matrixData2 = {                {new Fraction(1),new Fraction(2)},                {new Fraction(2),new Fraction(5)},                {new Fraction(1), new Fraction(7)}        };        FieldMatrix<Fraction> n = new Array2DRowFieldMatrix<Fraction>(matrixData2);        // Now multiply m by n        FieldMatrix<Fraction> p = m.multiply(n);        assertEquals(2, p.getRowDimension());        assertEquals(2, p.getColumnDimension());        // Invert p        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();         assertEquals(2, pInverse.getRowDimension());        assertEquals(2, pInverse.getColumnDimension());                // Solve example        Fraction[][] coefficientsData = {                {new Fraction(2), new Fraction(3), new Fraction(-2)},                {new Fraction(-1), new Fraction(7), new Fraction(6)},                {new Fraction(4), new Fraction(-3), new Fraction(-5)}        };        FieldMatrix<Fraction> coefficients = new Array2DRowFieldMatrix<Fraction>(coefficientsData);        Fraction[] constants = {new Fraction(1), new Fraction(-2), new Fraction(1)};        Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);        assertEquals(new Fraction(2).multiply(solution[0]).                     add(new Fraction(3).multiply(solution[1])).                     subtract(new Fraction(2).multiply(solution[2])), constants[0]);        assertEquals(new Fraction(-1).multiply(solution[0]).                     add(new Fraction(7).multiply(solution[1])).                     add(new Fraction(6).multiply(solution[2])), constants[1]);        assertEquals(new Fraction(4).multiply(solution[0]).                     subtract(new Fraction(3).multiply(solution[1])).                     subtract(new Fraction(5).multiply(solution[2])), constants[2]);               }        // test submatrix accessors    public void testGetSubMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);           checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);          checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);          checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);         checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,                                   int startRow, int endRow, int startColumn, int endColumn,                                   boolean mustFail) {        try {            FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);            assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }        private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,                                   int[] selectedRows, int[] selectedColumns,                                   boolean mustFail) {        try {            FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);            assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    public void testCopySubMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);           checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);          checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);          checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);         checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);         checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);                 checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, -1, 1, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,                           int startRow, int endRow, int startColumn, int endColumn,                           boolean mustFail) {        try {            Fraction[][] sub = (reference == null) ?                             new Fraction[1][1] :                             new Fraction[reference.length][reference[0].length];            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);            assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }        private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,                           int[] selectedRows, int[] selectedColumns,                           boolean mustFail) {        try {            Fraction[][] sub = (reference == null) ?                    new Fraction[1][1] :                    new Fraction[reference.length][reference[0].length];            m.copySubMatrix(selectedRows, selectedColumns, sub);            assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    public void testGetRowMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mRow0 = new Array2DRowFieldMatrix<Fraction>(subRow0);        FieldMatrix<Fraction> mRow3 = new Array2DRowFieldMatrix<Fraction>(subRow3);        assertEquals("Row0", mRow0,                 m.getRowMatrix(0));        assertEquals("Row3", mRow3,                 m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }        public void testSetRowMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mRow3 = new Array2DRowFieldMatrix<Fraction>(subRow3);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowMatrix(0, mRow3);        assertEquals(mRow3, m.getRowMatrix(0));        try {            m.setRowMatrix(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowMatrix(0, m);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        public void testGetColumnMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mColumn1 = new Array2DRowFieldMatrix<Fraction>(subColumn1);        FieldMatrix<Fraction> mColumn3 = new Array2DRowFieldMatrix<Fraction>(subColumn3);        assertEquals("Column1", mColumn1,                 m.getColumnMatrix(1));        assertEquals("Column3", mColumn3,                 m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mColumn3 = new Array2DRowFieldMatrix<Fraction>(subColumn3);        assertNotSame(mColumn3, m.getColumnMatrix(1));        m.setColumnMatrix(1, mColumn3);        assertEquals(mColumn3, m.getColumnMatrix(1));        try {            m.setColumnMatrix(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnMatrix(0, m);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    public void testGetRowVector() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);        assertEquals("Row0", mRow0, m.getRowVector(0));        assertEquals("Row3", mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowVector() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowVector(0, mRow3);        assertEquals(mRow3, m.getRowVector(0));        try {            m.setRowVector(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        public void testGetColumnVector() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);        assertEquals("Column1", mColumn1, m.getColumnVector(1));        assertEquals("Column3", mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnVector() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);        assertNotSame(mColumn3, m.getColumnVector(1));        m.setColumnVector(1, mColumn3);        assertEquals(mColumn3, m.getColumnVector(1));        try {            m.setColumnVector(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    private FieldVector<Fraction> columnToVector(Fraction[][] column) {        Fraction[] data = new Fraction[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayFieldVector<Fraction>(data, false);    }    public void testGetRow() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        checkArrays(subRow0[0], m.getRow(0));        checkArrays(subRow3[0], m.getRow(3));        try {            m.getRow(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRow(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRow() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        assertTrue(subRow3[0][0] != m.getRow(0)[0]);        m.setRow(0, subRow3[0]);        checkArrays(subRow3[0], m.getRow(0));        try {            m.setRow(-1, subRow3[0]);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRow(0, new Fraction[5]);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        public void testGetColumn() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        Fraction[] mColumn1 = columnToArray(subColumn1);        Fraction[] mColumn3 = columnToArray(subColumn3);        checkArrays(mColumn1, m.getColumn(1));        checkArrays(mColumn3, m.getColumn(3));        try {            m.getColumn(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumn(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumn() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        Fraction[] mColumn3 = columnToArray(subColumn3);        assertTrue(mColumn3[0] != m.getColumn(1)[0]);        m.setColumn(1, mColumn3);        checkArrays(mColumn3, m.getColumn(1));        try {            m.setColumn(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumn(0, new Fraction[5]);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    private Fraction[] columnToArray(Fraction[][] column) {        Fraction[] data = new Fraction[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return data;    }    private void checkArrays(Fraction[] expected, Fraction[] actual) {        assertEquals(expected.length, actual.length);        for (int i = 0; i < expected.length; ++i) {            assertEquals(expected[i], actual[i]);                    }    }        public void testEqualsAndHashCode() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m1 = (Array2DRowFieldMatrix<Fraction>) m.copy();        Array2DRowFieldMatrix<Fraction> mt = (Array2DRowFieldMatrix<Fraction>) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(new Array2DRowFieldMatrix<Fraction>(bigSingular)));     }        public void testToString() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        assertEquals("Array2DRowFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}", m.toString());        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance());        assertEquals("Array2DRowFieldMatrix{}", m.toString());    }        public void testSetSubMatrix() throws Exception {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        m.setSubMatrix(detData2,1,1);        FieldMatrix<Fraction> expected = new Array2DRowFieldMatrix<Fraction>            (new Fraction[][] {                    {new Fraction(1),new Fraction(2),new Fraction(3)},                    {new Fraction(2),new Fraction(1),new Fraction(3)},                    {new Fraction(1),new Fraction(2),new Fraction(4)}             });        assertEquals(expected, m);                  m.setSubMatrix(detData2,0,0);        expected = new Array2DRowFieldMatrix<Fraction>            (new Fraction[][] {                    {new Fraction(1),new Fraction(3),new Fraction(3)},                    {new Fraction(2),new Fraction(4),new Fraction(3)},                    {new Fraction(1),new Fraction(2),new Fraction(4)}             });        assertEquals(expected, m);                  m.setSubMatrix(testDataPlus2,0,0);              expected = new Array2DRowFieldMatrix<Fraction>            (new Fraction[][] {                    {new Fraction(3),new Fraction(4),new Fraction(5)},                    {new Fraction(4),new Fraction(7),new Fraction(5)},                    {new Fraction(3),new Fraction(2),new Fraction(10)}             });        assertEquals(expected, m);                   // dimension overflow        try {              m.setSubMatrix(testData,1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // dimension underflow        try {              m.setSubMatrix(testData,-1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        try {              m.setSubMatrix(testData,1,-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }                // null        try {            m.setSubMatrix(null,1,1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance());        try {            m2.setSubMatrix(testData,0,1);            fail("expecting IllegalStateException");        } catch (IllegalStateException e) {            // expected        }        try {            m2.setSubMatrix(testData,1,0);            fail("expecting IllegalStateException");        } catch (IllegalStateException e) {            // expected        }                // ragged        try {            m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }               // empty        try {            m.setSubMatrix(new Fraction[][] {{}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }            }    public void testWalk() {        int rows    = 150;        int columns = 75;        FieldMatrix<Fraction> m =            new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInRowOrder(new SetVisitor());        GetVisitor getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(new Fraction(0), m.getEntry(i, 0));                                assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            assertEquals(new Fraction(0), m.getEntry(0, j));                                assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInColumnOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(new Fraction(0), m.getEntry(i, 0));                                assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            assertEquals(new Fraction(0), m.getEntry(0, j));                                assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(new Fraction(0), m.getEntry(i, 0));                                assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            assertEquals(new Fraction(0), m.getEntry(0, j));                                assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(new Fraction(0), m.getEntry(i, 0));                                assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            assertEquals(new Fraction(0), m.getEntry(0, j));                                assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }    }    public void testSerial()  {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        assertEquals(m,TestUtils.serializeAndRecover(m));    }      private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Fraction> {        public SetVisitor() {            super(Fraction.ZERO);        }        @Override        public Fraction visit(int i, int j, Fraction value) {            return new Fraction(i * 1024 + j, 1024);        }    }    private static class GetVisitor extends DefaultFieldMatrixPreservingVisitor<Fraction> {        private int count;        public GetVisitor() {            super(Fraction.ZERO);            count = 0;        }        @Override        public void visit(int i, int j, Fraction value) {            ++count;            assertEquals(new Fraction(i * 1024 + j, 1024), value);        }        public int getCount() {            return count;        }    }    //--------------- -----------------Protected methods        /** extracts the l  and u matrices from compact lu representation */    protected void splitLU(FieldMatrix<Fraction> lu,                           Fraction[][] lowerData,                           Fraction[][] upperData)        throws InvalidMatrixException {           if (!lu.isSquare() ||            lowerData.length != lowerData[0].length ||            upperData.length != upperData[0].length ||            lowerData.length != upperData.length ||            lowerData.length != lu.getRowDimension()) {            throw new InvalidMatrixException("incorrect dimensions");        }            int n = lu.getRowDimension();        for (int i = 0; i < n; i++) {            for (int j = 0; j < n; j++) {                if (j < i) {                    lowerData[i][j] = lu.getEntry(i, j);                    upperData[i][j] = Fraction.ZERO;                } else if (i == j) {                    lowerData[i][j] = Fraction.ONE;                    upperData[i][j] = lu.getEntry(i, j);                } else {                    lowerData[i][j] = Fraction.ZERO;                    upperData[i][j] = lu.getEntry(i, j);                }               }        }    }        /** Returns the result of applying the given row permutation to the matrix */    protected FieldMatrix<Fraction> permuteRows(FieldMatrix<Fraction> matrix, int[] permutation) {        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {            throw new IllegalArgumentException("dimension mismatch");        }        int n = matrix.getRowDimension();        int m = matrix.getColumnDimension();        Fraction out[][] = new Fraction[m][n];        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                out[i][j] = matrix.getEntry(permutation[i], j);            }        }        return new Array2DRowFieldMatrix<Fraction>(out);    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.linear.DecompositionSolver;import org.apache.commons.math.linear.InvalidMatrixException;import org.apache.commons.math.linear.LUDecompositionImpl;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.ArrayRealVector;public class LUSolverTest extends TestCase {    private double[][] testData = {            { 1.0, 2.0, 3.0},            { 2.0, 5.0, 3.0},            { 1.0, 0.0, 8.0}    };    private double[][] luData = {            { 2.0, 3.0, 3.0 },            { 0.0, 5.0, 7.0 },            { 6.0, 9.0, 8.0 }    };        // singular matrices    private double[][] singular = {            { 2.0, 3.0 },            { 2.0, 3.0 }    };    private double[][] bigSingular = {            { 1.0, 2.0,   3.0,    4.0 },            { 2.0, 5.0,   3.0,    4.0 },            { 7.0, 3.0, 256.0, 1930.0 },            { 3.0, 7.0,   6.0,    8.0 }    }; // 4th row = 1st + 2nd    public LUSolverTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(LUSolverTest.class);        suite.setName("LUSolver Tests");        return suite;    }    /** test threshold impact */    public void testThreshold() {        final RealMatrix matrix = MatrixUtils.createRealMatrix(new double[][] {                                                       { 1.0, 2.0, 3.0},                                                       { 2.0, 5.0, 3.0},                                                       { 4.000001, 9.0, 9.0}                                                     });        assertFalse(new LUDecompositionImpl(matrix, 1.0e-5).getSolver().isNonSingular());        assertTrue(new LUDecompositionImpl(matrix, 1.0e-10).getSolver().isNonSingular());    }    /** test singular */    public void testSingular() {        DecompositionSolver solver =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();        assertTrue(solver.isNonSingular());        solver = new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular)).getSolver();        assertFalse(solver.isNonSingular());        solver = new LUDecompositionImpl(MatrixUtils.createRealMatrix(bigSingular)).getSolver();        assertFalse(solver.isNonSingular());    }    /** test solve dimension errors */    public void testSolveDimensionErrors() {        DecompositionSolver solver =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);        try {            solver.solve(b);            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumn(0));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test solve singularity errors */    public void testSolveSingularityErrors() {        DecompositionSolver solver =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);        try {            solver.solve(b);            fail("an exception should have been thrown");        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumn(0));            fail("an exception should have been thrown");        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumnVector(0));            fail("an exception should have been thrown");        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));            fail("an exception should have been thrown");        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test solve */    public void testSolve() {        DecompositionSolver solver =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                { 1, 0 }, { 2, -5 }, { 3, 1 }        });        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                { 19, -71 }, { -6, 22 }, { -2, 9 }        });        // using RealMatrix        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);        // using double[]        for (int i = 0; i < b.getColumnDimension(); ++i) {            assertEquals(0,                         new ArrayRealVector(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }        // using ArrayRealVector        for (int i = 0; i < b.getColumnDimension(); ++i) {            assertEquals(0,                         solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }        // using RealVector with an alternate implementation        for (int i = 0; i < b.getColumnDimension(); ++i) {            ArrayRealVectorTest.RealVectorTestImpl v =                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));            assertEquals(0,                         solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }    }    /** test determinant */    public void testDeterminant() {        assertEquals( -1, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15);        assertEquals(-10, getDeterminant(MatrixUtils.createRealMatrix(luData)), 1.0e-14);        assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(singular)), 1.0e-17);        assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(bigSingular)), 1.0e-10);    }    private double getDeterminant(RealMatrix m) {        return new LUDecompositionImpl(m).getDeterminant();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Random;import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;import org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.MatrixVisitorException;import org.apache.commons.math.linear.QRDecomposition;import org.apache.commons.math.linear.QRDecompositionImpl;import org.apache.commons.math.linear.RealMatrix;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;public class QRDecompositionImplTest extends TestCase {    double[][] testData3x3NonSingular = {             { 12, -51, 4 },             { 6, 167, -68 },            { -4, 24, -41 }, };    double[][] testData3x3Singular = {             { 1, 4, 7, },             { 2, 5, 8, },            { 3, 6, 9, }, };    double[][] testData3x4 = {             { 12, -51, 4, 1 },             { 6, 167, -68, 2 },            { -4, 24, -41, 3 }, };    double[][] testData4x3 = {             { 12, -51, 4, },             { 6, 167, -68, },            { -4, 24, -41, },             { -5, 34, 7, }, };    private static final double entryTolerance = 10e-16;    private static final double normTolerance = 10e-14;    public QRDecompositionImplTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(QRDecompositionImplTest.class);        suite.setName("QRDecompositionImpl Tests");        return suite;    }    /** test dimensions */    public void testDimensions() {        checkDimension(MatrixUtils.createRealMatrix(testData3x3NonSingular));        checkDimension(MatrixUtils.createRealMatrix(testData4x3));        checkDimension(MatrixUtils.createRealMatrix(testData3x4));        Random r = new Random(643895747384642l);        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        checkDimension(createTestMatrix(r, p, q));        checkDimension(createTestMatrix(r, q, p));    }    private void checkDimension(RealMatrix m) {        int rows = m.getRowDimension();        int columns = m.getColumnDimension();        QRDecomposition qr = new QRDecompositionImpl(m);        assertEquals(rows,    qr.getQ().getRowDimension());        assertEquals(rows,    qr.getQ().getColumnDimension());        assertEquals(rows,    qr.getR().getRowDimension());        assertEquals(columns, qr.getR().getColumnDimension());            }    /** test A = QR */    public void testAEqualQR() {        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3NonSingular));        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3Singular));        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x4));        checkAEqualQR(MatrixUtils.createRealMatrix(testData4x3));        Random r = new Random(643895747384642l);        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        checkAEqualQR(createTestMatrix(r, p, q));        checkAEqualQR(createTestMatrix(r, q, p));    }    private void checkAEqualQR(RealMatrix m) {        QRDecomposition qr = new QRDecompositionImpl(m);        double norm = qr.getQ().multiply(qr.getR()).subtract(m).getNorm();        assertEquals(0, norm, normTolerance);    }    /** test the orthogonality of Q */    public void testQOrthogonal() {        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3NonSingular));        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3Singular));        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x4));        checkQOrthogonal(MatrixUtils.createRealMatrix(testData4x3));        Random r = new Random(643895747384642l);        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        checkQOrthogonal(createTestMatrix(r, p, q));        checkQOrthogonal(createTestMatrix(r, q, p));    }    private void checkQOrthogonal(RealMatrix m) {        QRDecomposition qr = new QRDecompositionImpl(m);        RealMatrix eye = MatrixUtils.createRealIdentityMatrix(m.getRowDimension());        double norm = qr.getQT().multiply(qr.getQ()).subtract(eye).getNorm();        assertEquals(0, norm, normTolerance);    }    /** test that R is upper triangular */    public void testRUpperTriangular() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());        matrix = MatrixUtils.createRealMatrix(testData3x4);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());        matrix = MatrixUtils.createRealMatrix(testData4x3);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());        Random r = new Random(643895747384642l);        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        matrix = createTestMatrix(r, p, q);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());        matrix = createTestMatrix(r, p, q);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());    }    private void checkUpperTriangular(RealMatrix m) {        m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {            @Override            public void visit(int row, int column, double value) {                if (column < row) {                    assertEquals(0.0, value, entryTolerance);                }            }        });    }    /** test that H is trapezoidal */    public void testHTrapezoidal() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());        matrix = MatrixUtils.createRealMatrix(testData3x4);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());        matrix = MatrixUtils.createRealMatrix(testData4x3);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());        Random r = new Random(643895747384642l);        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        matrix = createTestMatrix(r, p, q);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());        matrix = createTestMatrix(r, p, q);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());    }    private void checkTrapezoidal(RealMatrix m) {        m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {            @Override            public void visit(int row, int column, double value) {                if (column > row) {                    assertEquals(0.0, value, entryTolerance);                }            }        });    }    /** test matrices values */    public void testMatricesValues() {        QRDecomposition qr =            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular));        RealMatrix qRef = MatrixUtils.createRealMatrix(new double[][] {                { -12.0 / 14.0,   69.0 / 175.0,  -58.0 / 175.0 },                {  -6.0 / 14.0, -158.0 / 175.0,    6.0 / 175.0 },                {   4.0 / 14.0,  -30.0 / 175.0, -165.0 / 175.0 }        });        RealMatrix rRef = MatrixUtils.createRealMatrix(new double[][] {                { -14.0,  -21.0, 14.0 },                {   0.0, -175.0, 70.0 },                {   0.0,    0.0, 35.0 }        });        RealMatrix hRef = MatrixUtils.createRealMatrix(new double[][] {                { 26.0 / 14.0, 0.0, 0.0 },                {  6.0 / 14.0, 648.0 / 325.0, 0.0 },                { -4.0 / 14.0,  36.0 / 325.0, 2.0 }        });        // check values against known references        RealMatrix q = qr.getQ();        assertEquals(0, q.subtract(qRef).getNorm(), 1.0e-13);        RealMatrix qT = qr.getQT();        assertEquals(0, qT.subtract(qRef.transpose()).getNorm(), 1.0e-13);        RealMatrix r = qr.getR();        assertEquals(0, r.subtract(rRef).getNorm(), 1.0e-13);        RealMatrix h = qr.getH();        assertEquals(0, h.subtract(hRef).getNorm(), 1.0e-13);        // check the same cached instance is returned the second time        assertTrue(q == qr.getQ());        assertTrue(r == qr.getR());        assertTrue(h == qr.getH());            }    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {        RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);        m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){            @Override            public double visit(int row, int column, double value)                throws MatrixVisitorException {                return 2.0 * r.nextDouble() - 1.0;            }        });        return m;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import org.apache.commons.math.MathException;import org.apache.commons.math.linear.CholeskyDecomposition;import org.apache.commons.math.linear.CholeskyDecompositionImpl;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.NonSquareMatrixException;import org.apache.commons.math.linear.NotPositiveDefiniteMatrixException;import org.apache.commons.math.linear.NotSymmetricMatrixException;import org.apache.commons.math.linear.RealMatrix;import org.junit.Test;public class CholeskyDecompositionImplTest {    private double[][] testData = new double[][] {            {  1,  2,   4,   7,  11 },            {  2, 13,  23,  38,  58 },            {  4, 23,  77, 122, 182 },            {  7, 38, 122, 294, 430 },            { 11, 58, 182, 430, 855 }    };    /** test dimensions */    @Test    public void testDimensions() throws MathException {        CholeskyDecomposition llt =            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData));        assertEquals(testData.length, llt.getL().getRowDimension());        assertEquals(testData.length, llt.getL().getColumnDimension());        assertEquals(testData.length, llt.getLT().getRowDimension());        assertEquals(testData.length, llt.getLT().getColumnDimension());    }    /** test non-square matrix */    @Test(expected = NonSquareMatrixException.class)    public void testNonSquare() throws MathException {        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[3][2]));    }    /** test non-symmetric matrix */    @Test(expected = NotSymmetricMatrixException.class)    public void testNotSymmetricMatrixException() throws MathException {        double[][] changed = testData.clone();        changed[0][changed[0].length - 1] += 1.0e-5;        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(changed));    }    /** test non positive definite matrix */    @Test(expected = NotPositiveDefiniteMatrixException.class)    public void testNotPositiveDefinite() throws MathException {        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {                { 14, 11, 13, 15, 24 },                { 11, 34, 13, 8,  25 },                { 13, 13, 14, 15, 21 },                { 15, 8,  15, 18, 23 },                { 24, 25, 21, 23, 45 }        }));    }    @Test(expected = NotPositiveDefiniteMatrixException.class)    public void testMath274() throws MathException {        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {                { 0.40434286, -0.09376327, 0.30328980, 0.04909388 },                {-0.09376327,  0.10400408, 0.07137959, 0.04762857 },                { 0.30328980,  0.07137959, 0.30458776, 0.04882449 },                { 0.04909388,  0.04762857, 0.04882449, 0.07543265 }                    }));    }    /** test A = LLT */    @Test    public void testAEqualLLT() throws MathException {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        CholeskyDecomposition llt = new CholeskyDecompositionImpl(matrix);        RealMatrix l  = llt.getL();        RealMatrix lt = llt.getLT();        double norm = l.multiply(lt).subtract(matrix).getNorm();        assertEquals(0, norm, 1.0e-15);    }    /** test that L is lower triangular */    @Test    public void testLLowerTriangular() throws MathException {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        RealMatrix l = new CholeskyDecompositionImpl(matrix).getL();        for (int i = 0; i < l.getRowDimension(); i++) {            for (int j = i + 1; j < l.getColumnDimension(); j++) {                assertEquals(0.0, l.getEntry(i, j), 0.0);            }        }    }    /** test that LT is transpose of L */    @Test    public void testLTTransposed() throws MathException {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        CholeskyDecomposition llt = new CholeskyDecompositionImpl(matrix);        RealMatrix l  = llt.getL();        RealMatrix lt = llt.getLT();        double norm = l.subtract(lt.transpose()).getNorm();        assertEquals(0, norm, 1.0e-15);    }    /** test matrices values */    @Test    public void testMatricesValues() throws MathException {        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {                {  1,  0,  0,  0,  0 },                {  2,  3,  0,  0,  0 },                {  4,  5,  6,  0,  0 },                {  7,  8,  9, 10,  0 },                { 11, 12, 13, 14, 15 }        });       CholeskyDecomposition llt =            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData));        // check values against known references        RealMatrix l = llt.getL();        assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);        RealMatrix lt = llt.getLT();        assertEquals(0, lt.subtract(lRef.transpose()).getNorm(), 1.0e-13);        // check the same cached instance is returned the second time        assertTrue(l  == llt.getL());        assertTrue(lt == llt.getLT());            }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Arrays;import java.util.Random;import org.apache.commons.math.linear.EigenDecomposition;import org.apache.commons.math.linear.EigenDecompositionImpl;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.RealVector;import org.apache.commons.math.linear.TriDiagonalTransformer;import org.apache.commons.math.util.MathUtils;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;public class EigenDecompositionImplTest extends TestCase {    private double[] refValues;    private RealMatrix matrix;    public EigenDecompositionImplTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(EigenDecompositionImplTest.class);        suite.setName("EigenDecompositionImpl Tests");        return suite;    }    public void testDimension1() {        RealMatrix matrix =            MatrixUtils.createRealMatrix(new double[][] { { 1.5 } });        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        assertEquals(1.5, ed.getRealEigenvalue(0), 1.0e-15);    }    public void testDimension2() {        RealMatrix matrix =            MatrixUtils.createRealMatrix(new double[][] {                    { 59.0, 12.0 },                    { 12.0, 66.0 }            });        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        assertEquals(75.0, ed.getRealEigenvalue(0), 1.0e-15);        assertEquals(50.0, ed.getRealEigenvalue(1), 1.0e-15);    }    public void testDimension3() {        RealMatrix matrix =            MatrixUtils.createRealMatrix(new double[][] {                                   {  39632.0, -4824.0, -16560.0 },                                   {  -4824.0,  8693.0,   7920.0 },                                   { -16560.0,  7920.0,  17300.0 }                               });        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        assertEquals(50000.0, ed.getRealEigenvalue(0), 3.0e-11);        assertEquals(12500.0, ed.getRealEigenvalue(1), 3.0e-11);        assertEquals( 3125.0, ed.getRealEigenvalue(2), 3.0e-11);    }    public void testDimension4WithSplit() {        RealMatrix matrix =            MatrixUtils.createRealMatrix(new double[][] {                                   {  0.784, -0.288,  0.000,  0.000 },                                   { -0.288,  0.616,  0.000,  0.000 },                                   {  0.000,  0.000,  0.164, -0.048 },                                   {  0.000,  0.000, -0.048,  0.136 }                               });        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);        assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);        assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);        assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);    }    public void testDimension4WithoutSplit() {        RealMatrix matrix =            MatrixUtils.createRealMatrix(new double[][] {                                   {  0.5608, -0.2016,  0.1152, -0.2976 },                                   { -0.2016,  0.4432, -0.2304,  0.1152 },                                   {  0.1152, -0.2304,  0.3088, -0.1344 },                                   { -0.2976,  0.1152, -0.1344,  0.3872 }                               });        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);        assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);        assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);        assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);    }    /** test a matrix already in tridiagonal form. */    public void testTridiagonal() {        Random r = new Random(4366663527842l);        double[] ref = new double[30];        for (int i = 0; i < ref.length; ++i) {            if (i < 5) {                ref[i] = 2 * r.nextDouble() - 1;            } else {                ref[i] = 0.0001 * r.nextDouble() + 6;                            }        }        Arrays.sort(ref);        TriDiagonalTransformer t =            new TriDiagonalTransformer(createTestMatrix(r, ref));        EigenDecomposition ed =            new EigenDecompositionImpl(t.getMainDiagonalRef(),                                       t.getSecondaryDiagonalRef(),                                       MathUtils.SAFE_MIN);        double[] eigenValues = ed.getRealEigenvalues();        assertEquals(ref.length, eigenValues.length);        for (int i = 0; i < ref.length; ++i) {            assertEquals(ref[ref.length - i - 1], eigenValues[i], 2.0e-14);        }            }    /** test dimensions */    public void testDimensions() {        final int m = matrix.getRowDimension();        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        assertEquals(m, ed.getV().getRowDimension());        assertEquals(m, ed.getV().getColumnDimension());        assertEquals(m, ed.getD().getColumnDimension());        assertEquals(m, ed.getD().getColumnDimension());        assertEquals(m, ed.getVT().getRowDimension());        assertEquals(m, ed.getVT().getColumnDimension());    }    /** test eigenvalues */    public void testEigenvalues() {        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        double[] eigenValues = ed.getRealEigenvalues();        assertEquals(refValues.length, eigenValues.length);        for (int i = 0; i < refValues.length; ++i) {            assertEquals(refValues[i], eigenValues[i], 3.0e-15);        }    }    /** test eigenvalues for a big matrix. */    public void testBigMatrix() {        Random r = new Random(17748333525117l);        double[] bigValues = new double[200];        for (int i = 0; i < bigValues.length; ++i) {            bigValues[i] = 2 * r.nextDouble() - 1;        }        Arrays.sort(bigValues);        EigenDecomposition ed =            new EigenDecompositionImpl(createTestMatrix(r, bigValues), MathUtils.SAFE_MIN);        double[] eigenValues = ed.getRealEigenvalues();        assertEquals(bigValues.length, eigenValues.length);        for (int i = 0; i < bigValues.length; ++i) {            assertEquals(bigValues[bigValues.length - i - 1], eigenValues[i], 2.0e-14);        }    }    /** test eigenvectors */    public void testEigenvectors() {        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        for (int i = 0; i < matrix.getRowDimension(); ++i) {            double lambda = ed.getRealEigenvalue(i);            RealVector v  = ed.getEigenvector(i);            RealVector mV = matrix.operate(v);            assertEquals(0, mV.subtract(v.mapMultiplyToSelf(lambda)).getNorm(), 1.0e-13);        }    }    /** test A = VDVt */    public void testAEqualVDVt() {        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        RealMatrix v  = ed.getV();        RealMatrix d  = ed.getD();        RealMatrix vT = ed.getVT();        double norm = v.multiply(d).multiply(vT).subtract(matrix).getNorm();        assertEquals(0, norm, 6.0e-13);    }    /** test that V is orthogonal */    public void testVOrthogonal() {        RealMatrix v = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN).getV();        RealMatrix vTv = v.transpose().multiply(v);        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension());        assertEquals(0, vTv.subtract(id).getNorm(), 2.0e-13);    }    /** test diagonal matrix */    public void testDiagonal() {        double[] diagonal = new double[] { -3.0, -2.0, 2.0, 5.0 };        RealMatrix m = createDiagonalMatrix(diagonal, diagonal.length, diagonal.length);        EigenDecomposition ed = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN);        assertEquals(diagonal[0], ed.getRealEigenvalue(3), 2.0e-15);        assertEquals(diagonal[1], ed.getRealEigenvalue(2), 2.0e-15);        assertEquals(diagonal[2], ed.getRealEigenvalue(1), 2.0e-15);        assertEquals(diagonal[3], ed.getRealEigenvalue(0), 2.0e-15);    }    /**     * Matrix with eigenvalues {8, -1, -1}     */    public void testRepeatedEigenvalue() {        RealMatrix repeated = MatrixUtils.createRealMatrix(new double[][] {                {3,  2,  4},                {2,  0,  2},                {4,  2,  3}        });         EigenDecomposition ed = new EigenDecompositionImpl(repeated, MathUtils.SAFE_MIN);        checkEigenValues((new double[] {8, -1, -1}), ed, 1E-12);        checkEigenVector((new double[] {2, 1, 2}), ed, 1E-12);    }        /**     * Matrix with eigenvalues {2, 0, 12}     */    public void testDistinctEigenvalues() {        RealMatrix distinct = MatrixUtils.createRealMatrix(new double[][] {                {3, 1, -4},                  {1, 3, -4},                 {-4, -4, 8}        });        EigenDecomposition ed = new EigenDecompositionImpl(distinct, MathUtils.SAFE_MIN);        checkEigenValues((new double[] {2, 0, 12}), ed, 1E-12);        checkEigenVector((new double[] {1, -1, 0}), ed, 1E-12);        checkEigenVector((new double[] {1, 1, 1}), ed, 1E-12);        checkEigenVector((new double[] {-1, -1, 2}), ed, 1E-12);    }        /**     * Verifies that the given EigenDecomposition has eigenvalues equivalent to     * the targetValues, ignoring the order of the values and allowing     * values to differ by tolerance.     */    protected void checkEigenValues(double[] targetValues,            EigenDecomposition ed, double tolerance) {        double[] observed = ed.getRealEigenvalues();        for (int i = 0; i < observed.length; i++) {            assertTrue(isIncludedValue(observed[i], targetValues, tolerance));            assertTrue(isIncludedValue(targetValues[i], observed, tolerance));        }    }        /**     * Returns true iff there is an entry within tolerance of value in     * searchArray.     */    private boolean isIncludedValue(double value, double[] searchArray,            double tolerance) {       boolean found = false;       int i = 0;       while (!found && i < searchArray.length) {           if (Math.abs(value - searchArray[i]) < tolerance) {               found = true;           }           i++;       }       return found;    }        /**     * Returns true iff eigenVector is a scalar multiple of one of the columns     * of ed.getV().  Does not try linear combinations - i.e., should only be     * used to find vectors in one-dimensional eigenspaces.     */    protected void checkEigenVector(double[] eigenVector,            EigenDecomposition ed, double tolerance) {        assertTrue(isIncludedColumn(eigenVector, ed.getV(), tolerance));    }        /**     * Returns true iff there is a column that is a scalar multiple of column     * in searchMatrix (modulo tolerance)     */    private boolean isIncludedColumn(double[] column, RealMatrix searchMatrix,            double tolerance) {        boolean found = false;        int i = 0;        while (!found && i < searchMatrix.getColumnDimension()) {            double multiplier = 1d;            boolean matching = true;            int j = 0;            while (matching && j < searchMatrix.getRowDimension()) {                double colEntry = searchMatrix.getEntry(j, i);                // Use the first entry where both are non-zero as scalar                if (multiplier == 1d && Math.abs(colEntry) > 1E-14                        && Math.abs(column[j]) > 1e-14) {                    multiplier = colEntry / column[j];                }                 if (Math.abs(column[j] * multiplier - colEntry) > tolerance) {                    matching = false;                }                j++;            }            found = matching;            i++;        }        return found;    }    @Override    public void setUp() {        refValues = new double[] {                2.003, 2.002, 2.001, 1.001, 1.000, 0.001        };        matrix = createTestMatrix(new Random(35992629946426l), refValues);    }    @Override    public void tearDown() {        refValues = null;        matrix    = null;    }    static RealMatrix createTestMatrix(final Random r, final double[] eigenValues) {        final int n = eigenValues.length;        final RealMatrix v = createOrthogonalMatrix(r, n);        final RealMatrix d = createDiagonalMatrix(eigenValues, n, n);        return v.multiply(d).multiply(v.transpose());    }    public static RealMatrix createOrthogonalMatrix(final Random r, final int size) {        final double[][] data = new double[size][size];        for (int i = 0; i < size; ++i) {            final double[] dataI = data[i];            double norm2 = 0;            do {                // generate randomly row I                for (int j = 0; j < size; ++j) {                    dataI[j] = 2 * r.nextDouble() - 1;                }                // project the row in the subspace orthogonal to previous rows                for (int k = 0; k < i; ++k) {                    final double[] dataK = data[k];                    double dotProduct = 0;                    for (int j = 0; j < size; ++j) {                        dotProduct += dataI[j] * dataK[j];                    }                    for (int j = 0; j < size; ++j) {                        dataI[j] -= dotProduct * dataK[j];                    }                }                // normalize the row                norm2 = 0;                for (final double dataIJ : dataI) {                    norm2 += dataIJ * dataIJ;                }                final double inv = 1.0 / Math.sqrt(norm2);                for (int j = 0; j < size; ++j) {                    dataI[j] *= inv;                }            } while (norm2 * size < 0.01);        }        return MatrixUtils.createRealMatrix(data);    }    public static RealMatrix createDiagonalMatrix(final double[] diagonal,                                                  final int rows, final int columns) {        final double[][] dData = new double[rows][columns];        for (int i = 0; i < Math.min(rows, columns); ++i) {            dData[i][i] = diagonal[i];        }        return MatrixUtils.createRealMatrix(dData);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import java.math.BigDecimal;import java.math.BigInteger;import java.text.NumberFormat;import java.text.ParseException;import java.util.Locale;import junit.framework.TestCase;public class BigFractionFormatTest extends TestCase {     BigFractionFormat properFormat = null;    BigFractionFormat improperFormat = null;    protected Locale getLocale() {        return Locale.getDefault();    }    @Override    protected void setUp() throws Exception {        properFormat = BigFractionFormat.getProperInstance(getLocale());        improperFormat = BigFractionFormat.getImproperInstance(getLocale());    }       public void testFormat() {        BigFraction c = new BigFraction(1, 2);        String expected = "1 / 2";                String actual = properFormat.format(c);         assertEquals(expected, actual);        actual = improperFormat.format(c);        assertEquals(expected, actual);    }    public void testFormatNegative() {        BigFraction c = new BigFraction(-1, 2);        String expected = "-1 / 2";        String actual = properFormat.format(c);         assertEquals(expected, actual);        actual = improperFormat.format(c);         assertEquals(expected, actual);    }    public void testFormatZero() {        BigFraction c = new BigFraction(0, 1);        String expected = "0 / 1";        String actual = properFormat.format(c);         assertEquals(expected, actual);        actual = improperFormat.format(c);         assertEquals(expected, actual);    }        public void testFormatImproper() {        BigFraction c = new BigFraction(5, 3);        String actual = properFormat.format(c);         assertEquals("1 2 / 3", actual);        actual = improperFormat.format(c);         assertEquals("5 / 3", actual);    }        public void testFormatImproperNegative() {        BigFraction c = new BigFraction(-5, 3);        String actual = properFormat.format(c);         assertEquals("-1 2 / 3", actual);        actual = improperFormat.format(c);         assertEquals("-5 / 3", actual);    }        public void testParse() {        String source = "1 / 2";        try {            BigFraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(BigInteger.ONE, c.getNumerator());            assertEquals(BigInteger.valueOf(2l), c.getDenominator());                        c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(BigInteger.ONE, c.getNumerator());            assertEquals(BigInteger.valueOf(2l), c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }    }        public void testParseInteger() {        String source = "10";        try {            BigFraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(BigInteger.TEN, c.getNumerator());            assertEquals(BigInteger.ONE, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }        try {            BigFraction c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(BigInteger.TEN, c.getNumerator());            assertEquals(BigInteger.ONE, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }    }        public void testParseInvalid() {        String source = "a";        String msg = "should not be able to parse '10 / a'.";        try {            properFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }        try {            improperFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }    }        public void testParseInvalidDenominator() {        String source = "10 / a";        String msg = "should not be able to parse '10 / a'.";        try {            properFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }        try {            improperFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }    }        public void testParseNegative() {        try {            String source = "-1 / 2";            BigFraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumeratorAsInt());            assertEquals(2, c.getDenominatorAsInt());                        c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumeratorAsInt());            assertEquals(2, c.getDenominatorAsInt());            source = "1 / -2";            c = properFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumeratorAsInt());            assertEquals(2, c.getDenominatorAsInt());                        c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumeratorAsInt());            assertEquals(2, c.getDenominatorAsInt());        } catch (ParseException ex) {            fail(ex.getMessage());        }    }        public void testParseProper() {        String source = "1 2 / 3";        try {            BigFraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(5, c.getNumeratorAsInt());            assertEquals(3, c.getDenominatorAsInt());        } catch (ParseException ex) {            fail(ex.getMessage());        }                try {            improperFormat.parse(source);            fail("invalid improper fraction.");        } catch (ParseException ex) {            // success        }    }        public void testParseProperNegative() {        String source = "-1 2 / 3";        try {            BigFraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(-5, c.getNumeratorAsInt());            assertEquals(3, c.getDenominatorAsInt());        } catch (ParseException ex) {            fail(ex.getMessage());        }                try {            improperFormat.parse(source);            fail("invalid improper fraction.");        } catch (ParseException ex) {            // success        }    }        public void testParseProperInvalidMinus() {        String source = "2 -2 / 3";        try {            properFormat.parse(source);            fail("invalid minus in improper fraction.");        } catch (ParseException ex) {            // expected        }        source = "2 2 / -3";        try {            properFormat.parse(source);            fail("invalid minus in improper fraction.");        } catch (ParseException ex) {            // expected        }    }    public void testParseBig() throws ParseException {        BigFraction f1 =            improperFormat.parse("167213075789791382630275400487886041651764456874403" +                                 " / " +                                 "53225575123090058458126718248444563466137046489291");        assertEquals(Math.PI, f1.doubleValue(), 0.0);        BigFraction f2 =            properFormat.parse("3 " +                               "7536350420521207255895245742552351253353317406530" +                               " / " +                               "53225575123090058458126718248444563466137046489291");        assertEquals(Math.PI, f2.doubleValue(), 0.0);        assertEquals(f1, f2);        BigDecimal pi =            new BigDecimal("3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068");        assertEquals(pi, f1.bigDecimalValue(99, BigDecimal.ROUND_HALF_EVEN));    }        public void testNumeratorFormat() {        NumberFormat old = properFormat.getNumeratorFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        properFormat.setNumeratorFormat(nf);        assertEquals(nf, properFormat.getNumeratorFormat());        properFormat.setNumeratorFormat(old);        old = improperFormat.getNumeratorFormat();        nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        improperFormat.setNumeratorFormat(nf);        assertEquals(nf, improperFormat.getNumeratorFormat());        improperFormat.setNumeratorFormat(old);    }        public void testDenominatorFormat() {        NumberFormat old = properFormat.getDenominatorFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        properFormat.setDenominatorFormat(nf);        assertEquals(nf, properFormat.getDenominatorFormat());        properFormat.setDenominatorFormat(old);        old = improperFormat.getDenominatorFormat();        nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        improperFormat.setDenominatorFormat(nf);        assertEquals(nf, improperFormat.getDenominatorFormat());        improperFormat.setDenominatorFormat(old);    }        public void testWholeFormat() {        ProperBigFractionFormat format = (ProperBigFractionFormat)properFormat;                NumberFormat old = format.getWholeFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        format.setWholeFormat(nf);        assertEquals(nf, format.getWholeFormat());        format.setWholeFormat(old);    }        public void testLongFormat() {        assertEquals("10 / 1", improperFormat.format(10l));    }        public void testDoubleFormat() {        assertEquals("1 / 16", improperFormat.format(0.0625));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import org.apache.commons.math.ConvergenceException;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class FractionTest extends TestCase {    private void assertFraction(int expectedNumerator, int expectedDenominator, Fraction actual) {        assertEquals(expectedNumerator, actual.getNumerator());        assertEquals(expectedDenominator, actual.getDenominator());    }        public void testConstructor() {        assertFraction(0, 1, new Fraction(0, 1));        assertFraction(0, 1, new Fraction(0, 2));        assertFraction(0, 1, new Fraction(0, -1));        assertFraction(1, 2, new Fraction(1, 2));        assertFraction(1, 2, new Fraction(2, 4));        assertFraction(-1, 2, new Fraction(-1, 2));        assertFraction(-1, 2, new Fraction(1, -2));        assertFraction(-1, 2, new Fraction(-2, 4));        assertFraction(-1, 2, new Fraction(2, -4));                // overflow        try {            new Fraction(Integer.MIN_VALUE, -1);            fail();        } catch (ArithmeticException ex) {            // success        }        try {            new Fraction(1, Integer.MIN_VALUE);            fail();        } catch (ArithmeticException ex) {            // success        }        try {                    assertFraction(0, 1, new Fraction(0.00000000000001));            assertFraction(2, 5, new Fraction(0.40000000000001));            assertFraction(15, 1, new Fraction(15.0000000000001));                    } catch (ConvergenceException ex) {            fail(ex.getMessage());        }    }    public void testGoldenRatio() {        try {            // the golden ratio is notoriously a difficult number for continuous fraction            new Fraction((1 + Math.sqrt(5)) / 2, 1.0e-12, 25);            fail("an exception should have been thrown");        } catch (ConvergenceException ce) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    // MATH-179    public void testDoubleConstructor() throws ConvergenceException  {        assertFraction(1, 2, new Fraction((double)1 / (double)2));        assertFraction(1, 3, new Fraction((double)1 / (double)3));        assertFraction(2, 3, new Fraction((double)2 / (double)3));        assertFraction(1, 4, new Fraction((double)1 / (double)4));        assertFraction(3, 4, new Fraction((double)3 / (double)4));        assertFraction(1, 5, new Fraction((double)1 / (double)5));        assertFraction(2, 5, new Fraction((double)2 / (double)5));        assertFraction(3, 5, new Fraction((double)3 / (double)5));        assertFraction(4, 5, new Fraction((double)4 / (double)5));        assertFraction(1, 6, new Fraction((double)1 / (double)6));        assertFraction(5, 6, new Fraction((double)5 / (double)6));        assertFraction(1, 7, new Fraction((double)1 / (double)7));        assertFraction(2, 7, new Fraction((double)2 / (double)7));        assertFraction(3, 7, new Fraction((double)3 / (double)7));        assertFraction(4, 7, new Fraction((double)4 / (double)7));        assertFraction(5, 7, new Fraction((double)5 / (double)7));        assertFraction(6, 7, new Fraction((double)6 / (double)7));        assertFraction(1, 8, new Fraction((double)1 / (double)8));        assertFraction(3, 8, new Fraction((double)3 / (double)8));        assertFraction(5, 8, new Fraction((double)5 / (double)8));        assertFraction(7, 8, new Fraction((double)7 / (double)8));        assertFraction(1, 9, new Fraction((double)1 / (double)9));        assertFraction(2, 9, new Fraction((double)2 / (double)9));        assertFraction(4, 9, new Fraction((double)4 / (double)9));        assertFraction(5, 9, new Fraction((double)5 / (double)9));        assertFraction(7, 9, new Fraction((double)7 / (double)9));        assertFraction(8, 9, new Fraction((double)8 / (double)9));        assertFraction(1, 10, new Fraction((double)1 / (double)10));        assertFraction(3, 10, new Fraction((double)3 / (double)10));        assertFraction(7, 10, new Fraction((double)7 / (double)10));        assertFraction(9, 10, new Fraction((double)9 / (double)10));        assertFraction(1, 11, new Fraction((double)1 / (double)11));        assertFraction(2, 11, new Fraction((double)2 / (double)11));        assertFraction(3, 11, new Fraction((double)3 / (double)11));        assertFraction(4, 11, new Fraction((double)4 / (double)11));        assertFraction(5, 11, new Fraction((double)5 / (double)11));        assertFraction(6, 11, new Fraction((double)6 / (double)11));        assertFraction(7, 11, new Fraction((double)7 / (double)11));        assertFraction(8, 11, new Fraction((double)8 / (double)11));        assertFraction(9, 11, new Fraction((double)9 / (double)11));        assertFraction(10, 11, new Fraction((double)10 / (double)11));    }    // MATH-181    public void testDigitLimitConstructor() throws ConvergenceException  {        assertFraction(2, 5, new Fraction(0.4,   9));        assertFraction(2, 5, new Fraction(0.4,  99));        assertFraction(2, 5, new Fraction(0.4, 999));        assertFraction(3, 5,      new Fraction(0.6152,    9));        assertFraction(8, 13,     new Fraction(0.6152,   99));        assertFraction(510, 829,  new Fraction(0.6152,  999));        assertFraction(769, 1250, new Fraction(0.6152, 9999));    }    public void testIntegerOverflow() {        checkIntegerOverflow(0.75000000001455192);        checkIntegerOverflow(1.0e10);    }    private void checkIntegerOverflow(double a) {        try {            new Fraction(a, 1.0e-12, 1000);            fail("an exception should have been thrown");        } catch (ConvergenceException ce) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testEpsilonLimitConstructor() throws ConvergenceException  {        assertFraction(2, 5, new Fraction(0.4, 1.0e-5, 100));        assertFraction(3, 5,      new Fraction(0.6152, 0.02, 100));        assertFraction(8, 13,     new Fraction(0.6152, 1.0e-3, 100));        assertFraction(251, 408,  new Fraction(0.6152, 1.0e-4, 100));        assertFraction(251, 408,  new Fraction(0.6152, 1.0e-5, 100));        assertFraction(510, 829,  new Fraction(0.6152, 1.0e-6, 100));        assertFraction(769, 1250, new Fraction(0.6152, 1.0e-7, 100));    }    public void testCompareTo() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(1, 3);        Fraction third = new Fraction(1, 2);                assertEquals(0, first.compareTo(first));        assertEquals(0, first.compareTo(third));        assertEquals(1, first.compareTo(second));        assertEquals(-1, second.compareTo(first));        // these two values are different approximations of PI        // the first  one is approximately PI - 3.07e-18        // the second one is approximately PI + 1.936e-17        Fraction pi1 = new Fraction(1068966896, 340262731);        Fraction pi2 = new Fraction( 411557987, 131002976);        assertEquals(-1, pi1.compareTo(pi2));        assertEquals( 1, pi2.compareTo(pi1));        assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);    }        public void testDoubleValue() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(1, 3);        assertEquals(0.5, first.doubleValue(), 0.0);        assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);    }        public void testFloatValue() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(1, 3);        assertEquals(0.5f, first.floatValue(), 0.0f);        assertEquals((float)(1.0 / 3.0), second.floatValue(), 0.0f);    }        public void testIntValue() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(3, 2);        assertEquals(0, first.intValue());        assertEquals(1, second.intValue());    }        public void testLongValue() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(3, 2);        assertEquals(0L, first.longValue());        assertEquals(1L, second.longValue());    }        public void testConstructorDouble() {        try {            assertFraction(1, 2, new Fraction(0.5));            assertFraction(1, 3, new Fraction(1.0 / 3.0));            assertFraction(17, 100, new Fraction(17.0 / 100.0));            assertFraction(317, 100, new Fraction(317.0 / 100.0));            assertFraction(-1, 2, new Fraction(-0.5));            assertFraction(-1, 3, new Fraction(-1.0 / 3.0));            assertFraction(-17, 100, new Fraction(17.0 / -100.0));            assertFraction(-317, 100, new Fraction(-317.0 / 100.0));        } catch (ConvergenceException ex) {            fail(ex.getMessage());        }    }        public void testAbs() {        Fraction a = new Fraction(10, 21);        Fraction b = new Fraction(-10, 21);        Fraction c = new Fraction(10, -21);                assertFraction(10, 21, a.abs());        assertFraction(10, 21, b.abs());        assertFraction(10, 21, c.abs());    }        public void testReciprocal() {        Fraction f = null;                f = new Fraction(50, 75);        f = f.reciprocal();        assertEquals(3, f.getNumerator());        assertEquals(2, f.getDenominator());                f = new Fraction(4, 3);        f = f.reciprocal();        assertEquals(3, f.getNumerator());        assertEquals(4, f.getDenominator());                f = new Fraction(-15, 47);        f = f.reciprocal();        assertEquals(-47, f.getNumerator());        assertEquals(15, f.getDenominator());                f = new Fraction(0, 3);        try {            f = f.reciprocal();            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}        // large values        f = new Fraction(Integer.MAX_VALUE, 1);        f = f.reciprocal();        assertEquals(1, f.getNumerator());        assertEquals(Integer.MAX_VALUE, f.getDenominator());    }        public void testNegate() {        Fraction f = null;                f = new Fraction(50, 75);        f = f.negate();        assertEquals(-2, f.getNumerator());        assertEquals(3, f.getDenominator());                f = new Fraction(-50, 75);        f = f.negate();        assertEquals(2, f.getNumerator());        assertEquals(3, f.getDenominator());        // large values        f = new Fraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE);        f = f.negate();        assertEquals(Integer.MIN_VALUE+2, f.getNumerator());        assertEquals(Integer.MAX_VALUE, f.getDenominator());        f = new Fraction(Integer.MIN_VALUE, 1);        try {            f = f.negate();            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}    }        public void testAdd() {        Fraction a = new Fraction(1, 2);        Fraction b = new Fraction(2, 3);                assertFraction(1, 1, a.add(a));        assertFraction(7, 6, a.add(b));        assertFraction(7, 6, b.add(a));        assertFraction(4, 3, b.add(b));                Fraction f1 = new Fraction(Integer.MAX_VALUE - 1, 1);        Fraction f2 = Fraction.ONE;        Fraction f = f1.add(f2);        assertEquals(Integer.MAX_VALUE, f.getNumerator());        assertEquals(1, f.getDenominator());        f = f1.add(1);        assertEquals(Integer.MAX_VALUE, f.getNumerator());        assertEquals(1, f.getDenominator());                f1 = new Fraction(-1, 13*13*2*2);        f2 = new Fraction(-2, 13*17*2);        f = f1.add(f2);        assertEquals(13*13*17*2*2, f.getDenominator());        assertEquals(-17 - 2*13*2, f.getNumerator());                try {            f.add(null);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {}                // if this fraction is added naively, it will overflow.        // check that it doesn't.        f1 = new Fraction(1,32768*3);        f2 = new Fraction(1,59049);        f = f1.add(f2);        assertEquals(52451, f.getNumerator());        assertEquals(1934917632, f.getDenominator());        f1 = new Fraction(Integer.MIN_VALUE, 3);        f2 = new Fraction(1,3);        f = f1.add(f2);        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());        assertEquals(3, f.getDenominator());                f1 = new Fraction(Integer.MAX_VALUE - 1, 1);        f2 = Fraction.ONE;        f = f1.add(f2);        assertEquals(Integer.MAX_VALUE, f.getNumerator());        assertEquals(1, f.getDenominator());                try {            f = f.add(Fraction.ONE); // should overflow            fail("expecting ArithmeticException but got: " + f.toString());        } catch (ArithmeticException ex) {}                // denominator should not be a multiple of 2 or 3 to trigger overflow        f1 = new Fraction(Integer.MIN_VALUE, 5);        f2 = new Fraction(-1,5);        try {            f = f1.add(f2); // should overflow            fail("expecting ArithmeticException but got: " + f.toString());        } catch (ArithmeticException ex) {}                try {            f= new Fraction(-Integer.MAX_VALUE, 1);            f = f.add(f);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}                try {            f= new Fraction(-Integer.MAX_VALUE, 1);            f = f.add(f);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}                f1 = new Fraction(3,327680);        f2 = new Fraction(2,59049);        try {            f = f1.add(f2); // should overflow            fail("expecting ArithmeticException but got: " + f.toString());        } catch (ArithmeticException ex) {}    }        public void testDivide() {        Fraction a = new Fraction(1, 2);        Fraction b = new Fraction(2, 3);                assertFraction(1, 1, a.divide(a));        assertFraction(3, 4, a.divide(b));        assertFraction(4, 3, b.divide(a));        assertFraction(1, 1, b.divide(b));                Fraction f1 = new Fraction(3, 5);        Fraction f2 = Fraction.ZERO;        try {            f1.divide(f2);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}                f1 = new Fraction(0, 5);        f2 = new Fraction(2, 7);        Fraction f = f1.divide(f2);        assertSame(Fraction.ZERO, f);                f1 = new Fraction(2, 7);        f2 = Fraction.ONE;        f = f1.divide(f2);        assertEquals(2, f.getNumerator());        assertEquals(7, f.getDenominator());                f1 = new Fraction(1, Integer.MAX_VALUE);        f = f1.divide(f1);          assertEquals(1, f.getNumerator());        assertEquals(1, f.getDenominator());                f1 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        f2 = new Fraction(1, Integer.MAX_VALUE);        f = f1.divide(f2);        assertEquals(Integer.MIN_VALUE, f.getNumerator());        assertEquals(1, f.getDenominator());        try {            f.divide(null);            fail("IllegalArgumentException");        } catch (IllegalArgumentException ex) {}                try {            f1 = new Fraction(1, Integer.MAX_VALUE);            f = f1.divide(f1.reciprocal());  // should overflow            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}        try {            f1 = new Fraction(1, -Integer.MAX_VALUE);            f = f1.divide(f1.reciprocal());  // should overflow            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}        f1 = new Fraction(6, 35);        f  = f1.divide(15);        assertEquals(2, f.getNumerator());        assertEquals(175, f.getDenominator());    }        public void testMultiply() {        Fraction a = new Fraction(1, 2);        Fraction b = new Fraction(2, 3);                assertFraction(1, 4, a.multiply(a));        assertFraction(1, 3, a.multiply(b));        assertFraction(1, 3, b.multiply(a));        assertFraction(4, 9, b.multiply(b));                Fraction f1 = new Fraction(Integer.MAX_VALUE, 1);        Fraction f2 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        Fraction f = f1.multiply(f2);        assertEquals(Integer.MIN_VALUE, f.getNumerator());        assertEquals(1, f.getDenominator());        try {            f.multiply(null);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {}        f1 = new Fraction(6, 35);        f  = f1.multiply(15);        assertEquals(18, f.getNumerator());        assertEquals(7, f.getDenominator());    }        public void testSubtract() {        Fraction a = new Fraction(1, 2);        Fraction b = new Fraction(2, 3);                assertFraction(0, 1, a.subtract(a));        assertFraction(-1, 6, a.subtract(b));        assertFraction(1, 6, b.subtract(a));        assertFraction(0, 1, b.subtract(b));                Fraction f = new Fraction(1,1);        try {            f.subtract(null);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {}                // if this fraction is subtracted naively, it will overflow.        // check that it doesn't.        Fraction f1 = new Fraction(1,32768*3);        Fraction f2 = new Fraction(1,59049);        f = f1.subtract(f2);        assertEquals(-13085, f.getNumerator());        assertEquals(1934917632, f.getDenominator());        f1 = new Fraction(Integer.MIN_VALUE, 3);        f2 = new Fraction(1,3).negate();        f = f1.subtract(f2);        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());        assertEquals(3, f.getDenominator());                f1 = new Fraction(Integer.MAX_VALUE, 1);        f2 = Fraction.ONE;        f = f1.subtract(f2);        assertEquals(Integer.MAX_VALUE-1, f.getNumerator());        assertEquals(1, f.getDenominator());        f = f1.subtract(1);        assertEquals(Integer.MAX_VALUE-1, f.getNumerator());        assertEquals(1, f.getDenominator());        try {            f1 = new Fraction(1, Integer.MAX_VALUE);            f2 = new Fraction(1, Integer.MAX_VALUE - 1);            f = f1.subtract(f2);            fail("expecting ArithmeticException");  //should overflow        } catch (ArithmeticException ex) {}                // denominator should not be a multiple of 2 or 3 to trigger overflow        f1 = new Fraction(Integer.MIN_VALUE, 5);        f2 = new Fraction(1,5);        try {            f = f1.subtract(f2); // should overflow            fail("expecting ArithmeticException but got: " + f.toString());        } catch (ArithmeticException ex) {}                try {            f= new Fraction(Integer.MIN_VALUE, 1);            f = f.subtract(Fraction.ONE);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}                try {            f= new Fraction(Integer.MAX_VALUE, 1);            f = f.subtract(Fraction.ONE.negate());            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}                f1 = new Fraction(3,327680);        f2 = new Fraction(2,59049);        try {            f = f1.subtract(f2); // should overflow            fail("expecting ArithmeticException but got: " + f.toString());        } catch (ArithmeticException ex) {}    }        public void testEqualsAndHashCode() {        Fraction zero  = new Fraction(0,1);        Fraction nullFraction = null;        assertTrue( zero.equals(zero));        assertFalse(zero.equals(nullFraction));        assertFalse(zero.equals(Double.valueOf(0)));        Fraction zero2 = new Fraction(0,2);        assertTrue(zero.equals(zero2));        assertEquals(zero.hashCode(), zero2.hashCode());        Fraction one = new Fraction(1,1);        assertFalse((one.equals(zero) ||zero.equals(one)));    }        public void testGetReducedFraction() {        Fraction threeFourths = new Fraction(3, 4);        assertTrue(threeFourths.equals(Fraction.getReducedFraction(6, 8)));        assertTrue(Fraction.ZERO.equals(Fraction.getReducedFraction(0, -1)));        try {            Fraction.getReducedFraction(1, 0);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected        }        assertEquals(Fraction.getReducedFraction                (2, Integer.MIN_VALUE).getNumerator(),-1);        assertEquals(Fraction.getReducedFraction                (1, -1).getNumerator(), -1);    }    public void testToString() {        assertEquals("0", new Fraction(0, 3).toString());        assertEquals("3", new Fraction(6, 2).toString());        assertEquals("2 / 3", new Fraction(18, 27).toString());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import java.math.BigDecimal;import java.math.BigInteger;import org.apache.commons.math.ConvergenceException;import junit.framework.TestCase;public class BigFractionTest extends TestCase {    private void assertFraction(int expectedNumerator, int expectedDenominator, BigFraction actual) {        assertEquals(expectedNumerator, actual.getNumeratorAsInt());        assertEquals(expectedDenominator, actual.getDenominatorAsInt());    }    private void assertFraction(long expectedNumerator, long expectedDenominator, BigFraction actual) {        assertEquals(expectedNumerator, actual.getNumeratorAsLong());        assertEquals(expectedDenominator, actual.getDenominatorAsLong());    }    public void testConstructor() {        assertFraction(0, 1, new BigFraction(0, 1));        assertFraction(0, 1, new BigFraction(0l, 2l));        assertFraction(0, 1, new BigFraction(0, -1));        assertFraction(1, 2, new BigFraction(1, 2));        assertFraction(1, 2, new BigFraction(2, 4));        assertFraction(-1, 2, new BigFraction(-1, 2));        assertFraction(-1, 2, new BigFraction(1, -2));        assertFraction(-1, 2, new BigFraction(-2, 4));        assertFraction(-1, 2, new BigFraction(2, -4));        assertFraction(11, 1, new BigFraction(11));        assertFraction(11, 1, new BigFraction(11l));        assertFraction(11, 1, new BigFraction(new BigInteger("11")));        try {            assertFraction(0, 1, new BigFraction(0.00000000000001, 1.0e-5, 100));            assertFraction(2, 5, new BigFraction(0.40000000000001, 1.0e-5, 100));            assertFraction(15, 1, new BigFraction(15.0000000000001, 1.0e-5, 100));        } catch (ConvergenceException ex) {            fail(ex.getMessage());        }        assertEquals(0.00000000000001, new BigFraction(0.00000000000001).doubleValue(), 0.0);        assertEquals(0.40000000000001, new BigFraction(0.40000000000001).doubleValue(), 0.0);        assertEquals(15.0000000000001, new BigFraction(15.0000000000001).doubleValue(), 0.0);        assertFraction(3602879701896487l, 9007199254740992l, new BigFraction(0.40000000000001));        assertFraction(1055531162664967l, 70368744177664l, new BigFraction(15.0000000000001));        try {            new BigFraction(null, BigInteger.ONE);        } catch (NullPointerException npe) {            // expected        }        try {            new BigFraction(BigInteger.ONE, null);        } catch (NullPointerException npe) {            // expected        }        try {            new BigFraction(BigInteger.ONE, BigInteger.ZERO);        } catch (ArithmeticException npe) {            // expected        }        try {            new BigFraction(2.0 * Integer.MAX_VALUE, 1.0e-5, 100000);        } catch (FractionConversionException fce) {            // expected        }    }    public void testGoldenRatio() {        try {            // the golden ratio is notoriously a difficult number for continuous            // fraction            new BigFraction((1 + Math.sqrt(5)) / 2, 1.0e-12, 25);            fail("an exception should have been thrown");        } catch (ConvergenceException ce) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    // MATH-179    public void testDoubleConstructor() throws ConvergenceException {        assertFraction(1, 2, new BigFraction((double) 1 / (double) 2, 1.0e-5, 100));        assertFraction(1, 3, new BigFraction((double) 1 / (double) 3, 1.0e-5, 100));        assertFraction(2, 3, new BigFraction((double) 2 / (double) 3, 1.0e-5, 100));        assertFraction(1, 4, new BigFraction((double) 1 / (double) 4, 1.0e-5, 100));        assertFraction(3, 4, new BigFraction((double) 3 / (double) 4, 1.0e-5, 100));        assertFraction(1, 5, new BigFraction((double) 1 / (double) 5, 1.0e-5, 100));        assertFraction(2, 5, new BigFraction((double) 2 / (double) 5, 1.0e-5, 100));        assertFraction(3, 5, new BigFraction((double) 3 / (double) 5, 1.0e-5, 100));        assertFraction(4, 5, new BigFraction((double) 4 / (double) 5, 1.0e-5, 100));        assertFraction(1, 6, new BigFraction((double) 1 / (double) 6, 1.0e-5, 100));        assertFraction(5, 6, new BigFraction((double) 5 / (double) 6, 1.0e-5, 100));        assertFraction(1, 7, new BigFraction((double) 1 / (double) 7, 1.0e-5, 100));        assertFraction(2, 7, new BigFraction((double) 2 / (double) 7, 1.0e-5, 100));        assertFraction(3, 7, new BigFraction((double) 3 / (double) 7, 1.0e-5, 100));        assertFraction(4, 7, new BigFraction((double) 4 / (double) 7, 1.0e-5, 100));        assertFraction(5, 7, new BigFraction((double) 5 / (double) 7, 1.0e-5, 100));        assertFraction(6, 7, new BigFraction((double) 6 / (double) 7, 1.0e-5, 100));        assertFraction(1, 8, new BigFraction((double) 1 / (double) 8, 1.0e-5, 100));        assertFraction(3, 8, new BigFraction((double) 3 / (double) 8, 1.0e-5, 100));        assertFraction(5, 8, new BigFraction((double) 5 / (double) 8, 1.0e-5, 100));        assertFraction(7, 8, new BigFraction((double) 7 / (double) 8, 1.0e-5, 100));        assertFraction(1, 9, new BigFraction((double) 1 / (double) 9, 1.0e-5, 100));        assertFraction(2, 9, new BigFraction((double) 2 / (double) 9, 1.0e-5, 100));        assertFraction(4, 9, new BigFraction((double) 4 / (double) 9, 1.0e-5, 100));        assertFraction(5, 9, new BigFraction((double) 5 / (double) 9, 1.0e-5, 100));        assertFraction(7, 9, new BigFraction((double) 7 / (double) 9, 1.0e-5, 100));        assertFraction(8, 9, new BigFraction((double) 8 / (double) 9, 1.0e-5, 100));        assertFraction(1, 10, new BigFraction((double) 1 / (double) 10, 1.0e-5, 100));        assertFraction(3, 10, new BigFraction((double) 3 / (double) 10, 1.0e-5, 100));        assertFraction(7, 10, new BigFraction((double) 7 / (double) 10, 1.0e-5, 100));        assertFraction(9, 10, new BigFraction((double) 9 / (double) 10, 1.0e-5, 100));        assertFraction(1, 11, new BigFraction((double) 1 / (double) 11, 1.0e-5, 100));        assertFraction(2, 11, new BigFraction((double) 2 / (double) 11, 1.0e-5, 100));        assertFraction(3, 11, new BigFraction((double) 3 / (double) 11, 1.0e-5, 100));        assertFraction(4, 11, new BigFraction((double) 4 / (double) 11, 1.0e-5, 100));        assertFraction(5, 11, new BigFraction((double) 5 / (double) 11, 1.0e-5, 100));        assertFraction(6, 11, new BigFraction((double) 6 / (double) 11, 1.0e-5, 100));        assertFraction(7, 11, new BigFraction((double) 7 / (double) 11, 1.0e-5, 100));        assertFraction(8, 11, new BigFraction((double) 8 / (double) 11, 1.0e-5, 100));        assertFraction(9, 11, new BigFraction((double) 9 / (double) 11, 1.0e-5, 100));        assertFraction(10, 11, new BigFraction((double) 10 / (double) 11, 1.0e-5, 100));    }    // MATH-181    public void testDigitLimitConstructor() throws ConvergenceException {        assertFraction(2, 5, new BigFraction(0.4, 9));        assertFraction(2, 5, new BigFraction(0.4, 99));        assertFraction(2, 5, new BigFraction(0.4, 999));        assertFraction(3, 5, new BigFraction(0.6152, 9));        assertFraction(8, 13, new BigFraction(0.6152, 99));        assertFraction(510, 829, new BigFraction(0.6152, 999));        assertFraction(769, 1250, new BigFraction(0.6152, 9999));    }    public void testEpsilonLimitConstructor() throws ConvergenceException {        assertFraction(2, 5, new BigFraction(0.4, 1.0e-5, 100));        assertFraction(3, 5, new BigFraction(0.6152, 0.02, 100));        assertFraction(8, 13, new BigFraction(0.6152, 1.0e-3, 100));        assertFraction(251, 408, new BigFraction(0.6152, 1.0e-4, 100));        assertFraction(251, 408, new BigFraction(0.6152, 1.0e-5, 100));        assertFraction(510, 829, new BigFraction(0.6152, 1.0e-6, 100));        assertFraction(769, 1250, new BigFraction(0.6152, 1.0e-7, 100));    }    public void testCompareTo() {        BigFraction first = new BigFraction(1, 2);        BigFraction second = new BigFraction(1, 3);        BigFraction third = new BigFraction(1, 2);        assertEquals(0, first.compareTo(first));        assertEquals(0, first.compareTo(third));        assertEquals(1, first.compareTo(second));        assertEquals(-1, second.compareTo(first));        // these two values are different approximations of PI        // the first  one is approximately PI - 3.07e-18        // the second one is approximately PI + 1.936e-17        BigFraction pi1 = new BigFraction(1068966896, 340262731);        BigFraction pi2 = new BigFraction( 411557987, 131002976);        assertEquals(-1, pi1.compareTo(pi2));        assertEquals( 1, pi2.compareTo(pi1));        assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);    }    public void testDoubleValue() {        BigFraction first = new BigFraction(1, 2);        BigFraction second = new BigFraction(1, 3);        assertEquals(0.5, first.doubleValue(), 0.0);        assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);    }    public void testFloatValue() {        BigFraction first = new BigFraction(1, 2);        BigFraction second = new BigFraction(1, 3);        assertEquals(0.5f, first.floatValue(), 0.0f);        assertEquals((float) (1.0 / 3.0), second.floatValue(), 0.0f);    }    public void testIntValue() {        BigFraction first = new BigFraction(1, 2);        BigFraction second = new BigFraction(3, 2);        assertEquals(0, first.intValue());        assertEquals(1, second.intValue());    }    public void testLongValue() {        BigFraction first = new BigFraction(1, 2);        BigFraction second = new BigFraction(3, 2);        assertEquals(0L, first.longValue());        assertEquals(1L, second.longValue());    }    public void testConstructorDouble() {        assertFraction(1, 2, new BigFraction(0.5));        assertFraction(6004799503160661l, 18014398509481984l, new BigFraction(1.0 / 3.0));        assertFraction(6124895493223875l, 36028797018963968l, new BigFraction(17.0 / 100.0));        assertFraction(1784551352345559l, 562949953421312l, new BigFraction(317.0 / 100.0));        assertFraction(-1, 2, new BigFraction(-0.5));        assertFraction(-6004799503160661l, 18014398509481984l, new BigFraction(-1.0 / 3.0));        assertFraction(-6124895493223875l, 36028797018963968l, new BigFraction(17.0 / -100.0));        assertFraction(-1784551352345559l, 562949953421312l, new BigFraction(-317.0 / 100.0));        for (double v : new double[] { Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY}) {            try {                new BigFraction(v);                fail("expected exception");            } catch (IllegalArgumentException iae) {                // expected            }        }        assertEquals(1l, new BigFraction(Double.MAX_VALUE).getDenominatorAsLong());        assertEquals(1l, new BigFraction(Double.longBitsToDouble(0x0010000000000000L)).getNumeratorAsLong());        assertEquals(1l, new BigFraction(Double.MIN_VALUE).getNumeratorAsLong());    }    public void testAbs() {        BigFraction a = new BigFraction(10, 21);        BigFraction b = new BigFraction(-10, 21);        BigFraction c = new BigFraction(10, -21);        assertFraction(10, 21, a.abs());        assertFraction(10, 21, b.abs());        assertFraction(10, 21, c.abs());    }    public void testReciprocal() {        BigFraction f = null;        f = new BigFraction(50, 75);        f = f.reciprocal();        assertEquals(3, f.getNumeratorAsInt());        assertEquals(2, f.getDenominatorAsInt());        f = new BigFraction(4, 3);        f = f.reciprocal();        assertEquals(3, f.getNumeratorAsInt());        assertEquals(4, f.getDenominatorAsInt());        f = new BigFraction(-15, 47);        f = f.reciprocal();        assertEquals(-47, f.getNumeratorAsInt());        assertEquals(15, f.getDenominatorAsInt());        f = new BigFraction(0, 3);        try {            f = f.reciprocal();            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {        }        // large values        f = new BigFraction(Integer.MAX_VALUE, 1);        f = f.reciprocal();        assertEquals(1, f.getNumeratorAsInt());        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());    }    public void testNegate() {        BigFraction f = null;        f = new BigFraction(50, 75);        f = f.negate();        assertEquals(-2, f.getNumeratorAsInt());        assertEquals(3, f.getDenominatorAsInt());        f = new BigFraction(-50, 75);        f = f.negate();        assertEquals(2, f.getNumeratorAsInt());        assertEquals(3, f.getDenominatorAsInt());        // large values        f = new BigFraction(Integer.MAX_VALUE - 1, Integer.MAX_VALUE);        f = f.negate();        assertEquals(Integer.MIN_VALUE + 2, f.getNumeratorAsInt());        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());    }    public void testAdd() {        BigFraction a = new BigFraction(1, 2);        BigFraction b = new BigFraction(2, 3);        assertFraction(1, 1, a.add(a));        assertFraction(7, 6, a.add(b));        assertFraction(7, 6, b.add(a));        assertFraction(4, 3, b.add(b));        BigFraction f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);        BigFraction f2 = BigFraction.ONE;        BigFraction f = f1.add(f2);        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f1 = new BigFraction(-1, 13 * 13 * 2 * 2);        f2 = new BigFraction(-2, 13 * 17 * 2);        f = f1.add(f2);        assertEquals(13 * 13 * 17 * 2 * 2, f.getDenominatorAsInt());        assertEquals(-17 - 2 * 13 * 2, f.getNumeratorAsInt());        try {            f.add((BigFraction) null);            fail("expecting NullPointerException");        } catch (NullPointerException ex) {        }        // if this fraction is added naively, it will overflow.        // check that it doesn't.        f1 = new BigFraction(1, 32768 * 3);        f2 = new BigFraction(1, 59049);        f = f1.add(f2);        assertEquals(52451, f.getNumeratorAsInt());        assertEquals(1934917632, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MIN_VALUE, 3);        f2 = new BigFraction(1, 3);        f = f1.add(f2);        assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt());        assertEquals(3, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);        f = f1.add(BigInteger.ONE);        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f = f.add(BigInteger.ZERO);        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);        f = f1.add(1);        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f = f.add(0);        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);        f = f1.add(1l);        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f = f.add(0l);        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());    }    public void testDivide() {        BigFraction a = new BigFraction(1, 2);        BigFraction b = new BigFraction(2, 3);        assertFraction(1, 1, a.divide(a));        assertFraction(3, 4, a.divide(b));        assertFraction(4, 3, b.divide(a));        assertFraction(1, 1, b.divide(b));        BigFraction f1 = new BigFraction(3, 5);        BigFraction f2 = BigFraction.ZERO;        try {            f1.divide(f2);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {        }        f1 = new BigFraction(0, 5);        f2 = new BigFraction(2, 7);        BigFraction f = f1.divide(f2);        assertSame(BigFraction.ZERO, f);        f1 = new BigFraction(2, 7);        f2 = BigFraction.ONE;        f = f1.divide(f2);        assertEquals(2, f.getNumeratorAsInt());        assertEquals(7, f.getDenominatorAsInt());        f1 = new BigFraction(1, Integer.MAX_VALUE);        f = f1.divide(f1);        assertEquals(1, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        f2 = new BigFraction(1, Integer.MAX_VALUE);        f = f1.divide(f2);        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        try {            f.divide((BigFraction) null);            fail("expecting NullPointerException");        } catch (NullPointerException ex) {        }        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        f = f1.divide(BigInteger.valueOf(Integer.MIN_VALUE));        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());        assertEquals(1, f.getNumeratorAsInt());        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        f = f1.divide(Integer.MIN_VALUE);        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());        assertEquals(1, f.getNumeratorAsInt());        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        f = f1.divide((long) Integer.MIN_VALUE);        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());        assertEquals(1, f.getNumeratorAsInt());    }    public void testMultiply() {        BigFraction a = new BigFraction(1, 2);        BigFraction b = new BigFraction(2, 3);        assertFraction(1, 4, a.multiply(a));        assertFraction(1, 3, a.multiply(b));        assertFraction(1, 3, b.multiply(a));        assertFraction(4, 9, b.multiply(b));        BigFraction f1 = new BigFraction(Integer.MAX_VALUE, 1);        BigFraction f2 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        BigFraction f = f1.multiply(f2);        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f = f2.multiply(Integer.MAX_VALUE);        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f = f2.multiply((long) Integer.MAX_VALUE);        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        try {            f.multiply((BigFraction) null);            fail("expecting NullPointerException");        } catch (NullPointerException ex) {        }    }    public void testSubtract() {        BigFraction a = new BigFraction(1, 2);        BigFraction b = new BigFraction(2, 3);        assertFraction(0, 1, a.subtract(a));        assertFraction(-1, 6, a.subtract(b));        assertFraction(1, 6, b.subtract(a));        assertFraction(0, 1, b.subtract(b));        BigFraction f = new BigFraction(1, 1);        try {            f.subtract((BigFraction) null);            fail("expecting NullPointerException");        } catch (NullPointerException ex) {        }        // if this fraction is subtracted naively, it will overflow.        // check that it doesn't.        BigFraction f1 = new BigFraction(1, 32768 * 3);        BigFraction f2 = new BigFraction(1, 59049);        f = f1.subtract(f2);        assertEquals(-13085, f.getNumeratorAsInt());        assertEquals(1934917632, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MIN_VALUE, 3);        f2 = new BigFraction(1, 3).negate();        f = f1.subtract(f2);        assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt());        assertEquals(3, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MAX_VALUE, 1);        f2 = BigFraction.ONE;        f = f1.subtract(f2);        assertEquals(Integer.MAX_VALUE - 1, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());    }    public void testBigDecimalValue() {        assertEquals(new BigDecimal(0.5), new BigFraction(1, 2).bigDecimalValue());        assertEquals(new BigDecimal("0.0003"), new BigFraction(3, 10000).bigDecimalValue());        assertEquals(new BigDecimal("0"), new BigFraction(1, 3).bigDecimalValue(BigDecimal.ROUND_DOWN));        assertEquals(new BigDecimal("0.333"), new BigFraction(1, 3).bigDecimalValue(3, BigDecimal.ROUND_DOWN));    }    public void testEqualsAndHashCode() {        BigFraction zero = new BigFraction(0, 1);        BigFraction nullFraction = null;        assertTrue(zero.equals(zero));        assertFalse(zero.equals(nullFraction));        assertFalse(zero.equals(Double.valueOf(0)));        BigFraction zero2 = new BigFraction(0, 2);        assertTrue(zero.equals(zero2));        assertEquals(zero.hashCode(), zero2.hashCode());        BigFraction one = new BigFraction(1, 1);        assertFalse((one.equals(zero) || zero.equals(one)));        assertTrue(one.equals(BigFraction.ONE));    }    public void testGetReducedFraction() {        BigFraction threeFourths = new BigFraction(3, 4);        assertTrue(threeFourths.equals(BigFraction.getReducedFraction(6, 8)));        assertTrue(BigFraction.ZERO.equals(BigFraction.getReducedFraction(0, -1)));        try {            BigFraction.getReducedFraction(1, 0);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected        }        assertEquals(BigFraction.getReducedFraction(2, Integer.MIN_VALUE).getNumeratorAsInt(), -1);        assertEquals(BigFraction.getReducedFraction(1, -1).getNumeratorAsInt(), -1);    }    public void testPow() {        assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(13));        assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(13l));        assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(BigInteger.valueOf(13l)));        assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(0));        assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(0l));        assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(BigInteger.valueOf(0l)));        assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(-13));        assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(-13l));        assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(BigInteger.valueOf(-13l)));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import java.text.NumberFormat;import java.text.ParseException;import java.util.Locale;import junit.framework.TestCase;public class FractionFormatTest extends TestCase {     FractionFormat properFormat = null;    FractionFormat improperFormat = null;    protected Locale getLocale() {        return Locale.getDefault();    }    @Override    protected void setUp() throws Exception {        properFormat = FractionFormat.getProperInstance(getLocale());        improperFormat = FractionFormat.getImproperInstance(getLocale());    }       public void testFormat() {        Fraction c = new Fraction(1, 2);        String expected = "1 / 2";                String actual = properFormat.format(c);         assertEquals(expected, actual);        actual = improperFormat.format(c);        assertEquals(expected, actual);    }    public void testFormatNegative() {        Fraction c = new Fraction(-1, 2);        String expected = "-1 / 2";        String actual = properFormat.format(c);         assertEquals(expected, actual);        actual = improperFormat.format(c);         assertEquals(expected, actual);    }    public void testFormatZero() {        Fraction c = new Fraction(0, 1);        String expected = "0 / 1";        String actual = properFormat.format(c);         assertEquals(expected, actual);        actual = improperFormat.format(c);         assertEquals(expected, actual);    }        public void testFormatImproper() {        Fraction c = new Fraction(5, 3);        String actual = properFormat.format(c);         assertEquals("1 2 / 3", actual);        actual = improperFormat.format(c);         assertEquals("5 / 3", actual);    }        public void testFormatImproperNegative() {        Fraction c = new Fraction(-5, 3);        String actual = properFormat.format(c);         assertEquals("-1 2 / 3", actual);        actual = improperFormat.format(c);         assertEquals("-5 / 3", actual);    }        public void testParse() {        String source = "1 / 2";        try {            Fraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(1, c.getNumerator());            assertEquals(2, c.getDenominator());                        c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(1, c.getNumerator());            assertEquals(2, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }    }        public void testParseInteger() {        String source = "10";        try {            Fraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(10, c.getNumerator());            assertEquals(1, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }        try {            Fraction c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(10, c.getNumerator());            assertEquals(1, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }    }        public void testParseInvalid() {        String source = "a";        String msg = "should not be able to parse '10 / a'.";        try {            properFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }        try {            improperFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }    }        public void testParseInvalidDenominator() {        String source = "10 / a";        String msg = "should not be able to parse '10 / a'.";        try {            properFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }        try {            improperFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }    }        public void testParseNegative() {        try {            String source = "-1 / 2";            Fraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumerator());            assertEquals(2, c.getDenominator());                        c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumerator());            assertEquals(2, c.getDenominator());            source = "1 / -2";            c = properFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumerator());            assertEquals(2, c.getDenominator());                        c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumerator());            assertEquals(2, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }    }        public void testParseProper() {        String source = "1 2 / 3";        try {            Fraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(5, c.getNumerator());            assertEquals(3, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }                try {            improperFormat.parse(source);            fail("invalid improper fraction.");        } catch (ParseException ex) {            // success        }    }        public void testParseProperNegative() {        String source = "-1 2 / 3";        try {            Fraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(-5, c.getNumerator());            assertEquals(3, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }                try {            improperFormat.parse(source);            fail("invalid improper fraction.");        } catch (ParseException ex) {            // success        }    }        public void testParseProperInvalidMinus() {        String source = "2 -2 / 3";        try {            properFormat.parse(source);            fail("invalid minus in improper fraction.");        } catch (ParseException ex) {            // expected        }        source = "2 2 / -3";        try {            properFormat.parse(source);            fail("invalid minus in improper fraction.");        } catch (ParseException ex) {            // expected        }    }        public void testNumeratorFormat() {        NumberFormat old = properFormat.getNumeratorFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        properFormat.setNumeratorFormat(nf);        assertEquals(nf, properFormat.getNumeratorFormat());        properFormat.setNumeratorFormat(old);        old = improperFormat.getNumeratorFormat();        nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        improperFormat.setNumeratorFormat(nf);        assertEquals(nf, improperFormat.getNumeratorFormat());        improperFormat.setNumeratorFormat(old);    }        public void testDenominatorFormat() {        NumberFormat old = properFormat.getDenominatorFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        properFormat.setDenominatorFormat(nf);        assertEquals(nf, properFormat.getDenominatorFormat());        properFormat.setDenominatorFormat(old);        old = improperFormat.getDenominatorFormat();        nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        improperFormat.setDenominatorFormat(nf);        assertEquals(nf, improperFormat.getDenominatorFormat());        improperFormat.setDenominatorFormat(old);    }        public void testWholeFormat() {        ProperFractionFormat format = (ProperFractionFormat)properFormat;                NumberFormat old = format.getWholeFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        format.setWholeFormat(nf);        assertEquals(nf, format.getWholeFormat());        format.setWholeFormat(old);    }        public void testLongFormat() {        assertEquals("10 / 1", improperFormat.format(10l));    }        public void testDoubleFormat() {        assertEquals("355 / 113", improperFormat.format(Math.PI));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for WeibullDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class WeibullDistributionTest extends ContinuousDistributionAbstractTest  {        /**     * Constructor for CauchyDistributionTest.     * @param arg0     */    public WeibullDistributionTest(String arg0) {        super(arg0);    }        //-------------- Implementations for abstract methods -----------------------        /** Creates the default continuous distribution instance to use in tests. */    @Override    public ContinuousDistribution makeDistribution() {        return new WeibullDistributionImpl(1.2, 2.1);    }           /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using Mathematica         return new double[] {0.00664355181d, 0.04543282833d, 0.09811627374d,                0.1767135246d, 0.3219468654d, 4.207902826d, 5.23968437d,                6.232056007d, 7.497630467d, 10.51154969d};    }        /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,                0.975d, 0.990d, 0.999d};    }        //---------------------------- Additional test cases -------------------------        public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0.0, 1.0});        setInverseCumulativeTestValues(                new double[] {0.0, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }        public void testAlpha() {        WeibullDistribution distribution = (WeibullDistribution) getDistribution();        double expected = Math.random();        distribution.setShape(expected);        assertEquals(expected, distribution.getShape(), 0.0);    }        public void testBeta() {        WeibullDistribution distribution = (WeibullDistribution) getDistribution();        double expected = Math.random();        distribution.setScale(expected);        assertEquals(expected, distribution.getScale(), 0.0);    }        public void testSetAlpha() {        WeibullDistribution distribution = (WeibullDistribution) getDistribution();        try {            distribution.setShape(0.0);            fail("Can not have 0.0 alpha.");        } catch (IllegalArgumentException ex) {            // success        }                try {            distribution.setShape(-1.0);            fail("Can not have negative alpha.");        } catch (IllegalArgumentException ex) {            // success        }    }        public void testSetBeta() {        WeibullDistribution distribution = (WeibullDistribution) getDistribution();        try {            distribution.setScale(0.0);            fail("Can not have 0.0 beta.");        } catch (IllegalArgumentException ex) {            // success        }                try {            distribution.setScale(-1.0);            fail("Can not have negative beta.");        } catch (IllegalArgumentException ex) {            // success        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for PascalDistribution. * Extends IntegerDistributionAbstractTest.  See class javadoc for * IntegerDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class PascalDistributionTest extends IntegerDistributionAbstractTest {        /**     * Constructor for PascalDistributionTest.     * @param name     */    public PascalDistributionTest(String name) {        super(name);    }        //-------------- Implementations for abstract methods -----------------------        /** Creates the default discrete distribution instance to use in tests. */    @Override    public IntegerDistribution makeDistribution() {        return new PascalDistributionImpl(10,0.70);    }        /** Creates the default probability density test input values */    @Override    public int[] makeDensityTestPoints() {      return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};    }        /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {      return new double[] {0d, 0.02824d, 0.08474d, 0.13982d,           0.16779d, 0.16359d, 0.1374d, 0.10306d, 0.070673d, 0.04505d, 0.02703d, 0.01540d, 0.0084};    }        /** Creates the default cumulative probability density test input values */    @Override    public int[] makeCumulativeTestPoints() {      return makeDensityTestPoints();    }        /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {      return new double[] {0d, 0.02824d, 0.11299d, 0.25281d, 0.42060d, 0.58420d,          0.72162d, 0.82468d, 0.89535d, 0.94041d, 0.967446d, 0.98285, 0.99125d};        }        /** Creates the default inverse cumulative probability test input values */    @Override    public double[] makeInverseCumulativeTestPoints() {      return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,          0.990d, 0.975d, 0.950d, 0.900d, 1};         }        /** Creates the default inverse cumulative probability density test expected values */    @Override    public int[] makeInverseCumulativeTestValues() {      return new int[] {-1, -1, -1, -1, 0, 0, 13, 10, 9, 8, 7, Integer.MAX_VALUE};    }    //----------------- Additional test cases ---------------------------------       /** Test degenerate case p = 0   */    public void testDegenerate0() throws Exception {        setDistribution(new PascalDistributionImpl(5,0.0d));        setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });        setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 0d});        setDensityTestPoints(new int[] {-1, 0, 1, 10, 11});        setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 1});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();         }        /** Test degenerate case p = 1   */    public void testDegenerate1() throws Exception {        setDistribution(new PascalDistributionImpl(5,1.0d));        setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });        setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10});        setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {-1, -1});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();         }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.TestUtils;/** * Test cases for HyperGeometriclDistribution. * Extends IntegerDistributionAbstractTest.  See class javadoc for * IntegerDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class HypergeometricDistributionTest extends IntegerDistributionAbstractTest {    /**     * Constructor for ChiSquareDistributionTest.     * @param name     */    public HypergeometricDistributionTest(String name) {        super(name);    }//-------------- Implementations for abstract methods -----------------------        /** Creates the default discrete distribution instance to use in tests. */    @Override    public IntegerDistribution makeDistribution() {        return new HypergeometricDistributionImpl(10,5, 5);    }        /** Creates the default probability density test input values */    @Override    public int[] makeDensityTestPoints() {        return new int[] {-1, 0, 1, 2, 3, 4, 5, 10};    }        /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0d, 0.003968d, 0.099206d, 0.396825d, 0.396825d,                 0.099206d, 0.003968d, 0d};    }        /** Creates the default cumulative probability density test input values */    @Override    public int[] makeCumulativeTestPoints() {        return makeDensityTestPoints();    }        /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0d, .003968d, .103175d, .50000d, .896825d, .996032d,                1.00000d, 1d};    }        /** Creates the default inverse cumulative probability test input values */    @Override    public double[] makeInverseCumulativeTestPoints() {        return new double[] {0d, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d, 1d};     }        /** Creates the default inverse cumulative probability density test expected values */    @Override    public int[] makeInverseCumulativeTestValues() {        return new int[] {-1, -1, 0, 0, 0, 0, 4, 3, 3, 3, 3, 5};    }        //-------------------- Additional test cases ------------------------------        /** Verify that if there are no failures, mass is concentrated on sampleSize */    public void testDegenerateNoFailures() throws Exception {        setDistribution(new HypergeometricDistributionImpl(5,5,3));        setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });        setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});        setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {2, 2});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();         }        /** Verify that if there are no successes, mass is concentrated on 0 */    public void testDegenerateNoSuccesses() throws Exception {        setDistribution(new HypergeometricDistributionImpl(5,0,3));        setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });        setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});        setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {-1, -1});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();         }        /** Verify that if sampleSize = populationSize, mass is concentrated on numberOfSuccesses */    public void testDegenerateFullSample() throws Exception {        setDistribution(new HypergeometricDistributionImpl(5,3,5));        setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });        setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});        setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {2, 2});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();         }    public void testPopulationSize() {        HypergeometricDistribution dist = new HypergeometricDistributionImpl(5,3,5);        try {            dist.setPopulationSize(-1);            fail("negative population size.  IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }                dist.setPopulationSize(10);        assertEquals(10, dist.getPopulationSize());    }        public void testLargeValues() {        int populationSize = 3456;        int sampleSize = 789;        int numberOfSucceses = 101;        double[][] data = {            {0.0, 2.75646034603961e-12, 2.75646034603961e-12, 1.0},            {1.0, 8.55705370142386e-11, 8.83269973602783e-11, 0.999999999997244},            {2.0, 1.31288129219665e-9, 1.40120828955693e-9, 0.999999999911673},            {3.0, 1.32724172984193e-8, 1.46736255879763e-8, 0.999999998598792},            {4.0, 9.94501711734089e-8, 1.14123796761385e-7, 0.999999985326375},            {5.0, 5.89080768883643e-7, 7.03204565645028e-7, 0.999999885876203},            {20.0, 0.0760051397707708, 0.27349758476299, 0.802507555007781},             {21.0, 0.087144222047629, 0.360641806810619, 0.72650241523701},             {22.0, 0.0940378846881819, 0.454679691498801, 0.639358193189381},             {23.0, 0.0956897500614809, 0.550369441560282, 0.545320308501199},             {24.0, 0.0919766921922999, 0.642346133752582, 0.449630558439718},             {25.0, 0.083641637261095, 0.725987771013677, 0.357653866247418},             {96.0, 5.93849188852098e-57, 1.0, 6.01900244560712e-57},            {97.0, 7.96593036832547e-59, 1.0, 8.05105570861321e-59},             {98.0, 8.44582921934367e-61, 1.0, 8.5125340287733e-61},            {99.0, 6.63604297068222e-63, 1.0, 6.670480942963e-63},             {100.0, 3.43501099007557e-65, 1.0, 3.4437972280786e-65},            {101.0, 8.78623800302957e-68, 1.0, 8.78623800302957e-68},        };                testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);    }    private void testHypergeometricDistributionProbabilities(int populationSize, int sampleSize, int numberOfSucceses, double[][] data) {        HypergeometricDistributionImpl dist = new HypergeometricDistributionImpl(populationSize, numberOfSucceses, sampleSize);        for (int i = 0; i < data.length; ++i) {            int x = (int)data[i][0];            double pdf = data[i][1];            double actualPdf = dist.probability(x);            TestUtils.assertRelativelyEquals(pdf, actualPdf, 1.0e-9);            double cdf = data[i][2];            double actualCdf = dist.cumulativeProbability(x);            TestUtils.assertRelativelyEquals(cdf, actualCdf, 1.0e-9);            double cdf1 = data[i][3];            double actualCdf1 = dist.upperCumulativeProbability(x);            TestUtils.assertRelativelyEquals(cdf1, actualCdf1, 1.0e-9);        }    }        public void testMoreLargeValues() {        int populationSize = 26896;        int sampleSize = 895;        int numberOfSucceses = 55;        double[][] data = {            {0.0, 0.155168304750504, 0.155168304750504, 1.0},             {1.0, 0.29437545000746, 0.449543754757964, 0.844831695249496},             {2.0, 0.273841321577003, 0.723385076334967, 0.550456245242036},             {3.0, 0.166488572570786, 0.889873648905753, 0.276614923665033},             {4.0, 0.0743969744713231, 0.964270623377076, 0.110126351094247},             {5.0, 0.0260542785784855, 0.990324901955562, 0.0357293766229237},             {20.0, 3.57101101678792e-16, 1.0, 3.78252101622096e-16},             {21.0, 2.00551638598312e-17, 1.0, 2.11509999433041e-17},             {22.0, 1.04317070180562e-18, 1.0, 1.09583608347287e-18},             {23.0, 5.03153504903308e-20, 1.0, 5.266538166725e-20},             {24.0, 2.2525984149695e-21, 1.0, 2.35003117691919e-21},             {25.0, 9.3677424515947e-23, 1.0, 9.74327619496943e-23},             {50.0, 9.83633962945521e-69, 1.0, 9.8677629437617e-69},             {51.0, 3.13448949497553e-71, 1.0, 3.14233143064882e-71},             {52.0, 7.82755221928122e-74, 1.0, 7.84193567329055e-74},             {53.0, 1.43662126065532e-76, 1.0, 1.43834540093295e-76},             {54.0, 1.72312692517348e-79, 1.0, 1.7241402776278e-79},             {55.0, 1.01335245432581e-82, 1.0, 1.01335245432581e-82},                };        testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import junit.framework.TestCase;/** * Abstract base class for {@link IntegerDistribution} tests. * <p> * To create a concrete test class for an integer distribution implementation, *  implement makeDistribution() to return a distribution instance to use in  *  tests and each of the test data generation methods below.  In each case, the *  test points and test values arrays returned represent parallel arrays of  *  inputs and expected values for the distribution returned by makeDistribution(). *  <p> *  makeDensityTestPoints() -- arguments used to test probability density calculation *  makeDensityTestValues() -- expected probability densities *  makeCumulativeTestPoints() -- arguments used to test cumulative probabilities *  makeCumulativeTestValues() -- expected cumulative probabilites *  makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf evaluation *  makeInverseCumulativeTestValues() -- expected inverse cdf values * <p> *  To implement additional test cases with different distribution instances and test data, *  use the setXxx methods for the instance data in test cases and call the verifyXxx methods *  to verify results.  *  * @version $Revision$ $Date$ */public abstract class IntegerDistributionAbstractTest extends TestCase {    //-------------------- Private test instance data -------------------------    /** Discrete distribution instance used to perform tests */    private IntegerDistribution distribution;        /** Tolerance used in comparing expected and returned values */    private double tolerance = 1E-4;        /** Arguments used to test probability density calculations */    private int[] densityTestPoints;        /** Values used to test probability density calculations */    private double[] densityTestValues;        /** Arguments used to test cumulative probability density calculations */    private int[] cumulativeTestPoints;        /** Values used to test cumulative probability density calculations */    private double[] cumulativeTestValues;        /** Arguments used to test inverse cumulative probability density calculations */    private double[] inverseCumulativeTestPoints;        /** Values used to test inverse cumulative probability density calculations */    private int[] inverseCumulativeTestValues;        //-------------------------------------------------------------------------        /**     * Constructor for IntegerDistributionAbstractTest.     * @param name     */    public IntegerDistributionAbstractTest(String name) {        super(name);    }        //-------------------- Abstract methods -----------------------------------        /** Creates the default discrete distribution instance to use in tests. */    public abstract IntegerDistribution makeDistribution();        /** Creates the default probability density test input values */    public abstract int[] makeDensityTestPoints();        /** Creates the default probability density test expected values */    public abstract double[] makeDensityTestValues();        /** Creates the default cumulative probability density test input values */    public abstract int[] makeCumulativeTestPoints();        /** Creates the default cumulative probability density test expected values */    public abstract double[] makeCumulativeTestValues();        /** Creates the default inverse cumulative probability test input values */    public abstract double[] makeInverseCumulativeTestPoints();        /** Creates the default inverse cumulative probability density test expected values */    public abstract int[] makeInverseCumulativeTestValues();        //-------------------- Setup / tear down ----------------------------------         /**     * Setup sets all test instance data to default values      */    @Override    protected void setUp() throws Exception {        super.setUp();        distribution = makeDistribution();        densityTestPoints = makeDensityTestPoints();        densityTestValues = makeDensityTestValues();        cumulativeTestPoints = makeCumulativeTestPoints();        cumulativeTestValues = makeCumulativeTestValues();        inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();        inverseCumulativeTestValues = makeInverseCumulativeTestValues();       }        /**     * Cleans up test instance data     */    @Override    protected void tearDown() throws Exception {              super.tearDown();        distribution = null;        densityTestPoints = null;        densityTestValues = null;        cumulativeTestPoints = null;        cumulativeTestValues = null;        inverseCumulativeTestPoints = null;        inverseCumulativeTestValues = null;       }        //-------------------- Verification methods -------------------------------        /**     * Verifies that probability density calculations match expected values     * using current test instance data     */    protected void verifyDensities() throws Exception {        for (int i = 0; i < densityTestPoints.length; i++) {            assertEquals("Incorrect density value returned for " + densityTestPoints[i],                    densityTestValues[i],                     distribution.probability(densityTestPoints[i]), tolerance);        }         }        /**     * Verifies that cumulative probability density calculations match expected values     * using current test instance data     */       protected void verifyCumulativeProbabilities() throws Exception {        for (int i = 0; i < cumulativeTestPoints.length; i++) {            assertEquals("Incorrect cumulative probability value returned for " + cumulativeTestPoints[i],                    cumulativeTestValues[i],                     distribution.cumulativeProbability(cumulativeTestPoints[i]), tolerance);        }               }            /**     * Verifies that inverse cumulative probability density calculations match expected values     * using current test instance data     */    protected void verifyInverseCumulativeProbabilities() throws Exception {        for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {            assertEquals("Incorrect inverse cumulative probability value returned for "                     + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i],                     distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]));        }               }        //------------------------ Default test cases -----------------------------    /**     * Verifies that probability density calculations match expected values     * using default test instance data     */    public void testDensities() throws Exception {        verifyDensities();         }        /**     * Verifies that cumulative probability density calculations match expected values     * using default test instance data     */    public void testCumulativeProbabilities() throws Exception {        verifyCumulativeProbabilities();          }        /**     * Verifies that floating point arguments are correctly handled by     * cumulativeProbablility(-,-)     * JIRA: MATH-184     */    public void testFloatingPointArguments() throws Exception {        for (int i = 0; i < cumulativeTestPoints.length; i++) {            double arg = cumulativeTestPoints[i];            assertEquals(                    "Incorrect cumulative probability value returned for " +                    cumulativeTestPoints[i],                    cumulativeTestValues[i],                     distribution.cumulativeProbability(arg), tolerance);            if (i < cumulativeTestPoints.length - 1) {                double arg2 = cumulativeTestPoints[i + 1];                assertEquals("Inconsistent probability for discrete range " +                        "[ " + arg + "," + arg2 + " ]",                   distribution.cumulativeProbability(                           cumulativeTestPoints[i],                           cumulativeTestPoints[i + 1]),                   distribution.cumulativeProbability(arg, arg2), tolerance);                arg = arg - Math.random();                arg2 = arg2 + Math.random();                assertEquals("Inconsistent probability for discrete range " +                        "[ " + arg + "," + arg2 + " ]",                   distribution.cumulativeProbability(                           cumulativeTestPoints[i],                           cumulativeTestPoints[i + 1]),                   distribution.cumulativeProbability(arg, arg2), tolerance);            }        }         int one = 1;        int ten = 10;        int two = 2;        double oned = one;        double twod = two;        double tend = ten;        assertEquals(distribution.cumulativeProbability(one, two),                 distribution.cumulativeProbability(oned, twod), tolerance);        assertEquals(distribution.cumulativeProbability(one, two),                 distribution.cumulativeProbability(oned - tolerance,                        twod + 0.9), tolerance);        assertEquals(distribution.cumulativeProbability(two, ten),                 distribution.cumulativeProbability(twod, tend), tolerance);        assertEquals(distribution.cumulativeProbability(two, ten),                 distribution.cumulativeProbability(twod - tolerance,                        tend + 0.9), tolerance);    }        /**     * Verifies that inverse cumulative probability density calculations match expected values     * using default test instance data     */    public void testInverseCumulativeProbabilities() throws Exception {        verifyInverseCumulativeProbabilities();           }        /**     * Verifies that illegal arguments are correctly handled     */    public void testIllegalArguments() throws Exception {        try {            distribution.cumulativeProbability(1, 0);            fail("Expecting IllegalArgumentException for bad cumulativeProbability interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            distribution.inverseCumulativeProbability(-1);            fail("Expecting IllegalArgumentException for p = -1");        } catch (IllegalArgumentException ex) {            // expected        }        try {            distribution.inverseCumulativeProbability(2);            fail("Expecting IllegalArgumentException for p = 2");        } catch (IllegalArgumentException ex) {            // expected        }           }        //------------------ Getters / Setters for test instance data -----------    /**     * @return Returns the cumulativeTestPoints.     */    protected int[] getCumulativeTestPoints() {        return cumulativeTestPoints;    }    /**     * @param cumulativeTestPoints The cumulativeTestPoints to set.     */    protected void setCumulativeTestPoints(int[] cumulativeTestPoints) {        this.cumulativeTestPoints = cumulativeTestPoints;    }    /**     * @return Returns the cumulativeTestValues.     */    protected double[] getCumulativeTestValues() {        return cumulativeTestValues;    }    /**     * @param cumulativeTestValues The cumulativeTestValues to set.     */    protected void setCumulativeTestValues(double[] cumulativeTestValues) {        this.cumulativeTestValues = cumulativeTestValues;    }    /**     * @return Returns the densityTestPoints.     */    protected int[] getDensityTestPoints() {        return densityTestPoints;    }    /**     * @param densityTestPoints The densityTestPoints to set.     */    protected void setDensityTestPoints(int[] densityTestPoints) {        this.densityTestPoints = densityTestPoints;    }    /**     * @return Returns the densityTestValues.     */    protected double[] getDensityTestValues() {        return densityTestValues;    }    /**     * @param densityTestValues The densityTestValues to set.     */    protected void setDensityTestValues(double[] densityTestValues) {        this.densityTestValues = densityTestValues;    }    /**     * @return Returns the distribution.     */    protected IntegerDistribution getDistribution() {        return distribution;    }    /**     * @param distribution The distribution to set.     */    protected void setDistribution(IntegerDistribution distribution) {        this.distribution = distribution;    }    /**     * @return Returns the inverseCumulativeTestPoints.     */    protected double[] getInverseCumulativeTestPoints() {        return inverseCumulativeTestPoints;    }    /**     * @param inverseCumulativeTestPoints The inverseCumulativeTestPoints to set.     */    protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) {        this.inverseCumulativeTestPoints = inverseCumulativeTestPoints;    }    /**     * @return Returns the inverseCumulativeTestValues.     */    protected int[] getInverseCumulativeTestValues() {        return inverseCumulativeTestValues;    }    /**     * @param inverseCumulativeTestValues The inverseCumulativeTestValues to set.     */    protected void setInverseCumulativeTestValues(int[] inverseCumulativeTestValues) {        this.inverseCumulativeTestValues = inverseCumulativeTestValues;    }    /**     * @return Returns the tolerance.     */    protected double getTolerance() {        return tolerance;    }    /**     * @param tolerance The tolerance to set.     */    protected void setTolerance(double tolerance) {        this.tolerance = tolerance;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for TDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */public class TDistributionTest extends ContinuousDistributionAbstractTest {    /**     * Constructor for TDistributionTest.     * @param name     */    public TDistributionTest(String name) {        super(name);    }//-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public ContinuousDistribution makeDistribution() {        return new TDistributionImpl(5.0);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 1.8.1 (linux version)        return new double[] {-5.89343,-3.36493, -2.570582, -2.015048,            -1.475884, 0.0, 5.89343, 3.36493, 2.570582,            2.015048, 1.475884};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.5d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d};    }    // --------------------- Override tolerance  --------------    @Override    protected void setUp() throws Exception {        super.setUp();        setTolerance(1E-6);    }    //---------------------------- Additional test cases -------------------------    /**     * @see <a href="http://issues.apache.org/bugzilla/show_bug.cgi?id=27243">     *      Bug report that prompted this unit test.</a>     */    public void testCumulativeProbabilityAgaintStackOverflow() throws Exception {        TDistributionImpl td = new TDistributionImpl(5.);        td.cumulativeProbability(.1);        td.cumulativeProbability(.01);    }    public void testSmallDf() throws Exception {        setDistribution(new TDistributionImpl(1d));        setTolerance(1E-4);        // quantiles computed using R version 1.8.1 (linux version)        setCumulativeTestPoints(new double[] {-318.3088, -31.82052, -12.70620, -6.313752,            -3.077684, 0.0, 318.3088, 31.82052, 12.70620,            6.313752, 3.077684});        setInverseCumulativeTestValues(getCumulativeTestPoints());        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }    public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0, 1});        setInverseCumulativeTestValues(                new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }    public void testDfAccessors() {        TDistribution distribution = (TDistribution) getDistribution();        assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);        distribution.setDegreesOfFreedom(4d);        assertEquals(4d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);        try {            distribution.setDegreesOfFreedom(0d);            fail("Expecting IllegalArgumentException for df = 0");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for CauchyDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class CauchyDistributionTest extends ContinuousDistributionAbstractTest  {        /**     * Constructor for CauchyDistributionTest.     * @param arg0     */    public CauchyDistributionTest(String arg0) {        super(arg0);    }        //-------------- Implementations for abstract methods -----------------------        /** Creates the default continuous distribution instance to use in tests. */    @Override    public ContinuousDistribution makeDistribution() {        return new CauchyDistributionImpl(1.2, 2.1);    }           /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using Mathematica         return new double[] {-667.2485619d, -65.6230835d, -25.48302995d,                -12.05887818d, -5.263135428d, 7.663135428d, 14.45887818d,                27.88302995d, 68.0230835d, 669.6485619d};    }        /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,                0.975d, 0.990d, 0.999d};    }        //---------------------------- Additional test cases -------------------------        public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0.0, 1.0});        setInverseCumulativeTestValues(                new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }        public void testMedian() {        CauchyDistribution distribution = (CauchyDistribution) getDistribution();        double expected = Math.random();        distribution.setMedian(expected);        assertEquals(expected, distribution.getMedian(), 0.0);    }        public void testScale() {        CauchyDistribution distribution = (CauchyDistribution) getDistribution();        double expected = Math.random();        distribution.setScale(expected);        assertEquals(expected, distribution.getScale(), 0.0);    }        public void testSetScale() {        CauchyDistribution distribution = (CauchyDistribution) getDistribution();        try {            distribution.setScale(0.0);            fail("Can not have 0.0 scale.");        } catch (IllegalArgumentException ex) {            // success        }                try {            distribution.setScale(-1.0);            fail("Can not have negative scale.");        } catch (IllegalArgumentException ex) {            // success        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for FDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class FDistributionTest extends ContinuousDistributionAbstractTest {    /**     * Constructor for FDistributionTest.     * @param name     */    public FDistributionTest(String name) {        super(name);    }    //-------------- Implementations for abstract methods -----------------------        /** Creates the default continuous distribution instance to use in tests. */    @Override    public ContinuousDistribution makeDistribution() {        return new FDistributionImpl(5.0, 6.0);    }           /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 1.8.1 (linux version)        return new double[] {0.03468084d ,0.09370091d, 0.1433137d,            0.2020084d, 0.2937283d, 20.80266d, 8.745895d, 5.987565d,             4.387374d, 3.107512d};    }        /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d};     }        // --------------------- Override tolerance  --------------    @Override    protected void setUp() throws Exception {        super.setUp();        setTolerance(4e-6);    }    //---------------------------- Additional test cases -------------------------    public void testCumulativeProbabilityExtremes() throws Exception {        setCumulativeTestPoints(new double[] {-2, 0});        setCumulativeTestValues(new double[] {0, 0});        verifyCumulativeProbabilities();    }    public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0, 1});        setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }        public void testDfAccessors() {        FDistribution distribution = (FDistribution) getDistribution();        assertEquals(5d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);        distribution.setNumeratorDegreesOfFreedom(4d);        assertEquals(4d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);        assertEquals(6d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);        distribution.setDenominatorDegreesOfFreedom(4d);        assertEquals(4d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);        try {            distribution.setNumeratorDegreesOfFreedom(0d);            fail("Expecting IllegalArgumentException for df = 0");        } catch (IllegalArgumentException ex) {            // expected        }        try {            distribution.setDenominatorDegreesOfFreedom(0d);            fail("Expecting IllegalArgumentException for df = 0");        } catch (IllegalArgumentException ex) {            // expected        }    }     public void testLargeDegreesOfFreedom() throws Exception {        org.apache.commons.math.distribution.FDistributionImpl fd =            new org.apache.commons.math.distribution.FDistributionImpl(                100000., 100000.);        double p = fd.cumulativeProbability(.999);        double x = fd.inverseCumulativeProbability(p);        assertEquals(.999, x, 1.0e-5);    }    public void testSmallDegreesOfFreedom() throws Exception {        org.apache.commons.math.distribution.FDistributionImpl fd =            new org.apache.commons.math.distribution.FDistributionImpl(                1.0, 1.0);        double p = fd.cumulativeProbability(0.975);        double x = fd.inverseCumulativeProbability(p);        assertEquals(0.975, x, 1.0e-5);        fd.setDenominatorDegreesOfFreedom(2.0);        p = fd.cumulativeProbability(0.975);        x = fd.inverseCumulativeProbability(p);        assertEquals(0.975, x, 1.0e-5);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for GammaDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class GammaDistributionTest extends ContinuousDistributionAbstractTest {        /**     * Constructor for GammaDistributionTest.     * @param name     */    public GammaDistributionTest(String name) {        super(name);    }    //-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public ContinuousDistribution makeDistribution() {        return new GammaDistributionImpl(4d, 2d);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 1.8.1 (linux version)        return new double[] {0.8571048, 1.646497, 2.179731, 2.732637,            3.489539, 26.12448, 20.09024, 17.53455,            15.50731, 13.36157};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d};    }    // --------------------- Override tolerance  --------------    @Override    protected void setUp() throws Exception {        super.setUp();        setTolerance(6e-6);    }    //---------------------------- Additional test cases -------------------------    public void testParameterAccessors() {        GammaDistribution distribution = (GammaDistribution) getDistribution();        assertEquals(4d, distribution.getAlpha(), 0);        distribution.setAlpha(3d);        assertEquals(3d, distribution.getAlpha(), 0);        assertEquals(2d, distribution.getBeta(), 0);        distribution.setBeta(4d);        assertEquals(4d, distribution.getBeta(), 0);        try {            distribution.setAlpha(0d);            fail("Expecting IllegalArgumentException for alpha = 0");        } catch (IllegalArgumentException ex) {            // expected        }        try {            distribution.setBeta(0d);            fail("Expecting IllegalArgumentException for beta = 0");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testProbabilities() throws Exception {        testProbability(-1.000, 4.0, 2.0, .0000);        testProbability(15.501, 4.0, 2.0, .9499);        testProbability(0.504, 4.0, 1.0, .0018);        testProbability(10.011, 1.0, 2.0, .9933);        testProbability(5.000, 2.0, 2.0, .7127);    }    public void testValues() throws Exception {        testValue(15.501, 4.0, 2.0, .9499);        testValue(0.504, 4.0, 1.0, .0018);        testValue(10.011, 1.0, 2.0, .9933);        testValue(5.000, 2.0, 2.0, .7127);    }    private void testProbability(double x, double a, double b, double expected) throws Exception {        GammaDistribution distribution = new GammaDistributionImpl( a, b );        double actual = distribution.cumulativeProbability(x);        assertEquals("probability for " + x, expected, actual, 10e-4);    }    private void testValue(double expected, double a, double b, double p) throws Exception {        GammaDistribution distribution = new GammaDistributionImpl( a, b );        double actual = distribution.inverseCumulativeProbability(p);        assertEquals("critical value for " + p, expected, actual, 10e-4);    }    public void testDensity() {        double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};        // R2.5: print(dgamma(x, shape=1, rate=1), digits=10)        checkDensity(1, 1, x, new double[]{0.000000000000, 0.999999000001, 0.606530659713, 0.367879441171, 0.135335283237, 0.006737946999});        // R2.5: print(dgamma(x, shape=2, rate=1), digits=10)        checkDensity(2, 1, x, new double[]{0.000000000000, 0.000000999999, 0.303265329856, 0.367879441171, 0.270670566473, 0.033689734995});        // R2.5: print(dgamma(x, shape=4, rate=1), digits=10)        checkDensity(4, 1, x, new double[]{0.000000000e+00, 1.666665000e-19, 1.263605541e-02, 6.131324020e-02, 1.804470443e-01, 1.403738958e-01});        // R2.5: print(dgamma(x, shape=4, rate=10), digits=10)        checkDensity(4, 10, x, new double[]{0.000000000e+00, 1.666650000e-15, 1.403738958e+00, 7.566654960e-02, 2.748204830e-05, 4.018228850e-17});        // R2.5: print(dgamma(x, shape=.1, rate=10), digits=10)        checkDensity(0.1, 10, x, new double[]{0.000000000e+00, 3.323953832e+04, 1.663849010e-03, 6.007786726e-06, 1.461647647e-10, 5.996008322e-24});        // R2.5: print(dgamma(x, shape=.1, rate=20), digits=10)        checkDensity(0.1, 20, x, new double[]{0.000000000e+00, 3.562489883e+04, 1.201557345e-05, 2.923295295e-10, 3.228910843e-19, 1.239484589e-45});        // R2.5: print(dgamma(x, shape=.1, rate=4), digits=10)        checkDensity(0.1, 4, x, new double[]{0.000000000e+00, 3.032938388e+04, 3.049322494e-02, 2.211502311e-03, 2.170613371e-05, 5.846590589e-11});        // R2.5: print(dgamma(x, shape=.1, rate=1), digits=10)        checkDensity(0.1, 1, x, new double[]{0.000000000e+00, 2.640334143e+04, 1.189704437e-01, 3.866916944e-02, 7.623306235e-03, 1.663849010e-04});    }    private void checkDensity(double alpha, double rate, double[] x, double[] expected) {        GammaDistribution d = new GammaDistributionImpl(alpha, 1 / rate);        for (int i = 0; i < x.length; i++) {            assertEquals(expected[i], d.density(x[i]), 1e-5);        }    }    public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0, 1});        setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import junit.framework.TestCase;import org.apache.commons.math.MathException;public class BetaDistributionTest extends TestCase {    public void testCumulative() throws MathException {        double[] x = new double[]{-0.1, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1};        // all test data computed using R 2.5        checkCumulative(0.1, 0.1,                x, new double[]{                0.0000000000, 0.0000000000, 0.4063850939, 0.4397091902, 0.4628041861,                0.4821200456, 0.5000000000, 0.5178799544, 0.5371958139, 0.5602908098,                0.5936149061, 1.0000000000, 1.0000000000});        checkCumulative(0.1, 0.5,                x, new double[]{                0.0000000000, 0.0000000000, 0.7048336221, 0.7593042194, 0.7951765304,                0.8234948385, 0.8480017124, 0.8706034370, 0.8926585878, 0.9156406404,                0.9423662883, 1.0000000000, 1.0000000000});        checkCumulative(0.1, 1.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.7943282347, 0.8513399225, 0.8865681506,                0.9124435366, 0.9330329915, 0.9502002165, 0.9649610951, 0.9779327685,                0.9895192582, 1.0000000000, 1.0000000000});        checkCumulative(0.1, 2.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.8658177758, 0.9194471163, 0.9486279211,                0.9671901487, 0.9796846411, 0.9882082252, 0.9939099280, 0.9974914239,                0.9994144508, 1.0000000000, 1.0000000000});        checkCumulative(0.1, 4.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.9234991121, 0.9661958941, 0.9842285085,                0.9928444112, 0.9970040660, 0.9989112804, 0.9996895625, 0.9999440793,                0.9999967829, 1.0000000000, 1.0000000000});        checkCumulative(0.5, 0.1,                x, new double[]{                0.00000000000, 0.00000000000, 0.05763371168, 0.08435935962,                0.10734141216, 0.12939656302, 0.15199828760, 0.17650516146,                0.20482346963, 0.24069578055, 0.29516637795, 1.00000000000, 1.00000000000});        checkCumulative(0.5, 0.5,                x, new double[]{                0.0000000000, 0.0000000000, 0.2048327647, 0.2951672353, 0.3690101196,                0.4359057832, 0.5000000000, 0.5640942168, 0.6309898804, 0.7048327647,                0.7951672353, 1.0000000000, 1.0000000000});        checkCumulative(0.5, 1.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.3162277660, 0.4472135955, 0.5477225575,                0.6324555320, 0.7071067812, 0.7745966692, 0.8366600265, 0.8944271910,                0.9486832981, 1.0000000000, 1.0000000000});        checkCumulative(0.5, 2.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.4585302607, 0.6260990337, 0.7394254526,                0.8221921916, 0.8838834765, 0.9295160031, 0.9621590305, 0.9838699101,                0.9961174630, 1.0000000000, 1.0000000000});        checkCumulative(0.5, 4.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.6266250826, 0.8049844719, 0.8987784842,                0.9502644369, 0.9777960959, 0.9914837366, 0.9974556254, 0.9995223859,                0.9999714889, 1.0000000000, 1.0000000000});        checkCumulative(1.0, 0.1,                x, new double[]{                0.00000000000, 0.00000000000, 0.01048074179, 0.02206723146,                0.03503890488, 0.04979978349, 0.06696700846, 0.08755646344,                0.11343184943, 0.14866007748, 0.20567176528, 1.00000000000, 1.00000000000});        checkCumulative(1.0, 0.5,                x, new double[]{                0.00000000000, 0.00000000000, 0.05131670195, 0.10557280900,                0.16333997347, 0.22540333076, 0.29289321881, 0.36754446797,                0.45227744249, 0.55278640450, 0.68377223398, 1.00000000000, 1.00000000000});        checkCumulative(1, 1,                x, new double[]{                0.0, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0});        checkCumulative(1, 2,                x, new double[]{                0.00, 0.00, 0.19, 0.36, 0.51, 0.64, 0.75, 0.84, 0.91, 0.96, 0.99, 1.00, 1.00});        checkCumulative(1, 4,                x, new double[]{                0.0000, 0.0000, 0.3439, 0.5904, 0.7599, 0.8704, 0.9375, 0.9744, 0.9919,                0.9984, 0.9999, 1.0000, 1.0000});        checkCumulative(2.0, 0.1,                x, new double[]{                0.0000000000000, 0.0000000000000, 0.0005855492117, 0.0025085760862,                0.0060900720266, 0.0117917748341, 0.0203153588864, 0.0328098512512,                0.0513720788952, 0.0805528836776, 0.1341822241505, 1.0000000000000, 1.0000000000000});        checkCumulative(2, 1,                x, new double[]{                0.00, 0.00, 0.01, 0.04, 0.09, 0.16, 0.25, 0.36, 0.49, 0.64, 0.81, 1.00, 1.00});        checkCumulative(2.0, 0.5,                x, new double[]{                0.000000000000, 0.000000000000, 0.003882537047, 0.016130089900,                0.037840969486, 0.070483996910, 0.116116523517, 0.177807808356,                0.260574547368, 0.373900966300, 0.541469739276, 1.000000000000, 1.000000000000});        checkCumulative(2, 2,                x, new double[]{                0.000, 0.000, 0.028, 0.104, 0.216, 0.352, 0.500, 0.648, 0.784, 0.896, 0.972, 1.000, 1.000});        checkCumulative(2, 4,                x, new double[]{                0.00000, 0.00000, 0.08146, 0.26272, 0.47178, 0.66304, 0.81250, 0.91296,                0.96922, 0.99328, 0.99954, 1.00000, 1.00000});        checkCumulative(4.0, 0.1,                x, new double[]{                0.000000000e+00, 0.000000000e+00, 3.217128269e-06, 5.592070271e-05,                3.104375474e-04, 1.088719595e-03, 2.995933981e-03, 7.155588777e-03,                1.577149153e-02, 3.380410585e-02, 7.650088789e-02, 1.000000000e+00, 1.000000000e+00});        checkCumulative(4.0, 0.5,                x, new double[]{                0.000000000e+00, 0.000000000e+00, 2.851114863e-05, 4.776140576e-04,                2.544374616e-03, 8.516263371e-03, 2.220390414e-02, 4.973556312e-02,                1.012215158e-01, 1.950155281e-01, 3.733749174e-01, 1.000000000e+00, 1.000000000e+00});        checkCumulative(4, 1,                x, new double[]{                0.0000, 0.0000, 0.0001, 0.0016, 0.0081, 0.0256, 0.0625, 0.1296, 0.2401,                0.4096, 0.6561, 1.0000, 1.0000});        checkCumulative(4, 2,                x, new double[]{                0.00000, 0.00000, 0.00046, 0.00672, 0.03078, 0.08704, 0.18750, 0.33696,                0.52822, 0.73728, 0.91854, 1.00000, 1.00000});        checkCumulative(4, 4,                x, new double[]{                0.000000, 0.000000, 0.002728, 0.033344, 0.126036, 0.289792, 0.500000,                0.710208, 0.873964, 0.966656, 0.997272, 1.000000, 1.000000});    }    private void checkCumulative(double alpha, double beta, double[] x, double[] cumes) throws MathException {        BetaDistribution d = new BetaDistributionImpl(alpha, beta);        for (int i = 0; i < x.length; i++) {            assertEquals(cumes[i], d.cumulativeProbability(x[i]), 1e-8);        }        for (int i = 1; i < x.length - 1; i++) {            assertEquals(x[i], d.inverseCumulativeProbability(cumes[i]), 1e-5);        }    }    public void testDensity() throws MathException {        double[] x = new double[]{1e-6, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9};        checkDensity(0.1, 0.1,                x, new double[]{                12741.2357380649, 0.4429889586665234, 2.639378715e-01, 2.066393611e-01,                1.832401831e-01, 1.766302780e-01, 1.832404579e-01, 2.066400696e-01,                2.639396531e-01, 4.429925026e-01});        checkDensity(0.1, 0.5,                x, new double[]{                2.218377102e+04, 7.394524202e-01, 4.203020268e-01, 3.119435533e-01,                2.600787829e-01, 2.330648626e-01, 2.211408259e-01, 2.222728708e-01,                2.414013907e-01, 3.070567405e-01});        checkDensity(0.1, 1.0,                x, new double[]{                2.511886432e+04, 7.943210858e-01, 4.256680458e-01, 2.955218303e-01,                2.281103709e-01, 1.866062624e-01, 1.583664652e-01, 1.378514078e-01,                1.222414585e-01, 1.099464743e-01});        checkDensity(0.1, 2.0,                x, new double[]{                2.763072312e+04, 7.863770012e-01, 3.745874120e-01, 2.275514842e-01,                1.505525939e-01, 1.026332391e-01, 6.968107049e-02, 4.549081293e-02,                2.689298641e-02, 1.209399123e-02});        checkDensity(0.1, 4.0,                x, new double[]{                2.997927462e+04, 6.911058917e-01, 2.601128486e-01, 1.209774010e-01,                5.880564714e-02, 2.783915474e-02, 1.209657335e-02, 4.442148268e-03,                1.167143939e-03, 1.312171805e-04});        checkDensity(0.5, 0.1,                x, new double[]{                88.3152184726, 0.3070542841, 0.2414007269, 0.2222727015,                0.2211409364, 0.2330652355, 0.2600795198, 0.3119449793,                0.4203052841, 0.7394649088});        checkDensity(0.5, 0.5,                x, new double[]{                318.3100453389, 1.0610282383, 0.7957732234, 0.6946084565,                0.6497470636, 0.6366197724, 0.6497476051, 0.6946097796,                0.7957762075, 1.0610376697});        checkDensity(0.5, 1.0,                x, new double[]{                500.0000000000, 1.5811309244, 1.1180311937, 0.9128694077,                0.7905684268, 0.7071060741, 0.6454966865, 0.5976138778,                0.5590166450, 0.5270459839});        checkDensity(0.5, 2.0,                x, new double[]{                749.99925000000, 2.134537420613655, 1.34163575536, 0.95851150881,                0.71151039830, 0.53032849490, 0.38729704363, 0.26892534859,                0.16770415497, 0.07905610701});        checkDensity(0.5, 4.0,                x, new double[]{                1.093746719e+03, 2.52142232809988, 1.252190241e+00, 6.849343920e-01,                3.735417140e-01, 1.933481570e-01, 9.036885833e-02, 3.529621669e-02,                9.782644546e-03, 1.152878503e-03});        checkDensity(1.0, 0.1,                x, new double[]{                0.1000000900, 0.1099466942, 0.1222417336, 0.1378517623, 0.1583669403,                0.1866069342, 0.2281113974, 0.2955236034, 0.4256718768,                0.7943353837});        checkDensity(1.0, 0.5,                x, new double[]{                0.5000002500, 0.5270465695, 0.5590173438, 0.5976147315, 0.6454977623,                0.7071074883, 0.7905704033, 0.9128724506,                1.1180367838, 1.5811467358});        checkDensity(1, 1,                x, new double[]{                1, 1, 1,                1, 1, 1, 1,                1, 1, 1});        checkDensity(1, 2,                x, new double[]{                1.999998, 1.799998, 1.599998, 1.399998, 1.199998, 0.999998, 0.799998,                0.599998, 0.399998,                0.199998});        checkDensity(1, 4,                x, new double[]{                3.999988000012, 2.915990280011, 2.047992320010, 1.371994120008,                0.863995680007, 0.499997000006, 0.255998080005, 0.107998920004,                0.031999520002, 0.003999880001});        checkDensity(2.0, 0.1,                x, new double[]{                1.100000990e-07, 1.209425730e-02, 2.689331586e-02, 4.549123318e-02,                6.968162794e-02, 1.026340191e-01, 1.505537732e-01, 2.275534997e-01,                3.745917198e-01, 7.863929037e-01});        checkDensity(2.0, 0.5,                x, new double[]{                7.500003750e-07, 7.905777599e-02, 1.677060417e-01, 2.689275256e-01,                3.872996256e-01, 5.303316769e-01, 7.115145488e-01, 9.585174425e-01,                1.341645818e+00, 2.134537420613655});        checkDensity(2, 1,                x, new double[]{                0.000002, 0.200002, 0.400002, 0.600002, 0.800002, 1.000002, 1.200002,                1.400002, 1.600002,                1.800002});        checkDensity(2, 2,                x, new double[]{                5.9999940e-06, 5.4000480e-01, 9.6000360e-01, 1.2600024e+00,                1.4400012e+00, 1.5000000e+00, 1.4399988e+00, 1.2599976e+00,                9.5999640e-01, 5.3999520e-01});        checkDensity(2, 4,                x, new double[]{                0.00001999994, 1.45800971996, 2.04800255997, 2.05799803998,                1.72799567999, 1.24999500000, 0.76799552000, 0.37799676001,                0.12799824001, 0.01799948000});        checkDensity(4.0, 0.1,                x, new double[]{                1.193501074e-19, 1.312253162e-04, 1.167181580e-03, 4.442248535e-03,                1.209679109e-02, 2.783958903e-02, 5.880649983e-02, 1.209791638e-01,                2.601171405e-01, 6.911229392e-01});        checkDensity(4.0, 0.5,                x, new double[]{                1.093750547e-18, 1.152948959e-03, 9.782950259e-03, 3.529697305e-02,                9.037036449e-02, 1.933508639e-01, 3.735463833e-01, 6.849425461e-01,                1.252205894e+00, 2.52142232809988});        checkDensity(4, 1,                x, new double[]{                4.000000000e-18, 4.000120001e-03, 3.200048000e-02, 1.080010800e-01,                2.560019200e-01, 5.000030000e-01, 8.640043200e-01, 1.372005880e+00,                2.048007680e+00, 2.916009720e+00});        checkDensity(4, 2,                x, new double[]{                1.999998000e-17, 1.800052000e-02, 1.280017600e-01, 3.780032400e-01,                7.680044800e-01, 1.250005000e+00, 1.728004320e+00, 2.058001960e+00,                2.047997440e+00, 1.457990280e+00});        checkDensity(4, 4,                x, new double[]{                1.399995800e-16, 1.020627216e-01, 5.734464512e-01, 1.296547409e+00,                1.935364838e+00, 2.187500000e+00, 1.935355162e+00, 1.296532591e+00,                5.734335488e-01, 1.020572784e-01});    }    private void checkDensity(double alpha, double beta, double[] x, double[] expected) throws MathException {        BetaDistribution d = new BetaDistributionImpl(alpha, beta);        for (int i = 0; i < x.length; i++) {            assertEquals(String.format("density at x=%.1f for alpha=%.1f, beta=%.1f", x[i], alpha, beta), expected[i], d.density(x[i]), 1e-5);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for {@link ZipfDistribution}. * Extends IntegerDistributionAbstractTest.  See class javadoc for * IntegerDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class ZipfDistributionTest extends IntegerDistributionAbstractTest {    public ZipfDistributionTest(String name) {        super(name);    }        //-------------- Implementations for abstract methods -----------------------        /** Creates the default discrete distribution instance to use in tests. */    @Override    public IntegerDistribution makeDistribution() {        return new ZipfDistributionImpl(10, 1);    }        /** Creates the default probability density test input values */    @Override    public int[] makeDensityTestPoints() {        return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};    }        /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0d, 0d, 0.3414d, 0.1707d, 0.1138d, 0.0854d, 0.0683d,                 0.0569d, 0.0488d, 0.0427d, 0.0379d, 0.0341d, 0d};    }        /** Creates the default cumulative probability density test input values */    @Override    public int[] makeCumulativeTestPoints() {        return makeDensityTestPoints();    }        /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0d, 0.0000d, 0.3414d, 0.5121d, 0.6259d, 0.7113d,                0.7796d, 0.8365d, 0.8852d, 0.9279d, 0.9659d, 1d, 1d};        }        /** Creates the default inverse cumulative probability test input values */    @Override    public double[] makeInverseCumulativeTestPoints() {        return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.3414d, 0.3415d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d, 1};         }        /** Creates the default inverse cumulative probability density test expected values */    @Override    public int[] makeInverseCumulativeTestValues() {        return new int[] {0, 0, 0, 0, 0, 0, 1, 9, 9, 9, 8, 7, 10};    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for NormalDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class NormalDistributionTest extends ContinuousDistributionAbstractTest  {        /**     * Constructor for NormalDistributionTest.     * @param arg0     */    public NormalDistributionTest(String arg0) {        super(arg0);    }        //-------------- Implementations for abstract methods -----------------------        /** Creates the default continuous distribution instance to use in tests. */    @Override    public ContinuousDistribution makeDistribution() {        return new NormalDistributionImpl(2.1, 1.4);    }           /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R         return new double[] {-2.226325d, -1.156887d, -0.6439496d, -0.2027951d, 0.3058278d,                 6.426325d, 5.356887d, 4.84395d, 4.402795d, 3.894172d};    }        /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d};     }        // --------------------- Override tolerance  --------------    @Override    protected void setUp() throws Exception {        super.setUp();        setTolerance(1E-6);    }        //---------------------------- Additional test cases -------------------------        private void verifyQuantiles() throws Exception {        NormalDistribution distribution = (NormalDistribution) getDistribution();        double mu = distribution.getMean();        double sigma = distribution.getStandardDeviation();        setCumulativeTestPoints( new double[] {mu - 2 *sigma, mu - sigma,                 mu, mu + sigma, mu +2 * sigma,  mu +3 * sigma, mu + 4 * sigma,                mu + 5 * sigma});        // Quantiles computed using R (same as Mathematica)        setCumulativeTestValues(new double[] {0.02275013, 0.1586553, 0.5, 0.8413447,                 0.9772499, 0.9986501, 0.9999683,  0.9999997});        verifyCumulativeProbabilities();           }        public void testQuantiles() throws Exception {        verifyQuantiles();        setDistribution(new NormalDistributionImpl(0, 1));        verifyQuantiles();        setDistribution(new NormalDistributionImpl(0, 0.1));        verifyQuantiles();    }        public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0, 1});        setInverseCumulativeTestValues(                new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }        public void testGetMean() {        NormalDistribution distribution = (NormalDistribution) getDistribution();        assertEquals(2.1, distribution.getMean(), 0);    }        public void testSetMean() throws Exception {        double mu = Math.random();        NormalDistribution distribution = (NormalDistribution) getDistribution();        distribution.setMean(mu);        verifyQuantiles();    }        public void testGetStandardDeviation() {        NormalDistribution distribution = (NormalDistribution) getDistribution();        assertEquals(1.4, distribution.getStandardDeviation(), 0);      }        public void testSetStandardDeviation() throws Exception {        double sigma = 0.1d + Math.random();        NormalDistribution distribution = (NormalDistribution) getDistribution();        distribution.setStandardDeviation(sigma);        assertEquals(sigma, distribution.getStandardDeviation(), 0);        verifyQuantiles();        try {            distribution.setStandardDeviation(0);            fail("Expecting IllegalArgumentException for sd = 0");        } catch (IllegalArgumentException ex) {            // Expected        }    }    public void testDensity() {        double [] x = new double[]{-2, -1, 0, 1, 2};        // R 2.5: print(dnorm(c(-2,-1,0,1,2)), digits=10)        checkDensity(0, 1, x, new double[]{0.05399096651, 0.24197072452, 0.39894228040, 0.24197072452, 0.05399096651});        // R 2.5: print(dnorm(c(-2,-1,0,1,2), mean=1.1), digits=10)         checkDensity(1.1, 1, x, new double[]{0.003266819056,0.043983595980,0.217852177033,0.396952547477,0.266085249899});    }    private void checkDensity(double mean, double sd, double[] x, double[] expected) {        NormalDistribution d = new NormalDistributionImpl(mean, sd);        for (int i = 0; i < x.length; i++) {            assertEquals(expected[i], d.density(x[i]), 1e-9);        }    }    /**     * Check to make sure top-coding of extreme values works correctly.     * Verifies fix for JIRA MATH-167     */    public void testExtremeValues() throws Exception {        NormalDistribution distribution = (NormalDistribution) getDistribution();        distribution.setMean(0);        distribution.setStandardDeviation(1);        for (int i = 0; i < 100; i+=5) { // make sure no convergence exception            double lowerTail = distribution.cumulativeProbability(-i);            double upperTail = distribution.cumulativeProbability(i);            if (i < 10) { // make sure not top-coded                assertTrue(lowerTail > 0.0d);                assertTrue(upperTail < 1.0d);            }            else { // make sure top coding not reversed                assertTrue(lowerTail < 0.00001);                assertTrue(upperTail > 0.99999);            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for ExponentialDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class ExponentialDistributionTest extends ContinuousDistributionAbstractTest {    /**     * Constructor for ExponentialDistributionTest.     * @param name     */    public ExponentialDistributionTest(String name) {        super(name);    }    //-------------- Implementations for abstract methods -----------------------        /** Creates the default continuous distribution instance to use in tests. */    @Override    public ContinuousDistribution makeDistribution() {        return new ExponentialDistributionImpl(5.0);    }           /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 1.8.1 (linux version)        return new double[] {0.005002502d, 0.05025168d, 0.1265890d, 0.2564665d, 0.5268026d,                 34.53878d, 23.02585d, 18.44440d, 14.97866d, 11.51293d};    }        /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d};     }        //------------ Additional tests -------------------------------------------     public void testCumulativeProbabilityExtremes() throws Exception {        setCumulativeTestPoints(new double[] {-2, 0});        setCumulativeTestValues(new double[] {0, 0});        verifyCumulativeProbabilities();    }    public void testInverseCumulativeProbabilityExtremes() throws Exception {         setInverseCumulativeTestPoints(new double[] {0, 1});         setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});         verifyInverseCumulativeProbabilities();    }    public void testCumulativeProbability2() throws Exception {        double actual = getDistribution().cumulativeProbability(0.25, 0.75);        assertEquals(0.0905214, actual, 10e-4);    }    public void testDensity() {        ExponentialDistribution d1 = new ExponentialDistributionImpl(1);        assertEquals(0.0, d1.density(-1e-9));        assertEquals(1.0, d1.density(0.0));        assertEquals(0.0, d1.density(1000.0));        assertEquals(Math.exp(-1), d1.density(1.0));        assertEquals(Math.exp(-2), d1.density(2.0));        ExponentialDistribution d2 = new ExponentialDistributionImpl(3);        assertEquals(1/3.0, d2.density(0.0));        // computed using  print(dexp(1, rate=1/3), digits=10) in R 2.5        assertEquals(0.2388437702, d2.density(1.0), 1e-8);        // computed using  print(dexp(2, rate=1/3), digits=10) in R 2.5        assertEquals(0.1711390397, d2.density(2.0), 1e-8);    }        public void testMeanAccessors() {        ExponentialDistribution distribution = (ExponentialDistribution) getDistribution();        assertEquals(5d, distribution.getMean(), Double.MIN_VALUE);        distribution.setMean(2d);        assertEquals(2d, distribution.getMean(), Double.MIN_VALUE);        try {            distribution.setMean(0);            fail("Expecting IllegalArgumentException for 0 mean");        } catch (IllegalArgumentException ex) {            // expected        }    }   }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for BinomialDistribution. * Extends IntegerDistributionAbstractTest.  See class javadoc for * IntegerDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class BinomialDistributionTest extends IntegerDistributionAbstractTest {        /**     * Constructor for BinomialDistributionTest.     * @param name     */    public BinomialDistributionTest(String name) {        super(name);    }        //-------------- Implementations for abstract methods -----------------------        /** Creates the default discrete distribution instance to use in tests. */    @Override    public IntegerDistribution makeDistribution() {        return new BinomialDistributionImpl(10,0.70);    }        /** Creates the default probability density test input values */    @Override    public int[] makeDensityTestPoints() {        return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};    }        /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0d, 0.0000d, 0.0001d, 0.0014d, 0.0090d, 0.0368d, 0.1029d,                 0.2001d, 0.2668d, 0.2335d, 0.1211d, 0.0282d, 0d};    }        /** Creates the default cumulative probability density test input values */    @Override    public int[] makeCumulativeTestPoints() {        return makeDensityTestPoints();    }        /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0d, 0.0000d, 0.0001d, 0.0016d, 0.0106d, 0.0473d,                0.1503d, 0.3504d, 0.6172d, 0.8507d, 0.9718d, 1d, 1d};        }        /** Creates the default inverse cumulative probability test input values */    @Override    public double[] makeInverseCumulativeTestPoints() {        return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d,1};         }        /** Creates the default inverse cumulative probability density test expected values */    @Override    public int[] makeInverseCumulativeTestValues() {        return new int[] {-1, 1, 2, 3, 4, 4, 9, 9, 9, 8, 8, Integer.MAX_VALUE};    }    //----------------- Additional test cases ---------------------------------       /** Test degenerate case p = 0   */    public void testDegenerate0() throws Exception {        setDistribution(new BinomialDistributionImpl(5,0.0d));        setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });        setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 10, 11});        setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {-1, -1});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();         }        /** Test degenerate case p = 1   */    public void testDegenerate1() throws Exception {        setDistribution(new BinomialDistributionImpl(5,1.0d));        setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });        setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10});        setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 1d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {4, 4});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();         }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.MathException;/** * <code>PoissonDistributionTest</code> *  * @version $Revision$ $Date$ */public class PoissonDistributionTest extends IntegerDistributionAbstractTest {    /**     * Poisson parameter value for the test distribution.     */    private static final double DEFAULT_TEST_POISSON_PARAMETER = 4.0;    /**     * Constructor.     * @param name     */    public PoissonDistributionTest(String name) {        super(name);        setTolerance(1e-12);    }    /**      * Creates the default discrete distribution instance to use in tests.      */    @Override    public IntegerDistribution makeDistribution() {        return new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);      }    /**      * Creates the default probability density test input values.     */    @Override    public int[] makeDensityTestPoints() {        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};    }    /**     * Creates the default probability density test expected values.     * These and all other test values are generated by R, version 1.8.1     */    @Override    public double[] makeDensityTestValues() {        return new double[] { 0d, 0.0183156388887d,  0.073262555555d,                0.14652511111d, 0.195366814813d, 0.195366814813,                 0.156293451851d, 0.00529247667642d, 8.27746364655e-09};    }    /**     * Creates the default cumulative probability density test input values.     */    @Override    public int[] makeCumulativeTestPoints() {        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20 };    }    /**     * Creates the default cumulative probability density test expected values.     */    @Override    public double[] makeCumulativeTestValues() {        return new double[] { 0d,  0.0183156388887d, 0.0915781944437d,                 0.238103305554d, 0.433470120367d, 0.62883693518,                0.78513038703d,  0.99716023388d, 0.999999998077 };    }    /**      * Creates the default inverse cumulative probability test input values.     * Increased 3rd and 7th values slightly as computed cumulative     * probabilities for corresponding values exceeds the target value (still      * within tolerance).     */    @Override    public double[] makeInverseCumulativeTestPoints() {        return new double[] { 0d,  0.018315638889d, 0.0915781944437d,                 0.238103305554d, 0.433470120367d, 0.62883693518,                0.78513038704d,  0.99716023388d, 0.999999998077 };    }    /**     * Creates the default inverse cumulative probability density test expected values.     */    @Override    public int[] makeInverseCumulativeTestValues() {        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};    }    /**     * Test the normal approximation of the Poisson distribution by     * calculating P(90 &le; X &le; 110) for X = Po(100) and     * P(9900 &le; X &le; 10200) for X  = Po(10000)     */    public void testNormalApproximateProbability() throws Exception {        PoissonDistribution dist = new PoissonDistributionImpl(100);        double result = dist.normalApproximateProbability(110)                - dist.normalApproximateProbability(89);        assertEquals(0.706281887248, result, 1E-10);        dist.setMean(10000);        result = dist.normalApproximateProbability(10200)        - dist.normalApproximateProbability(9899);        assertEquals(0.820070051552, result, 1E-10);    }    /**     * Test the degenerate cases of a 0.0 and 1.0 inverse cumulative probability.     * @throws Exception     */    public void testDegenerateInverseCumulativeProbability() throws Exception {        PoissonDistribution dist = new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);        assertEquals(Integer.MAX_VALUE, dist.inverseCumulativeProbability(1.0d));        assertEquals(-1, dist.inverseCumulativeProbability(0d));    }        public void testMean() {        PoissonDistribution dist = new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);        try {            dist.setMean(-1);            fail("negative mean.  IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }                dist.setMean(10.0);        assertEquals(10.0, dist.getMean(), 0.0);    }        public void testLargeMeanCumulativeProbability() {        PoissonDistribution dist = new PoissonDistributionImpl(1.0);        double mean = 1.0;        while (mean <= 10000000.0) {            dist.setMean(mean);                        double x = mean * 2.0;            double dx = x / 10.0;            while (x >= 0) {                try {                    dist.cumulativeProbability(x);                } catch (MathException ex) {                    fail("mean of " + mean + " and x of " + x + " caused " + ex.getMessage());                }                x -= dx;            }                        mean *= 10.0;        }    }        public void testLargeMeanInverseCumulativeProbability() {        PoissonDistribution dist = new PoissonDistributionImpl(1.0);        double mean = 1.0;        while (mean <= 10000000.0) {            dist.setMean(mean);                        double p = 0.1;            double dp = p;            while (p < 1.0) {                try {                    dist.inverseCumulativeProbability(p);                } catch (MathException ex) {                    fail("mean of " + mean + " and p of " + p + " caused " + ex.getMessage());                }                p += dp;            }                        mean *= 10.0;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for ChiSquareDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. *  * @version $Revision$ $Date$ */public class ChiSquareDistributionTest extends ContinuousDistributionAbstractTest {        /**     * Constructor for ChiSquareDistributionTest.     * @param name     */    public ChiSquareDistributionTest(String name) {        super(name);    }        //-------------- Implementations for abstract methods -----------------------        /** Creates the default continuous distribution instance to use in tests. */    @Override    public ContinuousDistribution makeDistribution() {        return new ChiSquaredDistributionImpl(5.0);    }           /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 1.8.1 (linux version)        return new double[] {0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d,                 20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d};    }        /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d};     }        /** Creates the default inverse cumulative probability test input values */    @Override    public double[] makeInverseCumulativeTestPoints() {        return new double[] {0, 0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d, 1};         }        /** Creates the default inverse cumulative probability density test expected values */    @Override    public double[] makeInverseCumulativeTestValues() {        return new double[] {0, 0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d,                 20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d,                 Double.POSITIVE_INFINITY};    }     // --------------------- Override tolerance  --------------    @Override    protected void setUp() throws Exception {        super.setUp();        setTolerance(5e-6);    } //---------------------------- Additional test cases -------------------------        public void testSmallDf() throws Exception {        setDistribution(new ChiSquaredDistributionImpl(0.1d));        setTolerance(1E-4);        // quantiles computed using R version 1.8.1 (linux version)        setCumulativeTestPoints(new double[] {1.168926E-60, 1.168926E-40, 1.063132E-32,                 1.144775E-26, 1.168926E-20, 5.472917, 2.175255, 1.13438,                 0.5318646, 0.1526342});        setInverseCumulativeTestValues(getCumulativeTestPoints());        setInverseCumulativeTestPoints(getCumulativeTestValues());        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }        public void testDfAccessors() {        ChiSquaredDistribution distribution = (ChiSquaredDistribution) getDistribution();        assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);        distribution.setDegreesOfFreedom(4d);        assertEquals(4d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);        try {            distribution.setDegreesOfFreedom(0d);            fail("Expecting IllegalArgumentException for df = 0");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testDensity() {        double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};        //R 2.5: print(dchisq(x, df=1), digits=10)        checkDensity(1, x, new double[]{0.00000000000, 398.94208093034, 0.43939128947, 0.24197072452, 0.10377687436, 0.01464498256});        //R 2.5: print(dchisq(x, df=0.1), digits=10)        checkDensity(0.1, x, new double[]{0.000000000e+00, 2.486453997e+04, 7.464238732e-02, 3.009077718e-02, 9.447299159e-03, 8.827199396e-04});        //R 2.5: print(dchisq(x, df=2), digits=10)        checkDensity(2, x, new double[]{0.00000000000, 0.49999975000, 0.38940039154, 0.30326532986, 0.18393972059, 0.04104249931});        //R 2.5: print(dchisq(x, df=10), digits=10)        checkDensity(10, x, new double[]{0.000000000e+00, 1.302082682e-27, 6.337896998e-05, 7.897534632e-04, 7.664155024e-03, 6.680094289e-02});    }    private void checkDensity(double df, double[] x, double[] expected) {        ChiSquaredDistribution d = new ChiSquaredDistributionImpl(df);        for (int i = 0; i < x.length; i++) {            assertEquals(expected[i], d.density(x[i]), 1e-5);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;/** * Abstract base class for {@link ContinuousDistribution} tests. * <p> * To create a concrete test class for a continuous distribution * implementation, first implement makeDistribution() to return a distribution * instance to use in tests. Then implement each of the test data generation * methods below.  In each case, the test points and test values arrays * returned represent parallel arrays of inputs and expected values for the * distribution returned by makeDistribution().  Default implementations * are provided for the makeInverseXxx methods that just invert the mapping * defined by the arrays returned by the makeCumulativeXxx methods. * <p> * makeCumulativeTestPoints() -- arguments used to test cumulative probabilities * makeCumulativeTestValues() -- expected cumulative probabilites * makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf * makeInverseCumulativeTestValues() -- expected inverse cdf values * <p> * To implement additional test cases with different distribution instances and * test data, use the setXxx methods for the instance data in test cases and * call the verifyXxx methods to verify results.  * <p> * Error tolerance can be overriden by implementing getTolerance(). * <p> * Test data should be validated against reference tables or other packages * where possible, and the source of the reference data and/or validation * should be documented in the test cases.  A framework for validating * distribution data against R is included in the /src/test/R source tree. * <p> * See {@link NormalDistributionTest} and {@link ChiSquareDistributionTest} * for examples. *  * @version $Revision$ $Date$ */public abstract class ContinuousDistributionAbstractTest extends TestCase {    //-------------------- Private test instance data -------------------------    /**  Distribution instance used to perform tests */    private ContinuousDistribution distribution;        /** Tolerance used in comparing expected and returned values */    private double tolerance = 1E-4;        /** Arguments used to test cumulative probability density calculations */    private double[] cumulativeTestPoints;        /** Values used to test cumulative probability density calculations */    private double[] cumulativeTestValues;        /** Arguments used to test inverse cumulative probability density calculations */    private double[] inverseCumulativeTestPoints;        /** Values used to test inverse cumulative probability density calculations */    private double[] inverseCumulativeTestValues;        //-------------------------------------------------------------------------        /**     * Constructor for ContinuousDistributionAbstractTest.     * @param name     */    public ContinuousDistributionAbstractTest(String name) {        super(name);    }        //-------------------- Abstract methods -----------------------------------        /** Creates the default continuous distribution instance to use in tests. */    public abstract ContinuousDistribution makeDistribution();        /** Creates the default cumulative probability density test input values */    public abstract double[] makeCumulativeTestPoints();        /** Creates the default cumulative probability density test expected values */    public abstract double[] makeCumulativeTestValues();        //---- Default implementations of inverse test data generation methods ----        /** Creates the default inverse cumulative probability test input values */    public double[] makeInverseCumulativeTestPoints() {        return makeCumulativeTestValues();    }        /** Creates the default inverse cumulative probability density test expected values */    public double[] makeInverseCumulativeTestValues() {        return makeCumulativeTestPoints();    }        //-------------------- Setup / tear down ----------------------------------         /**     * Setup sets all test instance data to default values      */    @Override    protected void setUp() throws Exception {        super.setUp();        distribution = makeDistribution();        cumulativeTestPoints = makeCumulativeTestPoints();        cumulativeTestValues = makeCumulativeTestValues();        inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();        inverseCumulativeTestValues = makeInverseCumulativeTestValues();       }        /**     * Cleans up test instance data     */    @Override    protected void tearDown() throws Exception {              super.tearDown();        distribution = null;        cumulativeTestPoints = null;        cumulativeTestValues = null;        inverseCumulativeTestPoints = null;        inverseCumulativeTestValues = null;       }        //-------------------- Verification methods -------------------------------        /**     * Verifies that cumulative probability density calculations match expected values     * using current test instance data     */       protected void verifyCumulativeProbabilities() throws Exception {        for (int i = 0; i < cumulativeTestPoints.length; i++) {            TestUtils.assertEquals("Incorrect cumulative probability value returned for "                 + cumulativeTestPoints[i], cumulativeTestValues[i],                 distribution.cumulativeProbability(cumulativeTestPoints[i]),                 getTolerance());        }               }        /**     * Verifies that inverse cumulative probability density calculations match expected values     * using current test instance data     */    protected void verifyInverseCumulativeProbabilities() throws Exception {        for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {            TestUtils.assertEquals("Incorrect inverse cumulative probability value returned for "                 + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i],                  distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]),                  getTolerance());        }               }        //------------------------ Default test cases -----------------------------        /**     * Verifies that cumulative probability density calculations match expected values     * using default test instance data     */    public void testCumulativeProbabilities() throws Exception {        verifyCumulativeProbabilities();          }        /**     * Verifies that inverse cumulative probability density calculations match expected values     * using default test instance data     */    public void testInverseCumulativeProbabilities() throws Exception {        verifyInverseCumulativeProbabilities();           }        /**     * Verifies that probability computations are consistent     */    public void testConsistency() throws Exception {        for (int i=1; i < cumulativeTestPoints.length; i++) {                        // check that cdf(x, x) = 0            TestUtils.assertEquals(0d,                distribution.cumulativeProbability                 (cumulativeTestPoints[i], cumulativeTestPoints[i]), tolerance);                        // check that P(a < X < b) = P(X < b) - P(X < a)            double upper = Math.max(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);            double lower = Math.min(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);            double diff = distribution.cumulativeProbability(upper) -                 distribution.cumulativeProbability(lower);            double direct = distribution.cumulativeProbability(lower, upper);            TestUtils.assertEquals("Inconsistent cumulative probabilities for ("                     + lower + "," + upper + ")", diff, direct, tolerance);        }    }        /**     * Verifies that illegal arguments are correctly handled     */    public void testIllegalArguments() throws Exception {        try {            distribution.cumulativeProbability(1, 0);            fail("Expecting IllegalArgumentException for bad cumulativeProbability interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            distribution.inverseCumulativeProbability(-1);            fail("Expecting IllegalArgumentException for p = -1");        } catch (IllegalArgumentException ex) {            // expected        }        try {            distribution.inverseCumulativeProbability(2);            fail("Expecting IllegalArgumentException for p = 2");        } catch (IllegalArgumentException ex) {            // expected        }           }        //------------------ Getters / Setters for test instance data -----------    /**     * @return Returns the cumulativeTestPoints.     */    protected double[] getCumulativeTestPoints() {        return cumulativeTestPoints;    }    /**     * @param cumulativeTestPoints The cumulativeTestPoints to set.     */    protected void setCumulativeTestPoints(double[] cumulativeTestPoints) {        this.cumulativeTestPoints = cumulativeTestPoints;    }    /**     * @return Returns the cumulativeTestValues.     */    protected double[] getCumulativeTestValues() {        return cumulativeTestValues;    }    /**     * @param cumulativeTestValues The cumulativeTestValues to set.     */    protected void setCumulativeTestValues(double[] cumulativeTestValues) {        this.cumulativeTestValues = cumulativeTestValues;    }    /**     * @return Returns the distribution.     */    protected ContinuousDistribution getDistribution() {        return distribution;    }    /**     * @param distribution The distribution to set.     */    protected void setDistribution(ContinuousDistribution distribution) {        this.distribution = distribution;    }    /**     * @return Returns the inverseCumulativeTestPoints.     */    protected double[] getInverseCumulativeTestPoints() {        return inverseCumulativeTestPoints;    }    /**     * @param inverseCumulativeTestPoints The inverseCumulativeTestPoints to set.     */    protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) {        this.inverseCumulativeTestPoints = inverseCumulativeTestPoints;    }    /**     * @return Returns the inverseCumulativeTestValues.     */    protected double[] getInverseCumulativeTestValues() {        return inverseCumulativeTestValues;    }    /**     * @param inverseCumulativeTestValues The inverseCumulativeTestValues to set.     */    protected void setInverseCumulativeTestValues(double[] inverseCumulativeTestValues) {        this.inverseCumulativeTestValues = inverseCumulativeTestValues;    }    /**     * @return Returns the tolerance.     */    protected double getTolerance() {        return tolerance;    }    /**     * @param tolerance The tolerance to set.     */    protected void setTolerance(double tolerance) {        this.tolerance = tolerance;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.ConvergenceException;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.events.EventException;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.nonstiff.HighamHall54Integrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;public class HighamHall54IntegratorTest  extends TestCase {  public HighamHall54IntegratorTest(String name) {    super(name);  }  public void testWrongDerivative() {    try {      HighamHall54Integrator integrator =          new HighamHall54Integrator(0.0, 1.0, 1.0e-10, 1.0e-10);      FirstOrderDifferentialEquations equations =          new FirstOrderDifferentialEquations() {            private static final long serialVersionUID = -1157081786301178032L;            public void computeDerivatives(double t, double[] y, double[] dot)            throws DerivativeException {            if (t < -0.5) {                throw new DerivativeException("{0}", "oops");            } else {                throw new DerivativeException(new RuntimeException("oops"));           }          }          public int getDimension() {              return 1;          }      };      try  {        integrator.integrate(equations, -1.0, new double[1], 0.0, new double[1]);        fail("an exception should have been thrown");      } catch(DerivativeException de) {        // expected behavior      }      try  {        integrator.integrate(equations, 0.0, new double[1], 1.0, new double[1]);        fail("an exception should have been thrown");      } catch(DerivativeException de) {        // expected behavior      }    } catch (Exception e) {      fail("wrong exception caught: " + e.getMessage());            }  }  public void testMinStep() {    try {      TestProblem1 pb = new TestProblem1();      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              vecAbsoluteTolerance,                                                              vecRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testIncreasingTolerance()    throws DerivativeException, IntegratorException {    int previousCalls = Integer.MAX_VALUE;    for (int i = -12; i < -2; ++i) {      TestProblem1 pb = new TestProblem1();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = Math.pow(10.0, i);      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      // the 1.3 factor is only valid for this test      // and has been obtained from trial and error      // there is no general relation between local and global errors      assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      int calls = pb.getCalls();      assertEquals(integ.getEvaluations(), calls);      assertTrue(calls <= previousCalls);      previousCalls = calls;    }  }  public void testBackward()      throws DerivativeException, IntegratorException {      TestProblem5 pb = new TestProblem5();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertTrue(handler.getLastError() < 5.0e-7);      assertTrue(handler.getMaximalValueError() < 5.0e-7);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      assertEquals("Higham-Hall 5(4)", integ.getName());  }  public void testEvents()    throws DerivativeException, IntegratorException {    TestProblem4 pb = new TestProblem4();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                            scalAbsoluteTolerance,                                                            scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    EventHandler[] functions = pb.getEventsHandlers();    for (int l = 0; l < functions.length; ++l) {      integ.addEventHandler(functions[l],                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);    }    assertEquals(functions.length, integ.getEventHandlers().size());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getMaximalValueError() < 1.0e-7);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);    integ.clearEventHandlers();    assertEquals(0, integ.getEventHandlers().size());  }  public void testEventsErrors() {      final TestProblem1 pb = new TestProblem1();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ =          new HighamHall54Integrator(minStep, maxStep,                                     scalAbsoluteTolerance, scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.addEventHandler(new EventHandler() {        public int eventOccurred(double t, double[] y, boolean increasing) {          return EventHandler.CONTINUE;        }        public double g(double t, double[] y) throws EventException {          double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;          double offset = t - middle;          if (offset > 0) {            throw new EventException("Evaluation failed for argument = {0}", t);          }          return offset;        }        public void resetState(double t, double[] y) {        }        private static final long serialVersionUID = 935652725339916361L;      }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);      try {        integ.integrate(pb,                        pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        fail("an exception should have been thrown");      } catch (IntegratorException ie) {        // expected behavior      } catch (Exception e) {        fail("wrong exception type caught");      }  }  public void testEventsNoConvergence() {    final TestProblem1 pb = new TestProblem1();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ =        new HighamHall54Integrator(minStep, maxStep,                                   scalAbsoluteTolerance, scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.addEventHandler(new EventHandler() {      public int eventOccurred(double t, double[] y, boolean increasing) {        return EventHandler.CONTINUE;      }      public double g(double t, double[] y) {        double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;        double offset = t - middle;        return (offset > 0) ? (offset + 0.5) : (offset - 0.5);      }      public void resetState(double t, double[] y) {      }      private static final long serialVersionUID = 935652725339916361L;    }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 3);    try {      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch (IntegratorException ie) {       assertTrue(ie.getCause() != null);       assertTrue(ie.getCause() instanceof ConvergenceException);    } catch (Exception e) {      fail("wrong exception type caught");    }}  public void testSanityChecks() {    try {      final TestProblem3 pb  = new TestProblem3(0.9);      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      try {        FirstOrderIntegrator integ =            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);        integ.integrate(pb, pb.getInitialTime(), new double[6],                        pb.getFinalTime(), new double[pb.getDimension()]);        fail("an exception should have been thrown");      } catch (IntegratorException ie) {        // expected behavior      }      try {        FirstOrderIntegrator integ =            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[6]);        fail("an exception should have been thrown");      } catch (IntegratorException ie) {        // expected behavior      }      try {        FirstOrderIntegrator integ =            new HighamHall54Integrator(minStep, maxStep, new double[2], new double[4]);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        fail("an exception should have been thrown");      } catch (IntegratorException ie) {        // expected behavior      }      try {        FirstOrderIntegrator integ =            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[2]);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        fail("an exception should have been thrown");      } catch (IntegratorException ie) {        // expected behavior      }      try {        FirstOrderIntegrator integ =            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getInitialTime(), new double[pb.getDimension()]);        fail("an exception should have been thrown");      } catch (IntegratorException ie) {        // expected behavior      }    } catch (Exception e) {      fail("wrong exception caught: " + e.getMessage());    }  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double[] vecAbsoluteTolerance = { 1.0e-8, 1.0e-8, 1.0e-10, 1.0e-10 };    double[] vecRelativeTolerance = { 1.0e-10, 1.0e-10, 1.0e-8, 1.0e-8 };    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                            vecAbsoluteTolerance,                                                            vecRelativeTolerance);    integ.addStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertEquals("Higham-Hall 5(4)", integ.getName());  }  private static class KeplerHandler implements StepHandler {    private static final long serialVersionUID = 3200246026175251943L;    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      nbSteps = 0;      maxError = 0;    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      nbSteps = 0;      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) throws DerivativeException {      ++nbSteps;      double[] interpolatedY = interpolator.getInterpolatedState();      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }      if (isLast) {        assertTrue(maxError < 4e-11);        assertTrue(nbSteps < 670);      }    }    private TestProblem3 pb;    private int nbSteps;    private double maxError;  }  public static Test suite() {    return new TestSuite(HighamHall54IntegratorTest.class);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;import org.apache.commons.math.ode.sampling.DummyStepHandler;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import junit.framework.*;public class DormandPrince853IntegratorTest  extends TestCase {  public DormandPrince853IntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,                                                                             1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()+10],                           1.0, new double[pb.getDimension()+10]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testNullIntervalCheck() {    try  {      TestProblem1 pb = new TestProblem1();      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,                                                                             1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()],                           0.0, new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testMinStep() {    try {      TestProblem1 pb = new TestProblem1();      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                  vecAbsoluteTolerance,                                                                  vecRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testIncreasingTolerance()    throws DerivativeException, IntegratorException {    int previousCalls = Integer.MAX_VALUE;    for (int i = -12; i < -2; ++i) {      TestProblem1 pb = new TestProblem1();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = Math.pow(10.0, i);      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                  scalAbsoluteTolerance,                                                                  scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      // the 1.3 factor is only valid for this test      // and has been obtained from trial and error      // there is no general relation between local and global errors      assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      int calls = pb.getCalls();      assertEquals(integ.getEvaluations(), calls);      assertTrue(calls <= previousCalls);      previousCalls = calls;    }  }  public void testBackward()      throws DerivativeException, IntegratorException {      TestProblem5 pb = new TestProblem5();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                  scalAbsoluteTolerance,                                                                  scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertTrue(handler.getLastError() < 8.0e-8);      assertTrue(handler.getMaximalValueError() < 2.0e-7);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      assertEquals("Dormand-Prince 8 (5, 3)", integ.getName());  }  public void testEvents()    throws DerivativeException, IntegratorException {    TestProblem4 pb = new TestProblem4();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-9;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                scalAbsoluteTolerance,                                                                scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    EventHandler[] functions = pb.getEventsHandlers();    for (int l = 0; l < functions.length; ++l) {      integ.addEventHandler(functions[l],                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);    }    assertEquals(functions.length, integ.getEventHandlers().size());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getMaximalValueError() < 5.0e-8);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);    integ.clearEventHandlers();    assertEquals(0, integ.getEventHandlers().size());  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                scalAbsoluteTolerance,                                                                scalRelativeTolerance);    integ.addStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertEquals(integ.getEvaluations(), pb.getCalls());    assertTrue(pb.getCalls() < 3300);  }  public void testVariableSteps()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);    integ.addStepHandler(new VariableHandler());    double stopTime = integ.integrate(pb,                                      pb.getInitialTime(), pb.getInitialState(),                                      pb.getFinalTime(), new double[pb.getDimension()]);    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);    assertEquals("Dormand-Prince 8 (5, 3)", integ.getName());  }  public void testNoDenseOutput()    throws DerivativeException, IntegratorException {    TestProblem1 pb1 = new TestProblem1();    TestProblem1 pb2 = (TestProblem1) pb1.clone();    double minStep = 0.1 * (pb1.getFinalTime() - pb1.getInitialTime());    double maxStep = pb1.getFinalTime() - pb1.getInitialTime();    double scalAbsoluteTolerance = 1.0e-4;    double scalRelativeTolerance = 1.0e-4;    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                scalAbsoluteTolerance,                                                                scalRelativeTolerance);    integ.addStepHandler(DummyStepHandler.getInstance());    integ.integrate(pb1,                    pb1.getInitialTime(), pb1.getInitialState(),                    pb1.getFinalTime(), new double[pb1.getDimension()]);    int callsWithoutDenseOutput = pb1.getCalls();    assertEquals(integ.getEvaluations(), callsWithoutDenseOutput);    integ.addStepHandler(new InterpolatingStepHandler());    integ.integrate(pb2,                    pb2.getInitialTime(), pb2.getInitialState(),                    pb2.getFinalTime(), new double[pb2.getDimension()]);    int callsWithDenseOutput = pb2.getCalls();    assertEquals(integ.getEvaluations(), callsWithDenseOutput);    assertTrue(callsWithDenseOutput > callsWithoutDenseOutput);  }  public void testUnstableDerivative()  throws DerivativeException, IntegratorException {    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);    FirstOrderIntegrator integ =      new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0);    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);    double[] y = { Double.NaN };    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);    assertEquals(8.0, y[0], 1.0e-12);  }  private static class KeplerHandler implements StepHandler {    private static final long serialVersionUID = -1752092987112788459L;    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public boolean requiresDenseOutput() {      return true;    }    public void reset() {      nbSteps = 0;      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast)    throws DerivativeException {      ++nbSteps;      for (int a = 1; a < 10; ++a) {        double prev   = interpolator.getPreviousTime();        double curr   = interpolator.getCurrentTime();        double interp = ((10 - a) * prev + a * curr) / 10;        interpolator.setInterpolatedTime(interp);        double[] interpolatedY = interpolator.getInterpolatedState ();        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());        double dx = interpolatedY[0] - theoreticalY[0];        double dy = interpolatedY[1] - theoreticalY[1];        double error = dx * dx + dy * dy;        if (error > maxError) {          maxError = error;        }      }      if (isLast) {        assertTrue(maxError < 2.4e-10);        assertTrue(nbSteps < 150);      }    }    private int nbSteps;    private double maxError;    private TestProblem3 pb;  }  private static class VariableHandler implements StepHandler {    private static final long serialVersionUID = 5542665697103383623L;    public VariableHandler() {      reset();    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      firstTime = true;      minStep = 0;      maxStep = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) {      double step = Math.abs(interpolator.getCurrentTime()                             - interpolator.getPreviousTime());      if (firstTime) {        minStep   = Math.abs(step);        maxStep   = minStep;        firstTime = false;      } else {        if (step < minStep) {          minStep = step;        }        if (step > maxStep) {          maxStep = step;        }      }      if (isLast) {        assertTrue(minStep < (1.0 / 100.0));        assertTrue(maxStep > (1.0 / 2.0));      }    }    private boolean firstTime = true;    private double  minStep = 0;    private double  maxStep = 0;  }  private static class InterpolatingStepHandler implements StepHandler {    private static final long serialVersionUID = -5272695044664350727L;    public boolean requiresDenseOutput() {      return true;    }    public void reset() {    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast)    throws DerivativeException {      double prev = interpolator.getPreviousTime();      double curr = interpolator.getCurrentTime();      interpolator.setInterpolatedTime(0.5*(prev + curr));    }  }  public static Test suite() {    return new TestSuite(DormandPrince853IntegratorTest.class);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import junit.framework.*;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.nonstiff.MidpointIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;public class MidpointIntegratorTest  extends TestCase {  public MidpointIntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      new MidpointIntegrator(0.01).integrate(pb,                                             0.0, new double[pb.getDimension()+10],                                             1.0, new double[pb.getDimension()+10]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }    public void testDecreasingSteps()    throws DerivativeException, IntegratorException  {          TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousError = Double.NaN;      for (int i = 4; i < 10; ++i) {        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();        double step = (pb.getFinalTime() - pb.getInitialTime())          * Math.pow(2.0, -i);        FirstOrderIntegrator integ = new MidpointIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        EventHandler[] functions = pb.getEventsHandlers();        for (int l = 0; l < functions.length; ++l) {          integ.addEventHandler(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);        }        double stopTime = integ.integrate(pb,                                          pb.getInitialTime(), pb.getInitialState(),                                          pb.getFinalTime(), new double[pb.getDimension()]);        if (functions.length == 0) {            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);        }        double error = handler.getMaximalValueError();        if (i > 4) {          assertTrue(error < Math.abs(previousError));        }        previousError = error;        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      }    }  }  public void testSmallStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb  = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new MidpointIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() < 2.0e-7);    assertTrue(handler.getMaximalValueError() < 1.0e-6);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals("midpoint", integ.getName());  }  public void testBigStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb  = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new MidpointIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() > 0.01);    assertTrue(handler.getMaximalValueError() > 0.05);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);  }  public void testBackward()      throws DerivativeException, IntegratorException {      TestProblem5 pb = new TestProblem5();      double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new MidpointIntegrator(step);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertTrue(handler.getLastError() < 6.0e-4);      assertTrue(handler.getMaximalValueError() < 6.0e-4);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      assertEquals("midpoint", integ.getName());  }  public void testStepSize()    throws DerivativeException, IntegratorException {      final double step = 1.23456;      FirstOrderIntegrator integ = new MidpointIntegrator(step);      integ.addStepHandler(new StepHandler() {          private static final long serialVersionUID = 0L;          public void handleStep(StepInterpolator interpolator, boolean isLast) {              if (! isLast) {                  assertEquals(step,                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),                               1.0e-12);              }          }          public boolean requiresDenseOutput() {              return false;          }          public void reset() {          }                });      integ.integrate(new FirstOrderDifferentialEquations() {          private static final long serialVersionUID = 0L;          public void computeDerivatives(double t, double[] y, double[] dot) {              dot[0] = 1.0;          }          public int getDimension() {              return 1;          }      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);  }  public static Test suite() {    return new TestSuite(MidpointIntegratorTest.class);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    y' = -y * </pre> * the solution of this equation is a simple exponential function : * <pre> *   y (t) = y (t0) exp (t0-t) * </pre> * </p> */public class TestProblem1  extends TestProblemAbstract {  /** Serializable version identifier. */  private static final long serialVersionUID = 1977870815289373164L;  /** theoretical state */  private double[] y;  /**   * Simple constructor.   */  public TestProblem1() {    super();    double[] y0 = { 1.0, 0.1 };    setInitialConditions(0.0, y0);    setFinalConditions(4.0);    double[] errorScale = { 1.0, 1.0 };    setErrorScale(errorScale);    y = new double[y0.length];  }   /**   * Copy constructor.   * @param problem problem to copy   */  public TestProblem1(TestProblem1 problem) {    super(problem);    y = problem.y.clone();  }  /**   * Clone operation.   * @return a copy of the instance   */  @Override  public Object clone() {    return new TestProblem1(this);  }  @Override  public void doComputeDerivatives(double t, double[] y, double[] yDot) {    // compute the derivatives    for (int i = 0; i < n; ++i)      yDot[i] = -y[i];  }  @Override  public double[] computeTheoreticalState(double t) {    double c = Math.exp (t0 - t);    for (int i = 0; i < n; ++i) {      y[i] = c * y0[i];    }    return y;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;import org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import junit.framework.*;public class DormandPrince54IntegratorTest  extends TestCase {  public DormandPrince54IntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      DormandPrince54Integrator integrator = new DormandPrince54Integrator(0.0, 1.0,                                                                           1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()+10],                           1.0, new double[pb.getDimension()+10]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testMinStep() {    try {      TestProblem1 pb = new TestProblem1();      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                 vecAbsoluteTolerance,                                                                 vecRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testSmallLastStep()    throws DerivativeException, IntegratorException {    TestProblemAbstract pb = new TestProblem5();    double minStep = 1.25;    double maxStep = Math.abs(pb.getFinalTime() - pb.getInitialTime());    double scalAbsoluteTolerance = 6.0e-4;    double scalRelativeTolerance = 6.0e-4;    AdaptiveStepsizeIntegrator integ =      new DormandPrince54Integrator(minStep, maxStep,                                    scalAbsoluteTolerance,                                    scalRelativeTolerance);    DP54SmallLastHandler handler = new DP54SmallLastHandler(minStep);    integ.addStepHandler(handler);    integ.setInitialStepSize(1.7);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.wasLastSeen());    assertEquals("Dormand-Prince 5(4)", integ.getName());  }  public void testBackward()      throws DerivativeException, IntegratorException {      TestProblem5 pb = new TestProblem5();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                 scalAbsoluteTolerance,                                                                 scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertTrue(handler.getLastError() < 2.0e-7);      assertTrue(handler.getMaximalValueError() < 2.0e-7);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      assertEquals("Dormand-Prince 5(4)", integ.getName());  }  private static class DP54SmallLastHandler implements StepHandler {    private static final long serialVersionUID = -8168590945325629799L;    public DP54SmallLastHandler(double minStep) {      lastSeen = false;      this.minStep = minStep;    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {    }    public void handleStep(StepInterpolator interpolator, boolean isLast) {      if (isLast) {        lastSeen = true;        double h = interpolator.getCurrentTime() - interpolator.getPreviousTime();        assertTrue(Math.abs(h) < minStep);      }    }    public boolean wasLastSeen() {      return lastSeen;    }    private boolean lastSeen;    private double  minStep;  }  public void testIncreasingTolerance()    throws DerivativeException, IntegratorException {    int previousCalls = Integer.MAX_VALUE;    for (int i = -12; i < -2; ++i) {      TestProblem1 pb = new TestProblem1();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = Math.pow(10.0, i);      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      EmbeddedRungeKuttaIntegrator integ =          new DormandPrince54Integrator(minStep, maxStep,                                        scalAbsoluteTolerance, scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.setSafety(0.8);      integ.setMaxGrowth(5.0);      integ.setMinReduction(0.3);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertEquals(0.8, integ.getSafety(), 1.0e-12);      assertEquals(5.0, integ.getMaxGrowth(), 1.0e-12);      assertEquals(0.3, integ.getMinReduction(), 1.0e-12);      // the 0.7 factor is only valid for this test      // and has been obtained from trial and error      // there is no general relation between local and global errors      assertTrue(handler.getMaximalValueError() < (0.7 * scalAbsoluteTolerance));      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      int calls = pb.getCalls();      assertEquals(integ.getEvaluations(), calls);      assertTrue(calls <= previousCalls);      previousCalls = calls;    }  }  public void testEvents()    throws DerivativeException, IntegratorException {    TestProblem4 pb = new TestProblem4();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    EventHandler[] functions = pb.getEventsHandlers();    for (int l = 0; l < functions.length; ++l) {      integ.addEventHandler(functions[l],                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);    }    assertEquals(functions.length, integ.getEventHandlers().size());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getMaximalValueError() < 5.0e-6);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);    integ.clearEventHandlers();    assertEquals(0, integ.getEventHandlers().size());  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);    integ.addStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertEquals(integ.getEvaluations(), pb.getCalls());    assertTrue(pb.getCalls() < 2800);  }  public void testVariableSteps()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);    integ.addStepHandler(new VariableHandler());    double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                      pb.getFinalTime(), new double[pb.getDimension()]);    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);  }  private static class KeplerHandler implements StepHandler {    private static final long serialVersionUID = -1645853847806655456L;    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public boolean requiresDenseOutput() {      return true;    }    public void reset() {      nbSteps = 0;      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast)    throws DerivativeException {      ++nbSteps;      for (int a = 1; a < 10; ++a) {        double prev   = interpolator.getPreviousTime();        double curr   = interpolator.getCurrentTime();        double interp = ((10 - a) * prev + a * curr) / 10;        interpolator.setInterpolatedTime(interp);        double[] interpolatedY = interpolator.getInterpolatedState ();        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());        double dx = interpolatedY[0] - theoreticalY[0];        double dy = interpolatedY[1] - theoreticalY[1];        double error = dx * dx + dy * dy;        if (error > maxError) {          maxError = error;        }      }      if (isLast) {        assertTrue(maxError < 7.0e-10);        assertTrue(nbSteps < 400);      }    }    private int nbSteps;    private double maxError;    private TestProblem3 pb;  }  private static class VariableHandler implements StepHandler {    private static final long serialVersionUID = -5196650833828379228L;    public VariableHandler() {      firstTime = true;      minStep = 0;      maxStep = 0;    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      firstTime = true;      minStep = 0;      maxStep = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) {      double step = Math.abs(interpolator.getCurrentTime()                             - interpolator.getPreviousTime());      if (firstTime) {        minStep   = Math.abs(step);        maxStep   = minStep;        firstTime = false;      } else {        if (step < minStep) {          minStep = step;        }        if (step > maxStep) {          maxStep = step;        }      }      if (isLast) {        assertTrue(minStep < (1.0 / 450.0));        assertTrue(maxStep > (1.0 / 4.2));      }    }      private boolean firstTime;    private double  minStep;    private double  maxStep;  }  public static Test suite() {    return new TestSuite(DormandPrince54IntegratorTest.class);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.junit.Test;public class ClassicalRungeKuttaStepInterpolatorTest {  @Test  public void derivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    assertTrue(bos.size () > 700000);    assertTrue(bos.size () < 701000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError > 0.005);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.ODEIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;/** * This class is used to handle steps for the test problems * integrated during the junit tests for the ODE integrators. */class TestProblemHandler  implements StepHandler {  /** Serializable version identifier. */  private static final long serialVersionUID = 3589490480549900461L;  /** Associated problem. */  private TestProblemAbstract problem;  /** Maximal errors encountered during the integration. */  private double maxValueError;  private double maxTimeError;  /** Error at the end of the integration. */  private double lastError;  /** Time at the end of integration. */  private double lastTime;  /** ODE solver used. */  private ODEIntegrator integrator;  /** Expected start for step. */  private double expectedStepStart;  /**   * Simple constructor.   * @param problem problem for which steps should be handled   * @param integrator ODE solver used   */  public TestProblemHandler(TestProblemAbstract problem, ODEIntegrator integrator) {    this.problem = problem;    this.integrator = integrator;    reset();  }  public boolean requiresDenseOutput() {    return true;  }  public void reset() {    maxValueError = 0;    maxTimeError  = 0;    lastError     = 0;    expectedStepStart = Double.NaN;  }  public void handleStep(StepInterpolator interpolator,                         boolean isLast)    throws DerivativeException {    double start = integrator.getCurrentStepStart();    if (Math.abs((start - problem.getInitialTime()) / integrator.getCurrentSignedStepsize()) > 0.001) {        // multistep integrators do not handle the first steps themselves        // so we have to make sure the integrator we look at has really started its work        if (!Double.isNaN(expectedStepStart)) {            maxTimeError = Math.max(maxTimeError, Math.abs(start - expectedStepStart));        }        expectedStepStart = start + integrator.getCurrentSignedStepsize();    }    double pT = interpolator.getPreviousTime();    double cT = interpolator.getCurrentTime();    double[] errorScale = problem.getErrorScale();    // store the error at the last step    if (isLast) {      double[] interpolatedY = interpolator.getInterpolatedState();      double[] theoreticalY  = problem.computeTheoreticalState(cT);      for (int i = 0; i < interpolatedY.length; ++i) {        double error = Math.abs(interpolatedY[i] - theoreticalY[i]);        lastError = Math.max(error, lastError);      }      lastTime = cT;    }    // walk through the step    for (int k = 0; k <= 20; ++k) {      double time = pT + (k * (cT - pT)) / 20;      interpolator.setInterpolatedTime(time);      double[] interpolatedY = interpolator.getInterpolatedState();      double[] theoreticalY  = problem.computeTheoreticalState(interpolator.getInterpolatedTime());      // update the errors      for (int i = 0; i < interpolatedY.length; ++i) {        double error = errorScale[i] * Math.abs(interpolatedY[i] - theoreticalY[i]);        maxValueError = Math.max(error, maxValueError);      }    }  }  /**   * Get the maximal value error encountered during integration.   * @return maximal value error   */  public double getMaximalValueError() {    return maxValueError;  }  /**   * Get the maximal time error encountered during integration.   * @return maximal time error   */  public double getMaximalTimeError() {    return maxTimeError;  }  /**   * Get the error at the end of the integration.   * @return error at the end of the integration   */  public double getLastError() {    return lastError;  }  /**   * Get the time at the end of the integration.   * @return time at the end of the integration.   */  public double getLastTime() {    return lastTime;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;/** * This class is used in the junit tests for the ODE integrators. * <p>This is the same as problem 1 except integration is done * backward in time</p> */public class TestProblem5  extends TestProblem1 {  /** Serializable version identifier. */  private static final long serialVersionUID = 7579233102411804237L;  /**   * Simple constructor.   */  public TestProblem5() {    super();    setFinalConditions(2 * t0 - t1);  } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.junit.Test;public class DormandPrince54StepInterpolatorTest {  @Test  public void derivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3(0.1);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                    scalAbsoluteTolerance,                                                                    scalRelativeTolerance);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                    scalAbsoluteTolerance,                                                                    scalRelativeTolerance);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    assertTrue(bos.size () > 119500);    assertTrue(bos.size () < 120500);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 7.0e-10);  }  @Test  public void checkClone()    throws DerivativeException, IntegratorException {      TestProblem3 pb = new TestProblem3(0.9);      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = scalAbsoluteTolerance;      DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                      scalAbsoluteTolerance,                                                                      scalRelativeTolerance);      integ.addStepHandler(new StepHandler() {        private static final long serialVersionUID = -6768136169276197L;        public void handleStep(StepInterpolator interpolator, boolean isLast)          throws DerivativeException {              StepInterpolator cloned = interpolator.copy();              double tA = cloned.getPreviousTime();              double tB = cloned.getCurrentTime();              double halfStep = Math.abs(tB - tA) / 2;              assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);              assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);              for (int i = 0; i < 10; ++i) {                  double t = (i * tB + (9 - i) * tA) / 9;                  interpolator.setInterpolatedTime(t);                  assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));                  cloned.setInterpolatedTime(t);                  assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);                  double[] referenceState = interpolator.getInterpolatedState();                  double[] cloneState     = cloned.getInterpolatedState();                  for (int j = 0; j < referenceState.length; ++j) {                      assertEquals(referenceState[j], cloneState[j], 1.0e-12);                  }              }          }          public boolean requiresDenseOutput() {              return true;          }          public void reset() {          }      });      integ.integrate(pb,              pb.getInitialTime(), pb.getInitialState(),              pb.getFinalTime(), new double[pb.getDimension()]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.junit.Test;public class AdamsBashforthIntegratorTest {    @Test(expected=IntegratorException.class)    public void dimensionCheck() throws DerivativeException, IntegratorException {        TestProblem1 pb = new TestProblem1();        FirstOrderIntegrator integ =            new AdamsBashforthIntegrator(3, 0.0, 1.0, 1.0e-10, 1.0e-10);        integ.integrate(pb,                        0.0, new double[pb.getDimension()+10],                        1.0, new double[pb.getDimension()+10]);    }    @Test(expected=IntegratorException.class)    public void testMinStep() throws DerivativeException, IntegratorException {          TestProblem1 pb = new TestProblem1();          double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());          double maxStep = pb.getFinalTime() - pb.getInitialTime();          double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };          double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };          FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, minStep, maxStep,                                                                    vecAbsoluteTolerance,                                                                    vecRelativeTolerance);          TestProblemHandler handler = new TestProblemHandler(pb, integ);          integ.addStepHandler(handler);          integ.integrate(pb,                          pb.getInitialTime(), pb.getInitialState(),                          pb.getFinalTime(), new double[pb.getDimension()]);    }    @Test    public void testIncreasingTolerance()        throws DerivativeException, IntegratorException {        int previousCalls = Integer.MAX_VALUE;        for (int i = -12; i < -2; ++i) {            TestProblem1 pb = new TestProblem1();            double minStep = 0;            double maxStep = pb.getFinalTime() - pb.getInitialTime();            double scalAbsoluteTolerance = Math.pow(10.0, i);            double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;            FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, minStep, maxStep,                                                                      scalAbsoluteTolerance,                                                                      scalRelativeTolerance);            TestProblemHandler handler = new TestProblemHandler(pb, integ);            integ.addStepHandler(handler);            integ.integrate(pb,                            pb.getInitialTime(), pb.getInitialState(),                            pb.getFinalTime(), new double[pb.getDimension()]);            // the 28 and 42 factors are only valid for this test            // and has been obtained from trial and error            // there is no general relation between local and global errors            assertTrue(handler.getMaximalValueError() > (28.0 * scalAbsoluteTolerance));            assertTrue(handler.getMaximalValueError() < (42.0 * scalAbsoluteTolerance));            assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);            int calls = pb.getCalls();            assertEquals(integ.getEvaluations(), calls);            assertTrue(calls <= previousCalls);            previousCalls = calls;        }    }    @Test(expected = DerivativeException.class)    public void exceedMaxEvaluations() throws DerivativeException, IntegratorException {        TestProblem1 pb  = new TestProblem1();        double range = pb.getFinalTime() - pb.getInitialTime();        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(3, 0, range, 1.0e-12, 1.0e-12);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        integ.setMaxEvaluations(650);        integ.integrate(pb,                        pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);    }    @Test    public void backward() throws DerivativeException, IntegratorException {        TestProblem5 pb = new TestProblem5();        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());        FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, 0, range, 1.0e-12, 1.0e-12);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        assertTrue(handler.getLastError() < 1.0e-8);        assertTrue(handler.getMaximalValueError() < 1.0e-8);        assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);        assertEquals("Adams-Bashforth", integ.getName());    }    @Test    public void polynomial() throws DerivativeException, IntegratorException {        TestProblem6 pb = new TestProblem6();        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());        for (int order = 2; order < 9; ++order) {            AdamsBashforthIntegrator integ =                new AdamsBashforthIntegrator(order, 1.0e-6 * range, 0.1 * range, 1.0e-10, 1.0e-10);            TestProblemHandler handler = new TestProblemHandler(pb, integ);            integ.addStepHandler(handler);            integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                            pb.getFinalTime(), new double[pb.getDimension()]);            if (order < 5) {                assertTrue(integ.getEvaluations() > 160);            } else {                assertTrue(integ.getEvaluations() < 70);            }        }    }    @Test    public void serialization()        throws IntegratorException, DerivativeException,               IOException, ClassNotFoundException {        TestProblem6 pb = new TestProblem6();        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());        ByteArrayOutputStream bos = new ByteArrayOutputStream();        ObjectOutputStream    oos = new ObjectOutputStream(bos);        oos.writeObject(new AdamsBashforthIntegrator(5, 0, range, 1.0e-12, 1.0e-12));        assertTrue(bos.size() > 2800);        assertTrue(bos.size() < 3000);        ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());        ObjectInputStream     ois = new ObjectInputStream(bis);        FirstOrderIntegrator integ  = (AdamsBashforthIntegrator) ois.readObject();        assertEquals("Adams-Bashforth", integ.getName());        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        assertTrue(handler.getMaximalValueError() < 2.0e-11);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.junit.Test;public class EulerStepInterpolatorTest {  @Test  public void noReset() throws DerivativeException {    double[]   y    =   { 0.0, 1.0, -2.0 };    double[][] yDot = { { 1.0, 2.0, -2.0 } };    EulerStepInterpolator interpolator = new EulerStepInterpolator();    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    double[] result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);    }  }  @Test  public void interpolationAtBounds()    throws DerivativeException {    double   t0 = 0;    double[] y0 = {0.0, 1.0, -2.0};    double[] y = y0.clone();    double[][] yDot = { new double[y0.length] };    EulerStepInterpolator interpolator = new EulerStepInterpolator();    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);    interpolator.storeTime(t0);    double dt = 1.0;    y[0] =  1.0;    y[1] =  3.0;    y[2] = -4.0;    yDot[0][0] = (y[0] - y0[0]) / dt;    yDot[0][1] = (y[1] - y0[1]) / dt;    yDot[0][2] = (y[2] - y0[2]) / dt;    interpolator.shift();    interpolator.storeTime(t0 + dt);    interpolator.setInterpolatedTime(interpolator.getPreviousTime());    double[] result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {      assertTrue(Math.abs(result[i] - y0[i]) < 1.0e-10);    }    interpolator.setInterpolatedTime(interpolator.getCurrentTime());    result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);    }  }  @Test  public void interpolationInside()  throws DerivativeException {    double[]   y    =   { 1.0, 3.0, -4.0 };    double[][] yDot = { { 1.0, 2.0, -2.0 } };    EulerStepInterpolator interpolator = new EulerStepInterpolator();    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    interpolator.setInterpolatedTime(0.1);    double[] result = interpolator.getInterpolatedState();    assertTrue(Math.abs(result[0] - 0.1) < 1.0e-10);    assertTrue(Math.abs(result[1] - 1.2) < 1.0e-10);    assertTrue(Math.abs(result[2] + 2.2) < 1.0e-10);    interpolator.setInterpolatedTime(0.5);    result = interpolator.getInterpolatedState();    assertTrue(Math.abs(result[0] - 0.5) < 1.0e-10);    assertTrue(Math.abs(result[1] - 2.0) < 1.0e-10);    assertTrue(Math.abs(result[2] + 3.0) < 1.0e-10);  }  @Test  public void derivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    EulerIntegrator integ = new EulerIntegrator(step);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    EulerIntegrator integ = new EulerIntegrator(step);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }        ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 0.001);  }  private static class DummyIntegrator extends RungeKuttaIntegrator {            protected DummyIntegrator(RungeKuttaStepInterpolator prototype) {          super("dummy", new double[0], new double[0][0], new double[0], prototype, Double.NaN);      }  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import junit.framework.*;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;public class ClassicalRungeKuttaIntegratorTest  extends TestCase {  public ClassicalRungeKuttaIntegratorTest(String name) {    super(name);  }  public void testSanityChecks() {    try  {      TestProblem1 pb = new TestProblem1();      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,                                                        0.0, new double[pb.getDimension()+10],                                                        1.0, new double[pb.getDimension()]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }    try  {        TestProblem1 pb = new TestProblem1();        new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,                                                          0.0, new double[pb.getDimension()],                                                          1.0, new double[pb.getDimension()+10]);          fail("an exception should have been thrown");      } catch(DerivativeException de) {        fail("wrong exception caught");      } catch(IntegratorException ie) {      }    try  {      TestProblem1 pb = new TestProblem1();      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,                                                        0.0, new double[pb.getDimension()],                                                        0.0, new double[pb.getDimension()]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }    public void testDecreasingSteps()    throws DerivativeException, IntegratorException  {          TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousError = Double.NaN;      for (int i = 4; i < 10; ++i) {        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();        double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);        FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        EventHandler[] functions = pb.getEventsHandlers();        for (int l = 0; l < functions.length; ++l) {          integ.addEventHandler(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);        }        assertEquals(functions.length, integ.getEventHandlers().size());        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                          pb.getFinalTime(), new double[pb.getDimension()]);        if (functions.length == 0) {            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);        }        double error = handler.getMaximalValueError();        if (i > 4) {          assertTrue(error < Math.abs(previousError));        }        previousError = error;        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);        integ.clearEventHandlers();        assertEquals(0, integ.getEventHandlers().size());      }    }  }  public void testSmallStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() < 2.0e-13);    assertTrue(handler.getMaximalValueError() < 4.0e-12);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals("classical Runge-Kutta", integ.getName());  }  public void testBigStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() > 0.0004);    assertTrue(handler.getMaximalValueError() > 0.005);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);  }  public void testBackward()    throws DerivativeException, IntegratorException {    TestProblem5 pb = new TestProblem5();    double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() < 5.0e-10);    assertTrue(handler.getMaximalValueError() < 7.0e-10);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals("classical Runge-Kutta", integ.getName());  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    integ.addStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);  }  private static class KeplerHandler implements StepHandler {    private static final long serialVersionUID = 7510061424396717277L;    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) throws DerivativeException {      double[] interpolatedY = interpolator.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }      if (isLast) {        // even with more than 1000 evaluations per period,        // RK4 is not able to integrate such an eccentric        // orbit with a good accuracy        assertTrue(maxError > 0.005);      }    }    private double maxError = 0;    private TestProblem3 pb;  }  public void testStepSize()    throws DerivativeException, IntegratorException {      final double step = 1.23456;      FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);      integ.addStepHandler(new StepHandler() {          private static final long serialVersionUID = 0L;          public void handleStep(StepInterpolator interpolator, boolean isLast) {              if (! isLast) {                  assertEquals(step,                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),                               1.0e-12);              }          }          public boolean requiresDenseOutput() {              return false;          }          public void reset() {          }                });      integ.integrate(new FirstOrderDifferentialEquations() {          private static final long serialVersionUID = 0L;          public void computeDerivatives(double t, double[] y, double[] dot) {              dot[0] = 1.0;          }          public int getDimension() {              return 1;          }      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);  }  public static Test suite() {    return new TestSuite(ClassicalRungeKuttaIntegratorTest.class);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.junit.Test;public class MidpointStepInterpolatorTest {  @Test  public void testDerivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    MidpointIntegrator integ = new MidpointIntegrator(step);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    MidpointIntegrator integ = new MidpointIntegrator(step);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    assertTrue(bos.size () > 98000);    assertTrue(bos.size () < 99000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 1.0e-6);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.events.EventHandler;/** * This class is used as the base class of the problems that are * integrated during the junit tests for the ODE integrators. */public abstract class TestProblemAbstract  implements FirstOrderDifferentialEquations, Cloneable {  /** Serializable version identifier. */  private static final long serialVersionUID = -8521928974502839379L;  /** Dimension of the problem. */  protected int n;  /** Number of functions calls. */  protected int calls;  /** Initial time */  protected double t0;  /** Initial state */  protected double[] y0;  /** Final time */  protected double t1;  /** Error scale */  protected double[] errorScale;  /**   * Simple constructor.   */  protected TestProblemAbstract() {    n          = 0;    calls      = 0;    t0         = 0;    y0         = null;    t1         = 0;    errorScale = null;  }  /**   * Copy constructor.   * @param problem problem to copy   */  protected TestProblemAbstract(TestProblemAbstract problem) {    n     = problem.n;    calls = problem.calls;    t0    = problem.t0;    if (problem.y0 == null) {      y0 = null;    } else {      y0 = problem.y0.clone();    }    if (problem.errorScale == null) {      errorScale = null;    } else {      errorScale = problem.errorScale.clone();    }    t1 = problem.t1;  }  /**   * Clone operation.   * @return a copy of the instance   */  @Override  public abstract Object clone();  /**   * Set the initial conditions   * @param t0 initial time   * @param y0 initial state vector   */  protected void setInitialConditions(double t0, double[] y0) {    calls     = 0;    n         = y0.length;    this.t0   = t0;    this.y0   = y0.clone();    }  /**   * Set the final conditions.   * @param t1 final time   */  protected void setFinalConditions(double t1) {    this.t1 = t1;  }  /**   * Set the error scale   * @param errorScale error scale   */  protected void setErrorScale(double[] errorScale) {    this.errorScale = errorScale.clone();   }  public int getDimension() {    return n;  }  /**   * Get the initial time.   * @return initial time   */  public double getInitialTime() {    return t0;  }  /**   * Get the initial state vector.   * @return initial state vector   */  public double[] getInitialState() {    return y0;  }  /**   * Get the final time.   * @return final time   */  public double getFinalTime() {    return t1;  }  /**   * Get the error scale.   * @return error scale   */  public double[] getErrorScale() {    return errorScale;  }  /**   * Get the events handlers.   * @return events handlers   */  public EventHandler[] getEventsHandlers() {    return new EventHandler[0];  }  /**   * Get the number of calls.   * @return nuber of calls   */  public int getCalls() {    return calls;  }  public void computeDerivatives(double t, double[] y, double[] yDot) {    ++calls;    doComputeDerivatives(t, y, yDot);  }  abstract public void doComputeDerivatives(double t, double[] y, double[] yDot);  /**   * Compute the theoretical state at the specified time.   * @param t time at which the state is required   * @return state vector at time t   */  abstract public double[] computeTheoreticalState(double t);}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import junit.framework.*;public class GraggBulirschStoerIntegratorTest  extends TestCase {  public GraggBulirschStoerIntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      AdaptiveStepsizeIntegrator integrator =        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()+10],                           1.0, new double[pb.getDimension()+10]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testNullIntervalCheck() {    try  {      TestProblem1 pb = new TestProblem1();      GraggBulirschStoerIntegrator integrator =        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()],                           0.0, new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testMinStep() {    try {      TestProblem5 pb  = new TestProblem5();      double minStep   = 0.1 * Math.abs(pb.getFinalTime() - pb.getInitialTime());      double maxStep   = Math.abs(pb.getFinalTime() - pb.getInitialTime());      double[] vecAbsoluteTolerance = { 1.0e-20, 1.0e-21 };      double[] vecRelativeTolerance = { 1.0e-20, 1.0e-21 };      FirstOrderIntegrator integ =        new GraggBulirschStoerIntegrator(minStep, maxStep,                                         vecAbsoluteTolerance, vecRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testBackward()      throws DerivativeException, IntegratorException {      TestProblem5 pb = new TestProblem5();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,                                                                    scalAbsoluteTolerance,                                                                    scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertTrue(handler.getLastError() < 9.0e-10);      assertTrue(handler.getMaximalValueError() < 9.0e-10);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      assertEquals("Gragg-Bulirsch-Stoer", integ.getName());  }  public void testIncreasingTolerance()    throws DerivativeException, IntegratorException {    int previousCalls = Integer.MAX_VALUE;    for (int i = -12; i < -4; ++i) {      TestProblem1 pb     = new TestProblem1();      double minStep      = 0;      double maxStep      = pb.getFinalTime() - pb.getInitialTime();      double absTolerance = Math.pow(10.0, i);      double relTolerance = absTolerance;      FirstOrderIntegrator integ =        new GraggBulirschStoerIntegrator(minStep, maxStep,                                         absTolerance, relTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      // the coefficients are only valid for this test      // and have been obtained from trial and error      // there is no general relation between local and global errors      double ratio =  handler.getMaximalValueError() / absTolerance;      assertTrue(ratio < 2.4);      assertTrue(ratio > 0.02);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      int calls = pb.getCalls();      assertEquals(integ.getEvaluations(), calls);      assertTrue(calls <= previousCalls);      previousCalls = calls;    }  }  public void testIntegratorControls()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3(0.999);    GraggBulirschStoerIntegrator integ =        new GraggBulirschStoerIntegrator(0, pb.getFinalTime() - pb.getInitialTime(),                1.0e-8, 1.0e-10);    double errorWithDefaultSettings = getMaxError(integ, pb);    // stability control    integ.setStabilityCheck(true, 2, 1, 0.99);    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));    integ.setStabilityCheck(true, -1, -1, -1);    integ.setStepsizeControl(0.5, 0.99, 0.1, 2.5);    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));    integ.setStepsizeControl(-1, -1, -1, -1);    integ.setOrderControl(10, 0.7, 0.95);    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));    integ.setOrderControl(-1, -1, -1);    integ.setInterpolationControl(true, 3);    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));    integ.setInterpolationControl(true, -1);  }  private double getMaxError(FirstOrderIntegrator integrator, TestProblemAbstract pb)    throws DerivativeException, IntegratorException {      TestProblemHandler handler = new TestProblemHandler(pb, integrator);      integrator.addStepHandler(handler);      integrator.integrate(pb,                           pb.getInitialTime(), pb.getInitialState(),                           pb.getFinalTime(), new double[pb.getDimension()]);      return handler.getMaximalValueError();  }  public void testEvents()    throws DerivativeException, IntegratorException {    TestProblem4 pb = new TestProblem4();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-10;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,                                                                  scalAbsoluteTolerance,                                                                  scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    EventHandler[] functions = pb.getEventsHandlers();    for (int l = 0; l < functions.length; ++l) {      integ.addEventHandler(functions[l],                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);    }    assertEquals(functions.length, integ.getEventHandlers().size());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getMaximalValueError() < 5.0e-8);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);    integ.clearEventHandlers();    assertEquals(0, integ.getEventHandlers().size());  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb = new TestProblem3(0.9);    double minStep        = 0;    double maxStep        = pb.getFinalTime() - pb.getInitialTime();    double absTolerance   = 1.0e-6;    double relTolerance   = 1.0e-6;    FirstOrderIntegrator integ =      new GraggBulirschStoerIntegrator(minStep, maxStep,                                       absTolerance, relTolerance);    integ.addStepHandler(new KeplerStepHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertEquals(integ.getEvaluations(), pb.getCalls());    assertTrue(pb.getCalls() < 2150);  }  public void testVariableSteps()    throws DerivativeException, IntegratorException {    final TestProblem3 pb = new TestProblem3(0.9);    double minStep        = 0;    double maxStep        = pb.getFinalTime() - pb.getInitialTime();    double absTolerance   = 1.0e-8;    double relTolerance   = 1.0e-8;    FirstOrderIntegrator integ =      new GraggBulirschStoerIntegrator(minStep, maxStep,                                       absTolerance, relTolerance);    integ.addStepHandler(new VariableStepHandler());    double stopTime = integ.integrate(pb,                                      pb.getInitialTime(), pb.getInitialState(),                                      pb.getFinalTime(), new double[pb.getDimension()]);    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);    assertEquals("Gragg-Bulirsch-Stoer", integ.getName());  }  public void testUnstableDerivative()    throws DerivativeException, IntegratorException {    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);    FirstOrderIntegrator integ =      new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0);    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);    double[] y = { Double.NaN };    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);    assertEquals(8.0, y[0], 1.0e-12);  }  private static class KeplerStepHandler implements StepHandler {    private static final long serialVersionUID = -8231434585284002546L;    public KeplerStepHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public boolean requiresDenseOutput() {      return true;    }    public void reset() {      nbSteps = 0;      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast)    throws DerivativeException {      ++nbSteps;      for (int a = 1; a < 100; ++a) {        double prev   = interpolator.getPreviousTime();        double curr   = interpolator.getCurrentTime();        double interp = ((100 - a) * prev + a * curr) / 100;        interpolator.setInterpolatedTime(interp);        double[] interpolatedY = interpolator.getInterpolatedState ();        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());        double dx = interpolatedY[0] - theoreticalY[0];        double dy = interpolatedY[1] - theoreticalY[1];        double error = dx * dx + dy * dy;        if (error > maxError) {          maxError = error;        }      }      if (isLast) {        assertTrue(maxError < 2.7e-6);        assertTrue(nbSteps < 80);      }    }    private int nbSteps;    private double maxError;    private TestProblem3 pb;  }  public static class VariableStepHandler implements StepHandler {    private static final long serialVersionUID = -5955452449048688985L;    public VariableStepHandler() {      reset();    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      firstTime = true;      minStep = 0;      maxStep = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) {      double step = Math.abs(interpolator.getCurrentTime()                             - interpolator.getPreviousTime());      if (firstTime) {        minStep   = Math.abs(step);        maxStep   = minStep;        firstTime = false;      } else {        if (step < minStep) {          minStep = step;        }        if (step > maxStep) {          maxStep = step;        }      }      if (isLast) {        assertTrue(minStep < 8.2e-3);        assertTrue(maxStep > 1.7);      }    }    private boolean firstTime;    private double  minStep;    private double  maxStep;  }  public static Test suite() {    return new TestSuite(GraggBulirschStoerIntegratorTest.class);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.junit.Test;public class GraggBulirschStoerStepInterpolatorTest {  @Test  public void derivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep   = 0;    double maxStep   = pb.getFinalTime() - pb.getInitialTime();    double absTolerance = 1.0e-8;    double relTolerance = 1.0e-8;    GraggBulirschStoerIntegrator integ =      new GraggBulirschStoerIntegrator(minStep, maxStep,                                       absTolerance, relTolerance);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-8);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb  = new TestProblem3(0.9);    double minStep   = 0;    double maxStep   = pb.getFinalTime() - pb.getInitialTime();    double absTolerance = 1.0e-8;    double relTolerance = 1.0e-8;    GraggBulirschStoerIntegrator integ =      new GraggBulirschStoerIntegrator(minStep, maxStep,                                       absTolerance, relTolerance);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    assertTrue(bos.size () > 34000);    assertTrue(bos.size () < 35000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 5.0e-11);  }  @Test  public void checklone()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,                                                                          scalAbsoluteTolerance,                                                                          scalRelativeTolerance);    integ.addStepHandler(new StepHandler() {        private static final long serialVersionUID = -5947183291381232297L;        public void handleStep(StepInterpolator interpolator, boolean isLast)        throws DerivativeException {            StepInterpolator cloned = interpolator.copy();            double tA = cloned.getPreviousTime();            double tB = cloned.getCurrentTime();            double halfStep = Math.abs(tB - tA) / 2;            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);            for (int i = 0; i < 10; ++i) {                double t = (i * tB + (9 - i) * tA) / 9;                interpolator.setInterpolatedTime(t);                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));                cloned.setInterpolatedTime(t);                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);                double[] referenceState = interpolator.getInterpolatedState();                double[] cloneState     = cloned.getInterpolatedState();                for (int j = 0; j < referenceState.length; ++j) {                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);                }            }        }        public boolean requiresDenseOutput() {            return true;        }        public void reset() {        }    });    integ.integrate(pb,            pb.getInitialTime(), pb.getInitialState(),            pb.getFinalTime(), new double[pb.getDimension()]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertTrue;import java.util.Random;import java.io.ByteArrayOutputStream;import java.io.ByteArrayInputStream;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.IOException;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.nonstiff.GillIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.junit.Test;public class GillStepInterpolatorTest {  @Test  public void testDerivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    GillIntegrator integ = new GillIntegrator(step);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    GillIntegrator integ = new GillIntegrator(step);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    assertTrue(bos.size () > 700000);    assertTrue(bos.size () < 701000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 0.003);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.junit.Test;public class ThreeEighthesStepInterpolatorTest {  @Test  public void derivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    assertTrue(bos.size () > 700000);    assertTrue(bos.size () < 701000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError > 0.005);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    y' = t^3 - t y * </pre> * with the initial condition y (0) = 0. The solution of this equation * is the following function : * <pre> *   y (t) = t^2 + 2 (exp (- t^2 / 2) - 1) * </pre> * </p> */public class TestProblem2  extends TestProblemAbstract {  /** Serializable version identifier. */  private static final long serialVersionUID = 8330741783213512366L;  /** theoretical state */  private double[] y;  /**   * Simple constructor.   */  public TestProblem2() {    super();    double[] y0 = { 0.0 };    setInitialConditions(0.0, y0);    setFinalConditions(1.0);    double[] errorScale = { 1.0 };    setErrorScale(errorScale);    y = new double[y0.length];  }   /**   * Copy constructor.   * @param problem problem to copy   */  public TestProblem2(TestProblem2 problem) {    super(problem);    y = problem.y.clone();  }  /**   * Clone operation.   * @return a copy of the instance   */  @Override  public Object clone() {    return new TestProblem2(this);  }  @Override  public void doComputeDerivatives(double t, double[] y, double[] yDot) {    // compute the derivatives    for (int i = 0; i < n; ++i)      yDot[i] = t * (t * t - y[i]);  }  @Override  public double[] computeTheoreticalState(double t) {    double t2 = t * t;    double c = t2 + 2 * (Math.exp (-0.5 * t2) - 1);    for (int i = 0; i < n; ++i) {      y[i] = c;    }    return y;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import junit.framework.*;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;public class ThreeEighthesIntegratorTest  extends TestCase {  public ThreeEighthesIntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      new ThreeEighthesIntegrator(0.01).integrate(pb,                                                  0.0, new double[pb.getDimension()+10],                                                  1.0, new double[pb.getDimension()+10]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }    public void testDecreasingSteps()    throws DerivativeException, IntegratorException  {          TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {          double previousError = Double.NaN;      for (int i = 4; i < 10; ++i) {        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();        double step = (pb.getFinalTime() - pb.getInitialTime())          * Math.pow(2.0, -i);        FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        EventHandler[] functions = pb.getEventsHandlers();        for (int l = 0; l < functions.length; ++l) {          integ.addEventHandler(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);        }        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                          pb.getFinalTime(), new double[pb.getDimension()]);        if (functions.length == 0) {            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);        }        double error = handler.getMaximalValueError();        if (i > 4) {          assertTrue(error < Math.abs(previousError));        }        previousError = error;        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      }    }  } public void testSmallStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() < 2.0e-13);    assertTrue(handler.getMaximalValueError() < 4.0e-12);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals("3/8", integ.getName());  }  public void testBigStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() > 0.0004);    assertTrue(handler.getMaximalValueError() > 0.005);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);  }  public void testBackward()      throws DerivativeException, IntegratorException {      TestProblem5 pb = new TestProblem5();      double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertTrue(handler.getLastError() < 5.0e-10);      assertTrue(handler.getMaximalValueError() < 7.0e-10);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      assertEquals("3/8", integ.getName());  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);    integ.addStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);  }  private static class KeplerHandler implements StepHandler {    private static final long serialVersionUID = 4400497468419540899L;    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      maxError = 0;    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) throws DerivativeException {      double[] interpolatedY = interpolator.getInterpolatedState();      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }      if (isLast) {        // even with more than 1000 evaluations per period,        // RK4 is not able to integrate such an eccentric        // orbit with a good accuracy        assertTrue(maxError > 0.005);      }    }    private TestProblem3 pb;    private double maxError = 0;  }  public void testStepSize()    throws DerivativeException, IntegratorException {      final double step = 1.23456;      FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);      integ.addStepHandler(new StepHandler() {          private static final long serialVersionUID = 0L;          public void handleStep(StepInterpolator interpolator, boolean isLast) {              if (! isLast) {                  assertEquals(step,                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),                               1.0e-12);              }          }          public boolean requiresDenseOutput() {              return false;          }          public void reset() {          }                });      integ.integrate(new FirstOrderDifferentialEquations() {          private static final long serialVersionUID = 0L;          public void computeDerivatives(double t, double[] y, double[] dot) {              dot[0] = 1.0;          }          public int getDimension() {              return 1;          }      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);  }  public static Test suite() {    return new TestSuite(ThreeEighthesIntegratorTest.class);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.junit.Test;public class DormandPrince853StepInterpolatorTest {  @Test  public void derivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3(0.1);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                      scalAbsoluteTolerance,                                                                      scalRelativeTolerance);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                      scalAbsoluteTolerance,                                                                      scalRelativeTolerance);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    assertTrue(bos.size () > 86000);    assertTrue(bos.size () < 87000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 2.4e-10);  }  @Test  public void checklone()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                      scalAbsoluteTolerance,                                                                      scalRelativeTolerance);    integ.addStepHandler(new StepHandler() {        private static final long serialVersionUID = 2209212559670665268L;        public void handleStep(StepInterpolator interpolator, boolean isLast)        throws DerivativeException {            StepInterpolator cloned = interpolator.copy();            double tA = cloned.getPreviousTime();            double tB = cloned.getCurrentTime();            double halfStep = Math.abs(tB - tA) / 2;            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);            for (int i = 0; i < 10; ++i) {                double t = (i * tB + (9 - i) * tA) / 9;                interpolator.setInterpolatedTime(t);                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));                cloned.setInterpolatedTime(t);                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);                double[] referenceState = interpolator.getInterpolatedState();                double[] cloneState     = cloned.getInterpolatedState();                for (int j = 0; j < referenceState.length; ++j) {                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);                }            }        }        public boolean requiresDenseOutput() {            return true;        }        public void reset() {        }    });    integ.integrate(pb,            pb.getInitialTime(), pb.getInitialState(),            pb.getFinalTime(), new double[pb.getDimension()]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    y' = 3x^5 - y * </pre> * when the initial condition is y(0) = -360, the solution of this * equation degenerates to a simple quintic polynomial function : * <pre> *   y (t) = 3x^5 - 15x^4 + 60x^3 - 180x^2 + 360x - 360 * </pre> * </p> */public class TestProblem6  extends TestProblemAbstract {    /** Serializable version identifier. */    private static final long serialVersionUID = 1353409119804352378L;    /** theoretical state */    private double[] y;    /**     * Simple constructor.     */    public TestProblem6() {        super();        double[] y0 = { -360.0 };        setInitialConditions(0.0, y0);        setFinalConditions(1.0);        double[] errorScale = { 1.0 };        setErrorScale(errorScale);        y = new double[y0.length];    }    /**     * Copy constructor.     * @param problem problem to copy     */    public TestProblem6(TestProblem6 problem) {        super(problem);        y = problem.y.clone();    }    /**     * Clone operation.     * @return a copy of the instance     */    @Override    public Object clone() {        return new TestProblem6(this);    }    @Override    public void doComputeDerivatives(double t, double[] y, double[] yDot) {        // compute the derivatives        double t2 = t  * t;        double t4 = t2 * t2;        double t5 = t4 * t;        for (int i = 0; i < n; ++i) {            yDot[i] = 3 * t5 - y[i];        }    }    @Override    public double[] computeTheoreticalState(double t) {        for (int i = 0; i < n; ++i) {            y[i] = ((((3 * t - 15) * t + 60) * t - 180) * t + 360) * t - 360;        }        return y;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import junit.framework.*;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.nonstiff.EulerIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;public class EulerIntegratorTest  extends TestCase {  public EulerIntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      new EulerIntegrator(0.01).integrate(pb,                                          0.0, new double[pb.getDimension()+10],                                          1.0, new double[pb.getDimension()+10]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }    public void testDecreasingSteps()    throws DerivativeException, IntegratorException {    TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousError = Double.NaN;      for (int i = 4; i < 10; ++i) {        TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();        double step = (pb.getFinalTime() - pb.getInitialTime())          * Math.pow(2.0, -i);        FirstOrderIntegrator integ = new EulerIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        EventHandler[] functions = pb.getEventsHandlers();        for (int l = 0; l < functions.length; ++l) {          integ.addEventHandler(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);        }        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                          pb.getFinalTime(), new double[pb.getDimension()]);        if (functions.length == 0) {            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);        }        double error = handler.getMaximalValueError();        if (i > 4) {          assertTrue(error < Math.abs(previousError));        }        previousError = error;        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      }    }  }  public void testSmallStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb  = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new EulerIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);   assertTrue(handler.getLastError() < 2.0e-4);   assertTrue(handler.getMaximalValueError() < 1.0e-3);   assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);   assertEquals("Euler", integ.getName());  }  public void testBigStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb  = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new EulerIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() > 0.01);    assertTrue(handler.getMaximalValueError() > 0.2);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);  }  public void testBackward()      throws DerivativeException, IntegratorException {      TestProblem5 pb = new TestProblem5();      double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new EulerIntegrator(step);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertTrue(handler.getLastError() < 0.45);      assertTrue(handler.getMaximalValueError() < 0.45);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      assertEquals("Euler", integ.getName());  }  public void testStepSize()    throws DerivativeException, IntegratorException {      final double step = 1.23456;      FirstOrderIntegrator integ = new EulerIntegrator(step);      integ.addStepHandler(new StepHandler() {        private static final long serialVersionUID = 0L;        public void handleStep(StepInterpolator interpolator, boolean isLast) {            if (! isLast) {                assertEquals(step,                             interpolator.getCurrentTime() - interpolator.getPreviousTime(),                             1.0e-12);            }        }        public boolean requiresDenseOutput() {            return false;        }        public void reset() {        }                });      integ.integrate(new FirstOrderDifferentialEquations() {                          private static final long serialVersionUID = 0L;                          public void computeDerivatives(double t, double[] y, double[] dot) {                              dot[0] = 1.0;                          }                          public int getDimension() {                              return 1;                          }                      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);  }  public static Test suite() {    return new TestSuite(EulerIntegratorTest.class);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.ode.events.EventHandler;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    x'' = -x * </pre> * And when x decreases down to 0, the state should be changed as follows : * <pre> *   x' -> -x' * </pre> * The theoretical solution of this problem is x = |sin(t+a)| * </p> */public class TestProblem4  extends TestProblemAbstract {  /** Serializable version identifier. */  private static final long serialVersionUID = -5910438521889015745L;  /** Time offset. */  private double a;  /** theoretical state */  private double[] y;  /** Simple constructor. */  public TestProblem4() {    super();    a = 1.2;    double[] y0 = { Math.sin(a), Math.cos(a) };    setInitialConditions(0.0, y0);    setFinalConditions(15);    double[] errorScale = { 1.0, 0.0 };    setErrorScale(errorScale);    y = new double[y0.length];  }   /**   * Copy constructor.   * @param problem problem to copy   */  public TestProblem4(TestProblem4 problem) {    super(problem);    a = problem.a;    y = problem.y.clone();  }  /**   * Clone operation.   * @return a copy of the instance   */  @Override  public Object clone() {    return new TestProblem4(this);  }  @Override  public EventHandler[] getEventsHandlers() {    return new EventHandler[] { new Bounce(), new Stop() };  }  @Override  public void doComputeDerivatives(double t, double[] y, double[] yDot) {    yDot[0] =  y[1];    yDot[1] = -y[0];  }  @Override  public double[] computeTheoreticalState(double t) {    double sin = Math.sin(t + a);    double cos = Math.cos(t + a);    y[0] = Math.abs(sin);    y[1] = (sin >= 0) ? cos : -cos;    return y;  }  private static class Bounce implements EventHandler {    private static final long serialVersionUID = 1356097180027801200L;    private int sign;    public Bounce() {      sign = +1;    }    public double g(double t, double[] y) {      return sign * y[0];    }    public int eventOccurred(double t, double[] y, boolean increasing) {      // this sign change is needed because the state will be reset soon      sign = -sign;      return EventHandler.RESET_STATE;    }      public void resetState(double t, double[] y) {      y[0] = -y[0];      y[1] = -y[1];    }  }  private static class Stop implements EventHandler {    private static final long serialVersionUID = 6975050568227951931L;    public Stop() {    }    public double g(double t, double[] y) {      return t - 12.0;    }    public int eventOccurred(double t, double[] y, boolean increasing) {      return EventHandler.STOP;    }      public void resetState(double t, double[] y) {    }  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    y1'' = -y1/r^3  y1 (0) = 1-e  y1' (0) = 0 *    y2'' = -y2/r^3  y2 (0) = 0    y2' (0) =sqrt((1+e)/(1-e)) *    r = sqrt (y1^2 + y2^2), e = 0.9 * </pre> * This is a two-body problem in the plane which can be solved by * Kepler's equation * <pre> *   y1 (t) = ... * </pre> * </p> */public class TestProblem3  extends TestProblemAbstract {  /** Serializable version identifier. */  private static final long serialVersionUID = 8567328542728919999L;  /** Eccentricity */  double e;  /** theoretical state */  private double[] y;  /**   * Simple constructor.   * @param e eccentricity   */  public TestProblem3(double e) {    super();    this.e = e;    double[] y0 = { 1 - e, 0, 0, Math.sqrt((1+e)/(1-e)) };    setInitialConditions(0.0, y0);    setFinalConditions(20.0);    double[] errorScale = { 1.0, 1.0, 1.0, 1.0 };    setErrorScale(errorScale);    y = new double[y0.length];  }   /**   * Simple constructor.   */  public TestProblem3() {    this(0.1);  }   /**   * Copy constructor.   * @param problem problem to copy   */  public TestProblem3(TestProblem3 problem) {    super(problem);    e = problem.e;    y = problem.y.clone();  }  /**   * Clone operation.   * @return a copy of the instance   */  @Override  public Object clone() {    return new TestProblem3(this);  }  @Override  public void doComputeDerivatives(double t, double[] y, double[] yDot) {    // current radius    double r2 = y[0] * y[0] + y[1] * y[1];    double invR3 = 1 / (r2 * Math.sqrt(r2));    // compute the derivatives    yDot[0] = y[2];    yDot[1] = y[3];    yDot[2] = -invR3  * y[0];    yDot[3] = -invR3  * y[1];  }  @Override  public double[] computeTheoreticalState(double t) {    // solve Kepler's equation    double E = t;    double d = 0;    double corr = 0;    do {      double f2  = e * Math.sin(E);      double f0  = d - f2;      double f1  = 1 - e * Math.cos(E);      double f12 = f1 + f1;      corr  = f0 * f12 / (f1 * f12 - f0 * f2);      d -= corr;      E = t + d;    } while (Math.abs(corr) > 1.0e-12);    double cosE = Math.cos(E);    double sinE = Math.sin(E);    y[0] = cosE - e;    y[1] = Math.sqrt(1 - e * e) * sinE;    y[2] = -sinE / (1 - e * cosE);    y[3] = Math.sqrt(1 - e * e) * cosE / (1 - e * cosE);    return y;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import junit.framework.*;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.nonstiff.GillIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;public class GillIntegratorTest  extends TestCase {  public GillIntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      new GillIntegrator(0.01).integrate(pb,                                         0.0, new double[pb.getDimension()+10],                                         1.0, new double[pb.getDimension()+10]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }    public void testDecreasingSteps()    throws DerivativeException, IntegratorException  {          TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousError = Double.NaN;      for (int i = 5; i < 10; ++i) {        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();        double step = (pb.getFinalTime() - pb.getInitialTime())          * Math.pow(2.0, -i);        FirstOrderIntegrator integ = new GillIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        EventHandler[] functions = pb.getEventsHandlers();        for (int l = 0; l < functions.length; ++l) {          integ.addEventHandler(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);        }        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                          pb.getFinalTime(), new double[pb.getDimension()]);        if (functions.length == 0) {            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);        }        double error = handler.getMaximalValueError();        if (i > 5) {          assertTrue(error < Math.abs(previousError));        }        previousError = error;        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      }    }  }  public void testSmallStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new GillIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() < 2.0e-13);    assertTrue(handler.getMaximalValueError() < 4.0e-12);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals("Gill", integ.getName());  }  public void testBigStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new GillIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() > 0.0004);    assertTrue(handler.getMaximalValueError() > 0.005);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);  }  public void testBackward()      throws DerivativeException, IntegratorException {      TestProblem5 pb = new TestProblem5();      double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new GillIntegrator(step);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertTrue(handler.getLastError() < 5.0e-10);      assertTrue(handler.getMaximalValueError() < 7.0e-10);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      assertEquals("Gill", integ.getName());  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    FirstOrderIntegrator integ = new GillIntegrator(step);    integ.addStepHandler(new KeplerStepHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);  }  public void testUnstableDerivative()  throws DerivativeException, IntegratorException {    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);    FirstOrderIntegrator integ = new GillIntegrator(0.3);    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);    double[] y = { Double.NaN };    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);    assertEquals(8.0, y[0], 1.0e-12);  }  private static class KeplerStepHandler implements StepHandler {    private static final long serialVersionUID = 1250933165809631538L;    public KeplerStepHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) throws DerivativeException {      double[] interpolatedY = interpolator.getInterpolatedState();      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }      if (isLast) {        // even with more than 1000 evaluations per period,        // RK4 is not able to integrate such an eccentric        // orbit with a good accuracy        assertTrue(maxError > 0.001);      }    }    private double maxError;    private TestProblem3 pb;  }  public void testStepSize()    throws DerivativeException, IntegratorException {      final double step = 1.23456;      FirstOrderIntegrator integ = new GillIntegrator(step);      integ.addStepHandler(new StepHandler() {          private static final long serialVersionUID = 0L;          public void handleStep(StepInterpolator interpolator, boolean isLast) {              if (! isLast) {                  assertEquals(step,                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),                               1.0e-12);              }          }          public boolean requiresDenseOutput() {              return false;          }          public void reset() {          }                });      integ.integrate(new FirstOrderDifferentialEquations() {          private static final long serialVersionUID = 0L;          public void computeDerivatives(double t, double[] y, double[] dot) {              dot[0] = 1.0;          }          public int getDimension() {              return 1;          }      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);  }  public static Test suite() {    return new TestSuite(GillIntegratorTest.class);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.junit.Test;public class AdamsMoultonIntegratorTest {    @Test(expected=IntegratorException.class)    public void dimensionCheck() throws DerivativeException, IntegratorException {        TestProblem1 pb = new TestProblem1();        FirstOrderIntegrator integ =            new AdamsMoultonIntegrator(3, 0.0, 1.0, 1.0e-10, 1.0e-10);        integ.integrate(pb,                        0.0, new double[pb.getDimension()+10],                        1.0, new double[pb.getDimension()+10]);    }    @Test(expected=IntegratorException.class)    public void testMinStep() throws DerivativeException, IntegratorException {          TestProblem1 pb = new TestProblem1();          double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());          double maxStep = pb.getFinalTime() - pb.getInitialTime();          double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };          double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };          FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, minStep, maxStep,                                                                    vecAbsoluteTolerance,                                                                    vecRelativeTolerance);          TestProblemHandler handler = new TestProblemHandler(pb, integ);          integ.addStepHandler(handler);          integ.integrate(pb,                          pb.getInitialTime(), pb.getInitialState(),                          pb.getFinalTime(), new double[pb.getDimension()]);    }    @Test    public void testIncreasingTolerance()        throws DerivativeException, IntegratorException {        int previousCalls = Integer.MAX_VALUE;        for (int i = -12; i < -2; ++i) {            TestProblem1 pb = new TestProblem1();            double minStep = 0;            double maxStep = pb.getFinalTime() - pb.getInitialTime();            double scalAbsoluteTolerance = Math.pow(10.0, i);            double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;            FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, minStep, maxStep,                                                                      scalAbsoluteTolerance,                                                                      scalRelativeTolerance);            TestProblemHandler handler = new TestProblemHandler(pb, integ);            integ.addStepHandler(handler);            integ.integrate(pb,                            pb.getInitialTime(), pb.getInitialState(),                            pb.getFinalTime(), new double[pb.getDimension()]);            // the 0.4 and 3.0 factors are only valid for this test            // and has been obtained from trial and error            // there is no general relation between local and global errors            assertTrue(handler.getMaximalValueError() > (0.4 * scalAbsoluteTolerance));            assertTrue(handler.getMaximalValueError() < (3.0 * scalAbsoluteTolerance));            assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);            int calls = pb.getCalls();            assertEquals(integ.getEvaluations(), calls);            assertTrue(calls <= previousCalls);            previousCalls = calls;        }    }    @Test(expected = DerivativeException.class)    public void exceedMaxEvaluations() throws DerivativeException, IntegratorException {        TestProblem1 pb  = new TestProblem1();        double range = pb.getFinalTime() - pb.getInitialTime();        AdamsMoultonIntegrator integ = new AdamsMoultonIntegrator(3, 0, range, 1.0e-12, 1.0e-12);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        integ.setMaxEvaluations(650);        integ.integrate(pb,                        pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);    }    @Test    public void backward() throws DerivativeException, IntegratorException {        TestProblem5 pb = new TestProblem5();        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());        FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, 0, range, 1.0e-12, 1.0e-12);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        assertTrue(handler.getLastError() < 1.0e-9);        assertTrue(handler.getMaximalValueError() < 1.0e-9);        assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);        assertEquals("Adams-Moulton", integ.getName());    }    @Test    public void polynomial() throws DerivativeException, IntegratorException {        TestProblem6 pb = new TestProblem6();        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());        for (int order = 2; order < 8; ++order) {            AdamsMoultonIntegrator integ =                new AdamsMoultonIntegrator(order, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);            TestProblemHandler handler = new TestProblemHandler(pb, integ);            integ.addStepHandler(handler);            integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                            pb.getFinalTime(), new double[pb.getDimension()]);            if (order < 5) {                assertTrue(integ.getEvaluations() > 150);            } else {                assertTrue(integ.getEvaluations() < 90);            }        }    }    @Test    public void serialization()        throws IntegratorException, DerivativeException,               IOException, ClassNotFoundException {        TestProblem6 pb = new TestProblem6();        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());        ByteArrayOutputStream bos = new ByteArrayOutputStream();        ObjectOutputStream    oos = new ObjectOutputStream(bos);        oos.writeObject(new AdamsMoultonIntegrator(5, 0, range, 1.0e-12, 1.0e-12));        assertTrue(bos.size() > 2800);        assertTrue(bos.size() < 3000);        ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());        ObjectInputStream     ois = new ObjectInputStream(bis);        FirstOrderIntegrator integ  = (AdamsMoultonIntegrator) ois.readObject();        assertEquals("Adams-Moulton", integ.getName());        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        assertTrue(handler.getMaximalValueError() < 8.0e-11);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.junit.Test;public class HighamHall54StepInterpolatorTest {  @Test  public void derivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3(0.1);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    assertTrue(bos.size () > 158000);    assertTrue(bos.size () < 159000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 1.6e-10);  }  @Test  public void checkClone()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);    integ.addStepHandler(new StepHandler() {        private static final long serialVersionUID = 9111679755950880352L;        public void handleStep(StepInterpolator interpolator, boolean isLast)        throws DerivativeException {            StepInterpolator cloned = interpolator.copy();            double tA = cloned.getPreviousTime();            double tB = cloned.getCurrentTime();            double halfStep = Math.abs(tB - tA) / 2;            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);            for (int i = 0; i < 10; ++i) {                double t = (i * tB + (9 - i) * tA) / 9;                interpolator.setInterpolatedTime(t);                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));                cloned.setInterpolatedTime(t);                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);                double[] referenceState = interpolator.getInterpolatedState();                double[] cloneState     = cloned.getInterpolatedState();                for (int j = 0; j < referenceState.length; ++j) {                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);                }            }        }        public boolean requiresDenseOutput() {            return true;        }        public void reset() {        }    });    integ.integrate(pb,            pb.getInitialTime(), pb.getInitialState(),            pb.getFinalTime(), new double[pb.getDimension()]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;/** * This class is used in the junit tests for the ODE integrators. */class TestProblemFactory {  /** Problems pool. */  private static TestProblemAbstract[] pool = {    new TestProblem1(),    new TestProblem2(),    new TestProblem3(),    new TestProblem4(),    new TestProblem5(),    new TestProblem6()  };  /**   * Private constructor.   * This is a utility class, so there are no instance at all.   */  private TestProblemFactory() {  }  /**   * Get the problems.   * @return array of problems to solve   */  public static TestProblemAbstract[] getProblems() {    return pool;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.sampling;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator;import org.apache.commons.math.ode.nonstiff.TestProblem1;import org.apache.commons.math.ode.nonstiff.TestProblem3;import org.junit.Test;public class NordsieckStepInterpolatorTest {    @Test    public void derivativesConsistency()    throws DerivativeException, IntegratorException {        TestProblem3 pb = new TestProblem3();        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(5, 0.0, 1.0, 1.0e-10, 1.0e-10);        StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 7e-10);    }    @Test    public void serialization()    throws DerivativeException, IntegratorException,    IOException, ClassNotFoundException {        TestProblem1 pb = new TestProblem1();        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(5, 0.0, 1.0, 1.0e-10, 1.0e-10);        integ.addStepHandler(new ContinuousOutputModel());        integ.integrate(pb,                        pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        ByteArrayOutputStream bos = new ByteArrayOutputStream();        ObjectOutputStream    oos = new ObjectOutputStream(bos);        for (StepHandler handler : integ.getStepHandlers()) {            oos.writeObject(handler);        }        assertTrue(bos.size () >  16000);        assertTrue(bos.size () <  17000);        ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());        ObjectInputStream     ois = new ObjectInputStream(bis);        ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();        Random random = new Random(347588535632l);        double maxError = 0.0;        for (int i = 0; i < 1000; ++i) {            double r = random.nextDouble();            double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();            cm.setInterpolatedTime(time);            double[] interpolatedY = cm.getInterpolatedState ();            double[] theoreticalY  = pb.computeTheoreticalState(time);            double dx = interpolatedY[0] - theoreticalY[0];            double dy = interpolatedY[1] - theoreticalY[1];            double error = dx * dx + dy * dy;            if (error > maxError) {                maxError = error;            }        }        assertTrue(maxError < 1.0e-6);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.sampling;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;import org.apache.commons.math.ode.nonstiff.TestProblem3;import org.apache.commons.math.ode.sampling.FixedStepHandler;import org.apache.commons.math.ode.sampling.StepNormalizer;import junit.framework.*;public class StepNormalizerTest  extends TestCase {  public StepNormalizerTest(String name) {    super(name);    pb    = null;    integ = null;  }  public void testBoundaries()    throws DerivativeException, IntegratorException {    double range = pb.getFinalTime() - pb.getInitialTime();    setLastSeen(false);    integ.addStepHandler(new StepNormalizer(range / 10.0,                                       new FixedStepHandler() {                                        private static final long serialVersionUID = 1650337364641626444L;                                        private boolean firstCall = true;                                         public void handleStep(double t,                                                                double[] y,                                                                double[] yDot,                                                                boolean isLast) {                                           if (firstCall) {                                             checkValue(t, pb.getInitialTime());                                             firstCall = false;                                           }                                           if (isLast) {                                             setLastSeen(true);                                             checkValue(t, pb.getFinalTime());                                           }                                         }                                       }));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(lastSeen);  }  public void testBeforeEnd()    throws DerivativeException, IntegratorException {    final double range = pb.getFinalTime() - pb.getInitialTime();    setLastSeen(false);    integ.addStepHandler(new StepNormalizer(range / 10.5,                                       new FixedStepHandler() {                                        private static final long serialVersionUID = 2228457391561277298L;                                        public void handleStep(double t,                                                                double[] y,                                                                double[] yDot,                                                                boolean isLast) {                                           if (isLast) {                                             setLastSeen(true);                                             checkValue(t,                                                        pb.getFinalTime() - range / 21.0);                                           }                                         }                                       }));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(lastSeen);  }  public void checkValue(double value, double reference) {    assertTrue(Math.abs(value - reference) < 1.0e-10);  }  public void setLastSeen(boolean lastSeen) {    this.lastSeen = lastSeen;  }  public static Test suite() {    return new TestSuite(StepNormalizerTest.class);  }  @Override  public void setUp() {    pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    integ = new DormandPrince54Integrator(minStep, maxStep, 10.e-8, 1.0e-8);    lastSeen = false;  }  @Override  public void tearDown() {    pb    = null;    integ = null;  }  TestProblem3 pb;  FirstOrderIntegrator integ;  boolean lastSeen;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.sampling;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.ByteArrayOutputStream;import java.io.ByteArrayInputStream;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.IOException;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;import org.apache.commons.math.ode.sampling.DummyStepInterpolator;import org.junit.Test;public class DummyStepInterpolatorTest {  @Test  public void testNoReset() throws DerivativeException {    double[]   y    =   { 0.0, 1.0, -2.0 };    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    double[] result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);    }  }  @Test  public void testFixedState()    throws DerivativeException {    double[]   y    =   { 1.0, 3.0, -4.0 };    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    interpolator.setInterpolatedTime(0.1);    double[] result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {        assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);    }    interpolator.setInterpolatedTime(0.5);    result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {        assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);    }  }  @Test  public void testSerialization()  throws DerivativeException, IOException, ClassNotFoundException {    double[]   y    =   { 0.0, 1.0, -2.0 };    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    oos.writeObject(interpolator);    assertTrue(bos.size () > 150);    assertTrue(bos.size () < 250);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    DummyStepInterpolator dsi = (DummyStepInterpolator) ois.readObject();    dsi.setInterpolatedTime(0.5);    double[] result = dsi.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {        assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);    }  }  @Test  public void testImpossibleSerialization()  throws IOException {    double[] y = { 0.0, 1.0, -2.0 };    AbstractStepInterpolator interpolator = new BadStepInterpolator(y, true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    try {        oos.writeObject(interpolator);        fail("an exception should have been thrown");    } catch (IOException ioe) {        // expected behavior        assertEquals(0, ioe.getMessage().length());    } catch (Exception e) {        fail("wrong exception caught");    }  }  private static class BadStepInterpolator extends DummyStepInterpolator {      public BadStepInterpolator() {          super();      }      public BadStepInterpolator(double[] y, boolean forward) {          super(y, forward);      }      @Override      protected void doFinalize()      throws DerivativeException {          throw new DerivativeException(null);      }  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import junit.framework.*;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;import org.apache.commons.math.ode.nonstiff.TestProblem3;import org.apache.commons.math.ode.sampling.DummyStepInterpolator;import org.apache.commons.math.ode.sampling.StepInterpolator;public class ContinuousOutputModelTest  extends TestCase {  public ContinuousOutputModelTest(String name) {    super(name);    pb    = null;    integ = null;  }  public void testBoundaries()    throws DerivativeException, IntegratorException {    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandlers().iterator().next();    cm.setInterpolatedTime(2.0 * pb.getInitialTime() - pb.getFinalTime());    cm.setInterpolatedTime(2.0 * pb.getFinalTime() - pb.getInitialTime());    cm.setInterpolatedTime(0.5 * (pb.getFinalTime() + pb.getInitialTime()));  }  public void testRandomAccess()    throws DerivativeException, IntegratorException {    ContinuousOutputModel cm = new ContinuousOutputModel();    integ.addStepHandler(cm);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 1.0e-9);  }  public void testModelsMerging()    throws DerivativeException, IntegratorException {      // theoretical solution: y[0] = cos(t), y[1] = sin(t)      FirstOrderDifferentialEquations problem =          new FirstOrderDifferentialEquations() {              private static final long serialVersionUID = 2472449657345878299L;              public void computeDerivatives(double t, double[] y, double[] dot)                  throws DerivativeException {                  dot[0] = -y[1];                  dot[1] =  y[0];              }              public int getDimension() {                  return 2;              }          };      // integrate backward from &pi; to 0;      ContinuousOutputModel cm1 = new ContinuousOutputModel();      FirstOrderIntegrator integ1 =          new DormandPrince853Integrator(0, 1.0, 1.0e-8, 1.0e-8);      integ1.addStepHandler(cm1);      integ1.integrate(problem, Math.PI, new double[] { -1.0, 0.0 },                       0, new double[2]);      // integrate backward from 2&pi; to &pi;      ContinuousOutputModel cm2 = new ContinuousOutputModel();      FirstOrderIntegrator integ2 =          new DormandPrince853Integrator(0, 0.1, 1.0e-12, 1.0e-12);      integ2.addStepHandler(cm2);      integ2.integrate(problem, 2.0 * Math.PI, new double[] { 1.0, 0.0 },                       Math.PI, new double[2]);      // merge the two half circles      ContinuousOutputModel cm = new ContinuousOutputModel();      cm.append(cm2);      cm.append(new ContinuousOutputModel());      cm.append(cm1);      // check circle      assertEquals(2.0 * Math.PI, cm.getInitialTime(), 1.0e-12);      assertEquals(0, cm.getFinalTime(), 1.0e-12);      assertEquals(cm.getFinalTime(), cm.getInterpolatedTime(), 1.0e-12);      for (double t = 0; t < 2.0 * Math.PI; t += 0.1) {          cm.setInterpolatedTime(t);          double[] y = cm.getInterpolatedState();          assertEquals(Math.cos(t), y[0], 1.0e-7);          assertEquals(Math.sin(t), y[1], 1.0e-7);      }        }  public void testErrorConditions()    throws DerivativeException {      ContinuousOutputModel cm = new ContinuousOutputModel();      cm.handleStep(buildInterpolator(0, new double[] { 0.0, 1.0, -2.0 }, 1), true);            // dimension mismatch      assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0 }, 2.0));      // hole between time ranges      assertTrue(checkAppendError(cm, 10.0, new double[] { 0.0, 1.0, -2.0 }, 20.0));      // propagation direction mismatch      assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 0.0));      // no errors      assertFalse(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 2.0));  }  private boolean checkAppendError(ContinuousOutputModel cm,                                   double t0, double[] y0, double t1)  throws DerivativeException {      try {          ContinuousOutputModel otherCm = new ContinuousOutputModel();          otherCm.handleStep(buildInterpolator(t0, y0, t1), true);          cm.append(otherCm);      } catch(IllegalArgumentException iae) {          //expected behavior          return true;      }      return false;  }  private StepInterpolator buildInterpolator(double t0, double[] y0, double t1) {      DummyStepInterpolator interpolator  = new DummyStepInterpolator(y0, t1 >= t0);      interpolator.storeTime(t0);      interpolator.shift();      interpolator.storeTime(t1);      return interpolator;  }  public void checkValue(double value, double reference) {    assertTrue(Math.abs(value - reference) < 1.0e-10);  }  public static Test suite() {    return new TestSuite(ContinuousOutputModelTest.class);  }  @Override  public void setUp() {    pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    integ = new DormandPrince54Integrator(minStep, maxStep, 1.0e-8, 1.0e-8);  }  @Override  public void tearDown() {    pb    = null;    integ = null;  }  TestProblem3 pb;  FirstOrderIntegrator integ;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderConverter;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.SecondOrderDifferentialEquations;import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator;import junit.framework.*;public class FirstOrderConverterTest  extends TestCase {  public FirstOrderConverterTest(String name) {    super(name);  }  public void testDoubleDimension() {    for (int i = 1; i < 10; ++i) {      SecondOrderDifferentialEquations eqn2 = new Equations(i, 0.2);      FirstOrderConverter eqn1 = new FirstOrderConverter(eqn2);      assertTrue(eqn1.getDimension() == (2 * eqn2.getDimension()));    }  }    public void testDecreasingSteps()    throws DerivativeException, IntegratorException {          double previousError = Double.NaN;    for (int i = 0; i < 10; ++i) {      double step  = Math.pow(2.0, -(i + 1));      double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, step)                   - Math.sin(4.0);      if (i > 0) {        assertTrue(Math.abs(error) < Math.abs(previousError));      }      previousError = error;          }  }  public void testSmallStep()    throws DerivativeException, IntegratorException {    double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 1.0e-4)                   - Math.sin(4.0);    assertTrue(Math.abs(error) < 1.0e-10);  }  public void testBigStep()    throws DerivativeException, IntegratorException {    double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 0.5)                   - Math.sin(4.0);    assertTrue(Math.abs(error) > 0.1);  }    public static Test suite() {    return new TestSuite(FirstOrderConverterTest.class);  }  private static class Equations    implements SecondOrderDifferentialEquations {          private static final long serialVersionUID = -7926271579508637558L;    private int n;      private double omega2;            public Equations(int n, double omega) {        this.n = n;        omega2 = omega * omega;      }            public int getDimension() {        return n;      }            public void computeSecondDerivatives(double t, double[] y, double[] yDot,                                           double[] yDDot) {        for (int i = 0; i < n; ++i) {          yDDot[i] = -omega2 * y[i];        }    }        }  private double integrateWithSpecifiedStep(double omega,                                            double t0, double t,                                            double step)  throws DerivativeException, IntegratorException {    double[] y0 = new double[2];    y0[0] = Math.sin(omega * t0);    y0[1] = omega * Math.cos(omega * t0);    ClassicalRungeKuttaIntegrator i = new ClassicalRungeKuttaIntegrator(step);    double[] y = new double[2];    i.integrate(new FirstOrderConverter(new Equations(1, omega)), t0, y0, t, y);    return y[0];  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import junit.framework.Test;import junit.framework.TestSuite;import java.util.Random;/** * Test cases for the RandomAdaptor class * * @version $Revision$ $Date$ */public class RandomAdaptorTest extends RandomDataTest {        public RandomAdaptorTest(String name) {        super(name);    }         public static Test suite() {        TestSuite suite = new TestSuite(RandomAdaptorTest.class);        suite.setName("RandomAdaptor Tests");        return suite;    }        public void testAdaptor() {        ConstantGenerator generator = new ConstantGenerator();        Random random = RandomAdaptor.createAdaptor(generator);        checkConstant(random);        RandomAdaptor randomAdaptor = new RandomAdaptor(generator);        checkConstant(randomAdaptor);     }        private void checkConstant(Random random) {        byte[] bytes = new byte[] {0};        random.nextBytes(bytes);        assertEquals(0, bytes[0]);          assertEquals(false, random.nextBoolean());        assertEquals(0, random.nextDouble(), 0);        assertEquals(0, random.nextFloat(), 0);        assertEquals(0, random.nextGaussian(), 0);        assertEquals(0, random.nextInt());        assertEquals(0, random.nextInt(1));        assertEquals(0, random.nextLong());        random.setSeed(100);        assertEquals(0, random.nextDouble(), 0);    }        /*     * "Constant" generator to test Adaptor delegation.     * "Powered by Eclipse ;-)"     *      */    private static class ConstantGenerator implements RandomGenerator {                public boolean nextBoolean() {            return false;        }                public void nextBytes(byte[] bytes) {        }        public double nextDouble() {            return 0;        }        public float nextFloat() {            return 0;        }        public double nextGaussian() {            return 0;        }        public int nextInt() {            return 0;        }        public int nextInt(int n) {            return 0;        }        public long nextLong() {            return 0;        }        public void setSeed(long seed) {        }           }}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.random;import org.apache.commons.math.DimensionMismatchException;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;import org.apache.commons.math.stat.descriptive.moment.VectorialMean;import junit.framework.*;public class UncorrelatedRandomVectorGeneratorTestextends TestCase {    public UncorrelatedRandomVectorGeneratorTest(String name) {        super(name);        mean = null;        standardDeviation = null;        generator = null;    }    public void testMeanAndCorrelation() throws DimensionMismatchException {        VectorialMean meanStat = new VectorialMean(mean.length);        VectorialCovariance covStat = new VectorialCovariance(mean.length, true);        for (int i = 0; i < 10000; ++i) {            double[] v = generator.nextVector();            meanStat.increment(v);            covStat.increment(v);        }        double[] estimatedMean = meanStat.getResult();        double scale;        RealMatrix estimatedCorrelation = covStat.getResult();        for (int i = 0; i < estimatedMean.length; ++i) {            assertEquals(mean[i], estimatedMean[i], 0.07);            for (int j = 0; j < i; ++j) {                scale = standardDeviation[i] * standardDeviation[j];                assertEquals(0, estimatedCorrelation.getEntry(i, j) / scale, 0.03);            }            scale = standardDeviation[i] * standardDeviation[i];            assertEquals(1, estimatedCorrelation.getEntry(i, i) / scale, 0.025);        }    }    @Override    public void setUp() {        mean              = new double[] {0.0, 1.0, -3.0, 2.3};        standardDeviation = new double[] {1.0, 2.0, 10.0, 0.1};        RandomGenerator rg = new JDKRandomGenerator();        rg.setSeed(17399225432l);        generator =            new UncorrelatedRandomVectorGenerator(mean, standardDeviation,                    new GaussianRandomGenerator(rg));    }    @Override    public void tearDown() {        mean = null;        standardDeviation = null;        generator = null;    }    public static Test suite() {        return new TestSuite(UncorrelatedRandomVectorGeneratorTest.class);    }    private double[] mean;    private double[] standardDeviation;    private UncorrelatedRandomVectorGenerator generator;}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.random;import org.apache.commons.math.stat.StatUtils;import junit.framework.*;public class GaussianRandomGeneratorTestextends TestCase {    public GaussianRandomGeneratorTest(String name) {        super(name);    }    public void testMeanAndStandardDeviation() {        RandomGenerator rg = new JDKRandomGenerator();        rg.setSeed(17399225432l);        GaussianRandomGenerator generator = new GaussianRandomGenerator(rg);        double[] sample = new double[10000];        for (int i = 0; i < sample.length; ++i) {            sample[i] = generator.nextNormalizedDouble();        }        assertEquals(0.0, StatUtils.mean(sample), 0.012);        assertEquals(1.0, StatUtils.variance(sample), 0.01);    }    public static Test suite() {        return new TestSuite(GaussianRandomGeneratorTest.class);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import junit.framework.Test;import junit.framework.TestSuite;import java.util.HashSet;import org.apache.commons.math.RetryTestCase;import org.apache.commons.math.stat.Frequency;import org.apache.commons.math.stat.inference.ChiSquareTestImpl;import org.apache.commons.math.stat.descriptive.SummaryStatistics;/** * Test cases for the RandomData class. *  * @version $Revision$ $Date: 2009-04-05 11:55:59 -0500 (Sun, 05 Apr *          2009) $ */public class RandomDataTest extends RetryTestCase {public RandomDataTest(String name) {super(name);randomData = new RandomDataImpl();}protected long smallSampleSize = 1000;protected double[] expected = { 250, 250, 250, 250 };protected int largeSampleSize = 10000;private String[] hex = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9","a", "b", "c", "d", "e", "f" };protected RandomDataImpl randomData = null;protected ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();public static Test suite() {TestSuite suite = new TestSuite(RandomDataTest.class);suite.setName("RandomData Tests");return suite;}public void testNextIntExtremeValues() {int x = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);int y = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);assertFalse(x == y);}public void testNextLongExtremeValues() {long x = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);long y = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);assertFalse(x == y);}/** test dispersion and failure modes for nextInt() */public void testNextInt() {try {randomData.nextInt(4, 3);fail("IllegalArgumentException expected");} catch (IllegalArgumentException ex) {// ignored}Frequency freq = new Frequency();int value = 0;for (int i = 0; i < smallSampleSize; i++) {value = randomData.nextInt(0, 3);assertTrue("nextInt range", (value >= 0) && (value <= 3));freq.addValue(value);}long[] observed = new long[4];for (int i = 0; i < 4; i++) {observed[i] = freq.getCount(i);}/* * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34 * for alpha = .01 */assertTrue("chi-square test -- will fail about 1 in 1000 times",testStatistic.chiSquare(expected, observed) < 16.27);}/** test dispersion and failure modes for nextLong() */public void testNextLong() {try {randomData.nextLong(4, 3);fail("IllegalArgumentException expected");} catch (IllegalArgumentException ex) {// ignored}Frequency freq = new Frequency();long value = 0;for (int i = 0; i < smallSampleSize; i++) {value = randomData.nextLong(0, 3);assertTrue("nextInt range", (value >= 0) && (value <= 3));freq.addValue(value);}long[] observed = new long[4];for (int i = 0; i < 4; i++) {observed[i] = freq.getCount(i);}/* * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34 * for alpha = .01 */assertTrue("chi-square test -- will fail about 1 in 1000 times",testStatistic.chiSquare(expected, observed) < 16.27);}/** test dispersion and failure modes for nextSecureLong() */public void testNextSecureLong() {try {randomData.nextSecureLong(4, 3);fail("IllegalArgumentException expected");} catch (IllegalArgumentException ex) {// ignored}Frequency freq = new Frequency();long value = 0;for (int i = 0; i < smallSampleSize; i++) {value = randomData.nextSecureLong(0, 3);assertTrue("nextInt range", (value >= 0) && (value <= 3));freq.addValue(value);}long[] observed = new long[4];for (int i = 0; i < 4; i++) {observed[i] = freq.getCount(i);}/* * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34 * for alpha = .01 */assertTrue("chi-square test -- will fail about 1 in 1000 times",testStatistic.chiSquare(expected, observed) < 16.27);}/** test dispersion and failure modes for nextSecureInt() */public void testNextSecureInt() {try {randomData.nextSecureInt(4, 3);fail("IllegalArgumentException expected");} catch (IllegalArgumentException ex) {// ignored}Frequency freq = new Frequency();int value = 0;for (int i = 0; i < smallSampleSize; i++) {value = randomData.nextSecureInt(0, 3);assertTrue("nextInt range", (value >= 0) && (value <= 3));freq.addValue(value);}long[] observed = new long[4];for (int i = 0; i < 4; i++) {observed[i] = freq.getCount(i);}/* * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34 * for alpha = .01 */assertTrue("chi-square test -- will fail about 1 in 1000 times",testStatistic.chiSquare(expected, observed) < 16.27);}/** * Make sure that empirical distribution of random Poisson(4)'s has P(X <= * 5) close to actual cumulative Poisson probablity and that nextPoisson * fails when mean is non-positive TODO: replace with statistical test, * adding test stat to TestStatistic */public void testNextPoisson() {try {randomData.nextPoisson(0);fail("zero mean -- expecting IllegalArgumentException");} catch (IllegalArgumentException ex) {// ignored}Frequency f = new Frequency();for (int i = 0; i < largeSampleSize; i++) {try {f.addValue(randomData.nextPoisson(4.0d));} catch (Exception ex) {fail(ex.getMessage());}}long cumFreq = f.getCount(0) + f.getCount(1) + f.getCount(2)+ f.getCount(3) + f.getCount(4) + f.getCount(5);long sumFreq = f.getSumFreq();double cumPct = Double.valueOf(cumFreq).doubleValue()/ Double.valueOf(sumFreq).doubleValue();assertEquals("cum Poisson(4)", cumPct, 0.7851, 0.2);try {randomData.nextPoisson(-1);fail("negative mean supplied -- IllegalArgumentException expected");} catch (IllegalArgumentException ex) {// ignored}try {randomData.nextPoisson(0);fail("0 mean supplied -- IllegalArgumentException expected");} catch (IllegalArgumentException ex) {// ignored}}public void testNextPoissonLargeMean() {for (int i = 0; i < 1000; i++) {long n = randomData.nextPoisson(1500.0);assertTrue(0 <= n);}}/** test dispersion and failute modes for nextHex() */public void testNextHex() {try {randomData.nextHexString(-1);fail("negative length supplied -- IllegalArgumentException expected");} catch (IllegalArgumentException ex) {// ignored}try {randomData.nextHexString(0);fail("zero length supplied -- IllegalArgumentException expected");} catch (IllegalArgumentException ex) {// ignored}String hexString = randomData.nextHexString(3);if (hexString.length() != 3) {fail("incorrect length for generated string");}hexString = randomData.nextHexString(1);if (hexString.length() != 1) {fail("incorrect length for generated string");}try {hexString = randomData.nextHexString(0);fail("zero length requested -- expecting IllegalArgumentException");} catch (IllegalArgumentException ex) {// ignored}if (hexString.length() != 1) {fail("incorrect length for generated string");}Frequency f = new Frequency();for (int i = 0; i < smallSampleSize; i++) {hexString = randomData.nextHexString(100);if (hexString.length() != 100) {fail("incorrect length for generated string");}for (int j = 0; j < hexString.length(); j++) {f.addValue(hexString.substring(j, j + 1));}}double[] expected = new double[16];long[] observed = new long[16];for (int i = 0; i < 16; i++) {expected[i] = (double) smallSampleSize * 100 / 16;observed[i] = f.getCount(hex[i]);}/* * Use ChiSquare dist with df = 16-1 = 15, alpha = .001 Change to 30.58 * for alpha = .01 */assertTrue("chi-square test -- will fail about 1 in 1000 times",testStatistic.chiSquare(expected, observed) < 37.70);}/** test dispersion and failute modes for nextHex() */public void testNextSecureHex() {try {randomData.nextSecureHexString(-1);fail("negative length -- IllegalArgumentException expected");} catch (IllegalArgumentException ex) {// ignored}try {randomData.nextSecureHexString(0);fail("zero length -- IllegalArgumentException expected");} catch (IllegalArgumentException ex) {// ignored}String hexString = randomData.nextSecureHexString(3);if (hexString.length() != 3) {fail("incorrect length for generated string");}hexString = randomData.nextSecureHexString(1);if (hexString.length() != 1) {fail("incorrect length for generated string");}try {hexString = randomData.nextSecureHexString(0);fail("zero length requested -- expecting IllegalArgumentException");} catch (IllegalArgumentException ex) {// ignored}if (hexString.length() != 1) {fail("incorrect length for generated string");}Frequency f = new Frequency();for (int i = 0; i < smallSampleSize; i++) {hexString = randomData.nextSecureHexString(100);if (hexString.length() != 100) {fail("incorrect length for generated string");}for (int j = 0; j < hexString.length(); j++) {f.addValue(hexString.substring(j, j + 1));}}double[] expected = new double[16];long[] observed = new long[16];for (int i = 0; i < 16; i++) {expected[i] = (double) smallSampleSize * 100 / 16;observed[i] = f.getCount(hex[i]);}/* * Use ChiSquare dist with df = 16-1 = 15, alpha = .001 Change to 30.58 * for alpha = .01 */assertTrue("chi-square test -- will fail about 1 in 1000 times",testStatistic.chiSquare(expected, observed) < 37.70);}/** test failure modes and dispersion of nextUniform() */public void testNextUniform() {try {randomData.nextUniform(4, 3);fail("IllegalArgumentException expected");} catch (IllegalArgumentException ex) {// ignored}try {randomData.nextUniform(3, 3);fail("IllegalArgumentException expected");} catch (IllegalArgumentException ex) {// ignored}double[] expected = { 500, 500 };long[] observed = { 0, 0 };double lower = -1d;double upper = 20d;double midpoint = (lower + upper) / 2d;double result = 0;for (int i = 0; i < 1000; i++) {result = randomData.nextUniform(lower, upper);if ((result == lower) || (result == upper)) {fail("generated value equal to an endpoint: " + result);}if (result < midpoint) {observed[0]++;} else {observed[1]++;}}/* * Use ChiSquare dist with df = 2-1 = 1, alpha = .001 Change to 6.64 for * alpha = .01 */assertTrue("chi-square test -- will fail about 1 in 1000 times",testStatistic.chiSquare(expected, observed) < 10.83);}/** test exclusive endpoints of nextUniform **/public void testNextUniformExclusiveEndpoints() {for (int i = 0; i < 1000; i++) {double u = randomData.nextUniform(0.99, 1);assertTrue(u > 0.99 && u < 1);}}/** test failure modes and distribution of nextGaussian() */public void testNextGaussian() {try {randomData.nextGaussian(0, 0);fail("zero sigma -- IllegalArgumentException expected");} catch (IllegalArgumentException ex) {// ignored}SummaryStatistics u = new SummaryStatistics();for (int i = 0; i < largeSampleSize; i++) {u.addValue(randomData.nextGaussian(0, 1));}double xbar = u.getMean();double s = u.getStandardDeviation();double n = u.getN();/* * t-test at .001-level TODO: replace with externalized t-test, with * test statistic defined in TestStatistic */assertTrue(Math.abs(xbar) / (s / Math.sqrt(n)) < 3.29);}/** test failure modes and distribution of nextExponential() */public void testNextExponential() {try {randomData.nextExponential(-1);fail("negative mean -- expecting IllegalArgumentException");} catch (IllegalArgumentException ex) {// ignored}assertEquals("0 mean", 0, randomData.nextExponential(0), 10E-8);long cumFreq = 0;double v = 0;for (int i = 0; i < largeSampleSize; i++) {v = randomData.nextExponential(1);assertTrue("exponential deviate postive", v > 0);if (v < 2)cumFreq++;}/* * TODO: Replace with a statistical test, with statistic added to * TestStatistic. Check below compares observed cumulative distribution * evaluated at 2 with exponential CDF */assertEquals("exponential cumulative distribution", (double) cumFreq/ (double) largeSampleSize, 0.8646647167633873, .2);}/** test reseeding, algorithm/provider games */public void testConfig() {randomData.reSeed(1000);double v = randomData.nextUniform(0, 1);randomData.reSeed();assertTrue("different seeds", Math.abs(v - randomData.nextUniform(0, 1)) > 10E-12);randomData.reSeed(1000);assertEquals("same seeds", v, randomData.nextUniform(0, 1), 10E-12);randomData.reSeedSecure(1000);String hex = randomData.nextSecureHexString(40);randomData.reSeedSecure();assertTrue("different seeds", !hex.equals(randomData.nextSecureHexString(40)));randomData.reSeedSecure(1000);assertTrue("same seeds", !hex.equals(randomData.nextSecureHexString(40)));/* * remove this test back soon, since it takes about 4 seconds *  * try { randomData.setSecureAlgorithm("SHA1PRNG","SUN"); } catch * (NoSuchProviderException ex) { ; } assertTrue("different seeds", * !hex.equals(randomData.nextSecureHexString(40))); try { * randomData.setSecureAlgorithm("NOSUCHTHING","SUN"); * fail("expecting NoSuchAlgorithmException"); } catch * (NoSuchProviderException ex) { ; } catch (NoSuchAlgorithmException * ex) { ; } *  * try { randomData.setSecureAlgorithm("SHA1PRNG","NOSUCHPROVIDER"); * fail("expecting NoSuchProviderException"); } catch * (NoSuchProviderException ex) { ; } */// test reseeding without first using the generatorsRandomDataImpl rd = new RandomDataImpl();rd.reSeed(100);rd.nextLong(1, 2);RandomDataImpl rd2 = new RandomDataImpl();rd2.reSeedSecure(2000);rd2.nextSecureLong(1, 2);rd = new RandomDataImpl();rd.reSeed();rd.nextLong(1, 2);rd2 = new RandomDataImpl();rd2.reSeedSecure();rd2.nextSecureLong(1, 2);}/** tests for nextSample() sampling from Collection */public void testNextSample() {Object[][] c = { { "0", "1" }, { "0", "2" }, { "0", "3" },{ "0", "4" }, { "1", "2" }, { "1", "3" }, { "1", "4" },{ "2", "3" }, { "2", "4" }, { "3", "4" } };long[] observed = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };double[] expected = { 100, 100, 100, 100, 100, 100, 100, 100, 100, 100 };HashSet<Object> cPop = new HashSet<Object>(); // {0,1,2,3,4}for (int i = 0; i < 5; i++) {cPop.add(Integer.toString(i));}Object[] sets = new Object[10]; // 2-sets from 5for (int i = 0; i < 10; i++) {HashSet<Object> hs = new HashSet<Object>();hs.add(c[i][0]);hs.add(c[i][1]);sets[i] = hs;}for (int i = 0; i < 1000; i++) {Object[] cSamp = randomData.nextSample(cPop, 2);observed[findSample(sets, cSamp)]++;}/* * Use ChiSquare dist with df = 10-1 = 9, alpha = .001 Change to 21.67 * for alpha = .01 */assertTrue("chi-square test -- will fail about 1 in 1000 times",testStatistic.chiSquare(expected, observed) < 27.88);// Make sure sample of size = size of collection returns same collectionHashSet<Object> hs = new HashSet<Object>();hs.add("one");Object[] one = randomData.nextSample(hs, 1);String oneString = (String) one[0];if ((one.length != 1) || !oneString.equals("one")) {fail("bad sample for set size = 1, sample size = 1");}// Make sure we fail for sample size > collection sizetry {one = randomData.nextSample(hs, 2);fail("sample size > set size, expecting IllegalArgumentException");} catch (IllegalArgumentException ex) {// ignored}// Make sure we fail for empty collectiontry {hs = new HashSet<Object>();one = randomData.nextSample(hs, 0);fail("n = k = 0, expecting IllegalArgumentException");} catch (IllegalArgumentException ex) {// ignored}}@SuppressWarnings("unchecked")private int findSample(Object[] u, Object[] samp) {for (int i = 0; i < u.length; i++) {HashSet<Object> set = (HashSet<Object>) u[i];HashSet<Object> sampSet = new HashSet<Object>();for (int j = 0; j < samp.length; j++) {sampSet.add(samp[j]);}if (set.equals(sampSet)) {return i;}}fail("sample not found:{" + samp[0] + "," + samp[1] + "}");return -1;}/** tests for nextPermutation */public void testNextPermutation() {int[][] p = { { 0, 1, 2 }, { 0, 2, 1 }, { 1, 0, 2 }, { 1, 2, 0 },{ 2, 0, 1 }, { 2, 1, 0 } };long[] observed = { 0, 0, 0, 0, 0, 0 };double[] expected = { 100, 100, 100, 100, 100, 100 };for (int i = 0; i < 600; i++) {int[] perm = randomData.nextPermutation(3, 3);observed[findPerm(p, perm)]++;}/* * Use ChiSquare dist with df = 6-1 = 5, alpha = .001 Change to 15.09 * for alpha = .01 */assertTrue("chi-square test -- will fail about 1 in 1000 times",testStatistic.chiSquare(expected, observed) < 20.52);// Check size = 1 boundary caseint[] perm = randomData.nextPermutation(1, 1);if ((perm.length != 1) || (perm[0] != 0)) {fail("bad permutation for n = 1, sample k = 1");// Make sure we fail for k size > ntry {perm = randomData.nextPermutation(2, 3);fail("permutation k > n, expecting IllegalArgumentException");} catch (IllegalArgumentException ex) {// ignored}// Make sure we fail for n = 0try {perm = randomData.nextPermutation(0, 0);fail("permutation k = n = 0, expecting IllegalArgumentException");} catch (IllegalArgumentException ex) {// ignored}// Make sure we fail for k < n < 0try {perm = randomData.nextPermutation(-1, -3);fail("permutation k < n < 0, expecting IllegalArgumentException");} catch (IllegalArgumentException ex) {// ignored}}}// Disable until we have equals//public void testSerial() {//    assertEquals(randomData, TestUtils.serializeAndRecover(randomData));//}private int findPerm(int[][] p, int[] samp) {for (int i = 0; i < p.length; i++) {boolean good = true;for (int j = 0; j < samp.length; j++) {if (samp[j] != p[i][j]) {good = false;}}if (good) {return i;}}fail("permutation not found");return -1;}}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import java.util.Random;/** * Dummy AbstractRandomGenerator concrete subclass that just wraps a  * java.util.Random instance.  Used by AbstractRandomGeneratorTest to test * default implementations in AbstractRandomGenerator. * * @version $Revision$ $Date$ */public class TestRandomGenerator extends AbstractRandomGenerator {    private Random random = new Random();    @Override    public void setSeed(long seed) {       clear();       random.setSeed(seed);    }    @Override    public double nextDouble() {        return random.nextDouble();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.Frequency; /** * Test cases for the AbstractRandomGenerator class * * @version $Revision$ $Date$ */public class AbstractRandomGeneratorTest extends RandomDataTest {        protected TestRandomGenerator testGenerator = new TestRandomGenerator();        public AbstractRandomGeneratorTest(String name) {        super(name);        randomData = new RandomDataImpl(testGenerator);    }         public static Test suite() {        TestSuite suite = new TestSuite(AbstractRandomGeneratorTest.class);        suite.setName("AbstractRandomGenerator Tests");        return suite;    }        @Override    public void testNextInt() {        try {            testGenerator.nextInt(-1);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }        Frequency freq = new Frequency();        int value = 0;        for (int i=0; i<smallSampleSize; i++) {            value = testGenerator.nextInt(4);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected,observed) < 16.27);        }        @Override    public void testNextLong() {        long q1 = Long.MAX_VALUE/4;        long q2 = 2 *  q1;        long q3 = 3 * q1;                Frequency freq = new Frequency();        long val = 0;        int value = 0;        for (int i=0; i<smallSampleSize; i++) {            val = testGenerator.nextLong();            if (val < q1) {                value = 0;            } else if (val < q2) {                value = 1;            } else if (val < q3) {                value = 2;            } else {                value = 3;            }            freq.addValue(value);          }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected,observed) < 16.27);        }        public void testNextBoolean() {        long halfSampleSize = smallSampleSize / 2;         double[] expected = {halfSampleSize, halfSampleSize};        long[] observed = new long[2];        for (int i=0; i<smallSampleSize; i++) {            if (testGenerator.nextBoolean()) {                observed[0]++;            } else {                observed[1]++;            }        }        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001         * Change to 6.635 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected,observed) < 10.828);        }        public void testNextFloat() {        Frequency freq = new Frequency();        float val = 0;        int value = 0;        for (int i=0; i<smallSampleSize; i++) {            val = testGenerator.nextFloat();            if (val < 0.25) {                value = 0;            } else if (val < 0.5) {                value = 1;            } else if (val < 0.75) {                value = 2;            } else {                value = 3;            }            freq.addValue(value);          }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected,observed) < 16.27);        }}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.random;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.DimensionMismatchException;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.NotPositiveDefiniteMatrixException;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;import org.apache.commons.math.stat.descriptive.moment.VectorialMean;public class CorrelatedRandomVectorGeneratorTestextends TestCase {    public CorrelatedRandomVectorGeneratorTest(String name) {        super(name);        mean       = null;        covariance = null;        generator  = null;    }    public void testRank() {        assertEquals(3, generator.getRank());    }    public void testMath226()        throws DimensionMismatchException, NotPositiveDefiniteMatrixException {        double[] mean = { 1, 1, 10, 1 };        double[][] cov = {                { 1, 3, 2, 6 },                { 3, 13, 16, 2 },                { 2, 16, 38, -1 },                { 6, 2, -1, 197 }        };        RealMatrix covRM = MatrixUtils.createRealMatrix(cov);        JDKRandomGenerator jg = new JDKRandomGenerator();        jg.setSeed(5322145245211l);        NormalizedRandomGenerator rg = new GaussianRandomGenerator(jg);        CorrelatedRandomVectorGenerator sg =            new CorrelatedRandomVectorGenerator(mean, covRM, 0.00001, rg);        for (int i = 0; i < 10; i++) {            double[] generated = sg.nextVector();            assertTrue(Math.abs(generated[0] - 1) > 0.1);        }    }    public void testRootMatrix() {        RealMatrix b = generator.getRootMatrix();        RealMatrix bbt = b.multiply(b.transpose());        for (int i = 0; i < covariance.getRowDimension(); ++i) {            for (int j = 0; j < covariance.getColumnDimension(); ++j) {                assertEquals(covariance.getEntry(i, j), bbt.getEntry(i, j), 1.0e-12);            }        }    }    public void testMeanAndCovariance() throws DimensionMismatchException {        VectorialMean meanStat = new VectorialMean(mean.length);        VectorialCovariance covStat = new VectorialCovariance(mean.length, true);        for (int i = 0; i < 5000; ++i) {            double[] v = generator.nextVector();            meanStat.increment(v);            covStat.increment(v);        }        double[] estimatedMean = meanStat.getResult();        RealMatrix estimatedCovariance = covStat.getResult();        for (int i = 0; i < estimatedMean.length; ++i) {            assertEquals(mean[i], estimatedMean[i], 0.07);            for (int j = 0; j <= i; ++j) {                assertEquals(covariance.getEntry(i, j),                        estimatedCovariance.getEntry(i, j),                        0.1 * (1.0 + Math.abs(mean[i])) * (1.0 + Math.abs(mean[j])));            }        }    }    @Override    public void setUp() {        try {            mean = new double[] { 0.0, 1.0, -3.0, 2.3};            RealMatrix b = MatrixUtils.createRealMatrix(4, 3);            int counter = 0;            for (int i = 0; i < b.getRowDimension(); ++i) {                for (int j = 0; j < b.getColumnDimension(); ++j) {                    b.setEntry(i, j, 1.0 + 0.1 * ++counter);                }            }            RealMatrix bbt = b.multiply(b.transpose());            covariance = MatrixUtils.createRealMatrix(mean.length, mean.length);            for (int i = 0; i < covariance.getRowDimension(); ++i) {                covariance.setEntry(i, i, bbt.getEntry(i, i));                for (int j = 0; j < covariance.getColumnDimension(); ++j) {                    double s = bbt.getEntry(i, j);                    covariance.setEntry(i, j, s);                    covariance.setEntry(j, i, s);                }            }            RandomGenerator rg = new JDKRandomGenerator();            rg.setSeed(17399225432l);            GaussianRandomGenerator rawGenerator = new GaussianRandomGenerator(rg);            generator = new CorrelatedRandomVectorGenerator(mean,                                                            covariance,                                                            1.0e-12 * covariance.getNorm(),                                                            rawGenerator);        } catch (DimensionMismatchException e) {            fail(e.getMessage());        } catch (NotPositiveDefiniteMatrixException e) {            fail("not positive definite matrix");        }    }    @Override    public void tearDown() {        mean       = null;        covariance = null;        generator  = null;    }    public static Test suite() {        return new TestSuite(CorrelatedRandomVectorGeneratorTest.class);    }    private double[] mean;    private RealMatrix covariance;    private CorrelatedRandomVectorGenerator generator;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import junit.framework.Test;import junit.framework.TestSuite;import java.io.EOFException;import java.net.URL;import org.apache.commons.math.RetryTestCase;import org.apache.commons.math.stat.descriptive.SummaryStatistics; /** * Test cases for the ValueServer class. * * @version $Revision$ $Date$ */public final class ValueServerTest extends RetryTestCase {    private ValueServer vs = new ValueServer();        public ValueServerTest(String name) {        super(name);    }    @Override    public void setUp() {        vs.setMode(ValueServer.DIGEST_MODE);        try {            URL url = getClass().getResource("testData.txt");            vs.setValuesFileURL(url);         } catch (Exception ex) {            fail("malformed test URL");        }    }    public static Test suite() {        TestSuite suite = new TestSuite(ValueServerTest.class);        suite.setName("ValueServer Tests");        return suite;    }       /**       * Generate 1000 random values and make sure they look OK.<br>      * Note that there is a non-zero (but very small) probability that      * these tests will fail even if the code is working as designed.      */    public void testNextDigest() throws Exception{        double next = 0.0;        double tolerance = 0.1;        vs.computeDistribution();        assertTrue("empirical distribution property",             vs.getEmpiricalDistribution() != null);        SummaryStatistics stats = new SummaryStatistics();        for (int i = 1; i < 1000; i++) {            next = vs.getNext();            stats.addValue(next);        }            assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);        assertEquals         ("std dev", 1.0173699343977738, stats.getStandardDeviation(),             tolerance);                vs.computeDistribution(500);        stats = new SummaryStatistics();        for (int i = 1; i < 1000; i++) {            next = vs.getNext();            stats.addValue(next);        }            assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);        assertEquals         ("std dev", 1.0173699343977738, stats.getStandardDeviation(),             tolerance);            }        /**      * Make sure exception thrown if digest getNext is attempted      * before loading empiricalDistribution.      */    public void testNextDigestFail() throws Exception {        try {            vs.getNext();            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {}    }    public void testEmptyReplayFile() {        try {            URL url = getClass().getResource("emptyFile.txt");            vs.setMode(ValueServer.REPLAY_MODE);            vs.setValuesFileURL(url);            vs.getNext();            fail("an exception should have been thrown");        } catch (EOFException eof) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testEmptyDigestFile() {        try {            URL url = getClass().getResource("emptyFile.txt");            vs.setMode(ValueServer.DIGEST_MODE);            vs.setValuesFileURL(url);            vs.computeDistribution();            fail("an exception should have been thrown");        } catch (EOFException eof) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /**     * Test ValueServer REPLAY_MODE using values in testData file.<br>      * Check that the values 1,2,1001,1002 match data file values 1 and 2.     * the sample data file.     */    public void testReplay() throws Exception {        double firstDataValue = 4.038625496201205;        double secondDataValue = 3.6485326248346936;        double tolerance = 10E-15;        double compareValue = 0.0d;        vs.setMode(ValueServer.REPLAY_MODE);        vs.resetReplayFile();        compareValue = vs.getNext();        assertEquals(compareValue,firstDataValue,tolerance);        compareValue = vs.getNext();        assertEquals(compareValue,secondDataValue,tolerance);        for (int i = 3; i < 1001; i++) {           compareValue = vs.getNext();        }        compareValue = vs.getNext();        assertEquals(compareValue,firstDataValue,tolerance);        compareValue = vs.getNext();        assertEquals(compareValue,secondDataValue,tolerance);        vs.closeReplayFile();        // make sure no NPE        vs.closeReplayFile();    }        /**      * Test other ValueServer modes     */    public void testModes() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        vs.setMu(0);        assertEquals("constant mode test",vs.getMu(),vs.getNext(),Double.MIN_VALUE);        vs.setMode(ValueServer.UNIFORM_MODE);        vs.setMu(2);        double val = vs.getNext();        assertTrue(val > 0 && val < 4);        vs.setSigma(1);        vs.setMode(ValueServer.GAUSSIAN_MODE);        val = vs.getNext();        assertTrue("gaussian value close enough to mean",            val < vs.getMu() + 100*vs.getSigma());        vs.setMode(ValueServer.EXPONENTIAL_MODE);        val = vs.getNext();        assertTrue(val > 0);        try {            vs.setMode(1000);            vs.getNext();            fail("bad mode, expecting IllegalStateException");        } catch (IllegalStateException ex) {            // ignored        }    }        /**     * Test fill     */    public void testFill() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        vs.setMu(2);        double[] val = new double[5];        vs.fill(val);        for (int i = 0; i < 5; i++) {            assertEquals("fill test in place",2,val[i],Double.MIN_VALUE);        }        double v2[] = vs.fill(3);        for (int i = 0; i < 3; i++) {            assertEquals("fill test in place",2,v2[i],Double.MIN_VALUE);        }    }        /**     * Test getters to make Clover happy     */    public void testProperties() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        assertEquals("mode test",ValueServer.CONSTANT_MODE,vs.getMode());        vs.setValuesFileURL("http://www.apache.org");        URL url = vs.getValuesFileURL();        assertEquals("valuesFileURL test","http://www.apache.org",url.toString());    }                          }
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.random;import org.apache.commons.math.stat.StatUtils;import junit.framework.*;public class UniformRandomGeneratorTestextends TestCase {    public UniformRandomGeneratorTest(String name) {        super(name);    }    public void testMeanAndStandardDeviation() {        RandomGenerator rg = new JDKRandomGenerator();        rg.setSeed(17399225432l);        UniformRandomGenerator generator = new UniformRandomGenerator(rg);        double[] sample = new double[10000];        for (int i = 0; i < sample.length; ++i) {            sample[i] = generator.nextNormalizedDouble();        }        assertEquals(0.0, StatUtils.mean(sample), 0.07);        assertEquals(1.0, StatUtils.variance(sample), 0.02);    }            public static Test suite() {        return new TestSuite(UniformRandomGeneratorTest.class);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import java.io.BufferedReader;import java.io.File;import java.io.IOException;import java.io.InputStreamReader;import java.net.URL;import java.util.ArrayList;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.MathRuntimeException;import org.apache.commons.math.RetryTestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.SummaryStatistics;/** * Test cases for the EmpiricalDistribution class * * @version $Revision$ $Date$ */public final class EmpiricalDistributionTest extends RetryTestCase {    protected EmpiricalDistribution empiricalDistribution = null;    protected EmpiricalDistribution empiricalDistribution2 = null;    protected File file = null;    protected URL url = null;     protected double[] dataArray = null;        public EmpiricalDistributionTest(String name) {        super(name);    }    @Override    public void setUp() throws IOException {        empiricalDistribution = new EmpiricalDistributionImpl(100);        url = getClass().getResource("testData.txt");                empiricalDistribution2 = new EmpiricalDistributionImpl(100);        BufferedReader in =                 new BufferedReader(new InputStreamReader(                        url.openStream()));        String str = null;        ArrayList<Double> list = new ArrayList<Double>();        while ((str = in.readLine()) != null) {            list.add(Double.valueOf(str));        }        in.close();        in = null;                dataArray = new double[list.size()];        int i = 0;        for (Double data : list) {            dataArray[i] = data.doubleValue();            i++;        }                     }    public static Test suite() {        TestSuite suite = new TestSuite(EmpiricalDistributionTest.class);        suite.setName("EmpiricalDistribution Tests");        return suite;    }    /**     * Test EmpiricalDistrbution.load() using sample data file.<br>      * Check that the sampleCount, mu and sigma match data in      * the sample data file.     */    public void testLoad() throws Exception {        empiricalDistribution.load(url);           // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1        // Make sure that loaded distribution matches this        assertEquals(empiricalDistribution.getSampleStats().getN(),1000,10E-7);        //TODO: replace with statistical tests        assertEquals            (empiricalDistribution.getSampleStats().getMean(),                5.069831575018909,10E-7);        assertEquals          (empiricalDistribution.getSampleStats().getStandardDeviation(),                1.0173699343977738,10E-7);    }    /**     * Test EmpiricalDistrbution.load(double[]) using data taken from     * sample data file.<br>      * Check that the sampleCount, mu and sigma match data in      * the sample data file.     */    public void testDoubleLoad() throws Exception {        empiricalDistribution2.load(dataArray);           // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1        // Make sure that loaded distribution matches this        assertEquals(empiricalDistribution2.getSampleStats().getN(),1000,10E-7);        //TODO: replace with statistical tests        assertEquals            (empiricalDistribution2.getSampleStats().getMean(),                5.069831575018909,10E-7);        assertEquals          (empiricalDistribution2.getSampleStats().getStandardDeviation(),                1.0173699343977738,10E-7);                double[] bounds = empiricalDistribution2.getUpperBounds();        assertEquals(bounds.length, 100);        assertEquals(bounds[99], 1.0, 10e-12);              }       /**       * Generate 1000 random values and make sure they look OK.<br>      * Note that there is a non-zero (but very small) probability that      * these tests will fail even if the code is working as designed.      */    public void testNext() throws Exception {        tstGen(0.1);        tstDoubleGen(0.1);    }        /**      * Make sure exception thrown if digest getNext is attempted      * before loading empiricalDistribution.     */    public void testNexFail() {        try {            empiricalDistribution.getNextValue();            empiricalDistribution2.getNextValue();            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {            // expected        } catch (Exception e) {            fail("wrong exception caught");        }    }        /**     * Make sure we can handle a grid size that is too fine     */    public void testGridTooFine() throws Exception {        empiricalDistribution = new EmpiricalDistributionImpl(1001);        tstGen(0.1);            empiricalDistribution2 = new EmpiricalDistributionImpl(1001);                   tstDoubleGen(0.1);    }        /**     * How about too fat?     */    public void testGridTooFat() throws Exception {        empiricalDistribution = new EmpiricalDistributionImpl(1);        tstGen(5); // ridiculous tolerance; but ridiculous grid size                   // really just checking to make sure we do not bomb        empiricalDistribution2 = new EmpiricalDistributionImpl(1);                   tstDoubleGen(5);               }        /**     * Test bin index overflow problem (BZ 36450)     */    public void testBinIndexOverflow() throws Exception {        double[] x = new double[] {9474.94326071674, 2080107.8865462579};        new EmpiricalDistributionImpl().load(x);    }        public void testSerialization() {        // Empty        EmpiricalDistribution dist = new EmpiricalDistributionImpl();        EmpiricalDistribution dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(dist);        verifySame(dist, dist2);                // Loaded        empiricalDistribution2.load(dataArray);           dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(empiricalDistribution2);        verifySame(empiricalDistribution2, dist2);    }    public void testLoadNullDoubleArray() {        EmpiricalDistribution dist = new EmpiricalDistributionImpl();        try {            dist.load((double[]) null);            fail("load((double[]) null) expected RuntimeException");        } catch (MathRuntimeException e) {            // expected        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testLoadNullURL() throws Exception {        EmpiricalDistribution dist = new EmpiricalDistributionImpl();        try {            dist.load((URL) null);            fail("load((URL) null) expected NullPointerException");        } catch (NullPointerException e) {            // expected        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testLoadNullFile() throws Exception {        EmpiricalDistribution dist = new EmpiricalDistributionImpl();        try {            dist.load((File) null);            fail("load((File) null) expected NullPointerException");        } catch (NullPointerException e) {            // expected        } catch (Exception e) {            fail("wrong exception caught");        }    }    private void verifySame(EmpiricalDistribution d1, EmpiricalDistribution d2) {        assertEquals(d1.isLoaded(), d2.isLoaded());        assertEquals(d1.getBinCount(), d2.getBinCount());        assertEquals(d1.getSampleStats(), d2.getSampleStats());        if (d1.isLoaded()) {            for (int i = 0;  i < d1.getUpperBounds().length; i++) {                assertEquals(d1.getUpperBounds()[i], d2.getUpperBounds()[i], 0);            }            assertEquals(d1.getBinStats(), d2.getBinStats());        }    }        private void tstGen(double tolerance)throws Exception {        empiricalDistribution.load(url);           SummaryStatistics stats = new SummaryStatistics();        for (int i = 1; i < 1000; i++) {            stats.addValue(empiricalDistribution.getNextValue());        }        assertEquals("mean", stats.getMean(),5.069831575018909,tolerance);        assertEquals         ("std dev", stats.getStandardDeviation(),1.0173699343977738,tolerance);    }    private void tstDoubleGen(double tolerance)throws Exception {        empiricalDistribution2.load(dataArray);           SummaryStatistics stats = new SummaryStatistics();        for (int i = 1; i < 1000; i++) {            stats.addValue(empiricalDistribution2.getNextValue());        }        assertEquals("mean", stats.getMean(),5.069831575018909,tolerance);        assertEquals         ("std dev", stats.getStandardDeviation(),1.0173699343977738,tolerance);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.general;import java.awt.geom.Point2D;import java.io.Serializable;import java.util.ArrayList;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.analysis.MultivariateVectorialFunction;import org.apache.commons.math.analysis.solvers.BrentSolver;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.optimization.OptimizationException;import org.apache.commons.math.optimization.RealPointValuePair;import org.apache.commons.math.optimization.SimpleScalarValueChecker;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files.  * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */public class NonLinearConjugateGradientOptimizerTestextends TestCase {    public NonLinearConjugateGradientOptimizerTest(String name) {        super(name);    }    public void testTrivial() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0 });        assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);        assertEquals(0.0, optimum.getValue(), 1.0e-10);    }    public void testColumnsPermutation() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },                              new double[] { 4.0, 6.0, 1.0 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0 });        assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);        assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(0.0, optimum.getValue(), 1.0e-10);    }    public void testNoDependency() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 2, 0, 0, 0, 0, 0 },                { 0, 2, 0, 0, 0, 0 },                { 0, 0, 2, 0, 0, 0 },                { 0, 0, 0, 2, 0, 0 },                { 0, 0, 0, 0, 2, 0 },                { 0, 0, 0, 0, 0, 2 }        }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });        for (int i = 0; i < problem.target.length; ++i) {            assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);        }    }    public void testOneSet() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                {  1,  0, 0 },                { -1,  1, 0 },                {  0, -1, 1 }        }, new double[] { 1, 1, 1});        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });        assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);        assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);    }    public void testTwoSets() throws FunctionEvaluationException, OptimizationException {        final double epsilon = 1.0e-7;        LinearProblem problem = new LinearProblem(new double[][] {                {  2,  1,   0,  4,       0, 0 },                { -4, -2,   3, -7,       0, 0 },                {  4,  1,  -2,  8,       0, 0 },                {  0, -3, -12, -1,       0, 0 },                {  0,  0,   0,  0, epsilon, 1 },                {  0,  0,   0,  0,       1, 1 }        }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxIterations(100);        optimizer.setPreconditioner(new Preconditioner() {            public double[] precondition(double[] point, double[] r) {                double[] d = r.clone();                d[0] /=  72.0;                d[1] /=  30.0;                d[2] /= 314.0;                d[3] /= 260.0;                d[4] /= 2 * (1 + epsilon * epsilon);                d[5] /= 4.0;                return d;            }        });        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-13, 1.0e-13));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });        assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);        assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);        assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);        assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);        assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);    }    public void testNonInversible() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                {  1, 2, -3 },                {  2, 1,  3 },                { -3, 0, -9 }        }, new double[] { 1, 1, 1 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =                optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });        assertTrue(optimum.getValue() > 0.5);    }    public void testIllConditioned() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem1 = new LinearProblem(new double[][] {                { 10.0, 7.0,  8.0,  7.0 },                {  7.0, 5.0,  6.0,  5.0 },                {  8.0, 6.0, 10.0,  9.0 },                {  7.0, 5.0,  9.0, 10.0 }        }, new double[] { 32, 23, 33, 31 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-13, 1.0e-13));        BrentSolver solver = new BrentSolver();        solver.setAbsoluteAccuracy(1.0e-15);        solver.setRelativeAccuracy(1.0e-15);        optimizer.setLineSearchSolver(solver);        RealPointValuePair optimum1 =            optimizer.optimize(problem1, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });        assertEquals(1.0, optimum1.getPoint()[0], 1.0e-5);        assertEquals(1.0, optimum1.getPoint()[1], 1.0e-5);        assertEquals(1.0, optimum1.getPoint()[2], 1.0e-5);        assertEquals(1.0, optimum1.getPoint()[3], 1.0e-5);        LinearProblem problem2 = new LinearProblem(new double[][] {                { 10.00, 7.00, 8.10, 7.20 },                {  7.08, 5.04, 6.00, 5.00 },                {  8.00, 5.98, 9.89, 9.00 },                {  6.99, 4.99, 9.00, 9.98 }        }, new double[] { 32, 23, 33, 31 });        RealPointValuePair optimum2 =            optimizer.optimize(problem2, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });        assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-1);        assertEquals(137.0, optimum2.getPoint()[1], 1.0e-1);        assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-1);        assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-1);    }    public void testMoreEstimatedParametersSimple()        throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 3.0, 2.0,  0.0, 0.0 },                { 0.0, 1.0, -1.0, 1.0 },                { 2.0, 0.0,  1.0, 0.0 }        }, new double[] { 7.0, 3.0, 5.0 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 7, 6, 5, 4 });        assertEquals(0, optimum.getValue(), 1.0e-10);    }    public void testMoreEstimatedParametersUnsorted()        throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                 { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },                 { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },                 { 0.0, 0.0,  0.0,  0.0, 1.0, -1.0 },                 { 0.0, 0.0, -1.0,  1.0, 0.0,  1.0 },                 { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }        }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 2, 2, 2, 2, 2, 2 });        assertEquals(0, optimum.getValue(), 1.0e-10);    }    public void testRedundantEquations() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 5.0 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 1, 1 });        assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);        assertEquals(1.0, optimum.getPoint()[1], 1.0e-8);    }    public void testInconsistentEquations() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 4.0 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 1, 1 });        assertTrue(optimum.getValue() > 0.1);    }    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {        Circle circle = new Circle();        circle.addPoint( 30.0,  68.0);        circle.addPoint( 50.0,  -6.0);        circle.addPoint(110.0, -20.0);        circle.addPoint( 35.0,  15.0);        circle.addPoint( 45.0,  97.0);        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-30, 1.0e-30));        BrentSolver solver = new BrentSolver();        solver.setAbsoluteAccuracy(1.0e-13);        solver.setRelativeAccuracy(1.0e-15);        optimizer.setLineSearchSolver(solver);        RealPointValuePair optimum =            optimizer.optimize(circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);        assertEquals(69.960161753, circle.getRadius(center), 1.0e-8);        assertEquals(96.075902096, center.x, 1.0e-8);        assertEquals(48.135167894, center.y, 1.0e-8);    }    private static class LinearProblem implements DifferentiableMultivariateRealFunction, Serializable {        private static final long serialVersionUID = 703247177355019415L;        final RealMatrix factors;        final double[] target;        public LinearProblem(double[][] factors, double[] target) {            this.factors = new BlockRealMatrix(factors);            this.target  = target;        }        private double[] gradient(double[] point) {            double[] r = factors.operate(point);            for (int i = 0; i < r.length; ++i) {                r[i] -= target[i];            }            double[] p = factors.transpose().operate(r);            for (int i = 0; i < p.length; ++i) {                p[i] *= 2;            }            return p;        }        public double value(double[] variables) throws FunctionEvaluationException {            double[] y = factors.operate(variables);            double sum = 0;            for (int i = 0; i < y.length; ++i) {                double ri = y[i] - target[i];                sum += ri * ri;            }            return sum;        }        public MultivariateVectorialFunction gradient() {            return new MultivariateVectorialFunction() {                private static final long serialVersionUID = 2621997811350805819L;                public double[] value(double[] point) {                    return gradient(point);                }            };        }        public MultivariateRealFunction partialDerivative(final int k) {            return new MultivariateRealFunction() {                private static final long serialVersionUID = -6186178619133562011L;                public double value(double[] point) {                    return gradient(point)[k];                }            };        }    }    private static class Circle implements DifferentiableMultivariateRealFunction, Serializable {        private static final long serialVersionUID = -4711170319243817874L;        private ArrayList<Point2D.Double> points;        public Circle() {            points  = new ArrayList<Point2D.Double>();        }        public void addPoint(double px, double py) {            points.add(new Point2D.Double(px, py));        }        public int getN() {            return points.size();        }        public double getRadius(Point2D.Double center) {            double r = 0;            for (Point2D.Double point : points) {                r += point.distance(center);            }            return r / points.size();        }        private double[] gradient(double[] point) {            // optimal radius            Point2D.Double center = new Point2D.Double(point[0], point[1]);            double radius = getRadius(center);            // gradient of the sum of squared residuals            double dJdX = 0;            double dJdY = 0;            for (Point2D.Double pk : points) {                double dk = pk.distance(center);                dJdX += (center.x - pk.x) * (dk - radius) / dk;                dJdY += (center.y - pk.y) * (dk - radius) / dk;            }            dJdX *= 2;            dJdY *= 2;            return new double[] { dJdX, dJdY };        }        public double value(double[] variables)                throws IllegalArgumentException, FunctionEvaluationException {            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);            double radius = getRadius(center);            double sum = 0;            for (Point2D.Double point : points) {                double di = point.distance(center) - radius;                sum += di * di;            }            return sum;        }        public MultivariateVectorialFunction gradient() {            return new MultivariateVectorialFunction() {                private static final long serialVersionUID = 3174909643301201710L;                public double[] value(double[] point) {                    return gradient(point);                }            };        }        public MultivariateRealFunction partialDerivative(final int k) {            return new MultivariateRealFunction() {                private static final long serialVersionUID = 3073956364104833888L;                public double value(double[] point) {                    return gradient(point)[k];                }            };        }    }    public static Test suite() {        return new TestSuite(NonLinearConjugateGradientOptimizerTest.class);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.general;import java.awt.geom.Point2D;import java.io.Serializable;import java.util.ArrayList;import java.util.Arrays;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;import org.apache.commons.math.analysis.MultivariateMatrixFunction;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.optimization.OptimizationException;import org.apache.commons.math.optimization.SimpleVectorialValueChecker;import org.apache.commons.math.optimization.VectorialPointValuePair;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files.  * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */public class GaussNewtonOptimizerTestextends TestCase {    public GaussNewtonOptimizerTest(String name) {        super(name);    }    public void testTrivial() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1 }, new double[] { 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);        assertEquals(3.0, optimum.getValue()[0], 1.0e-10);    }    public void testColumnsPermutation() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },                              new double[] { 4.0, 6.0, 1.0 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);        assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(4.0, optimum.getValue()[0], 1.0e-10);        assertEquals(6.0, optimum.getValue()[1], 1.0e-10);        assertEquals(1.0, optimum.getValue()[2], 1.0e-10);    }    public void testNoDependency() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 2, 0, 0, 0, 0, 0 },                { 0, 2, 0, 0, 0, 0 },                { 0, 0, 2, 0, 0, 0 },                { 0, 0, 0, 2, 0, 0 },                { 0, 0, 0, 0, 2, 0 },                { 0, 0, 0, 0, 0, 2 }        }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },                               new double[] { 0, 0, 0, 0, 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        for (int i = 0; i < problem.target.length; ++i) {            assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);        }    }    public void testOneSet() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                {  1,  0, 0 },                { -1,  1, 0 },                {  0, -1, 1 }        }, new double[] { 1, 1, 1});        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);        assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);    }    public void testTwoSets() throws FunctionEvaluationException, OptimizationException {        double epsilon = 1.0e-7;        LinearProblem problem = new LinearProblem(new double[][] {                {  2,  1,   0,  4,       0, 0 },                { -4, -2,   3, -7,       0, 0 },                {  4,  1,  -2,  8,       0, 0 },                {  0, -3, -12, -1,       0, 0 },                {  0,  0,   0,  0, epsilon, 1 },                {  0,  0,   0,  0,       1, 1 }        }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },                               new double[] { 0, 0, 0, 0, 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);        assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);        assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);        assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);        assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);    }    public void testNonInversible() {        LinearProblem problem = new LinearProblem(new double[][] {                {  1, 2, -3 },                {  2, 1,  3 },                { -3, 0, -9 }        }, new double[] { 1, 1, 1 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        try {            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });            fail("an exception should have been caught");        } catch (OptimizationException ee) {            // expected behavior        } catch (Exception e) {            fail("wrong exception type caught");        }    }    public void testIllConditioned() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem1 = new LinearProblem(new double[][] {                { 10.0, 7.0,  8.0,  7.0 },                {  7.0, 5.0,  6.0,  5.0 },                {  8.0, 6.0, 10.0,  9.0 },                {  7.0, 5.0,  9.0, 10.0 }        }, new double[] { 32, 23, 33, 31 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum1 =            optimizer.optimize(problem1, problem1.target, new double[] { 1, 1, 1, 1 },                               new double[] { 0, 1, 2, 3 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);        assertEquals(1.0, optimum1.getPoint()[1], 1.0e-10);        assertEquals(1.0, optimum1.getPoint()[2], 1.0e-10);        assertEquals(1.0, optimum1.getPoint()[3], 1.0e-10);        LinearProblem problem2 = new LinearProblem(new double[][] {                { 10.00, 7.00, 8.10, 7.20 },                {  7.08, 5.04, 6.00, 5.00 },                {  8.00, 5.98, 9.89, 9.00 },                {  6.99, 4.99, 9.00, 9.98 }        }, new double[] { 32, 23, 33, 31 });        VectorialPointValuePair optimum2 =            optimizer.optimize(problem2, problem2.target, new double[] { 1, 1, 1, 1 },                               new double[] { 0, 1, 2, 3 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);        assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8);        assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8);        assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);    }    public void testMoreEstimatedParametersSimple() {        LinearProblem problem = new LinearProblem(new double[][] {                { 3.0, 2.0,  0.0, 0.0 },                { 0.0, 1.0, -1.0, 1.0 },                { 2.0, 0.0,  1.0, 0.0 }        }, new double[] { 7.0, 3.0, 5.0 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        try {            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },                               new double[] { 7, 6, 5, 4 });            fail("an exception should have been caught");        } catch (OptimizationException ee) {            // expected behavior        } catch (Exception e) {            fail("wrong exception type caught");        }    }    public void testMoreEstimatedParametersUnsorted() {        LinearProblem problem = new LinearProblem(new double[][] {                 { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },                 { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },                 { 0.0, 0.0,  0.0,  0.0, 1.0, -1.0 },                 { 0.0, 0.0, -1.0,  1.0, 0.0,  1.0 },                 { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }        }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        try {            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1 },                               new double[] { 2, 2, 2, 2, 2, 2 });            fail("an exception should have been caught");        } catch (OptimizationException ee) {            // expected behavior        } catch (Exception e) {            fail("wrong exception type caught");        }    }    public void testRedundantEquations() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 5.0 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },                               new double[] { 1, 1 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);        assertEquals(1.0, optimum.getPoint()[1], 1.0e-8);    }    public void testInconsistentEquations() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 4.0 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });        assertTrue(optimizer.getRMS() > 0.1);    }    public void testInconsistentSizes() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(-1, optimum.getPoint()[0], 1.0e-10);        assertEquals(+1, optimum.getPoint()[1], 1.0e-10);        try {            optimizer.optimize(problem, problem.target,                               new double[] { 1 },                               new double[] { 0, 0 });            fail("an exception should have been thrown");        } catch (OptimizationException oe) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            optimizer.optimize(problem, new double[] { 1 },                               new double[] { 1 },                               new double[] { 0, 0 });            fail("an exception should have been thrown");        } catch (FunctionEvaluationException oe) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testMaxIterations() {        Circle circle = new Circle();        circle.addPoint( 30.0,  68.0);        circle.addPoint( 50.0,  -6.0);        circle.addPoint(110.0, -20.0);        circle.addPoint( 35.0,  15.0);        circle.addPoint( 45.0,  97.0);        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-15, 1.0e-15));        try {            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 },                               new double[] { 1, 1, 1, 1, 1 },                               new double[] { 98.680, 47.345 });            fail("an exception should have been caught");        } catch (OptimizationException ee) {            // expected behavior        } catch (Exception e) {            fail("wrong exception type caught");        }    }    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {        Circle circle = new Circle();        circle.addPoint( 30.0,  68.0);        circle.addPoint( 50.0,  -6.0);        circle.addPoint(110.0, -20.0);        circle.addPoint( 35.0,  15.0);        circle.addPoint( 45.0,  97.0);        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-13, 1.0e-13));        VectorialPointValuePair optimum =            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 },                               new double[] { 1, 1, 1, 1, 1 },                               new double[] { 98.680, 47.345 });        assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * optimizer.getRMS(),  1.0e-10);        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);        assertEquals(69.96016175359975, circle.getRadius(center), 1.0e-10);        assertEquals(96.07590209601095, center.x, 1.0e-10);        assertEquals(48.135167894714,   center.y, 1.0e-10);    }    public void testCircleFittingBadInit() throws FunctionEvaluationException, OptimizationException {        Circle circle = new Circle();        double[][] points = new double[][] {                {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},                {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},                {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},                {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},                { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},                { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},                {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},                {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},                {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},                {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},                {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},                { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},                { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},                {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},                {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},                {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},                {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},                {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},                { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},                { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},                { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},                {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},                {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},                {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},                {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},                {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},                { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},                { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},                {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}        };        double[] target = new double[points.length];        Arrays.fill(target, 0.0);        double[] weights = new double[points.length];        Arrays.fill(weights, 2.0);        for (int i = 0; i < points.length; ++i) {            circle.addPoint(points[i][0], points[i][1]);        }        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        try {            optimizer.optimize(circle, target, weights, new double[] { -12, -12 });            fail("an exception should have been caught");        } catch (OptimizationException ee) {            // expected behavior        } catch (Exception e) {            fail("wrong exception type caught");        }        VectorialPointValuePair optimum =            optimizer.optimize(circle, target, weights, new double[] { 0, 0 });        assertEquals(-0.1517383071957963, optimum.getPointRef()[0], 1.0e-8);        assertEquals(0.2074999736353867,  optimum.getPointRef()[1], 1.0e-8);        assertEquals(0.04268731682389561, optimizer.getRMS(),       1.0e-8);    }    private static class LinearProblem implements DifferentiableMultivariateVectorialFunction, Serializable {        private static final long serialVersionUID = -8804268799379350190L;        final RealMatrix factors;        final double[] target;        public LinearProblem(double[][] factors, double[] target) {            this.factors = new BlockRealMatrix(factors);            this.target  = target;        }        public double[] value(double[] variables) {            return factors.operate(variables);        }        public MultivariateMatrixFunction jacobian() {            return new MultivariateMatrixFunction() {                private static final long serialVersionUID = -8387467946663627585L;                public double[][] value(double[] point) {                    return factors.getData();                }            };        }    }    private static class Circle implements DifferentiableMultivariateVectorialFunction, Serializable {        private static final long serialVersionUID = -7165774454925027042L;        private ArrayList<Point2D.Double> points;        public Circle() {            points  = new ArrayList<Point2D.Double>();        }        public void addPoint(double px, double py) {            points.add(new Point2D.Double(px, py));        }        public int getN() {            return points.size();        }        public double getRadius(Point2D.Double center) {            double r = 0;            for (Point2D.Double point : points) {                r += point.distance(center);            }            return r / points.size();        }        private double[][] jacobian(double[] variables) {            int n = points.size();            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);            // gradient of the optimal radius            double dRdX = 0;            double dRdY = 0;            for (Point2D.Double pk : points) {                double dk = pk.distance(center);                dRdX += (center.x - pk.x) / dk;                dRdY += (center.y - pk.y) / dk;            }            dRdX /= n;            dRdY /= n;            // jacobian of the radius residuals            double[][] jacobian = new double[n][2];            for (int i = 0; i < n; ++i) {                Point2D.Double pi = points.get(i);                double di   = pi.distance(center);                jacobian[i][0] = (center.x - pi.x) / di - dRdX;                    jacobian[i][1] = (center.y - pi.y) / di - dRdY;               }            return jacobian;        }        public double[] value(double[] variables) {            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);            double radius = getRadius(center);            double[] residuals = new double[points.size()];            for (int i = 0; i < residuals.length; ++i) {                residuals[i] = points.get(i).distance(center) - radius;            }            return residuals;        }        public MultivariateMatrixFunction jacobian() {            return new MultivariateMatrixFunction() {                private static final long serialVersionUID = -4340046230875165095L;                public double[][] value(double[] point) {                    return jacobian(point);                }            };        }    }    public static Test suite() {        return new TestSuite(GaussNewtonOptimizerTest.class);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.general;import java.awt.geom.Point2D;import java.io.Serializable;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;import org.apache.commons.math.analysis.MultivariateMatrixFunction;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.optimization.OptimizationException;import org.apache.commons.math.optimization.SimpleVectorialValueChecker;import org.apache.commons.math.optimization.VectorialPointValuePair;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files.  * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */public class LevenbergMarquardtOptimizerTest  extends TestCase {    public LevenbergMarquardtOptimizerTest(String name) {        super(name);    }    public void testTrivial() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1 }, new double[] { 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        try {            optimizer.guessParametersErrors();            fail("an exception should have been thrown");        } catch (OptimizationException ee) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);        assertEquals(3.0, optimum.getValue()[0], 1.0e-10);    }    public void testQRColumnsPermutation() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },                              new double[] { 4.0, 6.0, 1.0 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);        assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(4.0, optimum.getValue()[0], 1.0e-10);        assertEquals(6.0, optimum.getValue()[1], 1.0e-10);        assertEquals(1.0, optimum.getValue()[2], 1.0e-10);    }    public void testNoDependency() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 2, 0, 0, 0, 0, 0 },                { 0, 2, 0, 0, 0, 0 },                { 0, 0, 2, 0, 0, 0 },                { 0, 0, 0, 2, 0, 0 },                { 0, 0, 0, 0, 2, 0 },                { 0, 0, 0, 0, 0, 2 }        }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },                               new double[] { 0, 0, 0, 0, 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        for (int i = 0; i < problem.target.length; ++i) {            assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);        }    }    public void testOneSet() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                {  1,  0, 0 },                { -1,  1, 0 },                {  0, -1, 1 }        }, new double[] { 1, 1, 1});        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);        assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);    }    public void testTwoSets() throws FunctionEvaluationException, OptimizationException {        double epsilon = 1.0e-7;        LinearProblem problem = new LinearProblem(new double[][] {                {  2,  1,   0,  4,       0, 0 },                { -4, -2,   3, -7,       0, 0 },                {  4,  1,  -2,  8,       0, 0 },                {  0, -3, -12, -1,       0, 0 },                {  0,  0,   0,  0, epsilon, 1 },                {  0,  0,   0,  0,       1, 1 }        }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },                               new double[] { 0, 0, 0, 0, 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);        assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);        assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);        assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);        assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);    }    public void testNonInversible() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                {  1, 2, -3 },                {  2, 1,  3 },                { -3, 0, -9 }        }, new double[] { 1, 1, 1 });         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });        assertTrue(Math.sqrt(problem.target.length) * optimizer.getRMS() > 0.6);        try {            optimizer.getCovariances();            fail("an exception should have been thrown");        } catch (OptimizationException ee) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testIllConditioned() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem1 = new LinearProblem(new double[][] {                { 10.0, 7.0,  8.0,  7.0 },                {  7.0, 5.0,  6.0,  5.0 },                {  8.0, 6.0, 10.0,  9.0 },                {  7.0, 5.0,  9.0, 10.0 }        }, new double[] { 32, 23, 33, 31 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum1 =            optimizer.optimize(problem1, problem1.target, new double[] { 1, 1, 1, 1 },                               new double[] { 0, 1, 2, 3 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);        assertEquals(1.0, optimum1.getPoint()[1], 1.0e-10);        assertEquals(1.0, optimum1.getPoint()[2], 1.0e-10);        assertEquals(1.0, optimum1.getPoint()[3], 1.0e-10);        LinearProblem problem2 = new LinearProblem(new double[][] {                { 10.00, 7.00, 8.10, 7.20 },                {  7.08, 5.04, 6.00, 5.00 },                {  8.00, 5.98, 9.89, 9.00 },                {  6.99, 4.99, 9.00, 9.98 }        }, new double[] { 32, 23, 33, 31 });        VectorialPointValuePair optimum2 =            optimizer.optimize(problem2, problem2.target, new double[] { 1, 1, 1, 1 },                               new double[] { 0, 1, 2, 3 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);        assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8);        assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8);        assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);    }    public void testMoreEstimatedParametersSimple() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 3.0, 2.0,  0.0, 0.0 },                { 0.0, 1.0, -1.0, 1.0 },                { 2.0, 0.0,  1.0, 0.0 }        }, new double[] { 7.0, 3.0, 5.0 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },                new double[] { 7, 6, 5, 4 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);    }    public void testMoreEstimatedParametersUnsorted() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },                { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },                { 0.0, 0.0,  0.0,  0.0, 1.0, -1.0 },                { 0.0, 0.0, -1.0,  1.0, 0.0,  1.0 },                { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }       }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1 },                               new double[] { 2, 2, 2, 2, 2, 2 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(3.0, optimum.getPointRef()[2], 1.0e-10);        assertEquals(4.0, optimum.getPointRef()[3], 1.0e-10);        assertEquals(5.0, optimum.getPointRef()[4], 1.0e-10);        assertEquals(6.0, optimum.getPointRef()[5], 1.0e-10);    }    public void testRedundantEquations() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 5.0 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },                               new double[] { 1, 1 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(2.0, optimum.getPointRef()[0], 1.0e-10);        assertEquals(1.0, optimum.getPointRef()[1], 1.0e-10);    }    public void testInconsistentEquations() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 4.0 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });        assertTrue(optimizer.getRMS() > 0.1);    }    public void testInconsistentSizes() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(-1, optimum.getPoint()[0], 1.0e-10);        assertEquals(+1, optimum.getPoint()[1], 1.0e-10);        try {            optimizer.optimize(problem, problem.target,                               new double[] { 1 },                               new double[] { 0, 0 });            fail("an exception should have been thrown");        } catch (OptimizationException oe) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            optimizer.optimize(problem, new double[] { 1 },                               new double[] { 1 },                               new double[] { 0, 0 });            fail("an exception should have been thrown");        } catch (FunctionEvaluationException oe) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testControlParameters() {        Circle circle = new Circle();        circle.addPoint( 30.0,  68.0);        circle.addPoint( 50.0,  -6.0);        circle.addPoint(110.0, -20.0);        circle.addPoint( 35.0,  15.0);        circle.addPoint( 45.0,  97.0);        checkEstimate(circle, 0.1, 10, 1.0e-14, 1.0e-16, 1.0e-10, false);        checkEstimate(circle, 0.1, 10, 1.0e-15, 1.0e-17, 1.0e-10, true);        checkEstimate(circle, 0.1,  5, 1.0e-15, 1.0e-16, 1.0e-10, true);        circle.addPoint(300, -300);        checkEstimate(circle, 0.1, 20, 1.0e-18, 1.0e-16, 1.0e-10, true);    }    private void checkEstimate(DifferentiableMultivariateVectorialFunction problem,                               double initialStepBoundFactor, int maxCostEval,                               double costRelativeTolerance, double parRelativeTolerance,                               double orthoTolerance, boolean shouldFail) {        try {            LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();            optimizer.setInitialStepBoundFactor(initialStepBoundFactor);            optimizer.setMaxIterations(maxCostEval);            optimizer.setCostRelativeTolerance(costRelativeTolerance);            optimizer.setParRelativeTolerance(parRelativeTolerance);            optimizer.setOrthoTolerance(orthoTolerance);            optimizer.optimize(problem, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },                               new double[] { 98.680, 47.345 });            assertTrue(! shouldFail);        } catch (OptimizationException ee) {            assertTrue(shouldFail);        } catch (FunctionEvaluationException ee) {            assertTrue(shouldFail);        } catch (Exception e) {            fail("wrong exception type caught");        }    }    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {        Circle circle = new Circle();        circle.addPoint( 30.0,  68.0);        circle.addPoint( 50.0,  -6.0);        circle.addPoint(110.0, -20.0);        circle.addPoint( 35.0,  15.0);        circle.addPoint( 45.0,  97.0);        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },                               new double[] { 98.680, 47.345 });        assertTrue(optimizer.getEvaluations() < 10);        assertTrue(optimizer.getJacobianEvaluations() < 10);        double rms = optimizer.getRMS();        assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);        assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);        assertEquals(96.07590211815305, center.x,      1.0e-10);        assertEquals(48.13516790438953, center.y,      1.0e-10);        double[][] cov = optimizer.getCovariances();        assertEquals(1.839, cov[0][0], 0.001);        assertEquals(0.731, cov[0][1], 0.001);        assertEquals(cov[0][1], cov[1][0], 1.0e-14);        assertEquals(0.786, cov[1][1], 0.001);        double[] errors = optimizer.guessParametersErrors();        assertEquals(1.384, errors[0], 0.001);        assertEquals(0.905, errors[1], 0.001);        // add perfect measurements and check errors are reduced        double  r = circle.getRadius(center);        for (double d= 0; d < 2 * Math.PI; d += 0.01) {            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));        }        double[] target = new double[circle.getN()];        Arrays.fill(target, 0.0);        double[] weights = new double[circle.getN()];        Arrays.fill(weights, 2.0);        optimum =            optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });        cov = optimizer.getCovariances();        assertEquals(0.0016, cov[0][0], 0.001);        assertEquals(3.2e-7, cov[0][1], 1.0e-9);        assertEquals(cov[0][1], cov[1][0], 1.0e-14);        assertEquals(0.0016, cov[1][1], 0.001);        errors = optimizer.guessParametersErrors();        assertEquals(0.002, errors[0], 0.001);        assertEquals(0.002, errors[1], 0.001);    }    public void testCircleFittingBadInit() throws FunctionEvaluationException, OptimizationException {        Circle circle = new Circle();        double[][] points = new double[][] {                {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},                {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},                {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},                {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},                { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},                { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},                {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},                {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},                {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},                {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},                {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},                { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},                { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},                {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},                {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},                {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},                {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},                {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},                { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},                { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},                { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},                {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},                {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},                {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},                {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},                {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},                { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},                { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},                {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}        };        double[] target = new double[points.length];        Arrays.fill(target, 0.0);        double[] weights = new double[points.length];        Arrays.fill(weights, 2.0);        for (int i = 0; i < points.length; ++i) {            circle.addPoint(points[i][0], points[i][1]);        }        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-10, 1.0e-10));        VectorialPointValuePair optimum =            optimizer.optimize(circle, target, weights, new double[] { -12, -12 });        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);        assertTrue(optimizer.getEvaluations() < 25);        assertTrue(optimizer.getJacobianEvaluations() < 20);        assertEquals( 0.043, optimizer.getRMS(), 1.0e-3);        assertEquals( 0.292235,  circle.getRadius(center), 1.0e-6);        assertEquals(-0.151738,  center.x,      1.0e-6);        assertEquals( 0.2075001, center.y,      1.0e-6);    }    public void testMath199() throws FunctionEvaluationException {        try {            QuadraticProblem problem = new QuadraticProblem();            problem.addPoint (0, -3.182591015485607);            problem.addPoint (1, -2.5581184967730577);            problem.addPoint (2, -2.1488478161387325);            problem.addPoint (3, -1.9122489313410047);            problem.addPoint (4, 1.7785661310051026);            new LevenbergMarquardtOptimizer().optimize(problem,                                                       new double[] { 0, 0, 0, 0, 0 },                                                       new double[] { 0.0, 4.4e-323, 1.0, 4.4e-323, 0.0 },                                                       new double[] { 0, 0, 0 });            fail("an exception should have been thrown");        } catch (OptimizationException ee) {            // expected behavior        }    }    private static class LinearProblem implements DifferentiableMultivariateVectorialFunction, Serializable {        private static final long serialVersionUID = 703247177355019415L;        final RealMatrix factors;        final double[] target;        public LinearProblem(double[][] factors, double[] target) {            this.factors = new BlockRealMatrix(factors);            this.target  = target;        }        public double[] value(double[] variables) {            return factors.operate(variables);        }        public MultivariateMatrixFunction jacobian() {            return new MultivariateMatrixFunction() {                private static final long serialVersionUID = 556396458721526234L;                public double[][] value(double[] point) {                    return factors.getData();                }            };        }    }    private static class Circle implements DifferentiableMultivariateVectorialFunction, Serializable {        private static final long serialVersionUID = -4711170319243817874L;        private ArrayList<Point2D.Double> points;        public Circle() {            points  = new ArrayList<Point2D.Double>();        }        public void addPoint(double px, double py) {            points.add(new Point2D.Double(px, py));        }        public int getN() {            return points.size();        }        public double getRadius(Point2D.Double center) {            double r = 0;            for (Point2D.Double point : points) {                r += point.distance(center);            }            return r / points.size();        }        private double[][] jacobian(double[] point) {            int n = points.size();            Point2D.Double center = new Point2D.Double(point[0], point[1]);            // gradient of the optimal radius            double dRdX = 0;            double dRdY = 0;            for (Point2D.Double pk : points) {                double dk = pk.distance(center);                dRdX += (center.x - pk.x) / dk;                dRdY += (center.y - pk.y) / dk;            }            dRdX /= n;            dRdY /= n;            // jacobian of the radius residuals            double[][] jacobian = new double[n][2];            for (int i = 0; i < n; ++i) {                Point2D.Double pi = points.get(i);                double di   = pi.distance(center);                jacobian[i][0] = (center.x - pi.x) / di - dRdX;                    jacobian[i][1] = (center.y - pi.y) / di - dRdY;                }            return jacobian;        }        public double[] value(double[] variables)        throws FunctionEvaluationException, IllegalArgumentException {            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);            double radius = getRadius(center);            double[] residuals = new double[points.size()];            for (int i = 0; i < residuals.length; ++i) {                residuals[i] = points.get(i).distance(center) - radius;            }            return residuals;        }        public MultivariateMatrixFunction jacobian() {            return new MultivariateMatrixFunction() {                private static final long serialVersionUID = -4340046230875165095L;                public double[][] value(double[] point) {                    return jacobian(point);                }            };        }    }    private static class QuadraticProblem implements DifferentiableMultivariateVectorialFunction, Serializable {        private static final long serialVersionUID = 7072187082052755854L;        private List<Double> x;        private List<Double> y;        public QuadraticProblem() {            x = new ArrayList<Double>();            y = new ArrayList<Double>();        }        public void addPoint(double x, double y) {            this.x.add(x);            this.y.add(y);        }        private double[][] jacobian(double[] variables) {            double[][] jacobian = new double[x.size()][3];            for (int i = 0; i < jacobian.length; ++i) {                jacobian[i][0] = x.get(i) * x.get(i);                jacobian[i][1] = x.get(i);                jacobian[i][2] = 1.0;            }            return jacobian;        }        public double[] value(double[] variables) {            double[] values = new double[x.size()];            for (int i = 0; i < values.length; ++i) {                values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];            }            return values;        }        public MultivariateMatrixFunction jacobian() {            return new MultivariateMatrixFunction() {                private static final long serialVersionUID = -8673650298627399464L;                public double[][] value(double[] point) {                    return jacobian(point);                }            };        }    }    public static Test suite() {        return new TestSuite(LevenbergMarquardtOptimizerTest.class);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.general;import java.io.Serializable;import java.util.Arrays;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;import org.apache.commons.math.analysis.MultivariateMatrixFunction;import org.apache.commons.math.optimization.OptimizationException;import org.apache.commons.math.optimization.VectorialPointValuePair;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files.  * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */public class MinpackTest extends TestCase {  public MinpackTest(String name) {    super(name);  }  public void testMinpackLinearFullRank() {    minpackTest(new LinearFullRankFunction(10, 5, 1.0,                                           5.0, 2.23606797749979), false);    minpackTest(new LinearFullRankFunction(50, 5, 1.0,                                           8.06225774829855, 6.70820393249937), false);  }  public void testMinpackLinearRank1() {    minpackTest(new LinearRank1Function(10, 5, 1.0,                                        291.521868819476, 1.4638501094228), false);    minpackTest(new LinearRank1Function(50, 5, 1.0,                                        3101.60039334535, 3.48263016573496), false);  }  public void testMinpackLinearRank1ZeroColsAndRows() {    minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false);    minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false);  }  public void testMinpackRosenbrok() {    minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },                                       Math.sqrt(24.2)), false);    minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 },                                       Math.sqrt(1795769.0)), false);    minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 },                                       11.0 * Math.sqrt(169000121.0)), false);  }  public void testMinpackHelicalValley() {    minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 },                                          50.0), false);    minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 },                                          102.95630140987), false);    minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0},                                          991.261822123701), false);  }      public void testMinpackPowellSingular() {    minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },                                           14.6628782986152), false);    minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 },                                           1270.9838708654), false);    minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 },                                           126887.903284750), false);  }      public void testMinpackFreudensteinRoth() {    minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },                                             20.0124960961895, 6.99887517584575,                                             new double[] {                                               11.4124844654993,                                               -0.896827913731509                                             }), false);    minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },                                             12432.833948863, 6.9988751744895,                                             new double[] {                                               11.4130046614746,                                               -0.896796038685958                                             }), false);    minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },                                             11426454.595762, 6.99887517242903,                                             new double[] {                                               11.4127817857886,                                               -0.89680510749204                                             }), false);  }      public void testMinpackBard() {    minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,                                 new double[] {                                   0.0824105765758334,                                   1.1330366534715,                                   2.34369463894115                                 }), false);    minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539,                                 new double[] {                                   0.840666673818329,                                   -158848033.259565,                                   -164378671.653535                                 }), false);    minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969,                                 new double[] {                                   0.840666673867645,                                   -158946167.205518,                                   -164464906.857771                                 }), false);  }      public void testMinpackKowalikOsborne() {    minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },                                           0.0728915102882945,                                           0.017535837721129,                                           new double[] {                                             0.192807810476249,                                             0.191262653354071,                                             0.123052801046931,                                             0.136053221150517                                           }), false);    minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 },                                           2.97937007555202,                                           0.032052192917937,                                           new double[] {                                             728675.473768287,                                             -14.0758803129393,                                             -32977797.7841797,                                             -20571594.1977912                                           }), false);    minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 },                                           29.9590617016037,                                           0.0175364017658228,                                           new double[] {                                             0.192948328597594,                                             0.188053165007911,                                             0.122430604321144,                                             0.134575665392506                                           }), false);  }      public void testMinpackMeyer() {    minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },                                  41153.4665543031, 9.37794514651874,                                  new double[] {                                    0.00560963647102661,                                    6181.34634628659,                                    345.223634624144                                  }), false);    minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 },                                  4168216.89130846, 792.917871779501,                                  new double[] {                                    1.42367074157994e-11,                                    33695.7133432541,                                    901.268527953801                                  }), true);  }      public void testMinpackWatson() {      minpackTest(new WatsonFunction(6, 0.0,                                   5.47722557505166, 0.0478295939097601,                                   new double[] {                                     -0.0157249615083782, 1.01243488232965,                                     -0.232991722387673,  1.26043101102818,                                     -1.51373031394421,   0.99299727291842                                   }), false);    minpackTest(new WatsonFunction(6, 10.0,                                   6433.12578950026, 0.0478295939096951,                                   new double[] {                                     -0.0157251901386677, 1.01243485860105,                                     -0.232991545843829,  1.26042932089163,                                     -1.51372776706575,   0.99299573426328                                   }), false);    minpackTest(new WatsonFunction(6, 100.0,                                   674256.040605213, 0.047829593911544,                                   new double[] {                                    -0.0157247019712586, 1.01243490925658,                                    -0.232991922761641,  1.26043292929555,                                    -1.51373320452707,   0.99299901922322                                   }), false);    minpackTest(new WatsonFunction(9, 0.0,                                   5.47722557505166, 0.00118311459212420,                                   new double[] {                                    -0.153070644166722e-4, 0.999789703934597,                                     0.0147639634910978,   0.146342330145992,                                     1.00082109454817,    -2.61773112070507,                                     4.10440313943354,    -3.14361226236241,                                     1.05262640378759                                   }), false);    minpackTest(new WatsonFunction(9, 10.0,                                   12088.127069307, 0.00118311459212513,                                   new double[] {                                   -0.153071334849279e-4, 0.999789703941234,                                    0.0147639629786217,   0.146342334818836,                                    1.00082107321386,    -2.61773107084722,                                    4.10440307655564,    -3.14361222178686,                                    1.05262639322589                                   }), false);    minpackTest(new WatsonFunction(9, 100.0,                                   1269109.29043834, 0.00118311459212384,                                   new double[] {                                    -0.153069523352176e-4, 0.999789703958371,                                     0.0147639625185392,   0.146342341096326,                                     1.00082104729164,    -2.61773101573645,                                     4.10440301427286,    -3.14361218602503,                                     1.05262638516774                                   }), false);    minpackTest(new WatsonFunction(12, 0.0,                                   5.47722557505166, 0.217310402535861e-4,                                   new double[] {                                    -0.660266001396382e-8, 1.00000164411833,                                    -0.000563932146980154, 0.347820540050756,                                    -0.156731500244233,    1.05281515825593,                                    -3.24727109519451,     7.2884347837505,                                   -10.271848098614,       9.07411353715783,                                    -4.54137541918194,     1.01201187975044                                   }), false);    minpackTest(new WatsonFunction(12, 10.0,                                   19220.7589790951, 0.217310402518509e-4,                                   new double[] {                                    -0.663710223017410e-8, 1.00000164411787,                                    -0.000563932208347327, 0.347820540486998,                                    -0.156731503955652,    1.05281517654573,                                    -3.2472711515214,      7.28843489430665,                                   -10.2718482369638,      9.07411364383733,                                    -4.54137546533666,     1.01201188830857                                   }), false);    minpackTest(new WatsonFunction(12, 100.0,                                   2018918.04462367, 0.217310402539845e-4,                                   new double[] {                                    -0.663806046485249e-8, 1.00000164411786,                                    -0.000563932210324959, 0.347820540503588,                                    -0.156731504091375,    1.05281517718031,                                    -3.24727115337025,     7.28843489775302,                                   -10.2718482410813,      9.07411364688464,                                    -4.54137546660822,     1.0120118885369                                   }), false);  }      public void testMinpackBox3Dimensional() {    minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },                                            32.1115837449572), false);  }      public void testMinpackJennrichSampson() {    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },                                            64.5856498144943, 11.1517793413499,                                            new double[] {                                             0.257819926636811, 0.257829976764542                                            }), false);  }  public void testMinpackBrownDennis() {    minpackTest(new BrownDennisFunction(20,                                        new double[] { 25.0, 5.0, -5.0, -1.0 },                                        2815.43839161816, 292.954288244866,                                        new double[] {                                         -11.59125141003, 13.2024883984741,                                         -0.403574643314272, 0.236736269844604                                        }), false);    minpackTest(new BrownDennisFunction(20,                                        new double[] { 250.0, 50.0, -50.0, -10.0 },                                        555073.354173069, 292.954270581415,                                        new double[] {                                         -11.5959274272203, 13.2041866926242,                                         -0.403417362841545, 0.236771143410386                                       }), false);    minpackTest(new BrownDennisFunction(20,                                        new double[] { 2500.0, 500.0, -500.0, -100.0 },                                        61211252.2338581, 292.954306151134,                                        new double[] {                                         -11.5902596937374, 13.2020628854665,                                         -0.403688070279258, 0.236665033746463                                        }), false);  }      public void testMinpackChebyquad() {    minpackTest(new ChebyquadFunction(1, 8, 1.0,                                      1.88623796907732, 1.88623796907732,                                      new double[] { 0.5 }), false);    minpackTest(new ChebyquadFunction(1, 8, 10.0,                                      5383344372.34005, 1.88424820499951,                                      new double[] { 0.9817314924684 }), false);    minpackTest(new ChebyquadFunction(1, 8, 100.0,                                      0.118088726698392e19, 1.88424820499347,                                      new double[] { 0.9817314852934 }), false);    minpackTest(new ChebyquadFunction(8, 8, 1.0,                                      0.196513862833975, 0.0593032355046727,                                      new double[] {                                        0.0431536648587336, 0.193091637843267,                                        0.266328593812698,  0.499999334628884,                                        0.500000665371116,  0.733671406187302,                                        0.806908362156733,  0.956846335141266                                      }), false);    minpackTest(new ChebyquadFunction(9, 9, 1.0,                                      0.16994993465202, 0.0,                                      new double[] {                                        0.0442053461357828, 0.199490672309881,                                        0.23561910847106,   0.416046907892598,                                        0.5,                0.583953092107402,                                        0.764380891528940,  0.800509327690119,                                        0.955794653864217                                      }), false);    minpackTest(new ChebyquadFunction(10, 10, 1.0,                                      0.183747831178711, 0.0806471004038253,                                      new double[] {                                        0.0596202671753563, 0.166708783805937,                                        0.239171018813509,  0.398885290346268,                                        0.398883667870681,  0.601116332129320,                                        0.60111470965373,   0.760828981186491,                                        0.833291216194063,  0.940379732824644                                      }), false);  }      public void testMinpackBrownAlmostLinear() {    minpackTest(new BrownAlmostLinearFunction(10, 0.5,                                              16.5302162063499, 0.0,                                              new double[] {                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 1.20569696650138                                              }), false);    minpackTest(new BrownAlmostLinearFunction(10, 5.0,                                              9765624.00089211, 0.0,                                              new double[] {                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 1.20569696650135                                              }), false);      minpackTest(new BrownAlmostLinearFunction(10, 50.0,                                              0.9765625e17, 0.0,                                              new double[] {                                                1.0, 1.0, 1.0, 1.0, 1.0,                                                1.0, 1.0, 1.0, 1.0, 1.0                                              }), false);    minpackTest(new BrownAlmostLinearFunction(30, 0.5,                                              83.476044467848, 0.0,                                              new double[] {                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 1.06737350671578                                              }), false);    minpackTest(new BrownAlmostLinearFunction(40, 0.5,                                              128.026364472323, 0.0,                                              new double[] {                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                0.999999999999121                                              }), false);    }      public void testMinpackOsborne1() {      minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },                                       0.937564021037838, 0.00739249260904843,                                       new double[] {                                         0.375410049244025, 1.93584654543108,                                        -1.46468676748716, 0.0128675339110439,                                         0.0221227011813076                                       }), false);    }      public void testMinpackOsborne2() {          minpackTest(new Osborne2Function(new double[] {                                       1.3, 0.65, 0.65, 0.7, 0.6,                                       3.0, 5.0, 7.0, 2.0, 4.5, 5.5                                     },                                     1.44686540984712, 0.20034404483314,                                     new double[] {                                       1.30997663810096,  0.43155248076,                                       0.633661261602859, 0.599428560991695,                                       0.754179768272449, 0.904300082378518,                                       1.36579949521007, 4.82373199748107,                                       2.39868475104871, 4.56887554791452,                                       5.67534206273052                                     }), false);  }  private void minpackTest(MinpackFunction function, boolean exceptionExpected) {      LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();      optimizer.setMaxIterations(100 * (function.getN() + 1));      optimizer.setCostRelativeTolerance(Math.sqrt(2.22044604926e-16));      optimizer.setParRelativeTolerance(Math.sqrt(2.22044604926e-16));      optimizer.setOrthoTolerance(2.22044604926e-16);//      assertTrue(function.checkTheoreticalStartCost(optimizer.getRMS()));      try {          VectorialPointValuePair optimum =              optimizer.optimize(function,                                 function.getTarget(), function.getWeight(),                                 function.getStartPoint());          assertFalse(exceptionExpected);          assertTrue(function.checkTheoreticalMinCost(optimizer.getRMS()));          assertTrue(function.checkTheoreticalMinParams(optimum));      } catch (OptimizationException lsse) {          assertTrue(exceptionExpected);      } catch (FunctionEvaluationException fe) {          assertTrue(exceptionExpected);      }  }  private static abstract class MinpackFunction      implements DifferentiableMultivariateVectorialFunction, Serializable {       private static final long serialVersionUID = -6209760235478794233L;      protected int      n;      protected int      m;      protected double[] startParams;      protected double   theoreticalMinCost;      protected double[] theoreticalMinParams;      protected double   costAccuracy;      protected double   paramsAccuracy;      protected MinpackFunction(int m, double[] startParams,                                double theoreticalMinCost, double[] theoreticalMinParams) {          this.m = m;          this.n = startParams.length;          this.startParams          = startParams.clone();          this.theoreticalMinCost   = theoreticalMinCost;          this.theoreticalMinParams = theoreticalMinParams;          this.costAccuracy         = 1.0e-8;          this.paramsAccuracy       = 1.0e-5;      }      protected static double[] buildArray(int n, double x) {          double[] array = new double[n];          Arrays.fill(array, x);          return array;      }      public double[] getTarget() {          return buildArray(m, 0.0);      }      public double[] getWeight() {          return buildArray(m, 1.0);      }      public double[] getStartPoint() {          return startParams.clone();      }      protected void setCostAccuracy(double costAccuracy) {          this.costAccuracy = costAccuracy;      }      protected void setParamsAccuracy(double paramsAccuracy) {          this.paramsAccuracy = paramsAccuracy;      }      public int getN() {          return startParams.length;      }      public boolean checkTheoreticalMinCost(double rms) {          double threshold = costAccuracy * (1.0 + theoreticalMinCost);          return Math.abs(Math.sqrt(m) * rms - theoreticalMinCost) <= threshold;      }      public boolean checkTheoreticalMinParams(VectorialPointValuePair optimum) {          double[] params = optimum.getPointRef();          if (theoreticalMinParams != null) {              for (int i = 0; i < theoreticalMinParams.length; ++i) {                  double mi = theoreticalMinParams[i];                  double vi = params[i];                  if (Math.abs(mi - vi) > (paramsAccuracy * (1.0 + Math.abs(mi)))) {                      return false;                  }              }          }          return true;      }      public MultivariateMatrixFunction jacobian() {          return new MultivariateMatrixFunction() {            private static final long serialVersionUID = -2435076097232923678L;            public double[][] value(double[] point) {                  return jacobian(point);              }          };      }      public abstract double[][] jacobian(double[] variables);      public abstract double[] value(double[] variables);  }  private static class LinearFullRankFunction extends MinpackFunction {    private static final long serialVersionUID = -9030323226268039536L;    public LinearFullRankFunction(int m, int n, double x0,                                  double theoreticalStartCost,                                  double theoreticalMinCost) {      super(m, buildArray(n, x0), theoreticalMinCost,            buildArray(n, -1.0));    }    @Override    public double[][] jacobian(double[] variables) {      double t = 2.0 / m;      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = (i == j) ? (1 - t) : -t;        }      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double sum = 0;      for (int i = 0; i < n; ++i) {        sum += variables[i];      }      double t  = 1 + 2 * sum / m;      double[] f = new double[m];      for (int i = 0; i < n; ++i) {        f[i] = variables[i] - t;      }      Arrays.fill(f, n, m, -t);      return f;    }  }  private static class LinearRank1Function extends MinpackFunction {    private static final long serialVersionUID = 8494863245104608300L;    public LinearRank1Function(int m, int n, double x0,                                  double theoreticalStartCost,                                  double theoreticalMinCost) {      super(m, buildArray(n, x0), theoreticalMinCost, null);    }    @Override    public double[][] jacobian(double[] variables) {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = (i + 1) * (j + 1);        }      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double[] f = new double[m];      double sum = 0;      for (int i = 0; i < n; ++i) {        sum += (i + 1) * variables[i];      }      for (int i = 0; i < m; ++i) {        f[i] = (i + 1) * sum - 1;      }      return f;    }  }  private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction {    private static final long serialVersionUID = -3316653043091995018L;    public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {      super(m, buildArray(n, x0),            Math.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),            null);    }    @Override    public double[][] jacobian(double[] variables) {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        jacobian[i][0] = 0;        for (int j = 1; j < (n - 1); ++j) {          if (i == 0) {            jacobian[i][j] = 0;          } else if (i != (m - 1)) {            jacobian[i][j] = i * (j + 1);          } else {            jacobian[i][j] = 0;          }        }        jacobian[i][n - 1] = 0;      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double[] f = new double[m];      double sum = 0;      for (int i = 1; i < (n - 1); ++i) {        sum += (i + 1) * variables[i];      }      for (int i = 0; i < (m - 1); ++i) {        f[i] = i * sum - 1;      }      f[m - 1] = -1;      return f;    }  }  private static class RosenbrockFunction extends MinpackFunction {    private static final long serialVersionUID = 2893438180956569134L;    public RosenbrockFunction(double[] startParams, double theoreticalStartCost) {      super(2, startParams, 0.0, buildArray(2, 1.0));    }    @Override    public double[][] jacobian(double[] variables) {      double x1 = variables[0];      return new double[][] { { -20 * x1, 10 }, { -1, 0 } };    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      return new double[] { 10 * (x2 - x1 * x1), 1 - x1 };    }  }  private static class HelicalValleyFunction extends MinpackFunction {    private static final long serialVersionUID = 220613787843200102L;    public HelicalValleyFunction(double[] startParams,                                 double theoreticalStartCost) {      super(3, startParams, 0.0, new double[] { 1.0, 0.0, 0.0 });    }    @Override    public double[][] jacobian(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double tmpSquare = x1 * x1 + x2 * x2;      double tmp1 = twoPi * tmpSquare;      double tmp2 = Math.sqrt(tmpSquare);      return new double[][] {        {  100 * x2 / tmp1, -100 * x1 / tmp1, 10 },        { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 },        { 0, 0, 1 }      };    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double tmp1;      if (x1 == 0) {        tmp1 = (x2 >= 0) ? 0.25 : -0.25;      } else {        tmp1 = Math.atan(x2 / x1) / twoPi;        if (x1 < 0) {          tmp1 += 0.5;        }      }      double tmp2 = Math.sqrt(x1 * x1 + x2 * x2);      return new double[] {        10.0 * (x3 - 10 * tmp1),        10.0 * (tmp2 - 1),        x3      };    }    private static final double twoPi = 2.0 * Math.PI;  }  private static class PowellSingularFunction extends MinpackFunction {    private static final long serialVersionUID = 7298364171208142405L;    public PowellSingularFunction(double[] startParams,                                  double theoreticalStartCost) {      super(4, startParams, 0.0, buildArray(4, 0.0));    }    @Override    public double[][] jacobian(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double x4 = variables[3];      return new double[][] {        { 1, 10, 0, 0 },        { 0, 0, sqrt5, -sqrt5 },        { 0, 2 * (x2 - 2 * x3), -4 * (x2 - 2 * x3), 0 },        { 2 * sqrt10 * (x1 - x4), 0, 0, -2 * sqrt10 * (x1 - x4) }      };    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double x4 = variables[3];      return new double[] {        x1 + 10 * x2,        sqrt5 * (x3 - x4),        (x2 - 2 * x3) * (x2 - 2 * x3),        sqrt10 * (x1 - x4) * (x1 - x4)      };    }    private static final double sqrt5  = Math.sqrt( 5.0);    private static final double sqrt10 = Math.sqrt(10.0);  }  private static class FreudensteinRothFunction extends MinpackFunction {    private static final long serialVersionUID = 2892404999344244214L;    public FreudensteinRothFunction(double[] startParams,                                    double theoreticalStartCost,                                    double theoreticalMinCost,                                    double[] theoreticalMinParams) {      super(2, startParams, theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double x2 = variables[1];      return new double[][] {        { 1, x2 * (10 - 3 * x2) -  2 },        { 1, x2 * ( 2 + 3 * x2) - 14, }      };    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      return new double[] {       -13.0 + x1 + ((5.0 - x2) * x2 -  2.0) * x2,       -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2      };    }  }  private static class BardFunction extends MinpackFunction {    private static final long serialVersionUID = 5990442612572087668L;    public BardFunction(double x0,                        double theoreticalStartCost,                        double theoreticalMinCost,                        double[] theoreticalMinParams) {      super(15, buildArray(3, x0), theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double   x2 = variables[1];      double   x3 = variables[2];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp1 = i  + 1;        double tmp2 = 15 - i;        double tmp3 = (i <= 7) ? tmp1 : tmp2;        double tmp4 = x2 * tmp2 + x3 * tmp3;        tmp4 *= tmp4;        jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double   x3 = variables[2];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double tmp1 = i + 1;        double tmp2 = 15 - i;        double tmp3 = (i <= 7) ? tmp1 : tmp2;        f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3));      }      return f;    }    private static final double[] y = {      0.14, 0.18, 0.22, 0.25, 0.29,      0.32, 0.35, 0.39, 0.37, 0.58,      0.73, 0.96, 1.34, 2.10, 4.39    };  }  private static class KowalikOsborneFunction extends MinpackFunction {    private static final long serialVersionUID = -4867445739880495801L;    public KowalikOsborneFunction(double[] startParams,                                  double theoreticalStartCost,                                  double theoreticalMinCost,                                  double[] theoreticalMinParams) {      super(11, startParams, theoreticalMinCost,            theoreticalMinParams);      if (theoreticalStartCost > 20.0) {        setCostAccuracy(2.0e-4);        setParamsAccuracy(5.0e-3);      }    }    @Override    public double[][] jacobian(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double   x3 = variables[2];      double   x4 = variables[3];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp = v[i] * (v[i] + x3) + x4;        double j1  = -v[i] * (v[i] + x2) / tmp;        double j2  = -v[i] * x1 / tmp;        double j3  = j1 * j2;        double j4  = j3 / v[i];        jacobian[i] = new double[] { j1, j2, j3, j4 };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double x4 = variables[3];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4);      }      return f;    }    private static final double[] v = {      4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625    };    private static final double[] y = {      0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627,      0.0456, 0.0342, 0.0323, 0.0235, 0.0246    };  }  private static class MeyerFunction extends MinpackFunction {    private static final long serialVersionUID = -838060619150131027L;    public MeyerFunction(double[] startParams,                         double theoreticalStartCost,                         double theoreticalMinCost,                         double[] theoreticalMinParams) {      super(16, startParams, theoreticalMinCost,            theoreticalMinParams);      if (theoreticalStartCost > 1.0e6) {        setCostAccuracy(7.0e-3);        setParamsAccuracy(2.0e-2);      }    }    @Override    public double[][] jacobian(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double   x3 = variables[2];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = 5.0 * (i + 1) + 45.0 + x3;        double tmp1 = x2 / temp;        double tmp2 = Math.exp(tmp1);        double tmp3 = x1 * tmp2 / temp;        jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        f[i] = x1 * Math.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];      }     return f;    }    private static final double[] y = {      34780.0, 28610.0, 23650.0, 19630.0,      16370.0, 13720.0, 11540.0,  9744.0,       8261.0,  7030.0,  6005.0,  5147.0,       4427.0,  3820.0,  3307.0,  2872.0                      };  }  private static class WatsonFunction extends MinpackFunction {    private static final long serialVersionUID = -9034759294980218927L;    public WatsonFunction(int n, double x0,                          double theoreticalStartCost,                          double theoreticalMinCost,                          double[] theoreticalMinParams) {      super(31, buildArray(n, x0), theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double[][] jacobian = new double[m][];      for (int i = 0; i < (m - 2); ++i) {        double div = (i + 1) / 29.0;        double s2  = 0.0;        double dx  = 1.0;        for (int j = 0; j < n; ++j) {          s2 += dx * variables[j];          dx *= div;        }        double temp= 2 * div * s2;        dx = 1.0 / div;        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = dx * (j - temp);          dx *= div;        }      }      jacobian[m - 2]    = new double[n];      jacobian[m - 2][0] = 1;      jacobian[m - 1]   = new double[n];      jacobian[m - 1][0]= -2 * variables[0];      jacobian[m - 1][1]= 1;      return jacobian;    }    @Override    public double[] value(double[] variables) {     double[] f = new double[m];     for (int i = 0; i < (m - 2); ++i) {       double div = (i + 1) / 29.0;       double s1 = 0;       double dx = 1;       for (int j = 1; j < n; ++j) {         s1 += j * dx * variables[j];         dx *= div;       }       double s2 =0;       dx =1;       for (int j = 0; j < n; ++j) {         s2 += dx * variables[j];         dx *= div;       }       f[i] = s1 - s2 * s2 - 1;     }     double x1 = variables[0];     double x2 = variables[1];     f[m - 2] = x1;     f[m - 1] = x2 - x1 * x1 - 1;     return f;    }  }  private static class Box3DimensionalFunction extends MinpackFunction {    private static final long serialVersionUID = 5511403858142574493L;    public Box3DimensionalFunction(int m, double[] startParams,                                   double theoreticalStartCost) {      super(m, startParams, 0.0,            new double[] { 1.0, 10.0, 1.0 });   }    @Override    public double[][] jacobian(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp = (i + 1) / 10.0;        jacobian[i] = new double[] {          -tmp * Math.exp(-tmp * x1),           tmp * Math.exp(-tmp * x2),          Math.exp(-i - 1) - Math.exp(-tmp)        };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double tmp = (i + 1) / 10.0;        f[i] = Math.exp(-tmp * x1) - Math.exp(-tmp * x2)             + (Math.exp(-i - 1) - Math.exp(-tmp)) * x3;      }      return f;    }  }  private static class JennrichSampsonFunction extends MinpackFunction {    private static final long serialVersionUID = -2489165190443352947L;    public JennrichSampsonFunction(int m, double[] startParams,                                   double theoreticalStartCost,                                   double theoreticalMinCost,                                   double[] theoreticalMinParams) {      super(m, startParams, theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double t = i + 1;        jacobian[i] = new double[] { -t * Math.exp(t * x1), -t * Math.exp(t * x2) };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = i + 1;        f[i] = 2 + 2 * temp - Math.exp(temp * x1) - Math.exp(temp * x2);      }      return f;    }  }  private static class BrownDennisFunction extends MinpackFunction {    private static final long serialVersionUID = 8340018645694243910L;    public BrownDennisFunction(int m, double[] startParams,                               double theoreticalStartCost,                               double theoreticalMinCost,                               double[] theoreticalMinParams) {      super(m, startParams, theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double   x3 = variables[2];      double   x4 = variables[3];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = (i + 1) / 5.0;        double ti   = Math.sin(temp);        double tmp1 = x1 + temp * x2 - Math.exp(temp);        double tmp2 = x3 + ti   * x4 - Math.cos(temp);        jacobian[i] = new double[] {          2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2        };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double x4 = variables[3];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = (i + 1) / 5.0;        double tmp1 = x1 + temp * x2 - Math.exp(temp);        double tmp2 = x3 + Math.sin(temp) * x4 - Math.cos(temp);        f[i] = tmp1 * tmp1 + tmp2 * tmp2;      }      return f;    }  }  private static class ChebyquadFunction extends MinpackFunction {    private static final long serialVersionUID = -2394877275028008594L;    private static double[] buildChebyquadArray(int n, double factor) {      double[] array = new double[n];      double inv = factor / (n + 1);      for (int i = 0; i < n; ++i) {        array[i] = (i + 1) * inv;      }      return array;    }    public ChebyquadFunction(int n, int m, double factor,                             double theoreticalStartCost,                             double theoreticalMinCost,                             double[] theoreticalMinParams) {      super(m, buildChebyquadArray(n, factor), theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];      }      double dx = 1.0 / n;      for (int j = 0; j < n; ++j) {        double tmp1 = 1;        double tmp2 = 2 * variables[j] - 1;        double temp = 2 * tmp2;        double tmp3 = 0;        double tmp4 = 2;        for (int i = 0; i < m; ++i) {          jacobian[i][j] = dx * tmp4;          double ti = 4 * tmp2 + temp * tmp4 - tmp3;          tmp3 = tmp4;          tmp4 = ti;          ti   = temp * tmp2 - tmp1;          tmp1 = tmp2;          tmp2 = ti;        }      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double[] f = new double[m];      for (int j = 0; j < n; ++j) {        double tmp1 = 1;        double tmp2 = 2 * variables[j] - 1;        double temp = 2 * tmp2;        for (int i = 0; i < m; ++i) {          f[i] += tmp2;          double ti = temp * tmp2 - tmp1;          tmp1 = tmp2;          tmp2 = ti;        }      }      double dx = 1.0 / n;      boolean iev = false;      for (int i = 0; i < m; ++i) {        f[i] *= dx;        if (iev) {          f[i] += 1.0 / (i * (i + 2));        }        iev = ! iev;      }      return f;    }  }  private static class BrownAlmostLinearFunction extends MinpackFunction {    private static final long serialVersionUID = 8239594490466964725L;    public BrownAlmostLinearFunction(int m, double factor,                                     double theoreticalStartCost,                                     double theoreticalMinCost,                                     double[] theoreticalMinParams) {      super(m, buildArray(m, factor), theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];      }      double prod = 1;      for (int j = 0; j < n; ++j) {        prod *= variables[j];        for (int i = 0; i < n; ++i) {          jacobian[i][j] = 1;        }        jacobian[j][j] = 2;      }      for (int j = 0; j < n; ++j) {        double temp = variables[j];        if (temp == 0) {          temp = 1;          prod = 1;          for (int k = 0; k < n; ++k) {            if (k != j) {              prod *= variables[k];            }          }        }        jacobian[n - 1][j] = prod / temp;      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double[] f = new double[m];      double sum  = -(n + 1);      double prod = 1;      for (int j = 0; j < n; ++j) {        sum  += variables[j];        prod *= variables[j];      }      for (int i = 0; i < n; ++i) {        f[i] = variables[i] + sum;      }      f[n - 1] = prod - 1;      return f;    }  }  private static class Osborne1Function extends MinpackFunction {    private static final long serialVersionUID = 4006743521149849494L;    public Osborne1Function(double[] startParams,                            double theoreticalStartCost,                            double theoreticalMinCost,                            double[] theoreticalMinParams) {      super(33, startParams, theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double   x2 = variables[1];      double   x3 = variables[2];      double   x4 = variables[3];      double   x5 = variables[4];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = 10.0 * i;        double tmp1 = Math.exp(-temp * x4);        double tmp2 = Math.exp(-temp * x5);        jacobian[i] = new double[] {          -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2        };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double x4 = variables[3];      double x5 = variables[4];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = 10.0 * i;        double tmp1 = Math.exp(-temp * x4);        double tmp2 = Math.exp(-temp * x5);        f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2);      }      return f;    }    private static final double[] y = {      0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751,      0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490,      0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406    };  }  private static class Osborne2Function extends MinpackFunction {    private static final long serialVersionUID = -8418268780389858746L;    public Osborne2Function(double[] startParams,                            double theoreticalStartCost,                            double theoreticalMinCost,                            double[] theoreticalMinParams) {      super(65, startParams, theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double   x01 = variables[0];      double   x02 = variables[1];      double   x03 = variables[2];      double   x04 = variables[3];      double   x05 = variables[4];      double   x06 = variables[5];      double   x07 = variables[6];      double   x08 = variables[7];      double   x09 = variables[8];      double   x10 = variables[9];      double   x11 = variables[10];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = i / 10.0;        double tmp1 = Math.exp(-x05 * temp);        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));        jacobian[i] = new double[] {          -tmp1,          -tmp2,          -tmp3,          -tmp4,          temp * x01 * tmp1,          x02 * (temp - x09) * (temp - x09) * tmp2,          x03 * (temp - x10) * (temp - x10) * tmp3,          x04 * (temp - x11) * (temp - x11) * tmp4,          -2 * x02 * x06 * (temp - x09) * tmp2,          -2 * x03 * x07 * (temp - x10) * tmp3,          -2 * x04 * x08 * (temp - x11) * tmp4        };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x01 = variables[0];      double x02 = variables[1];      double x03 = variables[2];      double x04 = variables[3];      double x05 = variables[4];      double x06 = variables[5];      double x07 = variables[6];      double x08 = variables[7];      double x09 = variables[8];      double x10 = variables[9];      double x11 = variables[10];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = i / 10.0;        double tmp1 = Math.exp(-x05 * temp);        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));        f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4);      }      return f;    }    private static final double[] y = {      1.366, 1.191, 1.112, 1.013, 0.991,      0.885, 0.831, 0.847, 0.786, 0.725,      0.746, 0.679, 0.608, 0.655, 0.616,      0.606, 0.602, 0.626, 0.651, 0.724,      0.649, 0.649, 0.694, 0.644, 0.624,      0.661, 0.612, 0.558, 0.533, 0.495,      0.500, 0.423, 0.395, 0.375, 0.372,      0.391, 0.396, 0.405, 0.428, 0.429,      0.523, 0.562, 0.607, 0.653, 0.672,      0.708, 0.633, 0.668, 0.645, 0.632,      0.591, 0.559, 0.597, 0.625, 0.739,      0.710, 0.729, 0.720, 0.636, 0.581,      0.428, 0.292, 0.162, 0.098, 0.054    };  }  public static Test suite() {    return new TestSuite(MinpackTest.class);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.univariate;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.optimization.UnivariateRealOptimizer;/** * @version $Revision$ $Date$  */public final class BrentMinimizerTest extends TestCase {    public BrentMinimizerTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(BrentMinimizerTest.class);        suite.setName("BrentOptimizer Tests");        return suite;    }    public void testSinMin() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealOptimizer minimizer = new BrentOptimizer();        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 70 * minimizer.getAbsoluteAccuracy());        assertTrue(minimizer.getIterationCount() <= 50);        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 1, 5), 70 * minimizer.getAbsoluteAccuracy());        assertTrue(minimizer.getIterationCount() <= 50);    }   public void testQuinticMin() throws MathException {        // The quintic function has zeros at 0, +-0.5 and +-1.        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealOptimizer minimizer = new BrentOptimizer();        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2), 1.0e-8);        assertEquals( 0.82221643, minimizer.optimize(f, GoalType.MINIMIZE,  0.3,  0.9), 1.0e-8);        assertTrue(minimizer.getIterationCount() <= 50);        // search in a large interval        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -1.0, 0.2), 1.0e-8);        assertTrue(minimizer.getIterationCount() <= 50);   }        public void testMinEndpoints() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealOptimizer solver = new BrentOptimizer();                // endpoint is minimum        double result = solver.optimize(f, GoalType.MINIMIZE, 3 * Math.PI / 2, 5);        assertEquals(3 * Math.PI / 2, result, 70 * solver.getAbsoluteAccuracy());        result = solver.optimize(f, GoalType.MINIMIZE, 4, 3 * Math.PI / 2);        assertEquals(3 * Math.PI / 2, result, 70 * solver.getAbsoluteAccuracy());    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.direct;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.ConvergenceException;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.optimization.RealPointValuePair;import org.apache.commons.math.optimization.SimpleScalarValueChecker;public class MultiDirectionalTest  extends TestCase {  public MultiDirectionalTest(String name) {    super(name);  }  public void testFunctionEvaluationExceptions() {      MultivariateRealFunction wrong =          new MultivariateRealFunction() {            private static final long serialVersionUID = 4751314470965489371L;            public double value(double[] x) throws FunctionEvaluationException {                if (x[0] < 0) {                    throw new FunctionEvaluationException(x, "{0}", "oops");                } else if (x[0] > 1) {                    throw new FunctionEvaluationException(new RuntimeException("oops"), x);                } else {                    return x[0] * (1 - x[0]);                }            }      };      try {          MultiDirectional optimizer = new MultiDirectional(0.9, 1.9);          optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { -1.0 });          fail("an exception should have been thrown");      } catch (FunctionEvaluationException ce) {          // expected behavior          assertNull(ce.getCause());      } catch (Exception e) {          fail("wrong exception caught: " + e.getMessage());      }       try {          MultiDirectional optimizer = new MultiDirectional(0.9, 1.9);          optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { +2.0 });          fail("an exception should have been thrown");      } catch (FunctionEvaluationException ce) {          // expected behavior          assertNotNull(ce.getCause());      } catch (Exception e) {          fail("wrong exception caught: " + e.getMessage());      }   }  public void testMinimizeMaximize()      throws FunctionEvaluationException, ConvergenceException {      // the following function has 4 local extrema:      final double xM        = -3.841947088256863675365;      final double yM        = -1.391745200270734924416;      final double xP        =  0.2286682237349059125691;      final double yP        = -yM;      final double valueXmYm =  0.2373295333134216789769; // local  maximum      final double valueXmYp = -valueXmYm;                // local  minimum      final double valueXpYm = -0.7290400707055187115322; // global minimum      final double valueXpYp = -valueXpYm;                // global maximum      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {          private static final long serialVersionUID = -7039124064449091152L;          public double value(double[] variables) throws FunctionEvaluationException {              final double x = variables[0];              final double y = variables[1];              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));          }      };      MultiDirectional optimizer = new MultiDirectional();      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-30));      optimizer.setMaxIterations(200);      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });      RealPointValuePair optimum;      // minimization      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });      assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);      assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);      assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);      assertTrue(optimizer.getEvaluations() > 120);      assertTrue(optimizer.getEvaluations() < 150);      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });      assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);      assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);      assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);                    assertTrue(optimizer.getEvaluations() > 120);      assertTrue(optimizer.getEvaluations() < 150);      // maximization      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });      assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);      assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);      assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);      assertTrue(optimizer.getEvaluations() > 120);      assertTrue(optimizer.getEvaluations() < 150);      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });      assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);      assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);      assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);      assertTrue(optimizer.getEvaluations() > 120);      assertTrue(optimizer.getEvaluations() < 150);  }  public void testRosenbrock()    throws FunctionEvaluationException, ConvergenceException {    MultivariateRealFunction rosenbrock =      new MultivariateRealFunction() {        private static final long serialVersionUID = -9044950469615237490L;        public double value(double[] x) throws FunctionEvaluationException {          ++count;          double a = x[1] - x[0] * x[0];          double b = 1.0 - x[0];          return 100 * a * a + b * b;        }      };    count = 0;    MultiDirectional optimizer = new MultiDirectional();    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));    optimizer.setMaxIterations(100);    optimizer.setStartConfiguration(new double[][] {            { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }    });    RealPointValuePair optimum =        optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });    assertEquals(count, optimizer.getEvaluations());    assertTrue(optimizer.getEvaluations() > 70);    assertTrue(optimizer.getEvaluations() < 100);    assertTrue(optimum.getValue() > 1.0e-2);  }  public void testPowell()    throws FunctionEvaluationException, ConvergenceException {    MultivariateRealFunction powell =      new MultivariateRealFunction() {        private static final long serialVersionUID = -832162886102041840L;        public double value(double[] x) throws FunctionEvaluationException {          ++count;          double a = x[0] + 10 * x[1];          double b = x[2] - x[3];          double c = x[1] - 2 * x[2];          double d = x[0] - x[3];          return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;        }      };    count = 0;    MultiDirectional optimizer = new MultiDirectional();    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));    optimizer.setMaxIterations(1000);    RealPointValuePair optimum =      optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });    assertEquals(count, optimizer.getEvaluations());    assertTrue(optimizer.getEvaluations() > 800);    assertTrue(optimizer.getEvaluations() < 900);    assertTrue(optimum.getValue() > 1.0e-2);  }  public static Test suite() {    return new TestSuite(MultiDirectionalTest.class);  }  private int count;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.direct;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import org.apache.commons.math.ConvergenceException;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.MathException;import org.apache.commons.math.MaxEvaluationsExceededException;import org.apache.commons.math.MaxIterationsExceededException;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.optimization.OptimizationException;import org.apache.commons.math.optimization.RealPointValuePair;import org.apache.commons.math.optimization.SimpleScalarValueChecker;import org.junit.Test;public class NelderMeadTest {  @Test  public void testFunctionEvaluationExceptions() {      MultivariateRealFunction wrong =          new MultivariateRealFunction() {            private static final long serialVersionUID = 4751314470965489371L;            public double value(double[] x) throws FunctionEvaluationException {                if (x[0] < 0) {                    throw new FunctionEvaluationException(x, "{0}", "oops");                } else if (x[0] > 1) {                    throw new FunctionEvaluationException(new RuntimeException("oops"), x);                } else {                    return x[0] * (1 - x[0]);                }            }      };      try {          NelderMead optimizer = new NelderMead(0.9, 1.9, 0.4, 0.6);          optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { -1.0 });          fail("an exception should have been thrown");      } catch (FunctionEvaluationException ce) {          // expected behavior          assertNull(ce.getCause());      } catch (Exception e) {          fail("wrong exception caught: " + e.getMessage());      }       try {          NelderMead optimizer = new NelderMead(0.9, 1.9, 0.4, 0.6);          optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { +2.0 });          fail("an exception should have been thrown");      } catch (FunctionEvaluationException ce) {          // expected behavior          assertNotNull(ce.getCause());      } catch (Exception e) {          fail("wrong exception caught: " + e.getMessage());      }   }  @Test  public void testMinimizeMaximize()      throws FunctionEvaluationException, ConvergenceException {      // the following function has 4 local extrema:      final double xM        = -3.841947088256863675365;      final double yM        = -1.391745200270734924416;      final double xP        =  0.2286682237349059125691;      final double yP        = -yM;      final double valueXmYm =  0.2373295333134216789769; // local  maximum      final double valueXmYp = -valueXmYm;                // local  minimum      final double valueXpYm = -0.7290400707055187115322; // global minimum      final double valueXpYp = -valueXpYm;                // global maximum      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {          private static final long serialVersionUID = -7039124064449091152L;          public double value(double[] variables) throws FunctionEvaluationException {              final double x = variables[0];              final double y = variables[1];              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));          }      };      NelderMead optimizer = new NelderMead();      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-30));      optimizer.setMaxIterations(100);      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });      RealPointValuePair optimum;      // minimization      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });      assertEquals(xM,        optimum.getPoint()[0], 2.0e-7);      assertEquals(yP,        optimum.getPoint()[1], 2.0e-5);      assertEquals(valueXmYp, optimum.getValue(),    6.0e-12);      assertTrue(optimizer.getEvaluations() > 60);      assertTrue(optimizer.getEvaluations() < 90);      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });      assertEquals(xP,        optimum.getPoint()[0], 5.0e-6);      assertEquals(yM,        optimum.getPoint()[1], 6.0e-6);      assertEquals(valueXpYm, optimum.getValue(),    1.0e-11);                    assertTrue(optimizer.getEvaluations() > 60);      assertTrue(optimizer.getEvaluations() < 90);      // maximization      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });      assertEquals(xM,        optimum.getPoint()[0], 1.0e-5);      assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);      assertEquals(valueXmYm, optimum.getValue(),    3.0e-12);      assertTrue(optimizer.getEvaluations() > 60);      assertTrue(optimizer.getEvaluations() < 90);      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });      assertEquals(xP,        optimum.getPoint()[0], 4.0e-6);      assertEquals(yP,        optimum.getPoint()[1], 5.0e-6);      assertEquals(valueXpYp, optimum.getValue(),    7.0e-12);      assertTrue(optimizer.getEvaluations() > 60);      assertTrue(optimizer.getEvaluations() < 90);  }  @Test  public void testRosenbrock()    throws FunctionEvaluationException, ConvergenceException {    Rosenbrock rosenbrock = new Rosenbrock();    NelderMead optimizer = new NelderMead();    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));    optimizer.setMaxIterations(100);    optimizer.setStartConfiguration(new double[][] {            { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }    });    RealPointValuePair optimum =        optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });    assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());    assertTrue(optimizer.getEvaluations() > 40);    assertTrue(optimizer.getEvaluations() < 50);    assertTrue(optimum.getValue() < 8.0e-4);  }  @Test  public void testPowell()    throws FunctionEvaluationException, ConvergenceException {    Powell powell = new Powell();    NelderMead optimizer = new NelderMead();    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));    optimizer.setMaxIterations(200);    RealPointValuePair optimum =      optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });    assertEquals(powell.getCount(), optimizer.getEvaluations());    assertTrue(optimizer.getEvaluations() > 110);    assertTrue(optimizer.getEvaluations() < 130);    assertTrue(optimum.getValue() < 2.0e-3);  }  @Test(expected = MaxIterationsExceededException.class)  public void testMaxIterations() throws MathException {      try {          Powell powell = new Powell();          NelderMead optimizer = new NelderMead();          optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));          optimizer.setMaxIterations(20);          optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });      } catch (OptimizationException oe) {          if (oe.getCause() instanceof ConvergenceException) {              throw (ConvergenceException) oe.getCause();          }          throw oe;      }  }  @Test(expected = MaxEvaluationsExceededException.class)  public void testMaxEvaluations() throws MathException {      try {          Powell powell = new Powell();          NelderMead optimizer = new NelderMead();          optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));          optimizer.setMaxEvaluations(20);          optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });      } catch (FunctionEvaluationException fee) {          if (fee.getCause() instanceof ConvergenceException) {              throw (ConvergenceException) fee.getCause();          }          throw fee;      }  }  private class Rosenbrock implements MultivariateRealFunction {      private int count;      public Rosenbrock() {          count = 0;      }      public double value(double[] x) throws FunctionEvaluationException {          ++count;          double a = x[1] - x[0] * x[0];          double b = 1.0 - x[0];          return 100 * a * a + b * b;      }      public int getCount() {          return count;      }  }  private class Powell implements MultivariateRealFunction {      private int count;      public Powell() {          count = 0;      }      public double value(double[] x) throws FunctionEvaluationException {          ++count;          double a = x[0] + 10 * x[1];          double b = x[2] - x[3];          double c = x[1] - 2 * x[2];          double d = x[0] - x[3];          return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;      }      public int getCount() {          return count;      }  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.linear;import java.util.ArrayList;import java.util.Collection;import org.apache.commons.math.TestUtils;import org.apache.commons.math.optimization.GoalType;import junit.framework.TestCase;public class SimplexTableauTest extends TestCase {    public void testInitialization() {            LinearObjectiveFunction f = createFunction();        Collection<LinearConstraint> constraints = createConstraints();        SimplexTableau tableau =            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);        double[][] expectedInitialTableau = {                                             {-1, 0,  -1,  -1,  2, 0, 0, 0, -4},                                             { 0, 1, -15, -10, 25, 0, 0, 0,  0},                                             { 0, 0,   1,   0, -1, 1, 0, 0,  2},                                             { 0, 0,   0,   1, -1, 0, 1, 0,  3},                                             { 0, 0,   1,   1, -2, 0, 0, 1,  4}        };        assertMatrixEquals(expectedInitialTableau, tableau.getData());    }    public void testdiscardArtificialVariables() {            LinearObjectiveFunction f = createFunction();        Collection<LinearConstraint> constraints = createConstraints();        SimplexTableau tableau =            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);        double[][] expectedTableau = {                                      { 1, -15, -10, 25, 0, 0, 0},                                      { 0,   1,   0, -1, 1, 0, 2},                                      { 0,   0,   1, -1, 0, 1, 3},                                      { 0,   1,   1, -2, 0, 0, 4}        };        tableau.discardArtificialVariables();        assertMatrixEquals(expectedTableau, tableau.getData());    }    public void testTableauWithNoArtificialVars() {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {15, 10}, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.LEQ, 2));        constraints.add(new LinearConstraint(new double[] {0, 1}, Relationship.LEQ, 3));        constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.LEQ, 4));            SimplexTableau tableau =            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);        double[][] initialTableau = {                                     {1, -15, -10, 25, 0, 0, 0, 0},                                     {0,   1,   0, -1, 1, 0, 0, 2},                                     {0,   0,   1, -1, 0, 1, 0, 3},                                     {0,   1,   1, -2, 0, 0, 1, 4}        };        assertMatrixEquals(initialTableau, tableau.getData());    }    public void testSerial() {        LinearObjectiveFunction f = createFunction();        Collection<LinearConstraint> constraints = createConstraints();        SimplexTableau tableau =            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);        assertEquals(tableau, TestUtils.serializeAndRecover(tableau));    }    private LinearObjectiveFunction createFunction() {        return new LinearObjectiveFunction(new double[] {15, 10}, 0);    }    private Collection<LinearConstraint> createConstraints() {        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.LEQ, 2));        constraints.add(new LinearConstraint(new double[] {0, 1}, Relationship.LEQ, 3));        constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.EQ, 4));        return constraints;    }    private void assertMatrixEquals(double[][] expected, double[][] result) {        assertEquals("Wrong number of rows.", expected.length, result.length);        for (int i = 0; i < expected.length; i++) {            assertEquals("Wrong number of columns.", expected[i].length, result[i].length);            for (int j = 0; j < expected[i].length; j++) {                assertEquals("Wrong value at position [" + i + "," + j + "]", expected[i][j], result[i][j]);            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.linear;import static org.junit.Assert.assertEquals;import java.util.ArrayList;import java.util.Collection;import org.apache.commons.math.linear.RealVector;import org.apache.commons.math.linear.ArrayRealVector;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.optimization.OptimizationException;import org.apache.commons.math.optimization.RealPointValuePair;import org.junit.Test;public class SimplexSolverTest {    @Test    public void testMath272() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 1, 0 }, Relationship.GEQ,  1));        constraints.add(new LinearConstraint(new double[] { 1, 0, 1 }, Relationship.GEQ,  1));        constraints.add(new LinearConstraint(new double[] { 0, 1, 0 }, Relationship.GEQ,  1));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);                assertEquals(0.0, solution.getPoint()[0], .0000001);        assertEquals(1.0, solution.getPoint()[1], .0000001);        assertEquals(1.0, solution.getPoint()[2], .0000001);        assertEquals(3.0, solution.getValue(), .0000001);      }    @Test    public void testSimplexSolver() throws OptimizationException {        LinearObjectiveFunction f =            new LinearObjectiveFunction(new double[] { 15, 10 }, 7);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2));        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.LEQ, 3));        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 4));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);        assertEquals(2.0, solution.getPoint()[0], 0.0);        assertEquals(2.0, solution.getPoint()[1], 0.0);        assertEquals(57.0, solution.getValue(), 0.0);    }    @Test    public void testSingleVariableAndConstraint() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 3 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 10));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);        assertEquals(10.0, solution.getPoint()[0], 0.0);        assertEquals(30.0, solution.getValue(), 0.0);    }        /**     * With no artificial variables needed (no equals and no greater than     * constraints) we can go straight to Phase 2.     */    @Test    public void testModelWithNoArtificialVars() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2));        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.LEQ, 3));        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.LEQ, 4));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);        assertEquals(2.0, solution.getPoint()[0], 0.0);        assertEquals(2.0, solution.getPoint()[1], 0.0);        assertEquals(50.0, solution.getValue(), 0.0);    }    @Test    public void testMinimization() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, -5);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 6));        constraints.add(new LinearConstraint(new double[] { 3, 2 }, Relationship.LEQ, 12));        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.GEQ, 0));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);        assertEquals(4.0, solution.getPoint()[0], 0.0);        assertEquals(0.0, solution.getPoint()[1], 0.0);        assertEquals(-13.0, solution.getValue(), 0.0);    }    @Test    public void testSolutionWithNegativeDecisionVariable() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.GEQ, 6));        constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 14));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);        assertEquals(-2.0, solution.getPoint()[0], 0.0);        assertEquals(8.0, solution.getPoint()[1], 0.0);        assertEquals(12.0, solution.getValue(), 0.0);    }    @Test(expected = NoFeasibleSolutionException.class)    public void testInfeasibleSolution() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 1));        constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.GEQ, 3));        SimplexSolver solver = new SimplexSolver();        solver.optimize(f, constraints, GoalType.MAXIMIZE, false);    }    @Test(expected = UnboundedSolutionException.class)    public void testUnboundedSolution() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.EQ, 2));        SimplexSolver solver = new SimplexSolver();        solver.optimize(f, constraints, GoalType.MAXIMIZE, false);    }    @Test    public void testRestrictVariablesToNonNegative() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 409, 523, 70, 204, 339 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] {    43,   56, 345,  56,    5 }, Relationship.LEQ,  4567456));        constraints.add(new LinearConstraint(new double[] {    12,   45,   7,  56,   23 }, Relationship.LEQ,    56454));        constraints.add(new LinearConstraint(new double[] {     8,  768,   0,  34, 7456 }, Relationship.LEQ,  1923421));        constraints.add(new LinearConstraint(new double[] { 12342, 2342,  34, 678, 2342 }, Relationship.GEQ,     4356));        constraints.add(new LinearConstraint(new double[] {    45,  678,  76,  52,   23 }, Relationship.EQ,    456356));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);        assertEquals(2902.92783505155, solution.getPoint()[0], .0000001);        assertEquals(480.419243986254, solution.getPoint()[1], .0000001);        assertEquals(0.0, solution.getPoint()[2], .0000001);        assertEquals(0.0, solution.getPoint()[3], .0000001);        assertEquals(0.0, solution.getPoint()[4], .0000001);        assertEquals(1438556.7491409, solution.getValue(), .0000001);    }    @Test    public void testEpsilon() throws OptimizationException {      LinearObjectiveFunction f =          new LinearObjectiveFunction(new double[] { 10, 5, 1 }, 0);      Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();      constraints.add(new LinearConstraint(new double[] {  9, 8, 0 }, Relationship.EQ,  17));      constraints.add(new LinearConstraint(new double[] {  0, 7, 8 }, Relationship.LEQ,  7));      constraints.add(new LinearConstraint(new double[] { 10, 0, 2 }, Relationship.LEQ, 10));      SimplexSolver solver = new SimplexSolver();      RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);      assertEquals(1.0, solution.getPoint()[0], 0.0);      assertEquals(1.0, solution.getPoint()[1], 0.0);      assertEquals(0.0, solution.getPoint()[2], 0.0);      assertEquals(15.0, solution.getValue(), 0.0);  }        @Test    public void testTrivialModel() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 1 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ,  0));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);        assertEquals(0, solution.getValue(), .0000001);    }    @Test    public void testLargeModel() throws OptimizationException {        double[] objective = new double[] {                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 12, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           12, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 12, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 12, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 12, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 12, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1};        LinearObjectiveFunction f = new LinearObjectiveFunction(objective, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(equationFromString(objective.length, "x0 + x1 + x2 + x3 - x12 = 0"));        constraints.add(equationFromString(objective.length, "x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 - x13 = 0"));        constraints.add(equationFromString(objective.length, "x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 >= 49"));        constraints.add(equationFromString(objective.length, "x0 + x1 + x2 + x3 >= 42"));        constraints.add(equationFromString(objective.length, "x14 + x15 + x16 + x17 - x26 = 0"));        constraints.add(equationFromString(objective.length, "x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x27 = 0"));        constraints.add(equationFromString(objective.length, "x14 + x15 + x16 + x17 - x12 = 0"));        constraints.add(equationFromString(objective.length, "x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x13 = 0"));        constraints.add(equationFromString(objective.length, "x28 + x29 + x30 + x31 - x40 = 0"));        constraints.add(equationFromString(objective.length, "x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 - x41 = 0"));        constraints.add(equationFromString(objective.length, "x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 >= 49"));        constraints.add(equationFromString(objective.length, "x28 + x29 + x30 + x31 >= 42"));        constraints.add(equationFromString(objective.length, "x42 + x43 + x44 + x45 - x54 = 0"));        constraints.add(equationFromString(objective.length, "x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x55 = 0"));        constraints.add(equationFromString(objective.length, "x42 + x43 + x44 + x45 - x40 = 0"));        constraints.add(equationFromString(objective.length, "x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x41 = 0"));        constraints.add(equationFromString(objective.length, "x56 + x57 + x58 + x59 - x68 = 0"));        constraints.add(equationFromString(objective.length, "x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 - x69 = 0"));        constraints.add(equationFromString(objective.length, "x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 >= 51"));        constraints.add(equationFromString(objective.length, "x56 + x57 + x58 + x59 >= 44"));        constraints.add(equationFromString(objective.length, "x70 + x71 + x72 + x73 - x82 = 0"));        constraints.add(equationFromString(objective.length, "x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x83 = 0"));        constraints.add(equationFromString(objective.length, "x70 + x71 + x72 + x73 - x68 = 0"));        constraints.add(equationFromString(objective.length, "x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x69 = 0"));        constraints.add(equationFromString(objective.length, "x84 + x85 + x86 + x87 - x96 = 0"));        constraints.add(equationFromString(objective.length, "x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 - x97 = 0"));        constraints.add(equationFromString(objective.length, "x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 >= 51"));        constraints.add(equationFromString(objective.length, "x84 + x85 + x86 + x87 >= 44"));        constraints.add(equationFromString(objective.length, "x98 + x99 + x100 + x101 - x110 = 0"));        constraints.add(equationFromString(objective.length, "x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x111 = 0"));        constraints.add(equationFromString(objective.length, "x98 + x99 + x100 + x101 - x96 = 0"));        constraints.add(equationFromString(objective.length, "x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x97 = 0"));        constraints.add(equationFromString(objective.length, "x112 + x113 + x114 + x115 - x124 = 0"));        constraints.add(equationFromString(objective.length, "x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 - x125 = 0"));        constraints.add(equationFromString(objective.length, "x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 >= 49"));        constraints.add(equationFromString(objective.length, "x112 + x113 + x114 + x115 >= 42"));        constraints.add(equationFromString(objective.length, "x126 + x127 + x128 + x129 - x138 = 0"));        constraints.add(equationFromString(objective.length, "x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x139 = 0"));        constraints.add(equationFromString(objective.length, "x126 + x127 + x128 + x129 - x124 = 0"));        constraints.add(equationFromString(objective.length, "x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x125 = 0"));        constraints.add(equationFromString(objective.length, "x140 + x141 + x142 + x143 - x152 = 0"));        constraints.add(equationFromString(objective.length, "x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 - x153 = 0"));        constraints.add(equationFromString(objective.length, "x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 >= 59"));        constraints.add(equationFromString(objective.length, "x140 + x141 + x142 + x143 >= 42"));        constraints.add(equationFromString(objective.length, "x154 + x155 + x156 + x157 - x166 = 0"));        constraints.add(equationFromString(objective.length, "x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x167 = 0"));        constraints.add(equationFromString(objective.length, "x154 + x155 + x156 + x157 - x152 = 0"));        constraints.add(equationFromString(objective.length, "x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x153 = 0"));        constraints.add(equationFromString(objective.length, "x83 + x82 - x168 = 0"));        constraints.add(equationFromString(objective.length, "x111 + x110 - x169 = 0"));        constraints.add(equationFromString(objective.length, "x170 - x182 = 0"));        constraints.add(equationFromString(objective.length, "x171 - x183 = 0"));        constraints.add(equationFromString(objective.length, "x172 - x184 = 0"));        constraints.add(equationFromString(objective.length, "x173 - x185 = 0"));        constraints.add(equationFromString(objective.length, "x174 - x186 = 0"));        constraints.add(equationFromString(objective.length, "x175 + x176 - x187 = 0"));        constraints.add(equationFromString(objective.length, "x177 - x188 = 0"));        constraints.add(equationFromString(objective.length, "x178 - x189 = 0"));        constraints.add(equationFromString(objective.length, "x179 - x190 = 0"));        constraints.add(equationFromString(objective.length, "x180 - x191 = 0"));        constraints.add(equationFromString(objective.length, "x181 - x192 = 0"));        constraints.add(equationFromString(objective.length, "x170 - x26 = 0"));        constraints.add(equationFromString(objective.length, "x171 - x27 = 0"));        constraints.add(equationFromString(objective.length, "x172 - x54 = 0"));        constraints.add(equationFromString(objective.length, "x173 - x55 = 0"));        constraints.add(equationFromString(objective.length, "x174 - x168 = 0"));        constraints.add(equationFromString(objective.length, "x177 - x169 = 0"));        constraints.add(equationFromString(objective.length, "x178 - x138 = 0"));        constraints.add(equationFromString(objective.length, "x179 - x139 = 0"));        constraints.add(equationFromString(objective.length, "x180 - x166 = 0"));        constraints.add(equationFromString(objective.length, "x181 - x167 = 0"));        constraints.add(equationFromString(objective.length, "x193 - x205 = 0"));        constraints.add(equationFromString(objective.length, "x194 - x206 = 0"));        constraints.add(equationFromString(objective.length, "x195 - x207 = 0"));        constraints.add(equationFromString(objective.length, "x196 - x208 = 0"));        constraints.add(equationFromString(objective.length, "x197 - x209 = 0"));        constraints.add(equationFromString(objective.length, "x198 + x199 - x210 = 0"));        constraints.add(equationFromString(objective.length, "x200 - x211 = 0"));        constraints.add(equationFromString(objective.length, "x201 - x212 = 0"));        constraints.add(equationFromString(objective.length, "x202 - x213 = 0"));        constraints.add(equationFromString(objective.length, "x203 - x214 = 0"));        constraints.add(equationFromString(objective.length, "x204 - x215 = 0"));        constraints.add(equationFromString(objective.length, "x193 - x182 = 0"));        constraints.add(equationFromString(objective.length, "x194 - x183 = 0"));        constraints.add(equationFromString(objective.length, "x195 - x184 = 0"));        constraints.add(equationFromString(objective.length, "x196 - x185 = 0"));        constraints.add(equationFromString(objective.length, "x197 - x186 = 0"));        constraints.add(equationFromString(objective.length, "x198 + x199 - x187 = 0"));        constraints.add(equationFromString(objective.length, "x200 - x188 = 0"));        constraints.add(equationFromString(objective.length, "x201 - x189 = 0"));        constraints.add(equationFromString(objective.length, "x202 - x190 = 0"));        constraints.add(equationFromString(objective.length, "x203 - x191 = 0"));        constraints.add(equationFromString(objective.length, "x204 - x192 = 0"));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);        assertEquals(7518.0, solution.getValue(), .0000001);    }        /**     * Converts a test string to a {@link LinearConstraint}.     * Ex: x0 + x1 + x2 + x3 - x12 = 0     */    private LinearConstraint equationFromString(int numCoefficients, String s) {        Relationship relationship;        if (s.contains(">=")) {            relationship = Relationship.GEQ;        } else if (s.contains("<=")) {            relationship = Relationship.LEQ;        } else if (s.contains("=")) {            relationship = Relationship.EQ;        } else {            throw new IllegalArgumentException();        }        String[] equationParts = s.split("[>|<]?=");        double rhs = Double.parseDouble(equationParts[1].trim());        RealVector lhs = new ArrayRealVector(numCoefficients);        String left = equationParts[0].replaceAll(" ?x", "");        String[] coefficients = left.split(" ");        for (String coefficient : coefficients) {            double value = coefficient.charAt(0) == '-' ? -1 : 1;            int index = Integer.parseInt(coefficient.replaceFirst("[+|-]", "").trim());            lhs.setEntry(index, value);        }        return new LinearConstraint(lhs, relationship, rhs);    }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.apache.commons.math.optimization.fitting;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.Random;import org.apache.commons.math.analysis.polynomials.PolynomialFunction;import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;import org.apache.commons.math.optimization.OptimizationException;import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;import org.junit.Test;public class PolynomialFitterTest {    @Test    public void testNoError() throws OptimizationException {        Random randomizer = new Random(64925784252l);        for (int degree = 1; degree < 10; ++degree) {            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);            PolynomialFitter fitter =                new PolynomialFitter(degree, new LevenbergMarquardtOptimizer());            for (int i = 0; i <= degree; ++i) {                fitter.addObservedPoint(1.0, i, p.value(i));            }            PolynomialFunction fitted = fitter.fit();            for (double x = -1.0; x < 1.0; x += 0.01) {                double error = Math.abs(p.value(x) - fitted.value(x)) /                               (1.0 + Math.abs(p.value(x)));                assertEquals(0.0, error, 1.0e-6);            }        }    }    @Test    public void testSmallError() throws OptimizationException {        Random randomizer = new Random(53882150042l);        double maxError = 0;        for (int degree = 0; degree < 10; ++degree) {            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);            PolynomialFitter fitter =                new PolynomialFitter(degree, new LevenbergMarquardtOptimizer());            for (double x = -1.0; x < 1.0; x += 0.01) {                fitter.addObservedPoint(1.0, x,                                        p.value(x) + 0.1 * randomizer.nextGaussian());            }            PolynomialFunction fitted = fitter.fit();            for (double x = -1.0; x < 1.0; x += 0.01) {                double error = Math.abs(p.value(x) - fitted.value(x)) /                              (1.0 + Math.abs(p.value(x)));                maxError = Math.max(maxError, error);                assertTrue(Math.abs(error) < 0.1);            }        }        assertTrue(maxError > 0.01);    }    @Test    public void testRedundantSolvable() {        // Levenberg-Marquardt should handle redundant information gracefully        checkUnsolvableProblem(new LevenbergMarquardtOptimizer(), true);    }    @Test    public void testRedundantUnsolvable() {        // Gauss-Newton should not be able to solve redundant information        DifferentiableMultivariateVectorialOptimizer optimizer =            new GaussNewtonOptimizer(true);        checkUnsolvableProblem(optimizer, false);    }    private void checkUnsolvableProblem(DifferentiableMultivariateVectorialOptimizer optimizer,                                        boolean solvable) {        Random randomizer = new Random(1248788532l);        for (int degree = 0; degree < 10; ++degree) {            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);            PolynomialFitter fitter = new PolynomialFitter(degree, optimizer);            // reusing the same point over and over again does not bring            // information, the problem cannot be solved in this case for            // degrees greater than 1 (but one point is sufficient for            // degree 0)            for (double x = -1.0; x < 1.0; x += 0.01) {                fitter.addObservedPoint(1.0, 0.0, p.value(0.0));            }            try {                fitter.fit();                assertTrue(solvable || (degree == 0));            } catch(OptimizationException e) {                assertTrue((! solvable) && (degree > 0));            }        }    }    private PolynomialFunction buildRandomPolynomial(int degree, Random randomizer) {        final double[] coefficients = new double[degree + 1];        for (int i = 0; i <= degree; ++i) {            coefficients[i] = randomizer.nextGaussian();        }        return new PolynomialFunction(coefficients);    }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at// //   http://www.apache.org/licenses/LICENSE-2.0// // Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.apache.commons.math.optimization.fitting;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.Random;import org.apache.commons.math.optimization.OptimizationException;import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;import org.apache.commons.math.util.MathUtils;import org.junit.Test;public class HarmonicFitterTest {    @Test    public void testNoError() throws OptimizationException {        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);        HarmonicFitter fitter =            new HarmonicFitter(new LevenbergMarquardtOptimizer());        for (double x = 0.0; x < 1.3; x += 0.01) {            fitter.addObservedPoint(1.0, x, f.value(x));        }        HarmonicFunction fitted = fitter.fit();        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 1.0e-13);        assertEquals(f.getPulsation(), fitted.getPulsation(), 1.0e-13);        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.0e-13);        for (double x = -1.0; x < 1.0; x += 0.01) {            assertTrue(Math.abs(f.value(x) - fitted.value(x)) < 1.0e-13);        }    }    @Test    public void test1PercentError() throws OptimizationException {        Random randomizer = new Random(64925784252l);        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);        HarmonicFitter fitter =            new HarmonicFitter(new LevenbergMarquardtOptimizer());        for (double x = 0.0; x < 10.0; x += 0.1) {            fitter.addObservedPoint(1.0, x,                                   f.value(x) + 0.01 * randomizer.nextGaussian());        }        HarmonicFunction fitted = fitter.fit();        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 7.6e-4);        assertEquals(f.getPulsation(), fitted.getPulsation(), 2.7e-3);        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.3e-2);    }    @Test    public void testInitialGuess() throws OptimizationException {        Random randomizer = new Random(45314242l);        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);        HarmonicFitter fitter =            new HarmonicFitter(new LevenbergMarquardtOptimizer(), new double[] { 0.15, 3.6, 4.5 });        for (double x = 0.0; x < 10.0; x += 0.1) {            fitter.addObservedPoint(1.0, x,                                   f.value(x) + 0.01 * randomizer.nextGaussian());        }        HarmonicFunction fitted = fitter.fit();        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 1.2e-3);        assertEquals(f.getPulsation(), fitted.getPulsation(), 3.3e-3);        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.7e-2);    }    @Test    public void testUnsorted() throws OptimizationException {        Random randomizer = new Random(64925784252l);        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);        HarmonicFitter fitter =            new HarmonicFitter(new LevenbergMarquardtOptimizer());        // build a regularly spaced array of measurements        int size = 100;        double[] xTab = new double[size];        double[] yTab = new double[size];        for (int i = 0; i < size; ++i) {            xTab[i] = 0.1 * i;            yTab[i] = f.value(xTab[i]) + 0.01 * randomizer.nextGaussian();        }        // shake it        for (int i = 0; i < size; ++i) {            int i1 = randomizer.nextInt(size);            int i2 = randomizer.nextInt(size);            double xTmp = xTab[i1];            double yTmp = yTab[i1];            xTab[i1] = xTab[i2];            yTab[i1] = yTab[i2];            xTab[i2] = xTmp;            yTab[i2] = yTmp;        }        // pass it to the fitter        for (int i = 0; i < size; ++i) {            fitter.addObservedPoint(1.0, xTab[i], yTab[i]);        }        HarmonicFunction fitted = fitter.fit();        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 7.6e-4);        assertEquals(f.getPulsation(), fitted.getPulsation(), 3.5e-3);        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.5e-2);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.Serializable;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;import org.apache.commons.math.analysis.MultivariateMatrixFunction;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;import org.apache.commons.math.random.GaussianRandomGenerator;import org.apache.commons.math.random.JDKRandomGenerator;import org.apache.commons.math.random.RandomVectorGenerator;import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;import org.junit.Test;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files.  * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */public class MultiStartDifferentiableMultivariateVectorialOptimizerTest {    @Test    public void testTrivial() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });        DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =            new GaussNewtonOptimizer(true);        JDKRandomGenerator g = new JDKRandomGenerator();        g.setSeed(16069223052l);        RandomVectorGenerator generator =            new UncorrelatedRandomVectorGenerator(1, new GaussianRandomGenerator(g));        MultiStartDifferentiableMultivariateVectorialOptimizer optimizer =            new MultiStartDifferentiableMultivariateVectorialOptimizer(underlyingOptimizer,                                                                       10, generator);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        // no optima before first optimization attempt        try {            optimizer.getOptima();            fail("an exception should have been thrown");        } catch (IllegalStateException ise) {            // expected        }        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1 }, new double[] { 0 });        assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);        assertEquals(3.0, optimum.getValue()[0], 1.0e-10);        VectorialPointValuePair[] optima = optimizer.getOptima();        assertEquals(10, optima.length);        for (int i = 0; i < optima.length; ++i) {            assertEquals(1.5, optima[i].getPoint()[0], 1.0e-10);            assertEquals(3.0, optima[i].getValue()[0], 1.0e-10);        }        assertTrue(optimizer.getEvaluations() > 20);        assertTrue(optimizer.getEvaluations() < 50);        assertTrue(optimizer.getIterations() > 20);        assertTrue(optimizer.getIterations() < 50);        assertTrue(optimizer.getJacobianEvaluations() > 20);        assertTrue(optimizer.getJacobianEvaluations() < 50);        assertEquals(100, optimizer.getMaxIterations());    }    @Test(expected = OptimizationException.class)    public void testNoOptimum() throws FunctionEvaluationException, OptimizationException {        DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =            new GaussNewtonOptimizer(true);        JDKRandomGenerator g = new JDKRandomGenerator();        g.setSeed(12373523445l);        RandomVectorGenerator generator =            new UncorrelatedRandomVectorGenerator(1, new GaussianRandomGenerator(g));        MultiStartDifferentiableMultivariateVectorialOptimizer optimizer =            new MultiStartDifferentiableMultivariateVectorialOptimizer(underlyingOptimizer,                                                                       10, generator);        optimizer.setMaxIterations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        optimizer.optimize(new DifferentiableMultivariateVectorialFunction() {                public MultivariateMatrixFunction jacobian() {                    return null;                }                public double[] value(double[] point) throws FunctionEvaluationException {                    throw new FunctionEvaluationException(point[0]);                }            }, new double[] { 2 }, new double[] { 1 }, new double[] { 0 });    }    private static class LinearProblem implements DifferentiableMultivariateVectorialFunction, Serializable {        private static final long serialVersionUID = -8804268799379350190L;        final RealMatrix factors;        final double[] target;        public LinearProblem(double[][] factors, double[] target) {            this.factors = new BlockRealMatrix(factors);            this.target  = target;        }        public double[] value(double[] variables) {            return factors.operate(variables);        }        public MultivariateMatrixFunction jacobian() {            return new MultivariateMatrixFunction() {                private static final long serialVersionUID = -8387467946663627585L;                public double[][] value(double[] point) {                    return factors.getData();                }            };        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import org.apache.commons.math.ConvergenceException;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.optimization.direct.NelderMead;import org.apache.commons.math.random.GaussianRandomGenerator;import org.apache.commons.math.random.JDKRandomGenerator;import org.apache.commons.math.random.RandomVectorGenerator;import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;import org.junit.Test;public class MultiStartMultivariateRealOptimizerTest {  @Test  public void testRosenbrock()    throws FunctionEvaluationException, ConvergenceException {    Rosenbrock rosenbrock = new Rosenbrock();    NelderMead underlying = new NelderMead();    underlying.setStartConfiguration(new double[][] {                                         { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }                                     });    JDKRandomGenerator g = new JDKRandomGenerator();    g.setSeed(16069223052l);    RandomVectorGenerator generator =        new UncorrelatedRandomVectorGenerator(2, new GaussianRandomGenerator(g));    MultiStartMultivariateRealOptimizer optimizer =        new MultiStartMultivariateRealOptimizer(underlying, 10, generator);    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));    optimizer.setMaxIterations(100);    RealPointValuePair optimum =        optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });    assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());    assertTrue(optimizer.getEvaluations() > 20);    assertTrue(optimizer.getEvaluations() < 250);    assertTrue(optimum.getValue() < 8.0e-4);  }  private class Rosenbrock implements MultivariateRealFunction {      private int count;      public Rosenbrock() {          count = 0;      }      public double value(double[] x) throws FunctionEvaluationException {          ++count;          double a = x[1] - x[0] * x[0];          double b = 1.0 - x[0];          return 100 * a * a + b * b;      }      public int getCount() {          return count;      }  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import org.apache.commons.math.TestUtils;import java.util.List;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class ComplexTest extends TestCase {        private double inf = Double.POSITIVE_INFINITY;    private double neginf = Double.NEGATIVE_INFINITY;    private double nan = Double.NaN;    private double pi = Math.PI;    private Complex oneInf = new Complex(1, inf);    private Complex oneNegInf = new Complex(1, neginf);    private Complex infOne = new Complex(inf, 1);    private Complex infZero = new Complex(inf, 0);    private Complex infNaN = new Complex(inf, nan);    private Complex infNegInf = new Complex(inf, neginf);    private Complex infInf = new Complex(inf, inf);    private Complex negInfInf = new Complex(neginf, inf);    private Complex negInfZero = new Complex(neginf, 0);    private Complex negInfOne = new Complex(neginf, 1);    private Complex negInfNaN = new Complex(neginf, nan);    private Complex negInfNegInf = new Complex(neginf, neginf);    private Complex oneNaN = new Complex(1, nan);    private Complex zeroInf = new Complex(0, inf);    private Complex zeroNaN = new Complex(0, nan);    private Complex nanInf = new Complex(nan, inf);    private Complex nanNegInf = new Complex(nan, neginf);    private Complex nanZero = new Complex(nan, 0);        public void testConstructor() {        Complex z = new Complex(3.0, 4.0);        assertEquals(3.0, z.getReal(), 1.0e-5);        assertEquals(4.0, z.getImaginary(), 1.0e-5);    }        public void testConstructorNaN() {        Complex z = new Complex(3.0, Double.NaN);        assertTrue(z.isNaN());        z = new Complex(nan, 4.0);        assertTrue(z.isNaN());        z = new Complex(3.0, 4.0);        assertFalse(z.isNaN());    }        public void testAbs() {        Complex z = new Complex(3.0, 4.0);        assertEquals(5.0, z.abs(), 1.0e-5);    }        public void testAbsNaN() {        assertTrue(Double.isNaN(Complex.NaN.abs()));        Complex z = new Complex(inf, nan);        assertTrue(Double.isNaN(z.abs()));    }        public void testAbsInfinite() {        Complex z = new Complex(inf, 0);        assertEquals(inf, z.abs(), 0);        z = new Complex(0, neginf);        assertEquals(inf, z.abs(), 0);        z = new Complex(inf, neginf);        assertEquals(inf, z.abs(), 0);         }        public void testAdd() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.add(y);        assertEquals(8.0, z.getReal(), 1.0e-5);        assertEquals(10.0, z.getImaginary(), 1.0e-5);    }        public void testAddNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.add(Complex.NaN);        assertTrue(z.isNaN());        z = new Complex(1, nan);        Complex w = x.add(z);        assertEquals(w.getReal(), 4.0, 0);        assertTrue(Double.isNaN(w.getImaginary()));    }        public void testAddInfinite() {        Complex x = new Complex(1, 1);        Complex z = new Complex(inf, 0);        Complex w = x.add(z);        assertEquals(w.getImaginary(), 1, 0);        assertEquals(inf, w.getReal(), 0);                x = new Complex(neginf, 0);        assertTrue(Double.isNaN(x.add(z).getReal()));    }        public void testConjugate() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.conjugate();        assertEquals(3.0, z.getReal(), 1.0e-5);        assertEquals(-4.0, z.getImaginary(), 1.0e-5);    }        public void testConjugateNaN() {        Complex z = Complex.NaN.conjugate();        assertTrue(z.isNaN());    }        public void testConjugateInfiinite() {        Complex z = new Complex(0, inf);        assertEquals(neginf, z.conjugate().getImaginary(), 0);        z = new Complex(0, neginf);        assertEquals(inf, z.conjugate().getImaginary(), 0);    }        public void testDivide() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.divide(y);        assertEquals(39.0 / 61.0, z.getReal(), 1.0e-5);        assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5);    }        public void testDivideInfinite() {        Complex x = new Complex(3, 4);        Complex w = new Complex(neginf, inf);        assertTrue(x.divide(w).equals(Complex.ZERO));                Complex z = w.divide(x);        assertTrue(Double.isNaN(z.getReal()));        assertEquals(inf, z.getImaginary(), 0);                w = new Complex(inf, inf);        z = w.divide(x);        assertTrue(Double.isNaN(z.getImaginary()));        assertEquals(inf, z.getReal(), 0);                w = new Complex(1, inf);        z = w.divide(w);        assertTrue(Double.isNaN(z.getReal()));        assertTrue(Double.isNaN(z.getImaginary()));    }        public void testDivideNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.divide(Complex.NaN);        assertTrue(z.isNaN());    }        public void testDivideNaNInf() {         Complex z = oneInf.divide(Complex.ONE);       assertTrue(Double.isNaN(z.getReal()));       assertEquals(inf, z.getImaginary(), 0);              z = negInfNegInf.divide(oneNaN);       assertTrue(Double.isNaN(z.getReal()));       assertTrue(Double.isNaN(z.getImaginary()));              z = negInfInf.divide(Complex.ONE);       assertTrue(Double.isNaN(z.getReal()));       assertTrue(Double.isNaN(z.getImaginary()));    }        public void testMultiply() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.multiply(y);        assertEquals(-9.0, z.getReal(), 1.0e-5);        assertEquals(38.0, z.getImaginary(), 1.0e-5);    }        public void testMultiplyNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.multiply(Complex.NaN);        assertTrue(z.isNaN());    }        public void testMultiplyNaNInf() {        Complex z = new Complex(1,1);        Complex w = z.multiply(infOne);        assertEquals(w.getReal(), inf, 0);        assertEquals(w.getImaginary(), inf, 0);        // [MATH-164]        assertTrue(new Complex( 1,0).multiply(infInf).equals(Complex.INF));        assertTrue(new Complex(-1,0).multiply(infInf).equals(Complex.INF));        assertTrue(new Complex( 1,0).multiply(negInfZero).equals(Complex.INF));                w = oneInf.multiply(oneNegInf);        assertEquals(w.getReal(), inf, 0);        assertEquals(w.getImaginary(), inf, 0);                w = negInfNegInf.multiply(oneNaN);        assertTrue(Double.isNaN(w.getReal()));        assertTrue(Double.isNaN(w.getImaginary()));      }        public void testNegate() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.negate();        assertEquals(-3.0, z.getReal(), 1.0e-5);        assertEquals(-4.0, z.getImaginary(), 1.0e-5);    }        public void testNegateNaN() {        Complex z = Complex.NaN.negate();        assertTrue(z.isNaN());    }        public void testSubtract() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.subtract(y);        assertEquals(-2.0, z.getReal(), 1.0e-5);        assertEquals(-2.0, z.getImaginary(), 1.0e-5);    }        public void testSubtractNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.subtract(Complex.NaN);        assertTrue(z.isNaN());    }        public void testEqualsNull() {        Complex x = new Complex(3.0, 4.0);        assertFalse(x.equals(null));    }        public void testEqualsClass() {        Complex x = new Complex(3.0, 4.0);        assertFalse(x.equals(this));    }        public void testEqualsSame() {        Complex x = new Complex(3.0, 4.0);        assertTrue(x.equals(x));    }        public void testEqualsTrue() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(3.0, 4.0);        assertTrue(x.equals(y));    }        public void testEqualsRealDifference() {        Complex x = new Complex(0.0, 0.0);        Complex y = new Complex(0.0 + Double.MIN_VALUE, 0.0);        assertFalse(x.equals(y));    }        public void testEqualsImaginaryDifference() {        Complex x = new Complex(0.0, 0.0);        Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);        assertFalse(x.equals(y));    }        public void testEqualsNaN() {        Complex realNaN = new Complex(Double.NaN, 0.0);        Complex imaginaryNaN = new Complex(0.0, Double.NaN);        Complex complexNaN = Complex.NaN;        assertTrue(realNaN.equals(imaginaryNaN));        assertTrue(imaginaryNaN.equals(complexNaN));        assertTrue(realNaN.equals(complexNaN));    }        public void testHashCode() {        Complex x = new Complex(0.0, 0.0);        Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);        assertFalse(x.hashCode()==y.hashCode());        y = new Complex(0.0 + Double.MIN_VALUE, 0.0);        assertFalse(x.hashCode()==y.hashCode());        Complex realNaN = new Complex(Double.NaN, 0.0);        Complex imaginaryNaN = new Complex(0.0, Double.NaN);        assertEquals(realNaN.hashCode(), imaginaryNaN.hashCode());        assertEquals(imaginaryNaN.hashCode(), Complex.NaN.hashCode());    }        public void testAcos() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(0.936812, -2.30551);        TestUtils.assertEquals(expected, z.acos(), 1.0e-5);        TestUtils.assertEquals(new Complex(Math.acos(0), 0),                 Complex.ZERO.acos(), 1.0e-12);    }        public void testAcosInf() {        TestUtils.assertSame(Complex.NaN, oneInf.acos());        TestUtils.assertSame(Complex.NaN, oneNegInf.acos());        TestUtils.assertSame(Complex.NaN, infOne.acos());        TestUtils.assertSame(Complex.NaN, negInfOne.acos());        TestUtils.assertSame(Complex.NaN, infInf.acos());        TestUtils.assertSame(Complex.NaN, infNegInf.acos());        TestUtils.assertSame(Complex.NaN, negInfInf.acos());        TestUtils.assertSame(Complex.NaN, negInfNegInf.acos());    }        public void testAcosNaN() {        assertTrue(Complex.NaN.acos().isNaN());    }        public void testAsin() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(0.633984, 2.30551);        TestUtils.assertEquals(expected, z.asin(), 1.0e-5);    }        public void testAsinNaN() {        assertTrue(Complex.NaN.asin().isNaN());    }        public void testAsinInf() {        TestUtils.assertSame(Complex.NaN, oneInf.asin());        TestUtils.assertSame(Complex.NaN, oneNegInf.asin());        TestUtils.assertSame(Complex.NaN, infOne.asin());        TestUtils.assertSame(Complex.NaN, negInfOne.asin());        TestUtils.assertSame(Complex.NaN, infInf.asin());        TestUtils.assertSame(Complex.NaN, infNegInf.asin());        TestUtils.assertSame(Complex.NaN, negInfInf.asin());        TestUtils.assertSame(Complex.NaN, negInfNegInf.asin());    }           public void testAtan() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(1.44831, 0.158997);        TestUtils.assertEquals(expected, z.atan(), 1.0e-5);    }        public void testAtanInf() {        TestUtils.assertSame(Complex.NaN, oneInf.atan());        TestUtils.assertSame(Complex.NaN, oneNegInf.atan());        TestUtils.assertSame(Complex.NaN, infOne.atan());        TestUtils.assertSame(Complex.NaN, negInfOne.atan());        TestUtils.assertSame(Complex.NaN, infInf.atan());        TestUtils.assertSame(Complex.NaN, infNegInf.atan());        TestUtils.assertSame(Complex.NaN, negInfInf.atan());        TestUtils.assertSame(Complex.NaN, negInfNegInf.atan());    }         public void testAtanNaN() {        assertTrue(Complex.NaN.atan().isNaN());        assertTrue(Complex.I.atan().isNaN());    }        public void testCos() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-27.03495, -3.851153);        TestUtils.assertEquals(expected, z.cos(), 1.0e-5);    }        public void testCosNaN() {        assertTrue(Complex.NaN.cos().isNaN());    }        public void testCosInf() {        TestUtils.assertSame(infNegInf, oneInf.cos());        TestUtils.assertSame(infInf, oneNegInf.cos());        TestUtils.assertSame(Complex.NaN, infOne.cos());        TestUtils.assertSame(Complex.NaN, negInfOne.cos());        TestUtils.assertSame(Complex.NaN, infInf.cos());        TestUtils.assertSame(Complex.NaN, infNegInf.cos());        TestUtils.assertSame(Complex.NaN, negInfInf.cos());        TestUtils.assertSame(Complex.NaN, negInfNegInf.cos());    }         public void testCosh() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-6.58066, -7.58155);        TestUtils.assertEquals(expected, z.cosh(), 1.0e-5);    }        public void testCoshNaN() {        assertTrue(Complex.NaN.cosh().isNaN());    }        public void testCoshInf() {          TestUtils.assertSame(Complex.NaN, oneInf.cosh());        TestUtils.assertSame(Complex.NaN, oneNegInf.cosh());        TestUtils.assertSame(infInf, infOne.cosh());        TestUtils.assertSame(infNegInf, negInfOne.cosh());        TestUtils.assertSame(Complex.NaN, infInf.cosh());        TestUtils.assertSame(Complex.NaN, infNegInf.cosh());        TestUtils.assertSame(Complex.NaN, negInfInf.cosh());        TestUtils.assertSame(Complex.NaN, negInfNegInf.cosh());    }         public void testExp() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-13.12878, -15.20078);        TestUtils.assertEquals(expected, z.exp(), 1.0e-5);        TestUtils.assertEquals(Complex.ONE,                 Complex.ZERO.exp(), 10e-12);        Complex iPi = Complex.I.multiply(new Complex(pi,0));        TestUtils.assertEquals(Complex.ONE.negate(),                 iPi.exp(), 10e-12);    }        public void testExpNaN() {        assertTrue(Complex.NaN.exp().isNaN());    }        public void testExpInf() {        TestUtils.assertSame(Complex.NaN, oneInf.exp());        TestUtils.assertSame(Complex.NaN, oneNegInf.exp());        TestUtils.assertSame(infInf, infOne.exp());        TestUtils.assertSame(Complex.ZERO, negInfOne.exp());        TestUtils.assertSame(Complex.NaN, infInf.exp());        TestUtils.assertSame(Complex.NaN, infNegInf.exp());        TestUtils.assertSame(Complex.NaN, negInfInf.exp());        TestUtils.assertSame(Complex.NaN, negInfNegInf.exp());    }        public void testLog() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(1.60944, 0.927295);        TestUtils.assertEquals(expected, z.log(), 1.0e-5);    }        public void testLogNaN() {        assertTrue(Complex.NaN.log().isNaN());    }        public void testLogInf() {        TestUtils.assertEquals(new Complex(inf, pi / 2),                oneInf.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, -pi / 2),                oneNegInf.log(), 10e-12);        TestUtils.assertEquals(infZero, infOne.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, pi),                negInfOne.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, pi / 4),                infInf.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, -pi / 4),                infNegInf.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, 3d * pi / 4),                negInfInf.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),                negInfNegInf.log(), 10e-12);    }        public void testLogZero() {        TestUtils.assertSame(negInfZero, Complex.ZERO.log());    }        public void testPow() {        Complex x = new Complex(3, 4);        Complex y = new Complex(5, 6);        Complex expected = new Complex(-1.860893, 11.83677);        TestUtils.assertEquals(expected, x.pow(y), 1.0e-5);    }        public void testPowNaNBase() {        Complex x = new Complex(3, 4);        assertTrue(Complex.NaN.pow(x).isNaN());    }        public void testPowNaNExponent() {        Complex x = new Complex(3, 4);        assertTrue(x.pow(Complex.NaN).isNaN());    }       public void testPowInf() {       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneInf));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneNegInf));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infOne));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infInf));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infNegInf));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfInf));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfNegInf));       TestUtils.assertSame(Complex.NaN,infOne.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,negInfOne.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,infInf.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,infNegInf.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,negInfInf.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infNegInf));       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(negInfNegInf));       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infInf));       TestUtils.assertSame(Complex.NaN,infInf.pow(infNegInf));       TestUtils.assertSame(Complex.NaN,infInf.pow(negInfNegInf));       TestUtils.assertSame(Complex.NaN,infInf.pow(infInf));       TestUtils.assertSame(Complex.NaN,infNegInf.pow(infNegInf));       TestUtils.assertSame(Complex.NaN,infNegInf.pow(negInfNegInf));       TestUtils.assertSame(Complex.NaN,infNegInf.pow(infInf));      }      public void testPowZero() {       TestUtils.assertSame(Complex.NaN,                Complex.ZERO.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,                Complex.ZERO.pow(Complex.ZERO));       TestUtils.assertSame(Complex.NaN,                Complex.ZERO.pow(Complex.I));       TestUtils.assertEquals(Complex.ONE,               Complex.ONE.pow(Complex.ZERO), 10e-12);       TestUtils.assertEquals(Complex.ONE,               Complex.I.pow(Complex.ZERO), 10e-12);       TestUtils.assertEquals(Complex.ONE,               new Complex(-1, 3).pow(Complex.ZERO), 10e-12);   }        public void testpowNull() {        try {            Complex.ONE.pow(null);             fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }        public void testSin() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(3.853738, -27.01681);        TestUtils.assertEquals(expected, z.sin(), 1.0e-5);    }        public void testSinInf() {        TestUtils.assertSame(infInf, oneInf.sin());        TestUtils.assertSame(infNegInf, oneNegInf.sin());        TestUtils.assertSame(Complex.NaN, infOne.sin());        TestUtils.assertSame(Complex.NaN, negInfOne.sin());        TestUtils.assertSame(Complex.NaN, infInf.sin());        TestUtils.assertSame(Complex.NaN, infNegInf.sin());        TestUtils.assertSame(Complex.NaN, negInfInf.sin());        TestUtils.assertSame(Complex.NaN, negInfNegInf.sin());    }        public void testSinNaN() {        assertTrue(Complex.NaN.sin().isNaN());    }        public void testSinh() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-6.54812, -7.61923);        TestUtils.assertEquals(expected, z.sinh(), 1.0e-5);    }        public void testSinhNaN() {        assertTrue(Complex.NaN.sinh().isNaN());    }        public void testSinhInf() {        TestUtils.assertSame(Complex.NaN, oneInf.sinh());        TestUtils.assertSame(Complex.NaN, oneNegInf.sinh());        TestUtils.assertSame(infInf, infOne.sinh());        TestUtils.assertSame(negInfInf, negInfOne.sinh());        TestUtils.assertSame(Complex.NaN, infInf.sinh());        TestUtils.assertSame(Complex.NaN, infNegInf.sinh());        TestUtils.assertSame(Complex.NaN, negInfInf.sinh());        TestUtils.assertSame(Complex.NaN, negInfNegInf.sinh());    }        public void testSqrtRealPositive() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(2, 1);        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);    }        public void testSqrtRealZero() {        Complex z = new Complex(0.0, 4);        Complex expected = new Complex(1.41421, 1.41421);        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);    }        public void testSqrtRealNegative() {        Complex z = new Complex(-3.0, 4);        Complex expected = new Complex(1, 2);        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);    }        public void testSqrtImaginaryZero() {        Complex z = new Complex(-3.0, 0.0);        Complex expected = new Complex(0.0, 1.73205);        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);    }        public void testSqrtImaginaryNegative() {        Complex z = new Complex(-3.0, -4.0);        Complex expected = new Complex(1.0, -2.0);        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);    }        public void testSqrtPolar() {        double r = 1;        for (int i = 0; i < 5; i++) {            r += i;            double theta = 0;            for (int j =0; j < 11; j++) {                theta += pi /12;                Complex z = ComplexUtils.polar2Complex(r, theta);                Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2);                TestUtils.assertEquals(sqrtz, z.sqrt(), 10e-12);            }        }           }        public void testSqrtNaN() {        assertTrue(Complex.NaN.sqrt().isNaN());    }          public void testSqrtInf() {        TestUtils.assertSame(infNaN, oneInf.sqrt());        TestUtils.assertSame(infNaN, oneNegInf.sqrt());        TestUtils.assertSame(infZero, infOne.sqrt());        TestUtils.assertSame(zeroInf, negInfOne.sqrt());        TestUtils.assertSame(infNaN, infInf.sqrt());        TestUtils.assertSame(infNaN, infNegInf.sqrt());        TestUtils.assertSame(nanInf, negInfInf.sqrt());        TestUtils.assertSame(nanNegInf, negInfNegInf.sqrt());    }        public void testSqrt1z() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(4.08033, -2.94094);        TestUtils.assertEquals(expected, z.sqrt1z(), 1.0e-5);    }        public void testSqrt1zNaN() {        assertTrue(Complex.NaN.sqrt1z().isNaN());    }        public void testTan() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-0.000187346, 0.999356);        TestUtils.assertEquals(expected, z.tan(), 1.0e-5);    }        public void testTanNaN() {        assertTrue(Complex.NaN.tan().isNaN());    }        public void testTanInf() {        TestUtils.assertSame(zeroNaN, oneInf.tan());        TestUtils.assertSame(zeroNaN, oneNegInf.tan());        TestUtils.assertSame(Complex.NaN, infOne.tan());        TestUtils.assertSame(Complex.NaN, negInfOne.tan());        TestUtils.assertSame(Complex.NaN, infInf.tan());        TestUtils.assertSame(Complex.NaN, infNegInf.tan());        TestUtils.assertSame(Complex.NaN, negInfInf.tan());        TestUtils.assertSame(Complex.NaN, negInfNegInf.tan());    }       public void testTanCritical() {        TestUtils.assertSame(infNaN, new Complex(pi/2, 0).tan());        TestUtils.assertSame(negInfNaN, new Complex(-pi/2, 0).tan());    }        public void testTanh() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(1.00071, 0.00490826);        TestUtils.assertEquals(expected, z.tanh(), 1.0e-5);    }        public void testTanhNaN() {        assertTrue(Complex.NaN.tanh().isNaN());    }        public void testTanhInf() {        TestUtils.assertSame(Complex.NaN, oneInf.tanh());        TestUtils.assertSame(Complex.NaN, oneNegInf.tanh());        TestUtils.assertSame(nanZero, infOne.tanh());        TestUtils.assertSame(nanZero, negInfOne.tanh());        TestUtils.assertSame(Complex.NaN, infInf.tanh());        TestUtils.assertSame(Complex.NaN, infNegInf.tanh());        TestUtils.assertSame(Complex.NaN, negInfInf.tanh());        TestUtils.assertSame(Complex.NaN, negInfNegInf.tanh());    }        public void testTanhCritical() {        TestUtils.assertSame(nanInf, new Complex(0, pi/2).tanh());    }    /** test issue MATH-221 */    public void testMath221() {        assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0)));    }        /**      * Test: computing <b>third roots</b> of z.     * <pre>     * <code>     * <b>z = -2 + 2 * i</b>     *   => z_0 =  1      +          i     *   => z_1 = -1.3660 + 0.3660 * i     *   => z_2 =  0.3660 - 1.3660 * i     * </code>     * </pre>     */    public void testNthRoot_normal_thirdRoot() {        // The complex number we want to compute all third-roots for.        Complex z = new Complex(-2,2);        // The List holding all third roots        Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);        // Returned Collection must not be empty!        assertEquals(3, thirdRootsOfZ.length);        // test z_0        assertEquals(1.0,                  thirdRootsOfZ[0].getReal(),      1.0e-5);         assertEquals(1.0,                  thirdRootsOfZ[0].getImaginary(), 1.0e-5);        // test z_1        assertEquals(-1.3660254037844386,  thirdRootsOfZ[1].getReal(),      1.0e-5);        assertEquals(0.36602540378443843,  thirdRootsOfZ[1].getImaginary(), 1.0e-5);        // test z_2        assertEquals(0.366025403784439,    thirdRootsOfZ[2].getReal(),      1.0e-5);        assertEquals(-1.3660254037844384,  thirdRootsOfZ[2].getImaginary(), 1.0e-5);    }    /**      * Test: computing <b>fourth roots</b> of z.     * <pre>     * <code>     * <b>z = 5 - 2 * i</b>     *   => z_0 =  1.5164 - 0.1446 * i     *   => z_1 =  0.1446 + 1.5164 * i     *   => z_2 = -1.5164 + 0.1446 * i     *   => z_3 = -1.5164 - 0.1446 * i     * </code>     * </pre>     */    public void testNthRoot_normal_fourthRoot() {        // The complex number we want to compute all third-roots for.        Complex z = new Complex(5,-2);        // The List holding all fourth roots        Complex[] fourthRootsOfZ = z.nthRoot(4).toArray(new Complex[0]);        // Returned Collection must not be empty!        assertEquals(4, fourthRootsOfZ.length);        // test z_0        assertEquals(1.5164629308487783,     fourthRootsOfZ[0].getReal(),      1.0e-5);         assertEquals(-0.14469266210702247,   fourthRootsOfZ[0].getImaginary(), 1.0e-5);        // test z_1        assertEquals(0.14469266210702256,    fourthRootsOfZ[1].getReal(),      1.0e-5);        assertEquals(1.5164629308487783,     fourthRootsOfZ[1].getImaginary(), 1.0e-5);        // test z_2        assertEquals(-1.5164629308487783,    fourthRootsOfZ[2].getReal(),      1.0e-5);        assertEquals(0.14469266210702267,    fourthRootsOfZ[2].getImaginary(), 1.0e-5);        // test z_3        assertEquals(-0.14469266210702275,   fourthRootsOfZ[3].getReal(),      1.0e-5);        assertEquals(-1.5164629308487783,    fourthRootsOfZ[3].getImaginary(), 1.0e-5);    }    /**      * Test: computing <b>third roots</b> of z.     * <pre>     * <code>     * <b>z = 8</b>     *   => z_0 =  2     *   => z_1 = -1 + 1.73205 * i     *   => z_2 = -1 - 1.73205 * i     * </code>     * </pre>     */    public void testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty() {        // The number 8 has three third roots. One we all already know is the number 2.        // But there are two more complex roots.        Complex z = new Complex(8,0);        // The List holding all third roots        Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);        // Returned Collection must not be empty!        assertEquals(3, thirdRootsOfZ.length);        // test z_0        assertEquals(2.0,                thirdRootsOfZ[0].getReal(),      1.0e-5);         assertEquals(0.0,                thirdRootsOfZ[0].getImaginary(), 1.0e-5);        // test z_1        assertEquals(-1.0,               thirdRootsOfZ[1].getReal(),      1.0e-5);        assertEquals(1.7320508075688774, thirdRootsOfZ[1].getImaginary(), 1.0e-5);        // test z_2        assertEquals(-1.0,               thirdRootsOfZ[2].getReal(),      1.0e-5);        assertEquals(-1.732050807568877, thirdRootsOfZ[2].getImaginary(), 1.0e-5);    }    /**      * Test: computing <b>third roots</b> of z with real part 0.     * <pre>     * <code>     * <b>z = 2 * i</b>     *   => z_0 =  1.0911 + 0.6299 * i     *   => z_1 = -1.0911 + 0.6299 * i     *   => z_2 = -2.3144 - 1.2599 * i     * </code>     * </pre>     */    public void testNthRoot_cornercase_thirdRoot_realPartZero() {        // complex number with only imaginary part        Complex z = new Complex(0,2);        // The List holding all third roots        Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);        // Returned Collection must not be empty!        assertEquals(3, thirdRootsOfZ.length);        // test z_0        assertEquals(1.0911236359717216,      thirdRootsOfZ[0].getReal(),      1.0e-5);         assertEquals(0.6299605249474365,      thirdRootsOfZ[0].getImaginary(), 1.0e-5);        // test z_1        assertEquals(-1.0911236359717216,     thirdRootsOfZ[1].getReal(),      1.0e-5);        assertEquals(0.6299605249474365,      thirdRootsOfZ[1].getImaginary(), 1.0e-5);        // test z_2        assertEquals(-2.3144374213981936E-16, thirdRootsOfZ[2].getReal(),      1.0e-5);        assertEquals(-1.2599210498948732,     thirdRootsOfZ[2].getImaginary(), 1.0e-5);    }    /**     * Test cornercases with NaN and Infinity.     */    public void testNthRoot_cornercase_NAN_Inf() {        // NaN + finite -> NaN        List<Complex> roots = oneNaN.nthRoot(3);        assertEquals(1,roots.size());        assertEquals(Complex.NaN, roots.get(0));                roots = nanZero.nthRoot(3);        assertEquals(1,roots.size());        assertEquals(Complex.NaN, roots.get(0));                // NaN + infinite -> NaN        roots = nanInf.nthRoot(3);        assertEquals(1,roots.size());        assertEquals(Complex.NaN, roots.get(0));                // finite + infinite -> Inf        roots = oneInf.nthRoot(3);        assertEquals(1,roots.size());        assertEquals(Complex.INF, roots.get(0));                // infinite + infinite -> Inf        roots = negInfInf.nthRoot(3);        assertEquals(1,roots.size());        assertEquals(Complex.INF, roots.get(0));    }        /**     * Test standard values     */    public void testGetArgument() {        Complex z = new Complex(1, 0);        assertEquals(0.0, z.getArgument(), 1.0e-12);                z = new Complex(1, 1);        assertEquals(Math.PI/4, z.getArgument(), 1.0e-12);                z = new Complex(0, 1);        assertEquals(Math.PI/2, z.getArgument(), 1.0e-12);                z = new Complex(-1, 1);        assertEquals(3 * Math.PI/4, z.getArgument(), 1.0e-12);                z = new Complex(-1, 0);        assertEquals(Math.PI, z.getArgument(), 1.0e-12);                z = new Complex(-1, -1);        assertEquals(-3 * Math.PI/4, z.getArgument(), 1.0e-12);                z = new Complex(0, -1);        assertEquals(-Math.PI/2, z.getArgument(), 1.0e-12);                z = new Complex(1, -1);        assertEquals(-Math.PI/4, z.getArgument(), 1.0e-12);            }        /**     * Verify atan2-style handling of infinite parts     */    public void testGetArgumentInf() {        assertEquals(Math.PI/4, infInf.getArgument(), 1.0e-12);        assertEquals(Math.PI/2, oneInf.getArgument(), 1.0e-12);        assertEquals(0.0, infOne.getArgument(), 1.0e-12);        assertEquals(Math.PI/2, zeroInf.getArgument(), 1.0e-12);        assertEquals(0.0, infZero.getArgument(), 1.0e-12);        assertEquals(Math.PI, negInfOne.getArgument(), 1.0e-12);        assertEquals(-3.0*Math.PI/4, negInfNegInf.getArgument(), 1.0e-12);          assertEquals(-Math.PI/2, oneNegInf.getArgument(), 1.0e-12);            }        /**     * Verify that either part NaN results in NaN     */    public void testGetArgumentNaN() {        assertEquals(nan, nanZero.getArgument());        assertEquals(nan, zeroNaN.getArgument());        assertEquals(nan, Complex.NaN.getArgument());      }        public void testSerial() {        Complex z = new Complex(3.0, 4.0);        assertEquals(z, TestUtils.serializeAndRecover(z));        Complex ncmplx = (Complex)TestUtils.serializeAndRecover(oneNaN);        assertEquals(nanZero, ncmplx);        assertTrue(ncmplx.isNaN());        Complex infcmplx = (Complex)TestUtils.serializeAndRecover(infInf);        assertEquals(infInf, infcmplx);        assertTrue(infcmplx.isInfinite());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import java.util.Locale;public class FrenchComplexFormatTest extends ComplexFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return ',';    }    @Override    protected Locale getLocale() {        return Locale.FRENCH;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import java.text.NumberFormat;import java.text.ParseException;import java.text.ParsePosition;import java.util.Locale;import org.apache.commons.math.util.CompositeFormat;import junit.framework.TestCase;public abstract class ComplexFormatAbstractTest extends TestCase {     CompositeFormat complexFormat = null;    ComplexFormat complexFormatJ = null;    protected abstract Locale getLocale();    protected abstract char getDecimalCharacter();    @Override    protected void setUp() throws Exception {        complexFormat = ComplexFormat.getInstance(getLocale());        complexFormatJ = ComplexFormat.getInstance(getLocale());        complexFormatJ.setImaginaryCharacter("j");    }       public void testSimpleNoDecimals() {        Complex c = new Complex(1, 1);        String expected = "1 + 1i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testSimpleWithDecimals() {        Complex c = new Complex(1.23, 1.43);        String expected = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testSimpleWithDecimalsTrunc() {        Complex c = new Complex(1.2323, 1.4343);        String expected = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testNegativeReal() {        Complex c = new Complex(-1.2323, 1.4343);        String expected = "-1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testNegativeImaginary() {        Complex c = new Complex(1.2323, -1.4343);        String expected = "1" + getDecimalCharacter() + "23 - 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testNegativeBoth() {        Complex c = new Complex(-1.2323, -1.4343);        String expected = "-1" + getDecimalCharacter() + "23 - 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testZeroReal() {        Complex c = new Complex(0.0, -1.4343);        String expected = "0 - 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testZeroImaginary() {        Complex c = new Complex(30.233, 0);        String expected = "30" + getDecimalCharacter() + "23";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testDifferentImaginaryChar() {        Complex c = new Complex(1, 1);        String expected = "1 + 1j";        String actual = complexFormatJ.format(c);         assertEquals(expected, actual);    }        public void testStaticFormatComplex() {        Locale defaultLocal = Locale.getDefault();        Locale.setDefault(getLocale());                Complex c = new Complex(232.222, -342.33);        String expected = "232" + getDecimalCharacter() + "22 - 342" + getDecimalCharacter() + "33i";        String actual = ComplexFormat.formatComplex(c);         assertEquals(expected, actual);                Locale.setDefault(defaultLocal);    }    public void testNan() {        Complex c = new Complex(Double.NaN, Double.NaN);        String expected = "(NaN) + (NaN)i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testPositiveInfinity() {        Complex c = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);        String expected = "(Infinity) + (Infinity)i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }    public void testNegativeInfinity() {        Complex c = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);        String expected = "(-Infinity) - (Infinity)i";        String actual = complexFormat.format(c);         assertEquals(expected, actual);    }        public void testParseSimpleNoDecimals() {        String source = "1 + 1i";        Complex expected = new Complex(1, 1);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseSimpleWithDecimals() {        String source = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";        Complex expected = new Complex(1.23, 1.43);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseSimpleWithDecimalsTrunc() {        String source = "1" + getDecimalCharacter() + "2323 + 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(1.2323, 1.4343);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeReal() {        String source = "-1" + getDecimalCharacter() + "2323 + 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(-1.2323, 1.4343);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeImaginary() {        String source = "1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(1.2323, -1.4343);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeBoth() {        String source = "-1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(-1.2323, -1.4343);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseZeroReal() {        String source = "0" + getDecimalCharacter() + "0 - 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(0.0, -1.4343);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseZeroImaginary() {        String source = "-1" + getDecimalCharacter() + "2323";        Complex expected = new Complex(-1.2323, 0);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseDifferentImaginaryChar() {        String source = "-1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343j";        Complex expected = new Complex(-1.2323, -1.4343);        try {            Complex actual = (Complex)complexFormatJ.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }        public void testParseNan() {        String source = "(NaN) + (NaN)i";        Complex expected = new Complex(Double.NaN, Double.NaN);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParsePositiveInfinity() {        String source = "(Infinity) + (Infinity)i";        Complex expected = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testPaseNegativeInfinity() {        String source = "(-Infinity) - (Infinity)i";        Complex expected = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);        try {            Complex actual = (Complex)complexFormat.parseObject(source);             assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }        public void testConstructorSingleFormat() {        NumberFormat nf = NumberFormat.getInstance();        ComplexFormat cf = new ComplexFormat(nf);        assertNotNull(cf);        assertEquals(nf, cf.getRealFormat());    }        public void testGetImaginaryFormat() {        NumberFormat nf = NumberFormat.getInstance();        ComplexFormat cf = new ComplexFormat();                assertNotSame(nf, cf.getImaginaryFormat());        cf.setImaginaryFormat(nf);        assertSame(nf, cf.getImaginaryFormat());    }        public void testSetImaginaryFormatNull() {        try {            ComplexFormat cf = new ComplexFormat();            cf.setImaginaryFormat(null);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }        public void testSetRealFormatNull() {        try {            ComplexFormat cf = new ComplexFormat();            cf.setRealFormat(null);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }        public void testGetRealFormat() {        NumberFormat nf = NumberFormat.getInstance();        ComplexFormat cf = new ComplexFormat();                assertNotSame(nf, cf.getRealFormat());        cf.setRealFormat(nf);        assertSame(nf, cf.getRealFormat());    }        public void testSetImaginaryCharacterNull() {        try {            ComplexFormat cf = new ComplexFormat();            cf.setImaginaryCharacter(null);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }        public void testSetImaginaryCharacterEmpty() {        try {            ComplexFormat cf = new ComplexFormat();            cf.setImaginaryCharacter("");            fail();        } catch (IllegalArgumentException ex) {            // success        }    }        public void testFormatNumber() {        CompositeFormat cf = ComplexFormat.getInstance(getLocale());        Double pi = Double.valueOf(Math.PI);        String text = cf.format(pi);        assertEquals("3" + getDecimalCharacter() + "14", text);    }        public void testFormatObject() {        try {            CompositeFormat cf = new ComplexFormat();            Object object = new Object();            cf.format(object);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }    public void testForgottenImaginaryCharacter() {        ParsePosition pos = new ParsePosition(0);        assertNull(new ComplexFormat().parse("1 + 1", pos));        assertEquals(5, pos.getErrorIndex());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class ComplexUtilsTest extends TestCase {        private double inf = Double.POSITIVE_INFINITY;    private double negInf = Double.NEGATIVE_INFINITY;    private double nan = Double.NaN;    private double pi = Math.PI;        private Complex negInfInf = new Complex(negInf, inf);    private Complex infNegInf = new Complex(inf, negInf);    private Complex infInf = new Complex(inf, inf);    private Complex negInfNegInf = new Complex(negInf, negInf);    private Complex infNaN = new Complex(inf, nan);    public void testPolar2Complex() {        TestUtils.assertEquals(Complex.ONE,                 ComplexUtils.polar2Complex(1, 0), 10e-12);        TestUtils.assertEquals(Complex.ZERO,                 ComplexUtils.polar2Complex(0, 1), 10e-12);        TestUtils.assertEquals(Complex.ZERO,                 ComplexUtils.polar2Complex(0, -1), 10e-12);        TestUtils.assertEquals(Complex.I,                 ComplexUtils.polar2Complex(1, pi/2), 10e-12);        TestUtils.assertEquals(Complex.I.negate(),                 ComplexUtils.polar2Complex(1, -pi/2), 10e-12);        double r = 0;        for (int i = 0; i < 5; i++) {          r += i;          double theta = 0;          for (int j =0; j < 20; j++) {              theta += pi / 6;              TestUtils.assertEquals(altPolar(r, theta),                       ComplexUtils.polar2Complex(r, theta), 10e-12);          }          theta = -2 * pi;          for (int j =0; j < 20; j++) {              theta -= pi / 6;              TestUtils.assertEquals(altPolar(r, theta),                       ComplexUtils.polar2Complex(r, theta), 10e-12);          }        }       }    protected Complex altPolar(double r, double theta) {        return Complex.I.multiply(new Complex(theta, 0)).exp().multiply(new Complex(r, 0));    }        public void testPolar2ComplexIllegalModulus() {        try {            ComplexUtils.polar2Complex(-1, 0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }           }        public void testPolar2ComplexNaN() {        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(nan, 1));        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, nan));        TestUtils.assertSame(Complex.NaN,                 ComplexUtils.polar2Complex(nan, nan));         }        public void testPolar2ComplexInf() {        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, inf));        TestUtils.assertSame(Complex.NaN,                ComplexUtils.polar2Complex(1, negInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(inf, inf));        TestUtils.assertSame(Complex.NaN,                ComplexUtils.polar2Complex(inf, negInf));        TestUtils.assertSame(infInf, ComplexUtils.polar2Complex(inf, pi/4));        TestUtils.assertSame(infNaN, ComplexUtils.polar2Complex(inf, 0));        TestUtils.assertSame(infNegInf, ComplexUtils.polar2Complex(inf, -pi/4));        TestUtils.assertSame(negInfInf, ComplexUtils.polar2Complex(inf, 3*pi/4));        TestUtils.assertSame(negInfNegInf, ComplexUtils.polar2Complex(inf, 5*pi/4));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import java.util.Locale;public class ComplexFormatTest extends ComplexFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return '.';    }        @Override    protected Locale getLocale() {        return Locale.US;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.util.Locale;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class ArgumentOutsideDomainExceptionTest extends TestCase {        public void testConstructor(){        ArgumentOutsideDomainException ex = new ArgumentOutsideDomainException(Math.PI, 10.0, 20.0);        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertTrue(ex.getMessage().indexOf("3.14") > 0);        assertEquals(Math.PI, ex.getArgument()[0], 0);        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import junit.framework.TestCase;import java.io.ByteArrayOutputStream;import java.io.PrintStream;import java.io.PrintWriter;import java.util.Locale;/** * @version $Revision$ $Date$ */public class MathExceptionTest extends TestCase {    public void testConstructor(){        MathException ex = new MathException();        assertNull(ex.getCause());        assertNull(ex.getMessage());        assertEquals(0, ex.getMessage(Locale.FRENCH).length());    }        public void testConstructorPatternArguments(){        String pattern = "a {0}x{1} matrix cannot be a rotation matrix";        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };        MathException ex = new MathException(pattern, arguments);        assertNull(ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }        public void testConstructorCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathException ex = new MathException(cause);        assertEquals(cause, ex.getCause());    }    public void testConstructorPatternArgumentsCause(){        String pattern = "a {0}x{1} matrix cannot be a rotation matrix";        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathException ex = new MathException(cause, pattern, arguments);        assertEquals(cause, ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }        /**     * Tests the printStackTrace() operation.     */    public void testPrintStackTrace() {        String outMsg = "outer message";        String inMsg = "inner message";        MathException cause = new MathConfigurationException(inMsg);        MathException ex = new MathException(cause, outMsg);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        PrintStream ps = new PrintStream(baos);        ex.printStackTrace(ps);        String stack = baos.toString();        String outerMsg = "org.apache.commons.math.MathException: outer message";        String innerMsg = "Caused by: " +         "org.apache.commons.math.MathConfigurationException: inner message";        assertTrue(stack.startsWith(outerMsg));        assertTrue(stack.indexOf(innerMsg) > 0);                PrintWriter pw = new PrintWriter(ps, true);        ex.printStackTrace(pw);        stack = baos.toString();        assertTrue(stack.startsWith(outerMsg));        assertTrue(stack.indexOf(innerMsg) > 0);    }        /**     * Test serialization     */    public void testSerialization() {        String outMsg = "outer message";        String inMsg = "inner message";        MathException cause = new MathConfigurationException(inMsg);        MathException ex = new MathException(cause, outMsg);        MathException image = (MathException) TestUtils.serializeAndRecover(ex);                ByteArrayOutputStream baos = new ByteArrayOutputStream();        PrintStream ps = new PrintStream(baos);        ex.printStackTrace(ps);        String stack = baos.toString();                ByteArrayOutputStream baos2 = new ByteArrayOutputStream();        PrintStream ps2 = new PrintStream(baos2);        image.printStackTrace(ps2);        String stack2 = baos2.toString();                // See if JDK supports nested exceptions.  If not, stack trace of        // inner exception will not be serialized        boolean jdkSupportsNesting = false;        try {            Throwable.class.getDeclaredMethod("getCause", new Class[0]);            jdkSupportsNesting = true;        } catch (NoSuchMethodException e) {            jdkSupportsNesting = false;        }                if (jdkSupportsNesting) {            assertEquals(stack, stack2);        } else {            assertTrue(stack2.indexOf(inMsg) != -1);            assertTrue(stack2.indexOf("MathConfigurationException") != -1);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.util.Locale;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class MaxIterationsExceededExceptionTest extends TestCase {        public void testSimpleConstructor(){        MaxIterationsExceededException ex = new MaxIterationsExceededException(1000000);        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertTrue(ex.getMessage().indexOf("1,000,000") > 0);        assertEquals(1000000, ex.getMaxIterations());        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    public void testComplexConstructor(){        MaxIterationsExceededException ex =            new MaxIterationsExceededException(1000000,                "Continued fraction convergents failed to converge for value {0}",                1234567);        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertTrue(ex.getMessage().indexOf("1,000,000") < 0);        assertTrue(ex.getMessage().indexOf("1,234,567") > 0);        assertEquals(1000000, ex.getMaxIterations());        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.util.Locale;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class FunctionEvaluationExceptionTest extends TestCase {        public void testConstructor(){        FunctionEvaluationException ex = new FunctionEvaluationException(0.0);        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertTrue(ex.getMessage().indexOf("0") > 0);        assertEquals(0.0, ex.getArgument()[0], 0);    }        public void testConstructorArray(){        FunctionEvaluationException ex =            new FunctionEvaluationException(new double[] { 0, 1, 2 });        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertTrue(ex.getMessage().indexOf("0") > 0);        assertEquals(0.0, ex.getArgument()[0], 0);        assertEquals(1.0, ex.getArgument()[1], 0);        assertEquals(2.0, ex.getArgument()[2], 0);    }        public void testConstructorPatternArguments(){        String pattern = "evaluation failed for argument = {0}";        Object[] arguments = { Double.valueOf(0.0) };        FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments);        assertNull(ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    public void testConstructorArrayPatternArguments(){        String pattern = "evaluation failed for argument = {0}";        Object[] arguments = { Double.valueOf(0.0) };        FunctionEvaluationException ex =            new FunctionEvaluationException(new double[] { 0, 1, 2 }, pattern, arguments);        assertNull(ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));        assertEquals(0.0, ex.getArgument()[0], 0);        assertEquals(1.0, ex.getArgument()[1], 0);        assertEquals(2.0, ex.getArgument()[2], 0);    }    public void testConstructorPatternArgumentsCause(){        String pattern = "evaluation failed for argument = {0}";        Object[] arguments = { Double.valueOf(0.0) };        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        FunctionEvaluationException ex = new FunctionEvaluationException(cause, 0.0, pattern, arguments);        assertEquals(cause, ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    public void testConstructorArrayPatternArgumentsCause(){        String pattern = "evaluation failed for argument = {0}";        Object[] arguments = { Double.valueOf(0.0) };        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        FunctionEvaluationException ex =            new FunctionEvaluationException(cause, new double[] { 0, 1, 2 }, pattern, arguments);        assertEquals(cause, ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));        assertEquals(0.0, ex.getArgument()[0], 0);        assertEquals(1.0, ex.getArgument()[1], 0);        assertEquals(2.0, ex.getArgument()[2], 0);    }    public void testConstructorArgumentCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        FunctionEvaluationException ex = new FunctionEvaluationException(cause, 0.0);        assertEquals(cause, ex.getCause());        assertTrue(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    public void testConstructorArrayArgumentCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        FunctionEvaluationException ex =            new FunctionEvaluationException(cause, new double[] { 0, 1, 2 });        assertEquals(cause, ex.getCause());        assertTrue(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));        assertEquals(0.0, ex.getArgument()[0], 0);        assertEquals(1.0, ex.getArgument()[1], 0);        assertEquals(2.0, ex.getArgument()[2], 0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import junit.framework.TestCase;import java.util.Locale;/** * @version $Revision$ $Date$ */public class MathConfigurationExceptionTest extends TestCase {    public void testConstructor(){        MathConfigurationException ex = new MathConfigurationException();        assertNull(ex.getCause());        assertNull(ex.getMessage());        assertEquals(0, ex.getMessage(Locale.FRENCH).length());    }        public void testConstructorPatternArguments(){        String pattern = "a {0}x{1} matrix cannot be a rotation matrix";        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };        MathConfigurationException ex = new MathConfigurationException(pattern, arguments);        assertNull(ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }        public void testConstructorCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathConfigurationException ex = new MathConfigurationException(cause);        assertEquals(cause, ex.getCause());    }    public void testConstructorPatternArgumentsCause(){        String pattern = "a {0}x{1} matrix cannot be a rotation matrix";        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathConfigurationException ex = new MathConfigurationException(cause, pattern, arguments);        assertEquals(cause, ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import junit.framework.Assert;import junit.framework.AssertionFailedError;import org.apache.commons.math.complex.Complex;import org.apache.commons.math.complex.ComplexFormat;import org.apache.commons.math.linear.FieldMatrix;import org.apache.commons.math.linear.RealMatrix;/** * @version $Revision$ $Date$ */public class TestUtils {    /**     * Collection of static methods used in math unit tests.     */    private TestUtils() {        super();    }    /**     * Verifies that expected and actual are within delta, or are both NaN or     * infinities of the same sign.     */    public static void assertEquals(double expected, double actual, double delta) {        assertEquals(null, expected, actual, delta);    }    /**     * Verifies that expected and actual are within delta, or are both NaN or     * infinities of the same sign.     */    public static void assertEquals(String msg, double expected, double actual, double delta) {        // check for NaN        if(Double.isNaN(expected)){            Assert.assertTrue("" + actual + " is not NaN.",                Double.isNaN(actual));        } else {            Assert.assertEquals(msg, expected, actual, delta);        }    }        /**     * Verifies that the two arguments are exactly the same, either     * both NaN or infinities of same sign, or identical floating point values.     */    public static void assertSame(double expected, double actual) {     assertEquals(expected, actual, 0);    }        /**     * Verifies that real and imaginary parts of the two complex arguments     * are exactly the same.  Also ensures that NaN / infinite components match.     */    public static void assertSame(Complex expected, Complex actual) {        assertSame(expected.getReal(), actual.getReal());        assertSame(expected.getImaginary(), actual.getImaginary());    }        /**     * Verifies that real and imaginary parts of the two complex arguments     * differ by at most delta.  Also ensures that NaN / infinite components match.     */    public static void assertEquals(Complex expected, Complex actual, double delta) {        assertEquals(expected.getReal(), actual.getReal(), delta);        assertEquals(expected.getImaginary(), actual.getImaginary(), delta);    }        /**     * Verifies that two double arrays have equal entries, up to tolerance     */    public static void assertEquals(double expected[], double observed[], double tolerance) {        assertEquals("Array comparison failure", expected, observed, tolerance);    }        /**     * Serializes an object to a bytes array and then recovers the object from the bytes array.     * Returns the deserialized object.     *      * @param o  object to serialize and recover     * @return  the recovered, deserialized object     */    public static Object serializeAndRecover(Object o) {        try {            // serialize the Object            ByteArrayOutputStream bos = new ByteArrayOutputStream();            ObjectOutputStream so = new ObjectOutputStream(bos);            so.writeObject(o);            // deserialize the Object            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());            ObjectInputStream si = new ObjectInputStream(bis);            return si.readObject();        } catch (IOException ioe) {            return null;        } catch (ClassNotFoundException cnfe) {            return null;        }    }        /**     * Verifies that serialization preserves equals and hashCode.     * Serializes the object, then recovers it and checks equals and hash code.     *      * @param object  the object to serialize and recover     */    public static void checkSerializedEquality(Object object) {        Object object2 = serializeAndRecover(object);        Assert.assertEquals("Equals check", object, object2);        Assert.assertEquals("HashCode check", object.hashCode(), object2.hashCode());    }    /**     * Verifies that the relative error in actual vs. expected is less than or     * equal to relativeError.  If expected is infinite or NaN, actual must be     * the same (NaN or infinity of the same sign).     *      * @param expected expected value     * @param actual  observed value     * @param relativeError  maximum allowable relative error     */    public static void assertRelativelyEquals(double expected, double actual,            double relativeError) {        assertRelativelyEquals(null, expected, actual, relativeError);    }        /**     * Verifies that the relative error in actual vs. expected is less than or     * equal to relativeError.  If expected is infinite or NaN, actual must be     * the same (NaN or infinity of the same sign).     *      * @param msg  message to return with failure     * @param expected expected value     * @param actual  observed value     * @param relativeError  maximum allowable relative error     */    public static void assertRelativelyEquals(String msg, double expected,            double actual, double relativeError) {        if (Double.isNaN(expected)) {            Assert.assertTrue(msg, Double.isNaN(actual));        } else if (Double.isNaN(actual)) {            Assert.assertTrue(msg, Double.isNaN(expected));        } else if (Double.isInfinite(actual) || Double.isInfinite(expected)) {            Assert.assertEquals(expected, actual, relativeError);        } else if (expected == 0.0) {            Assert.assertEquals(msg, actual, expected, relativeError);        } else {            double x = Math.abs((expected - actual) / expected);            Assert.assertEquals(msg, 0.0, x, relativeError);        }    }        /**     * Fails iff values does not contain a number within epsilon of z.     *      * @param msg  message to return with failure     * @param values complex array to search     * @param z  value sought     * @param epsilon  tolerance     */    public static void assertContains(String msg, Complex[] values,            Complex z, double epsilon) {        int i = 0;        boolean found = false;        while (!found && i < values.length) {            try {                assertEquals(values[i], z, epsilon);                found = true;             } catch (AssertionFailedError er) {                // no match            }            i++;        }        if (!found) {            Assert.fail(msg +                 " Unable to find " + ComplexFormat.formatComplex(z));        }    }        /**     * Fails iff values does not contain a number within epsilon of z.     *      * @param values complex array to search     * @param z  value sought     * @param epsilon  tolerance     */    public static void assertContains(Complex[] values,            Complex z, double epsilon) {        assertContains(null, values, z, epsilon);          }        /**     * Fails iff values does not contain a number within epsilon of x.     *      * @param msg  message to return with failure     * @param values double array to search     * @param x value sought     * @param epsilon  tolerance     */    public static void assertContains(String msg, double[] values,            double x, double epsilon) {        int i = 0;        boolean found = false;        while (!found && i < values.length) {            try {                assertEquals(values[i], x, epsilon);                found = true;             } catch (AssertionFailedError er) {                // no match            }            i++;        }        if (!found) {            Assert.fail(msg + " Unable to find" + x);        }    }        /**     * Fails iff values does not contain a number within epsilon of x.     *      * @param values double array to search     * @param x value sought     * @param epsilon  tolerance     */    public static void assertContains(double[] values, double x,            double epsilon) {       assertContains(null, values, x, epsilon);    }        /** verifies that two matrices are close (1-norm) */                  public static void assertEquals(String msg, RealMatrix expected, RealMatrix observed,        double tolerance) {                if (observed == null) {            Assert.fail(msg + "\nObserved is null");        }                if (expected.getColumnDimension() != observed.getColumnDimension() ||                 expected.getRowDimension() != observed.getRowDimension()) {            StringBuffer messageBuffer = new StringBuffer(msg);            messageBuffer.append("\nObserved has incorrect dimensions.");             messageBuffer.append("\nobserved is " + observed.getRowDimension() +                    " x " + observed.getColumnDimension());            messageBuffer.append("\nexpected " + expected.getRowDimension() +                    " x " + expected.getColumnDimension());            Assert.fail(messageBuffer.toString());        }        RealMatrix delta = expected.subtract(observed);        if (delta.getNorm() >= tolerance) {            StringBuffer messageBuffer = new StringBuffer(msg);            messageBuffer.append("\nExpected: " + expected);            messageBuffer.append("\nObserved: " + observed);            messageBuffer.append("\nexpected - observed: " + delta);            Assert.fail(messageBuffer.toString());        }    }        /** verifies that two matrices are equal */                  public static void assertEquals(FieldMatrix<? extends FieldElement<?>> expected,                                    FieldMatrix<? extends FieldElement<?>> observed) {                if (observed == null) {            Assert.fail("Observed is null");        }                if (expected.getColumnDimension() != observed.getColumnDimension() ||                 expected.getRowDimension() != observed.getRowDimension()) {            StringBuffer messageBuffer = new StringBuffer();            messageBuffer.append("Observed has incorrect dimensions.");             messageBuffer.append("\nobserved is " + observed.getRowDimension() +                    " x " + observed.getColumnDimension());            messageBuffer.append("\nexpected " + expected.getRowDimension() +                    " x " + expected.getColumnDimension());            Assert.fail(messageBuffer.toString());        }        for (int i = 0; i < expected.getRowDimension(); ++i) {            for (int j = 0; j < expected.getColumnDimension(); ++j) {                FieldElement<?> eij = expected.getEntry(i, j);                FieldElement<?> oij = observed.getEntry(i, j);                Assert.assertEquals(eij, oij);            }        }    }        /** verifies that two arrays are close (sup norm) */    public static void assertEquals(String msg, double[] expected, double[] observed,        double tolerance) {        StringBuffer out = new StringBuffer(msg);        if (expected.length != observed.length) {            out.append("\n Arrays not same length. \n");            out.append("expected has length ");            out.append(expected.length);            out.append(" observed length = ");            out.append(observed.length);            Assert.fail(out.toString());        }        boolean failure = false;        for (int i=0; i < expected.length; i++) {            try {                assertEquals(expected[i], observed[i], tolerance);            } catch (AssertionFailedError ex) {                failure = true;                out.append("\n Elements at index ");                out.append(i);                out.append(" differ. ");                out.append(" expected = ");                out.append(expected[i]);                out.append(" observed = ");                out.append(observed[i]);             }        }        if (failure) {            Assert.fail(out.toString());        }    }        /** verifies that two arrays are equal */    public static <T extends FieldElement<T>> void assertEquals(T[] m, T[] n) {        if (m.length != n.length) {            Assert.fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            Assert.assertEquals(m[i],n[i]);        }    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import junit.framework.TestCase;import java.util.Locale;/** * @version $Revision$ $Date$ */public class ConvergenceExceptionTest extends TestCase {    public void testConstructor(){        ConvergenceException ex = new ConvergenceException();        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertNotNull(ex.getMessage(Locale.FRENCH));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }        public void testConstructorPatternArguments(){        String pattern = "a {0}x{1} matrix cannot be a rotation matrix";        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };        ConvergenceException ex = new ConvergenceException(pattern, arguments);        assertNull(ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }        public void testConstructorCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        ConvergenceException ex = new ConvergenceException(cause);        assertEquals(cause, ex.getCause());    }    public void testConstructorPatternArgumentsCause(){        String pattern = "a {0}x{1} matrix cannot be a rotation matrix";        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        ConvergenceException ex = new ConvergenceException(cause, pattern, arguments);        assertEquals(cause, ex.getCause());        assertEquals(pattern, ex.getPattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.util.Locale;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class DuplicateSampleAbscissaExceptionTest extends TestCase {        public void testConstructor(){        DuplicateSampleAbscissaException ex = new DuplicateSampleAbscissaException(1.2, 10, 11);        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertTrue(ex.getMessage().indexOf("1.2") > 0);        assertEquals(1.2, ex.getDuplicateAbscissa(), 0);        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.MathException;/** * An interface for Chi-Square tests. * <p>This interface handles only known distributions. If the distribution is * unknown and should be provided by a sample, then the {@link UnknownDistributionChiSquareTest * UnknownDistributionChiSquareTest} extended interface should be used instead.</p> * @version $Revision$ $Date$  */public interface ChiSquareTest {          /**     * Computes the <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm">     * Chi-Square statistic</a> comparing <code>observed</code> and <code>expected</code>      * frequency counts.      * <p>     * This statistic can be used to perform a Chi-Square test evaluating the null hypothesis that     *  the observed counts follow the expected distribution.</p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Expected counts must all be positive.       * </li>     * <li>Observed counts must all be >= 0.        * </li>     * <li>The observed and expected arrays must have the same length and     * their common length must be at least 2.       * </li></ul></p><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed array of observed frequency counts     * @param expected array of expected frequency counts     * @return chiSquare statistic     * @throws IllegalArgumentException if preconditions are not met     */    double chiSquare(double[] expected, long[] observed)         throws IllegalArgumentException;        /**     * Returns the <i>observed significance level</i>, or <a href=     * "http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a      * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm">     * Chi-square goodness of fit test</a> comparing the <code>observed</code>      * frequency counts to those in the <code>expected</code> array.     * <p>     * The number returned is the smallest significance level at which one can reject      * the null hypothesis that the observed counts conform to the frequency distribution      * described by the expected counts.</p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Expected counts must all be positive.       * </li>     * <li>Observed counts must all be >= 0.        * </li>     * <li>The observed and expected arrays must have the same length and     * their common length must be at least 2.       * </li></ul></p><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed array of observed frequency counts     * @param expected array of expected frequency counts     * @return p-value     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs computing the p-value     */    double chiSquareTest(double[] expected, long[] observed)         throws IllegalArgumentException, MathException;        /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm">     * Chi-square goodness of fit test</a> evaluating the null hypothesis that the observed counts      * conform to the frequency distribution described by the expected counts, with      * significance level <code>alpha</code>.  Returns true iff the null hypothesis can be rejected     * with 100 * (1 - alpha) percent confidence.     * <p>     * <strong>Example:</strong><br>     * To test the hypothesis that <code>observed</code> follows      * <code>expected</code> at the 99% level, use </p><p>     * <code>chiSquareTest(expected, observed, 0.01) </code></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Expected counts must all be positive.       * </li>     * <li>Observed counts must all be >= 0.        * </li>     * <li>The observed and expected arrays must have the same length and     * their common length must be at least 2.       * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul></p><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed array of observed frequency counts     * @param expected array of expected frequency counts     * @param alpha significance level of the test     * @return true iff null hypothesis can be rejected with confidence     * 1 - alpha     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean chiSquareTest(double[] expected, long[] observed, double alpha)         throws IllegalArgumentException, MathException;        /**     *  Computes the Chi-Square statistic associated with a      * <a href="http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm">     *  chi-square test of independence</a> based on the input <code>counts</code>     *  array, viewed as a two-way table.       * <p>     * The rows of the 2-way table are      * <code>count[0], ... , count[count.length - 1] </code></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>All counts must be >= 0.       * </li>     * <li>The count array must be rectangular (i.e. all count[i] subarrays     *  must have the same length).      * </li>     * <li>The 2-way table represented by <code>counts</code> must have at     *  least 2 columns and at least 2 rows.     * </li>     * </li></ul></p><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param counts array representation of 2-way table     * @return chiSquare statistic     * @throws IllegalArgumentException if preconditions are not met     */    double chiSquare(long[][] counts)     throws IllegalArgumentException;        /**     * Returns the <i>observed significance level</i>, or <a href=     * "http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a      * <a href="http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm">     * chi-square test of independence</a> based on the input <code>counts</code>     * array, viewed as a two-way table.       * <p>     * The rows of the 2-way table are      * <code>count[0], ... , count[count.length - 1] </code></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>All counts must be >= 0.       * </li>     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length).      * </li>     * <li>The 2-way table represented by <code>counts</code> must have at least 2 columns and     *        at least 2 rows.     * </li>     * </li></ul></p><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param counts array representation of 2-way table     * @return p-value     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs computing the p-value     */    double chiSquareTest(long[][] counts)     throws IllegalArgumentException, MathException;        /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm">     * chi-square test of independence</a> evaluating the null hypothesis that the classifications      * represented by the counts in the columns of the input 2-way table are independent of the rows,     * with significance level <code>alpha</code>.  Returns true iff the null hypothesis can be rejected     * with 100 * (1 - alpha) percent confidence.     * <p>     * The rows of the 2-way table are      * <code>count[0], ... , count[count.length - 1] </code></p>     * <p>     * <strong>Example:</strong><br>     * To test the null hypothesis that the counts in     * <code>count[0], ... , count[count.length - 1] </code>     *  all correspond to the same underlying probability distribution at the 99% level, use </p><p>     * <code>chiSquareTest(counts, 0.01) </code></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>All counts must be >= 0.       * </li>     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length).      * </li>     * <li>The 2-way table represented by <code>counts</code> must have at least 2 columns and     *        at least 2 rows.     * </li>     * </li></ul></p><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param counts array representation of 2-way table     * @param alpha significance level of the test     * @return true iff null hypothesis can be rejected with confidence     * 1 - alpha     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean chiSquareTest(long[][] counts, double alpha)     throws IllegalArgumentException, MathException;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.MathException;/** * An interface for Chi-Square tests for unknown distributions. * <p>Two samples tests are used when the distribution is unknown <i>a priori</i> * but provided by one sample. We compare the second sample against the first.</p> * * @version $Revision$ $Date$ * @since 1.2  */public interface UnknownDistributionChiSquareTest extends ChiSquareTest {         /**     * <p>Computes a      * <a href="http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/chi2samp.htm">     * Chi-Square two sample test statistic</a> comparing bin frequency counts     * in <code>observed1</code> and <code>observed2</code>.  The     * sums of frequency counts in the two samples are not required to be the     * same.  The formula used to compute the test statistic is</p>     * <code>     * &sum;[(K * observed1[i] - observed2[i]/K)<sup>2</sup> / (observed1[i] + observed2[i])]     * </code> where      * <br/><code>K = &sqrt;[&sum(observed2 / &sum;(observed1)]</code>     * </p>     * <p>This statistic can be used to perform a Chi-Square test evaluating the null hypothesis that     * both observed counts follow the same distribution.</p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Observed counts must be non-negative.     * </li>     * <li>Observed counts for a specific bin must not both be zero.     * </li>     * <li>Observed counts for a specific sample must not all be 0.     * </li>     * <li>The arrays <code>observed1</code> and <code>observed2</code> must have the same length and     * their common length must be at least 2.     * </li></ul></p><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed1 array of observed frequency counts of the first data set     * @param observed2 array of observed frequency counts of the second data set     * @return chiSquare statistic     * @throws IllegalArgumentException if preconditions are not met     */    double chiSquareDataSetsComparison(long[] observed1, long[] observed2)        throws IllegalArgumentException;    /**     * <p>Returns the <i>observed significance level</i>, or <a href=     * "http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a Chi-Square two sample test comparing     * bin frequency counts in <code>observed1</code> and      * <code>observed2</code>.     * </p>     * <p>The number returned is the smallest significance level at which one     * can reject the null hypothesis that the observed counts conform to the     * same distribution.     * </p>     * <p>See {@link #chiSquareDataSetsComparison(long[], long[])} for details     * on the formula used to compute the test statistic. The degrees of     * of freedom used to perform the test is one less than the common length     * of the input observed count arrays.     * </p>     * <strong>Preconditions</strong>: <ul>     * <li>Observed counts must be non-negative.     * </li>     * <li>Observed counts for a specific bin must not both be zero.     * </li>     * <li>Observed counts for a specific sample must not all be 0.     * </li>     * <li>The arrays <code>observed1</code> and <code>observed2</code> must     * have the same length and     * their common length must be at least 2.     * </li></ul><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed1 array of observed frequency counts of the first data set     * @param observed2 array of observed frequency counts of the second data set     * @return p-value     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs computing the p-value     */    double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)      throws IllegalArgumentException, MathException;    /**     * <p>Performs a Chi-Square two sample test comparing two binned data     * sets. The test evaluates the null hypothesis that the two lists of     * observed counts conform to the same frequency distribution, with     * significance level <code>alpha</code>.  Returns true iff the null     * hypothesis can be rejected with 100 * (1 - alpha) percent confidence.     * </p>     * <p>See {@link #chiSquareDataSetsComparison(long[], long[])} for      * details on the formula used to compute the Chisquare statistic used     * in the test. The degrees of of freedom used to perform the test is     * one less than the common length of the input observed count arrays.     * </p>     * <strong>Preconditions</strong>: <ul>     * <li>Observed counts must be non-negative.     * </li>     * <li>Observed counts for a specific bin must not both be zero.     * </li>     * <li>Observed counts for a specific sample must not all be 0.     * </li>     * <li>The arrays <code>observed1</code> and <code>observed2</code> must     * have the same length and their common length must be at least 2.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed1 array of observed frequency counts of the first data set     * @param observed2 array of observed frequency counts of the second data set     * @param alpha significance level of the test     * @return true iff null hypothesis can be rejected with confidence     * 1 - alpha     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean chiSquareTestDataSetsComparison(long[] observed1, long[] observed2, double alpha)      throws IllegalArgumentException, MathException;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.MathException;import org.apache.commons.math.stat.descriptive.StatisticalSummary;/** * An interface for Student's t-tests. * <p> * Tests can be:<ul> * <li>One-sample or two-sample</li> * <li>One-sided or two-sided</li> * <li>Paired or unpaired (for two-sample tests)</li> * <li>Homoscedastic (equal variance assumption) or heteroscedastic * (for two sample tests)</li> * <li>Fixed significance level (boolean-valued) or returning p-values. * </li></ul></p> * <p> * Test statistics are available for all tests.  Methods including "Test" in * in their names perform tests, all other methods return t-statistics.  Among * the "Test" methods, <code>double-</code>valued methods return p-values; * <code>boolean-</code>valued methods perform fixed significance level tests. * Significance levels are always specified as numbers between 0 and 0.5 * (e.g. tests at the 95% level  use <code>alpha=0.05</code>).</p> * <p> * Input to tests can be either <code>double[]</code> arrays or  * {@link StatisticalSummary} instances.</p> *  * * @version $Revision$ $Date$  */public interface TTest {    /**     * Computes a paired, 2-sample t-statistic based on the data in the input      * arrays.  The t-statistic returned is equivalent to what would be returned by     * computing the one-sample t-statistic {@link #t(double, double[])}, with     * <code>mu = 0</code> and the sample array consisting of the (signed)      * differences between corresponding entries in <code>sample1</code> and      * <code>sample2.</code>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The input arrays must have the same length and their common length     * must be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if the statistic can not be computed do to a     *         convergence or other numerical error.     */    public abstract double pairedT(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or      * <i> p-value</i>, associated with a paired, two-sample, two-tailed t-test      * based on the data in the input arrays.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the mean of the paired     * differences is 0 in favor of the two-sided alternative that the mean paired      * difference is not equal to 0. For a one-sided test, divide the returned      * value by 2.</p>     * <p>     * This test is equivalent to a one-sample t-test computed using     * {@link #tTest(double, double[])} with <code>mu = 0</code> and the sample     * array consisting of the signed differences between corresponding elements of      * <code>sample1</code> and <code>sample2.</code></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The input array lengths must be the same and their common length must     * be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    public abstract double pairedTTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException;    /**     * Performs a paired t-test evaluating the null hypothesis that the      * mean of the paired differences between <code>sample1</code> and     * <code>sample2</code> is 0 in favor of the two-sided alternative that the      * mean paired difference is not equal to 0, with significance level      * <code>alpha</code>.     * <p>     * Returns <code>true</code> iff the null hypothesis can be rejected with      * confidence <code>1 - alpha</code>.  To perform a 1-sided test, use      * <code>alpha * 2</code></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The input array lengths must be the same and their common length      * must be at least 2.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with      * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    public abstract boolean pairedTTest(        double[] sample1,        double[] sample2,        double alpha)        throws IllegalArgumentException, MathException;    /**     * Computes a <a href="http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula">      * t statistic </a> given observed values and a comparison constant.     * <p>     * This statistic can be used to perform a one sample t-test for the mean.     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array length must be at least 2.     * </li></ul></p>     *     * @param mu comparison constant     * @param observed array of values     * @return t statistic     * @throws IllegalArgumentException if input array length is less than 2     */    public abstract double t(double mu, double[] observed)        throws IllegalArgumentException;    /**     * Computes a <a href="http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula">     * t statistic </a> to use in comparing the mean of the dataset described by      * <code>sampleStats</code> to <code>mu</code>.     * <p>     * This statistic can be used to perform a one sample t-test for the mean.     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li><code>observed.getN() > = 2</code>.     * </li></ul></p>     *     * @param mu comparison constant     * @param sampleStats DescriptiveStatistics holding sample summary statitstics     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    public abstract double t(double mu, StatisticalSummary sampleStats)        throws IllegalArgumentException;    /**     * Computes a 2-sample t statistic,  under the hypothesis of equal      * subpopulation variances.  To compute a t-statistic without the     * equal variances hypothesis, use {@link #t(double[], double[])}.     * <p>     * This statistic can be used to perform a (homoscedastic) two-sample     * t-test to compare sample means.</p>     * <p>     * The t-statisitc is</p>     * <p>     * &nbsp;&nbsp;<code>  t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))</code>     * </p><p>     * where <strong><code>n1</code></strong> is the size of first sample;      * <strong><code> n2</code></strong> is the size of second sample;      * <strong><code> m1</code></strong> is the mean of first sample;       * <strong><code> m2</code></strong> is the mean of second sample</li>     * </ul>     * and <strong><code>var</code></strong> is the pooled variance estimate:     * </p><p>     * <code>var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))</code>     * </p><p>      * with <strong><code>var1<code></strong> the variance of the first sample and     * <strong><code>var2</code></strong> the variance of the second sample.     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    public abstract double homoscedasticT(double[] sample1, double[] sample2)        throws IllegalArgumentException;    /**     * Computes a 2-sample t statistic, without the hypothesis of equal     * subpopulation variances.  To compute a t-statistic assuming equal     * variances, use {@link #homoscedasticT(double[], double[])}.     * <p>     * This statistic can be used to perform a two-sample t-test to compare     * sample means.</p>     * <p>     * The t-statisitc is</p>     * <p>     * &nbsp;&nbsp; <code>  t = (m1 - m2) / sqrt(var1/n1 + var2/n2)</code>     * </p><p>     *  where <strong><code>n1</code></strong> is the size of the first sample     * <strong><code> n2</code></strong> is the size of the second sample;      * <strong><code> m1</code></strong> is the mean of the first sample;       * <strong><code> m2</code></strong> is the mean of the second sample;     * <strong><code> var1</code></strong> is the variance of the first sample;     * <strong><code> var2</code></strong> is the variance of the second sample;       * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    public abstract double t(double[] sample1, double[] sample2)        throws IllegalArgumentException;    /**     * Computes a 2-sample t statistic </a>, comparing the means of the datasets     * described by two {@link StatisticalSummary} instances, without the     * assumption of equal subpopulation variances.  Use      * {@link #homoscedasticT(StatisticalSummary, StatisticalSummary)} to     * compute a t-statistic under the equal variances assumption.     * <p>     * This statistic can be used to perform a two-sample t-test to compare     * sample means.</p>     * <p>      * The returned  t-statisitc is</p>     * <p>     * &nbsp;&nbsp; <code>  t = (m1 - m2) / sqrt(var1/n1 + var2/n2)</code>     * </p><p>     * where <strong><code>n1</code></strong> is the size of the first sample;      * <strong><code> n2</code></strong> is the size of the second sample;      * <strong><code> m1</code></strong> is the mean of the first sample;       * <strong><code> m2</code></strong> is the mean of the second sample     * <strong><code> var1</code></strong> is the variance of the first sample;       * <strong><code> var2</code></strong> is the variance of the second sample     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li></ul></p>     *     * @param sampleStats1 StatisticalSummary describing data from the first sample     * @param sampleStats2 StatisticalSummary describing data from the second sample     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    public abstract double t(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException;    /**     * Computes a 2-sample t statistic, comparing the means of the datasets     * described by two {@link StatisticalSummary} instances, under the     * assumption of equal subpopulation variances.  To compute a t-statistic     * without the equal variances assumption, use      * {@link #t(StatisticalSummary, StatisticalSummary)}.     * <p>     * This statistic can be used to perform a (homoscedastic) two-sample     * t-test to compare sample means.</p>     * <p>     * The t-statisitc returned is</p>     * <p>     * &nbsp;&nbsp;<code>  t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))</code>     * </p><p>     * where <strong><code>n1</code></strong> is the size of first sample;      * <strong><code> n2</code></strong> is the size of second sample;      * <strong><code> m1</code></strong> is the mean of first sample;       * <strong><code> m2</code></strong> is the mean of second sample     * and <strong><code>var</code></strong> is the pooled variance estimate:     * </p><p>     * <code>var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))</code>     * </p><p>      * with <strong><code>var1<code></strong> the variance of the first sample and     * <strong><code>var2</code></strong> the variance of the second sample.     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li></ul></p>     *     * @param sampleStats1 StatisticalSummary describing data from the first sample     * @param sampleStats2 StatisticalSummary describing data from the second sample     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    public abstract double homoscedasticT(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException;    /**     * Returns the <i>observed significance level</i>, or      * <i>p-value</i>, associated with a one-sample, two-tailed t-test      * comparing the mean of the input array with the constant <code>mu</code>.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the mean equals      * <code>mu</code> in favor of the two-sided alternative that the mean     * is different from <code>mu</code>. For a one-sided test, divide the      * returned value by 2.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">here</a>     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array length must be at least 2.     * </li></ul></p>     *     * @param mu constant value to compare sample mean against     * @param sample array of sample data values     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    public abstract double tTest(double mu, double[] sample)        throws IllegalArgumentException, MathException;    /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that the mean of the population from     * which <code>sample</code> is drawn equals <code>mu</code>.     * <p>     * Returns <code>true</code> iff the null hypothesis can be      * rejected with confidence <code>1 - alpha</code>.  To      * perform a 1-sided test, use <code>alpha * 2</code></p>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>sample mean = mu </code> at     * the 95% level, use <br><code>tTest(mu, sample, 0.05) </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>     * at the 99% level, first verify that the measured sample mean is less      * than <code>mu</code> and then use      * <br><code>tTest(mu, sample, 0.02) </code>     * </li></ol></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the one-sample      * parametric t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample">here</a>     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array length must be at least 2.     * </li></ul></p>     *     * @param mu constant value to compare sample mean against     * @param sample array of sample data values     * @param alpha significance level of the test     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error computing the p-value     */    public abstract boolean tTest(double mu, double[] sample, double alpha)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or      * <i>p-value</i>, associated with a one-sample, two-tailed t-test      * comparing the mean of the dataset described by <code>sampleStats</code>     * with the constant <code>mu</code>.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the mean equals      * <code>mu</code> in favor of the two-sided alternative that the mean     * is different from <code>mu</code>. For a one-sided test, divide the      * returned value by 2.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The sample must contain at least 2 observations.     * </li></ul></p>     *     * @param mu constant value to compare sample mean against     * @param sampleStats StatisticalSummary describing sample data     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    public abstract double tTest(double mu, StatisticalSummary sampleStats)        throws IllegalArgumentException, MathException;    /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that the mean of the     * population from which the dataset described by <code>stats</code> is     * drawn equals <code>mu</code>.     * <p>     * Returns <code>true</code> iff the null hypothesis can be rejected with     * confidence <code>1 - alpha</code>.  To  perform a 1-sided test, use     * <code>alpha * 2.</code></p>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>sample mean = mu </code> at     * the 95% level, use <br><code>tTest(mu, sampleStats, 0.05) </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>     * at the 99% level, first verify that the measured sample mean is less      * than <code>mu</code> and then use      * <br><code>tTest(mu, sampleStats, 0.02) </code>     * </li></ol></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the one-sample      * parametric t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample">here</a>     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The sample must include at least 2 observations.     * </li></ul></p>     *     * @param mu constant value to compare sample mean against     * @param sampleStats StatisticalSummary describing sample data values     * @param alpha significance level of the test     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    public abstract boolean tTest(        double mu,        StatisticalSummary sampleStats,        double alpha)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or      * <i>p-value</i>, associated with a two-sample, two-tailed t-test      * comparing the means of the input arrays.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.      * For a one-sided test, divide the returned value by 2.</p>     * <p>     * The test does not assume that the underlying popuation variances are     * equal  and it uses approximated degrees of freedom computed from the      * sample data to compute the p-value.  The t-statistic used is as defined in     * {@link #t(double[], double[])} and the Welch-Satterthwaite approximation     * to the degrees of freedom is used,      * as described      * <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">     * here.</a>  To perform the test under the assumption of equal subpopulation     * variances, use {@link #homoscedasticTTest(double[], double[])}.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    public abstract double tTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or      * <i>p-value</i>, associated with a two-sample, two-tailed t-test      * comparing the means of the input arrays, under the assumption that     * the two samples are drawn from subpopulations with equal variances.     * To perform the test without the equal variances assumption, use     * {@link #tTest(double[], double[])}.</p>     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.      * For a one-sided test, divide the returned value by 2.</p>     * <p>     * A pooled variance estimate is used to compute the t-statistic.  See     * {@link #homoscedasticT(double[], double[])}. The sum of the sample sizes     * minus 2 is used as the degrees of freedom.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    public abstract double homoscedasticTTest(        double[] sample1,        double[] sample2)        throws IllegalArgumentException, MathException;    /**     * Performs a      * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code>      * and <code>sample2</code> are drawn from populations with the same mean,      * with significance level <code>alpha</code>.  This test does not assume     * that the subpopulation variances are equal.  To perform the test assuming     * equal variances, use      * {@link #homoscedasticTTest(double[], double[], double)}.     * <p>     * Returns <code>true</code> iff the null hypothesis that the means are     * equal can be rejected with confidence <code>1 - alpha</code>.  To      * perform a 1-sided test, use <code>alpha * 2</code></p>     * <p>     * See {@link #t(double[], double[])} for the formula used to compute the     * t-statistic.  Degrees of freedom are approximated using the     * <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">     * Welch-Satterthwaite approximation.</a></p>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at     * the 95% level,  use      * <br><code>tTest(sample1, sample2, 0.05). </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code>,     * at the 99% level, first verify that the measured  mean of <code>sample 1</code>     * is less than the mean of <code>sample 2</code> and then use      * <br><code>tTest(sample1, sample2, 0.02) </code>     * </li></ol></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with      * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    public abstract boolean tTest(        double[] sample1,        double[] sample2,        double alpha)        throws IllegalArgumentException, MathException;    /**     * Performs a      * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code>      * and <code>sample2</code> are drawn from populations with the same mean,      * with significance level <code>alpha</code>,  assuming that the     * subpopulation variances are equal.  Use      * {@link #tTest(double[], double[], double)} to perform the test without     * the assumption of equal variances.     * <p>     * Returns <code>true</code> iff the null hypothesis that the means are     * equal can be rejected with confidence <code>1 - alpha</code>.  To      * perform a 1-sided test, use <code>alpha * 2.</code>  To perform the test     * without the assumption of equal subpopulation variances, use      * {@link #tTest(double[], double[], double)}.</p>     * <p>     * A pooled variance estimate is used to compute the t-statistic. See     * {@link #t(double[], double[])} for the formula. The sum of the sample     * sizes minus 2 is used as the degrees of freedom.</p>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at     * the 95% level, use <br><code>tTest(sample1, sample2, 0.05). </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2, </code>     * at the 99% level, first verify that the measured mean of      * <code>sample 1</code> is less than the mean of <code>sample 2</code>     * and then use     * <br><code>tTest(sample1, sample2, 0.02) </code>     * </li></ol></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with      * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    public abstract boolean homoscedasticTTest(        double[] sample1,        double[] sample2,        double alpha)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or      * <i>p-value</i>, associated with a two-sample, two-tailed t-test      * comparing the means of the datasets described by two StatisticalSummary     * instances.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.      * For a one-sided test, divide the returned value by 2.</p>     * <p>     * The test does not assume that the underlying popuation variances are     * equal  and it uses approximated degrees of freedom computed from the      * sample data to compute the p-value.   To perform the test assuming     * equal variances, use      * {@link #homoscedasticTTest(StatisticalSummary, StatisticalSummary)}.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li></ul></p>     *     * @param sampleStats1  StatisticalSummary describing data from the first sample     * @param sampleStats2  StatisticalSummary describing data from the second sample     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    public abstract double tTest(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or      * <i>p-value</i>, associated with a two-sample, two-tailed t-test      * comparing the means of the datasets described by two StatisticalSummary     * instances, under the hypothesis of equal subpopulation variances. To     * perform a test without the equal variances assumption, use     * {@link #tTest(StatisticalSummary, StatisticalSummary)}.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.      * For a one-sided test, divide the returned value by 2.</p>     * <p>     * See {@link #homoscedasticT(double[], double[])} for the formula used to     * compute the t-statistic. The sum of the  sample sizes minus 2 is used as     * the degrees of freedom.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">here</a>     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li></ul></p>     *     * @param sampleStats1  StatisticalSummary describing data from the first sample     * @param sampleStats2  StatisticalSummary describing data from the second sample     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    public abstract double homoscedasticTTest(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException, MathException;    /**     * Performs a      * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that      * <code>sampleStats1</code> and <code>sampleStats2</code> describe     * datasets drawn from populations with the same mean, with significance     * level <code>alpha</code>.   This test does not assume that the     * subpopulation variances are equal.  To perform the test under the equal     * variances assumption, use     * {@link #homoscedasticTTest(StatisticalSummary, StatisticalSummary)}.     * <p>     * Returns <code>true</code> iff the null hypothesis that the means are     * equal can be rejected with confidence <code>1 - alpha</code>.  To      * perform a 1-sided test, use <code>alpha * 2</code></p>     * <p>     * See {@link #t(double[], double[])} for the formula used to compute the     * t-statistic.  Degrees of freedom are approximated using the     * <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">     * Welch-Satterthwaite approximation.</a></p>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at     * the 95%, use      * <br><code>tTest(sampleStats1, sampleStats2, 0.05) </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code>     * at the 99% level,  first verify that the measured mean of       * <code>sample 1</code> is less than  the mean of <code>sample 2</code>     * and then use      * <br><code>tTest(sampleStats1, sampleStats2, 0.02) </code>     * </li></ol></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul></p>     *     * @param sampleStats1 StatisticalSummary describing sample data values     * @param sampleStats2 StatisticalSummary describing sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with      * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    public abstract boolean tTest(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2,        double alpha)        throws IllegalArgumentException, MathException;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import java.util.Collection;import org.apache.commons.math.MathException;import org.apache.commons.math.stat.descriptive.StatisticalSummary;/** * A collection of static methods to create inference test instances or to * perform inference tests. * * @since 1.1 * @version $Revision$ $Date$  */public class TestUtils  {    /**     * Prevent instantiation.     */    protected TestUtils() {        super();    }        /** Singleton TTest instance using default implementation. */    private static TTest tTest = new TTestImpl();       /** Singleton ChiSquareTest instance using default implementation. */    private static ChiSquareTest chiSquareTest =         new ChiSquareTestImpl();        /** Singleton ChiSquareTest instance using default implementation. */    private static UnknownDistributionChiSquareTest unknownDistributionChiSquareTest =         new ChiSquareTestImpl();        /** Singleton OneWayAnova instance using default implementation. */    private static OneWayAnova oneWayAnova =        new OneWayAnovaImpl();        /**     * Set the (singleton) TTest instance.     *      * @param tTest the new instance to use     * @since 1.2     */    public static void setChiSquareTest(TTest tTest) {        TestUtils.tTest = tTest;    }        /**     * Return a (singleton) TTest instance.  Does not create a new instance.     *      * @return a TTest instance     */    public static TTest getTTest() {        return tTest;    }        /**     * Set the (singleton) ChiSquareTest instance.     *      * @param chiSquareTest the new instance to use     * @since 1.2     */    public static void setChiSquareTest(ChiSquareTest chiSquareTest) {        TestUtils.chiSquareTest = chiSquareTest;    }        /**     * Return a (singleton) ChiSquareTest instance.  Does not create a new instance.     *      * @return a ChiSquareTest instance     */    public static ChiSquareTest getChiSquareTest() {        return chiSquareTest;    }        /**     * Set the (singleton) UnknownDistributionChiSquareTest instance.     *      * @param unknownDistributionChiSquareTest the new instance to use     * @since 1.2     */    public static void setUnknownDistributionChiSquareTest(UnknownDistributionChiSquareTest unknownDistributionChiSquareTest) {        TestUtils.unknownDistributionChiSquareTest = unknownDistributionChiSquareTest;    }        /**     * Return a (singleton) UnknownDistributionChiSquareTest instance.  Does not create a new instance.     *      * @return a UnknownDistributionChiSquareTest instance     */    public static UnknownDistributionChiSquareTest getUnknownDistributionChiSquareTest() {        return unknownDistributionChiSquareTest;    }        /**     * Set the (singleton) OneWayAnova instance     *      * @param oneWayAnova the new instance to use     * @since 1.2     */    public static void setOneWayAnova(OneWayAnova oneWayAnova) {        TestUtils.oneWayAnova = oneWayAnova;    }        /**     * Return a (singleton) OneWayAnova instance.  Does not create a new instance.     *      * @return a OneWayAnova instance     * @since 1.2     */    public static OneWayAnova getOneWayAnova() {        return oneWayAnova;    }            // CHECKSTYLE: stop JavadocMethodCheck    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticT(double[], double[])     */    public static double homoscedasticT(double[] sample1, double[] sample2)        throws IllegalArgumentException {        return tTest.homoscedasticT(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticT(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double homoscedasticT(StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException {        return tTest.homoscedasticT(sampleStats1, sampleStats2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticTTest(double[], double[], double)     */    public static boolean homoscedasticTTest(double[] sample1, double[] sample2,            double alpha)        throws IllegalArgumentException, MathException {        return tTest. homoscedasticTTest(sample1, sample2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticTTest(double[], double[])     */    public static double homoscedasticTTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException {        return tTest.homoscedasticTTest(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticTTest(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double homoscedasticTTest(StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException, MathException {        return tTest.homoscedasticTTest(sampleStats1, sampleStats2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#pairedT(double[], double[])     */    public static double pairedT(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException {        return tTest.pairedT(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#pairedTTest(double[], double[], double)     */    public static boolean pairedTTest(double[] sample1, double[] sample2,        double alpha)        throws IllegalArgumentException, MathException {        return tTest.pairedTTest(sample1, sample2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#pairedTTest(double[], double[])     */    public static double pairedTTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException {        return tTest.pairedTTest(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#t(double, double[])     */    public static double t(double mu, double[] observed)        throws IllegalArgumentException {        return tTest.t(mu, observed);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#t(double, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double t(double mu, StatisticalSummary sampleStats)        throws IllegalArgumentException {        return tTest.t(mu, sampleStats);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#t(double[], double[])     */    public static double t(double[] sample1, double[] sample2)        throws IllegalArgumentException {        return tTest.t(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#t(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double t(StatisticalSummary sampleStats1,            StatisticalSummary sampleStats2)        throws IllegalArgumentException {        return tTest.t(sampleStats1, sampleStats2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, double[], double)     */    public static boolean tTest(double mu, double[] sample, double alpha)        throws IllegalArgumentException, MathException {        return tTest.tTest(mu, sample, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, double[])     */    public static double tTest(double mu, double[] sample)        throws IllegalArgumentException, MathException {        return tTest.tTest(mu, sample);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, org.apache.commons.math.stat.descriptive.StatisticalSummary, double)     */    public static boolean tTest(double mu, StatisticalSummary sampleStats,        double alpha)        throws IllegalArgumentException, MathException {        return tTest. tTest(mu, sampleStats, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double tTest(double mu, StatisticalSummary sampleStats)        throws IllegalArgumentException, MathException {        return tTest.tTest(mu, sampleStats);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double[], double[], double)     */    public static boolean tTest(double[] sample1, double[] sample2, double alpha)        throws IllegalArgumentException, MathException {        return tTest.tTest(sample1, sample2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double[], double[])     */    public static double tTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException {        return tTest.tTest(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary, double)     */    public static boolean tTest(StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2, double alpha)        throws IllegalArgumentException, MathException {        return tTest. tTest(sampleStats1, sampleStats2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double tTest(StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException, MathException {        return tTest.tTest(sampleStats1, sampleStats2);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquare(double[], long[])     */    public static double chiSquare(double[] expected, long[] observed)        throws IllegalArgumentException {        return chiSquareTest.chiSquare(expected, observed);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquare(long[][])     */    public static double chiSquare(long[][] counts)         throws IllegalArgumentException {        return chiSquareTest.chiSquare(counts);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(double[], long[], double)     */    public static boolean chiSquareTest(double[] expected, long[] observed,        double alpha)        throws IllegalArgumentException, MathException {        return chiSquareTest.chiSquareTest(expected, observed, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(double[], long[])     */    public static double chiSquareTest(double[] expected, long[] observed)        throws IllegalArgumentException, MathException {        return chiSquareTest.chiSquareTest(expected, observed);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(long[][], double)     */    public static boolean chiSquareTest(long[][] counts, double alpha)        throws IllegalArgumentException, MathException {        return chiSquareTest. chiSquareTest(counts, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(long[][])     */    public static double chiSquareTest(long[][] counts)        throws IllegalArgumentException, MathException {        return chiSquareTest. chiSquareTest(counts);    }    /**     * @see org.apache.commons.math.stat.inference.UnknownDistributionChiSquareTest#chiSquareDataSetsComparison(long[], long[])     *     * @since 1.2     */    public static double chiSquareDataSetsComparison(long[] observed1, long[] observed2)        throws IllegalArgumentException {        return unknownDistributionChiSquareTest.chiSquareDataSetsComparison(observed1, observed2);    }    /**     * @see org.apache.commons.math.stat.inference.UnknownDistributionChiSquareTest#chiSquareTestDataSetsComparison(long[], long[])     *     * @since 1.2     */    public static double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)        throws IllegalArgumentException, MathException {        return unknownDistributionChiSquareTest.chiSquareTestDataSetsComparison(observed1, observed2);    }    /**     * @see org.apache.commons.math.stat.inference.UnknownDistributionChiSquareTest#chiSquareTestDataSetsComparison(long[], long[], double)     *     * @since 1.2     */    public static boolean chiSquareTestDataSetsComparison(long[] observed1, long[] observed2,        double alpha)        throws IllegalArgumentException, MathException {        return unknownDistributionChiSquareTest.chiSquareTestDataSetsComparison(observed1, observed2, alpha);    }        /**     * @see org.apache.commons.math.stat.inference.OneWayAnova#anovaFValue(Collection)     *     * @since 1.2     */    public static double oneWayAnovaFValue(Collection<double[]> categoryData)    throws IllegalArgumentException, MathException {        return oneWayAnova.anovaFValue(categoryData);    }        /**     * @see org.apache.commons.math.stat.inference.OneWayAnova#anovaPValue(Collection)     *      * @since 1.2     */    public static double oneWayAnovaPValue(Collection<double[]> categoryData)    throws IllegalArgumentException, MathException {        return oneWayAnova.anovaPValue(categoryData);    }        /**     * @see org.apache.commons.math.stat.inference.OneWayAnova#anovaTest(Collection,double)     *     * @since 1.2     */    public static boolean oneWayAnovaTest(Collection<double[]> categoryData, double alpha)    throws IllegalArgumentException, MathException {        return oneWayAnova.anovaTest(categoryData, alpha);    }    // CHECKSTYLE: resume JavadocMethodCheck}