/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.MathException;/** * An interface for Chi-Square tests. * <p>This interface handles only known distributions. If the distribution is * unknown and should be provided by a sample, then the {@link UnknownDistributionChiSquareTest * UnknownDistributionChiSquareTest} extended interface should be used instead.</p> * @version $Revision$ $Date$ */public interface ChiSquareTest {     /**     * Computes the <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm">     * Chi-Square statistic</a> comparing <code>observed</code> and <code>expected</code>     * frequency counts.     * <p>     * This statistic can be used to perform a Chi-Square test evaluating the null hypothesis that     *  the observed counts follow the expected distribution.</p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Expected counts must all be positive.     * </li>     * <li>Observed counts must all be >= 0.     * </li>     * <li>The observed and expected arrays must have the same length and     * their common length must be at least 2.     * </li></ul></p><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed array of observed frequency counts     * @param expected array of expected frequency counts     * @return chiSquare statistic     * @throws IllegalArgumentException if preconditions are not met     */    double chiSquare(double[] expected, long[] observed)        throws IllegalArgumentException;    /**     * Returns the <i>observed significance level</i>, or <a href=     * "http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a     * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm">     * Chi-square goodness of fit test</a> comparing the <code>observed</code>     * frequency counts to those in the <code>expected</code> array.     * <p>     * The number returned is the smallest significance level at which one can reject     * the null hypothesis that the observed counts conform to the frequency distribution     * described by the expected counts.</p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Expected counts must all be positive.     * </li>     * <li>Observed counts must all be >= 0.     * </li>     * <li>The observed and expected arrays must have the same length and     * their common length must be at least 2.     * </li></ul></p><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed array of observed frequency counts     * @param expected array of expected frequency counts     * @return p-value     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs computing the p-value     */    double chiSquareTest(double[] expected, long[] observed)        throws IllegalArgumentException, MathException;    /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm">     * Chi-square goodness of fit test</a> evaluating the null hypothesis that the observed counts     * conform to the frequency distribution described by the expected counts, with     * significance level <code>alpha</code>.  Returns true iff the null hypothesis can be rejected     * with 100 * (1 - alpha) percent confidence.     * <p>     * <strong>Example:</strong><br>     * To test the hypothesis that <code>observed</code> follows     * <code>expected</code> at the 99% level, use </p><p>     * <code>chiSquareTest(expected, observed, 0.01) </code></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Expected counts must all be positive.     * </li>     * <li>Observed counts must all be >= 0.     * </li>     * <li>The observed and expected arrays must have the same length and     * their common length must be at least 2.     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul></p><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed array of observed frequency counts     * @param expected array of expected frequency counts     * @param alpha significance level of the test     * @return true iff null hypothesis can be rejected with confidence     * 1 - alpha     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean chiSquareTest(double[] expected, long[] observed, double alpha)        throws IllegalArgumentException, MathException;    /**     *  Computes the Chi-Square statistic associated with a     * <a href="http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm">     *  chi-square test of independence</a> based on the input <code>counts</code>     *  array, viewed as a two-way table.     * <p>     * The rows of the 2-way table are     * <code>count[0], ... , count[count.length - 1] </code></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>All counts must be >= 0.     * </li>     * <li>The count array must be rectangular (i.e. all count[i] subarrays     *  must have the same length).     * </li>     * <li>The 2-way table represented by <code>counts</code> must have at     *  least 2 columns and at least 2 rows.     * </li>     * </li></ul></p><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param counts array representation of 2-way table     * @return chiSquare statistic     * @throws IllegalArgumentException if preconditions are not met     */    double chiSquare(long[][] counts)    throws IllegalArgumentException;    /**     * Returns the <i>observed significance level</i>, or <a href=     * "http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a     * <a href="http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm">     * chi-square test of independence</a> based on the input <code>counts</code>     * array, viewed as a two-way table.     * <p>     * The rows of the 2-way table are     * <code>count[0], ... , count[count.length - 1] </code></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>All counts must be >= 0.     * </li>     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length).     * </li>     * <li>The 2-way table represented by <code>counts</code> must have at least 2 columns and     *        at least 2 rows.     * </li>     * </li></ul></p><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param counts array representation of 2-way table     * @return p-value     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs computing the p-value     */    double chiSquareTest(long[][] counts)    throws IllegalArgumentException, MathException;    /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm">     * chi-square test of independence</a> evaluating the null hypothesis that the classifications     * represented by the counts in the columns of the input 2-way table are independent of the rows,     * with significance level <code>alpha</code>.  Returns true iff the null hypothesis can be rejected     * with 100 * (1 - alpha) percent confidence.     * <p>     * The rows of the 2-way table are     * <code>count[0], ... , count[count.length - 1] </code></p>     * <p>     * <strong>Example:</strong><br>     * To test the null hypothesis that the counts in     * <code>count[0], ... , count[count.length - 1] </code>     *  all correspond to the same underlying probability distribution at the 99% level, use </p><p>     * <code>chiSquareTest(counts, 0.01) </code></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>All counts must be >= 0.     * </li>     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length).     * </li>     * <li>The 2-way table represented by <code>counts</code> must have at least 2 columns and     *        at least 2 rows.     * </li>     * </li></ul></p><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param counts array representation of 2-way table     * @param alpha significance level of the test     * @return true iff null hypothesis can be rejected with confidence     * 1 - alpha     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean chiSquareTest(long[][] counts, double alpha)    throws IllegalArgumentException, MathException;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.MathException;/** * An interface for Chi-Square tests for unknown distributions. * <p>Two samples tests are used when the distribution is unknown <i>a priori</i> * but provided by one sample. We compare the second sample against the first.</p> * * @version $Revision$ $Date$ * @since 1.2 */public interface UnknownDistributionChiSquareTest extends ChiSquareTest {    /**     * <p>Computes a     * <a href="http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/chi2samp.htm">     * Chi-Square two sample test statistic</a> comparing bin frequency counts     * in <code>observed1</code> and <code>observed2</code>.  The     * sums of frequency counts in the two samples are not required to be the     * same.  The formula used to compute the test statistic is</p>     * <code>     * &sum;[(K * observed1[i] - observed2[i]/K)<sup>2</sup> / (observed1[i] + observed2[i])]     * </code> where     * <br/><code>K = &sqrt;[&sum(observed2 / &sum;(observed1)]</code>     * </p>     * <p>This statistic can be used to perform a Chi-Square test evaluating the null hypothesis that     * both observed counts follow the same distribution.</p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Observed counts must be non-negative.     * </li>     * <li>Observed counts for a specific bin must not both be zero.     * </li>     * <li>Observed counts for a specific sample must not all be 0.     * </li>     * <li>The arrays <code>observed1</code> and <code>observed2</code> must have the same length and     * their common length must be at least 2.     * </li></ul></p><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed1 array of observed frequency counts of the first data set     * @param observed2 array of observed frequency counts of the second data set     * @return chiSquare statistic     * @throws IllegalArgumentException if preconditions are not met     */    double chiSquareDataSetsComparison(long[] observed1, long[] observed2)        throws IllegalArgumentException;    /**     * <p>Returns the <i>observed significance level</i>, or <a href=     * "http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a Chi-Square two sample test comparing     * bin frequency counts in <code>observed1</code> and     * <code>observed2</code>.     * </p>     * <p>The number returned is the smallest significance level at which one     * can reject the null hypothesis that the observed counts conform to the     * same distribution.     * </p>     * <p>See {@link #chiSquareDataSetsComparison(long[], long[])} for details     * on the formula used to compute the test statistic. The degrees of     * of freedom used to perform the test is one less than the common length     * of the input observed count arrays.     * </p>     * <strong>Preconditions</strong>: <ul>     * <li>Observed counts must be non-negative.     * </li>     * <li>Observed counts for a specific bin must not both be zero.     * </li>     * <li>Observed counts for a specific sample must not all be 0.     * </li>     * <li>The arrays <code>observed1</code> and <code>observed2</code> must     * have the same length and     * their common length must be at least 2.     * </li></ul><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed1 array of observed frequency counts of the first data set     * @param observed2 array of observed frequency counts of the second data set     * @return p-value     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs computing the p-value     */    double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)      throws IllegalArgumentException, MathException;    /**     * <p>Performs a Chi-Square two sample test comparing two binned data     * sets. The test evaluates the null hypothesis that the two lists of     * observed counts conform to the same frequency distribution, with     * significance level <code>alpha</code>.  Returns true iff the null     * hypothesis can be rejected with 100 * (1 - alpha) percent confidence.     * </p>     * <p>See {@link #chiSquareDataSetsComparison(long[], long[])} for     * details on the formula used to compute the Chisquare statistic used     * in the test. The degrees of of freedom used to perform the test is     * one less than the common length of the input observed count arrays.     * </p>     * <strong>Preconditions</strong>: <ul>     * <li>Observed counts must be non-negative.     * </li>     * <li>Observed counts for a specific bin must not both be zero.     * </li>     * <li>Observed counts for a specific sample must not all be 0.     * </li>     * <li>The arrays <code>observed1</code> and <code>observed2</code> must     * have the same length and their common length must be at least 2.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul><p>     * If any of the preconditions are not met, an     * <code>IllegalArgumentException</code> is thrown.</p>     *     * @param observed1 array of observed frequency counts of the first data set     * @param observed2 array of observed frequency counts of the second data set     * @param alpha significance level of the test     * @return true iff null hypothesis can be rejected with confidence     * 1 - alpha     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean chiSquareTestDataSetsComparison(long[] observed1, long[] observed2, double alpha)      throws IllegalArgumentException, MathException;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.MathException;import org.apache.commons.math.stat.descriptive.StatisticalSummary;/** * An interface for Student's t-tests. * <p> * Tests can be:<ul> * <li>One-sample or two-sample</li> * <li>One-sided or two-sided</li> * <li>Paired or unpaired (for two-sample tests)</li> * <li>Homoscedastic (equal variance assumption) or heteroscedastic * (for two sample tests)</li> * <li>Fixed significance level (boolean-valued) or returning p-values. * </li></ul></p> * <p> * Test statistics are available for all tests.  Methods including "Test" in * in their names perform tests, all other methods return t-statistics.  Among * the "Test" methods, <code>double-</code>valued methods return p-values; * <code>boolean-</code>valued methods perform fixed significance level tests. * Significance levels are always specified as numbers between 0 and 0.5 * (e.g. tests at the 95% level  use <code>alpha=0.05</code>).</p> * <p> * Input to tests can be either <code>double[]</code> arrays or * {@link StatisticalSummary} instances.</p> * * * @version $Revision$ $Date$ */public interface TTest {    /**     * Computes a paired, 2-sample t-statistic based on the data in the input     * arrays.  The t-statistic returned is equivalent to what would be returned by     * computing the one-sample t-statistic {@link #t(double, double[])}, with     * <code>mu = 0</code> and the sample array consisting of the (signed)     * differences between corresponding entries in <code>sample1</code> and     * <code>sample2.</code>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The input arrays must have the same length and their common length     * must be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if the statistic can not be computed do to a     *         convergence or other numerical error.     */    double pairedT(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or     * <i> p-value</i>, associated with a paired, two-sample, two-tailed t-test     * based on the data in the input arrays.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the mean of the paired     * differences is 0 in favor of the two-sided alternative that the mean paired     * difference is not equal to 0. For a one-sided test, divide the returned     * value by 2.</p>     * <p>     * This test is equivalent to a one-sample t-test computed using     * {@link #tTest(double, double[])} with <code>mu = 0</code> and the sample     * array consisting of the signed differences between corresponding elements of     * <code>sample1</code> and <code>sample2.</code></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The input array lengths must be the same and their common length must     * be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double pairedTTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException;    /**     * Performs a paired t-test evaluating the null hypothesis that the     * mean of the paired differences between <code>sample1</code> and     * <code>sample2</code> is 0 in favor of the two-sided alternative that the     * mean paired difference is not equal to 0, with significance level     * <code>alpha</code>.     * <p>     * Returns <code>true</code> iff the null hypothesis can be rejected with     * confidence <code>1 - alpha</code>.  To perform a 1-sided test, use     * <code>alpha * 2</code></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The input array lengths must be the same and their common length     * must be at least 2.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with     * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean pairedTTest(        double[] sample1,        double[] sample2,        double alpha)        throws IllegalArgumentException, MathException;    /**     * Computes a <a href="http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula">     * t statistic </a> given observed values and a comparison constant.     * <p>     * This statistic can be used to perform a one sample t-test for the mean.     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array length must be at least 2.     * </li></ul></p>     *     * @param mu comparison constant     * @param observed array of values     * @return t statistic     * @throws IllegalArgumentException if input array length is less than 2     */    double t(double mu, double[] observed)        throws IllegalArgumentException;    /**     * Computes a <a href="http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula">     * t statistic </a> to use in comparing the mean of the dataset described by     * <code>sampleStats</code> to <code>mu</code>.     * <p>     * This statistic can be used to perform a one sample t-test for the mean.     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li><code>observed.getN() > = 2</code>.     * </li></ul></p>     *     * @param mu comparison constant     * @param sampleStats DescriptiveStatistics holding sample summary statitstics     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    double t(double mu, StatisticalSummary sampleStats)        throws IllegalArgumentException;    /**     * Computes a 2-sample t statistic,  under the hypothesis of equal     * subpopulation variances.  To compute a t-statistic without the     * equal variances hypothesis, use {@link #t(double[], double[])}.     * <p>     * This statistic can be used to perform a (homoscedastic) two-sample     * t-test to compare sample means.</p>     * <p>     * The t-statisitc is</p>     * <p>     * &nbsp;&nbsp;<code>  t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))</code>     * </p><p>     * where <strong><code>n1</code></strong> is the size of first sample;     * <strong><code> n2</code></strong> is the size of second sample;     * <strong><code> m1</code></strong> is the mean of first sample;     * <strong><code> m2</code></strong> is the mean of second sample</li>     * </ul>     * and <strong><code>var</code></strong> is the pooled variance estimate:     * </p><p>     * <code>var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))</code>     * </p><p>     * with <strong><code>var1<code></strong> the variance of the first sample and     * <strong><code>var2</code></strong> the variance of the second sample.     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    double homoscedasticT(double[] sample1, double[] sample2)        throws IllegalArgumentException;    /**     * Computes a 2-sample t statistic, without the hypothesis of equal     * subpopulation variances.  To compute a t-statistic assuming equal     * variances, use {@link #homoscedasticT(double[], double[])}.     * <p>     * This statistic can be used to perform a two-sample t-test to compare     * sample means.</p>     * <p>     * The t-statisitc is</p>     * <p>     * &nbsp;&nbsp; <code>  t = (m1 - m2) / sqrt(var1/n1 + var2/n2)</code>     * </p><p>     *  where <strong><code>n1</code></strong> is the size of the first sample     * <strong><code> n2</code></strong> is the size of the second sample;     * <strong><code> m1</code></strong> is the mean of the first sample;     * <strong><code> m2</code></strong> is the mean of the second sample;     * <strong><code> var1</code></strong> is the variance of the first sample;     * <strong><code> var2</code></strong> is the variance of the second sample;     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    double t(double[] sample1, double[] sample2)        throws IllegalArgumentException;    /**     * Computes a 2-sample t statistic </a>, comparing the means of the datasets     * described by two {@link StatisticalSummary} instances, without the     * assumption of equal subpopulation variances.  Use     * {@link #homoscedasticT(StatisticalSummary, StatisticalSummary)} to     * compute a t-statistic under the equal variances assumption.     * <p>     * This statistic can be used to perform a two-sample t-test to compare     * sample means.</p>     * <p>      * The returned  t-statisitc is</p>     * <p>     * &nbsp;&nbsp; <code>  t = (m1 - m2) / sqrt(var1/n1 + var2/n2)</code>     * </p><p>     * where <strong><code>n1</code></strong> is the size of the first sample;     * <strong><code> n2</code></strong> is the size of the second sample;     * <strong><code> m1</code></strong> is the mean of the first sample;     * <strong><code> m2</code></strong> is the mean of the second sample     * <strong><code> var1</code></strong> is the variance of the first sample;     * <strong><code> var2</code></strong> is the variance of the second sample     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li></ul></p>     *     * @param sampleStats1 StatisticalSummary describing data from the first sample     * @param sampleStats2 StatisticalSummary describing data from the second sample     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    double t(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException;    /**     * Computes a 2-sample t statistic, comparing the means of the datasets     * described by two {@link StatisticalSummary} instances, under the     * assumption of equal subpopulation variances.  To compute a t-statistic     * without the equal variances assumption, use     * {@link #t(StatisticalSummary, StatisticalSummary)}.     * <p>     * This statistic can be used to perform a (homoscedastic) two-sample     * t-test to compare sample means.</p>     * <p>     * The t-statisitc returned is</p>     * <p>     * &nbsp;&nbsp;<code>  t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))</code>     * </p><p>     * where <strong><code>n1</code></strong> is the size of first sample;     * <strong><code> n2</code></strong> is the size of second sample;     * <strong><code> m1</code></strong> is the mean of first sample;     * <strong><code> m2</code></strong> is the mean of second sample     * and <strong><code>var</code></strong> is the pooled variance estimate:     * </p><p>     * <code>var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))</code>     * </p><p>     * with <strong><code>var1<code></strong> the variance of the first sample and     * <strong><code>var2</code></strong> the variance of the second sample.     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li></ul></p>     *     * @param sampleStats1 StatisticalSummary describing data from the first sample     * @param sampleStats2 StatisticalSummary describing data from the second sample     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    double homoscedasticT(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException;    /**     * Returns the <i>observed significance level</i>, or     * <i>p-value</i>, associated with a one-sample, two-tailed t-test     * comparing the mean of the input array with the constant <code>mu</code>.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the mean equals     * <code>mu</code> in favor of the two-sided alternative that the mean     * is different from <code>mu</code>. For a one-sided test, divide the     * returned value by 2.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">here</a>     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array length must be at least 2.     * </li></ul></p>     *     * @param mu constant value to compare sample mean against     * @param sample array of sample data values     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double tTest(double mu, double[] sample)        throws IllegalArgumentException, MathException;    /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that the mean of the population from     * which <code>sample</code> is drawn equals <code>mu</code>.     * <p>     * Returns <code>true</code> iff the null hypothesis can be     * rejected with confidence <code>1 - alpha</code>.  To     * perform a 1-sided test, use <code>alpha * 2</code></p>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>sample mean = mu </code> at     * the 95% level, use <br><code>tTest(mu, sample, 0.05) </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>     * at the 99% level, first verify that the measured sample mean is less     * than <code>mu</code> and then use     * <br><code>tTest(mu, sample, 0.02) </code>     * </li></ol></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the one-sample     * parametric t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample">here</a>     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array length must be at least 2.     * </li></ul></p>     *     * @param mu constant value to compare sample mean against     * @param sample array of sample data values     * @param alpha significance level of the test     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error computing the p-value     */    boolean tTest(double mu, double[] sample, double alpha)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or     * <i>p-value</i>, associated with a one-sample, two-tailed t-test     * comparing the mean of the dataset described by <code>sampleStats</code>     * with the constant <code>mu</code>.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the mean equals     * <code>mu</code> in favor of the two-sided alternative that the mean     * is different from <code>mu</code>. For a one-sided test, divide the     * returned value by 2.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The sample must contain at least 2 observations.     * </li></ul></p>     *     * @param mu constant value to compare sample mean against     * @param sampleStats StatisticalSummary describing sample data     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double tTest(double mu, StatisticalSummary sampleStats)        throws IllegalArgumentException, MathException;    /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that the mean of the     * population from which the dataset described by <code>stats</code> is     * drawn equals <code>mu</code>.     * <p>     * Returns <code>true</code> iff the null hypothesis can be rejected with     * confidence <code>1 - alpha</code>.  To  perform a 1-sided test, use     * <code>alpha * 2.</code></p>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>sample mean = mu </code> at     * the 95% level, use <br><code>tTest(mu, sampleStats, 0.05) </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>     * at the 99% level, first verify that the measured sample mean is less     * than <code>mu</code> and then use     * <br><code>tTest(mu, sampleStats, 0.02) </code>     * </li></ol></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the one-sample     * parametric t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample">here</a>     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The sample must include at least 2 observations.     * </li></ul></p>     *     * @param mu constant value to compare sample mean against     * @param sampleStats StatisticalSummary describing sample data values     * @param alpha significance level of the test     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    boolean tTest(        double mu,        StatisticalSummary sampleStats,        double alpha)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or     * <i>p-value</i>, associated with a two-sample, two-tailed t-test     * comparing the means of the input arrays.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.     * For a one-sided test, divide the returned value by 2.</p>     * <p>     * The test does not assume that the underlying popuation variances are     * equal  and it uses approximated degrees of freedom computed from the     * sample data to compute the p-value.  The t-statistic used is as defined in     * {@link #t(double[], double[])} and the Welch-Satterthwaite approximation     * to the degrees of freedom is used,     * as described     * <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">     * here.</a>  To perform the test under the assumption of equal subpopulation     * variances, use {@link #homoscedasticTTest(double[], double[])}.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double tTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or     * <i>p-value</i>, associated with a two-sample, two-tailed t-test     * comparing the means of the input arrays, under the assumption that     * the two samples are drawn from subpopulations with equal variances.     * To perform the test without the equal variances assumption, use     * {@link #tTest(double[], double[])}.</p>     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.     * For a one-sided test, divide the returned value by 2.</p>     * <p>     * A pooled variance estimate is used to compute the t-statistic.  See     * {@link #homoscedasticT(double[], double[])}. The sum of the sample sizes     * minus 2 is used as the degrees of freedom.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double homoscedasticTTest(        double[] sample1,        double[] sample2)        throws IllegalArgumentException, MathException;    /**     * Performs a     * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code>     * and <code>sample2</code> are drawn from populations with the same mean,     * with significance level <code>alpha</code>.  This test does not assume     * that the subpopulation variances are equal.  To perform the test assuming     * equal variances, use     * {@link #homoscedasticTTest(double[], double[], double)}.     * <p>     * Returns <code>true</code> iff the null hypothesis that the means are     * equal can be rejected with confidence <code>1 - alpha</code>.  To     * perform a 1-sided test, use <code>alpha * 2</code></p>     * <p>     * See {@link #t(double[], double[])} for the formula used to compute the     * t-statistic.  Degrees of freedom are approximated using the     * <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">     * Welch-Satterthwaite approximation.</a></p>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at     * the 95% level,  use     * <br><code>tTest(sample1, sample2, 0.05). </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code>,     * at the 99% level, first verify that the measured  mean of <code>sample 1</code>     * is less than the mean of <code>sample 2</code> and then use     * <br><code>tTest(sample1, sample2, 0.02) </code>     * </li></ol></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with     * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean tTest(        double[] sample1,        double[] sample2,        double alpha)        throws IllegalArgumentException, MathException;    /**     * Performs a     * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code>     * and <code>sample2</code> are drawn from populations with the same mean,     * with significance level <code>alpha</code>,  assuming that the     * subpopulation variances are equal.  Use     * {@link #tTest(double[], double[], double)} to perform the test without     * the assumption of equal variances.     * <p>     * Returns <code>true</code> iff the null hypothesis that the means are     * equal can be rejected with confidence <code>1 - alpha</code>.  To     * perform a 1-sided test, use <code>alpha * 2.</code>  To perform the test     * without the assumption of equal subpopulation variances, use     * {@link #tTest(double[], double[], double)}.</p>     * <p>     * A pooled variance estimate is used to compute the t-statistic. See     * {@link #t(double[], double[])} for the formula. The sum of the sample     * sizes minus 2 is used as the degrees of freedom.</p>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at     * the 95% level, use <br><code>tTest(sample1, sample2, 0.05). </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2, </code>     * at the 99% level, first verify that the measured mean of     * <code>sample 1</code> is less than the mean of <code>sample 2</code>     * and then use     * <br><code>tTest(sample1, sample2, 0.02) </code>     * </li></ol></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 2.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul></p>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with     * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean homoscedasticTTest(        double[] sample1,        double[] sample2,        double alpha)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or     * <i>p-value</i>, associated with a two-sample, two-tailed t-test     * comparing the means of the datasets described by two StatisticalSummary     * instances.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.     * For a one-sided test, divide the returned value by 2.</p>     * <p>     * The test does not assume that the underlying popuation variances are     * equal  and it uses approximated degrees of freedom computed from the     * sample data to compute the p-value.   To perform the test assuming     * equal variances, use     * {@link #homoscedasticTTest(StatisticalSummary, StatisticalSummary)}.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li></ul></p>     *     * @param sampleStats1  StatisticalSummary describing data from the first sample     * @param sampleStats2  StatisticalSummary describing data from the second sample     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double tTest(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException, MathException;    /**     * Returns the <i>observed significance level</i>, or     * <i>p-value</i>, associated with a two-sample, two-tailed t-test     * comparing the means of the datasets described by two StatisticalSummary     * instances, under the hypothesis of equal subpopulation variances. To     * perform a test without the equal variances assumption, use     * {@link #tTest(StatisticalSummary, StatisticalSummary)}.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.     * For a one-sided test, divide the returned value by 2.</p>     * <p>     * See {@link #homoscedasticT(double[], double[])} for the formula used to     * compute the t-statistic. The sum of the  sample sizes minus 2 is used as     * the degrees of freedom.</p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">here</a>     * </p><p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li></ul></p>     *     * @param sampleStats1  StatisticalSummary describing data from the first sample     * @param sampleStats2  StatisticalSummary describing data from the second sample     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double homoscedasticTTest(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException, MathException;    /**     * Performs a     * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that     * <code>sampleStats1</code> and <code>sampleStats2</code> describe     * datasets drawn from populations with the same mean, with significance     * level <code>alpha</code>.   This test does not assume that the     * subpopulation variances are equal.  To perform the test under the equal     * variances assumption, use     * {@link #homoscedasticTTest(StatisticalSummary, StatisticalSummary)}.     * <p>     * Returns <code>true</code> iff the null hypothesis that the means are     * equal can be rejected with confidence <code>1 - alpha</code>.  To     * perform a 1-sided test, use <code>alpha * 2</code></p>     * <p>     * See {@link #t(double[], double[])} for the formula used to compute the     * t-statistic.  Degrees of freedom are approximated using the     * <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">     * Welch-Satterthwaite approximation.</a></p>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at     * the 95%, use     * <br><code>tTest(sampleStats1, sampleStats2, 0.05) </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code>     * at the 99% level,  first verify that the measured mean of     * <code>sample 1</code> is less than  the mean of <code>sample 2</code>     * and then use     * <br><code>tTest(sampleStats1, sampleStats2, 0.02) </code>     * </li></ol></p>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed     * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">     * here</a></p>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 2 observations.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul></p>     *     * @param sampleStats1 StatisticalSummary describing sample data values     * @param sampleStats2 StatisticalSummary describing sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with     * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean tTest(        StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2,        double alpha)        throws IllegalArgumentException, MathException;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import java.util.Collection;import org.apache.commons.math.MathException;import org.apache.commons.math.stat.descriptive.StatisticalSummary;/** * A collection of static methods to create inference test instances or to * perform inference tests. * * @since 1.1 * @version $Revision$ $Date$ */public class TestUtils  {    /** Singleton TTest instance using default implementation. */    private static TTest tTest = new TTestImpl();    /** Singleton ChiSquareTest instance using default implementation. */    private static ChiSquareTest chiSquareTest =        new ChiSquareTestImpl();    /** Singleton ChiSquareTest instance using default implementation. */    private static UnknownDistributionChiSquareTest unknownDistributionChiSquareTest =        new ChiSquareTestImpl();    /** Singleton OneWayAnova instance using default implementation. */    private static OneWayAnova oneWayAnova =        new OneWayAnovaImpl();    /**     * Prevent instantiation.     */    protected TestUtils() {        super();    }    /**     * Set the (singleton) TTest instance.     *     * @param chiSquareTest the new instance to use     * @since 1.2     */    public static void setChiSquareTest(TTest chiSquareTest) {        TestUtils.tTest = chiSquareTest;    }    /**     * Return a (singleton) TTest instance.  Does not create a new instance.     *     * @return a TTest instance     */    public static TTest getTTest() {        return tTest;    }    /**     * Set the (singleton) ChiSquareTest instance.     *     * @param chiSquareTest the new instance to use     * @since 1.2     */    public static void setChiSquareTest(ChiSquareTest chiSquareTest) {        TestUtils.chiSquareTest = chiSquareTest;    }    /**     * Return a (singleton) ChiSquareTest instance.  Does not create a new instance.     *     * @return a ChiSquareTest instance     */    public static ChiSquareTest getChiSquareTest() {        return chiSquareTest;    }    /**     * Set the (singleton) UnknownDistributionChiSquareTest instance.     *     * @param unknownDistributionChiSquareTest the new instance to use     * @since 1.2     */    public static void setUnknownDistributionChiSquareTest(UnknownDistributionChiSquareTest unknownDistributionChiSquareTest) {        TestUtils.unknownDistributionChiSquareTest = unknownDistributionChiSquareTest;    }    /**     * Return a (singleton) UnknownDistributionChiSquareTest instance.  Does not create a new instance.     *     * @return a UnknownDistributionChiSquareTest instance     */    public static UnknownDistributionChiSquareTest getUnknownDistributionChiSquareTest() {        return unknownDistributionChiSquareTest;    }    /**     * Set the (singleton) OneWayAnova instance     *     * @param oneWayAnova the new instance to use     * @since 1.2     */    public static void setOneWayAnova(OneWayAnova oneWayAnova) {        TestUtils.oneWayAnova = oneWayAnova;    }    /**     * Return a (singleton) OneWayAnova instance.  Does not create a new instance.     *     * @return a OneWayAnova instance     * @since 1.2     */    public static OneWayAnova getOneWayAnova() {        return oneWayAnova;    }    // CHECKSTYLE: stop JavadocMethodCheck    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticT(double[], double[])     */    public static double homoscedasticT(double[] sample1, double[] sample2)        throws IllegalArgumentException {        return tTest.homoscedasticT(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticT(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double homoscedasticT(StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException {        return tTest.homoscedasticT(sampleStats1, sampleStats2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticTTest(double[], double[], double)     */    public static boolean homoscedasticTTest(double[] sample1, double[] sample2,            double alpha)        throws IllegalArgumentException, MathException {        return tTest. homoscedasticTTest(sample1, sample2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticTTest(double[], double[])     */    public static double homoscedasticTTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException {        return tTest.homoscedasticTTest(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticTTest(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double homoscedasticTTest(StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException, MathException {        return tTest.homoscedasticTTest(sampleStats1, sampleStats2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#pairedT(double[], double[])     */    public static double pairedT(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException {        return tTest.pairedT(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#pairedTTest(double[], double[], double)     */    public static boolean pairedTTest(double[] sample1, double[] sample2,        double alpha)        throws IllegalArgumentException, MathException {        return tTest.pairedTTest(sample1, sample2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#pairedTTest(double[], double[])     */    public static double pairedTTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException {        return tTest.pairedTTest(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#t(double, double[])     */    public static double t(double mu, double[] observed)        throws IllegalArgumentException {        return tTest.t(mu, observed);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#t(double, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double t(double mu, StatisticalSummary sampleStats)        throws IllegalArgumentException {        return tTest.t(mu, sampleStats);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#t(double[], double[])     */    public static double t(double[] sample1, double[] sample2)        throws IllegalArgumentException {        return tTest.t(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#t(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double t(StatisticalSummary sampleStats1,            StatisticalSummary sampleStats2)        throws IllegalArgumentException {        return tTest.t(sampleStats1, sampleStats2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, double[], double)     */    public static boolean tTest(double mu, double[] sample, double alpha)        throws IllegalArgumentException, MathException {        return tTest.tTest(mu, sample, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, double[])     */    public static double tTest(double mu, double[] sample)        throws IllegalArgumentException, MathException {        return tTest.tTest(mu, sample);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, org.apache.commons.math.stat.descriptive.StatisticalSummary, double)     */    public static boolean tTest(double mu, StatisticalSummary sampleStats,        double alpha)        throws IllegalArgumentException, MathException {        return tTest. tTest(mu, sampleStats, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double tTest(double mu, StatisticalSummary sampleStats)        throws IllegalArgumentException, MathException {        return tTest.tTest(mu, sampleStats);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double[], double[], double)     */    public static boolean tTest(double[] sample1, double[] sample2, double alpha)        throws IllegalArgumentException, MathException {        return tTest.tTest(sample1, sample2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(double[], double[])     */    public static double tTest(double[] sample1, double[] sample2)        throws IllegalArgumentException, MathException {        return tTest.tTest(sample1, sample2);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary, double)     */    public static boolean tTest(StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2, double alpha)        throws IllegalArgumentException, MathException {        return tTest. tTest(sampleStats1, sampleStats2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.TTest#tTest(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)     */    public static double tTest(StatisticalSummary sampleStats1,        StatisticalSummary sampleStats2)        throws IllegalArgumentException, MathException {        return tTest.tTest(sampleStats1, sampleStats2);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquare(double[], long[])     */    public static double chiSquare(double[] expected, long[] observed)        throws IllegalArgumentException {        return chiSquareTest.chiSquare(expected, observed);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquare(long[][])     */    public static double chiSquare(long[][] counts)        throws IllegalArgumentException {        return chiSquareTest.chiSquare(counts);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(double[], long[], double)     */    public static boolean chiSquareTest(double[] expected, long[] observed,        double alpha)        throws IllegalArgumentException, MathException {        return chiSquareTest.chiSquareTest(expected, observed, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(double[], long[])     */    public static double chiSquareTest(double[] expected, long[] observed)        throws IllegalArgumentException, MathException {        return chiSquareTest.chiSquareTest(expected, observed);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(long[][], double)     */    public static boolean chiSquareTest(long[][] counts, double alpha)        throws IllegalArgumentException, MathException {        return chiSquareTest. chiSquareTest(counts, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(long[][])     */    public static double chiSquareTest(long[][] counts)        throws IllegalArgumentException, MathException {        return chiSquareTest. chiSquareTest(counts);    }    /**     * @see org.apache.commons.math.stat.inference.UnknownDistributionChiSquareTest#chiSquareDataSetsComparison(long[], long[])     *     * @since 1.2     */    public static double chiSquareDataSetsComparison(long[] observed1, long[] observed2)        throws IllegalArgumentException {        return unknownDistributionChiSquareTest.chiSquareDataSetsComparison(observed1, observed2);    }    /**     * @see org.apache.commons.math.stat.inference.UnknownDistributionChiSquareTest#chiSquareTestDataSetsComparison(long[], long[])     *     * @since 1.2     */    public static double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)        throws IllegalArgumentException, MathException {        return unknownDistributionChiSquareTest.chiSquareTestDataSetsComparison(observed1, observed2);    }    /**     * @see org.apache.commons.math.stat.inference.UnknownDistributionChiSquareTest#chiSquareTestDataSetsComparison(long[], long[], double)     *     * @since 1.2     */    public static boolean chiSquareTestDataSetsComparison(long[] observed1, long[] observed2,        double alpha)        throws IllegalArgumentException, MathException {        return unknownDistributionChiSquareTest.chiSquareTestDataSetsComparison(observed1, observed2, alpha);    }    /**     * @see org.apache.commons.math.stat.inference.OneWayAnova#anovaFValue(Collection)     *     * @since 1.2     */    public static double oneWayAnovaFValue(Collection<double[]> categoryData)    throws IllegalArgumentException, MathException {        return oneWayAnova.anovaFValue(categoryData);    }    /**     * @see org.apache.commons.math.stat.inference.OneWayAnova#anovaPValue(Collection)     *     * @since 1.2     */    public static double oneWayAnovaPValue(Collection<double[]> categoryData)    throws IllegalArgumentException, MathException {        return oneWayAnova.anovaPValue(categoryData);    }    /**     * @see org.apache.commons.math.stat.inference.OneWayAnova#anovaTest(Collection,double)     *     * @since 1.2     */    public static boolean oneWayAnovaTest(Collection<double[]> categoryData, double alpha)    throws IllegalArgumentException, MathException {        return oneWayAnova.anovaTest(categoryData, alpha);    }    // CHECKSTYLE: resume JavadocMethodCheck}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.stat.StatUtils;import junit.framework.TestCase;/** * This class contains test cases for the ExpandableDoubleArray. * * @version $Revision$ $Date$ */public abstract class DoubleArrayAbstractTest extends TestCase {    protected DoubleArray da = null;    // Array used to test rolling    protected DoubleArray ra = null;    public DoubleArrayAbstractTest(String name) {        super(name);    }    public void testAdd1000() {        for (int i = 0; i < 1000; i++) {            da.addElement(i);        }        assertEquals(            "Number of elements should be equal to 1000 after adding 1000 values",            1000,            da.getNumElements());        assertEquals(            "The element at the 56th index should be 56",            56.0,            da.getElement(56),            Double.MIN_VALUE);    }    public void testGetValues() {        double[] controlArray = { 2.0, 4.0, 6.0 };        da.addElement(2.0);        da.addElement(4.0);        da.addElement(6.0);        double[] testArray = da.getElements();        for (int i = 0; i < da.getNumElements(); i++) {            assertEquals(                "The testArray values should equal the controlArray values, index i: "                    + i                    + " does not match",                testArray[i],                controlArray[i],                Double.MIN_VALUE);        }    }    public void testAddElementRolling() {        ra.addElement(0.5);        ra.addElement(1.0);        ra.addElement(1.0);        ra.addElement(1.0);        ra.addElement(1.0);        ra.addElement(1.0);        ra.addElementRolling(2.0);        assertEquals(            "There should be 6 elements in the eda",            6,            ra.getNumElements());        assertEquals(            "The max element should be 2.0",            2.0,            StatUtils.max(ra.getElements()),            Double.MIN_VALUE);        assertEquals(            "The min element should be 1.0",            1.0,            StatUtils.min(ra.getElements()),            Double.MIN_VALUE);        for (int i = 0; i < 1024; i++) {            ra.addElementRolling(i);        }        assertEquals(            "We just inserted 1024 rolling elements, num elements should still be 6",            6,            ra.getNumElements());    }    public void testMinMax() {        da.addElement(2.0);        da.addElement(22.0);        da.addElement(-2.0);        da.addElement(21.0);        da.addElement(22.0);        da.addElement(42.0);        da.addElement(62.0);        da.addElement(22.0);        da.addElement(122.0);        da.addElement(1212.0);        assertEquals("Min should be -2.0", -2.0, StatUtils.min(da.getElements()), Double.MIN_VALUE);        assertEquals(            "Max should be 1212.0",            1212.0,            StatUtils.max(da.getElements()),            Double.MIN_VALUE);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class ContinuedFractionTest extends TestCase {    /**     * Constructor for ContinuedFractionTest.     * @param name     */    public ContinuedFractionTest(String name) {        super(name);    }    public void testGoldenRatio(){        ContinuedFraction cf = new ContinuedFraction() {            @Override            public double getA(int n, double x) {                return 1.0;            }            @Override            public double getB(int n, double x) {                return 1.0;            }        };        try {            double gr = cf.evaluate(0.0, 10e-9);            assertEquals(1.61803399, gr, 10e-9);        } catch (MathException e) {            fail(e.getMessage());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.math.BigDecimal;import java.math.BigInteger;import java.math.MathContext;import org.apache.commons.math.TestUtils;import org.junit.Test;public class BigRealTest {    @Test    public void testConstructor() {        assertEquals(1.625, new BigReal(new BigDecimal("1.625")).doubleValue(), 1.0e-15);        assertEquals(-5.0, new BigReal(new BigInteger("-5")).doubleValue(), 1.0e-15);        assertEquals(-5.0, new BigReal(new BigInteger("-5"), MathContext.DECIMAL64).doubleValue(), 1.0e-15);        assertEquals(0.125, new BigReal(new BigInteger("125"), 3).doubleValue(), 1.0e-15);        assertEquals(0.125, new BigReal(new BigInteger("125"), 3, MathContext.DECIMAL64).doubleValue(), 1.0e-15);        assertEquals(1.625, new BigReal(new char[] { '1', '.', '6', '2', '5' }).doubleValue(), 1.0e-15);        assertEquals(1.625, new BigReal(new char[] { 'A', 'A', '1', '.', '6', '2', '5', '9' }, 2, 5).doubleValue(), 1.0e-15);        assertEquals(1.625, new BigReal(new char[] { 'A', 'A', '1', '.', '6', '2', '5', '9' }, 2, 5, MathContext.DECIMAL64).doubleValue(), 1.0e-15);        assertEquals(1.625, new BigReal(new char[] { '1', '.', '6', '2', '5' }, MathContext.DECIMAL64).doubleValue(), 1.0e-15);        assertEquals(1.625, new BigReal(1.625).doubleValue(), 1.0e-15);        assertEquals(1.625, new BigReal(1.625, MathContext.DECIMAL64).doubleValue(), 1.0e-15);        assertEquals(-5.0, new BigReal(-5).doubleValue(), 1.0e-15);        assertEquals(-5.0, new BigReal(-5, MathContext.DECIMAL64).doubleValue(), 1.0e-15);        assertEquals(-5.0, new BigReal(-5l).doubleValue(), 1.0e-15);        assertEquals(-5.0, new BigReal(-5l, MathContext.DECIMAL64).doubleValue(), 1.0e-15);        assertEquals(1.625, new BigReal("1.625").doubleValue(), 1.0e-15);        assertEquals(1.625, new BigReal("1.625", MathContext.DECIMAL64).doubleValue(), 1.0e-15);    }    @Test    public void testCompareTo() {        BigReal first = new BigReal(1.0 / 2.0);        BigReal second = new BigReal(1.0 / 3.0);        BigReal third = new BigReal(1.0 / 2.0);        assertEquals(0, first.compareTo(first));        assertEquals(0, first.compareTo(third));        assertEquals(1, first.compareTo(second));        assertEquals(-1, second.compareTo(first));    }    public void testAdd() {        BigReal a = new BigReal("1.2345678");        BigReal b = new BigReal("8.7654321");        assertEquals(9.9999999, a.add(b).doubleValue(), 1.0e-15);    }    public void testSubtract() {        BigReal a = new BigReal("1.2345678");        BigReal b = new BigReal("8.7654321");        assertEquals( -7.5308643, a.subtract(b).doubleValue(), 1.0e-15);    }    public void testDivide() {        BigReal a = new BigReal("1.0000000000");        BigReal b = new BigReal("0.0009765625");        assertEquals(1024.0, a.divide(b).doubleValue(), 1.0e-15);    }    public void testMultiply() {        BigReal a = new BigReal("1024.0");        BigReal b = new BigReal("0.0009765625");        assertEquals(1.0, a.multiply(b).doubleValue(), 1.0e-15);    }    @Test    public void testDoubleValue() {        assertEquals(0.5, new BigReal(0.5).doubleValue(), 1.0e-15);    }    @Test    public void testBigDecimalValue() {        BigDecimal pi = new BigDecimal("3.1415926535897932384626433832795028841971693993751");        assertEquals(pi, new BigReal(pi).bigDecimalValue());        assertEquals(new BigDecimal(0.5), new BigReal(1.0 / 2.0).bigDecimalValue());    }    @Test    public void testEqualsAndHashCode() {        BigReal zero = new BigReal(0.0);        BigReal nullReal = null;        assertTrue(zero.equals(zero));        assertFalse(zero.equals(nullReal));        assertFalse(zero.equals(Double.valueOf(0)));        BigReal zero2 = new BigReal(0.0);        assertTrue(zero.equals(zero2));        assertEquals(zero.hashCode(), zero2.hashCode());        BigReal one = new BigReal(1.0);        assertFalse((one.equals(zero) || zero.equals(one)));        assertTrue(one.equals(BigReal.ONE));    }    public void testSerial() {        BigReal[] Reals = {            new BigReal(3.0), BigReal.ONE, BigReal.ZERO,            new BigReal(17), new BigReal(FastMath.PI),            new BigReal(-2.5)        };        for (BigReal Real : Reals) {            assertEquals(Real, TestUtils.serializeAndRecover(Real));        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import java.util.ConcurrentModificationException;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.NoSuchElementException;import java.util.Random;import java.util.Set;import java.util.Map.Entry;import org.apache.commons.math.Field;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionConversionException;import org.apache.commons.math.fraction.FractionField;import junit.framework.TestCase;public class OpenIntToFieldTest extends TestCase {    private Map<Integer, Fraction> javaMap = new HashMap<Integer, Fraction>();    private FractionField field = FractionField.getInstance();    @Override    protected void setUp() throws Exception {        javaMap.put(50, new Fraction(100.0));        javaMap.put(75, new Fraction(75.0));        javaMap.put(25, new Fraction(500.0));        javaMap.put(Integer.MAX_VALUE, new Fraction(Integer.MAX_VALUE));        javaMap.put(0, new Fraction(-1.0));        javaMap.put(1, new Fraction(0.0));        javaMap.put(33, new Fraction(-0.1));        javaMap.put(23234234, new Fraction(-242343.0));        javaMap.put(23321, new Fraction (Integer.MIN_VALUE));        javaMap.put(-4444, new Fraction(332.0));        javaMap.put(-1, new Fraction(-2323.0));        javaMap.put(Integer.MIN_VALUE, new Fraction(44.0));        /* Add a few more to cause the table to rehash */        javaMap.putAll(generate());    }    private Map<Integer, Fraction> generate() {        Map<Integer, Fraction> map = new HashMap<Integer, Fraction>();        Random r = new Random();        double dd=0;        for (int i = 0; i < 2000; ++i)            dd = r.nextDouble();            try {                map.put(r.nextInt(), new Fraction(dd));            } catch (FractionConversionException e) {                throw new IllegalStateException("Invalid :"+dd, e);            }        return map;    }    private OpenIntToFieldHashMap<Fraction> createFromJavaMap(Field<Fraction> field) {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());        }        return map;    }    public void testPutAndGetWith0ExpectedSize() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field,0);        assertPutAndGet(map);    }    public void testPutAndGetWithExpectedSize() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field,500);        assertPutAndGet(map);    }    public void testPutAndGet() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);        assertPutAndGet(map);    }    private void assertPutAndGet(OpenIntToFieldHashMap<Fraction> map) {        assertPutAndGet(map, 0, new HashSet<Integer>());    }    private void assertPutAndGet(OpenIntToFieldHashMap<Fraction> map, int mapSize,            Set<Integer> keysInMap) {        assertEquals(mapSize, map.size());        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            if (!keysInMap.contains(mapEntry.getKey()))                ++mapSize;            assertEquals(mapSize, map.size());            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));        }    }    public void testPutAbsentOnExisting() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        int size = javaMap.size();        for (Map.Entry<Integer, Fraction> mapEntry : generateAbsent().entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            assertEquals(++size, map.size());            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));        }    }    public void testPutOnExisting() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            assertEquals(javaMap.size(), map.size());            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));        }    }    public void testGetAbsent() {        Map<Integer, Fraction> generated = generateAbsent();        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        for (Map.Entry<Integer, Fraction> mapEntry : generated.entrySet())            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));    }    public void testGetFromEmpty() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);        assertTrue(field.getZero().equals(map.get(5)));        assertTrue(field.getZero().equals(map.get(0)));        assertTrue(field.getZero().equals(map.get(50)));    }    public void testRemove() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        int mapSize = javaMap.size();        assertEquals(mapSize, map.size());        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            map.remove(mapEntry.getKey());            assertEquals(--mapSize, map.size());            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));        }        /* Ensure that put and get still work correctly after removals */        assertPutAndGet(map);    }    /* This time only remove some entries */    public void testRemove2() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        int mapSize = javaMap.size();        int count = 0;        Set<Integer> keysInMap = new HashSet<Integer>(javaMap.keySet());        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            keysInMap.remove(mapEntry.getKey());            map.remove(mapEntry.getKey());            assertEquals(--mapSize, map.size());            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));            if (count++ > 5)                break;        }        /* Ensure that put and get still work correctly after removals */        assertPutAndGet(map, mapSize, keysInMap);    }    public void testRemoveFromEmpty() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);        assertTrue(field.getZero().equals(map.remove(50)));    }    public void testRemoveAbsent() {        Map<Integer, Fraction> generated = generateAbsent();        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        int mapSize = map.size();        for (Map.Entry<Integer, Fraction> mapEntry : generated.entrySet()) {            map.remove(mapEntry.getKey());            assertEquals(mapSize, map.size());            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));        }    }    /**     * Returns a map with at least 100 elements where each element is absent from javaMap.     */    private Map<Integer, Fraction> generateAbsent() {        Map<Integer, Fraction> generated = new HashMap<Integer, Fraction>();        do {            generated.putAll(generate());            for (Integer key : javaMap.keySet())                generated.remove(key);        } while (generated.size() < 100);        return generated;    }    public void testCopy() {        OpenIntToFieldHashMap<Fraction> copy =            new OpenIntToFieldHashMap<Fraction>(createFromJavaMap(field));        assertEquals(javaMap.size(), copy.size());        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet())            assertEquals(mapEntry.getValue(), copy.get(mapEntry.getKey()));    }    public void testContainsKey() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        for (Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            assertTrue(map.containsKey(mapEntry.getKey()));        }        for (Map.Entry<Integer, Fraction> mapEntry : generateAbsent().entrySet()) {            assertFalse(map.containsKey(mapEntry.getKey()));        }        for (Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {            int key = mapEntry.getKey();            assertTrue(map.containsKey(key));            map.remove(key);            assertFalse(map.containsKey(key));        }    }    public void testIterator() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        OpenIntToFieldHashMap<Fraction>.Iterator iterator = map.iterator();        for (int i = 0; i < map.size(); ++i) {            assertTrue(iterator.hasNext());            iterator.advance();            int key = iterator.key();            assertTrue(map.containsKey(key));            assertEquals(javaMap.get(key), map.get(key));            assertEquals(javaMap.get(key), iterator.value());            assertTrue(javaMap.containsKey(key));        }        assertFalse(iterator.hasNext());        try {            iterator.advance();            fail("an exception should have been thrown");        } catch (NoSuchElementException nsee) {            // expected        }    }    public void testConcurrentModification() {        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);        OpenIntToFieldHashMap<Fraction>.Iterator iterator = map.iterator();        map.put(3, new Fraction(3));        try {            iterator.advance();            fail("an exception should have been thrown");        } catch (ConcurrentModificationException cme) {            // expected        }    }    /**     * Regression test for a bug in findInsertionIndex where the hashing in the second probing     * loop was inconsistent with the first causing duplicate keys after the right sequence     * of puts and removes.     */    public void testPutKeysWithCollisions() {        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);        int key1 = -1996012590;        Fraction value1 = new Fraction(1);        map.put(key1, value1);        int key2 = 835099822;        map.put(key2, value1);        int key3 = 1008859686;        map.put(key3, value1);        assertEquals(value1, map.get(key3));        assertEquals(3, map.size());        map.remove(key2);        Fraction value2 = new Fraction(2);        map.put(key3, value2);        assertEquals(value2, map.get(key3));        assertEquals(2, map.size());    }    /**     * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly     * different manner.     */    public void testPutKeysWithCollision2() {        OpenIntToFieldHashMap<Fraction>map = new OpenIntToFieldHashMap<Fraction>(field);        int key1 = 837989881;        Fraction value1 = new Fraction(1);        map.put(key1, value1);        int key2 = 476463321;        map.put(key2, value1);        assertEquals(2, map.size());        assertEquals(value1, map.get(key2));        map.remove(key1);        Fraction value2 = new Fraction(2);        map.put(key2, value2);        assertEquals(1, map.size());        assertEquals(value2, map.get(key2));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.random.RandomDataImpl;import org.apache.commons.math.random.RandomData;/** * This class contains test cases for the ResizableDoubleArray. * * @version $Revision$ $Date$ */public class ResizableDoubleArrayTest extends DoubleArrayAbstractTest {    public ResizableDoubleArrayTest(String name) {        super( name );    }    @Override    protected void tearDown() throws Exception {        da = null;        ra = null;    }    @Override    protected void setUp() throws Exception {        da = new ResizableDoubleArray();        ra = new ResizableDoubleArray();    }    public void testConstructors() {        float defaultExpansionFactor = 2.0f;        float defaultContractionCriteria = 2.5f;        int defaultMode = ResizableDoubleArray.MULTIPLICATIVE_MODE;        ResizableDoubleArray testDa = new ResizableDoubleArray(2);        assertEquals(0, testDa.getNumElements());        assertEquals(2, testDa.getInternalLength());        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);        assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);        assertEquals(defaultMode, testDa.getExpansionMode());        try {            da = new ResizableDoubleArray(-1);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        testDa = new ResizableDoubleArray(2, 2.0f);        assertEquals(0, testDa.getNumElements());        assertEquals(2, testDa.getInternalLength());        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);        assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);        assertEquals(defaultMode, testDa.getExpansionMode());        try {            da = new ResizableDoubleArray(2, 0.5f);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        testDa = new ResizableDoubleArray(2, 3.0f);        assertEquals(3.0f, testDa.getExpansionFactor(), 0);        assertEquals(3.5f, testDa.getContractionCriteria(), 0);        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f);        assertEquals(0, testDa.getNumElements());        assertEquals(2, testDa.getInternalLength());        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);        assertEquals(3.0f, testDa.getContractionCriteria(), 0);        assertEquals(defaultMode, testDa.getExpansionMode());        try {            da = new ResizableDoubleArray(2, 2.0f, 1.5f);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f,                ResizableDoubleArray.ADDITIVE_MODE);        assertEquals(0, testDa.getNumElements());        assertEquals(2, testDa.getInternalLength());        assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);        assertEquals(3.0f, testDa.getContractionCriteria(), 0);        assertEquals(ResizableDoubleArray.ADDITIVE_MODE,                testDa.getExpansionMode());        try {            da = new ResizableDoubleArray(2, 2.0f, 2.5f, -1);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        // Copy constructor        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f,                ResizableDoubleArray.ADDITIVE_MODE);        testDa.addElement(2.0);        testDa.addElement(3.2);        ResizableDoubleArray copyDa = new ResizableDoubleArray(testDa);        assertEquals(copyDa, testDa);        assertEquals(testDa, copyDa);    }    public void testSetElementArbitraryExpansion() {        // MULTIPLICATIVE_MODE        da.addElement(2.0);        da.addElement(4.0);        da.addElement(6.0);        da.setElement(1, 3.0);        // Expand the array arbitrarily to 1000 items        da.setElement(1000, 3.4);        assertEquals( "The number of elements should now be 1001, it isn't",                da.getNumElements(), 1001);        assertEquals( "Uninitialized Elements are default value of 0.0, index 766 wasn't", 0.0,                da.getElement( 760 ), Double.MIN_VALUE );        assertEquals( "The 1000th index should be 3.4, it isn't", 3.4, da.getElement(1000),                Double.MIN_VALUE );        assertEquals( "The 0th index should be 2.0, it isn't", 2.0, da.getElement(0),                Double.MIN_VALUE);        // Make sure numElements and expansion work correctly for expansion boundary cases        da.clear();        da.addElement(2.0);        da.addElement(4.0);        da.addElement(6.0);        assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());        assertEquals(3, da.getNumElements());        da.setElement(3, 7.0);        assertEquals(4, ((ResizableDoubleArray) da).getInternalLength());        assertEquals(4, da.getNumElements());        da.setElement(10, 10.0);        assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());        assertEquals(11, da.getNumElements());        da.setElement(9, 10.0);        assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());        assertEquals(11, da.getNumElements());        try {            da.setElement(-2, 3);            fail("Expecting ArrayIndexOutOfBoundsException for negative index");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected        }        // ADDITIVE_MODE        ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 3.0f,                ResizableDoubleArray.ADDITIVE_MODE);        assertEquals(2, testDa.getInternalLength());        testDa.addElement(1d);        testDa.addElement(1d);        assertEquals(2, testDa.getInternalLength());        testDa.addElement(1d);        assertEquals(4, testDa.getInternalLength());    }    @Override    public void testAdd1000() {        super.testAdd1000();        assertEquals("Internal Storage length should be 1024 if we started out with initial capacity of " +                "16 and an expansion factor of 2.0",                1024, ((ResizableDoubleArray) da).getInternalLength());    }    @Override    public void testAddElementRolling() {        super.testAddElementRolling();        // MULTIPLICATIVE_MODE        da.clear();        da.addElement(1);        da.addElement(2);        da.addElementRolling(3);        assertEquals(3, da.getElement(1), 0);        da.addElementRolling(4);        assertEquals(3, da.getElement(0), 0);        assertEquals(4, da.getElement(1), 0);        da.addElement(5);        assertEquals(5, da.getElement(2), 0);        da.addElementRolling(6);        assertEquals(4, da.getElement(0), 0);        assertEquals(5, da.getElement(1), 0);        assertEquals(6, da.getElement(2), 0);        // ADDITIVE_MODE  (x's are occupied storage locations, 0's are open)        ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 2.5f,                ResizableDoubleArray.ADDITIVE_MODE);        assertEquals(2, testDa.getInternalLength());        testDa.addElement(1d); // x,0        testDa.addElement(2d); // x,x        testDa.addElement(3d); // x,x,x,0 -- expanded        assertEquals(1d, testDa.getElement(0), 0);        assertEquals(2d, testDa.getElement(1), 0);        assertEquals(3d, testDa.getElement(2), 0);        assertEquals(4, testDa.getInternalLength());  // x,x,x,0        assertEquals(3, testDa.getNumElements());        testDa.addElementRolling(4d);        assertEquals(2d, testDa.getElement(0), 0);        assertEquals(3d, testDa.getElement(1), 0);        assertEquals(4d, testDa.getElement(2), 0);        assertEquals(4, testDa.getInternalLength());  // 0,x,x,x        assertEquals(3, testDa.getNumElements());        testDa.addElementRolling(5d);   // 0,0,x,x,x,0 -- time to contract        assertEquals(3d, testDa.getElement(0), 0);        assertEquals(4d, testDa.getElement(1), 0);        assertEquals(5d, testDa.getElement(2), 0);        assertEquals(4, testDa.getInternalLength());  // contracted -- x,x,x,0        assertEquals(3, testDa.getNumElements());        try {            testDa.getElement(4);            fail("Expecting ArrayIndexOutOfBoundsException");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected        }        try {            testDa.getElement(-1);            fail("Expecting ArrayIndexOutOfBoundsException");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected        }    }    public void testSetNumberOfElements() {        da.addElement( 1.0 );        da.addElement( 1.0 );        da.addElement( 1.0 );        da.addElement( 1.0 );        da.addElement( 1.0 );        da.addElement( 1.0 );        assertEquals( "Number of elements should equal 6", da.getNumElements(), 6);        ((ResizableDoubleArray) da).setNumElements( 3 );        assertEquals( "Number of elements should equal 3", da.getNumElements(), 3);        try {            ((ResizableDoubleArray) da).setNumElements( -3 );            fail( "Setting number of elements to negative should've thrown an exception");        } catch( IllegalArgumentException iae ) {        }        ((ResizableDoubleArray) da).setNumElements(1024);        assertEquals( "Number of elements should now be 1024", da.getNumElements(), 1024);        assertEquals( "Element 453 should be a default double", da.getElement( 453 ), 0.0, Double.MIN_VALUE);    }    public void testWithInitialCapacity() {        ResizableDoubleArray eDA2 = new ResizableDoubleArray(2);        assertEquals("Initial number of elements should be 0", 0, eDA2.getNumElements());        RandomData randomData = new RandomDataImpl();        int iterations = randomData.nextInt(100, 1000);        for( int i = 0; i < iterations; i++) {            eDA2.addElement( i );        }        assertEquals("Number of elements should be equal to " + iterations, iterations, eDA2.getNumElements());        eDA2.addElement( 2.0 );        assertEquals("Number of elements should be equals to " + (iterations +1),                iterations + 1 , eDA2.getNumElements() );    }    public void testWithInitialCapacityAndExpansionFactor() {        ResizableDoubleArray eDA3 = new ResizableDoubleArray(3, 3.0f, 3.5f);        assertEquals("Initial number of elements should be 0", 0, eDA3.getNumElements() );        RandomData randomData = new RandomDataImpl();        int iterations = randomData.nextInt(100, 3000);        for( int i = 0; i < iterations; i++) {            eDA3.addElement( i );        }        assertEquals("Number of elements should be equal to " + iterations, iterations,eDA3.getNumElements());        eDA3.addElement( 2.0 );        assertEquals("Number of elements should be equals to " + (iterations +1),                iterations +1, eDA3.getNumElements() );        assertEquals("Expansion factor should equal 3.0", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);    }    public void testDiscard() {        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        assertEquals( "Number of elements should be 11", 11, da.getNumElements());        ((ResizableDoubleArray)da).discardFrontElements(5);        assertEquals( "Number of elements should be 6", 6, da.getNumElements());        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        assertEquals( "Number of elements should be 10", 10, da.getNumElements());        ((ResizableDoubleArray)da).discardMostRecentElements(2);        assertEquals( "Number of elements should be 8", 8, da.getNumElements());        try {            ((ResizableDoubleArray)da).discardFrontElements(-1);            fail( "Trying to discard a negative number of element is not allowed");        } catch( Exception e ){        }        try {            ((ResizableDoubleArray)da).discardMostRecentElements(-1);            fail( "Trying to discard a negative number of element is not allowed");        } catch( Exception e ){        }        try {            ((ResizableDoubleArray)da).discardFrontElements( 10000 );            fail( "You can't discard more elements than the array contains");        } catch( Exception e ){        }        try {            ((ResizableDoubleArray)da).discardMostRecentElements( 10000 );            fail( "You can't discard more elements than the array contains");        } catch( Exception e ){        }    }    public void testSubstitute() {        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        da.addElement(2.0);        assertEquals( "Number of elements should be 11", 11, da.getNumElements());        ((ResizableDoubleArray)da).substituteMostRecentElement(24);        assertEquals( "Number of elements should be 11", 11, da.getNumElements());        try {            ((ResizableDoubleArray)da).discardMostRecentElements(10);        } catch( Exception e ){            fail( "Trying to discard a negative number of element is not allowed");        }        ((ResizableDoubleArray)da).substituteMostRecentElement(24);        assertEquals( "Number of elements should be 1", 1, da.getNumElements());    }    public void testMutators() {        ((ResizableDoubleArray)da).setContractionCriteria(10f);        assertEquals(10f, ((ResizableDoubleArray)da).getContractionCriteria(), 0);        ((ResizableDoubleArray)da).setExpansionFactor(8f);        assertEquals(8f, ((ResizableDoubleArray)da).getExpansionFactor(), 0);        try {            ((ResizableDoubleArray)da).setExpansionFactor(11f);  // greater than contractionCriteria            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        ((ResizableDoubleArray)da).setExpansionMode(                ResizableDoubleArray.ADDITIVE_MODE);        assertEquals(ResizableDoubleArray.ADDITIVE_MODE,                ((ResizableDoubleArray)da).getExpansionMode());        try {            ((ResizableDoubleArray)da).setExpansionMode(-1);            fail ("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testEqualsAndHashCode() throws Exception {        // Wrong type        ResizableDoubleArray first = new ResizableDoubleArray();        Double other = new Double(2);        assertFalse(first.equals(other));        // Null        other = null;        assertFalse(first.equals(other));        // Reflexive        assertTrue(first.equals(first));        // Argumentless constructor        ResizableDoubleArray second = new ResizableDoubleArray();        verifyEquality(first, second);        // Equals iff same data, same properties        ResizableDoubleArray third = new ResizableDoubleArray(3, 2.0f, 2.0f);        verifyInequality(third, first);        ResizableDoubleArray fourth = new ResizableDoubleArray(3, 2.0f, 2.0f);        ResizableDoubleArray fifth = new ResizableDoubleArray(2, 2.0f, 2.0f);        verifyEquality(third, fourth);        verifyInequality(third, fifth);        third.addElement(4.1);        third.addElement(4.2);        third.addElement(4.3);        fourth.addElement(4.1);        fourth.addElement(4.2);        fourth.addElement(4.3);        verifyEquality(third, fourth);        // expand        fourth.addElement(4.4);        verifyInequality(third, fourth);        third.addElement(4.4);        verifyEquality(third, fourth);        fourth.addElement(4.4);        verifyInequality(third, fourth);        third.addElement(4.4);        verifyEquality(third, fourth);        fourth.addElementRolling(4.5);        third.addElementRolling(4.5);        verifyEquality(third, fourth);        // discard        third.discardFrontElements(1);        verifyInequality(third, fourth);        fourth.discardFrontElements(1);        verifyEquality(third, fourth);        // discard recent        third.discardMostRecentElements(2);        fourth.discardMostRecentElements(2);        verifyEquality(third, fourth);        // wrong order        third.addElement(18);        fourth.addElement(17);        third.addElement(17);        fourth.addElement(18);        verifyInequality(third, fourth);        // copy        ResizableDoubleArray.copy(fourth, fifth);        verifyEquality(fourth, fifth);        // Copy constructor        verifyEquality(fourth, new ResizableDoubleArray(fourth));        // Instance copy        verifyEquality(fourth, fourth.copy());    }    private void verifyEquality(ResizableDoubleArray a, ResizableDoubleArray b) {        assertTrue(b.equals(a));        assertTrue(a.equals(b));        assertEquals(a.hashCode(), b.hashCode());    }    private void verifyInequality(ResizableDoubleArray a, ResizableDoubleArray b) {        assertFalse(b.equals(a));        assertFalse(a.equals(b));        assertFalse(a.hashCode() == b.hashCode());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.util;import java.math.BigDecimal;import java.math.BigInteger;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.exception.NonMonotonousSequenceException;import org.apache.commons.math.random.RandomDataImpl;/** * Test cases for the MathUtils class. * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug *          2007) $ */public final class MathUtilsTest extends TestCase {    public MathUtilsTest(String name) {        super(name);    }    /** cached binomial coefficients */    private static final List<Map<Integer, Long>> binomialCache = new ArrayList<Map<Integer, Long>>();    /**     * Exact (caching) recursive implementation to test against     */    private long binomialCoefficient(int n, int k) throws ArithmeticException {        if (binomialCache.size() > n) {            Long cachedResult = binomialCache.get(n).get(Integer.valueOf(k));            if (cachedResult != null) {                return cachedResult.longValue();            }        }        long result = -1;        if ((n == k) || (k == 0)) {            result = 1;        } else if ((k == 1) || (k == n - 1)) {            result = n;        } else {            // Reduce stack depth for larger values of n            if (k < n - 100) {                binomialCoefficient(n - 100, k);            }            if (k > 100) {                binomialCoefficient(n - 100, k - 100);            }            result = MathUtils.addAndCheck(binomialCoefficient(n - 1, k - 1),                binomialCoefficient(n - 1, k));        }        if (result == -1) {            throw new ArithmeticException(                "error computing binomial coefficient");        }        for (int i = binomialCache.size(); i < n + 1; i++) {            binomialCache.add(new HashMap<Integer, Long>());        }        binomialCache.get(n).put(Integer.valueOf(k), Long.valueOf(result));        return result;    }    /**     * Exact direct multiplication implementation to test against     */    private long factorial(int n) {        long result = 1;        for (int i = 2; i <= n; i++) {            result *= i;        }        return result;    }    /** Verify that b(0,0) = 1 */    public void test0Choose0() {        assertEquals(MathUtils.binomialCoefficientDouble(0, 0), 1d, 0);        assertEquals(MathUtils.binomialCoefficientLog(0, 0), 0d, 0);        assertEquals(MathUtils.binomialCoefficient(0, 0), 1);    }    public void testAddAndCheck() {        int big = Integer.MAX_VALUE;        int bigNeg = Integer.MIN_VALUE;        assertEquals(big, MathUtils.addAndCheck(big, 0));        try {            MathUtils.addAndCheck(big, 1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {        }        try {            MathUtils.addAndCheck(bigNeg, -1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {        }    }    public void testAddAndCheckLong() {        long max = Long.MAX_VALUE;        long min = Long.MIN_VALUE;        assertEquals(max, MathUtils.addAndCheck(max, 0L));        assertEquals(min, MathUtils.addAndCheck(min, 0L));        assertEquals(max, MathUtils.addAndCheck(0L, max));        assertEquals(min, MathUtils.addAndCheck(0L, min));        assertEquals(1, MathUtils.addAndCheck(-1L, 2L));        assertEquals(1, MathUtils.addAndCheck(2L, -1L));        assertEquals(-3, MathUtils.addAndCheck(-2L, -1L));        assertEquals(min, MathUtils.addAndCheck(min + 1, -1L));        testAddAndCheckLongFailure(max, 1L);        testAddAndCheckLongFailure(min, -1L);        testAddAndCheckLongFailure(1L, max);        testAddAndCheckLongFailure(-1L, min);    }    private void testAddAndCheckLongFailure(long a, long b) {        try {            MathUtils.addAndCheck(a, b);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // success        }    }    public void testBinomialCoefficient() {        long[] bcoef5 = {            1,            5,            10,            10,            5,            1 };        long[] bcoef6 = {            1,            6,            15,            20,            15,            6,            1 };        for (int i = 0; i < 6; i++) {            assertEquals("5 choose " + i, bcoef5[i], MathUtils.binomialCoefficient(5, i));        }        for (int i = 0; i < 7; i++) {            assertEquals("6 choose " + i, bcoef6[i], MathUtils.binomialCoefficient(6, i));        }        for (int n = 1; n < 10; n++) {            for (int k = 0; k <= n; k++) {                assertEquals(n + " choose " + k, binomialCoefficient(n, k), MathUtils.binomialCoefficient(n, k));                assertEquals(n + " choose " + k, binomialCoefficient(n, k), MathUtils.binomialCoefficientDouble(n, k), Double.MIN_VALUE);                assertEquals(n + " choose " + k, FastMath.log(binomialCoefficient(n, k)), MathUtils.binomialCoefficientLog(n, k), 10E-12);            }        }        int[] n = { 34, 66, 100, 1500, 1500 };        int[] k = { 17, 33, 10, 1500 - 4, 4 };        for (int i = 0; i < n.length; i++) {            long expected = binomialCoefficient(n[i], k[i]);            assertEquals(n[i] + " choose " + k[i], expected,                MathUtils.binomialCoefficient(n[i], k[i]));            assertEquals(n[i] + " choose " + k[i], expected,                MathUtils.binomialCoefficientDouble(n[i], k[i]), 0.0);            assertEquals("log(" + n[i] + " choose " + k[i] + ")", FastMath.log(expected),                MathUtils.binomialCoefficientLog(n[i], k[i]), 0.0);        }    }    /**     * Tests correctness for large n and sharpness of upper bound in API doc     * JIRA: MATH-241     */    public void testBinomialCoefficientLarge() throws Exception {        // This tests all legal and illegal values for n <= 200.        for (int n = 0; n <= 200; n++) {            for (int k = 0; k <= n; k++) {                long ourResult = -1;                long exactResult = -1;                boolean shouldThrow = false;                boolean didThrow = false;                try {                    ourResult = MathUtils.binomialCoefficient(n, k);                } catch (ArithmeticException ex) {                    didThrow = true;                }                try {                    exactResult = binomialCoefficient(n, k);                } catch (ArithmeticException ex) {                    shouldThrow = true;                }                assertEquals(n + " choose " + k, exactResult, ourResult);                assertEquals(n + " choose " + k, shouldThrow, didThrow);                assertTrue(n + " choose " + k, (n > 66 || !didThrow));                if (!shouldThrow && exactResult > 1) {                    assertEquals(n + " choose " + k, 1.,                        MathUtils.binomialCoefficientDouble(n, k) / exactResult, 1e-10);                    assertEquals(n + " choose " + k, 1,                        MathUtils.binomialCoefficientLog(n, k) / FastMath.log(exactResult), 1e-10);                }            }        }        long ourResult = MathUtils.binomialCoefficient(300, 3);        long exactResult = binomialCoefficient(300, 3);        assertEquals(exactResult, ourResult);        ourResult = MathUtils.binomialCoefficient(700, 697);        exactResult = binomialCoefficient(700, 697);        assertEquals(exactResult, ourResult);        // This one should throw        try {            MathUtils.binomialCoefficient(700, 300);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // Expected        }        int n = 10000;        ourResult = MathUtils.binomialCoefficient(n, 3);        exactResult = binomialCoefficient(n, 3);        assertEquals(exactResult, ourResult);        assertEquals(1, MathUtils.binomialCoefficientDouble(n, 3) / exactResult, 1e-10);        assertEquals(1, MathUtils.binomialCoefficientLog(n, 3) / FastMath.log(exactResult), 1e-10);    }    public void testBinomialCoefficientFail() {        try {            MathUtils.binomialCoefficient(4, 5);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficientDouble(4, 5);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficientLog(4, 5);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficient(-1, -2);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficientDouble(-1, -2);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficientLog(-1, -2);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.binomialCoefficient(67, 30);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {            // ignored        }        try {            MathUtils.binomialCoefficient(67, 34);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {            // ignored        }        double x = MathUtils.binomialCoefficientDouble(1030, 515);        assertTrue("expecting infinite binomial coefficient", Double            .isInfinite(x));    }    public void testCompareTo() {      assertEquals(0, MathUtils.compareTo(152.33, 152.32, .011));      assertTrue(MathUtils.compareTo(152.308, 152.32, .011) < 0);      assertTrue(MathUtils.compareTo(152.33, 152.318, .011) > 0);    }    public void testCosh() {        double x = 3.0;        double expected = 10.06766;        assertEquals(expected, MathUtils.cosh(x), 1.0e-5);    }    public void testCoshNaN() {        assertTrue(Double.isNaN(MathUtils.cosh(Double.NaN)));    }    public void testEqualsIncludingNaN() {        double[] testArray = {            Double.NaN,            Double.POSITIVE_INFINITY,            Double.NEGATIVE_INFINITY,            1d,            0d };        for (int i = 0; i < testArray.length; i++) {            for (int j = 0; j < testArray.length; j++) {                if (i == j) {                    assertTrue(MathUtils.equalsIncludingNaN(testArray[i], testArray[j]));                    assertTrue(MathUtils.equalsIncludingNaN(testArray[j], testArray[i]));                } else {                    assertTrue(!MathUtils.equalsIncludingNaN(testArray[i], testArray[j]));                    assertTrue(!MathUtils.equalsIncludingNaN(testArray[j], testArray[i]));                }            }        }    }    public void testEqualsWithAllowedDelta() {        assertTrue(MathUtils.equals(153.0000, 153.0000, .0625));        assertTrue(MathUtils.equals(153.0000, 153.0625, .0625));        assertTrue(MathUtils.equals(152.9375, 153.0000, .0625));        assertFalse(MathUtils.equals(Double.NaN, Double.NaN, 1.0));        assertTrue(MathUtils.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));        assertTrue(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0));        assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));        assertFalse(MathUtils.equals(153.0000, 153.0625, .0624));        assertFalse(MathUtils.equals(152.9374, 153.0000, .0625));    }    public void testEqualsIncludingNaNWithAllowedDelta() {        assertTrue(MathUtils.equalsIncludingNaN(153.0000, 153.0000, .0625));        assertTrue(MathUtils.equalsIncludingNaN(153.0000, 153.0625, .0625));        assertTrue(MathUtils.equalsIncludingNaN(152.9375, 153.0000, .0625));        assertTrue(MathUtils.equalsIncludingNaN(Double.NaN, Double.NaN, 1.0));        assertTrue(MathUtils.equalsIncludingNaN(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));        assertTrue(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0));        assertFalse(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));        assertFalse(MathUtils.equalsIncludingNaN(153.0000, 153.0625, .0624));        assertFalse(MathUtils.equalsIncludingNaN(152.9374, 153.0000, .0625));    }    public void testEqualsWithAllowedUlps() {        assertTrue(MathUtils.equals(0.0, -0.0, 1));        assertTrue(MathUtils.equals(1.0, 1 + FastMath.ulp(1d), 1));        assertFalse(MathUtils.equals(1.0, 1 + 2 * FastMath.ulp(1d), 1));        final double nUp1 = FastMath.nextAfter(1d, Double.POSITIVE_INFINITY);        final double nnUp1 = FastMath.nextAfter(nUp1, Double.POSITIVE_INFINITY);        assertTrue(MathUtils.equals(1.0, nUp1, 1));        assertTrue(MathUtils.equals(nUp1, nnUp1, 1));        assertFalse(MathUtils.equals(1.0, nnUp1, 1));        assertTrue(MathUtils.equals(0.0, FastMath.ulp(0d), 1));        assertTrue(MathUtils.equals(0.0, -FastMath.ulp(0d), 1));        assertTrue(MathUtils.equals(153.0, 153.0, 1));        assertTrue(MathUtils.equals(153.0, 153.00000000000003, 1));        assertFalse(MathUtils.equals(153.0, 153.00000000000006, 1));        assertTrue(MathUtils.equals(153.0, 152.99999999999997, 1));        assertFalse(MathUtils.equals(153, 152.99999999999994, 1));        assertTrue(MathUtils.equals(-128.0, -127.99999999999999, 1));        assertFalse(MathUtils.equals(-128.0, -127.99999999999997, 1));        assertTrue(MathUtils.equals(-128.0, -128.00000000000003, 1));        assertFalse(MathUtils.equals(-128.0, -128.00000000000006, 1));        assertTrue(MathUtils.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1));        assertTrue(MathUtils.equals(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));        assertTrue(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1));        assertTrue(MathUtils.equals(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1));        assertFalse(MathUtils.equals(Double.NaN, Double.NaN, 1));        assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));    }    public void testEqualsIncludingNaNWithAllowedUlps() {        assertTrue(MathUtils.equalsIncludingNaN(0.0, -0.0, 1));        assertTrue(MathUtils.equalsIncludingNaN(1.0, 1 + FastMath.ulp(1d), 1));        assertFalse(MathUtils.equalsIncludingNaN(1.0, 1 + 2 * FastMath.ulp(1d), 1));        final double nUp1 = FastMath.nextAfter(1d, Double.POSITIVE_INFINITY);        final double nnUp1 = FastMath.nextAfter(nUp1, Double.POSITIVE_INFINITY);        assertTrue(MathUtils.equalsIncludingNaN(1.0, nUp1, 1));        assertTrue(MathUtils.equalsIncludingNaN(nUp1, nnUp1, 1));        assertFalse(MathUtils.equalsIncludingNaN(1.0, nnUp1, 1));        assertTrue(MathUtils.equalsIncludingNaN(0.0, FastMath.ulp(0d), 1));        assertTrue(MathUtils.equalsIncludingNaN(0.0, -FastMath.ulp(0d), 1));        assertTrue(MathUtils.equalsIncludingNaN(153.0, 153.0, 1));        assertTrue(MathUtils.equalsIncludingNaN(153.0, 153.00000000000003, 1));        assertFalse(MathUtils.equalsIncludingNaN(153.0, 153.00000000000006, 1));        assertTrue(MathUtils.equalsIncludingNaN(153.0, 152.99999999999997, 1));        assertFalse(MathUtils.equalsIncludingNaN(153, 152.99999999999994, 1));        assertTrue(MathUtils.equalsIncludingNaN(-128.0, -127.99999999999999, 1));        assertFalse(MathUtils.equalsIncludingNaN(-128.0, -127.99999999999997, 1));        assertTrue(MathUtils.equalsIncludingNaN(-128.0, -128.00000000000003, 1));        assertFalse(MathUtils.equalsIncludingNaN(-128.0, -128.00000000000006, 1));        assertTrue(MathUtils.equalsIncludingNaN(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1));        assertTrue(MathUtils.equalsIncludingNaN(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));        assertTrue(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1));        assertTrue(MathUtils.equalsIncludingNaN(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1));        assertTrue(MathUtils.equalsIncludingNaN(Double.NaN, Double.NaN, 1));        assertFalse(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));    }    /**     * @deprecated To be removed in release 3.0 (replaced by {@link     * #testArrayEqualsIncludingNaN()}.     */    public void testArrayEquals() {        assertFalse(MathUtils.equals(new double[] { 1d }, null));        assertFalse(MathUtils.equals(null, new double[] { 1d }));        assertTrue(MathUtils.equals((double[]) null, (double[]) null));        assertFalse(MathUtils.equals(new double[] { 1d }, new double[0]));        assertTrue(MathUtils.equals(new double[] { 1d }, new double[] { 1d }));        assertTrue(MathUtils.equals(new double[] {                                      Double.POSITIVE_INFINITY,                                      Double.NEGATIVE_INFINITY, 1d, 0d                                    }, new double[] {                                      Double.POSITIVE_INFINITY,                                      Double.NEGATIVE_INFINITY, 1d, 0d                                    }));        assertFalse(MathUtils.equals(new double[] { Double.NaN },                                     new double[] { Double.NaN }));        assertFalse(MathUtils.equals(new double[] { Double.POSITIVE_INFINITY },                                     new double[] { Double.NEGATIVE_INFINITY }));        assertFalse(MathUtils.equals(new double[] { 1d },                                     new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) }));    }    public void testArrayEqualsIncludingNaN() {        assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d }, null));        assertFalse(MathUtils.equalsIncludingNaN(null, new double[] { 1d }));        assertTrue(MathUtils.equalsIncludingNaN((double[]) null, (double[]) null));        assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d }, new double[0]));        assertTrue(MathUtils.equalsIncludingNaN(new double[] { 1d }, new double[] { 1d }));        assertTrue(MathUtils.equalsIncludingNaN(new double[] {                    Double.NaN, Double.POSITIVE_INFINITY,                    Double.NEGATIVE_INFINITY, 1d, 0d                }, new double[] {                    Double.NaN, Double.POSITIVE_INFINITY,                    Double.NEGATIVE_INFINITY, 1d, 0d                }));        assertFalse(MathUtils.equalsIncludingNaN(new double[] { Double.POSITIVE_INFINITY },                                                 new double[] { Double.NEGATIVE_INFINITY }));        assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d },                                                 new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) }));    }    public void testFactorial() {        for (int i = 1; i < 21; i++) {            assertEquals(i + "! ", factorial(i), MathUtils.factorial(i));            assertEquals(i + "! ", factorial(i), MathUtils.factorialDouble(i), Double.MIN_VALUE);            assertEquals(i + "! ", FastMath.log(factorial(i)), MathUtils.factorialLog(i), 10E-12);        }        assertEquals("0", 1, MathUtils.factorial(0));        assertEquals("0", 1.0d, MathUtils.factorialDouble(0), 1E-14);        assertEquals("0", 0.0d, MathUtils.factorialLog(0), 1E-14);    }    public void testFactorialFail() {        try {            MathUtils.factorial(-1);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.factorialDouble(-1);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.factorialLog(-1);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            MathUtils.factorial(21);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {            // ignored        }        assertTrue("expecting infinite factorial value", Double.isInfinite(MathUtils.factorialDouble(171)));    }    public void testGcd() {        int a = 30;        int b = 50;        int c = 77;        assertEquals(0, MathUtils.gcd(0, 0));        assertEquals(b, MathUtils.gcd(0, b));        assertEquals(a, MathUtils.gcd(a, 0));        assertEquals(b, MathUtils.gcd(0, -b));        assertEquals(a, MathUtils.gcd(-a, 0));        assertEquals(10, MathUtils.gcd(a, b));        assertEquals(10, MathUtils.gcd(-a, b));        assertEquals(10, MathUtils.gcd(a, -b));        assertEquals(10, MathUtils.gcd(-a, -b));        assertEquals(1, MathUtils.gcd(a, c));        assertEquals(1, MathUtils.gcd(-a, c));        assertEquals(1, MathUtils.gcd(a, -c));        assertEquals(1, MathUtils.gcd(-a, -c));        assertEquals(3 * (1<<15), MathUtils.gcd(3 * (1<<20), 9 * (1<<15)));        assertEquals(Integer.MAX_VALUE, MathUtils.gcd(Integer.MAX_VALUE, 0));        assertEquals(Integer.MAX_VALUE, MathUtils.gcd(-Integer.MAX_VALUE, 0));        assertEquals(1<<30, MathUtils.gcd(1<<30, -Integer.MIN_VALUE));        try {            // gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE            MathUtils.gcd(Integer.MIN_VALUE, 0);            fail("expecting ArithmeticException");        } catch (ArithmeticException expected) {            // expected        }        try {            // gcd(0, Integer.MIN_VALUE) > Integer.MAX_VALUE            MathUtils.gcd(0, Integer.MIN_VALUE);            fail("expecting ArithmeticException");        } catch (ArithmeticException expected) {            // expected        }        try {            // gcd(Integer.MIN_VALUE, Integer.MIN_VALUE) > Integer.MAX_VALUE            MathUtils.gcd(Integer.MIN_VALUE, Integer.MIN_VALUE);            fail("expecting ArithmeticException");        } catch (ArithmeticException expected) {            // expected        }    }    public void  testGcdLong(){        long a = 30;        long b = 50;        long c = 77;        assertEquals(0, MathUtils.gcd(0L, 0));        assertEquals(b, MathUtils.gcd(0, b));        assertEquals(a, MathUtils.gcd(a, 0));        assertEquals(b, MathUtils.gcd(0, -b));        assertEquals(a, MathUtils.gcd(-a, 0));        assertEquals(10, MathUtils.gcd(a, b));        assertEquals(10, MathUtils.gcd(-a, b));        assertEquals(10, MathUtils.gcd(a, -b));        assertEquals(10, MathUtils.gcd(-a, -b));        assertEquals(1, MathUtils.gcd(a, c));        assertEquals(1, MathUtils.gcd(-a, c));        assertEquals(1, MathUtils.gcd(a, -c));        assertEquals(1, MathUtils.gcd(-a, -c));        assertEquals(3L * (1L<<45), MathUtils.gcd(3L * (1L<<50), 9L * (1L<<45)));        assertEquals(1L<<45, MathUtils.gcd(1L<<45, Long.MIN_VALUE));        assertEquals(Long.MAX_VALUE, MathUtils.gcd(Long.MAX_VALUE, 0L));        assertEquals(Long.MAX_VALUE, MathUtils.gcd(-Long.MAX_VALUE, 0L));        assertEquals(1, MathUtils.gcd(60247241209L, 153092023L));        try {            // gcd(Long.MIN_VALUE, 0) > Long.MAX_VALUE            MathUtils.gcd(Long.MIN_VALUE, 0);            fail("expecting ArithmeticException");        } catch (ArithmeticException expected) {            // expected        }        try {            // gcd(0, Long.MIN_VALUE) > Long.MAX_VALUE            MathUtils.gcd(0, Long.MIN_VALUE);            fail("expecting ArithmeticException");        } catch (ArithmeticException expected) {            // expected        }        try {            // gcd(Long.MIN_VALUE, Long.MIN_VALUE) > Long.MAX_VALUE            MathUtils.gcd(Long.MIN_VALUE, Long.MIN_VALUE);            fail("expecting ArithmeticException");        } catch (ArithmeticException expected) {            // expected        }    }    public void testGcdConsistency() {        int[] primeList = {19, 23, 53, 67, 73, 79, 101, 103, 111, 131};        ArrayList<Integer> primes = new ArrayList<Integer>();        for (int i = 0; i < primeList.length; i++) {            primes.add(Integer.valueOf(primeList[i]));        }        RandomDataImpl randomData = new RandomDataImpl();        for (int i = 0; i < 20; i++) {            Object[] sample = randomData.nextSample(primes, 4);            int p1 = ((Integer) sample[0]).intValue();            int p2 = ((Integer) sample[1]).intValue();            int p3 = ((Integer) sample[2]).intValue();            int p4 = ((Integer) sample[3]).intValue();            int i1 = p1 * p2 * p3;            int i2 = p1 * p2 * p4;            int gcd = p1 * p2;            assertEquals(gcd, MathUtils.gcd(i1, i2));            long l1 = i1;            long l2 = i2;            assertEquals(gcd, MathUtils.gcd(l1, l2));        }    }    public void testHash() {        double[] testArray = {            Double.NaN,            Double.POSITIVE_INFINITY,            Double.NEGATIVE_INFINITY,            1d,            0d,            1E-14,            (1 + 1E-14),            Double.MIN_VALUE,            Double.MAX_VALUE };        for (int i = 0; i < testArray.length; i++) {            for (int j = 0; j < testArray.length; j++) {                if (i == j) {                    assertEquals(MathUtils.hash(testArray[i]), MathUtils.hash(testArray[j]));                    assertEquals(MathUtils.hash(testArray[j]), MathUtils.hash(testArray[i]));                } else {                    assertTrue(MathUtils.hash(testArray[i]) != MathUtils.hash(testArray[j]));                    assertTrue(MathUtils.hash(testArray[j]) != MathUtils.hash(testArray[i]));                }            }        }    }    public void testArrayHash() {        assertEquals(0, MathUtils.hash((double[]) null));        assertEquals(MathUtils.hash(new double[] {                                      Double.NaN, Double.POSITIVE_INFINITY,                                      Double.NEGATIVE_INFINITY, 1d, 0d                                    }),                     MathUtils.hash(new double[] {                                      Double.NaN, Double.POSITIVE_INFINITY,                                      Double.NEGATIVE_INFINITY, 1d, 0d                                    }));        assertFalse(MathUtils.hash(new double[] { 1d }) ==                    MathUtils.hash(new double[] { FastMath.nextAfter(1d, 2d) }));        assertFalse(MathUtils.hash(new double[] { 1d }) ==                    MathUtils.hash(new double[] { 1d, 1d }));    }    /**     * Make sure that permuted arrays do not hash to the same value.     */    public void testPermutedArrayHash() {        double[] original = new double[10];        double[] permuted = new double[10];        RandomDataImpl random = new RandomDataImpl();        // Generate 10 distinct random values        for (int i = 0; i < 10; i++) {            original[i] = random.nextUniform(i + 0.5, i + 0.75);        }        // Generate a random permutation, making sure it is not the identity        boolean isIdentity = true;        do {            int[] permutation = random.nextPermutation(10, 10);            for (int i = 0; i < 10; i++) {                if (i != permutation[i]) {                    isIdentity = false;                }                permuted[i] = original[permutation[i]];            }        } while (isIdentity);        // Verify that permuted array has different hash        assertFalse(MathUtils.hash(original) == MathUtils.hash(permuted));    }    public void testIndicatorByte() {        assertEquals((byte)1, MathUtils.indicator((byte)2));        assertEquals((byte)1, MathUtils.indicator((byte)0));        assertEquals((byte)(-1), MathUtils.indicator((byte)(-2)));    }    public void testIndicatorDouble() {        double delta = 0.0;        assertEquals(1.0, MathUtils.indicator(2.0), delta);        assertEquals(1.0, MathUtils.indicator(0.0), delta);        assertEquals(-1.0, MathUtils.indicator(-2.0), delta);        assertEquals(Double.NaN, MathUtils.indicator(Double.NaN));    }    public void testIndicatorFloat() {        float delta = 0.0F;        assertEquals(1.0F, MathUtils.indicator(2.0F), delta);        assertEquals(1.0F, MathUtils.indicator(0.0F), delta);        assertEquals(-1.0F, MathUtils.indicator(-2.0F), delta);    }    public void testIndicatorInt() {        assertEquals(1, MathUtils.indicator((2)));        assertEquals(1, MathUtils.indicator((0)));        assertEquals((-1), MathUtils.indicator((-2)));    }    public void testIndicatorLong() {        assertEquals(1L, MathUtils.indicator(2L));        assertEquals(1L, MathUtils.indicator(0L));        assertEquals(-1L, MathUtils.indicator(-2L));    }    public void testIndicatorShort() {        assertEquals((short)1, MathUtils.indicator((short)2));        assertEquals((short)1, MathUtils.indicator((short)0));        assertEquals((short)(-1), MathUtils.indicator((short)(-2)));    }    public void testLcm() {        int a = 30;        int b = 50;        int c = 77;        assertEquals(0, MathUtils.lcm(0, b));        assertEquals(0, MathUtils.lcm(a, 0));        assertEquals(b, MathUtils.lcm(1, b));        assertEquals(a, MathUtils.lcm(a, 1));        assertEquals(150, MathUtils.lcm(a, b));        assertEquals(150, MathUtils.lcm(-a, b));        assertEquals(150, MathUtils.lcm(a, -b));        assertEquals(150, MathUtils.lcm(-a, -b));        assertEquals(2310, MathUtils.lcm(a, c));        // Assert that no intermediate value overflows:        // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)        assertEquals((1<<20)*15, MathUtils.lcm((1<<20)*3, (1<<20)*5));        // Special case        assertEquals(0, MathUtils.lcm(0, 0));        try {            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int            MathUtils.lcm(Integer.MIN_VALUE, 1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException expected) {            // expected        }        try {            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int            MathUtils.lcm(Integer.MIN_VALUE, 1<<20);            fail("Expecting ArithmeticException");        } catch (ArithmeticException expected) {            // expected        }        try {            MathUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException expected) {            // expected        }    }    public void testLcmLong() {        long a = 30;        long b = 50;        long c = 77;        assertEquals(0, MathUtils.lcm(0, b));        assertEquals(0, MathUtils.lcm(a, 0));        assertEquals(b, MathUtils.lcm(1, b));        assertEquals(a, MathUtils.lcm(a, 1));        assertEquals(150, MathUtils.lcm(a, b));        assertEquals(150, MathUtils.lcm(-a, b));        assertEquals(150, MathUtils.lcm(a, -b));        assertEquals(150, MathUtils.lcm(-a, -b));        assertEquals(2310, MathUtils.lcm(a, c));        assertEquals(Long.MAX_VALUE, MathUtils.lcm(60247241209L, 153092023L));        // Assert that no intermediate value overflows:        // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)        assertEquals((1L<<50)*15, MathUtils.lcm((1L<<45)*3, (1L<<50)*5));        // Special case        assertEquals(0L, MathUtils.lcm(0L, 0L));        try {            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int            MathUtils.lcm(Long.MIN_VALUE, 1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException expected) {            // expected        }        try {            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int            MathUtils.lcm(Long.MIN_VALUE, 1<<20);            fail("Expecting ArithmeticException");        } catch (ArithmeticException expected) {            // expected        }        assertEquals((long) Integer.MAX_VALUE * (Integer.MAX_VALUE - 1),            MathUtils.lcm((long)Integer.MAX_VALUE, Integer.MAX_VALUE - 1));        try {            MathUtils.lcm(Long.MAX_VALUE, Long.MAX_VALUE - 1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException expected) {            // expected        }    }    public void testLog() {        assertEquals(2.0, MathUtils.log(2, 4), 0);        assertEquals(3.0, MathUtils.log(2, 8), 0);        assertTrue(Double.isNaN(MathUtils.log(-1, 1)));        assertTrue(Double.isNaN(MathUtils.log(1, -1)));        assertTrue(Double.isNaN(MathUtils.log(0, 0)));        assertEquals(0, MathUtils.log(0, 10), 0);        assertEquals(Double.NEGATIVE_INFINITY, MathUtils.log(10, 0), 0);    }    public void testMulAndCheck() {        int big = Integer.MAX_VALUE;        int bigNeg = Integer.MIN_VALUE;        assertEquals(big, MathUtils.mulAndCheck(big, 1));        try {            MathUtils.mulAndCheck(big, 2);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {        }        try {            MathUtils.mulAndCheck(bigNeg, 2);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {        }    }    public void testMulAndCheckLong() {        long max = Long.MAX_VALUE;        long min = Long.MIN_VALUE;        assertEquals(max, MathUtils.mulAndCheck(max, 1L));        assertEquals(min, MathUtils.mulAndCheck(min, 1L));        assertEquals(0L, MathUtils.mulAndCheck(max, 0L));        assertEquals(0L, MathUtils.mulAndCheck(min, 0L));        assertEquals(max, MathUtils.mulAndCheck(1L, max));        assertEquals(min, MathUtils.mulAndCheck(1L, min));        assertEquals(0L, MathUtils.mulAndCheck(0L, max));        assertEquals(0L, MathUtils.mulAndCheck(0L, min));        assertEquals(1L, MathUtils.mulAndCheck(-1L, -1L));        assertEquals(min, MathUtils.mulAndCheck(min / 2, 2));        testMulAndCheckLongFailure(max, 2L);        testMulAndCheckLongFailure(2L, max);        testMulAndCheckLongFailure(min, 2L);        testMulAndCheckLongFailure(2L, min);        testMulAndCheckLongFailure(min, -1L);        testMulAndCheckLongFailure(-1L, min);    }    private void testMulAndCheckLongFailure(long a, long b) {        try {            MathUtils.mulAndCheck(a, b);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // success        }    }    public void testNextAfter() {        // 0x402fffffffffffff 0x404123456789abcd -> 4030000000000000        assertEquals(16.0, FastMath.nextAfter(15.999999999999998, 34.27555555555555), 0.0);        // 0xc02fffffffffffff 0x404123456789abcd -> c02ffffffffffffe        assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 34.27555555555555), 0.0);        // 0x402fffffffffffff 0x400123456789abcd -> 402ffffffffffffe        assertEquals(15.999999999999996, FastMath.nextAfter(15.999999999999998, 2.142222222222222), 0.0);        // 0xc02fffffffffffff 0x400123456789abcd -> c02ffffffffffffe        assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 2.142222222222222), 0.0);        // 0x4020000000000000 0x404123456789abcd -> 4020000000000001        assertEquals(8.000000000000002, FastMath.nextAfter(8.0, 34.27555555555555), 0.0);        // 0xc020000000000000 0x404123456789abcd -> c01fffffffffffff        assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 34.27555555555555), 0.0);        // 0x4020000000000000 0x400123456789abcd -> 401fffffffffffff        assertEquals(7.999999999999999, FastMath.nextAfter(8.0, 2.142222222222222), 0.0);        // 0xc020000000000000 0x400123456789abcd -> c01fffffffffffff        assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 2.142222222222222), 0.0);        // 0x3f2e43753d36a223 0x3f2e43753d36a224 -> 3f2e43753d36a224        assertEquals(2.308922399667661E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0);        // 0x3f2e43753d36a223 0x3f2e43753d36a223 -> 3f2e43753d36a224        assertEquals(2.308922399667661E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);        // 0x3f2e43753d36a223 0x3f2e43753d36a222 -> 3f2e43753d36a222        assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);        // 0x3f2e43753d36a223 0xbf2e43753d36a224 -> 3f2e43753d36a222        assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0);        // 0x3f2e43753d36a223 0xbf2e43753d36a223 -> 3f2e43753d36a222        assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);        // 0x3f2e43753d36a223 0xbf2e43753d36a222 -> 3f2e43753d36a222        assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);        // 0xbf2e43753d36a223 0x3f2e43753d36a224 -> bf2e43753d36a222        assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0);        // 0xbf2e43753d36a223 0x3f2e43753d36a223 -> bf2e43753d36a222        assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);        // 0xbf2e43753d36a223 0x3f2e43753d36a222 -> bf2e43753d36a222        assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);        // 0xbf2e43753d36a223 0xbf2e43753d36a224 -> bf2e43753d36a224        assertEquals(-2.308922399667661E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0);        // 0xbf2e43753d36a223 0xbf2e43753d36a223 -> bf2e43753d36a224        assertEquals(-2.308922399667661E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);        // 0xbf2e43753d36a223 0xbf2e43753d36a222 -> bf2e43753d36a222        assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);    }    public void testNextAfterSpecialCases() {        assertTrue(Double.isInfinite(FastMath.nextAfter(Double.NEGATIVE_INFINITY, 0)));        assertTrue(Double.isInfinite(FastMath.nextAfter(Double.POSITIVE_INFINITY, 0)));        assertTrue(Double.isNaN(FastMath.nextAfter(Double.NaN, 0)));        assertTrue(Double.isInfinite(FastMath.nextAfter(Double.MAX_VALUE, Double.POSITIVE_INFINITY)));        assertTrue(Double.isInfinite(FastMath.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY)));        assertEquals(Double.MIN_VALUE, FastMath.nextAfter(0, 1), 0);        assertEquals(-Double.MIN_VALUE, FastMath.nextAfter(0, -1), 0);        assertEquals(0, FastMath.nextAfter(Double.MIN_VALUE, -1), 0);        assertEquals(0, FastMath.nextAfter(-Double.MIN_VALUE, 1), 0);    }    public void testScalb() {        assertEquals( 0.0, MathUtils.scalb(0.0, 5), 1.0e-15);        assertEquals(32.0, MathUtils.scalb(1.0, 5), 1.0e-15);        assertEquals(1.0 / 32.0, MathUtils.scalb(1.0,  -5), 1.0e-15);        assertEquals(FastMath.PI, MathUtils.scalb(FastMath.PI, 0), 1.0e-15);        assertTrue(Double.isInfinite(MathUtils.scalb(Double.POSITIVE_INFINITY, 1)));        assertTrue(Double.isInfinite(MathUtils.scalb(Double.NEGATIVE_INFINITY, 1)));        assertTrue(Double.isNaN(MathUtils.scalb(Double.NaN, 1)));    }    public void testNormalizeAngle() {        for (double a = -15.0; a <= 15.0; a += 0.1) {            for (double b = -15.0; b <= 15.0; b += 0.2) {                double c = MathUtils.normalizeAngle(a, b);                assertTrue((b - FastMath.PI) <= c);                assertTrue(c <= (b + FastMath.PI));                double twoK = FastMath.rint((a - c) / FastMath.PI);                assertEquals(c, a - twoK * FastMath.PI, 1.0e-14);            }        }    }    public void testNormalizeArray() {        double[] testValues1 = new double[] {1, 1, 2};        TestUtils.assertEquals(                new double[] {.25, .25, .5},                MathUtils.normalizeArray(testValues1, 1),                Double.MIN_VALUE);        double[] testValues2 = new double[] {-1, -1, 1};        TestUtils.assertEquals(                new double[] {1, 1, -1},                MathUtils.normalizeArray(testValues2, 1),                Double.MIN_VALUE);        // Ignore NaNs        double[] testValues3 = new double[] {-1, -1, Double.NaN, 1, Double.NaN};        TestUtils.assertEquals(                new double[] {1, 1,Double.NaN, -1, Double.NaN},                MathUtils.normalizeArray(testValues3, 1),                Double.MIN_VALUE);        // Zero sum -> ArithmeticException        double[] zeroSum = new double[] {-1, 1};        try {            MathUtils.normalizeArray(zeroSum, 1);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}        // Infinite elements -> ArithmeticException        double[] hasInf = new double[] {1, 2, 1, Double.NEGATIVE_INFINITY};        try {            MathUtils.normalizeArray(hasInf, 1);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}        // Infinite target -> IllegalArgumentException        try {            MathUtils.normalizeArray(testValues1, Double.POSITIVE_INFINITY);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {}        // NaN target -> IllegalArgumentException        try {            MathUtils.normalizeArray(testValues1, Double.NaN);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {}    }    public void testRoundDouble() {        double x = 1.234567890;        assertEquals(1.23, MathUtils.round(x, 2), 0.0);        assertEquals(1.235, MathUtils.round(x, 3), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4), 0.0);        // JIRA MATH-151        assertEquals(39.25, MathUtils.round(39.245, 2), 0.0);        assertEquals(39.24, MathUtils.round(39.245, 2, BigDecimal.ROUND_DOWN), 0.0);        double xx = 39.0;        xx = xx + 245d / 1000d;        assertEquals(39.25, MathUtils.round(xx, 2), 0.0);        // BZ 35904        assertEquals(30.1d, MathUtils.round(30.095d, 2), 0.0d);        assertEquals(30.1d, MathUtils.round(30.095d, 1), 0.0d);        assertEquals(33.1d, MathUtils.round(33.095d, 1), 0.0d);        assertEquals(33.1d, MathUtils.round(33.095d, 2), 0.0d);        assertEquals(50.09d, MathUtils.round(50.085d, 2), 0.0d);        assertEquals(50.19d, MathUtils.round(50.185d, 2), 0.0d);        assertEquals(50.01d, MathUtils.round(50.005d, 2), 0.0d);        assertEquals(30.01d, MathUtils.round(30.005d, 2), 0.0d);        assertEquals(30.65d, MathUtils.round(30.645d, 2), 0.0d);        assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.236, MathUtils.round(1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.236, MathUtils.round(-1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.235, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.235, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.23, MathUtils.round(-1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);        assertEquals(1.23, MathUtils.round(1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);        try {            MathUtils.round(1.234, 2, BigDecimal.ROUND_UNNECESSARY);            fail();        } catch (ArithmeticException ex) {            // success        }        assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);        try {            MathUtils.round(1.234, 2, 1923);            fail();        } catch (IllegalArgumentException ex) {            // success        }        // MATH-151        assertEquals(39.25, MathUtils.round(39.245, 2, BigDecimal.ROUND_HALF_UP), 0.0);        // special values        TestUtils.assertEquals(Double.NaN, MathUtils.round(Double.NaN, 2), 0.0);        assertEquals(0.0, MathUtils.round(0.0, 2), 0.0);        assertEquals(Double.POSITIVE_INFINITY, MathUtils.round(Double.POSITIVE_INFINITY, 2), 0.0);        assertEquals(Double.NEGATIVE_INFINITY, MathUtils.round(Double.NEGATIVE_INFINITY, 2), 0.0);    }    public void testRoundFloat() {        float x = 1.234567890f;        assertEquals(1.23f, MathUtils.round(x, 2), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4), 0.0);        // BZ 35904        assertEquals(30.1f, MathUtils.round(30.095f, 2), 0.0f);        assertEquals(30.1f, MathUtils.round(30.095f, 1), 0.0f);        assertEquals(50.09f, MathUtils.round(50.085f, 2), 0.0f);        assertEquals(50.19f, MathUtils.round(50.185f, 2), 0.0f);        assertEquals(50.01f, MathUtils.round(50.005f, 2), 0.0f);        assertEquals(30.01f, MathUtils.round(30.005f, 2), 0.0f);        assertEquals(30.65f, MathUtils.round(30.645f, 2), 0.0f);        assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.236f, MathUtils.round(1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(-1.236f, MathUtils.round(-1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(1.235f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.235f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);        assertEquals(-1.23f, MathUtils.round(-1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);        assertEquals(1.23f, MathUtils.round(1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);        try {            MathUtils.round(1.234f, 2, BigDecimal.ROUND_UNNECESSARY);            fail();        } catch (ArithmeticException ex) {            // success        }        assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);        try {            MathUtils.round(1.234f, 2, 1923);            fail();        } catch (IllegalArgumentException ex) {            // success        }        // special values        TestUtils.assertEquals(Float.NaN, MathUtils.round(Float.NaN, 2), 0.0f);        assertEquals(0.0f, MathUtils.round(0.0f, 2), 0.0f);        assertEquals(Float.POSITIVE_INFINITY, MathUtils.round(Float.POSITIVE_INFINITY, 2), 0.0f);        assertEquals(Float.NEGATIVE_INFINITY, MathUtils.round(Float.NEGATIVE_INFINITY, 2), 0.0f);    }    public void testSignByte() {        assertEquals((byte) 1, MathUtils.sign((byte) 2));        assertEquals((byte) 0, MathUtils.sign((byte) 0));        assertEquals((byte) (-1), MathUtils.sign((byte) (-2)));    }    public void testSignDouble() {        double delta = 0.0;        assertEquals(1.0, MathUtils.sign(2.0), delta);        assertEquals(0.0, MathUtils.sign(0.0), delta);        assertEquals(-1.0, MathUtils.sign(-2.0), delta);        TestUtils.assertSame(-0. / 0., MathUtils.sign(Double.NaN));    }    public void testSignFloat() {        float delta = 0.0F;        assertEquals(1.0F, MathUtils.sign(2.0F), delta);        assertEquals(0.0F, MathUtils.sign(0.0F), delta);        assertEquals(-1.0F, MathUtils.sign(-2.0F), delta);        TestUtils.assertSame(Float.NaN, MathUtils.sign(Float.NaN));    }    public void testSignInt() {        assertEquals(1, MathUtils.sign(2));        assertEquals(0, MathUtils.sign(0));        assertEquals((-1), MathUtils.sign((-2)));    }    public void testSignLong() {        assertEquals(1L, MathUtils.sign(2L));        assertEquals(0L, MathUtils.sign(0L));        assertEquals(-1L, MathUtils.sign(-2L));    }    public void testSignShort() {        assertEquals((short) 1, MathUtils.sign((short) 2));        assertEquals((short) 0, MathUtils.sign((short) 0));        assertEquals((short) (-1), MathUtils.sign((short) (-2)));    }    public void testSinh() {        double x = 3.0;        double expected = 10.01787;        assertEquals(expected, MathUtils.sinh(x), 1.0e-5);    }    public void testSinhNaN() {        assertTrue(Double.isNaN(MathUtils.sinh(Double.NaN)));    }    public void testSubAndCheck() {        int big = Integer.MAX_VALUE;        int bigNeg = Integer.MIN_VALUE;        assertEquals(big, MathUtils.subAndCheck(big, 0));        assertEquals(bigNeg + 1, MathUtils.subAndCheck(bigNeg, -1));        assertEquals(-1, MathUtils.subAndCheck(bigNeg, -big));        try {            MathUtils.subAndCheck(big, -1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {        }        try {            MathUtils.subAndCheck(bigNeg, 1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {        }    }    public void testSubAndCheckErrorMessage() {        int big = Integer.MAX_VALUE;        try {            MathUtils.subAndCheck(big, -1);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            assertTrue(ex.getMessage().length() > 1);        }    }    public void testSubAndCheckLong() {        long max = Long.MAX_VALUE;        long min = Long.MIN_VALUE;        assertEquals(max, MathUtils.subAndCheck(max, 0));        assertEquals(min, MathUtils.subAndCheck(min, 0));        assertEquals(-max, MathUtils.subAndCheck(0, max));        assertEquals(min + 1, MathUtils.subAndCheck(min, -1));        // min == -1-max        assertEquals(-1, MathUtils.subAndCheck(-max - 1, -max));        assertEquals(max, MathUtils.subAndCheck(-1, -1 - max));        testSubAndCheckLongFailure(0L, min);        testSubAndCheckLongFailure(max, -1L);        testSubAndCheckLongFailure(min, 1L);    }    private void testSubAndCheckLongFailure(long a, long b) {        try {            MathUtils.subAndCheck(a, b);            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // success        }    }    public void testPow() {        assertEquals(1801088541, MathUtils.pow(21, 7));        assertEquals(1, MathUtils.pow(21, 0));        try {            MathUtils.pow(21, -7);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected behavior        }        assertEquals(1801088541, MathUtils.pow(21, 7l));        assertEquals(1, MathUtils.pow(21, 0l));        try {            MathUtils.pow(21, -7l);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected behavior        }        assertEquals(1801088541l, MathUtils.pow(21l, 7));        assertEquals(1l, MathUtils.pow(21l, 0));        try {            MathUtils.pow(21l, -7);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected behavior        }        assertEquals(1801088541l, MathUtils.pow(21l, 7l));        assertEquals(1l, MathUtils.pow(21l, 0l));        try {            MathUtils.pow(21l, -7l);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected behavior        }        BigInteger twentyOne = BigInteger.valueOf(21l);        assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, 7));        assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, 0));        try {            MathUtils.pow(twentyOne, -7);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected behavior        }        assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, 7l));        assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, 0l));        try {            MathUtils.pow(twentyOne, -7l);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected behavior        }        assertEquals(BigInteger.valueOf(1801088541l), MathUtils.pow(twentyOne, BigInteger.valueOf(7l)));        assertEquals(BigInteger.ONE, MathUtils.pow(twentyOne, BigInteger.ZERO));        try {            MathUtils.pow(twentyOne, BigInteger.valueOf(-7l));            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected behavior        }        BigInteger bigOne =            new BigInteger("1543786922199448028351389769265814882661837148" +                           "4763915343722775611762713982220306372888519211" +                           "560905579993523402015636025177602059044911261");        assertEquals(bigOne, MathUtils.pow(twentyOne, 103));        assertEquals(bigOne, MathUtils.pow(twentyOne, 103l));        assertEquals(bigOne, MathUtils.pow(twentyOne, BigInteger.valueOf(103l)));    }    public void testL1DistanceDouble() {        double[] p1 = { 2.5,  0.0 };        double[] p2 = { -0.5, 4.0 };        assertEquals(7.0, MathUtils.distance1(p1, p2));    }    public void testL1DistanceInt() {        int[] p1 = { 3, 0 };        int[] p2 = { 0, 4 };        assertEquals(7, MathUtils.distance1(p1, p2));    }    public void testL2DistanceDouble() {        double[] p1 = { 2.5,  0.0 };        double[] p2 = { -0.5, 4.0 };        assertEquals(5.0, MathUtils.distance(p1, p2));    }    public void testL2DistanceInt() {        int[] p1 = { 3, 0 };        int[] p2 = { 0, 4 };        assertEquals(5.0, MathUtils.distance(p1, p2));    }    public void testLInfDistanceDouble() {        double[] p1 = { 2.5,  0.0 };        double[] p2 = { -0.5, 4.0 };        assertEquals(4.0, MathUtils.distanceInf(p1, p2));    }    public void testLInfDistanceInt() {        int[] p1 = { 3, 0 };        int[] p2 = { 0, 4 };        assertEquals(4, MathUtils.distanceInf(p1, p2));    }    public void testCheckOrder() {        MathUtils.checkOrder(new double[] {-15, -5.5, -1, 2, 15},                             MathUtils.OrderDirection.INCREASING, true);        MathUtils.checkOrder(new double[] {-15, -5.5, -1, 2, 2},                             MathUtils.OrderDirection.INCREASING, false);        MathUtils.checkOrder(new double[] {3, -5.5, -11, -27.5},                             MathUtils.OrderDirection.DECREASING, true);        MathUtils.checkOrder(new double[] {3, 0, 0, -5.5, -11, -27.5},                             MathUtils.OrderDirection.DECREASING, false);        try {            MathUtils.checkOrder(new double[] {-15, -5.5, -1, -1, 2, 15},                                 MathUtils.OrderDirection.INCREASING, true);            fail("an exception should have been thrown");        } catch (NonMonotonousSequenceException e) {            // Expected        }        try {            MathUtils.checkOrder(new double[] {-15, -5.5, -1, -2, 2},                                 MathUtils.OrderDirection.INCREASING, false);            fail("an exception should have been thrown");        } catch (NonMonotonousSequenceException e) {            // Expected        }        try {            MathUtils.checkOrder(new double[] {3, 3, -5.5, -11, -27.5},                                 MathUtils.OrderDirection.DECREASING, true);            fail("an exception should have been thrown");        } catch (NonMonotonousSequenceException e) {            // Expected        }        try {            MathUtils.checkOrder(new double[] {3, -1, 0, -5.5, -11, -27.5},                                 MathUtils.OrderDirection.DECREASING, false);            fail("an exception should have been thrown");        } catch (NonMonotonousSequenceException e) {            // Expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import java.math.BigDecimal;import junit.framework.TestCase;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.exception.NullArgumentException;/** * @version $Revision$ $Date$ */public class DefaultTransformerTest extends TestCase {    /**     *     */    public void testTransformDouble() throws Exception {        double expected = 1.0;        Double input = Double.valueOf(expected);        DefaultTransformer t = new DefaultTransformer();        assertEquals(expected, t.transform(input), 1.0e-4);    }    /**     *     */    public void testTransformNull() throws Exception {        DefaultTransformer t = new DefaultTransformer();        try {            t.transform(null);            fail("Expecting NullArgumentException");        } catch (NullArgumentException e) {            // expected        }    }    /**     *     */    public void testTransformInteger() throws Exception {        double expected = 1.0;        Integer input = Integer.valueOf(1);        DefaultTransformer t = new DefaultTransformer();        assertEquals(expected, t.transform(input), 1.0e-4);    }    /**     *     */    public void testTransformBigDecimal() throws Exception {        double expected = 1.0;        BigDecimal input = new BigDecimal("1.0");        DefaultTransformer t = new DefaultTransformer();        assertEquals(expected, t.transform(input), 1.0e-4);    }    /**     *     */    public void testTransformString() throws Exception {        double expected = 1.0;        String input = "1.0";        DefaultTransformer t = new DefaultTransformer();        assertEquals(expected, t.transform(input), 1.0e-4);    }    /**     *     */    public void testTransformObject(){        Boolean input = Boolean.TRUE;        DefaultTransformer t = new DefaultTransformer();        try {            t.transform(input);            fail("Expecting MathException");        } catch (MathException e) {            // expected        }    }    public void testSerial() {        assertEquals(new DefaultTransformer(), TestUtils.serializeAndRecover(new DefaultTransformer()));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.dfp.Dfp;import org.apache.commons.math.dfp.DfpField;import org.apache.commons.math.dfp.DfpMath;import org.apache.commons.math.random.MersenneTwister;import org.apache.commons.math.random.RandomGenerator;import org.junit.Assert;import org.junit.Before;import org.junit.Ignore;import org.junit.Test;public class FastMathTest {    private final double MAX_ERROR_ULP = 0.51;    private final int NUMBER_OF_TRIALS = 1000;    private DfpField field;    private RandomGenerator generator;    @Before    public void setUp() {        field = new DfpField(40);        generator = new MersenneTwister(6176597458463500194l);    }    @Test    public void testMinMaxDouble() {        double[][] pairs = {            { -50.0, 50.0 },            {  Double.POSITIVE_INFINITY, 1.0 },            {  Double.NEGATIVE_INFINITY, 1.0 },            {  Double.NaN, 1.0 },            {  Double.POSITIVE_INFINITY, 0.0 },            {  Double.NEGATIVE_INFINITY, 0.0 },            {  Double.NaN, 0.0 },            {  Double.NaN, Double.NEGATIVE_INFINITY },            {  Double.NaN, Double.POSITIVE_INFINITY },            { MathUtils.SAFE_MIN, MathUtils.EPSILON }        };        for (double[] pair : pairs) {            Assert.assertEquals("min(" + pair[0] + ", " + pair[1] + ")",                                Math.min(pair[0], pair[1]),                                FastMath.min(pair[0], pair[1]),                                MathUtils.EPSILON);            Assert.assertEquals("min(" + pair[1] + ", " + pair[0] + ")",                                Math.min(pair[1], pair[0]),                                FastMath.min(pair[1], pair[0]),                                MathUtils.EPSILON);            Assert.assertEquals("max(" + pair[0] + ", " + pair[1] + ")",                                Math.max(pair[0], pair[1]),                                FastMath.max(pair[0], pair[1]),                                MathUtils.EPSILON);            Assert.assertEquals("max(" + pair[1] + ", " + pair[0] + ")",                                Math.max(pair[1], pair[0]),                                FastMath.max(pair[1], pair[0]),                                MathUtils.EPSILON);        }    }    @Test    public void testMinMaxFloat() {        double[][] pairs = {            { -50.0, 50.0 },            {  Float.POSITIVE_INFINITY, 1.0 },            {  Float.NEGATIVE_INFINITY, 1.0 },            {  Float.NaN, 1.0 },            {  Float.POSITIVE_INFINITY, 0.0 },            {  Float.NEGATIVE_INFINITY, 0.0 },            {  Float.NaN, 0.0 },            {  Float.NaN, Float.NEGATIVE_INFINITY },            {  Float.NaN, Float.POSITIVE_INFINITY }        };        for (double[] pair : pairs) {            Assert.assertEquals("min(" + pair[0] + ", " + pair[1] + ")",                                Math.min(pair[0], pair[1]),                                FastMath.min(pair[0], pair[1]),                                MathUtils.EPSILON);            Assert.assertEquals("min(" + pair[1] + ", " + pair[0] + ")",                                Math.min(pair[1], pair[0]),                                FastMath.min(pair[1], pair[0]),                                MathUtils.EPSILON);            Assert.assertEquals("max(" + pair[0] + ", " + pair[1] + ")",                                Math.max(pair[0], pair[1]),                                FastMath.max(pair[0], pair[1]),                                MathUtils.EPSILON);            Assert.assertEquals("max(" + pair[1] + ", " + pair[0] + ")",                                Math.max(pair[1], pair[0]),                                FastMath.max(pair[1], pair[0]),                                MathUtils.EPSILON);        }    }    @Test    public void testConstants() {        Assert.assertEquals(Math.PI, FastMath.PI, 1.0e-20);        Assert.assertEquals(Math.E, FastMath.E, 1.0e-20);    }    @Test    public void testAtan2() {        double y1 = 1.2713504628280707e10;        double x1 = -5.674940885228782e-10;        Assert.assertEquals(Math.atan2(y1, x1), FastMath.atan2(y1, x1), 2 * MathUtils.EPSILON);        double y2 = 0.0;        double x2 = Double.POSITIVE_INFINITY;        Assert.assertEquals(Math.atan2(y2, x2), FastMath.atan2(y2, x2), MathUtils.SAFE_MIN);    }    @Test    public void testHyperbolic() {        double maxErr = 0;        for (double x = -30; x < 30; x += 0.001) {            double tst = FastMath.sinh(x);            double ref = Math.sinh(x);            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));        }        Assert.assertEquals(0, maxErr, 2);        maxErr = 0;        for (double x = -30; x < 30; x += 0.001) {            double tst = FastMath.cosh(x);            double ref = Math.cosh(x);            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));        }        Assert.assertEquals(0, maxErr, 2);        maxErr = 0;        for (double x = -0.5; x < 0.5; x += 0.001) {            double tst = FastMath.tanh(x);            double ref = Math.tanh(x);            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));        }        Assert.assertEquals(0, maxErr, 4);    }    @Test    public void testHyperbolicInverses() {        double maxErr = 0;        for (double x = -30; x < 30; x += 0.01) {            maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.sinh(FastMath.asinh(x))) / (2 * FastMath.ulp(x)));        }        Assert.assertEquals(0, maxErr, 3);        maxErr = 0;        for (double x = 1; x < 30; x += 0.01) {            maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.cosh(FastMath.acosh(x))) / (2 * FastMath.ulp(x)));        }        Assert.assertEquals(0, maxErr, 2);        maxErr = 0;        for (double x = -1 + MathUtils.EPSILON; x < 1 - MathUtils.EPSILON; x += 0.0001) {            maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.tanh(FastMath.atanh(x))) / (2 * FastMath.ulp(x)));        }        Assert.assertEquals(0, maxErr, 2);    }    @Test    public void testLogAccuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            double x = Math.exp(generator.nextDouble() * 1416.0 - 708.0) * generator.nextDouble();            // double x = generator.nextDouble()*2.0;            double tst = FastMath.log(x);            double ref = DfpMath.log(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0.0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double                                          .doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("log() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testLog10Accuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            double x = Math.exp(generator.nextDouble() * 1416.0 - 708.0) * generator.nextDouble();            // double x = generator.nextDouble()*2.0;            double tst = FastMath.log10(x);            double ref = DfpMath.log(field.newDfp(x)).divide(DfpMath.log(field.newDfp("10"))).toDouble();            double err = (tst - ref) / ref;            if (err != 0.0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x)).divide(DfpMath.log(field.newDfp("10")))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("log10() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testLog1pAccuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            double x = Math.exp(generator.nextDouble() * 10.0 - 5.0) * generator.nextDouble();            // double x = generator.nextDouble()*2.0;            double tst = FastMath.log1p(x);            double ref = DfpMath.log(field.newDfp(x).add(field.getOne())).toDouble();            double err = (tst - ref) / ref;            if (err != 0.0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x).add(field.getOne()))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("log1p() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testLogSpecialCases() {        double x;        x = FastMath.log(0.0);        if (x != Double.NEGATIVE_INFINITY)            throw new RuntimeException("Log of zero should be -Inf");        x = FastMath.log(-0.0);        if (x != Double.NEGATIVE_INFINITY)            throw new RuntimeException("Log of zero should be -Inf");        x = FastMath.log(Double.NaN);        if (x == x)            throw new RuntimeException("Log of NaN should be NaN");        x = FastMath.log(-1.0);        if (x == x)            throw new RuntimeException("Log of negative number should be NaN");        x = FastMath.log(Double.MIN_VALUE);        if (x != -744.4400719213812)            throw new RuntimeException(                                       "Log of Double.MIN_VALUE should be -744.4400719213812");        x = FastMath.log(-1.0);        if (x == x)            throw new RuntimeException("Log of negative number should be NaN");        x = FastMath.log(Double.POSITIVE_INFINITY);        if (x != Double.POSITIVE_INFINITY)            throw new RuntimeException("Log of infinity should be infinity");    }    @Test    public void testExpSpecialCases() {        double x;        /* Smallest value that will round up to Double.MIN_VALUE */        x = FastMath.exp(-745.1332191019411);        if (x != Double.MIN_VALUE)            throw new RuntimeException(                                       "exp(-745.1332191019411) should be Double.MIN_VALUE");        x = FastMath.exp(-745.1332191019412);        if (x != 0.0)            throw new RuntimeException("exp(-745.1332191019412) should be 0.0");        x = FastMath.exp(Double.NaN);        if (x == x)            throw new RuntimeException("exp of NaN should be NaN");        x = FastMath.exp(Double.POSITIVE_INFINITY);        if (x != Double.POSITIVE_INFINITY)            throw new RuntimeException("exp of infinity should be infinity");        x = FastMath.exp(Double.NEGATIVE_INFINITY);        if (x != 0.0)            throw new RuntimeException("exp of -infinity should be 0.0");        x = FastMath.exp(1.0);        if (x != Math.E)            throw new RuntimeException("exp(1) should be Math.E");    }    @Test    public void testPowSpecialCases() {        double x;        x = FastMath.pow(-1.0, 0.0);        if (x != 1.0)            throw new RuntimeException("pow(x, 0) should be 1.0");        x = FastMath.pow(-1.0, -0.0);        if (x != 1.0)            throw new RuntimeException("pow(x, -0) should be 1.0");        x = FastMath.pow(Math.PI, 1.0);        if (x != Math.PI)            throw new RuntimeException("pow(PI, 1.0) should be PI");        x = FastMath.pow(-Math.PI, 1.0);        if (x != -Math.PI)            throw new RuntimeException("pow(-PI, 1.0) should be PI");        x = FastMath.pow(Math.PI, Double.NaN);        if (x == x)            throw new RuntimeException("pow(PI, NaN) should be NaN");        x = FastMath.pow(Double.NaN, Math.PI);        if (x == x)            throw new RuntimeException("pow(NaN, PI) should be NaN");        x = FastMath.pow(2.0, Double.POSITIVE_INFINITY);        if (x != Double.POSITIVE_INFINITY)            throw new RuntimeException("pow(2.0, Infinity) should be Infinity");        x = FastMath.pow(0.5, Double.NEGATIVE_INFINITY);        if (x != Double.POSITIVE_INFINITY)            throw new RuntimeException("pow(0.5, -Infinity) should be Infinity");        x = FastMath.pow(0.5, Double.POSITIVE_INFINITY);        if (x != 0.0)            throw new RuntimeException("pow(0.5, Infinity) should be 0.0");        x = FastMath.pow(2.0, Double.NEGATIVE_INFINITY);        if (x != 0.0)            throw new RuntimeException("pow(2.0, -Infinity) should be 0.0");        x = FastMath.pow(0.0, 0.5);        if (x != 0.0)            throw new RuntimeException("pow(0.0, 0.5) should be 0.0");        x = FastMath.pow(Double.POSITIVE_INFINITY, -0.5);        if (x != 0.0)            throw new RuntimeException("pow(Inf, -0.5) should be 0.0");        x = FastMath.pow(0.0, -0.5);        if (x != Double.POSITIVE_INFINITY)            throw new RuntimeException("pow(0.0, -0.5) should be Inf");        x = FastMath.pow(Double.POSITIVE_INFINITY, 0.5);        if (x != Double.POSITIVE_INFINITY)            throw new RuntimeException("pow(Inf, 0.5) should be Inf");        x = FastMath.pow(-0.0, -3.0);        if (x != Double.NEGATIVE_INFINITY)            throw new RuntimeException("pow(-0.0, -3.0) should be -Inf");        x = FastMath.pow(Double.NEGATIVE_INFINITY, 3.0);        if (x != Double.NEGATIVE_INFINITY)            throw new RuntimeException("pow(-Inf, -3.0) should be -Inf");        x = FastMath.pow(-0.0, -3.5);        if (x != Double.POSITIVE_INFINITY)            throw new RuntimeException("pow(-0.0, -3.5) should be Inf");        x = FastMath.pow(Double.POSITIVE_INFINITY, 3.5);        if (x != Double.POSITIVE_INFINITY)            throw new RuntimeException("pow(Inf, 3.5) should be Inf");        x = FastMath.pow(-2.0, 3.0);        if (x != -8.0)            throw new RuntimeException("pow(-2.0, 3.0) should be -8.0");        x = FastMath.pow(-2.0, 3.5);        if (x == x)            throw new RuntimeException("pow(-2.0, 3.5) should be NaN");    }    @Test    public void testAtan2SpecialCases() {        double x;        x = FastMath.atan2(Double.NaN, 0.0);        if (x == x)            throw new RuntimeException("atan2(NaN, 0.0) should be NaN");        x = FastMath.atan2(0.0, Double.NaN);        if (x == x)            throw new RuntimeException("atan2(0.0, NaN) should be NaN");        x = FastMath.atan2(0.0, 0.0);        if (x != 0.0 || 1 / x != Double.POSITIVE_INFINITY)            throw new RuntimeException("atan2(0.0, 0.0) should be 0.0");        x = FastMath.atan2(0.0, 0.001);        if (x != 0.0 || 1 / x != Double.POSITIVE_INFINITY)            throw new RuntimeException("atan2(0.0, 0.001) should be 0.0");        x = FastMath.atan2(0.1, Double.POSITIVE_INFINITY);        if (x != 0.0 || 1 / x != Double.POSITIVE_INFINITY)            throw new RuntimeException("atan2(0.1, +Inf) should be 0.0");        x = FastMath.atan2(-0.0, 0.0);        if (x != 0.0 || 1 / x != Double.NEGATIVE_INFINITY)            throw new RuntimeException("atan2(-0.0, 0.0) should be -0.0");        x = FastMath.atan2(-0.0, 0.001);        if (x != 0.0 || 1 / x != Double.NEGATIVE_INFINITY)            throw new RuntimeException("atan2(-0.0, 0.001) should be -0.0");        x = FastMath.atan2(-0.1, Double.POSITIVE_INFINITY);        if (x != 0.0 || 1 / x != Double.NEGATIVE_INFINITY)            throw new RuntimeException("atan2(-0.0, +Inf) should be -0.0");        x = FastMath.atan2(0.0, -0.0);        if (x != Math.PI)            throw new RuntimeException("atan2(0.0, -0.0) should be PI");        x = FastMath.atan2(0.1, Double.NEGATIVE_INFINITY);        if (x != Math.PI)            throw new RuntimeException("atan2(0.1, -Inf) should be PI");        x = FastMath.atan2(-0.0, -0.0);        if (x != -Math.PI)            throw new RuntimeException("atan2(-0.0, -0.0) should be -PI");        x = FastMath.atan2(-0.1, Double.NEGATIVE_INFINITY);        if (x != -Math.PI)            throw new RuntimeException("atan2(0.1, -Inf) should be -PI");        x = FastMath.atan2(0.1, 0.0);        if (x != Math.PI / 2)            throw new RuntimeException("atan2(0.1, 0.0) should be PI/2");        x = FastMath.atan2(0.1, -0.0);        if (x != Math.PI / 2)            throw new RuntimeException("atan2(0.1, -0.0) should be PI/2");        x = FastMath.atan2(Double.POSITIVE_INFINITY, 0.1);        if (x != Math.PI / 2)            throw new RuntimeException("atan2(Inf, 0.1) should be PI/2");        x = FastMath.atan2(Double.POSITIVE_INFINITY, -0.1);        if (x != Math.PI / 2)            throw new RuntimeException("atan2(Inf, -0.1) should be PI/2");        x = FastMath.atan2(-0.1, 0.0);        if (x != -Math.PI / 2)            throw new RuntimeException("atan2(-0.1, 0.0) should be -PI/2");        x = FastMath.atan2(-0.1, -0.0);        if (x != -Math.PI / 2)            throw new RuntimeException("atan2(-0.1, -0.0) should be -PI/2");        x = FastMath.atan2(Double.NEGATIVE_INFINITY, 0.1);        if (x != -Math.PI / 2)            throw new RuntimeException("atan2(-Inf, 0.1) should be -PI/2");        x = FastMath.atan2(Double.NEGATIVE_INFINITY, -0.1);        if (x != -Math.PI / 2)            throw new RuntimeException("atan2(-Inf, -0.1) should be -PI/2");        x = FastMath.atan2(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);        if (x != Math.PI / 4)            throw new RuntimeException("atan2(Inf, Inf) should be PI/4");        x = FastMath.atan2(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY);        if (x != Math.PI * 3.0 / 4.0)            throw new RuntimeException("atan2(Inf, -Inf) should be PI * 3/4");        x = FastMath.atan2(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);        if (x != -Math.PI / 4)            throw new RuntimeException("atan2(-Inf, Inf) should be -PI/4");        x = FastMath.atan2(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);        if (x != -Math.PI * 3.0 / 4.0)            throw new RuntimeException("atan2(-Inf, -Inf) should be -PI * 3/4");    }    @Test    public void testPowAccuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            double x = (generator.nextDouble() * 2.0 + 0.25);            double y = (generator.nextDouble() * 1200.0 - 600.0) * generator.nextDouble();            /*             * double x = FastMath.floor(generator.nextDouble()*1024.0 - 512.0); double             * y; if (x != 0) y = FastMath.floor(512.0 / FastMath.abs(x)); else             * y = generator.nextDouble()*1200.0; y = y - y/2; x = FastMath.pow(2.0, x) *             * generator.nextDouble(); y = y * generator.nextDouble();             */            // double x = generator.nextDouble()*2.0;            double tst = FastMath.pow(x, y);            double ref = DfpMath.pow(field.newDfp(x), field.newDfp(y)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double                                          .doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.pow(field.newDfp(x), field.newDfp(y))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + y + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("pow() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testExpAccuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            /* double x = 1.0 + i/1024.0/2.0; */            double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();            // double x = (generator.nextDouble() * 20.0) - 10.0;            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();            /* double x = 3.0 / 512.0 * i - 3.0; */            double tst = FastMath.exp(x);            double ref = DfpMath.exp(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("exp() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testSinAccuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            /* double x = 1.0 + i/1024.0/2.0; */            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();            double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) *                       Math.pow(2, 21) * generator.nextDouble();            // double x = (generator.nextDouble() * 20.0) - 10.0;            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();            /* double x = 3.0 / 512.0 * i - 3.0; */            double tst = FastMath.sin(x);            double ref = DfpMath.sin(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.sin(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("sin() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testCosAccuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            /* double x = 1.0 + i/1024.0/2.0; */            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();            double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) *                       Math.pow(2, 21) * generator.nextDouble();            // double x = (generator.nextDouble() * 20.0) - 10.0;            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();            /* double x = 3.0 / 512.0 * i - 3.0; */            double tst = FastMath.cos(x);            double ref = DfpMath.cos(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.cos(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("cos() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testTanAccuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            /* double x = 1.0 + i/1024.0/2.0; */            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();            double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) *                       Math.pow(2, 12) * generator.nextDouble();            // double x = (generator.nextDouble() * 20.0) - 10.0;            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();            /* double x = 3.0 / 512.0 * i - 3.0; */            double tst = FastMath.tan(x);            double ref = DfpMath.tan(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.tan(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("tan() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testAtanAccuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            /* double x = 1.0 + i/1024.0/2.0; */            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();            // double x = ((generator.nextDouble() * Math.PI) - Math.PI/2.0) *            // generator.nextDouble();            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble();            // double x = (generator.nextDouble() * 20.0) - 10.0;            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();            /* double x = 3.0 / 512.0 * i - 3.0; */            double tst = FastMath.atan(x);            double ref = DfpMath.atan(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.atan(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("atan() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testAtan2Accuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            /* double x = 1.0 + i/1024.0/2.0; */            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();            double x = generator.nextDouble() - 0.5;            double y = generator.nextDouble() - 0.5;            // double x = (generator.nextDouble() * 20.0) - 10.0;            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();            /* double x = 3.0 / 512.0 * i - 3.0; */            double tst = FastMath.atan2(y, x);            Dfp refdfp = DfpMath.atan(field.newDfp(y)                .divide(field.newDfp(x)));            /* Make adjustments for sign */            if (x < 0.0) {                if (y > 0.0)                    refdfp = field.getPi().add(refdfp);                else                    refdfp = refdfp.subtract(field.getPi());            }            double ref = refdfp.toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double                                          .doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(refdfp).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + y + "\t" + tst + "\t" + ref + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("atan2() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testExpm1Accuracy() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            /* double x = 1.0 + i/1024.0/2.0; */            // double x = (generator.nextDouble() * 20.0) - 10.0;            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble();            /* double x = 3.0 / 512.0 * i - 3.0; */            double tst = FastMath.expm1(x);            double ref = DfpMath.exp(field.newDfp(x)).subtract(field.getOne()).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double                                          .doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("expm1() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testAsinAccuracy() {        double maxerrulp = 0.0;        for (int i=0; i<10000; i++) {            double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();             double tst = FastMath.asin(x);            double ref = DfpMath.asin(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.asin(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();                //System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("asin() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testAcosAccuracy() {        double maxerrulp = 0.0;        for (int i=0; i<10000; i++) {            double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();             double tst = FastMath.acos(x);            double ref = DfpMath.acos(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.acos(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();                //System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("acos() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testCbrtAccuracy() {        double maxerrulp = 0.0;        for (int i=0; i<10000; i++) {            double x = ((generator.nextDouble() * 200.0) - 100.0) * generator.nextDouble();             double tst = FastMath.cbrt(x);            double ref = cbrt(field.newDfp(x)).toDouble();            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(cbrt(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();                 //System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp);                 maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("cbrt() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    private Dfp cbrt(Dfp x) {      boolean negative=false;      if (x.lessThan(field.getZero())) {          negative = true;          x = x.negate();      }      Dfp y = DfpMath.pow(x, field.getOne().divide(3));      if (negative) {          y = y.negate();      }      return y;    }    @Test    public void testToDegrees() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            double x = generator.nextDouble();            double tst = field.newDfp(x).multiply(180).divide(field.getPi()).toDouble();            double ref = FastMath.toDegrees(x);            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("toDegrees() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Test    public void testToRadians() {        double maxerrulp = 0.0;        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {            double x = generator.nextDouble();            double tst = field.newDfp(x).multiply(field.getPi()).divide(180).toDouble();            double ref = FastMath.toRadians(x);            double err = (tst - ref) / ref;            if (err != 0) {                double ulp = Math.abs(ref -                                      Double.longBitsToDouble((Double                                          .doubleToLongBits(ref) ^ 1)));                double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble();//                System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp);                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));            }        }        Assert.assertTrue("toRadians() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP);    }    @Ignore    @Test    public void testPerformance() {        final int numberOfRuns = 10000000;        for (int j = 0; j < 10; j++) {            double x = 0;            long time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += StrictMath.log(Math.PI + i/* 1.0 + i/1e9 */);            time = System.currentTimeMillis() - time;            System.out.print("StrictMath.log " + time + "\t" + x + "\t");            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += FastMath.log(Math.PI + i/* 1.0 + i/1e9 */);            time = System.currentTimeMillis() - time;            System.out.println("FastMath.log " + time + "\t" + x);            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += StrictMath.pow(Math.PI + i / 1e6, i / 1e6);            time = System.currentTimeMillis() - time;            System.out.print("StrictMath.pow " + time + "\t" + x + "\t");            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += FastMath.pow(Math.PI + i / 1e6, i / 1e6);            time = System.currentTimeMillis() - time;            System.out.println("FastMath.pow " + time + "\t" + x);            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += StrictMath.exp(i / 1000000.0);            time = System.currentTimeMillis() - time;            System.out.print("StrictMath.exp " + time + "\t" + x + "\t");            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += FastMath.exp(i / 1000000.0);            time = System.currentTimeMillis() - time;            System.out.println("FastMath.exp " + time + "\t" + x);            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += StrictMath.sin(i / 1000000.0);            time = System.currentTimeMillis() - time;            System.out.print("StrictMath.sin " + time + "\t" + x + "\t");            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += FastMath.sin(i / 1000000.0);            time = System.currentTimeMillis() - time;            System.out.println("FastMath.sin " + time + "\t" + x);            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += StrictMath.asin(i / 10000000.0);            time = System.currentTimeMillis() - time;            System.out.print("StrictMath.asin " + time + "\t" + x + "\t");            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += FastMath.asin(i / 10000000.0);            time = System.currentTimeMillis() - time;            System.out.println("FastMath.asin " + time + "\t" + x);            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += StrictMath.cos(i / 1000000.0);            time = System.currentTimeMillis() - time;            System.out.print("StrictMath.cos " + time + "\t" + x + "\t");            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += FastMath.cos(i / 1000000.0);            time = System.currentTimeMillis() - time;            System.out.println("FastMath.cos " + time + "\t" + x);            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += StrictMath.acos(i / 10000000.0);            time = System.currentTimeMillis() - time;            System.out.print("StrictMath.acos " + time + "\t" + x + "\t");            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += FastMath.acos(i / 10000000.0);            time = System.currentTimeMillis() - time;            System.out.println("FastMath.acos " + time + "\t" + x);            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += StrictMath.tan(i / 1000000.0);            time = System.currentTimeMillis() - time;            System.out.print("StrictMath.tan " + time + "\t" + x + "\t");            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += FastMath.tan(i / 1000000.0);            time = System.currentTimeMillis() - time;            System.out.println("FastMath.tan " + time + "\t" + x);            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += StrictMath.atan(i / 1000000.0);            time = System.currentTimeMillis() - time;            System.out.print("StrictMath.atan " + time + "\t" + x + "\t");            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += FastMath.atan(i / 1000000.0);            time = System.currentTimeMillis() - time;            System.out.println("FastMath.atan " + time + "\t" + x);            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += StrictMath.cbrt(i / 1000000.0);            time = System.currentTimeMillis() - time;            System.out.print("StrictMath.cbrt " + time + "\t" + x + "\t");            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += FastMath.cbrt(i / 1000000.0);            time = System.currentTimeMillis() - time;            System.out.println("FastMath.cbrt " + time + "\t" + x);           x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += StrictMath.expm1(-i / 100000.0);            time = System.currentTimeMillis() - time;            System.out.print("StrictMath.expm1 " + time + "\t" + x + "\t");            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += FastMath.expm1(-i / 100000.0);            time = System.currentTimeMillis() - time;            System.out.println("FastMath.expm1 " + time + "\t" + x);            x = 0;            time = System.currentTimeMillis();            for (int i = 0; i < numberOfRuns; i++)                x += FastMath.expm1(-i / 100000.0);            time = System.currentTimeMillis() - time;            System.out.println("FastMath.expm1 " + time + "\t" + x);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.OutOfRangeException;import org.apache.commons.math.exception.NotStrictlyPositiveException;import org.junit.Assert;import org.junit.Test;/** * */public class MultidimensionalCounterTest {    @Test    public void testPreconditions() {        MultidimensionalCounter c;        try {            c = new MultidimensionalCounter(0, 1);            Assert.fail("NotStrictlyPositiveException expected");        } catch (NotStrictlyPositiveException e) {            // Expected.        }        try {            c = new MultidimensionalCounter(2, 0);            Assert.fail("NotStrictlyPositiveException expected");        } catch (NotStrictlyPositiveException e) {            // Expected.        }        try {            c = new MultidimensionalCounter(-1, 1);            Assert.fail("NotStrictlyPositiveException expected");        } catch (NotStrictlyPositiveException e) {            // Expected.        }        c = new MultidimensionalCounter(2, 3);        try {            c.getCount(1, 1, 1);            Assert.fail("DimensionMismatchException expected");        } catch (DimensionMismatchException e) {            // Expected.        }        try {            c.getCount(3, 1);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException e) {            // Expected.        }        try {            c.getCount(0, -1);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException e) {            // Expected.        }        try {            c.getCounts(-1);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException e) {            // Expected.        }        try {            c.getCounts(6);            Assert.fail("OutOfRangeException expected");        } catch (OutOfRangeException e) {            // Expected.        }    }    @Test    public void testIteratorPreconditions() {        MultidimensionalCounter.Iterator iter = (new MultidimensionalCounter(2, 3)).iterator();        try {            iter.getCount(-1);            Assert.fail("IndexOutOfBoundsException expected");        } catch (IndexOutOfBoundsException e) {            // Expected.        }        try {            iter.getCount(2);            Assert.fail("IndexOutOfBoundsException expected");        } catch (IndexOutOfBoundsException e) {            // Expected.        }    }    @Test    public void testMulti2UniConversion() {        final MultidimensionalCounter c = new MultidimensionalCounter(2, 4, 5);        Assert.assertEquals(c.getCount(1, 2, 3), 33);    }    @Test    public void testAccessors() {        final int[] originalSize = new int[] {2, 6, 5};        final MultidimensionalCounter c = new MultidimensionalCounter(originalSize);        final int nDim = c.getDimension();        Assert.assertEquals(nDim, originalSize.length);        final int[] size = c.getSizes();        for (int i = 0; i < nDim; i++) {            Assert.assertEquals(originalSize[i], size[i]);        }    }    @Test    public void testIterationConsistency() {        final MultidimensionalCounter c = new MultidimensionalCounter(2, 3, 2);        final int[][] expected = new int[][] {            { 0, 0, 0 },            { 0, 0, 1 },            { 0, 1, 0 },            { 0, 1, 1 },            { 0, 2, 0 },            { 0, 2, 1 },            { 1, 0, 0 },            { 1, 0, 1 },            { 1, 1, 0 },            { 1, 1, 1 },            { 1, 2, 0 },            { 1, 2, 1 }        };        final int totalSize = c.getSize();        final int nDim = c.getDimension();        final MultidimensionalCounter.Iterator iter = c.iterator();        for (int i = 0; i < totalSize; i++) {            if (!iter.hasNext()) {                Assert.fail("Too short");            }            final int uniDimIndex = iter.next();            Assert.assertEquals("Wrong iteration at " + i, i, uniDimIndex);            for (int dimIndex = 0; dimIndex < nDim; dimIndex++) {                Assert.assertEquals("Wrong multidimensional index for [" + i + "][" + dimIndex + "]",                                    expected[i][dimIndex], iter.getCount(dimIndex));            }            Assert.assertEquals("Wrong unidimensional index for [" + i + "]",                                c.getCount(expected[i]), uniDimIndex);            final int[] indices = c.getCounts(uniDimIndex);            for (int dimIndex = 0; dimIndex < nDim; dimIndex++) {                Assert.assertEquals("Wrong multidimensional index for [" + i + "][" + dimIndex + "]",                                    expected[i][dimIndex], indices[dimIndex]);            }        }        if (iter.hasNext()) {            Assert.fail("Too long");        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import org.apache.commons.math.TestUtils;import org.junit.Test;public class BigRealFieldTest {    @Test    public void testZero() {        assertEquals(BigReal.ZERO, BigRealField.getInstance().getZero());    }    @Test    public void testOne() {        assertEquals(BigReal.ONE, BigRealField.getInstance().getOne());    }    @Test    public void testSerial() {        // deserializing the singleton should give the singleton itself back        BigRealField field = BigRealField.getInstance();        assertTrue(field == TestUtils.serializeAndRecover(field));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import java.util.ConcurrentModificationException;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.NoSuchElementException;import java.util.Random;import java.util.Set;import junit.framework.TestCase;/** * Test cases for the {@link OpenIntToDoubleHashMap}. */public class OpenIntToDoubleHashMapTest extends TestCase {    private Map<Integer, Double> javaMap = new HashMap<Integer, Double>();    @Override    protected void setUp() throws Exception {        javaMap.put(50, 100.0);        javaMap.put(75, 75.0);        javaMap.put(25, 500.0);        javaMap.put(Integer.MAX_VALUE, Double.MAX_VALUE);        javaMap.put(0, -1.0);        javaMap.put(1, 0.0);        javaMap.put(33, -0.1);        javaMap.put(23234234, -242343.0);        javaMap.put(23321, Double.MIN_VALUE);        javaMap.put(-4444, 332.0);        javaMap.put(-1, -2323.0);        javaMap.put(Integer.MIN_VALUE, 44.0);        /* Add a few more to cause the table to rehash */        javaMap.putAll(generate());    }    private Map<Integer, Double> generate() {        Map<Integer, Double> map = new HashMap<Integer, Double>();        Random r = new Random();        for (int i = 0; i < 2000; ++i)            map.put(r.nextInt(), r.nextDouble());        return map;    }    private OpenIntToDoubleHashMap createFromJavaMap() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());        }        return map;    }    public void testPutAndGetWith0ExpectedSize() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(0);        assertPutAndGet(map);    }    public void testPutAndGetWithExpectedSize() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(500);        assertPutAndGet(map);    }    public void testPutAndGet() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        assertPutAndGet(map);    }    private void assertPutAndGet(OpenIntToDoubleHashMap map) {        assertPutAndGet(map, 0, new HashSet<Integer>());    }    private void assertPutAndGet(OpenIntToDoubleHashMap map, int mapSize,            Set<Integer> keysInMap) {        assertEquals(mapSize, map.size());        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            if (!keysInMap.contains(mapEntry.getKey()))                ++mapSize;            assertEquals(mapSize, map.size());            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));        }    }    public void testPutAbsentOnExisting() {        OpenIntToDoubleHashMap map = createFromJavaMap();        int size = javaMap.size();        for (Map.Entry<Integer, Double> mapEntry : generateAbsent().entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            assertEquals(++size, map.size());            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));        }    }    public void testPutOnExisting() {        OpenIntToDoubleHashMap map = createFromJavaMap();        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            map.put(mapEntry.getKey(), mapEntry.getValue());            assertEquals(javaMap.size(), map.size());            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));        }    }    public void testGetAbsent() {        Map<Integer, Double> generated = generateAbsent();        OpenIntToDoubleHashMap map = createFromJavaMap();        for (Map.Entry<Integer, Double> mapEntry : generated.entrySet())            assertTrue(Double.isNaN(map.get(mapEntry.getKey())));    }    public void testGetFromEmpty() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        assertTrue(Double.isNaN(map.get(5)));        assertTrue(Double.isNaN(map.get(0)));        assertTrue(Double.isNaN(map.get(50)));    }    public void testRemove() {        OpenIntToDoubleHashMap map = createFromJavaMap();        int mapSize = javaMap.size();        assertEquals(mapSize, map.size());        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            map.remove(mapEntry.getKey());            assertEquals(--mapSize, map.size());            assertTrue(Double.isNaN(map.get(mapEntry.getKey())));        }        /* Ensure that put and get still work correctly after removals */        assertPutAndGet(map);    }    /* This time only remove some entries */    public void testRemove2() {        OpenIntToDoubleHashMap map = createFromJavaMap();        int mapSize = javaMap.size();        int count = 0;        Set<Integer> keysInMap = new HashSet<Integer>(javaMap.keySet());        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            keysInMap.remove(mapEntry.getKey());            map.remove(mapEntry.getKey());            assertEquals(--mapSize, map.size());            assertTrue(Double.isNaN(map.get(mapEntry.getKey())));            if (count++ > 5)                break;        }        /* Ensure that put and get still work correctly after removals */        assertPutAndGet(map, mapSize, keysInMap);    }    public void testRemoveFromEmpty() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        assertTrue(Double.isNaN(map.remove(50)));    }    public void testRemoveAbsent() {        Map<Integer, Double> generated = generateAbsent();        OpenIntToDoubleHashMap map = createFromJavaMap();        int mapSize = map.size();        for (Map.Entry<Integer, Double> mapEntry : generated.entrySet()) {            map.remove(mapEntry.getKey());            assertEquals(mapSize, map.size());            assertTrue(Double.isNaN(map.get(mapEntry.getKey())));        }    }    /**     * Returns a map with at least 100 elements where each element is absent from javaMap.     */    private Map<Integer, Double> generateAbsent() {        Map<Integer, Double> generated = new HashMap<Integer, Double>();        do {            generated.putAll(generate());            for (Integer key : javaMap.keySet())                generated.remove(key);        } while (generated.size() < 100);        return generated;    }    public void testCopy() {        OpenIntToDoubleHashMap copy =            new OpenIntToDoubleHashMap(createFromJavaMap());        assertEquals(javaMap.size(), copy.size());        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet())            assertEquals(mapEntry.getValue(), copy.get(mapEntry.getKey()));    }    public void testContainsKey() {        OpenIntToDoubleHashMap map = createFromJavaMap();        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            assertTrue(map.containsKey(mapEntry.getKey()));        }        for (Map.Entry<Integer, Double> mapEntry : generateAbsent().entrySet()) {            assertFalse(map.containsKey(mapEntry.getKey()));        }        for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {            int key = mapEntry.getKey();            assertTrue(map.containsKey(key));            map.remove(key);            assertFalse(map.containsKey(key));        }    }    public void testIterator() {        OpenIntToDoubleHashMap map = createFromJavaMap();        OpenIntToDoubleHashMap.Iterator iterator = map.iterator();        for (int i = 0; i < map.size(); ++i) {            assertTrue(iterator.hasNext());            iterator.advance();            int key = iterator.key();            assertTrue(map.containsKey(key));            assertEquals(javaMap.get(key), map.get(key), 0);            assertEquals(javaMap.get(key), iterator.value(), 0);            assertTrue(javaMap.containsKey(key));        }        assertFalse(iterator.hasNext());        try {            iterator.advance();            fail("an exception should have been thrown");        } catch (NoSuchElementException nsee) {            // expected        }    }    public void testConcurrentModification() {        OpenIntToDoubleHashMap map = createFromJavaMap();        OpenIntToDoubleHashMap.Iterator iterator = map.iterator();        map.put(3, 3);        try {            iterator.advance();            fail("an exception should have been thrown");        } catch (ConcurrentModificationException cme) {            // expected        }    }    /**     * Regression test for a bug in findInsertionIndex where the hashing in the second probing     * loop was inconsistent with the first causing duplicate keys after the right sequence     * of puts and removes.     */    public void testPutKeysWithCollisions() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        int key1 = -1996012590;        double value1 = 1.0;        map.put(key1, value1);        int key2 = 835099822;        map.put(key2, value1);        int key3 = 1008859686;        map.put(key3, value1);        assertEquals(value1, map.get(key3));        assertEquals(3, map.size());        map.remove(key2);        double value2 = 2.0;        map.put(key3, value2);        assertEquals(value2, map.get(key3));        assertEquals(2, map.size());    }    /**     * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly     * different manner.     */    public void testPutKeysWithCollision2() {        OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap();        int key1 = 837989881;        double value1 = 1.0;        map.put(key1, value1);        int key2 = 476463321;        map.put(key2, value1);        assertEquals(2, map.size());        assertEquals(value1, map.get(key2));        map.remove(key1);        double value2 = 2.0;        map.put(key2, value2);        assertEquals(1, map.size());        assertEquals(value2, map.get(key2));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class TransformerMapTest extends TestCase {    /**     *     */    public void testPutTransformer(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertEquals(expected, map.getTransformer(TransformerMapTest.class));    }    /**     *     */    public void testContainsClass(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.containsClass(TransformerMapTest.class));    }    /**     *     */    public void testContainsTransformer(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.containsTransformer(expected));    }    /**     *     */    public void testRemoveTransformer(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.containsClass(TransformerMapTest.class));        assertTrue(map.containsTransformer(expected));        map.removeTransformer(TransformerMapTest.class);        assertFalse(map.containsClass(TransformerMapTest.class));        assertFalse(map.containsTransformer(expected));    }    /**     *     */    public void testClear(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.containsClass(TransformerMapTest.class));        map.clear();        assertFalse(map.containsClass(TransformerMapTest.class));    }    /**     *     */    public void testClasses(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.classes().contains(TransformerMapTest.class));    }    /**     *     */    public void testTransformers(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.transformers().contains(expected));    }    public void testSerial(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertEquals(map, TestUtils.serializeAndRecover(map));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.MathRuntimeException;import org.apache.commons.math.exception.util.LocalizedFormats;/** * @version $Revision$ $Date$ */public class TestBean {    private Double x = Double.valueOf(1.0);    private String y = "1.0";    /**     *     */    public Double getX() {        return x;    }    /**     *     */    public String getY() {        return y;    }    /**     *     */    public void setX(Double double1) {        x = double1;    }    /**     *     */    public void setY(String string) {        y = string;    }    /**     *     */    public Double getZ() {        throw new MathRuntimeException(LocalizedFormats.SIMPLE_MESSAGE, "?");    }    /**     *     */    public void setZ(Double double1) {    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.exception.MaxCountExceededException;import org.junit.Assert;import org.junit.Test;/** * Test for {@link Incrementor}. */public class IncrementorTest {    @Test    public void testAccessor() {        final Incrementor i = new Incrementor();        i.setMaximalCount(10);        Assert.assertEquals(10, i.getMaximalCount());        Assert.assertEquals(0, i.getCount());    }    @Test    public void testBelowMaxCount() {        final Incrementor i = new Incrementor();        i.setMaximalCount(3);        i.incrementCount();        i.incrementCount();        i.incrementCount();        Assert.assertEquals(3, i.getCount());    }    @Test(expected = MaxCountExceededException.class)    public void testAboveMaxCount() {        final Incrementor i = new Incrementor();        i.setMaximalCount(3);        i.incrementCount();        i.incrementCount();        i.incrementCount();        i.incrementCount();    }    @Test    public void testReset() {        final Incrementor i = new Incrementor();        i.setMaximalCount(3);        i.incrementCount();        i.incrementCount();        i.incrementCount();        Assert.assertEquals(3, i.getCount());        i.resetCount();        Assert.assertEquals(0, i.getCount());    }    @Test    public void testBulkIncrement() {        final Incrementor i = new Incrementor();        i.setMaximalCount(3);        i.incrementCount(2);        Assert.assertEquals(2, i.getCount());        i.incrementCount(1);        Assert.assertEquals(3, i.getCount());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.transform;import junit.framework.TestCase;/** * JUnit Test for HadamardTransformerTest * @see org.apache.commons.math.transform.FastHadamardTransformer */public final class FastHadamardTransformerTest extends TestCase {    /**     * Test of transformer for the a 8-point FHT (means n=8)     */    public void test8Points() {        checkAllTransforms(new int[] { 1, 4, -2, 3, 0, 1, 4, -1 },                       new int[] { 10, -4, 2, -4, 2, -12, 6, 8 });    }    /**     * Test of transformer for the a 4-points FHT (means n=4)     */    public void test4Points() {        checkAllTransforms(new int[] { 1, 2, 3, 4 },                           new int[] { 10, -2, -4, 0 });    }    /**     * Test the inverse transform of an integer vector is not always an integer vector     */    public void testNoIntInverse() {        FastHadamardTransformer transformer = new FastHadamardTransformer();        double[] x = transformer.inversetransform(new double[] { 0, 1, 0, 1});        assertEquals( 0.5, x[0], 0);        assertEquals(-0.5, x[1], 0);        assertEquals( 0.0, x[2], 0);        assertEquals( 0.0, x[3], 0);    }    /**     * Test of transformer for wrong number of points     */    public void test3Points() {        try {            new FastHadamardTransformer().transform(new double[3]);            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected        }    }    private void checkAllTransforms(int[]x, int[] y) {        checkDoubleTransform(x, y);        checkInverseDoubleTransform(x, y);        checkIntTransform(x, y);    }    private void checkDoubleTransform(int[]x, int[] y) {        // Initiate the transformer        FastHadamardTransformer transformer = new FastHadamardTransformer();        // check double transform        double[] dX = new double[x.length];        for (int i = 0; i < dX.length; ++i) {            dX[i] = x[i];        }        double dResult[] = transformer.transform(dX);        for (int i = 0; i < dResult.length; i++) {            // compare computed results to precomputed results            assertEquals((double) y[i], dResult[i]);        }    }    private void checkIntTransform(int[]x, int[] y) {        // Initiate the transformer        FastHadamardTransformer transformer = new FastHadamardTransformer();        // check integer transform        int iResult[] = transformer.transform(x);        for (int i = 0; i < iResult.length; i++) {            // compare computed results to precomputed results            assertEquals(y[i], iResult[i]);        }    }    private void checkInverseDoubleTransform(int[]x, int[] y) {        // Initiate the transformer        FastHadamardTransformer transformer = new FastHadamardTransformer();        // check double transform        double[] dY = new double[y.length];        for (int i = 0; i < dY.length; ++i) {            dY[i] = y[i];        }        double dResult[] = transformer.inversetransform(dY);        for (int i = 0; i < dResult.length; i++) {            // compare computed results to precomputed results            assertEquals((double) x[i], dResult[i]);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.transform;import org.apache.commons.math.analysis.*;import org.apache.commons.math.complex.*;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for fast Fourier transformer. * <p> * FFT algorithm is exact, the small tolerance number is used only * to account for round-off errors. * * @version $Revision$ $Date$ */public final class FastFourierTransformerTest extends TestCase {    /**     * Test of transformer for the ad hoc data taken from Mathematica.     */    public void testAdHocData() {        FastFourierTransformer transformer = new FastFourierTransformer();        Complex result[]; double tolerance = 1E-12;        double x[] = {1.3, 2.4, 1.7, 4.1, 2.9, 1.7, 5.1, 2.7};        Complex y[] = {            new Complex(21.9, 0.0),            new Complex(-2.09497474683058, 1.91507575950825),            new Complex(-2.6, 2.7),            new Complex(-1.10502525316942, -4.88492424049175),            new Complex(0.1, 0.0),            new Complex(-1.10502525316942, 4.88492424049175),            new Complex(-2.6, -2.7),            new Complex(-2.09497474683058, -1.91507575950825)};        result = transformer.transform(x);        for (int i = 0; i < result.length; i++) {            assertEquals(y[i].getReal(), result[i].getReal(), tolerance);            assertEquals(y[i].getImaginary(), result[i].getImaginary(), tolerance);        }        result = transformer.inversetransform(y);        for (int i = 0; i < result.length; i++) {            assertEquals(x[i], result[i].getReal(), tolerance);            assertEquals(0.0, result[i].getImaginary(), tolerance);        }        double x2[] = {10.4, 21.6, 40.8, 13.6, 23.2, 32.8, 13.6, 19.2};        FastFourierTransformer.scaleArray(x2, 1.0 / FastMath.sqrt(x2.length));        Complex y2[] = y;        result = transformer.transform2(y2);        for (int i = 0; i < result.length; i++) {            assertEquals(x2[i], result[i].getReal(), tolerance);            assertEquals(0.0, result[i].getImaginary(), tolerance);        }        result = transformer.inversetransform2(x2);        for (int i = 0; i < result.length; i++) {            assertEquals(y2[i].getReal(), result[i].getReal(), tolerance);            assertEquals(y2[i].getImaginary(), result[i].getImaginary(), tolerance);        }    }    public void test2DData() {        FastFourierTransformer transformer = new FastFourierTransformer();        double tolerance = 1E-12;        Complex[][] input = new Complex[][] {new Complex[] {new Complex(1, 0),                                                            new Complex(2, 0)},                                             new Complex[] {new Complex(3, 1),                                                            new Complex(4, 2)}};        Complex[][] goodOutput = new Complex[][] {new Complex[] {new Complex(5,                1.5), new Complex(-1, -.5)}, new Complex[] {new Complex(-2,                -1.5), new Complex(0, .5)}};        Complex[][] output = (Complex[][])transformer.mdfft(input, true);        Complex[][] output2 = (Complex[][])transformer.mdfft(output, false);        assertEquals(input.length, output.length);        assertEquals(input.length, output2.length);        assertEquals(input[0].length, output[0].length);        assertEquals(input[0].length, output2[0].length);        assertEquals(input[1].length, output[1].length);        assertEquals(input[1].length, output2[1].length);        for (int i = 0; i < input.length; i++) {            for (int j = 0; j < input[0].length; j++) {                assertEquals(input[i][j].getImaginary(), output2[i][j].getImaginary(),                             tolerance);                assertEquals(input[i][j].getReal(), output2[i][j].getReal(), tolerance);                assertEquals(goodOutput[i][j].getImaginary(), output[i][j].getImaginary(),                             tolerance);                assertEquals(goodOutput[i][j].getReal(), output[i][j].getReal(), tolerance);            }        }    }    /**     * Test of transformer for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        FastFourierTransformer transformer = new FastFourierTransformer();        Complex result[]; int N = 1 << 8;        double min, max, tolerance = 1E-12;        min = 0.0; max = 2.0 * FastMath.PI;        result = transformer.transform(f, min, max, N);        assertEquals(0.0, result[1].getReal(), tolerance);        assertEquals(-(N >> 1), result[1].getImaginary(), tolerance);        assertEquals(0.0, result[N-1].getReal(), tolerance);        assertEquals(N >> 1, result[N-1].getImaginary(), tolerance);        for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {            assertEquals(0.0, result[i].getReal(), tolerance);            assertEquals(0.0, result[i].getImaginary(), tolerance);        }        min = -FastMath.PI; max = FastMath.PI;        result = transformer.inversetransform(f, min, max, N);        assertEquals(0.0, result[1].getReal(), tolerance);        assertEquals(-0.5, result[1].getImaginary(), tolerance);        assertEquals(0.0, result[N-1].getReal(), tolerance);        assertEquals(0.5, result[N-1].getImaginary(), tolerance);        for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {            assertEquals(0.0, result[i].getReal(), tolerance);            assertEquals(0.0, result[i].getImaginary(), tolerance);        }    }    /**     * Test of parameters for the transformer.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        FastFourierTransformer transformer = new FastFourierTransformer();        try {            // bad interval            transformer.transform(f, 1, -1, 64);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 0);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 100);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.transform;import org.apache.commons.math.analysis.*;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for fast cosine transformer. * <p> * FCT algorithm is exact, the small tolerance number is used only * to account for round-off errors. * * @version $Revision$ $Date$ */public final class FastCosineTransformerTest extends TestCase {    /**     * Test of transformer for the ad hoc data.     */    public void testAdHocData() {        FastCosineTransformer transformer = new FastCosineTransformer();        double result[], tolerance = 1E-12;        double x[] = { 0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0 };        double y[] = { 172.0, -105.096569476353, 27.3137084989848,                      -12.9593152353742, 8.0, -5.78585076868676,                       4.68629150101524, -4.15826451958632, 4.0 };        result = transformer.transform(x);        for (int i = 0; i < result.length; i++) {            assertEquals(y[i], result[i], tolerance);        }        result = transformer.inversetransform(y);        for (int i = 0; i < result.length; i++) {            assertEquals(x[i], result[i], tolerance);        }        FastFourierTransformer.scaleArray(x, FastMath.sqrt(0.5 * (x.length-1)));        result = transformer.transform2(y);        for (int i = 0; i < result.length; i++) {            assertEquals(x[i], result[i], tolerance);        }        result = transformer.inversetransform2(x);        for (int i = 0; i < result.length; i++) {            assertEquals(y[i], result[i], tolerance);        }    }    /**     * Test of transformer for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        FastCosineTransformer transformer = new FastCosineTransformer();        double min, max, result[], tolerance = 1E-12; int N = 9;        double expected[] = { 0.0, 3.26197262739567, 0.0,                             -2.17958042710327, 0.0, -0.648846697642915,                              0.0, -0.433545502649478, 0.0 };        min = 0.0; max = 2.0 * FastMath.PI * N / (N-1);        result = transformer.transform(f, min, max, N);        for (int i = 0; i < N; i++) {            assertEquals(expected[i], result[i], tolerance);        }        min = -FastMath.PI; max = FastMath.PI * (N+1) / (N-1);        result = transformer.transform(f, min, max, N);        for (int i = 0; i < N; i++) {            assertEquals(-expected[i], result[i], tolerance);        }    }    /**     * Test of parameters for the transformer.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        FastCosineTransformer transformer = new FastCosineTransformer();        try {            // bad interval            transformer.transform(f, 1, -1, 65);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 1);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 64);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.transform;import org.apache.commons.math.analysis.*;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for fast sine transformer. * <p> * FST algorithm is exact, the small tolerance number is used only * to account for round-off errors. * * @version $Revision$ $Date$ */public final class FastSineTransformerTest extends TestCase {    /**     * Test of transformer for the ad hoc data.     */    public void testAdHocData() {        FastSineTransformer transformer = new FastSineTransformer();        double result[], tolerance = 1E-12;        double x[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 };        double y[] = { 0.0, 20.1093579685034, -9.65685424949238,                       5.98642305066196, -4.0, 2.67271455167720,                      -1.65685424949238, 0.795649469518633 };        result = transformer.transform(x);        for (int i = 0; i < result.length; i++) {            assertEquals(y[i], result[i], tolerance);        }        result = transformer.inversetransform(y);        for (int i = 0; i < result.length; i++) {            assertEquals(x[i], result[i], tolerance);        }        FastFourierTransformer.scaleArray(x, FastMath.sqrt(x.length / 2.0));        result = transformer.transform2(y);        for (int i = 0; i < result.length; i++) {            assertEquals(x[i], result[i], tolerance);        }        result = transformer.inversetransform2(x);        for (int i = 0; i < result.length; i++) {            assertEquals(y[i], result[i], tolerance);        }    }    /**     * Test of transformer for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        FastSineTransformer transformer = new FastSineTransformer();        double min, max, result[], tolerance = 1E-12; int N = 1 << 8;        min = 0.0; max = 2.0 * FastMath.PI;        result = transformer.transform(f, min, max, N);        assertEquals(N >> 1, result[2], tolerance);        for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {            assertEquals(0.0, result[i], tolerance);        }        min = -FastMath.PI; max = FastMath.PI;        result = transformer.transform(f, min, max, N);        assertEquals(-(N >> 1), result[2], tolerance);        for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {            assertEquals(0.0, result[i], tolerance);        }    }    /**     * Test of parameters for the transformer.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        FastSineTransformer transformer = new FastSineTransformer();        try {            // bad interval            transformer.transform(f, 1, -1, 64);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 0);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad samples number            transformer.transform(f, -1, 1, 100);            fail("Expecting IllegalArgumentException - bad samples number");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception.util;import java.util.List;import java.util.ArrayList;import org.junit.Assert;import org.junit.Test;/** * Test for {@link ArgUtils}. *  * @version $Revision$ $Date$  */public class ArgUtilsTest {    @Test    public void testFlatten() {        final List<Object> orig = new ArrayList<Object>();        final Object[] struct = new Object[] {            new Object[] {                new Object[] {                    create(orig),                    create(orig),                },                create(orig),                new Object[] {                    create(orig),                }            },            create(orig),            new Object[] {                create(orig),                new Object[] {                    create(orig),                    create(orig),                }            },            create(orig),        };        Object[] flat = ArgUtils.flatten(struct);        Assert.assertEquals(flat.length, orig.size());        for (int i = 0, max = orig.size(); i < max; i++) {            Assert.assertEquals(orig.get(i), flat[i]);        }    }    /**     * Create and store an {@code Object}.     *     * @param list List to store to.     * @return the stored object.     */    private Object create(List<Object> list) {        final Object o = new Object();        list.add(o);        return o;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception;import org.junit.Assert;import org.junit.Test;/** * Test for {@link DimensionMismatchException}. *  * @version $Revision$ $Date$  */public class DimensionMismatchExceptionTest {    @Test    public void testAccessors() {        final DimensionMismatchException e = new DimensionMismatchException(1, 2);        Assert.assertEquals(1, e.getArgument());        Assert.assertEquals(2, e.getDimension());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception;import org.junit.Assert;import org.junit.Test;/** * Test for {@link NotStrictlyPositiveException}. *  * @version $Revision$ $Date$  */public class NotStrictlyPositiveExceptionTest {    @Test    public void testAccessors() {        final NotStrictlyPositiveException e = new NotStrictlyPositiveException(0);        Assert.assertEquals(0, e.getArgument());        Assert.assertEquals(0, e.getMin());        Assert.assertFalse(e.getBoundIsAllowed());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception;import org.junit.Assert;import org.junit.Test;/** * Test for {@link NotPositiveException}. *  * @version $Revision$ $Date$  */public class NotPositiveExceptionTest {    @Test    public void testAccessors() {        final NotPositiveException e = new NotPositiveException(-1);        Assert.assertEquals(-1, e.getArgument());        Assert.assertEquals(0, e.getMin());        Assert.assertTrue(e.getBoundIsAllowed());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception;import org.junit.Assert;import org.junit.Test;/** * Test for {@link NumberIsTooSmallException}. *  * @version $Revision$ $Date$  */public class NumberIsTooSmallExceptionTest {    @Test    public void testAccessors() {        final NumberIsTooSmallException e = new NumberIsTooSmallException(0, 0, false);        Assert.assertEquals(0, e.getArgument());        Assert.assertEquals(0, e.getMin());        Assert.assertFalse(e.getBoundIsAllowed());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception;import org.junit.Assert;import org.junit.Test;/** * Test for {@link NumberIsTooLargeException}. *  * @version $Revision$ $Date$  */public class NumberIsTooLargeExceptionTest {    @Test    public void testAccessors() {        final NumberIsTooLargeException e = new NumberIsTooLargeException(1, 0, true);        Assert.assertEquals(1, e.getArgument());        Assert.assertEquals(0, e.getMax());        Assert.assertTrue(e.getBoundIsAllowed());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception;import org.apache.commons.math.util.MathUtils;import org.junit.Assert;import org.junit.Test;/** * Test for {@link NonMonotonousSequenceException}. *  * @version $Revision$ $Date$  */public class NonMonotonousSequenceExceptionTest {    @Test    public void testAccessors() {        NonMonotonousSequenceException e            = new NonMonotonousSequenceException(0, -1, 1, MathUtils.OrderDirection.DECREASING, false);        Assert.assertEquals(0, e.getArgument());        Assert.assertEquals(-1, e.getPrevious());        Assert.assertEquals(1, e.getIndex());        Assert.assertTrue(e.getDirection() == MathUtils.OrderDirection.DECREASING);        Assert.assertFalse(e.getStrict());        e = new NonMonotonousSequenceException(-1, 0, 1);        Assert.assertEquals(-1, e.getArgument());        Assert.assertEquals(0, e.getPrevious());        Assert.assertEquals(1, e.getIndex());        Assert.assertTrue(e.getDirection() == MathUtils.OrderDirection.INCREASING);        Assert.assertTrue(e.getStrict());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception;import org.junit.Assert;import org.junit.Test;/** * Test for {@link OutOfRangeException}. *  * @version $Revision$ $Date$  */public class OutOfRangeExceptionTest {    @Test    public void testAccessors() {        final OutOfRangeException e = new OutOfRangeException(-1, 0, 2);        Assert.assertEquals(-1, e.getArgument());        Assert.assertEquals(0, e.getLo());        Assert.assertEquals(2, e.getHi());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.exception;import org.junit.Assert;import org.junit.Test;/** * Test for {@link MatrixDimensionMismatchException}. *  * @version $Revision$ $Date$  */public class MatrixDimensionMismatchExceptionTest {    @Test    public void testAccessors() {        final MatrixDimensionMismatchException e            = new MatrixDimensionMismatchException(1, 2, 3, 4);        Assert.assertEquals(1, e.getWrongRowDimension());        Assert.assertEquals(2, e.getWrongColumnDimension());        Assert.assertEquals(3, e.getExpectedRowDimension());        Assert.assertEquals(4, e.getExpectedColumnDimension());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.special;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class BetaTest extends TestCase {    /**     * Constructor for BetaTest.     * @param name     */    public BetaTest(String name) {        super(name);    }    private void testRegularizedBeta(double expected, double x, double a,        double b)    {        try {            double actual = Beta.regularizedBeta(x, a, b);            TestUtils.assertEquals(expected, actual, 10e-15);        } catch(MathException ex){            fail(ex.getMessage());        }    }    private void testLogBeta(double expected, double a, double b) {        double actual = Beta.logBeta(a, b);        TestUtils.assertEquals(expected, actual, 10e-15);    }    public void testRegularizedBetaNanPositivePositive() {        testRegularizedBeta(Double.NaN, Double.NaN, 1.0, 1.0);    }    public void testRegularizedBetaPositiveNanPositive() {        testRegularizedBeta(Double.NaN, 0.5, Double.NaN, 1.0);    }    public void testRegularizedBetaPositivePositiveNan() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, Double.NaN);    }    public void testRegularizedBetaNegativePositivePositive() {        testRegularizedBeta(Double.NaN, -0.5, 1.0, 2.0);    }    public void testRegularizedBetaPositiveNegativePositive() {        testRegularizedBeta(Double.NaN, 0.5, -1.0, 2.0);    }    public void testRegularizedBetaPositivePositiveNegative() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, -2.0);    }    public void testRegularizedBetaZeroPositivePositive() {        testRegularizedBeta(0.0, 0.0, 1.0, 2.0);    }    public void testRegularizedBetaPositiveZeroPositive() {        testRegularizedBeta(Double.NaN, 0.5, 0.0, 2.0);    }    public void testRegularizedBetaPositivePositiveZero() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, 0.0);    }    public void testRegularizedBetaPositivePositivePositive() {        testRegularizedBeta(0.75, 0.5, 1.0, 2.0);    }    public void testLogBetaNanPositive() {        testLogBeta(Double.NaN, Double.NaN, 2.0);    }    public void testLogBetaPositiveNan() {        testLogBeta(Double.NaN, 1.0, Double.NaN);    }    public void testLogBetaNegativePositive() {        testLogBeta(Double.NaN, -1.0, 2.0);    }    public void testLogBetaPositiveNegative() {        testLogBeta(Double.NaN, 1.0, -2.0);    }    public void testLogBetaZeroPositive() {        testLogBeta(Double.NaN, 0.0, 2.0);    }    public void testLogBetaPositiveZero() {        testLogBeta(Double.NaN, 1.0, 0.0);    }    public void testLogBetaPositivePositive() {        testLogBeta(-0.693147180559945, 1.0, 2.0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.special;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class GammaTest extends TestCase {    public GammaTest(String name) {        super(name);    }    private void testRegularizedGamma(double expected, double a, double x) {        try {            double actualP = Gamma.regularizedGammaP(a, x);            double actualQ = Gamma.regularizedGammaQ(a, x);            TestUtils.assertEquals(expected, actualP, 10e-15);            TestUtils.assertEquals(actualP, 1.0 - actualQ, 10e-15);        } catch(MathException ex){            fail(ex.getMessage());        }    }    private void testLogGamma(double expected, double x) {        double actual = Gamma.logGamma(x);        TestUtils.assertEquals(expected, actual, 10e-15);    }    public void testRegularizedGammaNanPositive() {        testRegularizedGamma(Double.NaN, Double.NaN, 1.0);    }    public void testRegularizedGammaPositiveNan() {        testRegularizedGamma(Double.NaN, 1.0, Double.NaN);    }    public void testRegularizedGammaNegativePositive() {        testRegularizedGamma(Double.NaN, -1.5, 1.0);    }    public void testRegularizedGammaPositiveNegative() {        testRegularizedGamma(Double.NaN, 1.0, -1.0);    }    public void testRegularizedGammaZeroPositive() {        testRegularizedGamma(Double.NaN, 0.0, 1.0);    }    public void testRegularizedGammaPositiveZero() {        testRegularizedGamma(0.0, 1.0, 0.0);    }    public void testRegularizedGammaPositivePositive() {        testRegularizedGamma(0.632120558828558, 1.0, 1.0);    }    public void testLogGammaNan() {        testLogGamma(Double.NaN, Double.NaN);    }    public void testLogGammaNegative() {        testLogGamma(Double.NaN, -1.0);    }    public void testLogGammaZero() {        testLogGamma(Double.NaN, 0.0);    }    public void testLogGammaPositive() {        testLogGamma(0.6931471805599457, 3.0);    }    public void testDigammaLargeArgs() {        double eps = 1e-8;        assertEquals(4.6001618527380874002, Gamma.digamma(100), eps);        assertEquals(3.9019896734278921970, Gamma.digamma(50), eps);        assertEquals(2.9705239922421490509, Gamma.digamma(20), eps);        assertEquals(2.9958363947076465821, Gamma.digamma(20.5), eps);        assertEquals(2.2622143570941481605, Gamma.digamma(10.1), eps);        assertEquals(2.1168588189004379233, Gamma.digamma(8.8), eps);        assertEquals(1.8727843350984671394, Gamma.digamma(7), eps);        assertEquals(0.42278433509846713939, Gamma.digamma(2), eps);        assertEquals(-100.56088545786867450, Gamma.digamma(0.01), eps);        assertEquals(-4.0390398965921882955, Gamma.digamma(-0.8), eps);        assertEquals(4.2003210041401844726, Gamma.digamma(-6.3), eps);    }    public void testDigammaSmallArgs() {        // values for negative powers of 10 from 1 to 30 as computed by webMathematica with 20 digits        // see functions.wolfram.com        double[] expected = {-10.423754940411076795, -100.56088545786867450, -1000.5755719318103005,                -10000.577051183514335, -100000.57719921568107, -1.0000005772140199687e6, -1.0000000577215500408e7,                -1.0000000057721564845e8, -1.0000000005772156633e9, -1.0000000000577215665e10, -1.0000000000057721566e11,                -1.0000000000005772157e12, -1.0000000000000577216e13, -1.0000000000000057722e14, -1.0000000000000005772e15, -1e+16,                -1e+17, -1e+18, -1e+19, -1e+20, -1e+21, -1e+22, -1e+23, -1e+24, -1e+25, -1e+26,                -1e+27, -1e+28, -1e+29, -1e+30};        for (double n = 1; n < 30; n++) {            checkRelativeError(String.format("Test %.0f: ", n), expected[(int) (n - 1)], Gamma.digamma(FastMath.pow(10.0, -n)), 1e-8);        }    }    public void testTrigamma() {        double eps = 1e-8;        // computed using webMathematica.  For example, to compute trigamma($i) = Polygamma(1, $i), use        //        // http://functions.wolfram.com/webMathematica/Evaluated.jsp?name=PolyGamma2&plottype=0&vars={%221%22,%22$i%22}&digits=20        double[] data = {                1e-4, 1.0000000164469368793e8,                1e-3, 1.0000016425331958690e6,                1e-2, 10001.621213528313220,                1e-1, 101.43329915079275882,                1, 1.6449340668482264365,                2, 0.64493406684822643647,                3, 0.39493406684822643647,                4, 0.28382295573711532536,                5, 0.22132295573711532536,                10, 0.10516633568168574612,                20, 0.051270822935203119832,                50, 0.020201333226697125806,                100, 0.010050166663333571395        };        for (int i = data.length - 2; i >= 0; i -= 2) {            assertEquals(String.format("trigamma %.0f", data[i]), data[i + 1], Gamma.trigamma(data[i]), eps);        }    }    private void checkRelativeError(String msg, double expected, double actual, double tolerance) {        assertEquals(msg, expected, actual, FastMath.abs(tolerance * actual));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.apache.commons.math.special;import org.apache.commons.math.MathException;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class ErfTest extends TestCase {    public void testErf0() throws MathException {        double actual = Erf.erf(0.0);        double expected = 0.0;        assertEquals(expected, actual, 1.0e-5);    }    public void testErf1960() throws MathException {        double x = 1.960 / FastMath.sqrt(2.0);        double actual = Erf.erf(x);        double expected = 0.95;        assertEquals(expected, actual, 1.0e-5);        actual = Erf.erf(-x);        expected = -expected;        assertEquals(expected, actual, 1.0e-5);    }    public void testErf2576() throws MathException {        double x = 2.576 / FastMath.sqrt(2.0);        double actual = Erf.erf(x);        double expected = 0.99;        assertEquals(expected, actual, 1.0e-5);        actual = Erf.erf(-x);        expected = -expected;        assertEquals(expected, actual, 1.0e-5);    }    public void testErf2807() throws MathException {        double x = 2.807 / FastMath.sqrt(2.0);        double actual = Erf.erf(x);        double expected = 0.995;        assertEquals(expected, actual, 1.0e-5);        actual = Erf.erf(-x);        expected = -expected;        assertEquals(expected, actual, 1.0e-5);    }    public void testErf3291() throws MathException {        double x = 3.291 / FastMath.sqrt(2.0);        double actual = Erf.erf(x);        double expected = 0.999;        assertEquals(expected, actual, 1.0e-5);        actual = Erf.erf(-x);        expected = -expected;        assertEquals(expected, actual, 1.0e-5);    }    /**     * MATH-301     */    public void testLargeValues() throws Exception {        for (int i = 1; i < 200; i++) {            double result = Erf.erf(i);            assertFalse(Double.isNaN(result));            assertTrue(result > 0 && result <= 1);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import org.junit.Test;public class RandomKeyMutationTest {    @Test    public void testMutate() {        MutationPolicy mutation = new RandomKeyMutation();        int l=10;        for (int i=0; i<20; i++) {            DummyRandomKey origRk = new DummyRandomKey(RandomKey.randomPermutation(l));            Chromosome mutated = mutation.mutate(origRk);            DummyRandomKey mutatedRk = (DummyRandomKey) mutated;            int changes = 0;            for (int j=0; j<origRk.getLength(); j++) {                if (origRk.getRepresentation().get(j) != mutatedRk.getRepresentation().get(j)) {                    changes++;                }            }            assertEquals(1,changes);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import java.util.Arrays;import java.util.Comparator;import java.util.List;import org.junit.Test;public class RandomKeyTest {    @Test(expected=IllegalArgumentException.class)    public void testConstructor1() {        new DummyRandomKey(new Double[] {0.2, 0.3, 1.2});    }    @Test(expected=IllegalArgumentException.class)    public void testConstructor2() {        new DummyRandomKey(new Double[] {0.2, 0.3, -0.2});    }    @Test    public void testIsSame() {        DummyRandomKey drk1 = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});        DummyRandomKey drk2 = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});        DummyRandomKey drk3 = new DummyRandomKey(new Double[] {0.4, 0.15, 0.5, 0.8, 0.2});        DummyRandomKey drk4 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2});        DummyRandomKey drk5 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2, 0.5});        assertTrue(drk1.isSame(drk2));        assertTrue(drk2.isSame(drk3));        assertFalse(drk3.isSame(drk4));        assertFalse(drk4.isSame(drk5));    }    @Test    public void testDecode() {        DummyRandomKey drk = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});        List<String> decoded = drk.decode(Arrays.asList(new String[] {"a", "b", "c", "d", "e"}));        assertEquals("b", decoded.get(0));        assertEquals("e", decoded.get(1));        assertEquals("a", decoded.get(2));        assertEquals("c", decoded.get(3));        assertEquals("d", decoded.get(4));    }    @Test    public void testRandomPermutation() {        // never generate an invalid one        for (int i=0; i<10; i++) {            DummyRandomKey drk = new DummyRandomKey(RandomKey.randomPermutation(20));            assertNotNull(drk);        }    }    @Test    public void testIdentityPermutation() {        DummyRandomKey drk = new DummyRandomKey(RandomKey.identityPermutation(5));        List<String> decoded = drk.decode(Arrays.asList(new String[] {"a", "b", "c", "d", "e"}));        assertEquals("a", decoded.get(0));        assertEquals("b", decoded.get(1));        assertEquals("c", decoded.get(2));        assertEquals("d", decoded.get(3));        assertEquals("e", decoded.get(4));    }    @Test    public void testComparatorPermutation() {        List<String> data = Arrays.asList(new String[] {"x", "b", "c", "z", "b"});        List<Double> permutation = RandomKey.comparatorPermutation(data, new Comparator<String>() {            public int compare(String o1, String o2) {                return o1.compareTo(o2);            }        });        Double[] permArr = new Double[data.size()];        permArr = permutation.toArray(permArr);        assertArrayEquals(new Double[] {0.6,0.0,0.4,0.8,0.2}, permArr);        List<String> decodedData = new DummyRandomKey(permutation).decode(data);        assertEquals("b", decodedData.get(0));        assertEquals("b", decodedData.get(1));        assertEquals("c", decodedData.get(2));        assertEquals("x", decodedData.get(3));        assertEquals("z", decodedData.get(4));        permutation = RandomKey.comparatorPermutation(data, new Comparator<String>() {            public int compare(String o1, String o2) {                return o2.compareTo(o1);            }        });        permArr = new Double[data.size()];        permArr = permutation.toArray(permArr);        assertArrayEquals(new Double[] {0.2,0.6,0.4,0.0,0.8}, permArr);        decodedData = new DummyRandomKey(permutation).decode(data);        assertEquals("z", decodedData.get(0));        assertEquals("x", decodedData.get(1));        assertEquals("c", decodedData.get(2));        assertEquals("b", decodedData.get(3));        assertEquals("b", decodedData.get(4));    }    @Test    public void testInducedPermutation() {        List<String> origData = Arrays.asList(new String[] {"a", "b", "c", "d", "d"});        List<String> permutedData = Arrays.asList(new String[] {"d", "b", "c", "a", "d"});        DummyRandomKey drk = new DummyRandomKey(RandomKey.inducedPermutation(origData, permutedData));        List<String> decoded = drk.decode(origData);        assertEquals("d", decoded.get(0));        assertEquals("b", decoded.get(1));        assertEquals("c", decoded.get(2));        assertEquals("a", decoded.get(3));        assertEquals("d", decoded.get(4));        try {            RandomKey.inducedPermutation(                    Arrays.asList(new String[] {"a", "b", "c", "d", "d"}),                    Arrays.asList(new String[] {"a", "b", "c", "d"})            );            fail("Uncaught exception");        } catch (IllegalArgumentException e) {            // no-op        }        try {            RandomKey.inducedPermutation(                    Arrays.asList(new String[] {"a", "b", "c", "d", "d"}),                    Arrays.asList(new String[] {"a", "b", "c", "d", "f"})            );            fail("Uncaught exception");        } catch (IllegalArgumentException e) {            // no-op        }    }    @Test    public void testEqualRepr() {        DummyRandomKey drk = new DummyRandomKey(new Double[] {0.2, 0.2, 0.5});        List<String> decodedData = drk.decode(Arrays.asList(new String[] {"a", "b", "c"}));        assertEquals("a", decodedData.get(0));        assertEquals("b", decodedData.get(1));        assertEquals("c", decodedData.get(2));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import org.junit.Test;public class TournamentSelectionTest {    private static int counter = 0;    @Test    public void testSelect() {        TournamentSelection ts = new TournamentSelection(2);        ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203);        for (int i=0; i<pop.getPopulationLimit(); i++) {            pop.addChromosome(new DummyChromosome());        }        // how to write a test for stochastic method?        for (int i=0; i<20; i++) {            ChromosomePair pair = ts.select(pop);            // the worst chromosome should NEVER be selected            assertTrue(pair.getFirst().getFitness() > 0);            assertTrue(pair.getSecond().getFitness() > 0);        }    }    private static class DummyChromosome extends Chromosome {        private final int fitness;        public DummyChromosome() {            this.fitness = counter;            counter++;        }        public double fitness() {            return this.fitness;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import java.util.Iterator;import org.junit.Test;public class FixedGenerationCountTest {    @Test    public void testIsSatisfied() {        FixedGenerationCount fgc = new FixedGenerationCount(20);        int cnt = 0;        Population pop = new Population() {            public void addChromosome(Chromosome chromosome) {                // unimportant            }            public Chromosome getFittestChromosome() {                // unimportant                return null;            }            public int getPopulationLimit() {                // unimportant                return 0;            }            public int getPopulationSize() {                // unimportant                return 0;            }            public Population nextGeneration() {                // unimportant                return null;            }            public Iterator<Chromosome> iterator() {                // unimportant                return null;            }        };        while (!fgc.isSatisfied(pop))            cnt++;        assertEquals(20, cnt);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import java.util.ArrayList;import java.util.List;import org.junit.Test;public class ChromosomeTest {    @Test    public void testCompareTo() {        Chromosome c1 = new Chromosome() {            public double fitness() {                return 0;            }        };        Chromosome c2 = new Chromosome() {            public double fitness() {                return 10;            }        };        Chromosome c3 = new Chromosome() {            public double fitness() {                return 10;            }        };        assertTrue(c1.compareTo(c2) < 0);        assertTrue(c2.compareTo(c1) > 0);        assertEquals(0,c3.compareTo(c2));        assertEquals(0,c2.compareTo(c3));    }    private abstract static class DummyChromosome extends Chromosome {        private final int repr;        public DummyChromosome(final int repr) {            this.repr = repr;        }        @Override        protected boolean isSame(Chromosome another) {            return ((DummyChromosome) another).repr == repr;        }    }    @Test    public void testFindSameChromosome() {        Chromosome c1 = new DummyChromosome(1) {            public double fitness() {                return 1;            }        };        Chromosome c2 = new DummyChromosome(2) {            public double fitness() {                return 2;            }        };        Chromosome c3 = new DummyChromosome(3) {            public double fitness() {                return 3;            }        };        Chromosome c4 = new DummyChromosome(1) {            public double fitness() {                return 5;            }        };        Chromosome c5 = new DummyChromosome(15) {            public double fitness() {                return 15;            }        };        List<Chromosome> popChr = new ArrayList<Chromosome>();        popChr.add(c1);        popChr.add(c2);        popChr.add(c3);        Population pop = new ListPopulation(popChr,3) {            public Population nextGeneration() {                // not important                return null;            }        };        assertNull(c5.findSameChromosome(pop));        assertEquals(c1, c4.findSameChromosome(pop));        c4.searchForFitnessUpdate(pop);        assertEquals(1, c4.getFitness(),0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import org.junit.Test;public class OnePointCrossoverTest {    @Test    public void testCrossover() {        Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};        Integer[] p2 = new Integer[] {0,1,1,0,1,0,1,1,1};        BinaryChromosome p1c = new DummyBinaryChromosome(p1);        BinaryChromosome p2c = new DummyBinaryChromosome(p2);        OnePointCrossover<Integer> opc = new OnePointCrossover<Integer>();        // how to test a stochastic method?        for (int i=0; i<20; i++) {            ChromosomePair pair = opc.crossover(p1c,p2c);            Integer[] c1 = new Integer[p1.length];            Integer[] c2 = new Integer[p2.length];            c1 = ((BinaryChromosome) pair.getFirst()).getRepresentation().toArray(c1);            c2 = ((BinaryChromosome) pair.getSecond()).getRepresentation().toArray(c2);            // first and last values will be the same            assertEquals((int) p1[0], (int) c1[0]);            assertEquals((int) p2[0], (int) c2[0]);            assertEquals((int) p1[p1.length-1], (int) c1[c1.length-1]);            assertEquals((int) p2[p2.length-1], (int) c2[c2.length-1]);            // moreover, in the above setting, the 2nd, 3rd and 7th values will be the same            assertEquals((int) p1[2], (int) c1[2]);            assertEquals((int) p2[2], (int) c2[2]);            assertEquals((int) p1[3], (int) c1[3]);            assertEquals((int) p2[3], (int) c2[3]);            assertEquals((int) p1[7], (int) c1[7]);            assertEquals((int) p2[7], (int) c2[7]);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import java.util.LinkedList;import java.util.List;import org.junit.Test;public class FitnessCachingTest {    // parameters for the GA    private static final int DIMENSION = 50;    private static final double CROSSOVER_RATE = 1;    private static final double MUTATION_RATE = 0.1;    private static final int TOURNAMENT_ARITY = 5;    private static final int POPULATION_SIZE = 10;    private static final int NUM_GENERATIONS = 50;    private static final double ELITISM_RATE = 0.2;    // how many times was the fitness computed    private static int fitnessCalls = 0;    @Test    public void testFitnessCaching() {        // initialize a new genetic algorithm        GeneticAlgorithm ga = new GeneticAlgorithm(                new OnePointCrossover<Integer>(),                CROSSOVER_RATE, // all selected chromosomes will be recombined (=crosssover)                new BinaryMutation(),                MUTATION_RATE, // no mutation                new TournamentSelection(TOURNAMENT_ARITY)        );        // initial population        Population initial = randomPopulation();        // stopping conditions        StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);        // run the algorithm        ga.evolve(initial, stopCond);        int neededCalls =            POPULATION_SIZE /*initial population*/ +            (NUM_GENERATIONS - 1) /*for each population*/ * (int)(POPULATION_SIZE * (1.0 - ELITISM_RATE)) /*some chromosomes are copied*/            ;        assertTrue(fitnessCalls <= neededCalls); // some chromosomes after crossover may be the same os old ones    }    /**     * Initializes a random population.     */    private static ElitisticListPopulation randomPopulation() {        List<Chromosome> popList = new LinkedList<Chromosome>();        for (int i=0; i<POPULATION_SIZE; i++) {            BinaryChromosome randChrom = new DummyCountingBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(DIMENSION));            popList.add(randChrom);        }        return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE);    }    private static class DummyCountingBinaryChromosome extends DummyBinaryChromosome {        public DummyCountingBinaryChromosome(List<Integer> representation) {            super(representation);        }        @Override        public double fitness() {            fitnessCalls++;            return 0;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import java.util.ArrayList;import org.junit.Test;public class ListPopulationTest {    @Test    public void testGetFittestChromosome() {        Chromosome c1 = new Chromosome() {            public double fitness() {                return 0;            }        };        Chromosome c2 = new Chromosome() {            public double fitness() {                return 10;            }        };        Chromosome c3 = new Chromosome() {            public double fitness() {                return 15;            }        };        ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome> ();        chromosomes.add(c1);        chromosomes.add(c2);        chromosomes.add(c3);        ListPopulation population = new ListPopulation(chromosomes,10) {            public Population nextGeneration() {                // not important                return null;            }        };        assertEquals(c3, population.getFittestChromosome());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import org.junit.Test;public class BinaryChromosomeTest {    @Test    public void testInvalidConstructor() {        Integer[][] reprs = new Integer[][] {                new Integer[] {0,1,0,1,2},                new Integer[] {0,1,0,1,-1}        };        for (Integer[] repr : reprs) {            try {                new DummyBinaryChromosome(repr);                fail("Exception not caught");            } catch (IllegalArgumentException e) {            }        }    }    @Test    public void testRandomConstructor() {        for (int i=0; i<20; i++) {            new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10));        }    }    @Test    public void testIsSame() {        Chromosome c1 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1});        Chromosome c2 = new DummyBinaryChromosome(new Integer[] {0,1,1,0,1});        Chromosome c3 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1,1});        Chromosome c4 = new DummyBinaryChromosome(new Integer[] {1,1,0,1,0,1});        Chromosome c5 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,0});        Chromosome c6 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1});        assertFalse(c1.isSame(c2));        assertFalse(c1.isSame(c3));        assertFalse(c1.isSame(c4));        assertFalse(c1.isSame(c5));        assertTrue(c1.isSame(c6));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import org.junit.Test;public class ElitisticListPopulationTest {    private static int counter = 0;    @Test    public void testNextGeneration() {        ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203);        for (int i=0; i<pop.getPopulationLimit(); i++) {            pop.addChromosome(new DummyChromosome());        }        Population nextGeneration = pop.nextGeneration();        assertEquals(20, nextGeneration.getPopulationSize());    }    private static class DummyChromosome extends Chromosome {        private final int fitness;        public DummyChromosome() {            this.fitness = counter;            counter++;        }        public double fitness() {            return this.fitness;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.genetics;import static org.junit.Assert.*;import org.junit.Test;public class BinaryMutationTest {    @Test    public void testMutate() {        BinaryMutation mutation = new BinaryMutation();        // stochastic testing :)        for (int i=0; i<20; i++) {            DummyBinaryChromosome original = new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10));            DummyBinaryChromosome mutated = (DummyBinaryChromosome) mutation.mutate(original);            // one gene should be different            int numDifferent = 0;            for (int j=0; j<original.getRepresentation().size(); j++) {                if (original.getRepresentation().get(j) != mutated.getRepresentation().get(j))                    numDifferent++;            }            assertEquals(1, numDifferent);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.Expm1Function;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * Testcase for Muller solver. * <p> * Muller's method converges almost quadratically near roots, but it can * be very slow in regions far away from zeros. Test runs show that for * reasonably good initial values, for a default absolute accuracy of 1E-6, * it generally takes 5 to 10 iterations for the solver to converge. * <p> * Tests for the exponential function illustrate the situations where * Muller solver performs poorly. * * @version $Revision$ $Date$ */public final class MullerSolverTest extends TestCase {    /**     * Test deprecated APIs.     */    @Deprecated    public void testDeprecated() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new MullerSolver(f);        double min, max, expected, result, tolerance;        min = 3.0; max = 4.0; expected = FastMath.PI;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);        min = -1.0; max = 1.5; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test deprecated APIs.     */    @Deprecated    public void testDeprecated2() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        MullerSolver solver = new MullerSolver(f);        double min, max, expected, result, tolerance;        min = -0.4; max = 0.2; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(min, max);        assertEquals(expected, result, tolerance);        min = 0.75; max = 1.5; expected = 1.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(min, max);        assertEquals(expected, result, tolerance);        min = -0.9; max = -0.2; expected = -0.5;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new MullerSolver();        double min, max, expected, result, tolerance;        min = 3.0; max = 4.0; expected = FastMath.PI;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -1.0; max = 1.5; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the sine function using solve2().     */    public void testSinFunction2() throws MathException {        UnivariateRealFunction f = new SinFunction();        MullerSolver solver = new MullerSolver();        double min, max, expected, result, tolerance;        min = 3.0; max = 4.0; expected = FastMath.PI;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(f, min, max);        assertEquals(expected, result, tolerance);        min = -1.0; max = 1.5; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function.     */    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new MullerSolver();        double min, max, expected, result, tolerance;        min = -0.4; max = 0.2; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = 0.75; max = 1.5; expected = 1.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -0.9; max = -0.2; expected = -0.5;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function using solve2().     */    public void testQuinticFunction2() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        MullerSolver solver = new MullerSolver();        double min, max, expected, result, tolerance;        min = -0.4; max = 0.2; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(f, min, max);        assertEquals(expected, result, tolerance);        min = 0.75; max = 1.5; expected = 1.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(f, min, max);        assertEquals(expected, result, tolerance);        min = -0.9; max = -0.2; expected = -0.5;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the exponential function.     * <p>     * It takes 10 to 15 iterations for the last two tests to converge.     * In fact, if not for the bisection alternative, the solver would     * exceed the default maximal iteration of 100.     */    public void testExpm1Function() throws MathException {        UnivariateRealFunction f = new Expm1Function();        UnivariateRealSolver solver = new MullerSolver();        double min, max, expected, result, tolerance;        min = -1.0; max = 2.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -20.0; max = 10.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -50.0; max = 100.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the exponential function using solve2().     * <p>     * It takes 25 to 50 iterations for the last two tests to converge.     */    public void testExpm1Function2() throws MathException {        UnivariateRealFunction f = new Expm1Function();        MullerSolver solver = new MullerSolver();        double min, max, expected, result, tolerance;        min = -1.0; max = 2.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(f, min, max);        assertEquals(expected, result, tolerance);        min = -20.0; max = 10.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(f, min, max);        assertEquals(expected, result, tolerance);        min = -50.0; max = 100.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve2(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the solver.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new MullerSolver();        try {            // bad interval            solver.solve(f, 1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // no bracketing            solver.solve(f, 2, 3);            fail("Expecting IllegalArgumentException - no bracketing");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * * Licensed to the Apache Software Foundation (ASF) under one or more *  contributor license agreements.  See the NOTICE file distributed with *  this work for additional information regarding copyright ownership. *  The ASF licenses this file to You under the Apache License, Version 2.0 *  (the "License"); you may not use this file except in compliance with *  the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.apache.commons.math.analysis.solvers;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class UnivariateRealSolverFactoryImplTest extends TestCase {    /** solver factory */    private UnivariateRealSolverFactory factory;    /**     * @throws java.lang.Exception     * @see junit.framework.TestCase#tearDown()     */    @Override    protected void setUp() throws Exception {        super.setUp();        factory = new UnivariateRealSolverFactoryImpl();    }    /**     * @throws java.lang.Exception     * @see junit.framework.TestCase#tearDown()     */    @Override    protected void tearDown() throws Exception {        factory = null;        super.tearDown();    }    public void testNewBisectionSolverValid() {        UnivariateRealSolver solver = factory.newBisectionSolver();        assertNotNull(solver);        assertTrue(solver instanceof BisectionSolver);    }    public void testNewNewtonSolverValid() {        UnivariateRealSolver solver = factory.newNewtonSolver();        assertNotNull(solver);        assertTrue(solver instanceof NewtonSolver);    }    public void testNewBrentSolverValid() {        UnivariateRealSolver solver = factory.newBrentSolver();        assertNotNull(solver);        assertTrue(solver instanceof BrentSolver);    }    public void testNewSecantSolverValid() {        UnivariateRealSolver solver = factory.newSecantSolver();        assertNotNull(solver);        assertTrue(solver instanceof SecantSolver);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import junit.framework.TestCase;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;/** * @version $Revision$ $Date$ */public class UnivariateRealSolverUtilsTest extends TestCase {    protected UnivariateRealFunction sin = new SinFunction();    public void testSolveNull() throws MathException {        try {            UnivariateRealSolverUtils.solve(null, 0.0, 4.0);            fail();        } catch(IllegalArgumentException ex){            // success        }    }    public void testSolveBadParameters() throws MathException {        try { // bad endpoints            UnivariateRealSolverUtils.solve(sin,0.0, 4.0, 4.0);        } catch (IllegalArgumentException ex) {            // expected        }        try { // bad accuracy            UnivariateRealSolverUtils.solve(sin, 0.0, 4.0, 0.0);        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testSolveSin() throws MathException {        double x = UnivariateRealSolverUtils.solve(sin, 1.0, 4.0);        assertEquals(FastMath.PI, x, 1.0e-4);    }    public void testSolveAccuracyNull()  throws MathException {        try {            double accuracy = 1.0e-6;            UnivariateRealSolverUtils.solve(null, 0.0, 4.0, accuracy);            fail();        } catch(IllegalArgumentException ex){            // success        }    }    public void testSolveAccuracySin() throws MathException {        double accuracy = 1.0e-6;        double x = UnivariateRealSolverUtils.solve(sin, 1.0,                4.0, accuracy);        assertEquals(FastMath.PI, x, accuracy);    }    public void testSolveNoRoot() throws MathException {        try {            UnivariateRealSolverUtils.solve(sin, 1.0, 1.5);            fail("Expecting IllegalArgumentException ");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testBracketSin() throws MathException {        double[] result = UnivariateRealSolverUtils.bracket(sin,                0.0, -2.0, 2.0);        assertTrue(sin.value(result[0]) < 0);        assertTrue(sin.value(result[1]) > 0);    }    public void testBracketEndpointRoot() throws MathException {        double[] result = UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0);        assertEquals(0.0, sin.value(result[0]), 1.0e-15);        assertTrue(sin.value(result[1]) > 0);    }    public void testBadParameters() throws MathException {        try { // null function            UnivariateRealSolverUtils.bracket(null, 1.5, 0, 2.0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try { // initial not between endpoints            UnivariateRealSolverUtils.bracket(sin, 2.5, 0, 2.0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try { // endpoints not valid            UnivariateRealSolverUtils.bracket(sin, 1.5, 2.0, 1.0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try { // bad maximum iterations            UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0, 0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.polynomials.PolynomialFunction;import org.apache.commons.math.complex.Complex;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * Testcase for Laguerre solver. * <p> * Laguerre's method is very efficient in solving polynomials. Test runs * show that for a default absolute accuracy of 1E-6, it generally takes * less than 5 iterations to find one root, provided solveAll() is not * invoked, and 15 to 20 iterations to find all roots for quintic function. * * @version $Revision$ $Date$ */public final class LaguerreSolverTest extends TestCase {    /**     * Test deprecated APIs.     */    @Deprecated    public void testDeprecated() throws MathException {        double min, max, expected, result, tolerance;        // p(x) = 4x - 1        double coefficients[] = { -1.0, 4.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        UnivariateRealSolver solver = new LaguerreSolver(f);        min = 0.0; max = 1.0; expected = 0.25;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the linear function.     */    public void testLinearFunction() throws MathException {        double min, max, expected, result, tolerance;        // p(x) = 4x - 1        double coefficients[] = { -1.0, 4.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        UnivariateRealSolver solver = new LaguerreSolver();        min = 0.0; max = 1.0; expected = 0.25;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quadratic function.     */    public void testQuadraticFunction() throws MathException {        double min, max, expected, result, tolerance;        // p(x) = 2x^2 + 5x - 3 = (x+3)(2x-1)        double coefficients[] = { -3.0, 5.0, 2.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        UnivariateRealSolver solver = new LaguerreSolver();        min = 0.0; max = 2.0; expected = 0.5;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -4.0; max = -1.0; expected = -3.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function.     */    public void testQuinticFunction() throws MathException {        double min, max, expected, result, tolerance;        // p(x) = x^5 - x^4 - 12x^3 + x^2 - x - 12 = (x+1)(x+3)(x-4)(x^2-x+1)        double coefficients[] = { -12.0, -1.0, 1.0, -12.0, -1.0, 1.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        UnivariateRealSolver solver = new LaguerreSolver();        min = -2.0; max = 2.0; expected = -1.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -5.0; max = -2.5; expected = -3.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = 3.0; max = 6.0; expected = 4.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function using solveAll().     */    public void testQuinticFunction2() throws MathException {        double initial = 0.0, tolerance;        Complex expected, result[];        // p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4)        double coefficients[] = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 };        LaguerreSolver solver = new LaguerreSolver();        result = solver.solveAll(coefficients, initial);        expected = new Complex(0.0, -2.0);        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));        TestUtils.assertContains(result, expected, tolerance);        expected = new Complex(0.0, 2.0);        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));        TestUtils.assertContains(result, expected, tolerance);        expected = new Complex(0.5, 0.5 * FastMath.sqrt(3.0));        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));        TestUtils.assertContains(result, expected, tolerance);        expected = new Complex(-1.0, 0.0);        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));        TestUtils.assertContains(result, expected, tolerance);        expected = new Complex(0.5, -0.5 * FastMath.sqrt(3.0));        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));        TestUtils.assertContains(result, expected, tolerance);    }    /**     * Test of parameters for the solver.     */    public void testParameters() throws Exception {        double coefficients[] = { -3.0, 5.0, 2.0 };        PolynomialFunction f = new PolynomialFunction(coefficients);        UnivariateRealSolver solver = new LaguerreSolver();        try {            // bad interval            solver.solve(f, 1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // no bracketing            solver.solve(f, 2, 3);            fail("Expecting IllegalArgumentException - no bracketing");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad function            solver.solve(new SinFunction(), -1, 1);            fail("Expecting IllegalArgumentException - bad function");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import junit.framework.TestCase;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.MonitoredFunction;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;/** * Testcase for UnivariateRealSolver. * Because Brent-Dekker is guaranteed to converge in less than the default * maximum iteration count due to bisection fallback, it is quite hard to * debug. I include measured iteration counts plus one in order to detect * regressions. On average Brent-Dekker should use 4..5 iterations for the * default absolute accuracy of 10E-8 for sinus and the quintic function around * zero, and 5..10 iterations for the other zeros. * * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $ */public final class BrentSolverTest extends TestCase {    public BrentSolverTest(String name) {        super(name);    }    @Deprecated    public void testDeprecated() throws MathException {        // The sinus function is behaved well around the root at #pi. The second        // order derivative is zero, which means linar approximating methods will        // still converge quadratically.        UnivariateRealFunction f = new SinFunction();        double result;        UnivariateRealSolver solver = new BrentSolver(f);        // Somewhat benign interval. The function is monotone.        result = solver.solve(3, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        // 4 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 5);        // Larger and somewhat less benign interval. The function is grows first.        result = solver.solve(1, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        solver = new SecantSolver(f);        result = solver.solve(3, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        // 4 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 5);        result = solver.solve(1, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        assertEquals(result, solver.getResult(), 0);    }    public void testSinZero() throws MathException {        // The sinus function is behaved well around the root at #pi. The second        // order derivative is zero, which means linar approximating methods will        // still converge quadratically.        UnivariateRealFunction f = new SinFunction();        double result;        UnivariateRealSolver solver = new BrentSolver();        // Somewhat benign interval. The function is monotone.        result = solver.solve(f, 3, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        // 4 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 5);        // Larger and somewhat less benign interval. The function is grows first.        result = solver.solve(f, 1, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        solver = new SecantSolver();        result = solver.solve(f, 3, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        // 4 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 5);        result = solver.solve(f, 1, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        assertEquals(result, solver.getResult(), 0);    }   public void testQuinticZero() throws MathException {        // The quintic function has zeros at 0, +-0.5 and +-1.        // Around the root of 0 the function is well behaved, with a second derivative        // of zero a 0.        // The other roots are less well to find, in particular the root at 1, because        // the function grows fast for x>1.        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,        // intervals containing these values are harder for the solvers.        UnivariateRealFunction f = new QuinticFunction();        double result;        // Brent-Dekker solver.        UnivariateRealSolver solver = new BrentSolver();        // Symmetric bracket around 0. Test whether solvers can handle hitting        // the root in the first iteration.        result = solver.solve(f, -0.2, 0.2);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        assertTrue(solver.getIterationCount() <= 2);        // 1 iterations on i586 JDK 1.4.1.        // Asymmetric bracket around 0, just for fun. Contains extremum.        result = solver.solve(f, -0.1, 0.3);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        // Large bracket around 0. Contains two extrema.        result = solver.solve(f, -0.3, 0.45);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        // Benign bracket around 0.5, function is monotonous.        result = solver.solve(f, 0.3, 0.7);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        // Less benign bracket around 0.5, contains one extremum.        result = solver.solve(f, 0.2, 0.6);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        // Large, less benign bracket around 0.5, contains both extrema.        result = solver.solve(f, 0.05, 0.95);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        // Relatively benign bracket around 1, function is monotonous. Fast growth for x>1        // is still a problem.        result = solver.solve(f, 0.85, 1.25);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        // Less benign bracket around 1 with extremum.        result = solver.solve(f, 0.8, 1.2);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        // Large bracket around 1. Monotonous.        result = solver.solve(f, 0.85, 1.75);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 10 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 11);        // Large bracket around 1. Interval contains extremum.        result = solver.solve(f, 0.55, 1.45);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 7 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 8);        // Very large bracket around 1 for testing fast growth behaviour.        result = solver.solve(f, 0.85, 5);        //System.out.println(       //     "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 12 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 13);        // Secant solver.        solver = new SecantSolver();        result = solver.solve(f, -0.2, 0.2);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 1 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 2);        result = solver.solve(f, -0.1, 0.3);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        result = solver.solve(f, -0.3, 0.45);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        result = solver.solve(f, 0.3, 0.7);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 7 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 8);        result = solver.solve(f, 0.2, 0.6);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        result = solver.solve(f, 0.05, 0.95);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        result = solver.solve(f, 0.85, 1.25);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 10 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 11);        result = solver.solve(f, 0.8, 1.2);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        result = solver.solve(f, 0.85, 1.75);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 14 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 15);        // The followig is especially slow because the solver first has to reduce        // the bracket to exclude the extremum. After that, convergence is rapide.        result = solver.solve(f, 0.55, 1.45);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 7 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 8);        result = solver.solve(f, 0.85, 5);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 14 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 15);        // Static solve method        result = UnivariateRealSolverUtils.solve(f, -0.2, 0.2);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = UnivariateRealSolverUtils.solve(f, -0.1, 0.3);        assertEquals(result, 0, 1E-8);        result = UnivariateRealSolverUtils.solve(f, -0.3, 0.45);        assertEquals(result, 0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.3, 0.7);        assertEquals(result, 0.5, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.2, 0.6);        assertEquals(result, 0.5, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.05, 0.95);        assertEquals(result, 0.5, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.25);        assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.8, 1.2);        assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.75);        assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.55, 1.45);        assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.85, 5);        assertEquals(result, 1.0, 1E-6);    }    public void testRootEndpoints() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new BrentSolver();        // endpoint is root        double result = solver.solve(f, FastMath.PI, 4);        assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());        result = solver.solve(f, 3, FastMath.PI);        assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());        result = solver.solve(f, FastMath.PI, 4, 3.5);        assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());        result = solver.solve(f, 3, FastMath.PI, 3.07);        assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());    }    public void testBadEndpoints() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new BrentSolver();        try {  // bad interval            solver.solve(f, 1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {  // no bracket            solver.solve(f, 1, 1.5);            fail("Expecting IllegalArgumentException - non-bracketing");        } catch (IllegalArgumentException ex) {            // expected        }        try {  // no bracket            solver.solve(f, 1, 1.5, 1.2);            fail("Expecting IllegalArgumentException - non-bracketing");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testInitialGuess() throws MathException {        MonitoredFunction f = new MonitoredFunction(new QuinticFunction());        UnivariateRealSolver solver = new BrentSolver();        double result;        // no guess        result = solver.solve(f, 0.6, 7.0);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        int referenceCallsCount = f.getCallsCount();        assertTrue(referenceCallsCount >= 13);        // invalid guess (it *is* a root, but outside of the range)        try {          result = solver.solve(f, 0.6, 7.0, 0.0);          fail("an IllegalArgumentException was expected");        } catch (IllegalArgumentException iae) {            // expected behaviour        } catch (Exception e) {            fail("wrong exception caught: " + e.getMessage());        }        // bad guess        f.setCallsCount(0);        result = solver.solve(f, 0.6, 7.0, 0.61);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        assertTrue(f.getCallsCount() > referenceCallsCount);        // good guess        f.setCallsCount(0);        result = solver.solve(f, 0.6, 7.0, 0.999999);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        assertTrue(f.getCallsCount() < referenceCallsCount);        // perfect guess        f.setCallsCount(0);        result = solver.solve(f, 0.6, 7.0, 1.0);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        assertEquals(0, solver.getIterationCount());        assertEquals(1, f.getCallsCount());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.Expm1Function;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * Testcase for Ridders solver. * <p> * Ridders' method converges superlinearly, more specific, its rate of * convergence is sqrt(2). Test runs show that for a default absolute * accuracy of 1E-6, it generally takes less than 5 iterations for close * initial bracket and 5 to 10 iterations for distant initial bracket * to converge. * * @version $Revision$ $Date$ */public final class RiddersSolverTest extends TestCase {    /**     * Test the deprecated APIs.     */    @Deprecated    public void testDeprecated() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new RiddersSolver(f);        double min, max, expected, result, tolerance;        min = 3.0; max = 4.0; expected = FastMath.PI;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);        min = -1.0; max = 1.5; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new RiddersSolver();        double min, max, expected, result, tolerance;        min = 3.0; max = 4.0; expected = FastMath.PI;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -1.0; max = 1.5; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the quintic function.     */    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new RiddersSolver();        double min, max, expected, result, tolerance;        min = -0.4; max = 0.2; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = 0.75; max = 1.5; expected = 1.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -0.9; max = -0.2; expected = -0.5;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of solver for the exponential function.     */    public void testExpm1Function() throws MathException {        UnivariateRealFunction f = new Expm1Function();        UnivariateRealSolver solver = new RiddersSolver();        double min, max, expected, result, tolerance;        min = -1.0; max = 2.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -20.0; max = 10.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);        min = -50.0; max = 100.0; expected = 0.0;        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),                    FastMath.abs(expected * solver.getRelativeAccuracy()));        result = solver.solve(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the solver.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new RiddersSolver();        try {            // bad interval            solver.solve(f, 1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // no bracketing            solver.solve(f, 2, 3);            fail("Expecting IllegalArgumentException - no bracketing");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public final class BisectionSolverTest extends TestCase {    @Deprecated    public void testDeprecated() throws MathException {        UnivariateRealFunction f = new SinFunction();        double result;        UnivariateRealSolver solver = new BisectionSolver(f);        result = solver.solve(3, 4);        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        result = solver.solve(1, 4);        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());    }    public void testSinZero() throws MathException {        UnivariateRealFunction f = new SinFunction();        double result;        UnivariateRealSolver solver = new BisectionSolver();        result = solver.solve(f, 3, 4);        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        result = solver.solve(f, 1, 4);        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());    }   public void testQuinticZero() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        double result;        UnivariateRealSolver solver = new BisectionSolver();        result = solver.solve(f, -0.2, 0.2);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(f, -0.1, 0.3);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(f, -0.3, 0.45);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.3, 0.7);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.2, 0.6);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.05, 0.95);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.85, 1.25);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.8, 1.2);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.85, 1.75);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.55, 1.45);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.85, 5);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        assertEquals(result, solver.getResult(), 0);        assertTrue(solver.getIterationCount() > 0);    }    public void testMath369() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealSolver solver = new BisectionSolver();        assertEquals(FastMath.PI, solver.solve(f, 3.0, 3.2, 3.1), solver.getAbsoluteAccuracy());    }    /**     *     */    public void testSetFunctionValueAccuracy(){        double expected = 1.0e-2;        UnivariateRealSolver solver = new BisectionSolver();        solver.setFunctionValueAccuracy(expected);        assertEquals(expected, solver.getFunctionValueAccuracy(), 1.0e-2);    }    /**     *     */    public void testResetFunctionValueAccuracy(){        double newValue = 1.0e-2;        UnivariateRealSolver solver = new BisectionSolver();        double oldValue = solver.getFunctionValueAccuracy();        solver.setFunctionValueAccuracy(newValue);        solver.resetFunctionValueAccuracy();        assertEquals(oldValue, solver.getFunctionValueAccuracy(), 1.0e-2);    }    /**     *     */    public void testSetAbsoluteAccuracy(){        double expected = 1.0e-2;        UnivariateRealSolver solver = new BisectionSolver();        solver.setAbsoluteAccuracy(expected);        assertEquals(expected, solver.getAbsoluteAccuracy(), 1.0e-2);    }    /**     *     */    public void testResetAbsoluteAccuracy(){        double newValue = 1.0e-2;        UnivariateRealSolver solver = new BisectionSolver();        double oldValue = solver.getAbsoluteAccuracy();        solver.setAbsoluteAccuracy(newValue);        solver.resetAbsoluteAccuracy();        assertEquals(oldValue, solver.getAbsoluteAccuracy(), 1.0e-2);    }    /**     *     */    public void testSetMaximalIterationCount(){        int expected = 100;        UnivariateRealSolver solver = new BisectionSolver();        solver.setMaximalIterationCount(expected);        assertEquals(expected, solver.getMaximalIterationCount());    }    /**     *     */    public void testResetMaximalIterationCount(){        int newValue = 10000;        UnivariateRealSolver solver = new BisectionSolver();        int oldValue = solver.getMaximalIterationCount();        solver.setMaximalIterationCount(newValue);        solver.resetMaximalIterationCount();        assertEquals(oldValue, solver.getMaximalIterationCount());    }    /**     *     */    public void testSetRelativeAccuracy(){        double expected = 1.0e-2;        UnivariateRealSolver solver = new BisectionSolver();        solver.setRelativeAccuracy(expected);        assertEquals(expected, solver.getRelativeAccuracy(), 1.0e-2);    }    /**     *     */    public void testResetRelativeAccuracy(){        double newValue = 1.0e-2;        UnivariateRealSolver solver = new BisectionSolver();        double oldValue = solver.getRelativeAccuracy();        solver.setRelativeAccuracy(newValue);        solver.resetRelativeAccuracy();        assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.solvers;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public final class NewtonSolverTest extends TestCase {    @Deprecated    public void testDeprecated() throws MathException {        DifferentiableUnivariateRealFunction f = new SinFunction();        double result;        UnivariateRealSolver solver = new NewtonSolver(f);        result = solver.solve(3, 4);        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        result = solver.solve(1, 4);        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());        assertEquals(result, solver.getResult(), 0);        assertTrue(solver.getIterationCount() > 0);    }    /**    *    */   public void testSinZero() throws MathException {       DifferentiableUnivariateRealFunction f = new SinFunction();       double result;       UnivariateRealSolver solver = new NewtonSolver();       result = solver.solve(f, 3, 4);       assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());       result = solver.solve(f, 1, 4);       assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());       assertEquals(result, solver.getResult(), 0);       assertTrue(solver.getIterationCount() > 0);   }   /**     *     */    public void testQuinticZero() throws MathException {        DifferentiableUnivariateRealFunction f = new QuinticFunction();        double result;        UnivariateRealSolver solver = new NewtonSolver();        result = solver.solve(f, -0.2, 0.2);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(f, -0.1, 0.3);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(f, -0.3, 0.45);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.3, 0.7);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.2, 0.6);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.05, 0.95);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.85, 1.25);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.8, 1.2);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.85, 1.75);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.55, 1.45);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(f, 0.85, 5);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.integration;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * Testcase for Romberg integrator. * <p> * Romberg algorithm is very fast for good behavior integrand. Test runs * show that for a default relative accuracy of 1E-6, it generally takes * takes less than 5 iterations for the integral to converge. * * @version $Revision$ $Date$ */public final class RombergIntegratorTest extends TestCase {    /**     * Test of integrator for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new RombergIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = FastMath.PI; expected = 2;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = -FastMath.PI/3; max = 0; expected = -0.5;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of integrator for the quintic function.     */    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealIntegrator integrator = new RombergIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = 1; expected = -1.0/48;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = 0; max = 0.5; expected = 11.0/768;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the integrator.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new RombergIntegrator();        try {            // bad interval            integrator.integrate(f, 1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(5);            integrator.setMaximalIterationCount(4);            integrator.integrate(f, -1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(10);            integrator.setMaximalIterationCount(50);            integrator.integrate(f, -1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.integration;import java.util.Random;import org.apache.commons.math.ConvergenceException;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.analysis.polynomials.PolynomialFunction;import org.apache.commons.math.util.FastMath;import junit.framework.*;public class LegendreGaussIntegratorTestextends TestCase {    public LegendreGaussIntegratorTest(String name) {        super(name);    }    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new LegendreGaussIntegrator(5, 64);        integrator.setAbsoluteAccuracy(1.0e-10);        integrator.setRelativeAccuracy(1.0e-14);        integrator.setMinimalIterationCount(2);        integrator.setMaximalIterationCount(15);        double min, max, expected, result, tolerance;        min = 0; max = FastMath.PI; expected = 2;        tolerance = FastMath.max(integrator.getAbsoluteAccuracy(),                             FastMath.abs(expected * integrator.getRelativeAccuracy()));        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = -FastMath.PI/3; max = 0; expected = -0.5;        tolerance = FastMath.max(integrator.getAbsoluteAccuracy(),                FastMath.abs(expected * integrator.getRelativeAccuracy()));        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);    }    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealIntegrator integrator = new LegendreGaussIntegrator(3, 64);        double min, max, expected, result;        min = 0; max = 1; expected = -1.0/48;        result = integrator.integrate(f, min, max);        assertEquals(expected, result, 1.0e-16);        min = 0; max = 0.5; expected = 11.0/768;        result = integrator.integrate(f, min, max);        assertEquals(expected, result, 1.0e-16);        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;        result = integrator.integrate(f, min, max);        assertEquals(expected, result, 1.0e-16);    }    public void testExactIntegration()        throws ConvergenceException, FunctionEvaluationException {        Random random = new Random(86343623467878363l);        for (int n = 2; n < 6; ++n) {            LegendreGaussIntegrator integrator =                new LegendreGaussIntegrator(n, 64);            // an n points Gauss-Legendre integrator integrates 2n-1 degree polynoms exactly            for (int degree = 0; degree <= 2 * n - 1; ++degree) {                for (int i = 0; i < 10; ++i) {                    double[] coeff = new double[degree + 1];                    for (int k = 0; k < coeff.length; ++k) {                        coeff[k] = 2 * random.nextDouble() - 1;                    }                    PolynomialFunction p = new PolynomialFunction(coeff);                    double result    = integrator.integrate(p, -5.0, 15.0);                    double reference = exactIntegration(p, -5.0, 15.0);                    assertEquals(n + " " + degree + " " + i, reference, result, 1.0e-12 * (1.0 + FastMath.abs(reference)));                }            }        }    }    private double exactIntegration(PolynomialFunction p, double a, double b) {        final double[] coeffs = p.getCoefficients();        double yb = coeffs[coeffs.length - 1] / coeffs.length;        double ya = yb;        for (int i = coeffs.length - 2; i >= 0; --i) {            yb = yb * b + coeffs[i] / (i + 1);            ya = ya * a + coeffs[i] / (i + 1);        }        return yb * b - ya * a;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.integration;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * Testcase for trapezoid integrator. * <p> * Test runs show that for a default relative accuracy of 1E-6, it * generally takes 10 to 15 iterations for the integral to converge. * * @version $Revision$ $Date$ */public final class TrapezoidIntegratorTest extends TestCase {    /**     * Test of integrator for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new TrapezoidIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = FastMath.PI; expected = 2;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = -FastMath.PI/3; max = 0; expected = -0.5;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of integrator for the quintic function.     */    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealIntegrator integrator = new TrapezoidIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = 1; expected = -1.0/48;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = 0; max = 0.5; expected = 11.0/768;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the integrator.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new TrapezoidIntegrator();        try {            // bad interval            integrator.integrate(f, 1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(5);            integrator.setMaximalIterationCount(4);            integrator.integrate(f, -1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(10);            integrator.setMaximalIterationCount(99);            integrator.integrate(f, -1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.integration;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * Testcase for Simpson integrator. * <p> * Test runs show that for a default relative accuracy of 1E-6, it * generally takes 5 to 10 iterations for the integral to converge. * * @version $Revision$ $Date$ */public final class SimpsonIntegratorTest extends TestCase {    /**     * Test of integrator for the sine function.     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new SimpsonIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = FastMath.PI; expected = 2;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = -FastMath.PI/3; max = 0; expected = -0.5;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of integrator for the quintic function.     */    public void testQuinticFunction() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealIntegrator integrator = new SimpsonIntegrator();        double min, max, expected, result, tolerance;        min = 0; max = 1; expected = -1.0/48;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = 0; max = 0.5; expected = 11.0/768;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());        result = integrator.integrate(f, min, max);        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the integrator.     */    public void testParameters() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealIntegrator integrator = new SimpsonIntegrator();        try {            // bad interval            integrator.integrate(f, 1, -1);            fail("Expecting IllegalArgumentException - bad interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(5);            integrator.setMaximalIterationCount(4);            integrator.integrate(f, -1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // bad iteration limits            integrator.setMinimalIterationCount(10);            integrator.setMaximalIterationCount(99);            integrator.integrate(f, -1, 1);            fail("Expecting IllegalArgumentException - bad iteration limits");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.MathException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.analysis.BivariateRealFunction;import org.junit.Assert;import org.junit.Test;/** * Testcase for the smoothing bicubic interpolator. *  * @version $Revision$ $Date$ */public final class SmoothingPolynomialBicubicSplineInterpolatorTest {    /**     * Test preconditions.     */    @Test    public void testPreconditions() throws MathException {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2.5};        double[][] zval = new double[xval.length][yval.length];        BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(0);                @SuppressWarnings("unused")        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);                double[] wxval = new double[] {3, 2, 5, 6.5};        try {            p = interpolator.interpolate(wxval, yval, zval);            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException e) {            // Expected        }        double[] wyval = new double[] {-4, -3, -1, -1};        try {            p = interpolator.interpolate(xval, wyval, zval);            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException e) {            // Expected        }        double[][] wzval = new double[xval.length][yval.length + 1];        try {            p = interpolator.interpolate(xval, yval, wzval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wzval = new double[xval.length - 1][yval.length];        try {            p = interpolator.interpolate(xval, yval, wzval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wzval = new double[xval.length][yval.length - 1];        try {            p = interpolator.interpolate(xval, yval, wzval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }    }    /**     * Test of interpolator for a plane.     * <p>     * z = 2 x - 3 y + 5     */    @Test    public void testPlane() throws MathException {        BivariateRealFunction f = new BivariateRealFunction() {                public double value(double x, double y) {                    return 2 * x - 3 * y + 5                        + ((int) (FastMath.abs(5 * x + 3 * y)) % 2 == 0 ? 1 : -1);                }            };        BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(1);        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2, 2.5};        double[][] zval = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                zval[i][j] = f.value(xval[i], yval[j]);            }        }        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);        double x, y;        double expected, result;                x = 4;        y = -3;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("On sample point", expected, result, 2);        x = 4.5;        y = -1.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 2);        x = 3.5;        y = -3.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 2);    }    /**     * Test of interpolator for a paraboloid.     * <p>     * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5     */    @Test    public void testParaboloid() throws MathException {        BivariateRealFunction f = new BivariateRealFunction() {                public double value(double x, double y) {                    return 2 * x * x - 3 * y * y + 4 * x * y - 5                        + ((int) (FastMath.abs(5 * x + 3 * y)) % 2 == 0 ? 1 : -1);                }            };        BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(4);        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -2, -1, 0.5, 2.5};        double[][] zval = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                zval[i][j] = f.value(xval[i], yval[j]);            }        }        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);        double x, y;        double expected, result;        x = 5;        y = 0.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("On sample point", expected, result, 2);        x = 4.5;        y = -1.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 2);        x = 3.5;        y = -3.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 2);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.MathException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Test of the LoessInterpolator class. */public class LoessInterpolatorTest {    @Test    public void testOnOnePoint() throws MathException {        double[] xval = {0.5};        double[] yval = {0.7};        double[] res = new LoessInterpolator().smooth(xval, yval);        Assert.assertEquals(1, res.length);        Assert.assertEquals(0.7, res[0], 0.0);    }    @Test    public void testOnTwoPoints() throws MathException {        double[] xval = {0.5, 0.6};        double[] yval = {0.7, 0.8};        double[] res = new LoessInterpolator().smooth(xval, yval);        Assert.assertEquals(2, res.length);        Assert.assertEquals(0.7, res[0], 0.0);        Assert.assertEquals(0.8, res[1], 0.0);    }    @Test    public void testOnStraightLine() throws MathException {        double[] xval = {1,2,3,4,5};        double[] yval = {2,4,6,8,10};        LoessInterpolator li = new LoessInterpolator(0.6, 2, 1e-12);        double[] res = li.smooth(xval, yval);        Assert.assertEquals(5, res.length);        for(int i = 0; i < 5; ++i) {            Assert.assertEquals(yval[i], res[i], 1e-8);        }    }    @Test    public void testOnDistortedSine() throws MathException {        int numPoints = 100;        double[] xval = new double[numPoints];        double[] yval = new double[numPoints];        double xnoise = 0.1;        double ynoise = 0.2;        generateSineData(xval, yval, xnoise, ynoise);        LoessInterpolator li = new LoessInterpolator(0.3, 4, 1e-12);        double[] res = li.smooth(xval, yval);        // Check that the resulting curve differs from        // the "real" sine less than the jittered one        double noisyResidualSum = 0;        double fitResidualSum = 0;        for(int i = 0; i < numPoints; ++i) {            double expected = FastMath.sin(xval[i]);            double noisy = yval[i];            double fit = res[i];            noisyResidualSum += FastMath.pow(noisy - expected, 2);            fitResidualSum += FastMath.pow(fit - expected, 2);        }        Assert.assertTrue(fitResidualSum < noisyResidualSum);    }    @Test    public void testIncreasingBandwidthIncreasesSmoothness() throws MathException {        int numPoints = 100;        double[] xval = new double[numPoints];        double[] yval = new double[numPoints];        double xnoise = 0.1;        double ynoise = 0.1;        generateSineData(xval, yval, xnoise, ynoise);        // Check that variance decreases as bandwidth increases        double[] bandwidths = {0.1, 0.5, 1.0};        double[] variances = new double[bandwidths.length];        for (int i = 0; i < bandwidths.length; i++) {            double bw = bandwidths[i];            LoessInterpolator li = new LoessInterpolator(bw, 4, 1e-12);            double[] res = li.smooth(xval, yval);            for (int j = 1; j < res.length; ++j) {                variances[i] += FastMath.pow(res[j] - res[j-1], 2);            }        }        for(int i = 1; i < variances.length; ++i) {            Assert.assertTrue(variances[i] < variances[i-1]);        }    }    @Test    public void testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers() throws MathException {        int numPoints = 100;        double[] xval = new double[numPoints];        double[] yval = new double[numPoints];        double xnoise = 0.1;        double ynoise = 0.1;        generateSineData(xval, yval, xnoise, ynoise);        // Introduce a couple of outliers        yval[numPoints/3] *= 100;        yval[2 * numPoints/3] *= -100;        // Check that variance decreases as the number of robustness        // iterations increases        double[] variances = new double[4];        for (int i = 0; i < 4; i++) {            LoessInterpolator li = new LoessInterpolator(0.3, i, 1e-12);            double[] res = li.smooth(xval, yval);            for (int j = 1; j < res.length; ++j) {                variances[i] += FastMath.abs(res[j] - res[j-1]);            }        }        for(int i = 1; i < variances.length; ++i) {            Assert.assertTrue(variances[i] < variances[i-1]);        }    }    @Test(expected=MathException.class)    public void testUnequalSizeArguments() throws MathException {        new LoessInterpolator().smooth(new double[] {1,2,3}, new double[] {1,2,3,4});    }    @Test(expected=MathException.class)    public void testEmptyData() throws MathException {        new LoessInterpolator().smooth(new double[] {}, new double[] {});    }    @Test(expected=MathException.class)    public void testNonStrictlyIncreasing1() throws MathException {        new LoessInterpolator().smooth(new double[] {4,3,1,2}, new double[] {3,4,5,6});    }    @Test(expected=MathException.class)    public void testNonStrictlyIncreasing2() throws MathException {        new LoessInterpolator().smooth(new double[] {1,2,2,3}, new double[] {3,4,5,6});    }    @Test(expected=MathException.class)    public void testNotAllFiniteReal1() throws MathException {        new LoessInterpolator().smooth(new double[] {1,2,Double.NaN}, new double[] {3,4,5});    }    @Test(expected=MathException.class)    public void testNotAllFiniteReal2() throws MathException {        new LoessInterpolator().smooth(new double[] {1,2,Double.POSITIVE_INFINITY}, new double[] {3,4,5});    }    @Test(expected=MathException.class)    public void testNotAllFiniteReal3() throws MathException {        new LoessInterpolator().smooth(new double[] {1,2,Double.NEGATIVE_INFINITY}, new double[] {3,4,5});    }    @Test(expected=MathException.class)    public void testNotAllFiniteReal4() throws MathException {        new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.NaN});    }    @Test(expected=MathException.class)    public void testNotAllFiniteReal5() throws MathException {        new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.POSITIVE_INFINITY});    }    @Test(expected=MathException.class)    public void testNotAllFiniteReal6() throws MathException {        new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.NEGATIVE_INFINITY});    }    @Test(expected=MathException.class)    public void testInsufficientBandwidth() throws MathException {        LoessInterpolator li = new LoessInterpolator(0.1, 3, 1e-12);        li.smooth(new double[] {1,2,3,4,5,6,7,8,9,10,11,12}, new double[] {1,2,3,4,5,6,7,8,9,10,11,12});    }    @Test(expected=MathException.class)    public void testCompletelyIncorrectBandwidth1() throws MathException {        new LoessInterpolator(-0.2, 3, 1e-12);    }    @Test(expected=MathException.class)    public void testCompletelyIncorrectBandwidth2() throws MathException {        new LoessInterpolator(1.1, 3, 1e-12);    }    @Test    public void testMath296withoutWeights() throws MathException {        double[] xval = {                0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0,                 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0};        double[] yval = {                0.47, 0.48, 0.55, 0.56, -0.08, -0.04, -0.07, -0.07,                -0.56, -0.46, -0.56, -0.52, -3.03, -3.08, -3.09,                -3.04, 3.54, 3.46, 3.36, 3.35};        // Output from R, rounded to .001        double[] yref = {                0.461, 0.499, 0.541, 0.308, 0.175, -0.042, -0.072,                -0.196, -0.311, -0.446, -0.557, -1.497, -2.133,                -3.08, -3.09, -0.621, 0.982, 3.449, 3.389, 3.336        };        LoessInterpolator li = new LoessInterpolator(0.3, 4, 1e-12);        double[] res = li.smooth(xval, yval);        Assert.assertEquals(xval.length, res.length);        for(int i = 0; i < res.length; ++i) {            Assert.assertEquals(yref[i], res[i], 0.02);        }    }    private void generateSineData(double[] xval, double[] yval, double xnoise, double ynoise) {        double dx = 2 * FastMath.PI / xval.length;        double x = 0;        for(int i = 0; i < xval.length; ++i) {            xval[i] = x;            yval[i] = FastMath.sin(x) + (2 * FastMath.random() - 1) * ynoise;            x += dx * (1 + (2 * FastMath.random() - 1) * xnoise);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.MathException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.analysis.TrivariateRealFunction;import org.junit.Assert;import org.junit.Test;/** * Testcase for the tricubic interpolator. *  * @version $Revision$ $Date$  */public final class TricubicSplineInterpolatorTest {    /**     * Test preconditions.     */    @Test    public void testPreconditions() throws MathException {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2.5};        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};        double[][][] fval = new double[xval.length][yval.length][zval.length];        TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator();                @SuppressWarnings("unused")        TrivariateRealFunction p = interpolator.interpolate(xval, yval, zval, fval);                double[] wxval = new double[] {3, 2, 5, 6.5};        try {            p = interpolator.interpolate(wxval, yval, zval, fval);            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException e) {            // Expected        }        double[] wyval = new double[] {-4, -3, -1, -1};        try {            p = interpolator.interpolate(xval, wyval, zval, fval);            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException e) {            // Expected        }        double[] wzval = new double[] {-12, -8, -5.5, -3, -4, 2.5};        try {            p = interpolator.interpolate(xval, yval, wzval, fval);            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException e) {            // Expected        }        double[][][] wfval = new double[xval.length][yval.length + 1][zval.length];        try {            p = interpolator.interpolate(xval, yval, zval, wfval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wfval = new double[xval.length - 1][yval.length][zval.length];        try {            p = interpolator.interpolate(xval, yval, zval, wfval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wfval = new double[xval.length][yval.length][zval.length - 1];        try {            p = interpolator.interpolate(xval, yval, zval, wfval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }    }    /**     * Test of interpolator for a plane.     * <p>     * f(x, y, z) = 2 x - 3 y - z + 5     */    @Test    public void testPlane() throws MathException {        TrivariateRealFunction f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return 2 * x - 3 * y - z + 5;                }            };        TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator();        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2, 2.5};        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};        double[][][] fval = new double[xval.length][yval.length][zval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    fval[i][j][k] = f.value(xval[i], yval[j], zval[k]);                }            }        }        TrivariateRealFunction p = interpolator.interpolate(xval, yval, zval, fval);        double x, y, z;        double expected, result;                x = 4;        y = -3;        z = 0;        expected = f.value(x, y, z);        result = p.value(x, y, z);        Assert.assertEquals("On sample point", expected, result, 1e-15);        x = 4.5;        y = -1.5;        z = -4.25;        expected = f.value(x, y, z);        result = p.value(x, y, z);        Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 0.3);        x = 3.5;        y = -3.5;        z = -10;        expected = f.value(x, y, z);        result = p.value(x, y, z);        Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 0.3);    }    /**     * Test of interpolator for a sine wave.     * <p>     * <p>     *  f(x, y, z) = a cos [&omega; z - k<sub>y</sub> x - k<sub>y</sub> y]     * </p>     * with A = 0.2, &omega; = 0.5, k<sub>x</sub> = 2, k<sub>y</sub> = 1.     */    @Test    public void testWave() throws MathException {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2, 2.5};        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 4};        final double a = 0.2;        final double omega = 0.5;        final double kx = 2;        final double ky = 1;        // Function values        TrivariateRealFunction f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return a * FastMath.cos(omega * z - kx * x - ky * y);                }            };                double[][][] fval = new double[xval.length][yval.length][zval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    fval[i][j][k] = f.value(xval[i], yval[j], zval[k]);                }            }        }        TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator();        TrivariateRealFunction p = interpolator.interpolate(xval, yval, zval, fval);        double x, y, z;        double expected, result;                x = 4;        y = -3;        z = 0;        expected = f.value(x, y, z);        result = p.value(x, y, z);        Assert.assertEquals("On sample point",                            expected, result, 1e-12);        x = 4.5;        y = -1.5;        z = -4.25;        expected = f.value(x, y, z);        result = p.value(x, y, z);        Assert.assertEquals("Half-way between sample points (middle of the patch)",                            expected, result, 0.1);        x = 3.5;        y = -3.5;        z = -10;        expected = f.value(x, y, z);        result = p.value(x, y, z);        Assert.assertEquals("Half-way between sample points (border of the patch)",                            expected, result, 0.1);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.Expm1Function;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * Testcase for Divided Difference interpolator. * <p> * The error of polynomial interpolation is *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n! * where f^(n) is the n-th derivative of the approximated function and * zeta is some point in the interval determined by x[] and z. * <p> * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound * it and use the absolute value upper bound for estimates. For reference, * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2. * * @version $Revision$ $Date$ */public final class DividedDifferenceInterpolatorTest extends TestCase {    /**     * Test of interpolator for the sine function.     * <p>     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();        double x[], y[], z, expected, result, tolerance;        // 6 interpolating points on interval [0, 2*PI]        int n = 6;        double min = 0.0, max = 2 * FastMath.PI;        x = new double[n];        y = new double[n];        for (int i = 0; i < n; i++) {            x[i] = min + i * (max - min) / n;            y[i] = f.value(x[i]);        }        double derivativebound = 1.0;        UnivariateRealFunction p = interpolator.interpolate(x, y);        z = FastMath.PI / 4; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = FastMath.PI * 1.5; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);    }    /**     * Test of interpolator for the exponential function.     * <p>     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]     */    public void testExpm1Function() throws MathException {        UnivariateRealFunction f = new Expm1Function();        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();        double x[], y[], z, expected, result, tolerance;        // 5 interpolating points on interval [-1, 1]        int n = 5;        double min = -1.0, max = 1.0;        x = new double[n];        y = new double[n];        for (int i = 0; i < n; i++) {            x[i] = min + i * (max - min) / n;            y[i] = f.value(x[i]);        }        double derivativebound = FastMath.E;        UnivariateRealFunction p = interpolator.interpolate(x, y);        z = 0.0; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = 0.5; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = -0.5; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the interpolator.     */    public void testParameters() throws Exception {        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();        try {            // bad abscissas array            double x[] = { 1.0, 2.0, 2.0, 4.0 };            double y[] = { 0.0, 4.0, 4.0, 2.5 };            UnivariateRealFunction p = interpolator.interpolate(x, y);            p.value(0.0);            fail("Expecting MathException - bad abscissas array");        } catch (MathException ex) {            // expected        }    }    /**     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!     */    protected double partialerror(double x[], double z) throws        IllegalArgumentException {        if (x.length < 1) {            throw new IllegalArgumentException                ("Interpolation array cannot be empty.");        }        double out = 1;        for (int i = 0; i < x.length; i++) {            out *= (z - x[i]) / (i + 1);        }        return out;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;/** * Testcase for the "microsphere projection" interpolator. * * @version $Revision$ $Date$ */public final class MicrosphereInterpolatorTest {    /**     * Test of interpolator for a plane.     * <p>     * y = 2 x<sub>1</sub> - 3 x<sub>2</sub> + 5     */    @Test    public void testLinearFunction2D() throws MathException {        MultivariateRealFunction f = new MultivariateRealFunction() {                public double value(double[] x) {                    if (x.length != 2) {                        throw new IllegalArgumentException();                    }                    return 2 * x[0] - 3 * x[1] + 5;                }            };        MultivariateRealInterpolator interpolator = new MicrosphereInterpolator();        // Interpolating points in [-1, 1][-1, 1] by steps of 1.        final int n = 9;        final int dim = 2;        double[][] x = new double[n][dim];        double[] y = new double[n];        int index = 0;        for (int i = -1; i <= 1; i++) {            for (int j = -1; j <= 1; j++) {                x[index][0] = i;                x[index][1] = j;                y[index] = f.value(x[index]);                ++index;            }        }        MultivariateRealFunction p = interpolator.interpolate(x, y);        double[] c = new double[dim];        double expected, result;        c[0] = 0;        c[1] = 0;        expected = f.value(c);        result = p.value(c);        Assert.assertEquals("On sample point", expected, result, FastMath.ulp(1d));        c[0] = 0 + 1e-5;        c[1] = 1 - 1e-5;        expected = f.value(c);        result = p.value(c);        Assert.assertEquals("1e-5 away from sample point", expected, result, 1e-4);    }    /**     * Test of interpolator for a quadratic function.     * <p>     * y = 2 x<sub>1</sub><sup>2</sup> - 3 x<sub>2</sub><sup>2</sup>     *     + 4 x<sub>1</sub> x<sub>2</sub> - 5     */    @Test    public void testParaboloid2D() throws MathException {        MultivariateRealFunction f = new MultivariateRealFunction() {                public double value(double[] x) {                    if (x.length != 2) {                        throw new IllegalArgumentException();                    }                    return 2 * x[0] * x[0] - 3 * x[1] * x[1] + 4 * x[0] * x[1] - 5;                }            };        MultivariateRealInterpolator interpolator = new MicrosphereInterpolator();        // Interpolating points in [-10, 10][-10, 10] by steps of 2.        final int n = 121;        final int dim = 2;        double[][] x = new double[n][dim];        double[] y = new double[n];        int index = 0;        for (int i = -10; i <= 10; i += 2) {            for (int j = -10; j <= 10; j += 2) {                x[index][0] = i;                x[index][1] = j;                y[index] = f.value(x[index]);                ++index;            }        }        MultivariateRealFunction p = interpolator.interpolate(x, y);        double[] c = new double[dim];        double expected, result;        c[0] = 0;        c[1] = 0;        expected = f.value(c);        result = p.value(c);        Assert.assertEquals("On sample point", expected, result, FastMath.ulp(1d));        c[0] = 2 + 1e-5;        c[1] = 2 - 1e-5;        expected = f.value(c);        result = p.value(c);        Assert.assertEquals("1e-5 away from sample point", expected, result, 1e-3);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.MathException;import org.apache.commons.math.DimensionMismatchException;import org.apache.commons.math.analysis.BivariateRealFunction;import org.junit.Assert;import org.junit.Test;/** * Testcase for the bicubic function. *  * @version $Revision: 821626 $ $Date: 2009-10-04 23:57:30 +0200 (Sun, 04 Oct 2009) $  */public final class BicubicSplineInterpolatingFunctionTest {    /**     * Test preconditions.     */    @Test    public void testPreconditions() throws MathException {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2.5};        double[][] zval = new double[xval.length][yval.length];        @SuppressWarnings("unused")        BivariateRealFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval,                                                                           zval, zval, zval);                double[] wxval = new double[] {3, 2, 5, 6.5};        try {            bcf = new BicubicSplineInterpolatingFunction(wxval, yval, zval, zval, zval, zval);            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException e) {            // Expected        }        double[] wyval = new double[] {-4, -1, -1, 2.5};        try {            bcf = new BicubicSplineInterpolatingFunction(xval, wyval, zval, zval, zval, zval);            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException e) {            // Expected        }        double[][] wzval = new double[xval.length][yval.length - 1];        try {            bcf = new BicubicSplineInterpolatingFunction(xval, yval, wzval, zval, zval, zval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, wzval, zval, zval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, wzval, zval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, zval, wzval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wzval = new double[xval.length - 1][yval.length];        try {            bcf = new BicubicSplineInterpolatingFunction(xval, yval, wzval, zval, zval, zval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, wzval, zval, zval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, wzval, zval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, zval, wzval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }    }    /**     * Test for a plane.     * <p>     * z = 2 x - 3 y + 5     */    @Test    public void testPlane() throws MathException {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2, 2.5};        // Function values        BivariateRealFunction f = new BivariateRealFunction() {                public double value(double x, double y) {                    return 2 * x - 3 * y + 5;                }            };        double[][] zval = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                zval[i][j] = f.value(xval[i], yval[j]);            }        }        // Partial derivatives with respect to x        double[][] dZdX = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                dZdX[i][j] = 2;            }        }        // Partial derivatives with respect to y        double[][] dZdY = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                dZdY[i][j] = -3;            }        }        // Partial cross-derivatives        double[][] dZdXdY = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                dZdXdY[i][j] = 0;            }        }        BivariateRealFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval,                                                                           dZdX, dZdY, dZdXdY);        double x, y;        double expected, result;        x = 4;        y = -3;        expected = f.value(x, y);        result = bcf.value(x, y);        Assert.assertEquals("On sample point",                            expected, result, 1e-15);        x = 4.5;        y = -1.5;        expected = f.value(x, y);        result = bcf.value(x, y);        Assert.assertEquals("Half-way between sample points (middle of the patch)",                            expected, result, 0.3);        x = 3.5;        y = -3.5;        expected = f.value(x, y);        result = bcf.value(x, y);        Assert.assertEquals("Half-way between sample points (border of the patch)",                            expected, result, 0.3);    }    /**     * Test for a paraboloid.     * <p>     * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5     */    @Test    public void testParaboloid() throws MathException {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2, 2.5};        // Function values        BivariateRealFunction f = new BivariateRealFunction() {                public double value(double x, double y) {                    return 2 * x * x - 3 * y * y + 4 * x * y - 5;                }            };        double[][] zval = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                zval[i][j] = f.value(xval[i], yval[j]);            }        }        // Partial derivatives with respect to x        double[][] dZdX = new double[xval.length][yval.length];        BivariateRealFunction dfdX = new BivariateRealFunction() {                public double value(double x, double y) {                    return 4 * (x + y);                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                dZdX[i][j] = dfdX.value(xval[i], yval[j]);            }        }        // Partial derivatives with respect to y        double[][] dZdY = new double[xval.length][yval.length];        BivariateRealFunction dfdY = new BivariateRealFunction() {                public double value(double x, double y) {                    return 4 * x - 6 * y;                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                dZdY[i][j] = dfdY.value(xval[i], yval[j]);            }        }        // Partial cross-derivatives        double[][] dZdXdY = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                dZdXdY[i][j] = 4;            }        }        BivariateRealFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval,                                                                           dZdX, dZdY, dZdXdY);        double x, y;        double expected, result;                x = 4;        y = -3;        expected = f.value(x, y);        result = bcf.value(x, y);        Assert.assertEquals("On sample point",                            expected, result, 1e-15);        x = 4.5;        y = -1.5;        expected = f.value(x, y);        result = bcf.value(x, y);        Assert.assertEquals("Half-way between sample points (middle of the patch)",                            expected, result, 2);        x = 3.5;        y = -3.5;        expected = f.value(x, y);        result = bcf.value(x, y);        Assert.assertEquals("Half-way between sample points (border of the patch)",                            expected, result, 2);    }    /**     * Test for partial derivatives of {@link BicubicSplineFunction}.     * <p>     * f(x, y) = &Sigma;<sub>i</sub>&Sigma;<sub>j</sub> (i+1) (j+2) x<sup>i</sup> y<sup>j</sup>     */    @Test    public void testSplinePartialDerivatives() throws MathException {        final int N = 4;        final double[] coeff = new double[16];        for (int i = 0; i < N; i++) {            for (int j = 0; j < N; j++) {                coeff[i + N * j] = (i + 1) * (j + 2);            }        }        final BicubicSplineFunction f = new BicubicSplineFunction(coeff);        BivariateRealFunction derivative;        final double x = 0.435;        final double y = 0.776;        final double tol = 1e-13;        derivative = new BivariateRealFunction() {                public double value(double x, double y) {                    final double x2 = x * x;                    final double y2 = y * y;                    final double y3 = y2 * y;                    final double yFactor = 2 + 3 * y + 4 * y2 + 5 * y3;                    return yFactor * (2 + 6 * x + 12 * x2);                }            };        Assert.assertEquals("dFdX", derivative.value(x, y),                            f.partialDerivativeX().value(x, y), tol);                derivative = new BivariateRealFunction() {                public double value(double x, double y) {                    final double x2 = x * x;                    final double x3 = x2 * x;                    final double y2 = y * y;                    final double xFactor = 1 + 2 * x + 3 * x2 + 4 * x3;                    return xFactor * (3 + 8 * y + 15 * y2);                }            };        Assert.assertEquals("dFdY", derivative.value(x, y),                            f.partialDerivativeY().value(x, y), tol);        derivative = new BivariateRealFunction() {                public double value(double x, double y) {                    final double y2 = y * y;                    final double y3 = y2 * y;                    final double yFactor = 2 + 3 * y + 4 * y2 + 5 * y3;                    return yFactor * (6 + 24 * x);                }            };        Assert.assertEquals("d2FdX2", derivative.value(x, y),                            f.partialDerivativeXX().value(x, y), tol);        derivative = new BivariateRealFunction() {                public double value(double x, double y) {                    final double x2 = x * x;                    final double x3 = x2 * x;                    final double xFactor = 1 + 2 * x + 3 * x2 + 4 * x3;                    return xFactor * (8 + 30 * y);                }            };        Assert.assertEquals("d2FdY2", derivative.value(x, y),                            f.partialDerivativeYY().value(x, y), tol);        derivative = new BivariateRealFunction() {                public double value(double x, double y) {                    final double x2 = x * x;                    final double y2 = y * y;                    final double yFactor = 3 + 8 * y + 15 * y2;                    return yFactor * (2 + 6 * x + 12 * x2);                }            };        Assert.assertEquals("d2FdXdY", derivative.value(x, y),                            f.partialDerivativeXY().value(x, y), tol);    }    /**     * Test that the partial derivatives computed from a     * {@link BicubicSplineInterpolatingFunction} match the input data.     * <p>     * f(x, y) = 5     *           - 3 x + 2 y     *           - x y + 2 x<sup>2</sup> - 3 y<sup>2</sup>     *           + 4 x<sup>2</sup> y - x y<sup>2</sup> - 3 x<sup>3</sup> + y<sup>3</sup>     */    @Test    public void testMatchingPartialDerivatives() throws MathException {        final int sz = 21;        double[] val = new double[sz];        // Coordinate values        final double delta = 1d / (sz - 1);        for (int i = 0; i < sz; i++) {            val[i] = i * delta;        }        // Function values        BivariateRealFunction f = new BivariateRealFunction() {                public double value(double x, double y) {                    final double x2 = x * x;                    final double x3 = x2 * x;                    final double y2 = y * y;                    final double y3 = y2 * y;                    return 5                        - 3 * x + 2 * y                        - x * y + 2 * x2 - 3 * y2                        + 4 * x2 * y - x * y2 - 3 * x3 + y3;                }            };        double[][] fval = new double[sz][sz];        for (int i = 0; i < sz; i++) {            for (int j = 0; j < sz; j++) {                fval[i][j] = f.value(val[i], val[j]);            }        }        // Partial derivatives with respect to x        double[][] dFdX = new double[sz][sz];        BivariateRealFunction dfdX = new BivariateRealFunction() {                public double value(double x, double y) {                    final double x2 = x * x;                    final double y2 = y * y;                                        return - 3 - y + 4 * x + 8 * x * y - y2 - 9 * x2;                }            };        for (int i = 0; i < sz; i++) {            for (int j = 0; j < sz; j++) {                dFdX[i][j] = dfdX.value(val[i], val[j]);            }        }        // Partial derivatives with respect to y        double[][] dFdY = new double[sz][sz];        BivariateRealFunction dfdY = new BivariateRealFunction() {                public double value(double x, double y) {                    final double x2 = x * x;                    final double y2 = y * y;                                        return 2 - x - 6 * y + 4 * x2 - 2 * x * y + 3 * y2;                }            };        for (int i = 0; i < sz; i++) {            for (int j = 0; j < sz; j++) {                dFdY[i][j] = dfdY.value(val[i], val[j]);            }        }        // Partial cross-derivatives        double[][] d2FdXdY = new double[sz][sz];        BivariateRealFunction d2fdXdY = new BivariateRealFunction() {                public double value(double x, double y) {                    return -1 + 8 * x - 2 * y;                }            };        for (int i = 0; i < sz; i++) {            for (int j = 0; j < sz; j++) {                d2FdXdY[i][j] = d2fdXdY.value(val[i], val[j]);            }        }        BicubicSplineInterpolatingFunction bcf            = new BicubicSplineInterpolatingFunction(val, val, fval, dFdX, dFdY, d2FdXdY);        double x, y;        double expected, result;        final double tol = 1e-12;        for (int i = 0; i < sz; i++) {            x = val[i];            for (int j = 0; j < sz; j++) {                y = val[j];                                expected = dfdX.value(x, y);                result = bcf.partialDerivativeX(x, y);                Assert.assertEquals(x + " " + y + " dFdX", expected, result, tol);                expected = dfdY.value(x, y);                result = bcf.partialDerivativeY(x, y);                Assert.assertEquals(x + " " + y + " dFdY", expected, result, tol);                                expected = d2fdXdY.value(x, y);                result = bcf.partialDerivativeXY(x, y);                Assert.assertEquals(x + " " + y + " d2FdXdY", expected, result, tol);            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.MathException;import org.apache.commons.math.exception.NonMonotonousSequenceException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.analysis.polynomials.PolynomialFunction;import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;import org.junit.Assert;import org.junit.Test;/** * Test the LinearInterpolator. */public class LinearInterpolatorTest {    /** error tolerance for spline interpolator value at knot points */    protected double knotTolerance = 1E-12;    /** error tolerance for interpolating polynomial coefficients */    protected double coefficientTolerance = 1E-6;    /** error tolerance for interpolated values */    protected double interpolationTolerance = 1E-12;    @Test    public void testInterpolateLinearDegenerateTwoSegment()        throws Exception {        double x[] = { 0.0, 0.5, 1.0 };        double y[] = { 0.0, 0.5, 1.0 };        UnivariateRealInterpolator i = new LinearInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 1d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        // Check interpolation        Assert.assertEquals(0.0,f.value(0.0), interpolationTolerance);        Assert.assertEquals(0.4,f.value(0.4), interpolationTolerance);        Assert.assertEquals(1.0,f.value(1.0), interpolationTolerance);    }    @Test    public void testInterpolateLinearDegenerateThreeSegment()        throws Exception {        double x[] = { 0.0, 0.5, 1.0, 1.5 };        double y[] = { 0.0, 0.5, 1.0, 1.5 };        UnivariateRealInterpolator i = new LinearInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 1d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[2], 1d};        TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);        // Check interpolation        Assert.assertEquals(0,f.value(0), interpolationTolerance);        Assert.assertEquals(1.4,f.value(1.4), interpolationTolerance);        Assert.assertEquals(1.5,f.value(1.5), interpolationTolerance);    }    @Test    public void testInterpolateLinear() throws Exception {        double x[] = { 0.0, 0.5, 1.0 };        double y[] = { 0.0, 0.5, 0.0 };        UnivariateRealInterpolator i = new LinearInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], -1d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);    }    @Test    public void testIllegalArguments() throws MathException {        // Data set arrays of different size.        UnivariateRealInterpolator i = new LinearInterpolator();        try {            double xval[] = { 0.0, 1.0 };            double yval[] = { 0.0, 1.0, 2.0 };            i.interpolate(xval, yval);            Assert.fail("Failed to detect data set array with different sizes.");        } catch (DimensionMismatchException iae) {            // Expected.        }        // X values not sorted.        try {            double xval[] = { 0.0, 1.0, 0.5 };            double yval[] = { 0.0, 1.0, 2.0 };            i.interpolate(xval, yval);            Assert.fail("Failed to detect unsorted arguments.");        } catch (NonMonotonousSequenceException iae) {            // Expected.        }        // Not enough data to interpolate.        try {            double xval[] = { 0.0 };            double yval[] = { 0.0 };            i.interpolate(xval, yval);            Assert.fail("Failed to detect unsorted arguments.");        } catch (NumberIsTooSmallException iae) {            // Expected.        }    }    /**     * verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length.     */    protected void verifyInterpolation(UnivariateRealFunction f, double x[], double y[])        throws Exception{        for (int i = 0; i < x.length; i++) {            Assert.assertEquals(f.value(x[i]), y[i], knotTolerance);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.MathException;import org.apache.commons.math.exception.NonMonotonousSequenceException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.NumberIsTooSmallException;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.TestUtils;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.analysis.polynomials.PolynomialFunction;import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;import org.junit.Assert;import org.junit.Test;/** * Test the SplineInterpolator. * * @version $Revision$ $Date$ */public class SplineInterpolatorTest {    /** error tolerance for spline interpolator value at knot points */    protected double knotTolerance = 1E-12;    /** error tolerance for interpolating polynomial coefficients */    protected double coefficientTolerance = 1E-6;    /** error tolerance for interpolated values -- high value is from sin test */    protected double interpolationTolerance = 1E-2;    @Test    public void testInterpolateLinearDegenerateTwoSegment()        throws Exception {        double x[] = { 0.0, 0.5, 1.0 };        double y[] = { 0.0, 0.5, 1.0 };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        verifyConsistency((PolynomialSplineFunction) f, x);        // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 1d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        // Check interpolation        Assert.assertEquals(0.0,f.value(0.0), interpolationTolerance);        Assert.assertEquals(0.4,f.value(0.4), interpolationTolerance);        Assert.assertEquals(1.0,f.value(1.0), interpolationTolerance);    }    @Test    public void testInterpolateLinearDegenerateThreeSegment()        throws Exception {        double x[] = { 0.0, 0.5, 1.0, 1.5 };        double y[] = { 0.0, 0.5, 1.0, 1.5 };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 1d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[2], 1d};        TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);        // Check interpolation        Assert.assertEquals(0,f.value(0), interpolationTolerance);        Assert.assertEquals(1.4,f.value(1.4), interpolationTolerance);        Assert.assertEquals(1.5,f.value(1.5), interpolationTolerance);    }    @Test    public void testInterpolateLinear() throws Exception {        double x[] = { 0.0, 0.5, 1.0 };        double y[] = { 0.0, 0.5, 0.0 };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        verifyConsistency((PolynomialSplineFunction) f, x);        // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1.5d, 0d, -2d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 0d, -3d, 2d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);    }    @Test    public void testInterpolateSin() throws Exception {        double x[] =            {                0.0,                FastMath.PI / 6d,                FastMath.PI / 2d,                5d * FastMath.PI / 6d,                FastMath.PI,                7d * FastMath.PI / 6d,                3d * FastMath.PI / 2d,                11d * FastMath.PI / 6d,                2.d * FastMath.PI };        double y[] = { 0d, 0.5d, 1d, 0.5d, 0d, -0.5d, -1d, -0.5d, 0d };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        verifyConsistency((PolynomialSplineFunction) f, x);        /* Check coefficients against values computed using R (version 1.8.1, Red Hat Linux 9)         *         * To replicate in R:         *     x[1] <- 0         *     x[2] <- pi / 6, etc, same for y[] (could use y <- scan() for y values)         *     g <- splinefun(x, y, "natural")         *     splinecoef <- eval(expression(z), envir = environment(g))         *     print(splinecoef)         */        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1.002676d, 0d, -0.17415829d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 8.594367e-01, -2.735672e-01, -0.08707914};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[2], 1.471804e-17,-5.471344e-01, 0.08707914};        TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[3], -8.594367e-01, -2.735672e-01, 0.17415829};        TestUtils.assertEquals(polynomials[3].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[4], -1.002676, 6.548562e-17, 0.17415829};        TestUtils.assertEquals(polynomials[4].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[5], -8.594367e-01, 2.735672e-01, 0.08707914};        TestUtils.assertEquals(polynomials[5].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[6], 3.466465e-16, 5.471344e-01, -0.08707914};        TestUtils.assertEquals(polynomials[6].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[7], 8.594367e-01, 2.735672e-01, -0.17415829};        TestUtils.assertEquals(polynomials[7].getCoefficients(), target, coefficientTolerance);        //Check interpolation        Assert.assertEquals(FastMath.sqrt(2d) / 2d,f.value(FastMath.PI/4d),interpolationTolerance);        Assert.assertEquals(FastMath.sqrt(2d) / 2d,f.value(3d*FastMath.PI/4d),interpolationTolerance);    }    @Test    public void testIllegalArguments() throws MathException {        // Data set arrays of different size.        UnivariateRealInterpolator i = new SplineInterpolator();        try {            double xval[] = { 0.0, 1.0 };            double yval[] = { 0.0, 1.0, 2.0 };            i.interpolate(xval, yval);            Assert.fail("Failed to detect data set array with different sizes.");        } catch (DimensionMismatchException iae) {            // Expected.        }        // X values not sorted.        try {            double xval[] = { 0.0, 1.0, 0.5 };            double yval[] = { 0.0, 1.0, 2.0 };            i.interpolate(xval, yval);            Assert.fail("Failed to detect unsorted arguments.");        } catch (NonMonotonousSequenceException iae) {            // Expected.        }        // Not enough data to interpolate.        try {            double xval[] = { 0.0, 1.0 };            double yval[] = { 0.0, 1.0 };            i.interpolate(xval, yval);            Assert.fail("Failed to detect unsorted arguments.");        } catch (NumberIsTooSmallException iae) {            // Expected.        }    }    /**     * verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length.     */    protected void verifyInterpolation(UnivariateRealFunction f, double x[], double y[])        throws Exception{        for (int i = 0; i < x.length; i++) {            Assert.assertEquals(f.value(x[i]), y[i], knotTolerance);        }    }    /**     * Verifies that interpolating polynomials satisfy consistency requirement:     *    adjacent polynomials must agree through two derivatives at knot points     */    protected void verifyConsistency(PolynomialSplineFunction f, double x[])        throws Exception {        PolynomialFunction polynomials[] = f.getPolynomials();        for (int i = 1; i < x.length - 2; i++) {            // evaluate polynomials and derivatives at x[i + 1]            Assert.assertEquals(polynomials[i].value(x[i +1] - x[i]), polynomials[i + 1].value(0), 0.1);            Assert.assertEquals(polynomials[i].derivative().value(x[i +1] - x[i]),                                polynomials[i + 1].derivative().value(0), 0.5);            Assert.assertEquals(polynomials[i].polynomialDerivative().derivative().value(x[i +1] - x[i]),                                polynomials[i + 1].polynomialDerivative().derivative().value(0), 0.5);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.MathException;import org.apache.commons.math.DimensionMismatchException;import org.apache.commons.math.analysis.BivariateRealFunction;import org.junit.Assert;import org.junit.Test;/** * Testcase for the bicubic interpolator. *  * @version $Revision: 821626 $ $Date: 2009-10-04 23:57:30 +0200 (Sun, 04 Oct 2009) $  */public final class BicubicSplineInterpolatorTest {    /**     * Test preconditions.     */    @Test    public void testPreconditions() throws MathException {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2.5};        double[][] zval = new double[xval.length][yval.length];        BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator();                @SuppressWarnings("unused")        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);                double[] wxval = new double[] {3, 2, 5, 6.5};        try {            p = interpolator.interpolate(wxval, yval, zval);            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException e) {            // Expected        }        double[] wyval = new double[] {-4, -3, -1, -1};        try {            p = interpolator.interpolate(xval, wyval, zval);            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException e) {            // Expected        }        double[][] wzval = new double[xval.length][yval.length + 1];        try {            p = interpolator.interpolate(xval, yval, wzval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wzval = new double[xval.length - 1][yval.length];        try {            p = interpolator.interpolate(xval, yval, wzval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }    }    /**     * Test of interpolator for a plane.     * <p>     * z = 2 x - 3 y + 5     */    @Test    public void testPlane() throws MathException {        BivariateRealFunction f = new BivariateRealFunction() {                public double value(double x, double y) {                    return 2 * x - 3 * y + 5;                }            };        BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator();        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2, 2.5};        double[][] zval = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                zval[i][j] = f.value(xval[i], yval[j]);            }        }        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);        double x, y;        double expected, result;                x = 4;        y = -3;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("On sample point", expected, result, 1e-15);        x = 4.5;        y = -1.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 0.3);        x = 3.5;        y = -3.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 0.3);    }    /**     * Test of interpolator for a paraboloid.     * <p>     * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5     */    @Test    public void testParaboloid() throws MathException {        BivariateRealFunction f = new BivariateRealFunction() {                public double value(double x, double y) {                    return 2 * x * x - 3 * y * y + 4 * x * y - 5;                }            };        BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator();        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -2, -1, 0.5, 2.5};        double[][] zval = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                zval[i][j] = f.value(xval[i], yval[j]);            }        }        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);        double x, y;        double expected, result;                x = 5;        y = 0.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("On sample point", expected, result, 1e-13);        x = 4.5;        y = -1.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 0.2);        x = 3.5;        y = -3.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 0.2);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.MathException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.analysis.TrivariateRealFunction;import org.junit.Assert;import org.junit.Test;/** * Testcase for the bicubic function. *  * @version $Revision: 821626 $ $Date: 2009-10-04 23:57:30 +0200 (Sun, 04 Oct 2009) $  */public final class TricubicSplineInterpolatingFunctionTest {    /**     * Test preconditions.     */    @Test    public void testPreconditions() throws MathException {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2.5};        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};        double[][][] fval = new double[xval.length][yval.length][zval.length];        @SuppressWarnings("unused")        TrivariateRealFunction tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                                             fval, fval, fval, fval,                                                                             fval, fval, fval, fval);                double[] wxval = new double[] {3, 2, 5, 6.5};        try {            tcf = new TricubicSplineInterpolatingFunction(wxval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException e) {            // Expected        }        double[] wyval = new double[] {-4, -1, -1, 2.5};        try {            tcf = new TricubicSplineInterpolatingFunction(xval, wyval, zval,                                                          fval, fval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException e) {            // Expected        }        double[] wzval = new double[] {-12, -8, -9, -3, 0, 2.5};        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, wzval,                                                          fval, fval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException e) {            // Expected        }        double[][][] wfval = new double[xval.length - 1][yval.length - 1][zval.length];        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          wfval, fval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, wfval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, wfval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, wfval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          wfval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, wfval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, fval, wfval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, fval, fval, wfval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wfval = new double[xval.length][yval.length - 1][zval.length];        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          wfval, fval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, wfval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, wfval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, wfval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          wfval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, wfval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, fval, wfval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, fval, fval, wfval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wfval = new double[xval.length][yval.length][zval.length - 1];        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          wfval, fval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, wfval, fval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, wfval, fval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, wfval,                                                          fval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          wfval, fval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, wfval, fval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, fval, wfval, fval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        try {            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                          fval, fval, fval, fval,                                                          fval, fval, fval, wfval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }    }    /**     * Test for a plane.     * <p>     *  f(x, y, z) = 2 x - 3 y - 4 z + 5     * </p>     */    @Test    public void testPlane() throws MathException {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2, 2.5};        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};        // Function values        TrivariateRealFunction f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return 2 * x - 3 * y - 4 * z + 5;                }            };        double[][][] fval = new double[xval.length][yval.length][zval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    fval[i][j][k] = f.value(xval[i], yval[j], zval[k]);                }            }        }        // Partial derivatives with respect to x        double[][][] dFdX = new double[xval.length][yval.length][zval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    dFdX[i][j][k] = 2;                }            }        }        // Partial derivatives with respect to y        double[][][] dFdY = new double[xval.length][yval.length][zval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    dFdY[i][j][k] = -3;                }            }        }        // Partial derivatives with respect to z        double[][][] dFdZ = new double[xval.length][yval.length][zval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    dFdZ[i][j][k] = -4;                }            }        }        // Partial cross-derivatives        double[][][] d2FdXdY = new double[xval.length][yval.length][zval.length];        double[][][] d2FdXdZ = new double[xval.length][yval.length][zval.length];        double[][][] d2FdYdZ = new double[xval.length][yval.length][zval.length];        double[][][] d3FdXdYdZ = new double[xval.length][yval.length][zval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    d2FdXdY[i][j][k] = 0;                    d2FdXdZ[i][j][k] = 0;                    d2FdYdZ[i][j][k] = 0;                    d3FdXdYdZ[i][j][k] = 0;                }            }        }        TrivariateRealFunction tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                                             fval, dFdX, dFdY, dFdZ,                                                                             d2FdXdY, d2FdXdZ, d2FdYdZ,                                                                             d3FdXdYdZ);        double x, y, z;        double expected, result;        x = 4;        y = -3;        z = 0;        expected = f.value(x, y, z);        result = tcf.value(x, y, z);        Assert.assertEquals("On sample point",                            expected, result, 1e-15);        x = 4.5;        y = -1.5;        z = -4.25;        expected = f.value(x, y, z);        result = tcf.value(x, y, z);        Assert.assertEquals("Half-way between sample points (middle of the patch)",                            expected, result, 0.3);        x = 3.5;        y = -3.5;        z = -10;        expected = f.value(x, y, z);        result = tcf.value(x, y, z);        Assert.assertEquals("Half-way between sample points (border of the patch)",                            expected, result, 0.3);    }    /**     * Sine wave.     * <p>     *  f(x, y, z) = a cos [&omega; z - k<sub>y</sub> x - k<sub>y</sub> y]     * </p>     * with A = 0.2, &omega; = 0.5, k<sub>x</sub> = 2, k<sub>y</sub> = 1.     */    @Test    public void testWave() throws MathException {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2, 2.5};        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 4};                final double a = 0.2;        final double omega = 0.5;        final double kx = 2;        final double ky = 1;                // Function values        TrivariateRealFunction f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return a * FastMath.cos(omega * z - kx * x - ky * y);                }            };                double[][][] fval = new double[xval.length][yval.length][zval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    fval[i][j][k] = f.value(xval[i], yval[j], zval[k]);                }            }        }                // Partial derivatives with respect to x        double[][][] dFdX = new double[xval.length][yval.length][zval.length];        TrivariateRealFunction dFdX_f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return a * FastMath.sin(omega * z - kx * x - ky * y) * kx;                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    dFdX[i][j][k] = dFdX_f.value(xval[i], yval[j], zval[k]);                }            }        }                    // Partial derivatives with respect to y        double[][][] dFdY = new double[xval.length][yval.length][zval.length];        TrivariateRealFunction dFdY_f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return a * FastMath.sin(omega * z - kx * x - ky * y) * ky;                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    dFdY[i][j][k] = dFdY_f.value(xval[i], yval[j], zval[k]);                }            }        }        // Partial derivatives with respect to z        double[][][] dFdZ = new double[xval.length][yval.length][zval.length];        TrivariateRealFunction dFdZ_f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return -a * FastMath.sin(omega * z - kx * x - ky * y) * omega;                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    dFdZ[i][j][k] = dFdZ_f.value(xval[i], yval[j], zval[k]);                }            }        }        // Partial second derivatives w.r.t. (x, y)        double[][][] d2FdXdY = new double[xval.length][yval.length][zval.length];        TrivariateRealFunction d2FdXdY_f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return -a * FastMath.cos(omega * z - kx * x - ky * y) * kx * ky;                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    d2FdXdY[i][j][k] = d2FdXdY_f.value(xval[i], yval[j], zval[k]);                }            }        }        // Partial second derivatives w.r.t. (x, z)        double[][][] d2FdXdZ = new double[xval.length][yval.length][zval.length];        TrivariateRealFunction d2FdXdZ_f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return a * FastMath.cos(omega * z - kx * x - ky * y) * kx * omega;                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    d2FdXdZ[i][j][k] = d2FdXdZ_f.value(xval[i], yval[j], zval[k]);                }            }        }        // Partial second derivatives w.r.t. (y, z)        double[][][] d2FdYdZ = new double[xval.length][yval.length][zval.length];        TrivariateRealFunction d2FdYdZ_f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return a * FastMath.cos(omega * z - kx * x - ky * y) * ky * omega;                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    d2FdYdZ[i][j][k] = d2FdYdZ_f.value(xval[i], yval[j], zval[k]);                }            }        }        // Partial third derivatives        double[][][] d3FdXdYdZ = new double[xval.length][yval.length][zval.length];        TrivariateRealFunction d3FdXdYdZ_f = new TrivariateRealFunction() {                public double value(double x, double y, double z) {                    return a * FastMath.sin(omega * z - kx * x - ky * y) * kx * ky * omega;                }            };        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                for (int k = 0; k < zval.length; k++) {                    d3FdXdYdZ[i][j][k] = d3FdXdYdZ_f.value(xval[i], yval[j], zval[k]);                }            }        }        TrivariateRealFunction tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,                                                                             fval, dFdX, dFdY, dFdZ,                                                                             d2FdXdY, d2FdXdZ, d2FdYdZ,                                                                             d3FdXdYdZ);        double x, y, z;        double expected, result;                x = 4;        y = -3;        z = 0;        expected = f.value(x, y, z);        result = tcf.value(x, y, z);        Assert.assertEquals("On sample point",                            expected, result, 1e-14);        x = 4.5;        y = -1.5;        z = -4.25;        expected = f.value(x, y, z);        result = tcf.value(x, y, z);        Assert.assertEquals("Half-way between sample points (middle of the patch)",                            expected, result, 0.1);        x = 3.5;        y = -3.5;        z = -10;        expected = f.value(x, y, z);        result = tcf.value(x, y, z);        Assert.assertEquals("Half-way between sample points (border of the patch)",                            expected, result, 0.1);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.Expm1Function;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * Testcase for Neville interpolator. * <p> * The error of polynomial interpolation is *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n! * where f^(n) is the n-th derivative of the approximated function and * zeta is some point in the interval determined by x[] and z. * <p> * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound * it and use the absolute value upper bound for estimates. For reference, * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2. * * @version $Revision$ $Date$ */public final class NevilleInterpolatorTest extends TestCase {    /**     * Test of interpolator for the sine function.     * <p>     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]     */    public void testSinFunction() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealInterpolator interpolator = new NevilleInterpolator();        double x[], y[], z, expected, result, tolerance;        // 6 interpolating points on interval [0, 2*PI]        int n = 6;        double min = 0.0, max = 2 * FastMath.PI;        x = new double[n];        y = new double[n];        for (int i = 0; i < n; i++) {            x[i] = min + i * (max - min) / n;            y[i] = f.value(x[i]);        }        double derivativebound = 1.0;        UnivariateRealFunction p = interpolator.interpolate(x, y);        z = FastMath.PI / 4; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = FastMath.PI * 1.5; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);    }    /**     * Test of interpolator for the exponential function.     * <p>     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]     */    public void testExpm1Function() throws MathException {        UnivariateRealFunction f = new Expm1Function();        UnivariateRealInterpolator interpolator = new NevilleInterpolator();        double x[], y[], z, expected, result, tolerance;        // 5 interpolating points on interval [-1, 1]        int n = 5;        double min = -1.0, max = 1.0;        x = new double[n];        y = new double[n];        for (int i = 0; i < n; i++) {            x[i] = min + i * (max - min) / n;            y[i] = f.value(x[i]);        }        double derivativebound = FastMath.E;        UnivariateRealFunction p = interpolator.interpolate(x, y);        z = 0.0; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = 0.5; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);        z = -0.5; expected = f.value(z); result = p.value(z);        tolerance = FastMath.abs(derivativebound * partialerror(x, z));        assertEquals(expected, result, tolerance);    }    /**     * Test of parameters for the interpolator.     */    public void testParameters() throws Exception {        UnivariateRealInterpolator interpolator = new NevilleInterpolator();        try {            // bad abscissas array            double x[] = { 1.0, 2.0, 2.0, 4.0 };            double y[] = { 0.0, 4.0, 4.0, 2.5 };            UnivariateRealFunction p = interpolator.interpolate(x, y);            p.value(0.0);            fail("Expecting MathException - bad abscissas array");        } catch (MathException ex) {            // expected        }    }    /**     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!     */    protected double partialerror(double x[], double z) throws        IllegalArgumentException {        if (x.length < 1) {            throw new IllegalArgumentException                ("Interpolation array cannot be empty.");        }        double out = 1;        for (int i = 0; i < x.length; i++) {            out *= (z - x[i]) / (i + 1);        }        return out;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.interpolation;import org.apache.commons.math.MathException;import org.apache.commons.math.DimensionMismatchException;import org.apache.commons.math.analysis.BivariateRealFunction;import org.junit.Assert;import org.junit.Test;/** * Testcase for the bicubic interpolator. *  * @version $Revision$ $Date$  * @deprecated To be removed in math 3.0 (when the class for which it is a test will also be removed). */public final class SmoothingBicubicSplineInterpolatorTest {    /**     * Test preconditions.     */    @Test    public void testPreconditions() throws MathException {        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2.5};        double[][] zval = new double[xval.length][yval.length];        BivariateRealGridInterpolator interpolator = new SmoothingBicubicSplineInterpolator();                @SuppressWarnings("unused")        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);                double[] wxval = new double[] {3, 2, 5, 6.5};        try {            p = interpolator.interpolate(wxval, yval, zval);            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException e) {            // Expected        }        double[] wyval = new double[] {-4, -3, -1, -1};        try {            p = interpolator.interpolate(xval, wyval, zval);            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException e) {            // Expected        }        double[][] wzval = new double[xval.length][yval.length + 1];        try {            p = interpolator.interpolate(xval, yval, wzval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wzval = new double[xval.length - 1][yval.length];        try {            p = interpolator.interpolate(xval, yval, wzval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }        wzval = new double[xval.length][yval.length - 1];        try {            p = interpolator.interpolate(xval, yval, wzval);            Assert.fail("an exception should have been thrown");        } catch (DimensionMismatchException e) {            // Expected        }    }    /**     * Test of interpolator for a plane.     * <p>     * z = 2 x - 3 y + 5     */    @Test    public void testPlane() throws MathException {        BivariateRealFunction f = new BivariateRealFunction() {                public double value(double x, double y) {                    return 2 * x - 3 * y + 5;                }            };        BivariateRealGridInterpolator interpolator = new SmoothingBicubicSplineInterpolator();        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -1, 2, 2.5};        double[][] zval = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                zval[i][j] = f.value(xval[i], yval[j]);            }        }        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);        double x, y;        double expected, result;                x = 4;        y = -3;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("On sample point", expected, result, 1e-15);        x = 4.5;        y = -1.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 0.3);        x = 3.5;        y = -3.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 0.3);    }    /**     * Test of interpolator for a paraboloid.     * <p>     * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5     */    @Test    public void testParaboloid() throws MathException {        BivariateRealFunction f = new BivariateRealFunction() {                public double value(double x, double y) {                    return 2 * x * x - 3 * y * y + 4 * x * y - 5;                }            };        BivariateRealGridInterpolator interpolator = new SmoothingBicubicSplineInterpolator();        double[] xval = new double[] {3, 4, 5, 6.5};        double[] yval = new double[] {-4, -3, -2, -1, 0.5, 2.5};        double[][] zval = new double[xval.length][yval.length];        for (int i = 0; i < xval.length; i++) {            for (int j = 0; j < yval.length; j++) {                zval[i][j] = f.value(xval[i], yval[j]);            }        }        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);        double x, y;        double expected, result;                x = 5;        y = 0.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("On sample point", expected, result, 1e-13);        x = 4.5;        y = -1.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 0.2);        x = 3.5;        y = -3.5;        expected = f.value(x, y);        result = p.value(x, y);        Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 0.2);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.polynomials;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for Lagrange form of polynomial function. * <p> * We use n+1 points to interpolate a polynomial of degree n. This should * give us the exact same polynomial as result. Thus we can use a very * small tolerance to account only for round-off errors. * * @version $Revision$ $Date$ */public final class PolynomialFunctionLagrangeFormTest extends TestCase {    /**     * Test of polynomial for the linear function.     */    public void testLinearFunction() throws MathException {        PolynomialFunctionLagrangeForm p;        double c[], z, expected, result, tolerance = 1E-12;        // p(x) = 1.5x - 4        double x[] = { 0.0, 3.0 };        double y[] = { -4.0, 0.5 };        p = new PolynomialFunctionLagrangeForm(x, y);        z = 2.0; expected = -1.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 4.5; expected = 2.75; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 6.0; expected = 5.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(1, p.degree());        c = p.getCoefficients();        assertEquals(2, c.length);        assertEquals(-4.0, c[0], tolerance);        assertEquals(1.5, c[1], tolerance);    }    /**     * Test of polynomial for the quadratic function.     */    public void testQuadraticFunction() throws MathException {        PolynomialFunctionLagrangeForm p;        double c[], z, expected, result, tolerance = 1E-12;        // p(x) = 2x^2 + 5x - 3 = (2x - 1)(x + 3)        double x[] = { 0.0, -1.0, 0.5 };        double y[] = { -3.0, -6.0, 0.0 };        p = new PolynomialFunctionLagrangeForm(x, y);        z = 1.0; expected = 4.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 2.5; expected = 22.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = -2.0; expected = -5.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(2, p.degree());        c = p.getCoefficients();        assertEquals(3, c.length);        assertEquals(-3.0, c[0], tolerance);        assertEquals(5.0, c[1], tolerance);        assertEquals(2.0, c[2], tolerance);    }    /**     * Test of polynomial for the quintic function.     */    public void testQuinticFunction() throws MathException {        PolynomialFunctionLagrangeForm p;        double c[], z, expected, result, tolerance = 1E-12;        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x = x(x^2 - 1)(x + 2)(x - 3)        double x[] = { 1.0, -1.0, 2.0, 3.0, -3.0, 0.5 };        double y[] = { 0.0, 0.0, -24.0, 0.0, -144.0, 2.34375 };        p = new PolynomialFunctionLagrangeForm(x, y);        z = 0.0; expected = 0.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = -2.0; expected = 0.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 4.0; expected = 360.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(5, p.degree());        c = p.getCoefficients();        assertEquals(6, c.length);        assertEquals(0.0, c[0], tolerance);        assertEquals(6.0, c[1], tolerance);        assertEquals(1.0, c[2], tolerance);        assertEquals(-7.0, c[3], tolerance);        assertEquals(-1.0, c[4], tolerance);        assertEquals(1.0, c[5], tolerance);    }    /**     * Test of parameters for the polynomial.     */    public void testParameters() throws Exception {        try {            // bad input array length            double x[] = { 1.0 };            double y[] = { 2.0 };            new PolynomialFunctionLagrangeForm(x, y);            fail("Expecting IllegalArgumentException - bad input array length");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // mismatch input arrays            double x[] = { 1.0, 2.0, 3.0, 4.0 };            double y[] = { 0.0, -4.0, -24.0 };            new PolynomialFunctionLagrangeForm(x, y);            fail("Expecting IllegalArgumentException - mismatch input arrays");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.polynomials;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * Testcase for Newton form of polynomial function. * <p> * The small tolerance number is used only to account for round-off errors. * * @version $Revision$ $Date$ */public final class PolynomialFunctionNewtonFormTest extends TestCase {    /**     * Test of polynomial for the linear function.     */    public void testLinearFunction() throws MathException {        PolynomialFunctionNewtonForm p;        double coefficients[], z, expected, result, tolerance = 1E-12;        // p(x) = 1.5x - 4 = 2 + 1.5(x-4)        double a[] = { 2.0, 1.5 };        double c[] = { 4.0 };        p = new PolynomialFunctionNewtonForm(a, c);        z = 2.0; expected = -1.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 4.5; expected = 2.75; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 6.0; expected = 5.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(1, p.degree());        coefficients = p.getCoefficients();        assertEquals(2, coefficients.length);        assertEquals(-4.0, coefficients[0], tolerance);        assertEquals(1.5, coefficients[1], tolerance);    }    /**     * Test of polynomial for the quadratic function.     */    public void testQuadraticFunction() throws MathException {        PolynomialFunctionNewtonForm p;        double coefficients[], z, expected, result, tolerance = 1E-12;        // p(x) = 2x^2 + 5x - 3 = 4 + 3(x-1) + 2(x-1)(x+2)        double a[] = { 4.0, 3.0, 2.0 };        double c[] = { 1.0, -2.0 };        p = new PolynomialFunctionNewtonForm(a, c);        z = 1.0; expected = 4.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 2.5; expected = 22.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = -2.0; expected = -5.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(2, p.degree());        coefficients = p.getCoefficients();        assertEquals(3, coefficients.length);        assertEquals(-3.0, coefficients[0], tolerance);        assertEquals(5.0, coefficients[1], tolerance);        assertEquals(2.0, coefficients[2], tolerance);    }    /**     * Test of polynomial for the quintic function.     */    public void testQuinticFunction() throws MathException {        PolynomialFunctionNewtonForm p;        double coefficients[], z, expected, result, tolerance = 1E-12;        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x        //      = 6x - 6x^2 -6x^2(x-1) + x^2(x-1)(x+1) + x^2(x-1)(x+1)(x-2)        double a[] = { 0.0, 6.0, -6.0, -6.0, 1.0, 1.0 };        double c[] = { 0.0, 0.0, 1.0, -1.0, 2.0 };        p = new PolynomialFunctionNewtonForm(a, c);        z = 0.0; expected = 0.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = -2.0; expected = 0.0; result = p.value(z);        assertEquals(expected, result, tolerance);        z = 4.0; expected = 360.0; result = p.value(z);        assertEquals(expected, result, tolerance);        assertEquals(5, p.degree());        coefficients = p.getCoefficients();        assertEquals(6, coefficients.length);        assertEquals(0.0, coefficients[0], tolerance);        assertEquals(6.0, coefficients[1], tolerance);        assertEquals(1.0, coefficients[2], tolerance);        assertEquals(-7.0, coefficients[3], tolerance);        assertEquals(-1.0, coefficients[4], tolerance);        assertEquals(1.0, coefficients[5], tolerance);    }    /**     * Test of parameters for the polynomial.     */    public void testParameters() throws Exception {        try {            // bad input array length            double a[] = { 1.0 };            double c[] = { 2.0 };            new PolynomialFunctionNewtonForm(a, c);            fail("Expecting IllegalArgumentException - bad input array length");        } catch (IllegalArgumentException ex) {            // expected        }        try {            // mismatch input arrays            double a[] = { 1.0, 2.0, 3.0, 4.0 };            double c[] = { 4.0, 3.0, 2.0, 1.0 };            new PolynomialFunctionNewtonForm(a, c);            fail("Expecting IllegalArgumentException - mismatch input arrays");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.polynomials;// commons-mathimport org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;// junitimport junit.framework.TestCase;/** * Tests the PolynomialFunction implementation of a UnivariateRealFunction. * * @version $Revision$ * @author Matt Cliff <matt@mattcliff.com> */public final class PolynomialFunctionTest extends TestCase {    /** Error tolerance for tests */    protected double tolerance = 1.0e-12;    /**     * tests the value of a constant polynomial.     *     * <p>value of this is 2.5 everywhere.</p>     */    public void testConstants() throws MathException {        double[] c = { 2.5 };        PolynomialFunction f = new PolynomialFunction( c );        // verify that we are equal to c[0] at several (nonsymmetric) places        assertEquals( f.value( 0.0), c[0], tolerance );        assertEquals( f.value( -1.0), c[0], tolerance );        assertEquals( f.value( -123.5), c[0], tolerance );        assertEquals( f.value( 3.0), c[0], tolerance );        assertEquals( f.value( 456.89), c[0], tolerance );        assertEquals(f.degree(), 0);        assertEquals(f.derivative().value(0), 0, tolerance);        assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);    }    /**     * tests the value of a linear polynomial.     *     * <p>This will test the function f(x) = 3*x - 1.5</p>     * <p>This will have the values     *  <tt>f(0.0) = -1.5, f(-1.0) = -4.5, f(-2.5) = -9.0,     *      f(0.5) = 0.0, f(1.5) = 3.0</tt> and <tt>f(3.0) = 7.5</tt>     * </p>     */    public void testLinear() throws MathException {        double[] c = { -1.5, 3.0 };        PolynomialFunction f = new PolynomialFunction( c );        // verify that we are equal to c[0] when x=0        assertEquals( f.value( 0.0), c[0], tolerance );        // now check a few other places        assertEquals( -4.5, f.value( -1.0), tolerance );        assertEquals( -9.0, f.value( -2.5), tolerance );        assertEquals( 0.0, f.value( 0.5), tolerance );        assertEquals( 3.0, f.value( 1.5), tolerance );        assertEquals( 7.5, f.value( 3.0), tolerance );        assertEquals(f.degree(), 1);        assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);    }    /**     * Tests a second order polynomial.     * <p> This will test the function f(x) = 2x^2 - 3x -2 = (2x+1)(x-2)</p>     *     */    public void testQuadratic() {        double[] c = { -2.0, -3.0, 2.0 };        PolynomialFunction f = new PolynomialFunction( c );        // verify that we are equal to c[0] when x=0        assertEquals( f.value( 0.0), c[0], tolerance );        // now check a few other places        assertEquals( 0.0, f.value( -0.5), tolerance );        assertEquals( 0.0, f.value( 2.0), tolerance );        assertEquals( -2.0, f.value( 1.5), tolerance );        assertEquals( 7.0, f.value( -1.5), tolerance );        assertEquals( 265.5312, f.value( 12.34), tolerance );    }    /**     * This will test the quintic function     *   f(x) = x^2(x-5)(x+3)(x-1) = x^5 - 3x^4 -13x^3 + 15x^2</p>     *     */    public void testQuintic() {        double[] c = { 0.0, 0.0, 15.0, -13.0, -3.0, 1.0 };        PolynomialFunction f = new PolynomialFunction( c );        // verify that we are equal to c[0] when x=0        assertEquals( f.value( 0.0), c[0], tolerance );        // now check a few other places        assertEquals( 0.0, f.value( 5.0), tolerance );        assertEquals( 0.0, f.value( 1.0), tolerance );        assertEquals( 0.0, f.value( -3.0), tolerance );        assertEquals( 54.84375, f.value( -1.5), tolerance );        assertEquals( -8.06637, f.value( 1.3), tolerance );        assertEquals(f.degree(), 5);    }    /**     * tests the firstDerivative function by comparison     *     * <p>This will test the functions     * <tt>f(x) = x^3 - 2x^2 + 6x + 3, g(x) = 3x^2 - 4x + 6</tt>     * and <tt>h(x) = 6x - 4</tt>     */    public void testfirstDerivativeComparison() throws MathException {        double[] f_coeff = { 3.0, 6.0, -2.0, 1.0 };        double[] g_coeff = { 6.0, -4.0, 3.0 };        double[] h_coeff = { -4.0, 6.0 };        PolynomialFunction f = new PolynomialFunction( f_coeff );        PolynomialFunction g = new PolynomialFunction( g_coeff );        PolynomialFunction h = new PolynomialFunction( h_coeff );        // compare f' = g        assertEquals( f.derivative().value(0.0), g.value(0.0), tolerance );        assertEquals( f.derivative().value(1.0), g.value(1.0), tolerance );        assertEquals( f.derivative().value(100.0), g.value(100.0), tolerance );        assertEquals( f.derivative().value(4.1), g.value(4.1), tolerance );        assertEquals( f.derivative().value(-3.25), g.value(-3.25), tolerance );        // compare g' = h        assertEquals( g.derivative().value(FastMath.PI), h.value(FastMath.PI), tolerance );        assertEquals( g.derivative().value(FastMath.E),  h.value(FastMath.E),  tolerance );    }    public void testString() {        PolynomialFunction p = new PolynomialFunction(new double[] { -5.0, 3.0, 1.0 });        checkPolynomial(p, "-5.0 + 3.0 x + x^2");        checkPolynomial(new PolynomialFunction(new double[] { 0.0, -2.0, 3.0 }),                        "-2.0 x + 3.0 x^2");        checkPolynomial(new PolynomialFunction(new double[] { 1.0, -2.0, 3.0 }),                      "1.0 - 2.0 x + 3.0 x^2");        checkPolynomial(new PolynomialFunction(new double[] { 0.0,  2.0, 3.0 }),                       "2.0 x + 3.0 x^2");        checkPolynomial(new PolynomialFunction(new double[] { 1.0,  2.0, 3.0 }),                     "1.0 + 2.0 x + 3.0 x^2");        checkPolynomial(new PolynomialFunction(new double[] { 1.0,  0.0, 3.0 }),                     "1.0 + 3.0 x^2");        checkPolynomial(new PolynomialFunction(new double[] { 0.0 }),                     "0");    }    public void testAddition() {        PolynomialFunction p1 = new PolynomialFunction(new double[] { -2.0, 1.0 });        PolynomialFunction p2 = new PolynomialFunction(new double[] { 2.0, -1.0, 0.0 });        checkNullPolynomial(p1.add(p2));        p2 = p1.add(p1);        checkPolynomial(p2, "-4.0 + 2.0 x");        p1 = new PolynomialFunction(new double[] { 1.0, -4.0, 2.0 });        p2 = new PolynomialFunction(new double[] { -1.0, 3.0, -2.0 });        p1 = p1.add(p2);        assertEquals(1, p1.degree());        checkPolynomial(p1, "-x");    }    public void testSubtraction() {        PolynomialFunction p1 = new PolynomialFunction(new double[] { -2.0, 1.0 });        checkNullPolynomial(p1.subtract(p1));        PolynomialFunction p2 = new PolynomialFunction(new double[] { -2.0, 6.0 });        p2 = p2.subtract(p1);        checkPolynomial(p2, "5.0 x");        p1 = new PolynomialFunction(new double[] { 1.0, -4.0, 2.0 });        p2 = new PolynomialFunction(new double[] { -1.0, 3.0, 2.0 });        p1 = p1.subtract(p2);        assertEquals(1, p1.degree());        checkPolynomial(p1, "2.0 - 7.0 x");    }    public void testMultiplication() {        PolynomialFunction p1 = new PolynomialFunction(new double[] { -3.0, 2.0 });        PolynomialFunction p2 = new PolynomialFunction(new double[] { 3.0, 2.0, 1.0 });        checkPolynomial(p1.multiply(p2), "-9.0 + x^2 + 2.0 x^3");        p1 = new PolynomialFunction(new double[] { 0.0, 1.0 });        p2 = p1;        for (int i = 2; i < 10; ++i) {            p2 = p2.multiply(p1);            checkPolynomial(p2, "x^" + i);        }    }    public void testSerial() {        PolynomialFunction p2 = new PolynomialFunction(new double[] { 3.0, 2.0, 1.0 });        assertEquals(p2, TestUtils.serializeAndRecover(p2));    }    /**     * tests the firstDerivative function by comparison     *     * <p>This will test the functions     * <tt>f(x) = x^3 - 2x^2 + 6x + 3, g(x) = 3x^2 - 4x + 6</tt>     * and <tt>h(x) = 6x - 4</tt>     */    public void testMath341() throws MathException {        double[] f_coeff = { 3.0, 6.0, -2.0, 1.0 };        double[] g_coeff = { 6.0, -4.0, 3.0 };        double[] h_coeff = { -4.0, 6.0 };        PolynomialFunction f = new PolynomialFunction( f_coeff );        PolynomialFunction g = new PolynomialFunction( g_coeff );        PolynomialFunction h = new PolynomialFunction( h_coeff );        // compare f' = g        assertEquals( f.derivative().value(0.0), g.value(0.0), tolerance );        assertEquals( f.derivative().value(1.0), g.value(1.0), tolerance );        assertEquals( f.derivative().value(100.0), g.value(100.0), tolerance );        assertEquals( f.derivative().value(4.1), g.value(4.1), tolerance );        assertEquals( f.derivative().value(-3.25), g.value(-3.25), tolerance );        // compare g' = h        assertEquals( g.derivative().value(FastMath.PI), h.value(FastMath.PI), tolerance );        assertEquals( g.derivative().value(FastMath.E),  h.value(FastMath.E),  tolerance );    }    public void checkPolynomial(PolynomialFunction p, String reference) {        assertEquals(reference, p.toString());    }    private void checkNullPolynomial(PolynomialFunction p) {        for (double coefficient : p.getCoefficients()) {            assertEquals(0.0, coefficient, 1.0e-15);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.polynomials;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * Tests the PolynomialsUtils class. * * @version $Revision$ $Date$ */public class PolynomialsUtilsTest extends TestCase {    public void testFirstChebyshevPolynomials() {        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(3), "-3.0 x + 4.0 x^3");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(2), "-1.0 + 2.0 x^2");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(1), "x");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(0), "1.0");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(7), "-7.0 x + 56.0 x^3 - 112.0 x^5 + 64.0 x^7");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(6), "-1.0 + 18.0 x^2 - 48.0 x^4 + 32.0 x^6");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(5), "5.0 x - 20.0 x^3 + 16.0 x^5");        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(4), "1.0 - 8.0 x^2 + 8.0 x^4");    }    public void testChebyshevBounds() {        for (int k = 0; k < 12; ++k) {            PolynomialFunction Tk = PolynomialsUtils.createChebyshevPolynomial(k);            for (double x = -1.0; x <= 1.0; x += 0.02) {                assertTrue(k + " " + Tk.value(x), FastMath.abs(Tk.value(x)) < (1.0 + 1.0e-12));            }        }    }    public void testChebyshevDifferentials() {        for (int k = 0; k < 12; ++k) {            PolynomialFunction Tk0 = PolynomialsUtils.createChebyshevPolynomial(k);            PolynomialFunction Tk1 = Tk0.polynomialDerivative();            PolynomialFunction Tk2 = Tk1.polynomialDerivative();            PolynomialFunction g0 = new PolynomialFunction(new double[] { k * k });            PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -1});            PolynomialFunction g2 = new PolynomialFunction(new double[] { 1, 0, -1 });            PolynomialFunction Tk0g0 = Tk0.multiply(g0);            PolynomialFunction Tk1g1 = Tk1.multiply(g1);            PolynomialFunction Tk2g2 = Tk2.multiply(g2);            checkNullPolynomial(Tk0g0.add(Tk1g1.add(Tk2g2)));        }    }    public void testFirstHermitePolynomials() {        checkPolynomial(PolynomialsUtils.createHermitePolynomial(3), "-12.0 x + 8.0 x^3");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(2), "-2.0 + 4.0 x^2");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(1), "2.0 x");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(0), "1.0");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(7), "-1680.0 x + 3360.0 x^3 - 1344.0 x^5 + 128.0 x^7");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(6), "-120.0 + 720.0 x^2 - 480.0 x^4 + 64.0 x^6");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(5), "120.0 x - 160.0 x^3 + 32.0 x^5");        checkPolynomial(PolynomialsUtils.createHermitePolynomial(4), "12.0 - 48.0 x^2 + 16.0 x^4");    }    public void testHermiteDifferentials() {        for (int k = 0; k < 12; ++k) {            PolynomialFunction Hk0 = PolynomialsUtils.createHermitePolynomial(k);            PolynomialFunction Hk1 = Hk0.polynomialDerivative();            PolynomialFunction Hk2 = Hk1.polynomialDerivative();            PolynomialFunction g0 = new PolynomialFunction(new double[] { 2 * k });            PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -2 });            PolynomialFunction g2 = new PolynomialFunction(new double[] { 1 });            PolynomialFunction Hk0g0 = Hk0.multiply(g0);            PolynomialFunction Hk1g1 = Hk1.multiply(g1);            PolynomialFunction Hk2g2 = Hk2.multiply(g2);            checkNullPolynomial(Hk0g0.add(Hk1g1.add(Hk2g2)));        }    }    public void testFirstLaguerrePolynomials() {        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(3), 6l, "6.0 - 18.0 x + 9.0 x^2 - x^3");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(2), 2l, "2.0 - 4.0 x + x^2");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(1), 1l, "1.0 - x");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(0), 1l, "1.0");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(7), 5040l,                "5040.0 - 35280.0 x + 52920.0 x^2 - 29400.0 x^3"                + " + 7350.0 x^4 - 882.0 x^5 + 49.0 x^6 - x^7");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(6),  720l,                "720.0 - 4320.0 x + 5400.0 x^2 - 2400.0 x^3 + 450.0 x^4"                + " - 36.0 x^5 + x^6");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(5),  120l,        "120.0 - 600.0 x + 600.0 x^2 - 200.0 x^3 + 25.0 x^4 - x^5");        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(4),   24l,        "24.0 - 96.0 x + 72.0 x^2 - 16.0 x^3 + x^4");    }    public void testLaguerreDifferentials() {        for (int k = 0; k < 12; ++k) {            PolynomialFunction Lk0 = PolynomialsUtils.createLaguerrePolynomial(k);            PolynomialFunction Lk1 = Lk0.polynomialDerivative();            PolynomialFunction Lk2 = Lk1.polynomialDerivative();            PolynomialFunction g0 = new PolynomialFunction(new double[] { k });            PolynomialFunction g1 = new PolynomialFunction(new double[] { 1, -1 });            PolynomialFunction g2 = new PolynomialFunction(new double[] { 0, 1 });            PolynomialFunction Lk0g0 = Lk0.multiply(g0);            PolynomialFunction Lk1g1 = Lk1.multiply(g1);            PolynomialFunction Lk2g2 = Lk2.multiply(g2);            checkNullPolynomial(Lk0g0.add(Lk1g1.add(Lk2g2)));        }    }    public void testFirstLegendrePolynomials() {        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(3),  2l, "-3.0 x + 5.0 x^3");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(2),  2l, "-1.0 + 3.0 x^2");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(1),  1l, "x");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(0),  1l, "1.0");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(7), 16l, "-35.0 x + 315.0 x^3 - 693.0 x^5 + 429.0 x^7");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(6), 16l, "-5.0 + 105.0 x^2 - 315.0 x^4 + 231.0 x^6");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(5),  8l, "15.0 x - 70.0 x^3 + 63.0 x^5");        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(4),  8l, "3.0 - 30.0 x^2 + 35.0 x^4");    }    public void testLegendreDifferentials() {        for (int k = 0; k < 12; ++k) {            PolynomialFunction Pk0 = PolynomialsUtils.createLegendrePolynomial(k);            PolynomialFunction Pk1 = Pk0.polynomialDerivative();            PolynomialFunction Pk2 = Pk1.polynomialDerivative();            PolynomialFunction g0 = new PolynomialFunction(new double[] { k * (k + 1) });            PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -2 });            PolynomialFunction g2 = new PolynomialFunction(new double[] { 1, 0, -1 });            PolynomialFunction Pk0g0 = Pk0.multiply(g0);            PolynomialFunction Pk1g1 = Pk1.multiply(g1);            PolynomialFunction Pk2g2 = Pk2.multiply(g2);            checkNullPolynomial(Pk0g0.add(Pk1g1.add(Pk2g2)));        }    }    public void testHighDegreeLegendre() {        PolynomialsUtils.createLegendrePolynomial(40);        double[] l40 = PolynomialsUtils.createLegendrePolynomial(40).getCoefficients();        double denominator = 274877906944.0;        double[] numerators = new double[] {                          +34461632205.0,            -28258538408100.0,          +3847870979902950.0,        -207785032914759300.0,                  +5929294332103310025.0,     -103301483474866556880.0,    +1197358103913226000200.0,    -9763073770369381232400.0,              +58171647881784229843050.0,  -260061484647976556945400.0,  +888315281771246239250340.0, -2345767627188139419665400.0,            +4819022625419112503443050.0, -7710436200670580005508880.0, +9566652323054238154983240.0, -9104813935044723209570256.0,            +6516550296251767619752905.0, -3391858621221953912598660.0, +1211378079007840683070950.0,  -265365894974690562152100.0,              +26876802183334044115405.0        };        for (int i = 0; i < l40.length; ++i) {            if (i % 2 == 0) {                double ci = numerators[i / 2] / denominator;                assertEquals(ci, l40[i], FastMath.abs(ci) * 1.0e-15);            } else {                assertEquals(0.0, l40[i], 0.0);            }        }    }    private void checkPolynomial(PolynomialFunction p, long denominator, String reference) {        PolynomialFunction q = new PolynomialFunction(new double[] { denominator});        assertEquals(reference, p.multiply(q).toString());    }    private void checkPolynomial(PolynomialFunction p, String reference) {        assertEquals(reference, p.toString());    }    private void checkNullPolynomial(PolynomialFunction p) {        for (double coefficient : p.getCoefficients()) {            assertEquals(0.0, coefficient, 1.0e-13);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis.polynomials;import java.util.Arrays;import junit.framework.TestCase;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.analysis.UnivariateRealFunction;/** * Tests the PolynomialSplineFunction implementation. * * @version $Revision$ */public class PolynomialSplineFunctionTest extends TestCase {    /** Error tolerance for tests */    protected double tolerance = 1.0e-12;    /**     * Quadratic polynomials used in tests:     *     * x^2 + x            [-1, 0)     * x^2 + x + 2        [0, 1)     * x^2 + x + 4        [1, 2)     *     * Defined so that evaluation using PolynomialSplineFunction evaluation     * algorithm agrees at knot point boundaries.     */    protected PolynomialFunction[] polynomials = {        new PolynomialFunction(new double[] {0d, 1d, 1d}),        new PolynomialFunction(new double[] {2d, 1d, 1d}),        new PolynomialFunction(new double[] {4d, 1d, 1d})    };    /** Knot points  */    protected double[] knots = {-1, 0, 1, 2};    /** Derivative of test polynomials -- 2x + 1  */    protected PolynomialFunction dp =        new PolynomialFunction(new double[] {1d, 2d});    public void testConstructor() {        PolynomialSplineFunction spline =            new PolynomialSplineFunction(knots, polynomials);        assertTrue(Arrays.equals(knots, spline.getKnots()));        assertEquals(1d, spline.getPolynomials()[0].getCoefficients()[2], 0);        assertEquals(3, spline.getN());        try { // too few knots            new PolynomialSplineFunction(new double[] {0}, polynomials);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try { // too many knots            new PolynomialSplineFunction(new double[] {0,1,2,3,4}, polynomials);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try { // knots not increasing            new PolynomialSplineFunction(new double[] {0,1, 3, 2}, polynomials);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testValues() throws Exception {        PolynomialSplineFunction spline =            new PolynomialSplineFunction(knots, polynomials);        UnivariateRealFunction dSpline = spline.derivative();        /**         * interior points -- spline value at x should equal p(x - knot)         * where knot is the largest knot point less than or equal to x and p         * is the polynomial defined over the knot segment to which x belongs.         */        double x = -1;        int index = 0;        for (int i = 0; i < 10; i++) {           x+=0.25;           index = findKnot(knots, x);           assertEquals("spline function evaluation failed for x=" + x,                   polynomials[index].value(x - knots[index]), spline.value(x), tolerance);           assertEquals("spline derivative evaluation failed for x=" + x,                   dp.value(x - knots[index]), dSpline.value(x), tolerance);        }        // knot points -- centering should zero arguments        for (int i = 0; i < 3; i++) {            assertEquals("spline function evaluation failed for knot=" + knots[i],                    polynomials[i].value(0), spline.value(knots[i]), tolerance);            assertEquals("spline function evaluation failed for knot=" + knots[i],                    dp.value(0), dSpline.value(knots[i]), tolerance);        }        try { //outside of domain -- under min            x = spline.value(-1.5);            fail("Expecting IllegalArgumentException");        } catch (FunctionEvaluationException ex) {            // expected        }        try { //outside of domain -- over max            x = spline.value(2.5);            fail("Expecting IllegalArgumentException");        } catch (FunctionEvaluationException ex) {            // expected        }    }    /**     *  Do linear search to find largest knot point less than or equal to x.     *  Implementation does binary search.     */     protected int findKnot(double[] knots, double x) {         if (x < knots[0] || x >= knots[knots.length -1]) {             throw new IllegalArgumentException("x is out of range");         }         for (int i = 0; i < knots.length; i++) {             if (knots[i] > x) {                 return i -1;             }         }         throw new IllegalArgumentException("x is out of range");     }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class BinaryFunctionTest {    @Test    public void testAdd() throws FunctionEvaluationException {        Assert.assertEquals(5.0, BinaryFunction.ADD.value(2, 3), 1.0e-15);        Assert.assertEquals(0.0, BinaryFunction.ADD.value(-1, 1), 1.0e-15);    }    @Test    public void testSubtract() throws FunctionEvaluationException {        Assert.assertEquals(-1.0, BinaryFunction.SUBTRACT.value(2, 3), 1.0e-15);        Assert.assertEquals(-2.0, BinaryFunction.SUBTRACT.value(-1, 1), 1.0e-15);    }    @Test    public void testMultiply() throws FunctionEvaluationException {        Assert.assertEquals(6.0, BinaryFunction.MULTIPLY.value(2, 3), 1.0e-15);        Assert.assertEquals(-1.0, BinaryFunction.MULTIPLY.value(-1, 1), 1.0e-15);    }    @Test    public void testDivide() throws FunctionEvaluationException {        Assert.assertEquals(1.5, BinaryFunction.DIVIDE.value(3, 2), 1.0e-15);        Assert.assertEquals(-1.0, BinaryFunction.DIVIDE.value(-1, 1), 1.0e-15);    }    @Test    public void testPow() throws FunctionEvaluationException {        Assert.assertEquals(9.0, BinaryFunction.POW.value(3, 2), 1.0e-15);        Assert.assertEquals(-1.0, BinaryFunction.POW.value(-1, 1), 1.0e-15);    }    @Test    public void testAtan2() throws FunctionEvaluationException {        Assert.assertEquals(FastMath.PI / 4, BinaryFunction.ATAN2.value(1, 1), 1.0e-15);        Assert.assertEquals(-FastMath.PI / 4, BinaryFunction.ATAN2.value(-1, 1), 1.0e-15);    }    @Test    public void testFix1st() throws FunctionEvaluationException {        ComposableFunction f = BinaryFunction.POW.fix1stArgument(2);        for (double x = 0.0; x < 1.0; x += 0.01) {            Assert.assertEquals(FastMath.pow(2.0, x), f.value(x), 1.0e-15);        }    }    @Test    public void testFix2nd() throws FunctionEvaluationException {        ComposableFunction f = BinaryFunction.POW.fix2ndArgument(2);        for (double y = 0.0; y < 1.0; y += 0.01) {            Assert.assertEquals(y * y, f.value(y), 1.0e-15);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class ComposableFunctionTest {    @Test    public void testZero() throws FunctionEvaluationException {        Assert.assertEquals(0.0, ComposableFunction.ZERO.value(1), 1.0e-15);        Assert.assertEquals(0.0, ComposableFunction.ZERO.value(2), 1.0e-15);    }    @Test    public void testOne() throws FunctionEvaluationException {        Assert.assertEquals(1.0, ComposableFunction.ONE.value(1), 1.0e-15);        Assert.assertEquals(1.0, ComposableFunction.ONE.value(2), 1.0e-15);    }    @Test    public void testIdentity() throws FunctionEvaluationException {        Assert.assertEquals(1.0, ComposableFunction.IDENTITY.value(1), 1.0e-15);        Assert.assertEquals(2.0, ComposableFunction.IDENTITY.value(2), 1.0e-15);    }    @Test    public void testRint() throws FunctionEvaluationException {        Assert.assertEquals(1.0, ComposableFunction.RINT.value(0.9), 1.0e-15);        Assert.assertEquals(2.0, ComposableFunction.RINT.value(2.2), 1.0e-15);    }    @Test    public void testSignum() throws FunctionEvaluationException {        Assert.assertEquals(1.0, ComposableFunction.SIGNUM.value(12.3), 1.0e-15);        Assert.assertEquals(-1.0, ComposableFunction.SIGNUM.value(-6), 1.0e-15);    }    @Test    public void testComposition() throws FunctionEvaluationException {        ComposableFunction abs    = ComposableFunction.ABS;        ComposableFunction acos   = ComposableFunction.ACOS;        ComposableFunction asin   = ComposableFunction.ASIN;        ComposableFunction atan   = ComposableFunction.ATAN;        ComposableFunction cbrt   = ComposableFunction.CBRT;        ComposableFunction ceil   = ComposableFunction.CEIL;        ComposableFunction cos    = ComposableFunction.COS;        ComposableFunction cosh   = ComposableFunction.COSH;        ComposableFunction exp    = ComposableFunction.EXP;        ComposableFunction expm1  = ComposableFunction.EXPM1;        ComposableFunction floor  = ComposableFunction.FLOOR;        ComposableFunction id     = ComposableFunction.IDENTITY;        ComposableFunction log    = ComposableFunction.LOG;        ComposableFunction log10  = ComposableFunction.LOG10;        ComposableFunction negate = ComposableFunction.NEGATE;        ComposableFunction sin    = ComposableFunction.SIN;        ComposableFunction sinh   = ComposableFunction.SINH;        ComposableFunction sqrt   = ComposableFunction.SQRT;        ComposableFunction tan    = ComposableFunction.TAN;        ComposableFunction tanh   = ComposableFunction.TANH;        ComposableFunction ulp    = ComposableFunction.ULP;        ComposableFunction f1 = sqrt.of(abs.of(expm1.of(cbrt.of(tanh).of(id))));        for (double x = 0.1; x < 0.9; x += 0.01) {            Assert.assertEquals(FastMath.sqrt(FastMath.abs(FastMath.expm1(FastMath.cbrt(FastMath.tanh(x))))),                                f1.value(x), 1.0e-15);        }        ComposableFunction f2 = cosh.of(sinh.of(tanh.of(ceil.postCompose(log.postCompose(cosh)))));        for (double x = 0.1; x < 12.9; x += 1.0) {            Assert.assertEquals(FastMath.cosh(FastMath.sinh(FastMath.tanh(FastMath.cosh(FastMath.log(FastMath.ceil(x)))))),                                f2.value(x), 1.0e-15);        }        ComposableFunction f3 = cos.of(sin.of(tan.of(acos.of(asin.of(log10.of(log.of(ulp)))))));        for (double x = 1.0e16; x < 1.0e17; x += 1.0e16) {            Assert.assertEquals(FastMath.cos(FastMath.sin(FastMath.tan(FastMath.acos(FastMath.asin(FastMath.log10(FastMath.log(FastMath.ulp(x)))))))),                                f3.value(x), 1.0e-15);        }        ComposableFunction f4 = atan.of(exp.of(negate.of(floor)));        for (double x = 1.1; x < 10.2; x += 1.0) {            Assert.assertEquals(FastMath.atan(FastMath.exp(-FastMath.floor(x))),                                f4.value(x), 1.0e-15);        }    }    @Test    public void testCombine() throws FunctionEvaluationException {        ComposableFunction f =            ComposableFunction.COS.combine(ComposableFunction.ASIN, BinaryFunction.POW);        for (double x = 0.1; x < 0.9; x += 0.01) {            Assert.assertEquals(FastMath.pow(FastMath.cos(x), FastMath.asin(x)), f.value(x), 1.0e-15);        }    }    @Test    public void testSimpleCombination() throws FunctionEvaluationException {        ComposableFunction f1 = ComposableFunction.COS.add(3);        ComposableFunction f2 = ComposableFunction.COS.add(ComposableFunction.SIN);        ComposableFunction f3 = ComposableFunction.COS.subtract(ComposableFunction.SIN);        ComposableFunction f4 = ComposableFunction.COS.multiply(ComposableFunction.SIN);        ComposableFunction f5 = ComposableFunction.COS.multiply(5);        ComposableFunction f6 = ComposableFunction.COS.divide(ComposableFunction.SIN);        for (double x = 0.1; x < 0.9; x += 0.01) {            Assert.assertEquals(FastMath.cos(x) + 3, f1.value(x), 1.0e-15);            Assert.assertEquals(FastMath.cos(x) + FastMath.sin(x), f2.value(x), 1.0e-15);            Assert.assertEquals(FastMath.cos(x) - FastMath.sin(x), f3.value(x), 1.0e-15);            Assert.assertEquals(FastMath.cos(x) * FastMath.sin(x), f4.value(x), 1.0e-15);            Assert.assertEquals(FastMath.cos(x) * 5, f5.value(x), 1.0e-15);            Assert.assertEquals(FastMath.cos(x) / FastMath.sin(x), f6.value(x), 1.0e-15);        }    }    @Test    public void testCollector() throws FunctionEvaluationException {        ComposableFunction f = BinaryFunction.POW.fix2ndArgument(2);        Assert.assertEquals(30, f.asCollector().value(new double[] { 1, 2, 3, 4 }), 1.0e-15);        Assert.assertEquals(33, f.asCollector(3).value(new double[] { 1, 2, 3, 4 }), 1.0e-15);        Assert.assertEquals(-30, f.asCollector(BinaryFunction.SUBTRACT).value(new double[] { 1, 2, 3, 4 }), 1.0e-15);        Assert.assertEquals(1152, f.asCollector(BinaryFunction.MULTIPLY, 2).value(new double[] { 1, 2, 3, 4 }), 1.0e-15);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.rank;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class MaxTest extends StorelessUnivariateStatisticAbstractTest{    protected Max stat;    /**     * @param name     */    public MaxTest(String name) {        super(name);    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Max();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.max;    }    public void testSpecialValues() {        double[] testArray = {0d, Double.NaN, Double.NEGATIVE_INFINITY,                Double.POSITIVE_INFINITY};        Max max = new Max();        assertTrue(Double.isNaN(max.getResult()));        max.increment(testArray[0]);        assertEquals(0d, max.getResult(), 0);        max.increment(testArray[1]);        assertEquals(0d, max.getResult(), 0);        max.increment(testArray[2]);        assertEquals(0d, max.getResult(), 0);        max.increment(testArray[3]);        assertEquals(Double.POSITIVE_INFINITY, max.getResult(), 0);        assertEquals(Double.POSITIVE_INFINITY, max.evaluate(testArray), 0);    }    public void testNaNs() {        Max max = new Max();        double nan = Double.NaN;        assertEquals(3d, max.evaluate(new double[]{nan, 2d, 3d}), 0);        assertEquals(3d, max.evaluate(new double[]{1d, nan, 3d}), 0);        assertEquals(2d, max.evaluate(new double[]{1d, 2d, nan}), 0);        assertTrue(Double.isNaN(max.evaluate(new double[]{nan, nan, nan})));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.rank;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class PercentileTest extends UnivariateStatisticAbstractTest{    protected Percentile stat;    /**     * @param name     */    public PercentileTest(String name) {        super(name);    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Percentile(95.0);    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.percentile95;    }    public void testHighPercentile(){        double[] d = new double[]{1, 2, 3};        Percentile p = new Percentile(75);        assertEquals(3.0, p.evaluate(d), 1.0e-5);    }    public void testPercentile() {        double[] d = new double[] {1, 3, 2, 4};        Percentile p = new Percentile(30);        assertEquals(1.5, p.evaluate(d), 1.0e-5);        p.setQuantile(25);        assertEquals(1.25, p.evaluate(d), 1.0e-5);        p.setQuantile(75);        assertEquals(3.75, p.evaluate(d), 1.0e-5);        p.setQuantile(50);        assertEquals(2.5, p.evaluate(d), 1.0e-5);        // invalid percentiles        try {            p.evaluate(d, 0, d.length, -1.0);            fail();        } catch (IllegalArgumentException ex) {            // success        }        try {            p.evaluate(d, 0, d.length, 101.0);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }    public void testNISTExample() {        double[] d = new double[] {95.1772, 95.1567, 95.1937, 95.1959,                95.1442, 95.0610,  95.1591, 95.1195, 95.1772, 95.0925, 95.1990, 95.1682        };        Percentile p = new Percentile(90);        assertEquals(95.1981, p.evaluate(d), 1.0e-4);        assertEquals(95.1990, p.evaluate(d,0,d.length, 100d), 0);    }    public void test5() {        Percentile percentile = new Percentile(5);        assertEquals(this.percentile5, percentile.evaluate(testArray), getTolerance());    }    public void testNullEmpty() {        Percentile percentile = new Percentile(50);        double[] nullArray = null;        double[] emptyArray = new double[] {};        try {            percentile.evaluate(nullArray);            fail("Expecting IllegalArgumentException for null array");        } catch (IllegalArgumentException ex) {            // expected        }        assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));    }    public void testSingleton() {        Percentile percentile = new Percentile(50);        double[] singletonArray = new double[] {1d};        assertEquals(1d, percentile.evaluate(singletonArray), 0);        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 5), 0);        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 100), 0);        assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0)));    }    public void testSpecialValues() {        Percentile percentile = new Percentile(50);        double[] specialValues = new double[] {0d, 1d, 2d, 3d, 4d,  Double.NaN};        assertEquals(2.5d, percentile.evaluate(specialValues), 0);        specialValues =  new double[] {Double.NEGATIVE_INFINITY, 1d, 2d, 3d,                Double.NaN, Double.POSITIVE_INFINITY};        assertEquals(2.5d, percentile.evaluate(specialValues), 0);        specialValues = new double[] {1d, 1d, Double.POSITIVE_INFINITY,                Double.POSITIVE_INFINITY};        assertTrue(Double.isInfinite(percentile.evaluate(specialValues)));        specialValues = new double[] {1d, 1d, Double.NaN,                Double.NaN};        assertTrue(Double.isNaN(percentile.evaluate(specialValues)));        specialValues = new double[] {1d, 1d, Double.NEGATIVE_INFINITY,                Double.NEGATIVE_INFINITY};        // Interpolation results in NEGATIVE_INFINITY + POSITIVE_INFINITY        assertTrue(Double.isNaN(percentile.evaluate(specialValues)));    }    public void testSetQuantile() {        Percentile percentile = new Percentile(10);        percentile.setQuantile(100); // OK        assertEquals(100, percentile.getQuantile(), 0);        try {            percentile.setQuantile(0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            new Percentile(0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.rank;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class MedianTest extends UnivariateStatisticAbstractTest{    protected Median stat;    /**     * @param name     */    public MedianTest(String name) {        super(name);    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Median();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.median;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.rank;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class MinTest extends StorelessUnivariateStatisticAbstractTest{    protected Min stat;    /**     * @param name     */    public MinTest(String name) {        super(name);    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Min();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.min;    }    public void testSpecialValues() {        double[] testArray = {0d, Double.NaN, Double.POSITIVE_INFINITY,                Double.NEGATIVE_INFINITY};        Min min = new Min();        assertTrue(Double.isNaN(min.getResult()));        min.increment(testArray[0]);        assertEquals(0d, min.getResult(), 0);        min.increment(testArray[1]);        assertEquals(0d, min.getResult(), 0);        min.increment(testArray[2]);        assertEquals(0d, min.getResult(), 0);        min.increment(testArray[3]);        assertEquals(Double.NEGATIVE_INFINITY, min.getResult(), 0);        assertEquals(Double.NEGATIVE_INFINITY, min.evaluate(testArray), 0);    }    public void testNaNs() {        Min min = new Min();        double nan = Double.NaN;        assertEquals(2d, min.evaluate(new double[]{nan, 2d, 3d}), 0);        assertEquals(1d, min.evaluate(new double[]{1d, nan, 3d}), 0);        assertEquals(1d, min.evaluate(new double[]{1d, 2d, nan}), 0);        assertTrue(Double.isNaN(min.evaluate(new double[]{nan, nan, nan})));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.apache.commons.math.util.FastMath;/** * Test cases for the {@link UnivariateStatistic} class. * * @version $Revision$ $Date$ */public class StandardDeviationTest extends StorelessUnivariateStatisticAbstractTest{    protected StandardDeviation stat;    /**     * @param name     */    public StandardDeviationTest(String name) {        super(name);    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new StandardDeviation();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.std;    }    /**     * Make sure Double.NaN is returned iff n = 0     *     */    public void testNaN() {        StandardDeviation std = new StandardDeviation();        assertTrue(Double.isNaN(std.getResult()));        std.increment(1d);        assertEquals(0d, std.getResult(), 0);    }    /**     * Test population version of variance     */    public void testPopulation() {        double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};        double sigma = populationStandardDeviation(values);        SecondMoment m = new SecondMoment();        m.evaluate(values);  // side effect is to add values        StandardDeviation s1 = new StandardDeviation();        s1.setBiasCorrected(false);        assertEquals(sigma, s1.evaluate(values), 1E-14);        s1.incrementAll(values);        assertEquals(sigma, s1.getResult(), 1E-14);        s1 = new StandardDeviation(false, m);        assertEquals(sigma, s1.getResult(), 1E-14);        s1 = new StandardDeviation(false);        assertEquals(sigma, s1.evaluate(values), 1E-14);        s1.incrementAll(values);        assertEquals(sigma, s1.getResult(), 1E-14);    }    /**     * Definitional formula for population standard deviation     */    protected double populationStandardDeviation(double[] v) {        double mean = new Mean().evaluate(v);        double sum = 0;        for (int i = 0; i < v.length; i++) {            sum += (v[i] - mean) * (v[i] - mean);        }        return FastMath.sqrt(sum / v.length);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.StatUtils;import junit.framework.TestCase;public class SemiVarianceTest extends TestCase {    public void testInsufficientData() {        double[] nothing = null;        SemiVariance sv = new SemiVariance();        try {            sv.evaluate(nothing);            fail("null is not a valid data array.");        } catch (IllegalArgumentException iae) {        }        try {            sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);            sv.evaluate(nothing);            fail("null is not a valid data array.");        } catch (IllegalArgumentException iae) {        }        nothing = new double[] {};        assertTrue(Double.isNaN(sv.evaluate(nothing)));    }    public void testSingleDown() {        SemiVariance sv = new SemiVariance();        double[] values = { 50.0d };        double singletest = sv.evaluate(values);        assertEquals(0.0d, singletest, 0);    }    public void testSingleUp() {        SemiVariance sv = new SemiVariance(SemiVariance.UPSIDE_VARIANCE);        double[] values = { 50.0d };        double singletest = sv.evaluate(values);        assertEquals(0.0d, singletest, 0);    }    public void testSample() {        final double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };        final int length = values.length;        final double mean = StatUtils.mean(values); // 6.333...        final SemiVariance sv = new SemiVariance();  // Default bias correction is true        final double downsideSemiVariance = sv.evaluate(values); // Downside is the default        assertEquals(TestUtils.sumSquareDev(new double[] {-2d, 2d, 4d, -2d, 3d, 5d}, mean) / (length - 1),                downsideSemiVariance, 1E-14);        sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);        final double upsideSemiVariance = sv.evaluate(values);        assertEquals(TestUtils.sumSquareDev(new double[] {22d, 11d, 14d}, mean) / (length - 1),                upsideSemiVariance, 1E-14);        // Verify that upper + lower semivariance against the mean sum to variance        assertEquals(StatUtils.variance(values), downsideSemiVariance + upsideSemiVariance, 10e-12);    }    public void testPopulation() {        double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };        SemiVariance sv = new SemiVariance(false);        double singletest = sv.evaluate(values);        assertEquals(19.556d, singletest, 0.01d);        sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);        singletest = sv.evaluate(values);        assertEquals(36.222d, singletest, 0.01d);    }    public void testNonMeanCutoffs() {        double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };        SemiVariance sv = new SemiVariance(false); // Turn off bias correction - use df = length        double singletest = sv.evaluate(values, 1.0d, SemiVariance.DOWNSIDE_VARIANCE, false, 0, values.length);        assertEquals(TestUtils.sumSquareDev(new double[] { -2d, -2d }, 1.0d) / values.length,                singletest, 0.01d);        singletest = sv.evaluate(values, 3.0d, SemiVariance.UPSIDE_VARIANCE, false, 0, values.length);        assertEquals(TestUtils.sumSquareDev(new double[] { 4d, 22d, 11d, 14d, 5d }, 3.0d) / values.length, singletest,                0.01d);    }    /**     * Check that the lower + upper semivariance against the mean sum to the     * variance.     */    public void testVarianceDecompMeanCutoff() {        double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };        double variance = StatUtils.variance(values);        SemiVariance sv = new SemiVariance(true); // Bias corrected        sv.setVarianceDirection(SemiVariance.DOWNSIDE_VARIANCE);        final double lower = sv.evaluate(values);        sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);        final double upper = sv.evaluate(values);        assertEquals(variance, lower + upper, 10e-12);    }    /**     * Check that upper and lower semivariances against a cutoff sum to the sum     * of squared deviations of the full set of values against the cutoff     * divided by df = length - 1 (assuming bias-corrected).     */    public void testVarianceDecompNonMeanCutoff() {        double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };        double target = 0;        double totalSumOfSquares = TestUtils.sumSquareDev(values, target);        SemiVariance sv = new SemiVariance(true); // Bias corrected        sv.setVarianceDirection(SemiVariance.DOWNSIDE_VARIANCE);        double lower = sv.evaluate(values, target);        sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);        double upper = sv.evaluate(values, target);        assertEquals(totalSumOfSquares / (values.length - 1), lower + upper, 10e-12);    }    public void testNoVariance() {        final double[] values = {100d, 100d, 100d, 100d};        SemiVariance sv = new SemiVariance();        assertEquals(0, sv.evaluate(values), 10E-12);        assertEquals(0, sv.evaluate(values, 100d), 10E-12);        assertEquals(0, sv.evaluate(values, 100d, SemiVariance.UPSIDE_VARIANCE, false, 0, values.length), 10E-12);    }}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.stat.descriptive.moment;import junit.framework.TestCase;import org.apache.commons.math.DimensionMismatchException;import org.apache.commons.math.TestUtils;public class VectorialMeanTestextends TestCase {    public VectorialMeanTest(String name) {        super(name);        points = null;    }    public void testMismatch() {        try {            new VectorialMean(8).increment(new double[5]);            fail("an exception should have been thrown");        } catch (DimensionMismatchException dme) {            assertEquals(5, dme.getDimension1());            assertEquals(8, dme.getDimension2());        } catch (Exception e) {            fail("wrong exception type caught: " + e.getClass().getName());        }    }    public void testSimplistic() throws DimensionMismatchException {        VectorialMean stat = new VectorialMean(2);        stat.increment(new double[] {-1.0,  1.0});        stat.increment(new double[] { 1.0, -1.0});        double[] mean = stat.getResult();        assertEquals(0.0, mean[0], 1.0e-12);        assertEquals(0.0, mean[1], 1.0e-12);    }    public void testBasicStats() throws DimensionMismatchException {        VectorialMean stat = new VectorialMean(points[0].length);        for (int i = 0; i < points.length; ++i) {            stat.increment(points[i]);        }        assertEquals(points.length, stat.getN());        double[] mean = stat.getResult();        double[]   refMean = new double[] { 1.78, 1.62,  3.12};        for (int i = 0; i < mean.length; ++i) {            assertEquals(refMean[i], mean[i], 1.0e-12);        }    }    public void testSerial() throws DimensionMismatchException {        VectorialMean stat = new VectorialMean(points[0].length);        for (int i = 0; i < points.length; ++i) {            stat.increment(points[i]);        }        assertEquals(stat, TestUtils.serializeAndRecover(stat));    }    @Override    public void setUp() {        points = new double[][] {                { 1.2, 2.3,  4.5},                {-0.7, 2.3,  5.0},                { 3.1, 0.0, -3.1},                { 6.0, 1.2,  4.2},                {-0.7, 2.3,  5.0}        };    }    @Override    public void tearDown() {        points = null;    }    private double [][] points;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link FourthMoment} class. * @version $Revision$ $Date$ */public class FourthMomentTest extends StorelessUnivariateStatisticAbstractTest{    /** descriptive statistic. */    protected FourthMoment stat;    /**     * @param name     */    public FourthMomentTest(String name) {        super(name);    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new FourthMoment();    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    @Override    public double expectedValue() {       return this.fourthMoment;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link ThirdMoment} class. * @version $Revision$ $Date$ */public class ThirdMomentTest extends StorelessUnivariateStatisticAbstractTest{    /** descriptive statistic. */    protected ThirdMoment stat;    /**     * @param name     */    public ThirdMomentTest(String name) {        super(name);    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new ThirdMoment();    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    @Override    public double expectedValue() {      return this.thirdMoment;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class KurtosisTest extends StorelessUnivariateStatisticAbstractTest{    protected Kurtosis stat;    /**     * @param name     */    public KurtosisTest(String name) {        super(name);    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Kurtosis();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.kurt;    }    /**     * Make sure Double.NaN is returned iff n < 4     *     */    public void testNaN() {        Kurtosis kurt = new Kurtosis();        assertTrue(Double.isNaN(kurt.getResult()));        kurt.increment(1d);        assertTrue(Double.isNaN(kurt.getResult()));        kurt.increment(1d);        assertTrue(Double.isNaN(kurt.getResult()));        kurt.increment(1d);        assertTrue(Double.isNaN(kurt.getResult()));        kurt.increment(1d);        assertFalse(Double.isNaN(kurt.getResult()));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * * @version $Revision$ $Date$ */public class SkewnessTest extends StorelessUnivariateStatisticAbstractTest{    protected Skewness stat;    /**     * @param name     */    public SkewnessTest(String name) {        super(name);    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Skewness();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.skew;    }    /**     * Make sure Double.NaN is returned iff n < 3     *     */    public void testNaN() {        Skewness skew = new Skewness();        assertTrue(Double.isNaN(skew.getResult()));        skew.increment(1d);        assertTrue(Double.isNaN(skew.getResult()));        skew.increment(1d);        assertTrue(Double.isNaN(skew.getResult()));        skew.increment(1d);        assertFalse(Double.isNaN(skew.getResult()));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;import org.apache.commons.math.util.MathUtils;/** * Test cases for the {@link UnivariateStatistic} class. * * @version $Revision$ $Date$ */public class VarianceTest extends StorelessUnivariateStatisticAbstractTest{    protected Variance stat;    /**     * @param name     */    public VarianceTest(String name) {        super(name);    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Variance();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.var;    }    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */    public double expectedWeightedValue() {        return this.weightedVar;    }    /**     * Make sure Double.NaN is returned iff n = 0     *     */    public void testNaN() {        StandardDeviation std = new StandardDeviation();        assertTrue(Double.isNaN(std.getResult()));        std.increment(1d);        assertEquals(0d, std.getResult(), 0);    }    /**     * Test population version of variance     */    public void testPopulation() {        double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};        SecondMoment m = new SecondMoment();        m.evaluate(values);  // side effect is to add values        Variance v1 = new Variance();        v1.setBiasCorrected(false);        assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);        v1.incrementAll(values);        assertEquals(populationVariance(values), v1.getResult(), 1E-14);        v1 = new Variance(false, m);        assertEquals(populationVariance(values), v1.getResult(), 1E-14);        v1 = new Variance(false);        assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);        v1.incrementAll(values);        assertEquals(populationVariance(values), v1.getResult(), 1E-14);    }    /**     * Definitional formula for population variance     */    protected double populationVariance(double[] v) {        double mean = new Mean().evaluate(v);        double sum = 0;        for (int i = 0; i < v.length; i++) {           sum += (v[i] - mean) * (v[i] - mean);        }        return sum / v.length;    }    public void testWeightedVariance() {        Variance variance = new Variance();        assertEquals(expectedWeightedValue(),                variance.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());        // All weights = 1 -> weighted variance = unweighted variance        assertEquals(expectedValue(),                variance.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());        // All weights the same -> when weights are normalized to sum to the length of the values array,        // weighted variance = unweighted value        assertEquals(expectedValue(),                variance.evaluate(testArray, MathUtils.normalizeArray(identicalWeightsArray, testArray.length),                        0, testArray.length), getTolerance());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link FirstMoment} class. * @version $Revision$ $Date$ */public class FirstMomentTest extends StorelessUnivariateStatisticAbstractTest{    /** descriptive statistic. */    protected FirstMoment stat;    /**     * @param name     */    public FirstMomentTest(String name) {        super(name);    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new FirstMoment();    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    @Override    public double expectedValue() {        return this.mean;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class GeometricMeanTest extends StorelessUnivariateStatisticAbstractTest{    protected GeometricMean stat;    /**     * @param name     */    public GeometricMeanTest(String name) {        super(name);    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new GeometricMean();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.geoMean;    }    public void testSpecialValues() {        GeometricMean mean = new GeometricMean();        // empty        assertTrue(Double.isNaN(mean.getResult()));        // finite data        mean.increment(1d);        assertFalse(Double.isNaN(mean.getResult()));        // add 0 -- makes log sum blow to minus infinity, should make 0        mean.increment(0d);        assertEquals(0d, mean.getResult(), 0);        // add positive infinity - note the minus infinity above        mean.increment(Double.POSITIVE_INFINITY);        assertTrue(Double.isNaN(mean.getResult()));        // clear        mean.clear();        assertTrue(Double.isNaN(mean.getResult()));        // positive infinity by itself        mean.increment(Double.POSITIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, mean.getResult(), 0);        // negative value -- should make NaN        mean.increment(-2d);        assertTrue(Double.isNaN(mean.getResult()));    }}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.stat.descriptive.moment;import junit.framework.TestCase;import org.apache.commons.math.DimensionMismatchException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.linear.RealMatrix;public class VectorialCovarianceTestextends TestCase {    public VectorialCovarianceTest(String name) {        super(name);        points = null;    }    public void testMismatch() {        try {            new VectorialCovariance(8, true).increment(new double[5]);            fail("an exception should have been thrown");        } catch (DimensionMismatchException dme) {            assertEquals(5, dme.getDimension1());            assertEquals(8, dme.getDimension2());        } catch (Exception e) {            fail("wrong exception type caught: " + e.getClass().getName());        }    }    public void testSimplistic() throws DimensionMismatchException {        VectorialCovariance stat = new VectorialCovariance(2, true);        stat.increment(new double[] {-1.0,  1.0});        stat.increment(new double[] { 1.0, -1.0});        RealMatrix c = stat.getResult();        assertEquals( 2.0, c.getEntry(0, 0), 1.0e-12);        assertEquals(-2.0, c.getEntry(1, 0), 1.0e-12);        assertEquals( 2.0, c.getEntry(1, 1), 1.0e-12);    }    public void testBasicStats() throws DimensionMismatchException {        VectorialCovariance stat = new VectorialCovariance(points[0].length, true);        for (int i = 0; i < points.length; ++i) {            stat.increment(points[i]);        }        assertEquals(points.length, stat.getN());        RealMatrix c = stat.getResult();        double[][] refC    = new double[][] {                { 8.0470, -1.9195, -3.4445},                {-1.9195,  1.0470,  3.2795},                {-3.4445,  3.2795, 12.2070}        };        for (int i = 0; i < c.getRowDimension(); ++i) {            for (int j = 0; j <= i; ++j) {                assertEquals(refC[i][j], c.getEntry(i, j), 1.0e-12);            }        }    }    public void testSerial(){        VectorialCovariance stat = new VectorialCovariance(points[0].length, true);        assertEquals(stat, TestUtils.serializeAndRecover(stat));    }    @Override    public void setUp() {        points = new double[][] {                { 1.2, 2.3,  4.5},                {-0.7, 2.3,  5.0},                { 3.1, 0.0, -3.1},                { 6.0, 1.2,  4.2},                {-0.7, 2.3,  5.0}        };    }    @Override    public void tearDown() {        points = null;    }    private double [][] points;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link SecondMoment} class. * @version $Revision$ $Date$ */public class SecondMomentTest extends StorelessUnivariateStatisticAbstractTest {    /** descriptive statistic. */    protected SecondMoment stat;    /**     * @param name     */    public SecondMomentTest(String name) {        super(name);    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new SecondMoment();    }    /**     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()     */    @Override    public double expectedValue() {        return this.secondMoment;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.moment;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class MeanTest extends StorelessUnivariateStatisticAbstractTest{    protected Mean stat;    /**     * @param name     */    public MeanTest(String name) {        super(name);    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Mean();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.mean;    }    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */    public double expectedWeightedValue() {        return this.weightedMean;    }    public void testSmallSamples() {        Mean mean = new Mean();        assertTrue(Double.isNaN(mean.getResult()));        mean.increment(1d);        assertEquals(1d, mean.getResult(), 0);    }    public void testWeightedMean() {        Mean mean = new Mean();        assertEquals(expectedWeightedValue(), mean.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());        assertEquals(expectedValue(), mean.evaluate(testArray, identicalWeightsArray, 0, testArray.length), getTolerance());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.summary;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link Sum} class. * @version $Revision$ $Date$ */public class SumTest extends StorelessUnivariateStatisticAbstractTest{    protected Sum stat;    /**     * @param name     */    public SumTest(String name) {        super(name);    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Sum();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.sum;    }    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */    public double expectedWeightedValue() {        return this.weightedSum;    }    public void testSpecialValues() {        Sum sum = new Sum();        assertEquals(0, sum.getResult(), 0);        sum.increment(1);        assertEquals(1, sum.getResult(), 0);        sum.increment(Double.POSITIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);        sum.increment(Double.NEGATIVE_INFINITY);        assertTrue(Double.isNaN(sum.getResult()));        sum.increment(1);        assertTrue(Double.isNaN(sum.getResult()));    }    public void testWeightedSum() {        Sum sum = new Sum();        assertEquals(expectedWeightedValue(), sum.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());        assertEquals(expectedValue(), sum.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());    }        protected void checkClearValue(StorelessUnivariateStatistic statistic){        assertEquals(0, statistic.getResult(), 0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.summary;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class SumLogTest extends StorelessUnivariateStatisticAbstractTest{    protected SumOfLogs stat;    /**     * @param name     */    public SumLogTest(String name) {        super(name);    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new SumOfLogs();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.sumLog;    }    public void testSpecialValues() {        SumOfLogs sum = new SumOfLogs();        // empty        assertEquals(0, sum.getResult(), 0);        // finite data        sum.increment(1d);        assertFalse(Double.isNaN(sum.getResult()));        // add negative infinity        sum.increment(0d);        assertEquals(Double.NEGATIVE_INFINITY, sum.getResult(), 0);        // add positive infinity -- should make NaN        sum.increment(Double.POSITIVE_INFINITY);        assertTrue(Double.isNaN(sum.getResult()));        // clear        sum.clear();        assertEquals(0, sum.getResult(), 0);        // positive infinity by itself        sum.increment(Double.POSITIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);        // negative value -- should make NaN        sum.increment(-2d);        assertTrue(Double.isNaN(sum.getResult()));    }        protected void checkClearValue(StorelessUnivariateStatistic statistic){        assertEquals(0, statistic.getResult(), 0);    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.summary;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public class ProductTest extends StorelessUnivariateStatisticAbstractTest{    protected Product stat;    /**     * @param name     */    public ProductTest(String name) {        super(name);    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new Product();    }    /**     * {@inheritDoc}     */    @Override    public double getTolerance() {        return 10E8;    //sic -- big absolute error due to only 15 digits of accuracy in double    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.product;    }    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */    public double expectedWeightedValue() {        return this.weightedProduct;    }    public void testSpecialValues() {        Product product = new Product();        assertEquals(1, product.getResult(), 0);        product.increment(1);        assertEquals(1, product.getResult(), 0);        product.increment(Double.POSITIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, product.getResult(), 0);        product.increment(Double.NEGATIVE_INFINITY);        assertEquals(Double.NEGATIVE_INFINITY, product.getResult(), 0);        product.increment(Double.NaN);        assertTrue(Double.isNaN(product.getResult()));        product.increment(1);        assertTrue(Double.isNaN(product.getResult()));    }    public void testWeightedProduct() {        Product product = new Product();        assertEquals(expectedWeightedValue(), product.evaluate(testArray, testWeightsArray, 0, testArray.length),getTolerance());        assertEquals(expectedValue(), product.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());    }        protected void checkClearValue(StorelessUnivariateStatistic statistic){        assertEquals(1, statistic.getResult(), 0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive.summary;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.descriptive.UnivariateStatistic;/** * Test cases for the {@link SumOfSquares} class. * * @version $Revision$ $Date$ */public class SumSqTest extends StorelessUnivariateStatisticAbstractTest{    protected SumOfSquares stat;    /**     * @param name     */    public SumSqTest(String name) {        super(name);    }    /**     * {@inheritDoc}     */    @Override    public UnivariateStatistic getUnivariateStatistic() {        return new SumOfSquares();    }    /**     * {@inheritDoc}     */    @Override    public double expectedValue() {        return this.sumSq;    }    public void testSpecialValues() {        SumOfSquares sumSq = new SumOfSquares();        assertEquals(0, sumSq.getResult(), 0);        sumSq.increment(2d);        assertEquals(4d, sumSq.getResult(), 0);        sumSq.increment(Double.POSITIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);        sumSq.increment(Double.NEGATIVE_INFINITY);        assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);        sumSq.increment(Double.NaN);        assertTrue(Double.isNaN(sumSq.getResult()));        sumSq.increment(1);        assertTrue(Double.isNaN(sumSq.getResult()));    }        protected void checkClearValue(StorelessUnivariateStatistic statistic){        assertEquals(0, statistic.getResult(), 0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import java.io.Serializable;import java.util.ArrayList;import java.util.List;import junit.framework.TestCase;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.util.NumberTransformer;import org.apache.commons.math.util.TransformerMap;/** * Test cases for the {@link ListUnivariateImpl} class. * * @version $Revision$ $Date$ */public final class MixedListUnivariateImplTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = FastMath.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double tolerance = 10E-15;    private TransformerMap transformers = new TransformerMap();    public MixedListUnivariateImplTest(String name) {        super(name);        transformers = new TransformerMap();        transformers.putTransformer(Foo.class, new FooTransformer());        transformers.putTransformer(Bar.class, new BarTransformer());    }    /** test stats */    public void testStats() {        List<Object> externalList = new ArrayList<Object>();        DescriptiveStatistics u = new ListUnivariateImpl(externalList,transformers);        assertEquals("total count", 0, u.getN(), tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        assertEquals("N", n, u.getN(), tolerance);        assertEquals("sum", sum, u.getSum(), tolerance);        assertEquals("sumsq", sumSq, u.getSumsq(), tolerance);        assertEquals("var", var, u.getVariance(), tolerance);        assertEquals("std", std, u.getStandardDeviation(), tolerance);        assertEquals("mean", mean, u.getMean(), tolerance);        assertEquals("min", min, u.getMin(), tolerance);        assertEquals("max", max, u.getMax(), tolerance);        u.clear();        assertEquals("total count", 0, u.getN(), tolerance);    }    public void testN0andN1Conditions() throws Exception {        DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);        assertTrue(            "Mean of n = 0 set should be NaN",            Double.isNaN(u.getMean()));        assertTrue(            "Standard Deviation of n = 0 set should be NaN",            Double.isNaN(u.getStandardDeviation()));        assertTrue(            "Variance of n = 0 set should be NaN",            Double.isNaN(u.getVariance()));        u.addValue(one);        assertTrue(            "Mean of n = 1 set should be value of single item n1, instead it is " + u.getMean() ,            u.getMean() == one);        assertTrue(            "StdDev of n = 1 set should be zero, instead it is: "                + u.getStandardDeviation(),            u.getStandardDeviation() == 0);        assertTrue(            "Variance of n = 1 set should be zero",            u.getVariance() == 0);    }    public void testSkewAndKurtosis() {        ListUnivariateImpl u =            new ListUnivariateImpl(new ArrayList<Object>(), transformers);        u.addObject("12.5");        u.addObject(Integer.valueOf(12));        u.addObject("11.8");        u.addObject("14.2");        u.addObject(new Foo());        u.addObject("14.5");        u.addObject(Long.valueOf(21));        u.addObject("8.2");        u.addObject("10.3");        u.addObject("11.3");        u.addObject(Float.valueOf(14.1f));        u.addObject("9.9");        u.addObject("12.2");        u.addObject(new Bar());        u.addObject("12.1");        u.addObject("11");        u.addObject(Double.valueOf(19.8));        u.addObject("11");        u.addObject("10");        u.addObject("8.8");        u.addObject("9");        u.addObject("12.3");        assertEquals("mean", 12.40455, u.getMean(), 0.0001);        assertEquals("variance", 10.00236, u.getVariance(), 0.0001);        assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);        assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);        u.setWindowSize(10);        u.addValue(1.0);        u.addValue(2.0);        u.addValue(3.0);        u.addValue(4.0);        assertEquals(            "Geometric mean not expected",            2.213364,            u.getGeometricMean(),            0.00001);        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution        // of a discarded element        for (int i = 0; i < 10; i++) {            u.addValue(i + 2);        }        // Values should be (2,3,4,5,6,7,8,9,10,11)        assertEquals(            "Geometric mean not expected",            5.755931,            u.getGeometricMean(),            0.00001);    }    public static final class Foo {        public String heresFoo() {            return "14.9";        }    }    public static final class FooTransformer implements NumberTransformer, Serializable {        private static final long serialVersionUID = -4252248129291326127L;        public double transform(Object o) {            return Double.parseDouble(((Foo) o).heresFoo());        }    }    public static final class Bar {        public String heresBar() {            return "12.0";        }    }    public static final class BarTransformer implements NumberTransformer, Serializable {        private static final long serialVersionUID = -1768345377764262043L;        public double transform(Object o) {            return Double.parseDouble(((Bar) o).heresBar());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.stat.descriptive;/** * Test cases for the {@link SynchronizedDescriptiveStatisticsTest} class. * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug *          2007) $ */public final class SynchronizedDescriptiveStatisticsTest extends DescriptiveStatisticsTest {    public SynchronizedDescriptiveStatisticsTest(String name) {        super(name);    }    @Override    protected DescriptiveStatistics createDescriptiveStatistics() {        return new SynchronizedDescriptiveStatistics();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;/** * Test cases for the {@link StatisticalSummaryValues} class. * * @version $Revision$ $Date$ */public final class StatisticalSummaryValuesTest extends TestCase {    public StatisticalSummaryValuesTest(String name) {        super(name);    }    public void testSerialization() {        StatisticalSummaryValues u = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);        TestUtils.checkSerializedEquality(u);        StatisticalSummaryValues t = (StatisticalSummaryValues) TestUtils.serializeAndRecover(u);        verifyEquality(u, t);    }    public void testEqualsAndHashCode() {        StatisticalSummaryValues u  = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);        StatisticalSummaryValues t = null;        assertTrue("reflexive", u.equals(u));        assertFalse("non-null compared to null", u.equals(t));        assertFalse("wrong type", u.equals(Double.valueOf(0)));        t = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);        assertTrue("instances with same data should be equal", t.equals(u));        assertEquals("hash code", u.hashCode(), t.hashCode());        u = new StatisticalSummaryValues(Double.NaN, 2, 3, 4, 5, 6);        t = new StatisticalSummaryValues(1, Double.NaN, 3, 4, 5, 6);        assertFalse("instances based on different data should be different",                (u.equals(t) ||t.equals(u)));    }    private void verifyEquality(StatisticalSummaryValues s, StatisticalSummaryValues u) {        assertEquals("N",s.getN(),u.getN());        TestUtils.assertEquals("sum",s.getSum(),u.getSum(), 0);        TestUtils.assertEquals("var",s.getVariance(),u.getVariance(), 0);        TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(), 0);        TestUtils.assertEquals("mean",s.getMean(),u.getMean(), 0);        TestUtils.assertEquals("min",s.getMin(),u.getMin(), 0);        TestUtils.assertEquals("max",s.getMax(),u.getMax(), 0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 *s * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import java.util.ArrayList;import java.util.List;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.random.RandomData;import org.apache.commons.math.random.RandomDataImpl;import org.apache.commons.math.util.FastMath;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */public abstract class UnivariateStatisticAbstractTest extends TestCase {    protected double mean = 12.404545454545455d;    protected double geoMean = 12.070589161633011d;    protected double var = 10.00235930735931d;    protected double std = FastMath.sqrt(var);    protected double skew = 1.437423729196190d;    protected double kurt = 2.377191264804700d;    protected double min = 8.2d;    protected double max = 21d;    protected double median = 12d;    protected double percentile5 = 8.29d;    protected double percentile95 = 20.82d;    protected double product = 628096400563833396009676.9200400128d;    protected double sumLog = 54.7969806116451507d;    protected double sumSq = 3595.250d;    protected double sum = 272.90d;    protected double secondMoment = 210.04954545454547d;    protected double thirdMoment = 868.0906859504136;    protected double fourthMoment = 9244.080993773481;    protected double weightedMean = 12.366995073891626d;    protected double weightedVar =   9.974760968886391d;    protected double weightedStd = FastMath.sqrt(weightedVar);    protected double weightedProduct = 8517647448765288000000d;    protected double weightedSum = 251.05d;    protected double tolerance = 10E-12;    protected double[] testArray =        { 12.5, 12.0, 11.8, 14.2, 14.9, 14.5, 21.0,  8.2, 10.3, 11.3,          14.1,  9.9, 12.2, 12.0, 12.1, 11.0, 19.8, 11.0, 10.0,  8.8,           9.0, 12.3 };    protected double[] testWeightsArray =        {  1.5,  0.8,  1.2,  0.4,  0.8,  1.8,  1.2,  1.1,  1.0,  0.7,           1.3,  0.6,  0.7,  1.3,  0.7,  1.0,  0.4,  0.1,  1.4,  0.9,           1.1,  0.3 };    protected double[] identicalWeightsArray =        {  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,           0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,           0.5,  0.5 };    protected double[] unitWeightsArray =        {  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,           1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,           1.0,  1.0 };    public UnivariateStatisticAbstractTest(String name) {        super(name);    }    public abstract UnivariateStatistic getUnivariateStatistic();    public abstract double expectedValue();    public double getTolerance() {        return tolerance;    }    public void testEvaluation() throws Exception {        assertEquals(            expectedValue(),            getUnivariateStatistic().evaluate(testArray),            getTolerance());    }    public void testCopy() throws Exception {        UnivariateStatistic original = getUnivariateStatistic();        UnivariateStatistic copy = original.copy();        assertEquals(                expectedValue(),                copy.evaluate(testArray),                getTolerance());    }    /**     * Tests consistency of weighted statistic computation.     * For statistics that support weighted evaluation, this test case compares     * the result of direct computation on an array with repeated values with     * a weighted computation on the corresponding (shorter) array with each     * value appearing only once but with a weight value equal to its multiplicity     * in the repeating array.     */    public void testWeightedConsistency() throws Exception {        // See if this statistic computes weighted statistics        // If not, skip this test        UnivariateStatistic statistic = getUnivariateStatistic();        if (!(statistic instanceof WeightedEvaluation)) {            return;        }        // Create arrays of values and corresponding integral weights        // and longer array with values repeated according to the weights        final int len = 10;        // length of values array        final double mu = 0;       // mean of test data        final double sigma = 5;    // std dev of test data        double[] values = new double[len];        double[] weights = new double[len];        RandomData randomData = new RandomDataImpl();        // Fill weights array with random int values between 1 and 5        int[] intWeights = new int[len];        for (int i = 0; i < len; i++) {            intWeights[i] = randomData.nextInt(1, 5);            weights[i] = intWeights[i];        }        // Fill values array with random data from N(mu, sigma)        // and fill valuesList with values from values array with        // values[i] repeated weights[i] times, each i        List<Double> valuesList = new ArrayList<Double>();        for (int i = 0; i < len; i++) {            double value = randomData.nextGaussian(mu, sigma);            values[i] = value;            for (int j = 0; j < intWeights[i]; j++) {                valuesList.add(new Double(value));            }        }        // Dump valuesList into repeatedValues array        int sumWeights = valuesList.size();        double[] repeatedValues = new double[sumWeights];        for (int i = 0; i < sumWeights; i++) {            repeatedValues[i] = valuesList.get(i);        }        // Compare result of weighted statistic computation with direct computation        // on array of repeated values        WeightedEvaluation weightedStatistic = (WeightedEvaluation) statistic;        TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),                weightedStatistic.evaluate(values, weights, 0, values.length),                10E-14);        // Check consistency of weighted evaluation methods        assertEquals(weightedStatistic.evaluate(values, weights, 0, values.length),                weightedStatistic.evaluate(values, weights), Double.MIN_VALUE);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.stat.descriptive;import java.util.Locale;import junit.framework.TestCase;import org.apache.commons.math.stat.descriptive.rank.Percentile;import org.apache.commons.math.util.MathUtils;/** * Test cases for the DescriptiveStatistics class. * * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug *          2007) $ */public class DescriptiveStatisticsTest extends TestCase {    public DescriptiveStatisticsTest(String name) {        super(name);    }    protected DescriptiveStatistics createDescriptiveStatistics() {        return new DescriptiveStatistics();    }    public void testSetterInjection() {        DescriptiveStatistics stats = createDescriptiveStatistics();        stats.addValue(1);        stats.addValue(3);        assertEquals(2, stats.getMean(), 1E-10);        // Now lets try some new math        stats.setMeanImpl(new deepMean());        assertEquals(42, stats.getMean(), 1E-10);    }    public void testCopy() {        DescriptiveStatistics stats = createDescriptiveStatistics();        stats.addValue(1);        stats.addValue(3);        DescriptiveStatistics copy = new DescriptiveStatistics(stats);        assertEquals(2, copy.getMean(), 1E-10);        // Now lets try some new math        stats.setMeanImpl(new deepMean());        copy = stats.copy();        assertEquals(42, copy.getMean(), 1E-10);    }    public void testWindowSize() {        DescriptiveStatistics stats = createDescriptiveStatistics();        stats.setWindowSize(300);        for (int i = 0; i < 100; ++i) {            stats.addValue(i + 1);        }        int refSum = (100 * 101) / 2;        assertEquals(refSum / 100.0, stats.getMean(), 1E-10);        assertEquals(300, stats.getWindowSize());        try {            stats.setWindowSize(-3);            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected        } catch (Exception e) {            fail("wrong exception caught: " + e.getMessage());        }        assertEquals(300, stats.getWindowSize());        stats.setWindowSize(50);        assertEquals(50, stats.getWindowSize());        int refSum2 = refSum - (50 * 51) / 2;        assertEquals(refSum2 / 50.0, stats.getMean(), 1E-10);    }    public void testGetValues() {        DescriptiveStatistics stats = createDescriptiveStatistics();        for (int i = 100; i > 0; --i) {            stats.addValue(i);        }        int refSum = (100 * 101) / 2;        assertEquals(refSum / 100.0, stats.getMean(), 1E-10);        double[] v = stats.getValues();        for (int i = 0; i < v.length; ++i) {            assertEquals(100.0 - i, v[i], 1.0e-10);        }        double[] s = stats.getSortedValues();        for (int i = 0; i < s.length; ++i) {            assertEquals(i + 1.0, s[i], 1.0e-10);        }        assertEquals(12.0, stats.getElement(88), 1.0e-10);    }    public void testToString() {        DescriptiveStatistics stats = createDescriptiveStatistics();        stats.addValue(1);        stats.addValue(2);        stats.addValue(3);        Locale d = Locale.getDefault();        Locale.setDefault(Locale.US);        assertEquals("DescriptiveStatistics:\n" +                     "n: 3\n" +                     "min: 1.0\n" +                     "max: 3.0\n" +                     "mean: 2.0\n" +                     "std dev: 1.0\n" +                     "median: 2.0\n" +                     "skewness: 0.0\n" +                     "kurtosis: NaN\n",  stats.toString());        Locale.setDefault(d);    }    public void testShuffledStatistics() {        // the purpose of this test is only to check the get/set methods        // we are aware shuffling statistics like this is really not        // something sensible to do in production ...        DescriptiveStatistics reference = createDescriptiveStatistics();        DescriptiveStatistics shuffled  = createDescriptiveStatistics();        UnivariateStatistic tmp = shuffled.getGeometricMeanImpl();        shuffled.setGeometricMeanImpl(shuffled.getMeanImpl());        shuffled.setMeanImpl(shuffled.getKurtosisImpl());        shuffled.setKurtosisImpl(shuffled.getSkewnessImpl());        shuffled.setSkewnessImpl(shuffled.getVarianceImpl());        shuffled.setVarianceImpl(shuffled.getMaxImpl());        shuffled.setMaxImpl(shuffled.getMinImpl());        shuffled.setMinImpl(shuffled.getSumImpl());        shuffled.setSumImpl(shuffled.getSumsqImpl());        shuffled.setSumsqImpl(tmp);        for (int i = 100; i > 0; --i) {            reference.addValue(i);            shuffled.addValue(i);        }        assertEquals(reference.getMean(),          shuffled.getGeometricMean(), 1.0e-10);        assertEquals(reference.getKurtosis(),      shuffled.getMean(),          1.0e-10);        assertEquals(reference.getSkewness(),      shuffled.getKurtosis(), 1.0e-10);        assertEquals(reference.getVariance(),      shuffled.getSkewness(), 1.0e-10);        assertEquals(reference.getMax(),           shuffled.getVariance(), 1.0e-10);        assertEquals(reference.getMin(),           shuffled.getMax(), 1.0e-10);        assertEquals(reference.getSum(),           shuffled.getMin(), 1.0e-10);        assertEquals(reference.getSumsq(),         shuffled.getSum(), 1.0e-10);        assertEquals(reference.getGeometricMean(), shuffled.getSumsq(), 1.0e-10);    }    public void testPercentileSetter() throws Exception {        DescriptiveStatistics stats = createDescriptiveStatistics();        stats.addValue(1);        stats.addValue(2);        stats.addValue(3);        assertEquals(2, stats.getPercentile(50.0), 1E-10);        // Inject wrapped Percentile impl        stats.setPercentileImpl(new goodPercentile());        assertEquals(2, stats.getPercentile(50.0), 1E-10);        // Try "new math" impl        stats.setPercentileImpl(new subPercentile());        assertEquals(10.0, stats.getPercentile(10.0), 1E-10);        // Try to set bad impl        try {            stats.setPercentileImpl(new badPercentile());            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void test20090720() {        DescriptiveStatistics descriptiveStatistics = new DescriptiveStatistics(100);        for (int i = 0; i < 161; i++) {            descriptiveStatistics.addValue(1.2);        }        descriptiveStatistics.clear();        descriptiveStatistics.addValue(1.2);        assertEquals(1, descriptiveStatistics.getN());    }    public void testRemoval() {        final DescriptiveStatistics dstat = createDescriptiveStatistics();        checkremoval(dstat, 1, 6.0, 0.0, Double.NaN);        checkremoval(dstat, 3, 5.0, 3.0, 4.5);        checkremoval(dstat, 6, 3.5, 2.5, 3.0);        checkremoval(dstat, 9, 3.5, 2.5, 3.0);        checkremoval(dstat, DescriptiveStatistics.INFINITE_WINDOW, 3.5, 2.5, 3.0);    }    public void checkremoval(DescriptiveStatistics dstat, int wsize,                             double mean1, double mean2, double mean3) {        dstat.setWindowSize(wsize);        dstat.clear();        for (int i = 1 ; i <= 6 ; ++i) {            dstat.addValue(i);        }        assertTrue(MathUtils.equalsIncludingNaN(mean1, dstat.getMean()));        dstat.replaceMostRecentValue(0);        assertTrue(MathUtils.equalsIncludingNaN(mean2, dstat.getMean()));        dstat.removeMostRecentValue();        assertTrue(MathUtils.equalsIncludingNaN(mean3, dstat.getMean()));    }    // Test UnivariateStatistics impls for setter injection tests    /**     * A new way to compute the mean     */    static class deepMean implements UnivariateStatistic {        public double evaluate(double[] values, int begin, int length) {            return 42;        }        public double evaluate(double[] values) {            return 42;        }        public UnivariateStatistic copy() {            return new deepMean();        }    }    /**     * Test percentile implementation - wraps a Percentile     */    static class goodPercentile implements UnivariateStatistic {        private Percentile percentile = new Percentile();        public void setQuantile(double quantile) {            percentile.setQuantile(quantile);        }        public double evaluate(double[] values, int begin, int length) {            return percentile.evaluate(values, begin, length);        }        public double evaluate(double[] values) {            return percentile.evaluate(values);        }        public UnivariateStatistic copy() {            goodPercentile result = new goodPercentile();            result.setQuantile(percentile.getQuantile());            return result;        }    }    /**     * Test percentile subclass - another "new math" impl     * Always returns currently set quantile     */    static class subPercentile extends Percentile {        @Override        public double evaluate(double[] values, int begin, int length) {            return getQuantile();        }        @Override        public double evaluate(double[] values) {            return getQuantile();        }        private static final long serialVersionUID = 8040701391045914979L;        @Override        public Percentile copy() {            subPercentile result = new subPercentile();            return result;        }    }    /**     * "Bad" test percentile implementation - no setQuantile     */    static class badPercentile implements UnivariateStatistic {        private Percentile percentile = new Percentile();        public double evaluate(double[] values, int begin, int length) {            return percentile.evaluate(values, begin, length);        }        public double evaluate(double[] values) {            return percentile.evaluate(values);        }        public UnivariateStatistic copy() {            return new badPercentile();        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.TestCase;import org.apache.commons.math.stat.descriptive.moment.Mean;/** * Tests for AbstractUnivariateStatistic * * @version $Revision$ $Date$ */public class AbstractUnivariateStatisticTest extends TestCase {    public AbstractUnivariateStatisticTest(String name) {        super(name);    }    protected double[] testArray = {0, 1, 2, 3, 4, 5};    protected double[] testWeightsArray = {0.3, 0.2, 1.3, 1.1, 1.0, 1.8};    protected double[] testNegativeWeightsArray = {-0.3, 0.2, -1.3, 1.1, 1.0, 1.8};    protected double[] nullArray = null;    protected double[] singletonArray = {0};    protected Mean testStatistic = new Mean();    public void testTestPositive() {        for (int j = 0; j < 6; j++) {            for (int i = 1; i < (7 - j); i++) {                assertTrue(testStatistic.test(testArray, 0, i));            }        }        assertTrue(testStatistic.test(singletonArray, 0, 1));        assertTrue(testStatistic.test(singletonArray, 0, 0, true));    }    public void testTestNegative() {        assertFalse(testStatistic.test(singletonArray, 0, 0));        assertFalse(testStatistic.test(testArray, 0, 0));        try {            testStatistic.test(singletonArray, 2, 1);  // start past end            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, 0, 7);  // end past end            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, -1, 1);  // start negative            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, 0, -1);  // length negative            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(nullArray, 0, 1);  // null array            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, nullArray, 0, 1);  // null weights array            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(singletonArray, testWeightsArray, 0, 1);  // weights.length != value.length            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, testNegativeWeightsArray, 0, 6);  // can't have negative weights            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import java.util.ArrayList;import java.util.List;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;/** * Test cases for the {@link ListUnivariateImpl} class. * * @version $Revision$ $Date$ */public final class ListUnivariateImplTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = FastMath.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double tolerance = 10E-15;    public ListUnivariateImplTest(String name) {        super(name);    }    /** test stats */    public void testStats() {        List<Object> externalList = new ArrayList<Object>();        DescriptiveStatistics u = new ListUnivariateImpl( externalList );        assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);    }    public void testN0andN1Conditions() throws Exception {        List<Object> list = new ArrayList<Object>();        DescriptiveStatistics u = new ListUnivariateImpl( list );        assertTrue("Mean of n = 0 set should be NaN", Double.isNaN( u.getMean() ) );        assertTrue("Standard Deviation of n = 0 set should be NaN", Double.isNaN( u.getStandardDeviation() ) );        assertTrue("Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance() ) );        list.add( Double.valueOf(one));        assertTrue( "Mean of n = 1 set should be value of single item n1", u.getMean() == one);        assertTrue( "StdDev of n = 1 set should be zero, instead it is: " + u.getStandardDeviation(), u.getStandardDeviation() == 0);        assertTrue( "Variance of n = 1 set should be zero", u.getVariance() == 0);    }    public void testSkewAndKurtosis() {        DescriptiveStatistics u = new DescriptiveStatistics();        double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,                                             9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };        for( int i = 0; i < testArray.length; i++) {            u.addValue( testArray[i]);        }        assertEquals("mean", 12.40455, u.getMean(), 0.0001);        assertEquals("variance", 10.00236, u.getVariance(), 0.0001);        assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);        assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>());        u.setWindowSize(10);        u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001 );        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution        // of a discarded element        for( int i = 0; i < 10; i++ ) {            u.addValue( i + 2 );        }        // Values should be (2,3,4,5,6,7,8,9,10,11)        assertEquals( "Geometric mean not expected", 5.755931, u.getGeometricMean(), 0.00001 );    }    /** test stats */    public void testSerialization() {        DescriptiveStatistics u = new ListUnivariateImpl();        assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);        DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u);        u2.addValue(two);        u2.addValue(three);        assertEquals("N",n,u2.getN(),tolerance);        assertEquals("sum",sum,u2.getSum(),tolerance);        assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance);        assertEquals("var",var,u2.getVariance(),tolerance);        assertEquals("std",std,u2.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u2.getMean(),tolerance);        assertEquals("min",min,u2.getMin(),tolerance);        assertEquals("max",max,u2.getMax(),tolerance);        u2.clear();        assertEquals("total count",0,u2.getN(),tolerance);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.stat.descriptive;/** * Test cases for the {@link SynchronizedSummaryStatisticsTest} class. * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug *          2007) $ */public final class SynchronizedSummaryStatisticsTest extends SummaryStatisticsTest {    public SynchronizedSummaryStatisticsTest(String name) {        super(name);    }    @Override    protected SummaryStatistics createSummaryStatistics() {        return new SynchronizedSummaryStatistics();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.moment.Mean;import org.apache.commons.math.stat.descriptive.summary.Sum;import org.apache.commons.math.util.FastMath;/** * Test cases for the {@link SummaryStatistics} class. * * @version $Revision$ $Date$ */public class SummaryStatisticsTest extends TestCase {    private double one = 1;    private float twoF = 2;    private long twoL = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = FastMath.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double tolerance = 10E-15;    public SummaryStatisticsTest(String name) {        super(name);    }    protected SummaryStatistics createSummaryStatistics() {        return new SummaryStatistics();    }    /** test stats */    public void testStats() {        SummaryStatistics u = createSummaryStatistics();        assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(twoF);        u.addValue(twoL);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);    }    public void testN0andN1Conditions() throws Exception {        SummaryStatistics u = createSummaryStatistics();        assertTrue("Mean of n = 0 set should be NaN",                Double.isNaN( u.getMean() ) );        assertTrue("Standard Deviation of n = 0 set should be NaN",                Double.isNaN( u.getStandardDeviation() ) );        assertTrue("Variance of n = 0 set should be NaN",                Double.isNaN(u.getVariance() ) );        /* n=1 */        u.addValue(one);        assertTrue("mean should be one (n = 1)",                u.getMean() == one);        assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(),                u.getGeometricMean() == one);        assertTrue("Std should be zero (n = 1)",                u.getStandardDeviation() == 0.0);        assertTrue("variance should be zero (n = 1)",                u.getVariance() == 0.0);        /* n=2 */        u.addValue(twoF);        assertTrue("Std should not be zero (n = 2)",                u.getStandardDeviation() != 0.0);        assertTrue("variance should not be zero (n = 2)",                u.getVariance() != 0.0);    }    public void testProductAndGeometricMean() throws Exception {        SummaryStatistics u = createSummaryStatistics();        u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        assertEquals( "Geometric mean not expected", 2.213364,                u.getGeometricMean(), 0.00001 );    }    public void testNaNContracts() {        SummaryStatistics u = createSummaryStatistics();        assertTrue("mean not NaN",Double.isNaN(u.getMean()));        assertTrue("min not NaN",Double.isNaN(u.getMin()));        assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation()));        assertTrue("var not NaN",Double.isNaN(u.getVariance()));        assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));        u.addValue(1.0);        assertEquals( "mean not expected", 1.0,                u.getMean(), Double.MIN_VALUE);        assertEquals( "variance not expected", 0.0,                u.getVariance(), Double.MIN_VALUE);        assertEquals( "geometric mean not expected", 1.0,                u.getGeometricMean(), Double.MIN_VALUE);        u.addValue(-1.0);        assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));        u.addValue(0.0);        assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));        //FiXME: test all other NaN contract specs    }    public void testGetSummary() {        SummaryStatistics u = createSummaryStatistics();        StatisticalSummary summary = u.getSummary();        verifySummary(u, summary);        u.addValue(1d);        summary = u.getSummary();        verifySummary(u, summary);        u.addValue(2d);        summary = u.getSummary();        verifySummary(u, summary);        u.addValue(2d);        summary = u.getSummary();        verifySummary(u, summary);    }    public void testSerialization() {        SummaryStatistics u = createSummaryStatistics();        // Empty test        TestUtils.checkSerializedEquality(u);        SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);        StatisticalSummary summary = s.getSummary();        verifySummary(u, summary);        // Add some data        u.addValue(2d);        u.addValue(1d);        u.addValue(3d);        u.addValue(4d);        u.addValue(5d);        // Test again        TestUtils.checkSerializedEquality(u);        s = (SummaryStatistics) TestUtils.serializeAndRecover(u);        summary = s.getSummary();        verifySummary(u, summary);    }    public void testEqualsAndHashCode() {        SummaryStatistics u = createSummaryStatistics();        SummaryStatistics t = null;        int emptyHash = u.hashCode();        assertTrue("reflexive", u.equals(u));        assertFalse("non-null compared to null", u.equals(t));        assertFalse("wrong type", u.equals(Double.valueOf(0)));        t = createSummaryStatistics();        assertTrue("empty instances should be equal", t.equals(u));        assertTrue("empty instances should be equal", u.equals(t));        assertEquals("empty hash code", emptyHash, t.hashCode());        // Add some data to u        u.addValue(2d);        u.addValue(1d);        u.addValue(3d);        u.addValue(4d);        assertFalse("different n's should make instances not equal", t.equals(u));        assertFalse("different n's should make instances not equal", u.equals(t));        assertTrue("different n's should make hashcodes different",                u.hashCode() != t.hashCode());        //Add data in same order to t        t.addValue(2d);        t.addValue(1d);        t.addValue(3d);        t.addValue(4d);        assertTrue("summaries based on same data should be equal", t.equals(u));        assertTrue("summaries based on same data should be equal", u.equals(t));        assertEquals("summaries based on same data should have same hashcodes",                u.hashCode(), t.hashCode());        // Clear and make sure summaries are indistinguishable from empty summary        u.clear();        t.clear();        assertTrue("empty instances should be equal", t.equals(u));        assertTrue("empty instances should be equal", u.equals(t));        assertEquals("empty hash code", emptyHash, t.hashCode());        assertEquals("empty hash code", emptyHash, u.hashCode());    }    public void testCopy() throws Exception {        SummaryStatistics u = createSummaryStatistics();        u.addValue(2d);        u.addValue(1d);        u.addValue(3d);        u.addValue(4d);        SummaryStatistics v = new SummaryStatistics(u);        assertEquals(u, v);        assertEquals(v, u);        assertTrue(v.geoMean == v.getGeoMeanImpl());        assertTrue(v.mean == v.getMeanImpl());        assertTrue(v.min == v.getMinImpl());        assertTrue(v.max == v.getMaxImpl());        assertTrue(v.sum == v.getSumImpl());        assertTrue(v.sumsq == v.getSumsqImpl());        assertTrue(v.sumLog == v.getSumLogImpl());        assertTrue(v.variance == v.getVarianceImpl());        // Make sure both behave the same with additional values added        u.addValue(7d);        u.addValue(9d);        u.addValue(11d);        u.addValue(23d);        v.addValue(7d);        v.addValue(9d);        v.addValue(11d);        v.addValue(23d);        assertEquals(u, v);        assertEquals(v, u);        // Check implementation pointers are preserved        u.clear();        u.setSumImpl(new Sum());        SummaryStatistics.copy(u,v);        assertEquals(u.sum, v.sum);        assertEquals(u.getSumImpl(), v.getSumImpl());    }    private void verifySummary(SummaryStatistics u, StatisticalSummary s) {        assertEquals("N",s.getN(),u.getN());        TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance);        TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance);        TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);        TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance);        TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance);        TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance);    }    public void testSetterInjection() throws Exception {        SummaryStatistics u = createSummaryStatistics();        u.setMeanImpl(new Sum());        u.setSumLogImpl(new Sum());        u.addValue(1);        u.addValue(3);        assertEquals(4, u.getMean(), 1E-14);        assertEquals(4, u.getSumOfLogs(), 1E-14);        assertEquals(FastMath.exp(2), u.getGeometricMean(), 1E-14);        u.clear();        u.addValue(1);        u.addValue(2);        assertEquals(3, u.getMean(), 1E-14);        u.clear();        u.setMeanImpl(new Mean()); // OK after clear    }    public void testSetterIllegalState() throws Exception {        SummaryStatistics u = createSummaryStatistics();        u.addValue(1);        u.addValue(3);        try {            u.setMeanImpl(new Sum());            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import java.util.ArrayList;import java.util.Collection;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.random.RandomData;import org.apache.commons.math.random.RandomDataImpl;/** * Test cases for {@link AggregateSummaryStatistics} * */public class AggregateSummaryStatisticsTest extends TestCase {    /**     * Tests the standard aggregation behavior     */    public void testAggregation() {        AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();        SummaryStatistics setOneStats = aggregate.createContributingStatistics();        SummaryStatistics setTwoStats = aggregate.createContributingStatistics();        assertNotNull("The set one contributing stats are null", setOneStats);        assertNotNull("The set two contributing stats are null", setTwoStats);        assertNotSame("Contributing stats objects are the same", setOneStats, setTwoStats);        setOneStats.addValue(2);        setOneStats.addValue(3);        setOneStats.addValue(5);        setOneStats.addValue(7);        setOneStats.addValue(11);        assertEquals("Wrong number of set one values", 5, setOneStats.getN());        assertEquals("Wrong sum of set one values", 28.0, setOneStats.getSum());        setTwoStats.addValue(2);        setTwoStats.addValue(4);        setTwoStats.addValue(8);        assertEquals("Wrong number of set two values", 3, setTwoStats.getN());        assertEquals("Wrong sum of set two values", 14.0, setTwoStats.getSum());        assertEquals("Wrong number of aggregate values", 8, aggregate.getN());        assertEquals("Wrong aggregate sum", 42.0, aggregate.getSum());    }    /**     * Verify that aggregating over a partition gives the same results     * as direct computation.     *     *  1) Randomly generate a dataset of 10-100 values     *     from [-100, 100]     *  2) Divide the dataset it into 2-5 partitions     *  3) Create an AggregateSummaryStatistic and ContributingStatistics     *     for each partition     *  4) Compare results from the AggregateSummaryStatistic with values     *     returned by a single SummaryStatistics instance that is provided     *     the full dataset     */    public void testAggregationConsistency() throws Exception {        // Generate a random sample and random partition        double[] totalSample = generateSample();        double[][] subSamples = generatePartition(totalSample);        int nSamples = subSamples.length;        // Create aggregator and total stats for comparison        AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();        SummaryStatistics totalStats = new SummaryStatistics();        // Create array of component stats        SummaryStatistics componentStats[] = new SummaryStatistics[nSamples];        for (int i = 0; i < nSamples; i++) {            // Make componentStats[i] a contributing statistic to aggregate            componentStats[i] = aggregate.createContributingStatistics();            // Add values from subsample            for (int j = 0; j < subSamples[i].length; j++) {                componentStats[i].addValue(subSamples[i][j]);            }        }        // Compute totalStats directly        for (int i = 0; i < totalSample.length; i++) {            totalStats.addValue(totalSample[i]);        }        /*         * Compare statistics in totalStats with aggregate.         * Note that guaranteed success of this comparison depends on the         * fact that <aggregate> gets values in exactly the same order         * as <totalStats>.         *         */        assertEquals(totalStats.getSummary(), aggregate.getSummary());    }    /**     * Test aggregate function by randomly generating a dataset of 10-100 values     * from [-100, 100], dividing it into 2-5 partitions, computing stats for each     * partition and comparing the result of aggregate(...) applied to the collection     * of per-partition SummaryStatistics with a single SummaryStatistics computed     * over the full sample.     *     * @throws Exception     */    public void testAggregate() throws Exception {        // Generate a random sample and random partition        double[] totalSample = generateSample();        double[][] subSamples = generatePartition(totalSample);        int nSamples = subSamples.length;        // Compute combined stats directly        SummaryStatistics totalStats = new SummaryStatistics();        for (int i = 0; i < totalSample.length; i++) {            totalStats.addValue(totalSample[i]);        }        // Now compute subsample stats individually and aggregate        SummaryStatistics[] subSampleStats = new SummaryStatistics[nSamples];        for (int i = 0; i < nSamples; i++) {            subSampleStats[i] = new SummaryStatistics();        }        Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();        for (int i = 0; i < nSamples; i++) {            for (int j = 0; j < subSamples[i].length; j++) {                subSampleStats[i].addValue(subSamples[i][j]);            }            aggregate.add(subSampleStats[i]);        }        // Compare values        StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);        assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);    }    public void testAggregateDegenerate() throws Exception {        double[] totalSample = {1, 2, 3, 4, 5};        double[][] subSamples = {{1}, {2}, {3}, {4}, {5}};        // Compute combined stats directly        SummaryStatistics totalStats = new SummaryStatistics();        for (int i = 0; i < totalSample.length; i++) {            totalStats.addValue(totalSample[i]);        }        // Now compute subsample stats individually and aggregate        SummaryStatistics[] subSampleStats = new SummaryStatistics[5];        for (int i = 0; i < 5; i++) {            subSampleStats[i] = new SummaryStatistics();        }        Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();        for (int i = 0; i < 5; i++) {            for (int j = 0; j < subSamples[i].length; j++) {                subSampleStats[i].addValue(subSamples[i][j]);            }            aggregate.add(subSampleStats[i]);        }        // Compare values        StatisticalSummaryValues aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);        assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);    }    public void testAggregateSpecialValues() throws Exception {        double[] totalSample = {Double.POSITIVE_INFINITY, 2, 3, Double.NaN, 5};        double[][] subSamples = {{Double.POSITIVE_INFINITY, 2}, {3}, {Double.NaN}, {5}};        // Compute combined stats directly        SummaryStatistics totalStats = new SummaryStatistics();        for (int i = 0; i < totalSample.length; i++) {            totalStats.addValue(totalSample[i]);        }        // Now compute subsample stats individually and aggregate        SummaryStatistics[] subSampleStats = new SummaryStatistics[5];        for (int i = 0; i < 4; i++) {            subSampleStats[i] = new SummaryStatistics();        }        Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();        for (int i = 0; i < 4; i++) {            for (int j = 0; j < subSamples[i].length; j++) {                subSampleStats[i].addValue(subSamples[i][j]);            }            aggregate.add(subSampleStats[i]);        }        // Compare values        StatisticalSummaryValues aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);        assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);    }    /**     * Verifies that a StatisticalSummary and a StatisticalSummaryValues are equal up     * to delta, with NaNs, infinities returned in the same spots. For max, min, n, values     * have to agree exactly, delta is used only for sum, mean, variance, std dev.     */    protected static void assertEquals(StatisticalSummary expected, StatisticalSummary observed, double delta) {        TestUtils.assertEquals(expected.getMax(), observed.getMax(), 0);        TestUtils.assertEquals(expected.getMin(), observed.getMin(), 0);        assertEquals(expected.getN(), observed.getN());        TestUtils.assertEquals(expected.getSum(), observed.getSum(), delta);        TestUtils.assertEquals(expected.getMean(), observed.getMean(), delta);        TestUtils.assertEquals(expected.getStandardDeviation(), observed.getStandardDeviation(), delta);        TestUtils.assertEquals(expected.getVariance(), observed.getVariance(), delta);    }    /**     * Generates a random sample of double values.     * Sample size is random, between 10 and 100 and values are     * uniformly distributed over [-100, 100].     *     * @return array of random double values     */    private double[] generateSample() {        final RandomData randomData = new RandomDataImpl();        final int sampleSize = randomData.nextInt(10,100);        double[] out = new double[sampleSize];        for (int i = 0; i < out.length; i++) {            out[i] = randomData.nextUniform(-100, 100);        }        return out;    }    /**     * Generates a partition of <sample> into up to 5 sequentially selected     * subsamples with randomly selected partition points.     *     * @param sample array to partition     * @return rectangular array with rows = subsamples     */    private double[][] generatePartition(double[] sample) {        final int length = sample.length;        final double[][] out = new double[5][];        final RandomData randomData = new RandomDataImpl();        int cur = 0;        int offset = 0;        int sampleCount = 0;        for (int i = 0; i < 5; i++) {            if (cur == length || offset == length) {                break;            }            final int next = (i == 4 || cur == length - 1) ? length - 1 : randomData.nextInt(cur, length - 1);            final int subLength = next - cur + 1;            out[i] = new double[subLength];            System.arraycopy(sample, offset, out[i], 0, subLength);            cur = next + 1;            sampleCount++;            offset += subLength;        }        if (sampleCount < 5) {            double[][] out2 = new double[sampleCount][];            for (int j = 0; j < sampleCount; j++) {                final int curSize = out[j].length;                out2[j] = new double[curSize];                System.arraycopy(out[j], 0, out2[j], 0, curSize);            }            return out2;        } else {            return out;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import java.util.Locale;import junit.framework.TestCase;import org.apache.commons.math.DimensionMismatchException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.moment.Mean;import org.apache.commons.math.util.FastMath;/** * Test cases for the {@link MultivariateSummaryStatistics} class. * * @version $Revision$ $Date$ */public class MultivariateSummaryStatisticsTest extends TestCase {    public MultivariateSummaryStatisticsTest(String name) {        super(name);    }    protected MultivariateSummaryStatistics createMultivariateSummaryStatistics(int k, boolean isCovarianceBiasCorrected) {        return new MultivariateSummaryStatistics(k, isCovarianceBiasCorrected);    }    public void testSetterInjection() throws Exception {        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);        u.setMeanImpl(new StorelessUnivariateStatistic[] {                        new sumMean(), new sumMean()                      });        u.addValue(new double[] { 1, 2 });        u.addValue(new double[] { 3, 4 });        assertEquals(4, u.getMean()[0], 1E-14);        assertEquals(6, u.getMean()[1], 1E-14);        u.clear();        u.addValue(new double[] { 1, 2 });        u.addValue(new double[] { 3, 4 });        assertEquals(4, u.getMean()[0], 1E-14);        assertEquals(6, u.getMean()[1], 1E-14);        u.clear();        u.setMeanImpl(new StorelessUnivariateStatistic[] {                        new Mean(), new Mean()                      }); // OK after clear        u.addValue(new double[] { 1, 2 });        u.addValue(new double[] { 3, 4 });        assertEquals(2, u.getMean()[0], 1E-14);        assertEquals(3, u.getMean()[1], 1E-14);        assertEquals(2, u.getDimension());    }    public void testSetterIllegalState() throws Exception {        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);        u.addValue(new double[] { 1, 2 });        u.addValue(new double[] { 3, 4 });        try {            u.setMeanImpl(new StorelessUnivariateStatistic[] {                            new sumMean(), new sumMean()                          });            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {            // expected        }    }    public void testToString() throws DimensionMismatchException {        MultivariateSummaryStatistics stats = createMultivariateSummaryStatistics(2, true);        stats.addValue(new double[] {1, 3});        stats.addValue(new double[] {2, 2});        stats.addValue(new double[] {3, 1});        Locale d = Locale.getDefault();        Locale.setDefault(Locale.US);        final String suffix = System.getProperty("line.separator");        assertEquals("MultivariateSummaryStatistics:" + suffix+                     "n: 3" +suffix+                     "min: 1.0, 1.0" +suffix+                     "max: 3.0, 3.0" +suffix+                     "mean: 2.0, 2.0" +suffix+                     "geometric mean: 1.817..., 1.817..." +suffix+                     "sum of squares: 14.0, 14.0" +suffix+                     "sum of logarithms: 1.791..., 1.791..." +suffix+                     "standard deviation: 1.0, 1.0" +suffix+                     "covariance: Array2DRowRealMatrix{{1.0,-1.0},{-1.0,1.0}}" +suffix,                     stats.toString().replaceAll("([0-9]+\\.[0-9][0-9][0-9])[0-9]+", "$1..."));        Locale.setDefault(d);    }    public void testShuffledStatistics() throws DimensionMismatchException {        // the purpose of this test is only to check the get/set methods        // we are aware shuffling statistics like this is really not        // something sensible to do in production ...        MultivariateSummaryStatistics reference = createMultivariateSummaryStatistics(2, true);        MultivariateSummaryStatistics shuffled  = createMultivariateSummaryStatistics(2, true);        StorelessUnivariateStatistic[] tmp = shuffled.getGeoMeanImpl();        shuffled.setGeoMeanImpl(shuffled.getMeanImpl());        shuffled.setMeanImpl(shuffled.getMaxImpl());        shuffled.setMaxImpl(shuffled.getMinImpl());        shuffled.setMinImpl(shuffled.getSumImpl());        shuffled.setSumImpl(shuffled.getSumsqImpl());        shuffled.setSumsqImpl(shuffled.getSumLogImpl());        shuffled.setSumLogImpl(tmp);        for (int i = 100; i > 0; --i) {            reference.addValue(new double[] {i, i});            shuffled.addValue(new double[] {i, i});        }        TestUtils.assertEquals(reference.getMean(),          shuffled.getGeometricMean(), 1.0e-10);        TestUtils.assertEquals(reference.getMax(),           shuffled.getMean(),          1.0e-10);        TestUtils.assertEquals(reference.getMin(),           shuffled.getMax(),           1.0e-10);        TestUtils.assertEquals(reference.getSum(),           shuffled.getMin(),           1.0e-10);        TestUtils.assertEquals(reference.getSumSq(),         shuffled.getSum(),           1.0e-10);        TestUtils.assertEquals(reference.getSumLog(),        shuffled.getSumSq(),         1.0e-10);        TestUtils.assertEquals(reference.getGeometricMean(), shuffled.getSumLog(),        1.0e-10);    }    /**     * Bogus mean implementation to test setter injection.     * Returns the sum instead of the mean.     */    static class sumMean implements StorelessUnivariateStatistic {        private double sum = 0;        private long n = 0;        public double evaluate(double[] values, int begin, int length) {            return 0;        }        public double evaluate(double[] values) {            return 0;        }        public void clear() {          sum = 0;          n = 0;        }        public long getN() {            return n;        }        public double getResult() {            return sum;        }        public void increment(double d) {            sum += d;            n++;        }        public void incrementAll(double[] values, int start, int length) {        }        public void incrementAll(double[] values) {        }        public StorelessUnivariateStatistic copy() {            return new sumMean();        }    }    public void testDimension() {        try {            createMultivariateSummaryStatistics(2, true).addValue(new double[3]);        } catch (DimensionMismatchException dme) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test stats */    public void testStats() throws DimensionMismatchException {        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);        assertEquals(0, u.getN());        u.addValue(new double[] { 1, 2 });        u.addValue(new double[] { 2, 3 });        u.addValue(new double[] { 2, 3 });        u.addValue(new double[] { 3, 4 });        assertEquals( 4, u.getN());        assertEquals( 8, u.getSum()[0], 1.0e-10);        assertEquals(12, u.getSum()[1], 1.0e-10);        assertEquals(18, u.getSumSq()[0], 1.0e-10);        assertEquals(38, u.getSumSq()[1], 1.0e-10);        assertEquals( 1, u.getMin()[0], 1.0e-10);        assertEquals( 2, u.getMin()[1], 1.0e-10);        assertEquals( 3, u.getMax()[0], 1.0e-10);        assertEquals( 4, u.getMax()[1], 1.0e-10);        assertEquals(2.4849066497880003102, u.getSumLog()[0], 1.0e-10);        assertEquals( 4.276666119016055311, u.getSumLog()[1], 1.0e-10);        assertEquals( 1.8612097182041991979, u.getGeometricMean()[0], 1.0e-10);        assertEquals( 2.9129506302439405217, u.getGeometricMean()[1], 1.0e-10);        assertEquals( 2, u.getMean()[0], 1.0e-10);        assertEquals( 3, u.getMean()[1], 1.0e-10);        assertEquals(FastMath.sqrt(2.0 / 3.0), u.getStandardDeviation()[0], 1.0e-10);        assertEquals(FastMath.sqrt(2.0 / 3.0), u.getStandardDeviation()[1], 1.0e-10);        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 0), 1.0e-10);        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 1), 1.0e-10);        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 0), 1.0e-10);        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 1), 1.0e-10);        u.clear();        assertEquals(0, u.getN());    }    public void testN0andN1Conditions() throws Exception {        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(1, true);        assertTrue(Double.isNaN(u.getMean()[0]));        assertTrue(Double.isNaN(u.getStandardDeviation()[0]));        /* n=1 */        u.addValue(new double[] { 1 });        assertEquals(1.0, u.getMean()[0], 1.0e-10);        assertEquals(1.0, u.getGeometricMean()[0], 1.0e-10);        assertEquals(0.0, u.getStandardDeviation()[0], 1.0e-10);        /* n=2 */        u.addValue(new double[] { 2 });        assertTrue(u.getStandardDeviation()[0] > 0);    }    public void testNaNContracts() throws DimensionMismatchException {        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(1, true);        assertTrue(Double.isNaN(u.getMean()[0]));        assertTrue(Double.isNaN(u.getMin()[0]));        assertTrue(Double.isNaN(u.getStandardDeviation()[0]));        assertTrue(Double.isNaN(u.getGeometricMean()[0]));        u.addValue(new double[] { 1.0 });        assertFalse(Double.isNaN(u.getMean()[0]));        assertFalse(Double.isNaN(u.getMin()[0]));        assertFalse(Double.isNaN(u.getStandardDeviation()[0]));        assertFalse(Double.isNaN(u.getGeometricMean()[0]));    }    public void testSerialization() throws DimensionMismatchException {        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);        // Empty test        TestUtils.checkSerializedEquality(u);        MultivariateSummaryStatistics s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u);        assertEquals(u, s);        // Add some data        u.addValue(new double[] { 2d, 1d });        u.addValue(new double[] { 1d, 1d });        u.addValue(new double[] { 3d, 1d });        u.addValue(new double[] { 4d, 1d });        u.addValue(new double[] { 5d, 1d });        // Test again        TestUtils.checkSerializedEquality(u);        s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u);        assertEquals(u, s);    }    public void testEqualsAndHashCode() throws DimensionMismatchException {        MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);        MultivariateSummaryStatistics t = null;        int emptyHash = u.hashCode();        assertTrue(u.equals(u));        assertFalse(u.equals(t));        assertFalse(u.equals(Double.valueOf(0)));        t = createMultivariateSummaryStatistics(2, true);        assertTrue(t.equals(u));        assertTrue(u.equals(t));        assertEquals(emptyHash, t.hashCode());        // Add some data to u        u.addValue(new double[] { 2d, 1d });        u.addValue(new double[] { 1d, 1d });        u.addValue(new double[] { 3d, 1d });        u.addValue(new double[] { 4d, 1d });        u.addValue(new double[] { 5d, 1d });        assertFalse(t.equals(u));        assertFalse(u.equals(t));        assertTrue(u.hashCode() != t.hashCode());        //Add data in same order to t        t.addValue(new double[] { 2d, 1d });        t.addValue(new double[] { 1d, 1d });        t.addValue(new double[] { 3d, 1d });        t.addValue(new double[] { 4d, 1d });        t.addValue(new double[] { 5d, 1d });        assertTrue(t.equals(u));        assertTrue(u.equals(t));        assertEquals(u.hashCode(), t.hashCode());        // Clear and make sure summaries are indistinguishable from empty summary        u.clear();        t.clear();        assertTrue(t.equals(u));        assertTrue(u.equals(t));        assertEquals(emptyHash, t.hashCode());        assertEquals(emptyHash, u.hashCode());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.stat.descriptive;/** * Test cases for the {@link SynchronizedMultivariateSummaryStatisticsTest} class. * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug *          2007) $ */public final class SynchronizedMultivariateSummaryStatisticsTest extends MultivariateSummaryStatisticsTest {    public SynchronizedMultivariateSummaryStatisticsTest(String name) {        super(name);    }    @Override    protected MultivariateSummaryStatistics createMultivariateSummaryStatistics(int k, boolean isCovarianceBiasCorrected) {        return new SynchronizedMultivariateSummaryStatistics(k, isCovarianceBiasCorrected);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import org.apache.commons.math.stat.descriptive.moment.FourthMoment;import org.apache.commons.math.stat.descriptive.moment.Kurtosis;import org.apache.commons.math.stat.descriptive.moment.Mean;import org.apache.commons.math.stat.descriptive.moment.Skewness;import org.apache.commons.math.stat.descriptive.moment.Variance;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class InteractionTest extends TestCase {    protected double mean = 12.40454545454550;    protected double var = 10.00235930735930;    protected double skew = 1.437423729196190;    protected double kurt = 2.377191264804700;    protected double tolerance = 10E-12;    protected double[] testArray =        {            12.5,            12,            11.8,            14.2,            14.9,            14.5,            21,            8.2,            10.3,            11.3,            14.1,            9.9,            12.2,            12,            12.1,            11,            19.8,            11,            10,            8.8,            9,            12.3 };    public InteractionTest(String name) {        super(name);    }    public void testInteraction() {        FourthMoment m4 = new FourthMoment();        Mean m = new Mean(m4);        Variance v = new Variance(m4);        Skewness s= new Skewness(m4);        Kurtosis k = new Kurtosis(m4);        for (int i = 0; i < testArray.length; i++){            m4.increment(testArray[i]);        }        assertEquals(mean,m.getResult(),tolerance);        assertEquals(var,v.getResult(),tolerance);        assertEquals(skew ,s.getResult(),tolerance);        assertEquals(kurt,k.getResult(),tolerance);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.descriptive;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.moment.SecondMoment;import org.apache.commons.math.util.FastMath;/** * Test cases for {@link StorelessUnivariateStatistic} classes. * @version $Revision$ $Date$ */public abstract class StorelessUnivariateStatisticAbstractTest    extends UnivariateStatisticAbstractTest {    public StorelessUnivariateStatisticAbstractTest(String name) {        super(name);    }    /** Small sample arrays */    protected double[][] smallSamples = {{}, {1}, {1,2}, {1,2,3}, {1,2,3,4}};    /** Return a new instance of the statistic */    @Override    public abstract UnivariateStatistic getUnivariateStatistic();    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */    @Override    public abstract double expectedValue();    /**     *  Verifies that increment() and incrementAll work properly.     */    public void testIncrementation() throws Exception {        StorelessUnivariateStatistic statistic =            (StorelessUnivariateStatistic) getUnivariateStatistic();        // Add testArray one value at a time and check result        for (int i = 0; i < testArray.length; i++) {            statistic.increment(testArray[i]);        }        assertEquals(expectedValue(), statistic.getResult(), getTolerance());        assertEquals(testArray.length, statistic.getN());        statistic.clear();        // Add testArray all at once and check again        statistic.incrementAll(testArray);        assertEquals(expectedValue(), statistic.getResult(), getTolerance());        assertEquals(testArray.length, statistic.getN());        statistic.clear();        // Cleared        checkClearValue(statistic);        assertEquals(0, statistic.getN());    }    protected void checkClearValue(StorelessUnivariateStatistic statistic){        assertTrue(Double.isNaN(statistic.getResult()));    }        public void testSerialization() throws Exception {        StorelessUnivariateStatistic statistic =            (StorelessUnivariateStatistic) getUnivariateStatistic();        TestUtils.checkSerializedEquality(statistic);        statistic.clear();        for (int i = 0; i < testArray.length; i++) {            statistic.increment(testArray[i]);            if(i % 5 == 0)                statistic = (StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);        }        TestUtils.checkSerializedEquality(statistic);        assertEquals(expectedValue(), statistic.getResult(), getTolerance());        statistic.clear();        checkClearValue(statistic);    }    public void testEqualsAndHashCode() {        StorelessUnivariateStatistic statistic =            (StorelessUnivariateStatistic) getUnivariateStatistic();        StorelessUnivariateStatistic statistic2 = null;        assertTrue("non-null, compared to null", !statistic.equals(statistic2));        assertTrue("reflexive, non-null", statistic.equals(statistic));        int emptyHash = statistic.hashCode();        statistic2 = (StorelessUnivariateStatistic) getUnivariateStatistic();        assertTrue("empty stats should be equal", statistic.equals(statistic2));        assertEquals("empty stats should have the same hashcode",                emptyHash, statistic2.hashCode());        statistic.increment(1d);        assertTrue("reflexive, non-empty", statistic.equals(statistic));        assertTrue("non-empty, compared to empty", !statistic.equals(statistic2));        assertTrue("non-empty, compared to empty", !statistic2.equals(statistic));        assertTrue("non-empty stat should have different hashcode from empty stat",                statistic.hashCode() != emptyHash);        statistic2.increment(1d);        assertTrue("stats with same data should be equal", statistic.equals(statistic2));        assertEquals("stats with same data should have the same hashcode",                statistic.hashCode(), statistic2.hashCode());        statistic.increment(Double.POSITIVE_INFINITY);        assertTrue("stats with different n's should not be equal", !statistic2.equals(statistic));        assertTrue("stats with different n's should have different hashcodes",                statistic.hashCode() != statistic2.hashCode());        statistic2.increment(Double.POSITIVE_INFINITY);        assertTrue("stats with same data should be equal", statistic.equals(statistic2));        assertEquals("stats with same data should have the same hashcode",                statistic.hashCode(), statistic2.hashCode());        statistic.clear();        statistic2.clear();        assertTrue("cleared stats should be equal", statistic.equals(statistic2));        assertEquals("cleared stats should have thashcode of empty stat",                emptyHash, statistic2.hashCode());        assertEquals("cleared stats should have thashcode of empty stat",                emptyHash, statistic.hashCode());    }    public void testMomentSmallSamples() {        UnivariateStatistic stat = getUnivariateStatistic();        if (stat instanceof SecondMoment) {            SecondMoment moment = (SecondMoment) getUnivariateStatistic();            assertTrue(Double.isNaN(moment.getResult()));            moment.increment(1d);            assertEquals(0d, moment.getResult(), 0);        }    }    /**     * Make sure that evaluate(double[]) and inrementAll(double[]),     * getResult() give same results.     */    public void testConsistency() {        StorelessUnivariateStatistic stat = (StorelessUnivariateStatistic) getUnivariateStatistic();        stat.incrementAll(testArray);        assertEquals(stat.getResult(), stat.evaluate(testArray), getTolerance());        for (int i = 0; i < smallSamples.length; i++) {            stat.clear();            for (int j =0; j < smallSamples[i].length; j++) {                stat.increment(smallSamples[i][j]);            }            TestUtils.assertEquals(stat.getResult(), stat.evaluate(smallSamples[i]), getTolerance());        }    }    /**     * Verifies that copied statistics remain equal to originals when     * incremented the same way.     *     */    public void testCopyConsistency() {        StorelessUnivariateStatistic master =            (StorelessUnivariateStatistic) getUnivariateStatistic();        StorelessUnivariateStatistic replica = null;        // Randomly select a portion of testArray to load first        long index = FastMath.round((FastMath.random()) * testArray.length);        // Put first half in master and copy master to replica        master.incrementAll(testArray, 0, (int) index);        replica = master.copy();        // Check same        assertTrue(replica.equals(master));        assertTrue(master.equals(replica));        // Now add second part to both and check again        master.incrementAll(testArray,                (int) index, (int) (testArray.length - index));        replica.incrementAll(testArray,                (int) index, (int) (testArray.length - index));        assertTrue(replica.equals(master));        assertTrue(master.equals(replica));    }    public void testSerial() {        StorelessUnivariateStatistic s =            (StorelessUnivariateStatistic) getUnivariateStatistic();        assertEquals(s, TestUtils.serializeAndRecover(s));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import junit.framework.TestCase;import org.apache.commons.math.stat.descriptive.SummaryStatistics;/** * Test cases for the TTestImpl class. * * @version $Revision$ $Date$ */public class TTestTest extends TestCase {    protected TTest testStatistic = new TTestImpl();    private double[] tooShortObs = { 1.0 };    private double[] emptyObs = {};    private SummaryStatistics emptyStats = new SummaryStatistics();   SummaryStatistics tooShortStats = null;    public TTestTest(String name) {        super(name);    }    @Override    public void setUp() {        tooShortStats = new SummaryStatistics();        tooShortStats.addValue(0d);    }    public void testOneSampleT() throws Exception {        double[] observed =            {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0,  88.0, 98.0, 94.0, 101.0, 92.0, 95.0 };        double mu = 100.0;        SummaryStatistics sampleStats = null;        sampleStats = new SummaryStatistics();        for (int i = 0; i < observed.length; i++) {            sampleStats.addValue(observed[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("t statistic",  -2.81976445346,                testStatistic.t(mu, observed), 10E-10);        assertEquals("t statistic",  -2.81976445346,                testStatistic.t(mu, sampleStats), 10E-10);        assertEquals("p value", 0.0136390585873,                testStatistic.tTest(mu, observed), 10E-10);        assertEquals("p value", 0.0136390585873,                testStatistic.tTest(mu, sampleStats), 10E-10);        try {            testStatistic.t(mu, (double[]) null);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(mu, (SummaryStatistics) null);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(mu, emptyObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(mu, emptyStats);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(mu, tooShortObs);            fail("insufficient data to compute t statistic, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.tTest(mu, tooShortObs);            fail("insufficient data to perform t test, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {           // expected        }        try {            testStatistic.t(mu, tooShortStats);            fail("insufficient data to compute t statistic, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.tTest(mu, tooShortStats);            fail("insufficient data to perform t test, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testOneSampleTTest() throws Exception {        double[] oneSidedP =            {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d };        SummaryStatistics oneSidedPStats = new SummaryStatistics();        for (int i = 0; i < oneSidedP.length; i++) {            oneSidedPStats.addValue(oneSidedP[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("one sample t stat", 3.86485535541,                testStatistic.t(0d, oneSidedP), 10E-10);        assertEquals("one sample t stat", 3.86485535541,                testStatistic.t(0d, oneSidedPStats),1E-10);        assertEquals("one sample p value", 0.000521637019637,                testStatistic.tTest(0d, oneSidedP) / 2d, 10E-10);        assertEquals("one sample p value", 0.000521637019637,                testStatistic.tTest(0d, oneSidedPStats) / 2d, 10E-5);        assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedP, 0.01));        assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedPStats, 0.01));        assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedP, 0.0001));        assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedPStats, 0.0001));        try {            testStatistic.tTest(0d, oneSidedP, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.tTest(0d, oneSidedPStats, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testTwoSampleTHeterscedastic() throws Exception {        double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };        double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };        SummaryStatistics sampleStats1 = new SummaryStatistics();        for (int i = 0; i < sample1.length; i++) {            sampleStats1.addValue(sample1[i]);        }        SummaryStatistics sampleStats2 = new SummaryStatistics();        for (int i = 0; i < sample2.length; i++) {            sampleStats2.addValue(sample2[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("two sample heteroscedastic t stat", 1.60371728768,                testStatistic.t(sample1, sample2), 1E-10);        assertEquals("two sample heteroscedastic t stat", 1.60371728768,                testStatistic.t(sampleStats1, sampleStats2), 1E-10);        assertEquals("two sample heteroscedastic p value", 0.128839369622,                testStatistic.tTest(sample1, sample2), 1E-10);        assertEquals("two sample heteroscedastic p value", 0.128839369622,                testStatistic.tTest(sampleStats1, sampleStats2), 1E-10);        assertTrue("two sample heteroscedastic t-test reject",                testStatistic.tTest(sample1, sample2, 0.2));        assertTrue("two sample heteroscedastic t-test reject",                testStatistic.tTest(sampleStats1, sampleStats2, 0.2));        assertTrue("two sample heteroscedastic t-test accept",                !testStatistic.tTest(sample1, sample2, 0.1));        assertTrue("two sample heteroscedastic t-test accept",                !testStatistic.tTest(sampleStats1, sampleStats2, 0.1));        try {            testStatistic.tTest(sample1, sample2, .95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.tTest(sampleStats1, sampleStats2, .95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.tTest(sample1, tooShortObs, .01);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.tTest(sampleStats1, tooShortStats, .01);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.tTest(sample1, tooShortObs);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {           // expected        }        try {            testStatistic.tTest(sampleStats1, tooShortStats);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(sample1, tooShortObs);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.t(sampleStats1, tooShortStats);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {           // expected        }    }    public void testTwoSampleTHomoscedastic() throws Exception {        double[] sample1 ={2, 4, 6, 8, 10, 97};        double[] sample2 = {4, 6, 8, 10, 16};        SummaryStatistics sampleStats1 = new SummaryStatistics();        for (int i = 0; i < sample1.length; i++) {            sampleStats1.addValue(sample1[i]);        }        SummaryStatistics sampleStats2 = new SummaryStatistics();        for (int i = 0; i < sample2.length; i++) {            sampleStats2.addValue(sample2[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("two sample homoscedastic t stat", 0.73096310086,              testStatistic.homoscedasticT(sample1, sample2), 10E-11);        assertEquals("two sample homoscedastic p value", 0.4833963785,                testStatistic.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);        assertTrue("two sample homoscedastic t-test reject",                testStatistic.homoscedasticTTest(sample1, sample2, 0.49));        assertTrue("two sample homoscedastic t-test accept",                !testStatistic.homoscedasticTTest(sample1, sample2, 0.48));    }    public void testSmallSamples() throws Exception {        double[] sample1 = {1d, 3d};        double[] sample2 = {4d, 5d};        // Target values computed using R, version 1.8.1 (linux version)        assertEquals(-2.2360679775, testStatistic.t(sample1, sample2),                1E-10);        assertEquals(0.198727388935, testStatistic.tTest(sample1, sample2),                1E-10);    }    public void testPaired() throws Exception {        double[] sample1 = {1d, 3d, 5d, 7d};        double[] sample2 = {0d, 6d, 11d, 2d};        double[] sample3 = {5d, 7d, 8d, 10d};        // Target values computed using R, version 1.8.1 (linux version)        assertEquals(-0.3133, testStatistic.pairedT(sample1, sample2), 1E-4);        assertEquals(0.774544295819, testStatistic.pairedTTest(sample1, sample2), 1E-10);        assertEquals(0.001208, testStatistic.pairedTTest(sample1, sample3), 1E-6);        assertFalse(testStatistic.pairedTTest(sample1, sample3, .001));        assertTrue(testStatistic.pairedTTest(sample1, sample3, .002));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import java.util.ArrayList;import java.util.List;import junit.framework.TestCase;/** * Test cases for the OneWayAnovaImpl class. * * @version $Revision$ $Date$ */public class OneWayAnovaTest extends TestCase {    protected OneWayAnova testStatistic = new OneWayAnovaImpl();    private double[] emptyArray = {};    private double[] classA =            {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 };    private double[] classB =            {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 };    private double[] classC =            {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 };    public OneWayAnovaTest(String name) {        super(name);    }    public void testAnovaFValue() throws Exception {        // Target comparison values computed using R version 2.6.0 (Linux version)        List<double[]> threeClasses = new ArrayList<double[]>();        threeClasses.add(classA);        threeClasses.add(classB);        threeClasses.add(classC);        assertEquals("ANOVA F-value",  24.67361709460624,                 testStatistic.anovaFValue(threeClasses), 1E-12);        List<double[]> twoClasses = new ArrayList<double[]>();        twoClasses.add(classA);        twoClasses.add(classB);        assertEquals("ANOVA F-value",  0.0150579150579,                 testStatistic.anovaFValue(twoClasses), 1E-12);        List<double[]> emptyContents = new ArrayList<double[]>();        emptyContents.add(emptyArray);        emptyContents.add(classC);        try {            testStatistic.anovaFValue(emptyContents);            fail("empty array for key classX, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        List<double[]> tooFew = new ArrayList<double[]>();        tooFew.add(classA);        try {            testStatistic.anovaFValue(tooFew);            fail("less than two classes, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testAnovaPValue() throws Exception {        // Target comparison values computed using R version 2.6.0 (Linux version)        List<double[]> threeClasses = new ArrayList<double[]>();        threeClasses.add(classA);        threeClasses.add(classB);        threeClasses.add(classC);        assertEquals("ANOVA P-value", 6.959446E-06,                 testStatistic.anovaPValue(threeClasses), 1E-12);        List<double[]> twoClasses = new ArrayList<double[]>();        twoClasses.add(classA);        twoClasses.add(classB);        assertEquals("ANOVA P-value",  0.904212960464,                 testStatistic.anovaPValue(twoClasses), 1E-12);    }    public void testAnovaTest() throws Exception {        // Target comparison values computed using R version 2.3.1 (Linux version)        List<double[]> threeClasses = new ArrayList<double[]>();        threeClasses.add(classA);        threeClasses.add(classB);        threeClasses.add(classC);        assertTrue("ANOVA Test P<0.01", testStatistic.anovaTest(threeClasses, 0.01));        List<double[]> twoClasses = new ArrayList<double[]>();        twoClasses.add(classA);        twoClasses.add(classB);        assertFalse("ANOVA Test P>0.01", testStatistic.anovaTest(twoClasses, 0.01));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;/** * Test cases for the ChiSquareTestFactory. * * @version $Revision$ $Date$ */public class ChiSquareFactoryTest extends ChiSquareTestTest {    public ChiSquareFactoryTest(String name) {        super(name);    }    @Override    public void setUp() throws Exception {        super.setUp();        testStatistic = TestUtils.getUnknownDistributionChiSquareTest();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;/** * Test cases for the TTestTestFactory. * * @version $Revision$ $Date$ */public class TTestFactoryTest extends TTestTest {    public TTestFactoryTest(String name) {        super(name);    }    @Override    public void setUp() {        super.setUp();        testStatistic = TestUtils.getTTest();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import junit.framework.TestCase;/** * Test cases for the ChiSquareTestImpl class. * * @version $Revision$ $Date$ */public class ChiSquareTestTest extends TestCase {    protected UnknownDistributionChiSquareTest testStatistic = new ChiSquareTestImpl();    public ChiSquareTestTest(String name) {        super(name);    }    public void testChiSquare() throws Exception {        // Target values computed using R version 1.8.1        // Some assembly required ;-)        //      Use sum((obs - exp)^2/exp) for the chi-square statistic and        //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value        long[] observed = {10, 9, 11};        double[] expected = {10, 10, 10};        assertEquals("chi-square statistic", 0.2,  testStatistic.chiSquare(expected, observed), 10E-12);        assertEquals("chi-square p-value", 0.904837418036, testStatistic.chiSquareTest(expected, observed), 1E-10);        long[] observed1 = { 500, 623, 72, 70, 31 };        double[] expected1 = { 485, 541, 82, 61, 37 };        assertEquals( "chi-square test statistic", 9.023307936427388, testStatistic.chiSquare(expected1, observed1), 1E-10);        assertEquals("chi-square p-value", 0.06051952647453607, testStatistic.chiSquareTest(expected1, observed1), 1E-9);        assertTrue("chi-square test reject", testStatistic.chiSquareTest(expected1, observed1, 0.08));        assertTrue("chi-square test accept", !testStatistic.chiSquareTest(expected1, observed1, 0.05));        try {            testStatistic.chiSquareTest(expected1, observed1, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        long[] tooShortObs = { 0 };        double[] tooShortEx = { 1 };        try {            testStatistic.chiSquare(tooShortEx, tooShortObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        // unmatched arrays        long[] unMatchedObs = { 0, 1, 2, 3 };        double[] unMatchedEx = { 1, 1, 2 };        try {            testStatistic.chiSquare(unMatchedEx, unMatchedObs);            fail("arrays have different lengths, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        // 0 expected count        expected[0] = 0;        try {            testStatistic.chiSquareTest(expected, observed, .01);            fail("bad expected count, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        // negative observed count        expected[0] = 1;        observed[0] = -1;        try {            testStatistic.chiSquareTest(expected, observed, .01);            fail("bad expected count, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testChiSquareIndependence() throws Exception {        // Target values computed using R version 1.8.1        long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};        assertEquals( "chi-square test statistic", 22.709027688, testStatistic.chiSquare(counts), 1E-9);        assertEquals("chi-square p-value", 0.000144751460134, testStatistic.chiSquareTest(counts), 1E-9);        assertTrue("chi-square test reject", testStatistic.chiSquareTest(counts, 0.0002));        assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts, 0.0001));        long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };        assertEquals( "chi-square test statistic", 0.168965517241, testStatistic.chiSquare(counts2), 1E-9);        assertEquals("chi-square p-value",0.918987499852, testStatistic.chiSquareTest(counts2), 1E-9);        assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts2, 0.1));        // ragged input array        long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};        try {            testStatistic.chiSquare(counts3);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        // insufficient data        long[][] counts4 = {{40, 22, 43}};        try {            testStatistic.chiSquare(counts4);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        long[][] counts5 = {{40}, {40}, {30}, {10}};        try {            testStatistic.chiSquare(counts5);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        // negative counts        long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };        try {            testStatistic.chiSquare(counts6);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        // bad alpha        try {            testStatistic.chiSquareTest(counts, 0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testChiSquareLargeTestStatistic() throws Exception {        double[] exp = new double[] {            3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0,            232921.0, 437665.75        };        long[] obs = new long[] {            2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899        };        org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =            new org.apache.commons.math.stat.inference.ChiSquareTestImpl();        double cst = csti.chiSquareTest(exp, obs);        assertEquals("chi-square p-value", 0.0, cst, 1E-3);        assertEquals( "chi-square test statistic",                114875.90421929007, testStatistic.chiSquare(exp, obs), 1E-9);    }    /** Contingency table containing zeros - PR # 32531 */    public void testChiSquareZeroCount() throws Exception {        // Target values computed using R version 1.8.1        long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};        assertEquals( "chi-square test statistic", 9.67444662263,                testStatistic.chiSquare(counts), 1E-9);        assertEquals("chi-square p-value", 0.0462835770603,                testStatistic.chiSquareTest(counts), 1E-9);    }    /** Target values verified using DATAPLOT version 2006.3 */    public void testChiSquareDataSetsComparisonEqualCounts()    throws Exception {        long[] observed1 = {10, 12, 12, 10};        long[] observed2 = {5, 15, 14, 10};        assertEquals("chi-square p value", 0.541096,                testStatistic.chiSquareTestDataSetsComparison(                observed1, observed2), 1E-6);        assertEquals("chi-square test statistic", 2.153846,                testStatistic.chiSquareDataSetsComparison(                observed1, observed2), 1E-6);        assertFalse("chi-square test result",                testStatistic.chiSquareTestDataSetsComparison(                observed1, observed2, 0.4));    }    /** Target values verified using DATAPLOT version 2006.3 */    public void testChiSquareDataSetsComparisonUnEqualCounts()    throws Exception {        long[] observed1 = {10, 12, 12, 10, 15};        long[] observed2 = {15, 10, 10, 15, 5};        assertEquals("chi-square p value", 0.124115,                testStatistic.chiSquareTestDataSetsComparison(                observed1, observed2), 1E-6);        assertEquals("chi-square test statistic", 7.232189,                testStatistic.chiSquareDataSetsComparison(                observed1, observed2), 1E-6);        assertTrue("chi-square test result",                testStatistic.chiSquareTestDataSetsComparison(                observed1, observed2, 0.13));        assertFalse("chi-square test result",                testStatistic.chiSquareTestDataSetsComparison(                observed1, observed2, 0.12));    }    public void testChiSquareDataSetsComparisonBadCounts()    throws Exception {        long[] observed1 = {10, -1, 12, 10, 15};        long[] observed2 = {15, 10, 10, 15, 5};        try {            testStatistic.chiSquareTestDataSetsComparison(                    observed1, observed2);            fail("Expecting IllegalArgumentException - negative count");        } catch (IllegalArgumentException ex) {            // expected        }        long[] observed3 = {10, 0, 12, 10, 15};        long[] observed4 = {15, 0, 10, 15, 5};        try {            testStatistic.chiSquareTestDataSetsComparison(                    observed3, observed4);            fail("Expecting IllegalArgumentException - double 0's");        } catch (IllegalArgumentException ex) {            // expected        }        long[] observed5 = {10, 10, 12, 10, 15};        long[] observed6 = {0, 0, 0, 0, 0};        try {            testStatistic.chiSquareTestDataSetsComparison(                    observed5, observed6);            fail("Expecting IllegalArgumentException - vanishing counts");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import java.util.ArrayList;import java.util.List;import junit.framework.TestCase;import org.apache.commons.math.stat.descriptive.SummaryStatistics;/** * Test cases for the TestUtils class. * * @version $Revision$ $Date$ */public class TestUtilsTest extends TestCase {    public TestUtilsTest(String name) {        super(name);    }    public void testChiSquare() throws Exception {        // Target values computed using R version 1.8.1        // Some assembly required ;-)        //      Use sum((obs - exp)^2/exp) for the chi-square statistic and        //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value        long[] observed = {10, 9, 11};        double[] expected = {10, 10, 10};        assertEquals("chi-square statistic", 0.2,  TestUtils.chiSquare(expected, observed), 10E-12);        assertEquals("chi-square p-value", 0.904837418036, TestUtils.chiSquareTest(expected, observed), 1E-10);        long[] observed1 = { 500, 623, 72, 70, 31 };        double[] expected1 = { 485, 541, 82, 61, 37 };        assertEquals( "chi-square test statistic", 9.023307936427388, TestUtils.chiSquare(expected1, observed1), 1E-10);        assertEquals("chi-square p-value", 0.06051952647453607, TestUtils.chiSquareTest(expected1, observed1), 1E-9);        assertTrue("chi-square test reject", TestUtils.chiSquareTest(expected1, observed1, 0.07));        assertTrue("chi-square test accept", !TestUtils.chiSquareTest(expected1, observed1, 0.05));        try {            TestUtils.chiSquareTest(expected1, observed1, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        long[] tooShortObs = { 0 };        double[] tooShortEx = { 1 };        try {            TestUtils.chiSquare(tooShortEx, tooShortObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        // unmatched arrays        long[] unMatchedObs = { 0, 1, 2, 3 };        double[] unMatchedEx = { 1, 1, 2 };        try {            TestUtils.chiSquare(unMatchedEx, unMatchedObs);            fail("arrays have different lengths, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        // 0 expected count        expected[0] = 0;        try {            TestUtils.chiSquareTest(expected, observed, .01);            fail("bad expected count, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        // negative observed count        expected[0] = 1;        observed[0] = -1;        try {            TestUtils.chiSquareTest(expected, observed, .01);            fail("bad expected count, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testChiSquareIndependence() throws Exception {        // Target values computed using R version 1.8.1        long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};        assertEquals( "chi-square test statistic", 22.709027688, TestUtils.chiSquare(counts), 1E-9);        assertEquals("chi-square p-value", 0.000144751460134, TestUtils.chiSquareTest(counts), 1E-9);        assertTrue("chi-square test reject", TestUtils.chiSquareTest(counts, 0.0002));        assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts, 0.0001));        long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };        assertEquals( "chi-square test statistic", 0.168965517241, TestUtils.chiSquare(counts2), 1E-9);        assertEquals("chi-square p-value",0.918987499852, TestUtils.chiSquareTest(counts2), 1E-9);        assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts2, 0.1));        // ragged input array        long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};        try {            TestUtils.chiSquare(counts3);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        // insufficient data        long[][] counts4 = {{40, 22, 43}};        try {            TestUtils.chiSquare(counts4);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        long[][] counts5 = {{40}, {40}, {30}, {10}};        try {            TestUtils.chiSquare(counts5);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        // negative counts        long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };        try {            TestUtils.chiSquare(counts6);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        // bad alpha        try {            TestUtils.chiSquareTest(counts, 0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testChiSquareLargeTestStatistic() throws Exception {        double[] exp = new double[] {                3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0,                232921.0, 437665.75        };        long[] obs = new long[] {                2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899        };        org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =            new org.apache.commons.math.stat.inference.ChiSquareTestImpl();        double cst = csti.chiSquareTest(exp, obs);        assertEquals("chi-square p-value", 0.0, cst, 1E-3);        assertEquals( "chi-square test statistic",                114875.90421929007, TestUtils.chiSquare(exp, obs), 1E-9);    }    /** Contingency table containing zeros - PR # 32531 */    public void testChiSquareZeroCount() throws Exception {        // Target values computed using R version 1.8.1        long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};        assertEquals( "chi-square test statistic", 9.67444662263,                TestUtils.chiSquare(counts), 1E-9);        assertEquals("chi-square p-value", 0.0462835770603,                TestUtils.chiSquareTest(counts), 1E-9);    }    private double[] tooShortObs = { 1.0 };    private double[] emptyObs = {};    private SummaryStatistics emptyStats = new SummaryStatistics();    public void testOneSampleT() throws Exception {        double[] observed =            {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0,  88.0, 98.0, 94.0, 101.0, 92.0, 95.0 };        double mu = 100.0;        SummaryStatistics sampleStats = null;        sampleStats = new SummaryStatistics();        for (int i = 0; i < observed.length; i++) {            sampleStats.addValue(observed[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("t statistic",  -2.81976445346,                TestUtils.t(mu, observed), 10E-10);        assertEquals("t statistic",  -2.81976445346,                TestUtils.t(mu, sampleStats), 10E-10);        assertEquals("p value", 0.0136390585873,                TestUtils.tTest(mu, observed), 10E-10);        assertEquals("p value", 0.0136390585873,                TestUtils.tTest(mu, sampleStats), 10E-10);        try {            TestUtils.t(mu, (double[]) null);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(mu, (SummaryStatistics) null);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(mu, emptyObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(mu, emptyStats);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(mu, tooShortObs);            fail("insufficient data to compute t statistic, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(mu, tooShortObs);            fail("insufficient data to perform t test, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(mu, (SummaryStatistics) null);            fail("insufficient data to compute t statistic, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(mu, (SummaryStatistics) null);            fail("insufficient data to perform t test, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testOneSampleTTest() throws Exception {        double[] oneSidedP =            {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d };        SummaryStatistics oneSidedPStats = new SummaryStatistics();        for (int i = 0; i < oneSidedP.length; i++) {            oneSidedPStats.addValue(oneSidedP[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("one sample t stat", 3.86485535541,                TestUtils.t(0d, oneSidedP), 10E-10);        assertEquals("one sample t stat", 3.86485535541,                TestUtils.t(0d, oneSidedPStats),1E-10);        assertEquals("one sample p value", 0.000521637019637,                TestUtils.tTest(0d, oneSidedP) / 2d, 10E-10);        assertEquals("one sample p value", 0.000521637019637,                TestUtils.tTest(0d, oneSidedPStats) / 2d, 10E-5);        assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedP, 0.01));        assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedPStats, 0.01));        assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedP, 0.0001));        assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedPStats, 0.0001));        try {            TestUtils.tTest(0d, oneSidedP, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(0d, oneSidedPStats, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testTwoSampleTHeterscedastic() throws Exception {        double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };        double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };        SummaryStatistics sampleStats1 = new SummaryStatistics();        for (int i = 0; i < sample1.length; i++) {            sampleStats1.addValue(sample1[i]);        }        SummaryStatistics sampleStats2 = new SummaryStatistics();        for (int i = 0; i < sample2.length; i++) {            sampleStats2.addValue(sample2[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("two sample heteroscedastic t stat", 1.60371728768,                TestUtils.t(sample1, sample2), 1E-10);        assertEquals("two sample heteroscedastic t stat", 1.60371728768,                TestUtils.t(sampleStats1, sampleStats2), 1E-10);        assertEquals("two sample heteroscedastic p value", 0.128839369622,                TestUtils.tTest(sample1, sample2), 1E-10);        assertEquals("two sample heteroscedastic p value", 0.128839369622,                TestUtils.tTest(sampleStats1, sampleStats2), 1E-10);        assertTrue("two sample heteroscedastic t-test reject",                TestUtils.tTest(sample1, sample2, 0.2));        assertTrue("two sample heteroscedastic t-test reject",                TestUtils.tTest(sampleStats1, sampleStats2, 0.2));        assertTrue("two sample heteroscedastic t-test accept",                !TestUtils.tTest(sample1, sample2, 0.1));        assertTrue("two sample heteroscedastic t-test accept",                !TestUtils.tTest(sampleStats1, sampleStats2, 0.1));        try {            TestUtils.tTest(sample1, sample2, .95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(sampleStats1, sampleStats2, .95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(sample1, tooShortObs, .01);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(sampleStats1, (SummaryStatistics) null, .01);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(sample1, tooShortObs);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.tTest(sampleStats1, (SummaryStatistics) null);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(sample1, tooShortObs);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        try {            TestUtils.t(sampleStats1, (SummaryStatistics) null);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testTwoSampleTHomoscedastic() throws Exception {        double[] sample1 ={2, 4, 6, 8, 10, 97};        double[] sample2 = {4, 6, 8, 10, 16};        SummaryStatistics sampleStats1 = new SummaryStatistics();        for (int i = 0; i < sample1.length; i++) {            sampleStats1.addValue(sample1[i]);        }        SummaryStatistics sampleStats2 = new SummaryStatistics();        for (int i = 0; i < sample2.length; i++) {            sampleStats2.addValue(sample2[i]);        }        // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("two sample homoscedastic t stat", 0.73096310086,                TestUtils.homoscedasticT(sample1, sample2), 10E-11);        assertEquals("two sample homoscedastic p value", 0.4833963785,                TestUtils.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);        assertTrue("two sample homoscedastic t-test reject",                TestUtils.homoscedasticTTest(sample1, sample2, 0.49));        assertTrue("two sample homoscedastic t-test accept",                !TestUtils.homoscedasticTTest(sample1, sample2, 0.48));    }    public void testSmallSamples() throws Exception {        double[] sample1 = {1d, 3d};        double[] sample2 = {4d, 5d};        // Target values computed using R, version 1.8.1 (linux version)        assertEquals(-2.2360679775, TestUtils.t(sample1, sample2),                1E-10);        assertEquals(0.198727388935, TestUtils.tTest(sample1, sample2),                1E-10);    }    public void testPaired() throws Exception {        double[] sample1 = {1d, 3d, 5d, 7d};        double[] sample2 = {0d, 6d, 11d, 2d};        double[] sample3 = {5d, 7d, 8d, 10d};        // Target values computed using R, version 1.8.1 (linux version)        assertEquals(-0.3133, TestUtils.pairedT(sample1, sample2), 1E-4);        assertEquals(0.774544295819, TestUtils.pairedTTest(sample1, sample2), 1E-10);        assertEquals(0.001208, TestUtils.pairedTTest(sample1, sample3), 1E-6);        assertFalse(TestUtils.pairedTTest(sample1, sample3, .001));        assertTrue(TestUtils.pairedTTest(sample1, sample3, .002));    }    private double[] classA =      {93.0, 103.0, 95.0, 101.0};    private double[] classB =      {99.0, 92.0, 102.0, 100.0, 102.0};    private double[] classC =      {110.0, 115.0, 111.0, 117.0, 128.0};    private List<double[]> classes = new ArrayList<double[]>();    private OneWayAnova oneWayAnova = new OneWayAnovaImpl();    public void testOneWayAnovaUtils() throws Exception {        classes.add(classA);        classes.add(classB);        classes.add(classC);        assertEquals(oneWayAnova.anovaFValue(classes),                TestUtils.oneWayAnovaFValue(classes), 10E-12);        assertEquals(oneWayAnova.anovaPValue(classes),                TestUtils.oneWayAnovaPValue(classes), 10E-12);        assertEquals(oneWayAnova.anovaTest(classes, 0.01),                TestUtils.oneWayAnovaTest(classes, 0.01));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.clustering;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.Arrays;import java.util.List;import java.util.Random;import org.junit.Test;public class KMeansPlusPlusClustererTest {    @Test    public void dimension2() {        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer =            new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(new Random(1746432956321l));        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {                // first expected cluster                new EuclideanIntegerPoint(new int[] { -15,  3 }),                new EuclideanIntegerPoint(new int[] { -15,  4 }),                new EuclideanIntegerPoint(new int[] { -15,  5 }),                new EuclideanIntegerPoint(new int[] { -14,  3 }),                new EuclideanIntegerPoint(new int[] { -14,  5 }),                new EuclideanIntegerPoint(new int[] { -13,  3 }),                new EuclideanIntegerPoint(new int[] { -13,  4 }),                new EuclideanIntegerPoint(new int[] { -13,  5 }),                // second expected cluster                new EuclideanIntegerPoint(new int[] { -1,  0 }),                new EuclideanIntegerPoint(new int[] { -1, -1 }),                new EuclideanIntegerPoint(new int[] {  0, -1 }),                new EuclideanIntegerPoint(new int[] {  1, -1 }),                new EuclideanIntegerPoint(new int[] {  1, -2 }),                // third expected cluster                new EuclideanIntegerPoint(new int[] { 13,  3 }),                new EuclideanIntegerPoint(new int[] { 13,  4 }),                new EuclideanIntegerPoint(new int[] { 14,  4 }),                new EuclideanIntegerPoint(new int[] { 14,  7 }),                new EuclideanIntegerPoint(new int[] { 16,  5 }),                new EuclideanIntegerPoint(new int[] { 16,  6 }),                new EuclideanIntegerPoint(new int[] { 17,  4 }),                new EuclideanIntegerPoint(new int[] { 17,  7 })        };        List<Cluster<EuclideanIntegerPoint>> clusters =            transformer.cluster(Arrays.asList(points), 3, 10);        assertEquals(3, clusters.size());        boolean cluster1Found = false;        boolean cluster2Found = false;        boolean cluster3Found = false;        for (Cluster<EuclideanIntegerPoint> cluster : clusters) {            int[] center = cluster.getCenter().getPoint();            if (center[0] < 0) {                cluster1Found = true;                assertEquals(8, cluster.getPoints().size());                assertEquals(-14, center[0]);                assertEquals( 4, center[1]);            } else if (center[1] < 0) {                cluster2Found = true;                assertEquals(5, cluster.getPoints().size());                assertEquals( 0, center[0]);                assertEquals(-1, center[1]);            } else {                cluster3Found = true;                assertEquals(8, cluster.getPoints().size());                assertEquals(15, center[0]);                assertEquals(5, center[1]);            }        }        assertTrue(cluster1Found);        assertTrue(cluster2Found);        assertTrue(cluster3Found);    }    /**     * JIRA: MATH-305     *     * Two points, one cluster, one iteration     */    @Test    public void testPerformClusterAnalysisDegenerate() {        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(                new Random(1746432956321l));        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);        assertEquals(1, clusters.size());        assertEquals(2, (clusters.get(0).getPoints().size()));        EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });        EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });        assertTrue(clusters.get(0).getPoints().contains(pt1));        assertTrue(clusters.get(0).getPoints().contains(pt2));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.clustering;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.List;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Test;public class EuclideanIntegerPointTest {    @Test    public void testArrayIsReference() {        int[] array = { -3, -2, -1, 0, 1 };        assertTrue(array == new EuclideanIntegerPoint(array).getPoint());    }    @Test    public void testDistance() {        EuclideanIntegerPoint e1 = new EuclideanIntegerPoint(new int[] { -3, -2, -1, 0, 1 });        EuclideanIntegerPoint e2 = new EuclideanIntegerPoint(new int[] {  1,  0, -1, 1, 1 });        assertEquals(FastMath.sqrt(21.0), e1.distanceFrom(e2), 1.0e-15);        assertEquals(0.0, e1.distanceFrom(e1), 1.0e-15);        assertEquals(0.0, e2.distanceFrom(e2), 1.0e-15);    }    @Test    public void testCentroid() {        List<EuclideanIntegerPoint> list = new ArrayList<EuclideanIntegerPoint>();        list.add(new EuclideanIntegerPoint(new int[] {  1,  3 }));        list.add(new EuclideanIntegerPoint(new int[] {  2,  2 }));        list.add(new EuclideanIntegerPoint(new int[] {  3,  3 }));        list.add(new EuclideanIntegerPoint(new int[] {  2,  4 }));        EuclideanIntegerPoint c = list.get(0).centroidOf(list);        assertEquals(2, c.getPoint()[0]);        assertEquals(3, c.getPoint()[1]);    }    @Test    public void testSerial() {        EuclideanIntegerPoint p = new EuclideanIntegerPoint(new int[] { -3, -2, -1, 0, 1 });        assertEquals(p, TestUtils.serializeAndRecover(p));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.regression;import static org.junit.Assert.assertEquals;import org.apache.commons.math.TestUtils;import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.MatrixVisitorException;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.Array2DRowRealMatrix;import org.apache.commons.math.linear.RealVector;import org.apache.commons.math.stat.StatUtils;import org.junit.Before;import org.junit.Test;public class OLSMultipleLinearRegressionTest extends MultipleLinearRegressionAbstractTest {    private double[] y;    private double[][] x;    @Before    @Override    public void setUp(){        y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};        x = new double[6][];        x[0] = new double[]{0, 0, 0, 0, 0};        x[1] = new double[]{2.0, 0, 0, 0, 0};        x[2] = new double[]{0, 3.0, 0, 0, 0};        x[3] = new double[]{0, 0, 4.0, 0, 0};        x[4] = new double[]{0, 0, 0, 5.0, 0};        x[5] = new double[]{0, 0, 0, 0, 6.0};        super.setUp();    }    @Override    protected OLSMultipleLinearRegression createRegression() {        OLSMultipleLinearRegression regression = new OLSMultipleLinearRegression();        regression.newSampleData(y, x);        return regression;    }    @Override    protected int getNumberOfRegressors() {        return x[0].length + 1;    }    @Override    protected int getSampleSize() {        return y.length;    }        @Test(expected=IllegalArgumentException.class)    public void cannotAddSampleDataWithSizeMismatch() {        double[] y = new double[]{1.0, 2.0};        double[][] x = new double[1][];        x[0] = new double[]{1.0, 0};        createRegression().newSampleData(y, x);    }    @Test    public void testPerfectFit() throws Exception {        double[] betaHat = regression.estimateRegressionParameters();        TestUtils.assertEquals(betaHat,                               new double[]{ 11.0, 1.0 / 2.0, 2.0 / 3.0, 3.0 / 4.0, 4.0 / 5.0, 5.0 / 6.0 },                               1e-14);        double[] residuals = regression.estimateResiduals();        TestUtils.assertEquals(residuals, new double[]{0d,0d,0d,0d,0d,0d},                               1e-14);        RealMatrix errors =            new Array2DRowRealMatrix(regression.estimateRegressionParametersVariance(), false);        final double[] s = { 1.0, -1.0 /  2.0, -1.0 /  3.0, -1.0 /  4.0, -1.0 /  5.0, -1.0 /  6.0 };        RealMatrix referenceVariance = new Array2DRowRealMatrix(s.length, s.length);        referenceVariance.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {            @Override            public double visit(int row, int column, double value)                throws MatrixVisitorException {                if (row == 0) {                    return s[column];                }                double x = s[row] * s[column];                return (row == column) ? 2 * x : x;            }        });       assertEquals(0.0,                     errors.subtract(referenceVariance).getNorm(),                     5.0e-16 * referenceVariance.getNorm());       assertEquals(1, ((OLSMultipleLinearRegression) regression).calculateRSquared(), 1E-12);    }    /**     * Test Longley dataset against certified values provided by NIST.     * Data Source: J. Longley (1967) "An Appraisal of Least Squares     * Programs for the Electronic Computer from the Point of View of the User"     * Journal of the American Statistical Association, vol. 62. September,     * pp. 819-841.     *     * Certified values (and data) are from NIST:     * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat     */    @Test    public void testLongly() throws Exception {        // Y values are first, then independent vars        // Each row is one observation        double[] design = new double[] {            60323,83.0,234289,2356,1590,107608,1947,            61122,88.5,259426,2325,1456,108632,1948,            60171,88.2,258054,3682,1616,109773,1949,            61187,89.5,284599,3351,1650,110929,1950,            63221,96.2,328975,2099,3099,112075,1951,            63639,98.1,346999,1932,3594,113270,1952,            64989,99.0,365385,1870,3547,115094,1953,            63761,100.0,363112,3578,3350,116219,1954,            66019,101.2,397469,2904,3048,117388,1955,            67857,104.6,419180,2822,2857,118734,1956,            68169,108.4,442769,2936,2798,120445,1957,            66513,110.8,444546,4681,2637,121950,1958,            68655,112.6,482704,3813,2552,123366,1959,            69564,114.2,502601,3931,2514,125368,1960,            69331,115.7,518173,4806,2572,127852,1961,            70551,116.9,554894,4007,2827,130081,1962        };        final int nobs = 16;        final int nvars = 6;        // Estimate the model        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();        model.newSampleData(design, nobs, nvars);        // Check expected beta values from NIST        double[] betaHat = model.estimateRegressionParameters();        TestUtils.assertEquals(betaHat,          new double[]{-3482258.63459582, 15.0618722713733,                -0.358191792925910E-01,-2.02022980381683,                -1.03322686717359,-0.511041056535807E-01,                 1829.15146461355}, 2E-8); //        // Check expected residuals from R        double[] residuals = model.estimateResiduals();        TestUtils.assertEquals(residuals, new double[]{                267.340029759711,-94.0139423988359,46.28716775752924,                -410.114621930906,309.7145907602313,-249.3112153297231,                -164.0489563956039,-13.18035686637081,14.30477260005235,                 455.394094551857,-17.26892711483297,-39.0550425226967,                -155.5499735953195,-85.6713080421283,341.9315139607727,                -206.7578251937366},                      1E-8);        // Check standard errors from NIST        double[] errors = model.estimateRegressionParametersStandardErrors();        TestUtils.assertEquals(new double[] {890420.383607373,                       84.9149257747669,                       0.334910077722432E-01,                       0.488399681651699,                       0.214274163161675,                       0.226073200069370,                       455.478499142212}, errors, 1E-6);                // Check regression standard error against R        assertEquals(304.8540735619638, model.estimateRegressionStandardError(), 1E-10);                // Check R-Square statistics against R        assertEquals(0.995479004577296, model.calculateRSquared(), 1E-12);        assertEquals(0.992465007628826, model.calculateAdjustedRSquared(), 1E-12);                checkVarianceConsistency(model);                // Estimate model without intercept        model.setNoIntercept(true);        model.newSampleData(design, nobs, nvars);                // Check expected beta values from R        betaHat = model.estimateRegressionParameters();        TestUtils.assertEquals(betaHat,          new double[]{-52.99357013868291, 0.07107319907358,                -0.42346585566399,-0.57256866841929,                -0.41420358884978, 48.41786562001326}, 1E-11);                 // Check standard errors from R        errors = model.estimateRegressionParametersStandardErrors();        TestUtils.assertEquals(new double[] {129.54486693117232, 0.03016640003786,                0.41773654056612, 0.27899087467676, 0.32128496193363,                17.68948737819961}, errors, 1E-11);                // Check expected residuals from R        residuals = model.estimateResiduals();        TestUtils.assertEquals(residuals, new double[]{                279.90274927293092, -130.32465380836874, 90.73228661967445, -401.31252201634948,                -440.46768772620027, -543.54512853774793, 201.32111639536299, 215.90889365977932,                73.09368242049943, 913.21694494481869, 424.82484953610174, -8.56475876776709,                -361.32974610842876, 27.34560497213464, 151.28955976355002, -492.49937355336846},                      1E-10);                // Check regression standard error against R        assertEquals(475.1655079819517, model.estimateRegressionStandardError(), 1E-10);                // Check R-Square statistics against R        assertEquals(0.9999670130706, model.calculateRSquared(), 1E-12);        assertEquals(0.999947220913, model.calculateAdjustedRSquared(), 1E-12);             }    /**     * Test R Swiss fertility dataset against R.     * Data Source: R datasets package     */    @Test    public void testSwissFertility() throws Exception {        double[] design = new double[] {            80.2,17.0,15,12,9.96,            83.1,45.1,6,9,84.84,            92.5,39.7,5,5,93.40,            85.8,36.5,12,7,33.77,            76.9,43.5,17,15,5.16,            76.1,35.3,9,7,90.57,            83.8,70.2,16,7,92.85,            92.4,67.8,14,8,97.16,            82.4,53.3,12,7,97.67,            82.9,45.2,16,13,91.38,            87.1,64.5,14,6,98.61,            64.1,62.0,21,12,8.52,            66.9,67.5,14,7,2.27,            68.9,60.7,19,12,4.43,            61.7,69.3,22,5,2.82,            68.3,72.6,18,2,24.20,            71.7,34.0,17,8,3.30,            55.7,19.4,26,28,12.11,            54.3,15.2,31,20,2.15,            65.1,73.0,19,9,2.84,            65.5,59.8,22,10,5.23,            65.0,55.1,14,3,4.52,            56.6,50.9,22,12,15.14,            57.4,54.1,20,6,4.20,            72.5,71.2,12,1,2.40,            74.2,58.1,14,8,5.23,            72.0,63.5,6,3,2.56,            60.5,60.8,16,10,7.72,            58.3,26.8,25,19,18.46,            65.4,49.5,15,8,6.10,            75.5,85.9,3,2,99.71,            69.3,84.9,7,6,99.68,            77.3,89.7,5,2,100.00,            70.5,78.2,12,6,98.96,            79.4,64.9,7,3,98.22,            65.0,75.9,9,9,99.06,            92.2,84.6,3,3,99.46,            79.3,63.1,13,13,96.83,            70.4,38.4,26,12,5.62,            65.7,7.7,29,11,13.79,            72.7,16.7,22,13,11.22,            64.4,17.6,35,32,16.92,            77.6,37.6,15,7,4.97,            67.6,18.7,25,7,8.65,            35.0,1.2,37,53,42.34,            44.7,46.6,16,29,50.43,            42.8,27.7,22,29,58.33        };                final int nobs = 47;        final int nvars = 4;        // Estimate the model        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();        model.newSampleData(design, nobs, nvars);        // Check expected beta values from R        double[] betaHat = model.estimateRegressionParameters();        TestUtils.assertEquals(betaHat,                new double[]{91.05542390271397,                -0.22064551045715,                -0.26058239824328,                -0.96161238456030,                 0.12441843147162}, 1E-12);        // Check expected residuals from R        double[] residuals = model.estimateResiduals();        TestUtils.assertEquals(residuals, new double[]{                7.1044267859730512,1.6580347433531366,                4.6944952770029644,8.4548022690166160,13.6547432343186212,               -9.3586864458500774,7.5822446330520386,15.5568995563859289,                0.8113090736598980,7.1186762732484308,7.4251378771228724,                2.6761316873234109,0.8351584810309354,7.1769991119615177,               -3.8746753206299553,-3.1337779476387251,-0.1412575244091504,                1.1186809170469780,-6.3588097346816594,3.4039270429434074,                2.3374058329820175,-7.9272368576900503,-7.8361010968497959,               -11.2597369269357070,0.9445333697827101,6.6544245101380328,               -0.9146136301118665,-4.3152449403848570,-4.3536932047009183,               -3.8907885169304661,-6.3027643926302188,-7.8308982189289091,               -3.1792280015332750,-6.7167298771158226,-4.8469946718041754,               -10.6335664353633685,11.1031134362036958,6.0084032641811733,                5.4326230830188482,-7.2375578629692230,2.1671550814448222,                15.0147574652763112,4.8625103516321015,-7.1597256413907706,                -0.4515205619767598,-10.2916870903837587,-15.7812984571900063},                1E-12);        // Check standard errors from R        double[] errors = model.estimateRegressionParametersStandardErrors();        TestUtils.assertEquals(new double[] {6.94881329475087,                0.07360008972340,                0.27410957467466,                0.19454551679325,                0.03726654773803}, errors, 1E-10);                // Check regression standard error against R        assertEquals(7.73642194433223, model.estimateRegressionStandardError(), 1E-12);                // Check R-Square statistics against R        assertEquals(0.649789742860228, model.calculateRSquared(), 1E-12);        assertEquals(0.6164363850373927, model.calculateAdjustedRSquared(), 1E-12);                checkVarianceConsistency(model);                // Estimate the model with no intercept        model = new OLSMultipleLinearRegression();        model.setNoIntercept(true);        model.newSampleData(design, nobs, nvars);        // Check expected beta values from R        betaHat = model.estimateRegressionParameters();        TestUtils.assertEquals(betaHat,                new double[]{0.52191832900513,                  2.36588087917963,                  -0.94770353802795,                   0.30851985863609}, 1E-12);        // Check expected residuals from R        residuals = model.estimateResiduals();        TestUtils.assertEquals(residuals, new double[]{                44.138759883538249, 27.720705122356215, 35.873200836126799,                 34.574619581211977, 26.600168342080213, 15.074636243026923, -12.704904871199814,                1.497443824078134, 2.691972687079431, 5.582798774291231, -4.422986561283165,                 -9.198581600334345, 4.481765170730647, 2.273520207553216, -22.649827853221336,                -17.747900013943308, 20.298314638496436, 6.861405135329779, -8.684712790954924,                -10.298639278062371, -9.896618896845819, 4.568568616351242, -15.313570491727944,                -13.762961360873966, 7.156100301980509, 16.722282219843990, 26.716200609071898,                -1.991466398777079, -2.523342564719335, 9.776486693095093, -5.297535127628603,                -16.639070567471094, -10.302057295211819, -23.549487860816846, 1.506624392156384,                -17.939174438345930, 13.105792202765040, -1.943329906928462, -1.516005841666695,                -0.759066561832886, 20.793137744128977, -2.485236153005426, 27.588238710486976,                2.658333257106881, -15.998337823623046, -5.550742066720694, -14.219077806826615},                1E-12);        // Check standard errors from R        errors = model.estimateRegressionParametersStandardErrors();        TestUtils.assertEquals(new double[] {0.10470063765677, 0.41684100584290,                0.43370143099691, 0.07694953606522}, errors, 1E-10);                // Check regression standard error against R        assertEquals(17.24710630547, model.estimateRegressionStandardError(), 1E-10);                // Check R-Square statistics against R        assertEquals(0.946350722085, model.calculateRSquared(), 1E-12);        assertEquals(0.9413600915813, model.calculateAdjustedRSquared(), 1E-12);    }    /**     * Test hat matrix computation     *     * @throws Exception     */    @Test    public void testHat() throws Exception {        /*         * This example is from "The Hat Matrix in Regression and ANOVA",         * David C. Hoaglin and Roy E. Welsch,         * The American Statistician, Vol. 32, No. 1 (Feb., 1978), pp. 17-22.         *         */        double[] design = new double[] {                11.14, .499, 11.1,                12.74, .558, 8.9,                13.13, .604, 8.8,                11.51, .441, 8.9,                12.38, .550, 8.8,                12.60, .528, 9.9,                11.13, .418, 10.7,                11.7, .480, 10.5,                11.02, .406, 10.5,                11.41, .467, 10.7        };        int nobs = 10;        int nvars = 2;        // Estimate the model        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();        model.newSampleData(design, nobs, nvars);        RealMatrix hat = model.calculateHat();        // Reference data is upper half of symmetric hat matrix        double[] referenceData = new double[] {                .418, -.002,  .079, -.274, -.046,  .181,  .128,  .222,  .050,  .242,                       .242,  .292,  .136,  .243,  .128, -.041,  .033, -.035,  .004,                              .417, -.019,  .273,  .187, -.126,  .044, -.153,  .004,                                     .604,  .197, -.038,  .168, -.022,  .275, -.028,                                            .252,  .111, -.030,  .019, -.010, -.010,                                                   .148,  .042,  .117,  .012,  .111,                                                          .262,  .145,  .277,  .174,                                                                 .154,  .120,  .168,                                                                        .315,  .148,                                                                               .187        };        // Check against reference data and verify symmetry        int k = 0;        for (int i = 0; i < 10; i++) {            for (int j = i; j < 10; j++) {                assertEquals(referenceData[k], hat.getEntry(i, j), 10e-3);                assertEquals(hat.getEntry(i, j), hat.getEntry(j, i), 10e-12);                k++;            }        }        /*         * Verify that residuals computed using the hat matrix are close to         * what we get from direct computation, i.e. r = (I - H) y         */        double[] residuals = model.estimateResiduals();        RealMatrix I = MatrixUtils.createRealIdentityMatrix(10);        double[] hatResiduals = I.subtract(hat).operate(model.Y).getData();        TestUtils.assertEquals(residuals, hatResiduals, 10e-12);    }    /**     * test calculateYVariance     */    @Test    public void testYVariance() {        // assumes: y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();        model.newSampleData(y, x);        TestUtils.assertEquals(model.calculateYVariance(), 3.5, 0);    }        /**     * Verifies that calculateYVariance and calculateResidualVariance return consistent     * values with direct variance computation from Y, residuals, respectively.     */    protected void checkVarianceConsistency(OLSMultipleLinearRegression model) throws Exception {        // Check Y variance consistency        TestUtils.assertEquals(StatUtils.variance(model.Y.getData()), model.calculateYVariance(), 0);                // Check residual variance consistency        double[] residuals = model.calculateResiduals().getData();        RealMatrix X = model.X;        TestUtils.assertEquals(                StatUtils.variance(model.calculateResiduals().getData()) * (residuals.length - 1),                model.calculateErrorVariance() * (X.getRowDimension() - X.getColumnDimension()), 1E-20);            }        /**     * Verifies that setting X and Y separately has the same effect as newSample(X,Y).     */    @Test    public void testNewSample2() throws Exception {        double[] y = new double[] {1, 2, 3, 4};         double[][] x = new double[][] {          {19, 22, 33},          {20, 30, 40},          {25, 35, 45},          {27, 37, 47}           };        OLSMultipleLinearRegression regression = new OLSMultipleLinearRegression();        regression.newSampleData(y, x);        RealMatrix combinedX = regression.X.copy();        RealVector combinedY = regression.Y.copy();        regression.newXSampleData(x);        regression.newYSampleData(y);        assertEquals(combinedX, regression.X);        assertEquals(combinedY, regression.Y);                // No intercept        regression.setNoIntercept(true);        regression.newSampleData(y, x);        combinedX = regression.X.copy();        combinedY = regression.Y.copy();        regression.newXSampleData(x);        regression.newYSampleData(y);        assertEquals(combinedX, regression.X);        assertEquals(combinedY, regression.Y);    }        @Test(expected=IllegalArgumentException.class)    public void testNewSampleDataYNull() {        createRegression().newSampleData(null, new double[][] {});    }        @Test(expected=IllegalArgumentException.class)    public void testNewSampleDataXNull() {        createRegression().newSampleData(new double[] {}, null);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.regression;import java.util.Random;import junit.framework.TestCase;/** * Test cases for the TestStatistic class. * * @version $Revision$ $Date$ */public final class SimpleRegressionTest extends TestCase {    /*     * NIST "Norris" refernce data set from     * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat     * Strangely, order is {y,x}     */    private double[][] data = { { 0.1, 0.2 }, {338.8, 337.4 }, {118.1, 118.2 },            {888.0, 884.6 }, {9.2, 10.1 }, {228.1, 226.5 }, {668.5, 666.3 }, {998.5, 996.3 },            {449.1, 448.6 }, {778.9, 777.0 }, {559.2, 558.2 }, {0.3, 0.4 }, {0.1, 0.6 }, {778.1, 775.5 },            {668.8, 666.9 }, {339.3, 338.0 }, {448.9, 447.5 }, {10.8, 11.6 }, {557.7, 556.0 },            {228.3, 228.1 }, {998.0, 995.8 }, {888.8, 887.6 }, {119.6, 120.2 }, {0.3, 0.3 },            {0.6, 0.3 }, {557.6, 556.8 }, {339.3, 339.1 }, {888.0, 887.2 }, {998.5, 999.0 },            {778.9, 779.0 }, {10.2, 11.1 }, {117.6, 118.3 }, {228.9, 229.2 }, {668.4, 669.1 },            {449.2, 448.9 }, {0.2, 0.5 }    };    /*     * Correlation example from     * http://www.xycoon.com/correlation.htm     */    private double[][] corrData = { { 101.0, 99.2 }, {100.1, 99.0 }, {100.0, 100.0 },            {90.6, 111.6 }, {86.5, 122.2 }, {89.7, 117.6 }, {90.6, 121.1 }, {82.8, 136.0 },            {70.1, 154.2 }, {65.4, 153.6 }, {61.3, 158.5 }, {62.5, 140.6 }, {63.6, 136.2 },            {52.6, 168.0 }, {59.7, 154.3 }, {59.5, 149.0 }, {61.3, 165.5 }    };    /*     * From Moore and Mcabe, "Introduction to the Practice of Statistics"     * Example 10.3     */    private double[][] infData = { { 15.6, 5.2 }, {26.8, 6.1 }, {37.8, 8.7 }, {36.4, 8.5 },            {35.5, 8.8 }, {18.6, 4.9 }, {15.3, 4.5 }, {7.9, 2.5 }, {0.0, 1.1 }    };    /*     * Points to remove in the remove tests     */    private double[][] removeSingle = {infData[1]};    private double[][] removeMultiple = { infData[1], infData[2] };    private double removeX = infData[0][0];    private double removeY = infData[0][1];    /*     * Data with bad linear fit     */    private double[][] infData2 = { { 1, 1 }, {2, 0 }, {3, 5 }, {4, 2 },            {5, -1 }, {6, 12 }    };    public SimpleRegressionTest(String name) {        super(name);    }    public void testNorris() {        SimpleRegression regression = new SimpleRegression();        for (int i = 0; i < data.length; i++) {            regression.addData(data[i][1], data[i][0]);        }        // Tests against certified values from        // http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat        assertEquals("slope", 1.00211681802045, regression.getSlope(), 10E-12);        assertEquals("slope std err", 0.429796848199937E-03,                regression.getSlopeStdErr(),10E-12);        assertEquals("number of observations", 36, regression.getN());        assertEquals( "intercept", -0.262323073774029,            regression.getIntercept(),10E-12);        assertEquals("std err intercept", 0.232818234301152,            regression.getInterceptStdErr(),10E-12);        assertEquals("r-square", 0.999993745883712,            regression.getRSquare(), 10E-12);        assertEquals("SSR", 4255954.13232369,            regression.getRegressionSumSquares(), 10E-9);        assertEquals("MSE", 0.782864662630069,            regression.getMeanSquareError(), 10E-10);        assertEquals("SSE", 26.6173985294224,            regression.getSumSquaredErrors(),10E-9);        // ------------  End certified data tests        assertEquals( "predict(0)",  -0.262323073774029,            regression.predict(0), 10E-12);        assertEquals("predict(1)", 1.00211681802045 - 0.262323073774029,            regression.predict(1), 10E-12);    }    public void testCorr() {        SimpleRegression regression = new SimpleRegression();        regression.addData(corrData);        assertEquals("number of observations", 17, regression.getN());        assertEquals("r-square", .896123, regression.getRSquare(), 10E-6);        assertEquals("r", -0.94663767742, regression.getR(), 1E-10);    }    public void testNaNs() {        SimpleRegression regression = new SimpleRegression();        assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept()));        assertTrue("slope not NaN", Double.isNaN(regression.getSlope()));        assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));        assertTrue("e not NaN", Double.isNaN(regression.getR()));        assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare()));        assertTrue( "RSS not NaN", Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE not NaN",Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("SSTO not NaN", Double.isNaN(regression.getTotalSumSquares()));        assertTrue("predict not NaN", Double.isNaN(regression.predict(0)));        regression.addData(1, 2);        regression.addData(1, 3);        // No x variation, so these should still blow...        assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept()));        assertTrue("slope not NaN", Double.isNaN(regression.getSlope()));        assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));        assertTrue("e not NaN", Double.isNaN(regression.getR()));        assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare()));        assertTrue("RSS not NaN", Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE not NaN", Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("predict not NaN", Double.isNaN(regression.predict(0)));        // but SSTO should be OK        assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares()));        regression = new SimpleRegression();        regression.addData(1, 2);        regression.addData(3, 3);        // All should be OK except MSE, s(b0), s(b1) which need one more df        assertTrue("interceptNaN", !Double.isNaN(regression.getIntercept()));        assertTrue("slope NaN", !Double.isNaN(regression.getSlope()));        assertTrue ("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));        assertTrue("r NaN", !Double.isNaN(regression.getR()));        assertTrue("r-square NaN", !Double.isNaN(regression.getRSquare()));        assertTrue("RSS NaN", !Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE NaN", !Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares()));        assertTrue("predict NaN", !Double.isNaN(regression.predict(0)));        regression.addData(1, 4);        // MSE, MSE, s(b0), s(b1) should all be OK now        assertTrue("MSE NaN", !Double.isNaN(regression.getMeanSquareError()));        assertTrue("slope std err NaN", !Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err NaN", !Double.isNaN(regression.getInterceptStdErr()));    }    public void testClear() {        SimpleRegression regression = new SimpleRegression();        regression.addData(corrData);        assertEquals("number of observations", 17, regression.getN());        regression.clear();        assertEquals("number of observations", 0, regression.getN());        regression.addData(corrData);        assertEquals("r-square", .896123, regression.getRSquare(), 10E-6);        regression.addData(data);        assertEquals("number of observations", 53, regression.getN());    }    public void testInference() throws Exception {        //----------  verified against R, version 1.8.1 -----        // infData        SimpleRegression regression = new SimpleRegression();        regression.addData(infData);        assertEquals("slope std err", 0.011448491,                regression.getSlopeStdErr(), 1E-10);        assertEquals("std err intercept", 0.286036932,                regression.getInterceptStdErr(),1E-8);        assertEquals("significance", 4.596e-07,                regression.getSignificance(),1E-8);        assertEquals("slope conf interval half-width", 0.0270713794287,                regression.getSlopeConfidenceInterval(),1E-8);        // infData2        regression = new SimpleRegression();        regression.addData(infData2);        assertEquals("slope std err", 1.07260253,                regression.getSlopeStdErr(), 1E-8);        assertEquals("std err intercept",4.17718672,                regression.getInterceptStdErr(),1E-8);        assertEquals("significance", 0.261829133982,                regression.getSignificance(),1E-11);        assertEquals("slope conf interval half-width", 2.97802204827,                regression.getSlopeConfidenceInterval(),1E-8);        //------------- End R-verified tests -------------------------------        //FIXME: get a real example to test against with alpha = .01        assertTrue("tighter means wider",                regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01));        try {            regression.getSlopeConfidenceInterval(1);            fail("expecting IllegalArgumentException for alpha = 1");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testPerfect() throws Exception {        SimpleRegression regression = new SimpleRegression();        int n = 100;        for (int i = 0; i < n; i++) {            regression.addData(((double) i) / (n - 1), i);        }        assertEquals(0.0, regression.getSignificance(), 1.0e-5);        assertTrue(regression.getSlope() > 0.0);        assertTrue(regression.getSumSquaredErrors() >= 0.0);    }    public void testPerfectNegative() throws Exception {        SimpleRegression regression = new SimpleRegression();        int n = 100;        for (int i = 0; i < n; i++) {            regression.addData(- ((double) i) / (n - 1), i);        }        assertEquals(0.0, regression.getSignificance(), 1.0e-5);        assertTrue(regression.getSlope() < 0.0);    }    public void testRandom() throws Exception {        SimpleRegression regression = new SimpleRegression();        Random random = new Random(1);        int n = 100;        for (int i = 0; i < n; i++) {            regression.addData(((double) i) / (n - 1), random.nextDouble());        }        assertTrue( 0.0 < regression.getSignificance()                    && regression.getSignificance() < 1.0);    }    // Jira MATH-85 = Bugzilla 39432    public void testSSENonNegative() {        double[] y = { 8915.102, 8919.302, 8923.502 };        double[] x = { 1.107178495E2, 1.107264895E2, 1.107351295E2 };        SimpleRegression reg = new SimpleRegression();        for (int i = 0; i < x.length; i++) {            reg.addData(x[i], y[i]);        }        assertTrue(reg.getSumSquaredErrors() >= 0.0);    }    // Test remove X,Y (single observation)    public void testRemoveXY() throws Exception {        // Create regression with inference data then remove to test        SimpleRegression regression = new SimpleRegression();        regression.addData(infData);        regression.removeData(removeX, removeY);        regression.addData(removeX, removeY);        // Use the inference assertions to make sure that everything worked        assertEquals("slope std err", 0.011448491,                regression.getSlopeStdErr(), 1E-10);        assertEquals("std err intercept", 0.286036932,                regression.getInterceptStdErr(),1E-8);        assertEquals("significance", 4.596e-07,                regression.getSignificance(),1E-8);        assertEquals("slope conf interval half-width", 0.0270713794287,                regression.getSlopeConfidenceInterval(),1E-8);     }    // Test remove single observation in array    public void testRemoveSingle() throws Exception {        // Create regression with inference data then remove to test        SimpleRegression regression = new SimpleRegression();        regression.addData(infData);        regression.removeData(removeSingle);        regression.addData(removeSingle);        // Use the inference assertions to make sure that everything worked        assertEquals("slope std err", 0.011448491,                regression.getSlopeStdErr(), 1E-10);        assertEquals("std err intercept", 0.286036932,                regression.getInterceptStdErr(),1E-8);        assertEquals("significance", 4.596e-07,                regression.getSignificance(),1E-8);        assertEquals("slope conf interval half-width", 0.0270713794287,                regression.getSlopeConfidenceInterval(),1E-8);     }    // Test remove multiple observations    public void testRemoveMultiple() throws Exception {        // Create regression with inference data then remove to test        SimpleRegression regression = new SimpleRegression();        regression.addData(infData);        regression.removeData(removeMultiple);        regression.addData(removeMultiple);        // Use the inference assertions to make sure that everything worked        assertEquals("slope std err", 0.011448491,                regression.getSlopeStdErr(), 1E-10);        assertEquals("std err intercept", 0.286036932,                regression.getInterceptStdErr(),1E-8);        assertEquals("significance", 4.596e-07,                regression.getSignificance(),1E-8);        assertEquals("slope conf interval half-width", 0.0270713794287,                regression.getSlopeConfidenceInterval(),1E-8);     }    // Remove observation when empty    public void testRemoveObsFromEmpty() {        SimpleRegression regression = new SimpleRegression();        regression.removeData(removeX, removeY);        assertEquals(regression.getN(), 0);    }    // Remove single observation to empty    public void testRemoveObsFromSingle() {        SimpleRegression regression = new SimpleRegression();        regression.addData(removeX, removeY);        regression.removeData(removeX, removeY);        assertEquals(regression.getN(), 0);    }    // Remove multiple observations to empty    public void testRemoveMultipleToEmpty() {        SimpleRegression regression = new SimpleRegression();        regression.addData(removeMultiple);        regression.removeData(removeMultiple);        assertEquals(regression.getN(), 0);    }    // Remove multiple observations past empty (i.e. size of array > n)    public void testRemoveMultiplePastEmpty() {        SimpleRegression regression = new SimpleRegression();        regression.addData(removeX, removeY);        regression.removeData(removeMultiple);        assertEquals(regression.getN(), 0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.regression;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.RealVector;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import org.junit.Before;import org.junit.Test;public abstract class MultipleLinearRegressionAbstractTest {    protected AbstractMultipleLinearRegression regression;    @Before    public void setUp(){        regression = createRegression();    }    protected abstract AbstractMultipleLinearRegression createRegression();    protected abstract int getNumberOfRegressors();    protected abstract int getSampleSize();    @Test    public void canEstimateRegressionParameters(){        double[] beta = regression.estimateRegressionParameters();        assertEquals(getNumberOfRegressors(), beta.length);    }    @Test    public void canEstimateResiduals(){        double[] e = regression.estimateResiduals();        assertEquals(getSampleSize(), e.length);    }    @Test    public void canEstimateRegressionParametersVariance(){        double[][] variance = regression.estimateRegressionParametersVariance();        assertEquals(getNumberOfRegressors(), variance.length);    }    @Test    public void canEstimateRegressandVariance(){        if (getSampleSize() > getNumberOfRegressors()) {            double variance = regression.estimateRegressandVariance();            assertTrue(variance > 0.0);        }    }        /**     * Verifies that newSampleData methods consistently insert unitary columns     * in design matrix.  Confirms the fix for MATH-411.     */    @Test    public void testNewSample() throws Exception {        double[] design = new double[] {          1, 19, 22, 33,          2, 20, 30, 40,          3, 25, 35, 45,          4, 27, 37, 47        };        double[] y = new double[] {1, 2, 3, 4};         double[][] x = new double[][] {          {19, 22, 33},          {20, 30, 40},          {25, 35, 45},          {27, 37, 47}           };        AbstractMultipleLinearRegression regression = (AbstractMultipleLinearRegression) createRegression();        regression.newSampleData(design, 4, 3);        RealMatrix flatX = regression.X.copy();        RealVector flatY = regression.Y.copy();        regression.newXSampleData(x);        regression.newYSampleData(y);        assertEquals(flatX, regression.X);        assertEquals(flatY, regression.Y);                // No intercept        regression.setNoIntercept(true);        regression.newSampleData(design, 4, 3);        flatX = regression.X.copy();        flatY = regression.Y.copy();        regression.newXSampleData(x);        regression.newYSampleData(y);        assertEquals(flatX, regression.X);        assertEquals(flatY, regression.Y);    }        @Test(expected=IllegalArgumentException.class)    public void testNewSampleNullData() throws Exception {        double[] data = null;        createRegression().newSampleData(data, 2, 3);     }        @Test(expected=IllegalArgumentException.class)    public void testNewSampleInvalidData() throws Exception {        double[] data = new double[] {1, 2, 3, 4};        createRegression().newSampleData(data, 2, 3);    }        @Test(expected=IllegalArgumentException.class)    public void testNewSampleInsufficientData() throws Exception {        double[] data = new double[] {1, 2, 3, 4};        createRegression().newSampleData(data, 1, 3);    }        @Test(expected=IllegalArgumentException.class)    public void testXSampleDataNull() {        createRegression().newXSampleData(null);    }        @Test(expected=IllegalArgumentException.class)    public void testYSampleDataNull() {        createRegression().newYSampleData(null);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.regression;import static org.junit.Assert.assertEquals;import org.junit.Before;import org.junit.Test;import org.apache.commons.math.TestUtils;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.RealVector;public class GLSMultipleLinearRegressionTest extends MultipleLinearRegressionAbstractTest {    private double[] y;    private double[][] x;    private double[][] omega;    @Before    @Override    public void setUp(){        y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};        x = new double[6][];        x[0] = new double[]{0, 0, 0, 0, 0};        x[1] = new double[]{2.0, 0, 0, 0, 0};        x[2] = new double[]{0, 3.0, 0, 0, 0};        x[3] = new double[]{0, 0, 4.0, 0, 0};        x[4] = new double[]{0, 0, 0, 5.0, 0};        x[5] = new double[]{0, 0, 0, 0, 6.0};        omega = new double[6][];        omega[0] = new double[]{1.0, 0, 0, 0, 0, 0};        omega[1] = new double[]{0, 2.0, 0, 0, 0, 0};        omega[2] = new double[]{0, 0, 3.0, 0, 0, 0};        omega[3] = new double[]{0, 0, 0, 4.0, 0, 0};        omega[4] = new double[]{0, 0, 0, 0, 5.0, 0};        omega[5] = new double[]{0, 0, 0, 0, 0, 6.0};        super.setUp();    }    @Test(expected=IllegalArgumentException.class)    public void cannotAddXSampleData() {        createRegression().newSampleData(new double[]{}, null, null);    }    @Test(expected=IllegalArgumentException.class)    public void cannotAddNullYSampleData() {        createRegression().newSampleData(null, new double[][]{}, null);    }    @Test(expected=IllegalArgumentException.class)    public void cannotAddSampleDataWithSizeMismatch() {        double[] y = new double[]{1.0, 2.0};        double[][] x = new double[1][];        x[0] = new double[]{1.0, 0};        createRegression().newSampleData(y, x, null);    }    @Test(expected=IllegalArgumentException.class)    public void cannotAddNullCovarianceData() {        createRegression().newSampleData(new double[]{}, new double[][]{}, null);    }    @Test(expected=IllegalArgumentException.class)    public void notEnoughData() {        double[]   reducedY = new double[y.length - 1];        double[][] reducedX = new double[x.length - 1][];        double[][] reducedO = new double[omega.length - 1][];        System.arraycopy(y,     0, reducedY, 0, reducedY.length);        System.arraycopy(x,     0, reducedX, 0, reducedX.length);        System.arraycopy(omega, 0, reducedO, 0, reducedO.length);        createRegression().newSampleData(reducedY, reducedX, reducedO);    }    @Test(expected=IllegalArgumentException.class)    public void cannotAddCovarianceDataWithSampleSizeMismatch() {        double[] y = new double[]{1.0, 2.0};        double[][] x = new double[2][];        x[0] = new double[]{1.0, 0};        x[1] = new double[]{0, 1.0};        double[][] omega = new double[1][];        omega[0] = new double[]{1.0, 0};        createRegression().newSampleData(y, x, omega);    }    @Test(expected=IllegalArgumentException.class)    public void cannotAddCovarianceDataThatIsNotSquare() {        double[] y = new double[]{1.0, 2.0};        double[][] x = new double[2][];        x[0] = new double[]{1.0, 0};        x[1] = new double[]{0, 1.0};        double[][] omega = new double[3][];        omega[0] = new double[]{1.0, 0};        omega[1] = new double[]{0, 1.0};        omega[2] = new double[]{0, 2.0};        createRegression().newSampleData(y, x, omega);    }    @Override    protected GLSMultipleLinearRegression createRegression() {        GLSMultipleLinearRegression regression = new GLSMultipleLinearRegression();        regression.newSampleData(y, x, omega);        return regression;    }    @Override    protected int getNumberOfRegressors() {        return x[0].length + 1;    }    @Override    protected int getSampleSize() {        return y.length;    }    /**     * test calculateYVariance     */    @Test    public void testYVariance() {        // assumes: y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};        GLSMultipleLinearRegression model = new GLSMultipleLinearRegression();        model.newSampleData(y, x, omega);        TestUtils.assertEquals(model.calculateYVariance(), 3.5, 0);    }        /**     * Verifies that setting X, Y and covariance separately has the same effect as newSample(X,Y,cov).     */    @Test    public void testNewSample2() throws Exception {        double[] y = new double[] {1, 2, 3, 4};         double[][] x = new double[][] {          {19, 22, 33},          {20, 30, 40},          {25, 35, 45},          {27, 37, 47}           };        double[][] covariance = MatrixUtils.createRealIdentityMatrix(4).scalarMultiply(2).getData();        GLSMultipleLinearRegression regression = new GLSMultipleLinearRegression();        regression.newSampleData(y, x, covariance);        RealMatrix combinedX = regression.X.copy();        RealVector combinedY = regression.Y.copy();        RealMatrix combinedCovInv = regression.getOmegaInverse();        regression.newXSampleData(x);        regression.newYSampleData(y);        assertEquals(combinedX, regression.X);        assertEquals(combinedY, regression.Y);        assertEquals(combinedCovInv, regression.getOmegaInverse());    }        /**     * Verifies that GLS with identity covariance matrix gives the same results     * as OLS.     */    @Test    public void testGLSOLSConsistency() throws Exception {        // Use Longley data to test        double[] design = new double[] {                60323,83.0,234289,2356,1590,107608,1947,                61122,88.5,259426,2325,1456,108632,1948,                60171,88.2,258054,3682,1616,109773,1949,                61187,89.5,284599,3351,1650,110929,1950,                63221,96.2,328975,2099,3099,112075,1951,                63639,98.1,346999,1932,3594,113270,1952,                64989,99.0,365385,1870,3547,115094,1953,                63761,100.0,363112,3578,3350,116219,1954,                66019,101.2,397469,2904,3048,117388,1955,                67857,104.6,419180,2822,2857,118734,1956,                68169,108.4,442769,2936,2798,120445,1957,                66513,110.8,444546,4681,2637,121950,1958,                68655,112.6,482704,3813,2552,123366,1959,                69564,114.2,502601,3931,2514,125368,1960,                69331,115.7,518173,4806,2572,127852,1961,                70551,116.9,554894,4007,2827,130081,1962            };        RealMatrix identityCov = MatrixUtils.createRealIdentityMatrix(16);        GLSMultipleLinearRegression glsModel = new GLSMultipleLinearRegression();        OLSMultipleLinearRegression olsModel = new OLSMultipleLinearRegression();        glsModel.newSampleData(design, 16, 6);        olsModel.newSampleData(design, 16, 6);        glsModel.newCovarianceData(identityCov.getData());        double[] olsBeta = olsModel.calculateBeta().getData();        double[] glsBeta = glsModel.calculateBeta().getData();        // TODO:  Should have assertRelativelyEquals(double[], double[], eps) in TestUtils        //        Should also add RealVector and RealMatrix versions        for (int i = 0; i < olsBeta.length; i++) {            TestUtils.assertRelativelyEquals(olsBeta[i], glsBeta[i], 10E-7);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.correlation;import org.apache.commons.math.TestUtils;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.linear.RealMatrix;/** * Test cases for Spearman's rank correlation * * @since 2.0 * @version $Revision$ $Date$ */public class SpearmansRankCorrelationTest extends PearsonsCorrelationTest {    @Override    protected void setUp() throws Exception {        super.setUp();    }    @Override    protected void tearDown() throws Exception {        super.tearDown();    }    /**     * Test Longley dataset against R.     */    @Override    public void testLongly() throws Exception {        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);        RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();        double[] rData = new double[] {                1, 0.982352941176471, 0.985294117647059, 0.564705882352941, 0.2264705882352941, 0.976470588235294,                0.976470588235294, 0.982352941176471, 1, 0.997058823529412, 0.664705882352941, 0.2205882352941176,                0.997058823529412, 0.997058823529412, 0.985294117647059, 0.997058823529412, 1, 0.638235294117647,                0.2235294117647059, 0.9941176470588236, 0.9941176470588236, 0.564705882352941, 0.664705882352941,                0.638235294117647, 1, -0.3411764705882353, 0.685294117647059, 0.685294117647059, 0.2264705882352941,                0.2205882352941176, 0.2235294117647059, -0.3411764705882353, 1, 0.2264705882352941, 0.2264705882352941,                0.976470588235294, 0.997058823529412, 0.9941176470588236, 0.685294117647059, 0.2264705882352941, 1, 1,                0.976470588235294, 0.997058823529412, 0.9941176470588236, 0.685294117647059, 0.2264705882352941, 1, 1        };        TestUtils.assertEquals("Spearman's correlation matrix", createRealMatrix(rData, 7, 7), correlationMatrix, 10E-15);    }    /**     * Test R swiss fertility dataset.     */    public void testSwiss() throws Exception {        RealMatrix matrix = createRealMatrix(swissData, 47, 5);        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);        RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();        double[] rData = new double[] {                1, 0.2426642769364176, -0.660902996352354, -0.443257690360988, 0.4136455623012432,                0.2426642769364176, 1, -0.598859938748963, -0.650463814145816, 0.2886878090882852,               -0.660902996352354, -0.598859938748963, 1, 0.674603831406147, -0.4750575257171745,               -0.443257690360988, -0.650463814145816, 0.674603831406147, 1, -0.1444163088302244,                0.4136455623012432, 0.2886878090882852, -0.4750575257171745, -0.1444163088302244, 1        };        TestUtils.assertEquals("Spearman's correlation matrix", createRealMatrix(rData, 5, 5), correlationMatrix, 10E-15);    }    /**     * Constant column     */    @Override    public void testConstant() {        double[] noVariance = new double[] {1, 1, 1, 1};        double[] values = new double[] {1, 2, 3, 4};        assertTrue(Double.isNaN(new SpearmansCorrelation().correlation(noVariance, values)));    }    /**     * Insufficient data     */    @Override    public void testInsufficientData() {        double[] one = new double[] {1};        double[] two = new double[] {2};        try {            new SpearmansCorrelation().correlation(one, two);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }        RealMatrix matrix = new BlockRealMatrix(new double[][] {{0},{1}});        try {            new SpearmansCorrelation(matrix);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }    }    @Override    public void testConsistency() {        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);        double[][] data = matrix.getData();        double[] x = matrix.getColumn(0);        double[] y = matrix.getColumn(1);        assertEquals(new SpearmansCorrelation().correlation(x, y),                corrInstance.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE);        TestUtils.assertEquals("Correlation matrix", corrInstance.getCorrelationMatrix(),                new SpearmansCorrelation().computeCorrelationMatrix(data), Double.MIN_VALUE);    }    // Not relevant here    @Override    public void testStdErrorConsistency() throws Exception {}    @Override    public void testCovarianceConsistency() throws Exception {}}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.correlation;import org.apache.commons.math.TestUtils;import org.apache.commons.math.distribution.TDistribution;import org.apache.commons.math.distribution.TDistributionImpl;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;public class PearsonsCorrelationTest extends TestCase {    protected final double[] longleyData = new double[] {            60323,83.0,234289,2356,1590,107608,1947,            61122,88.5,259426,2325,1456,108632,1948,            60171,88.2,258054,3682,1616,109773,1949,            61187,89.5,284599,3351,1650,110929,1950,            63221,96.2,328975,2099,3099,112075,1951,            63639,98.1,346999,1932,3594,113270,1952,            64989,99.0,365385,1870,3547,115094,1953,            63761,100.0,363112,3578,3350,116219,1954,            66019,101.2,397469,2904,3048,117388,1955,            67857,104.6,419180,2822,2857,118734,1956,            68169,108.4,442769,2936,2798,120445,1957,            66513,110.8,444546,4681,2637,121950,1958,            68655,112.6,482704,3813,2552,123366,1959,            69564,114.2,502601,3931,2514,125368,1960,            69331,115.7,518173,4806,2572,127852,1961,            70551,116.9,554894,4007,2827,130081,1962        };    protected final double[] swissData = new double[] {            80.2,17.0,15,12,9.96,            83.1,45.1,6,9,84.84,            92.5,39.7,5,5,93.40,            85.8,36.5,12,7,33.77,            76.9,43.5,17,15,5.16,            76.1,35.3,9,7,90.57,            83.8,70.2,16,7,92.85,            92.4,67.8,14,8,97.16,            82.4,53.3,12,7,97.67,            82.9,45.2,16,13,91.38,            87.1,64.5,14,6,98.61,            64.1,62.0,21,12,8.52,            66.9,67.5,14,7,2.27,            68.9,60.7,19,12,4.43,            61.7,69.3,22,5,2.82,            68.3,72.6,18,2,24.20,            71.7,34.0,17,8,3.30,            55.7,19.4,26,28,12.11,            54.3,15.2,31,20,2.15,            65.1,73.0,19,9,2.84,            65.5,59.8,22,10,5.23,            65.0,55.1,14,3,4.52,            56.6,50.9,22,12,15.14,            57.4,54.1,20,6,4.20,            72.5,71.2,12,1,2.40,            74.2,58.1,14,8,5.23,            72.0,63.5,6,3,2.56,            60.5,60.8,16,10,7.72,            58.3,26.8,25,19,18.46,            65.4,49.5,15,8,6.10,            75.5,85.9,3,2,99.71,            69.3,84.9,7,6,99.68,            77.3,89.7,5,2,100.00,            70.5,78.2,12,6,98.96,            79.4,64.9,7,3,98.22,            65.0,75.9,9,9,99.06,            92.2,84.6,3,3,99.46,            79.3,63.1,13,13,96.83,            70.4,38.4,26,12,5.62,            65.7,7.7,29,11,13.79,            72.7,16.7,22,13,11.22,            64.4,17.6,35,32,16.92,            77.6,37.6,15,7,4.97,            67.6,18.7,25,7,8.65,            35.0,1.2,37,53,42.34,            44.7,46.6,16,29,50.43,            42.8,27.7,22,29,58.33        };    /**     * Test Longley dataset against R.     */    public void testLongly() throws Exception {        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);        RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();        double[] rData = new double[] {                1.000000000000000, 0.9708985250610560, 0.9835516111796693, 0.5024980838759942,                0.4573073999764817, 0.960390571594376, 0.9713294591921188,                0.970898525061056, 1.0000000000000000, 0.9915891780247822, 0.6206333925590966,                0.4647441876006747, 0.979163432977498, 0.9911491900672053,                0.983551611179669, 0.9915891780247822, 1.0000000000000000, 0.6042609398895580,                0.4464367918926265, 0.991090069458478, 0.9952734837647849,                0.502498083875994, 0.6206333925590966, 0.6042609398895580, 1.0000000000000000,                -0.1774206295018783, 0.686551516365312, 0.6682566045621746,                0.457307399976482, 0.4647441876006747, 0.4464367918926265, -0.1774206295018783,                1.0000000000000000, 0.364416267189032, 0.4172451498349454,                0.960390571594376, 0.9791634329774981, 0.9910900694584777, 0.6865515163653120,                0.3644162671890320, 1.000000000000000, 0.9939528462329257,                0.971329459192119, 0.9911491900672053, 0.9952734837647849, 0.6682566045621746,                0.4172451498349454, 0.993952846232926, 1.0000000000000000        };        TestUtils.assertEquals("correlation matrix", createRealMatrix(rData, 7, 7), correlationMatrix, 10E-15);        double[] rPvalues = new double[] {                4.38904690369668e-10,                8.36353208910623e-12, 7.8159700933611e-14,                0.0472894097790304, 0.01030636128354301, 0.01316878049026582,                0.0749178049642416, 0.06971758330341182, 0.0830166169296545, 0.510948586323452,                3.693245043123738e-09, 4.327782576751815e-11, 1.167954621905665e-13, 0.00331028281967516, 0.1652293725106684,                3.95834476307755e-10, 1.114663916723657e-13, 1.332267629550188e-15, 0.00466039138541463, 0.1078477071581498, 7.771561172376096e-15        };        RealMatrix rPMatrix = createLowerTriangularRealMatrix(rPvalues, 7);        fillUpper(rPMatrix, 0d);        TestUtils.assertEquals("correlation p values", rPMatrix, corrInstance.getCorrelationPValues(), 10E-15);    }    /**     * Test R Swiss fertility dataset against R.     */    public void testSwissFertility() throws Exception {         RealMatrix matrix = createRealMatrix(swissData, 47, 5);         PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);         RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();         double[] rData = new double[] {               1.0000000000000000, 0.3530791836199747, -0.6458827064572875, -0.6637888570350691,  0.4636847006517939,                 0.3530791836199747, 1.0000000000000000,-0.6865422086171366, -0.6395225189483201, 0.4010950530487398,                -0.6458827064572875, -0.6865422086171366, 1.0000000000000000, 0.6984152962884830, -0.5727418060641666,                -0.6637888570350691, -0.6395225189483201, 0.6984152962884830, 1.0000000000000000, -0.1538589170909148,                 0.4636847006517939, 0.4010950530487398, -0.5727418060641666, -0.1538589170909148, 1.0000000000000000         };         TestUtils.assertEquals("correlation matrix", createRealMatrix(rData, 5, 5), correlationMatrix, 10E-15);         double[] rPvalues = new double[] {                 0.01491720061472623,                 9.45043734069043e-07, 9.95151527133974e-08,                 3.658616965962355e-07, 1.304590105694471e-06, 4.811397236181847e-08,                 0.001028523190118147, 0.005204433539191644, 2.588307925380906e-05, 0.301807756132683         };         RealMatrix rPMatrix = createLowerTriangularRealMatrix(rPvalues, 5);         fillUpper(rPMatrix, 0d);         TestUtils.assertEquals("correlation p values", rPMatrix, corrInstance.getCorrelationPValues(), 10E-15);    }        /**     * Test p-value near 0. JIRA: MATH-371     */    public void testPValueNearZero() throws Exception {        /*         * Create a dataset that has r -> 1, p -> 0 as dimension increases.         * Prior to the fix for MATH-371, p vanished for dimension >= 14.         * Post fix, p-values diminish smoothly, vanishing at dimension = 127.         * Tested value is ~1E-303.         */        int dimension = 120;         double[][] data = new double[dimension][2];        for (int i = 0; i < dimension; i++) {            data[i][0] = i;            data[i][1] = i + 1/((double)i + 1);        }        PearsonsCorrelation corrInstance = new PearsonsCorrelation(data);        assertTrue(corrInstance.getCorrelationPValues().getEntry(0, 1) > 0);    }        /**     * Constant column     */    public void testConstant() {        double[] noVariance = new double[] {1, 1, 1, 1};        double[] values = new double[] {1, 2, 3, 4};        assertTrue(Double.isNaN(new PearsonsCorrelation().correlation(noVariance, values)));    }    /**     * Insufficient data     */    public void testInsufficientData() {        double[] one = new double[] {1};        double[] two = new double[] {2};        try {            new PearsonsCorrelation().correlation(one, two);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }        RealMatrix matrix = new BlockRealMatrix(new double[][] {{0},{1}});        try {            new PearsonsCorrelation(matrix);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }    }    /**     * Verify that direct t-tests using standard error estimates are consistent     * with reported p-values     */    public void testStdErrorConsistency() throws Exception {        TDistribution tDistribution = new TDistributionImpl(45);        RealMatrix matrix = createRealMatrix(swissData, 47, 5);        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);        RealMatrix rValues = corrInstance.getCorrelationMatrix();        RealMatrix pValues = corrInstance.getCorrelationPValues();        RealMatrix stdErrors = corrInstance.getCorrelationStandardErrors();        for (int i = 0; i < 5; i++) {            for (int j = 0; j < i; j++) {                double t = FastMath.abs(rValues.getEntry(i, j)) / stdErrors.getEntry(i, j);                double p = 2 * (1 - tDistribution.cumulativeProbability(t));                assertEquals(p, pValues.getEntry(i, j), 10E-15);            }        }    }    /**     * Verify that creating correlation from covariance gives same results as     * direct computation from the original matrix     */    public void testCovarianceConsistency() throws Exception {        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);        Covariance covInstance = new Covariance(matrix);        PearsonsCorrelation corrFromCovInstance = new PearsonsCorrelation(covInstance);        TestUtils.assertEquals("correlation values", corrInstance.getCorrelationMatrix(),                corrFromCovInstance.getCorrelationMatrix(), 10E-15);        TestUtils.assertEquals("p values", corrInstance.getCorrelationPValues(),                corrFromCovInstance.getCorrelationPValues(), 10E-15);        TestUtils.assertEquals("standard errors", corrInstance.getCorrelationStandardErrors(),                corrFromCovInstance.getCorrelationStandardErrors(), 10E-15);        PearsonsCorrelation corrFromCovInstance2 =            new PearsonsCorrelation(covInstance.getCovarianceMatrix(), 16);        TestUtils.assertEquals("correlation values", corrInstance.getCorrelationMatrix(),                corrFromCovInstance2.getCorrelationMatrix(), 10E-15);        TestUtils.assertEquals("p values", corrInstance.getCorrelationPValues(),                corrFromCovInstance2.getCorrelationPValues(), 10E-15);        TestUtils.assertEquals("standard errors", corrInstance.getCorrelationStandardErrors(),                corrFromCovInstance2.getCorrelationStandardErrors(), 10E-15);    }    public void testConsistency() {        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);        double[][] data = matrix.getData();        double[] x = matrix.getColumn(0);        double[] y = matrix.getColumn(1);        assertEquals(new PearsonsCorrelation().correlation(x, y),                corrInstance.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE);        TestUtils.assertEquals("Correlation matrix", corrInstance.getCorrelationMatrix(),                new PearsonsCorrelation().computeCorrelationMatrix(data), Double.MIN_VALUE);    }    protected RealMatrix createRealMatrix(double[] data, int nRows, int nCols) {        double[][] matrixData = new double[nRows][nCols];        int ptr = 0;        for (int i = 0; i < nRows; i++) {            System.arraycopy(data, ptr, matrixData[i], 0, nCols);            ptr += nCols;        }        return new BlockRealMatrix(matrixData);    }    protected RealMatrix createLowerTriangularRealMatrix(double[] data, int dimension) {        int ptr = 0;        RealMatrix result = new BlockRealMatrix(dimension, dimension);        for (int i = 1; i < dimension; i++) {            for (int j = 0; j < i; j++) {                result.setEntry(i, j, data[ptr]);                ptr++;            }        }        return result;    }    protected void fillUpper(RealMatrix matrix, double diagonalValue) {        int dimension = matrix.getColumnDimension();        for (int i = 0; i < dimension; i++) {            matrix.setEntry(i, i, diagonalValue);            for (int j = i+1; j < dimension; j++) {                matrix.setEntry(i, j, matrix.getEntry(j, i));            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.correlation;import org.apache.commons.math.TestUtils;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.linear.Array2DRowRealMatrix;import org.apache.commons.math.stat.descriptive.moment.Variance;import junit.framework.TestCase;public class CovarianceTest extends TestCase {    protected final double[] longleyData = new double[] {            60323,83.0,234289,2356,1590,107608,1947,            61122,88.5,259426,2325,1456,108632,1948,            60171,88.2,258054,3682,1616,109773,1949,            61187,89.5,284599,3351,1650,110929,1950,            63221,96.2,328975,2099,3099,112075,1951,            63639,98.1,346999,1932,3594,113270,1952,            64989,99.0,365385,1870,3547,115094,1953,            63761,100.0,363112,3578,3350,116219,1954,            66019,101.2,397469,2904,3048,117388,1955,            67857,104.6,419180,2822,2857,118734,1956,            68169,108.4,442769,2936,2798,120445,1957,            66513,110.8,444546,4681,2637,121950,1958,            68655,112.6,482704,3813,2552,123366,1959,            69564,114.2,502601,3931,2514,125368,1960,            69331,115.7,518173,4806,2572,127852,1961,            70551,116.9,554894,4007,2827,130081,1962        };    protected final double[] swissData = new double[] {            80.2,17.0,15,12,9.96,            83.1,45.1,6,9,84.84,            92.5,39.7,5,5,93.40,            85.8,36.5,12,7,33.77,            76.9,43.5,17,15,5.16,            76.1,35.3,9,7,90.57,            83.8,70.2,16,7,92.85,            92.4,67.8,14,8,97.16,            82.4,53.3,12,7,97.67,            82.9,45.2,16,13,91.38,            87.1,64.5,14,6,98.61,            64.1,62.0,21,12,8.52,            66.9,67.5,14,7,2.27,            68.9,60.7,19,12,4.43,            61.7,69.3,22,5,2.82,            68.3,72.6,18,2,24.20,            71.7,34.0,17,8,3.30,            55.7,19.4,26,28,12.11,            54.3,15.2,31,20,2.15,            65.1,73.0,19,9,2.84,            65.5,59.8,22,10,5.23,            65.0,55.1,14,3,4.52,            56.6,50.9,22,12,15.14,            57.4,54.1,20,6,4.20,            72.5,71.2,12,1,2.40,            74.2,58.1,14,8,5.23,            72.0,63.5,6,3,2.56,            60.5,60.8,16,10,7.72,            58.3,26.8,25,19,18.46,            65.4,49.5,15,8,6.10,            75.5,85.9,3,2,99.71,            69.3,84.9,7,6,99.68,            77.3,89.7,5,2,100.00,            70.5,78.2,12,6,98.96,            79.4,64.9,7,3,98.22,            65.0,75.9,9,9,99.06,            92.2,84.6,3,3,99.46,            79.3,63.1,13,13,96.83,            70.4,38.4,26,12,5.62,            65.7,7.7,29,11,13.79,            72.7,16.7,22,13,11.22,            64.4,17.6,35,32,16.92,            77.6,37.6,15,7,4.97,            67.6,18.7,25,7,8.65,            35.0,1.2,37,53,42.34,            44.7,46.6,16,29,50.43,            42.8,27.7,22,29,58.33        };    /**     * Test Longley dataset against R.     * Data Source: J. Longley (1967) "An Appraisal of Least Squares     * Programs for the Electronic Computer from the Point of View of the User"     * Journal of the American Statistical Association, vol. 62. September,     * pp. 819-841.     *     * Data are from NIST:     * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat     */    public void testLongly() {        RealMatrix matrix = createRealMatrix(longleyData, 16, 7);        RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();        double[] rData = new double[] {         12333921.73333333246, 3.679666000000000e+04, 343330206.333333313,         1649102.666666666744, 1117681.066666666651, 23461965.733333334, 16240.93333333333248,         36796.66000000000, 1.164576250000000e+02, 1063604.115416667,         6258.666250000000, 3490.253750000000, 73503.000000000, 50.92333333333334,         343330206.33333331347, 1.063604115416667e+06, 9879353659.329166412,         56124369.854166664183, 30880428.345833335072, 685240944.600000024, 470977.90000000002328,         1649102.66666666674, 6.258666250000000e+03, 56124369.854166664,         873223.429166666698, -115378.762499999997, 4462741.533333333, 2973.03333333333330,         1117681.06666666665, 3.490253750000000e+03, 30880428.345833335,         -115378.762499999997, 484304.095833333326, 1764098.133333333, 1382.43333333333339,         23461965.73333333433, 7.350300000000000e+04, 685240944.600000024,         4462741.533333333209, 1764098.133333333302, 48387348.933333330, 32917.40000000000146,         16240.93333333333, 5.092333333333334e+01, 470977.900000000,         2973.033333333333, 1382.433333333333, 32917.40000000, 22.66666666666667        };        TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 7, 7), covarianceMatrix, 10E-9);    }    /**     * Test R Swiss fertility dataset against R.     * Data Source: R datasets package     */    public void testSwissFertility() {         RealMatrix matrix = createRealMatrix(swissData, 47, 5);         RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();         double[] rData = new double[] {           156.0424976873265, 100.1691489361702, -64.36692876965772, -79.7295097132285, 241.5632030527289,           100.169148936170251, 515.7994172062905, -124.39283071230344, -139.6574005550416, 379.9043755781684,           -64.3669287696577, -124.3928307123034, 63.64662349676226, 53.5758556891767, -190.5606105457909,           -79.7295097132285, -139.6574005550416, 53.57585568917669, 92.4560592044403, -61.6988297872340,            241.5632030527289, 379.9043755781684, -190.56061054579092, -61.6988297872340, 1739.2945371877890         };         TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 5, 5), covarianceMatrix, 10E-13);    }    /**     * Constant column     */    public void testConstant() {        double[] noVariance = new double[] {1, 1, 1, 1};        double[] values = new double[] {1, 2, 3, 4};        assertEquals(0d, new Covariance().covariance(noVariance, values, true), Double.MIN_VALUE);        assertEquals(0d, new Covariance().covariance(noVariance, noVariance, true), Double.MIN_VALUE);    }    /**     * Insufficient data     */    public void testInsufficientData() {        double[] one = new double[] {1};        double[] two = new double[] {2};        try {            new Covariance().covariance(one, two, false);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }        RealMatrix matrix = new Array2DRowRealMatrix(new double[][] {{0},{1}});        try {            new Covariance(matrix);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // Expected        }    }    /**     * Verify that diagonal entries are consistent with Variance computation and matrix matches     * column-by-column covariances     */    public void testConsistency() {        final RealMatrix matrix = createRealMatrix(swissData, 47, 5);        final RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();        // Variances on the diagonal        Variance variance = new Variance();        for (int i = 0; i < 5; i++) {            assertEquals(variance.evaluate(matrix.getColumn(i)), covarianceMatrix.getEntry(i,i), 10E-14);        }        // Symmetry, column-consistency        assertEquals(covarianceMatrix.getEntry(2, 3),                new Covariance().covariance(matrix.getColumn(2), matrix.getColumn(3), true), 10E-14);        assertEquals(covarianceMatrix.getEntry(2, 3), covarianceMatrix.getEntry(3, 2), Double.MIN_VALUE);        // All columns same -> all entries = column variance        RealMatrix repeatedColumns = new Array2DRowRealMatrix(47, 3);        for (int i = 0; i < 3; i++) {            repeatedColumns.setColumnMatrix(i, matrix.getColumnMatrix(0));        }        RealMatrix repeatedCovarianceMatrix = new Covariance(repeatedColumns).getCovarianceMatrix();        double columnVariance = variance.evaluate(matrix.getColumn(0));        for (int i = 0; i < 3; i++) {            for (int j = 0; j < 3; j++) {                assertEquals(columnVariance, repeatedCovarianceMatrix.getEntry(i, j), 10E-14);            }        }        // Check bias-correction defaults        double[][] data = matrix.getData();        TestUtils.assertEquals("Covariances",                covarianceMatrix, new Covariance().computeCovarianceMatrix(data),Double.MIN_VALUE);        TestUtils.assertEquals("Covariances",                covarianceMatrix, new Covariance().computeCovarianceMatrix(data, true),Double.MIN_VALUE);        double[] x = data[0];        double[] y = data[1];        assertEquals(new Covariance().covariance(x, y),                new Covariance().covariance(x, y, true), Double.MIN_VALUE);    }    protected RealMatrix createRealMatrix(double[] data, int nRows, int nCols) {        double[][] matrixData = new double[nRows][nCols];        int ptr = 0;        for (int i = 0; i < nRows; i++) {            System.arraycopy(data, ptr, matrixData[i], 0, nCols);            ptr += nCols;        }        return new Array2DRowRealMatrix(matrixData);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.data;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.net.URL;import java.util.HashMap;import java.util.Map;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;import org.apache.commons.math.stat.descriptive.SummaryStatistics;/** * @version $Revision$ $Date$ */public abstract class CertifiedDataAbstractTest extends TestCase {    private DescriptiveStatistics descriptives;    private SummaryStatistics summaries;    private Map<String, Double> certifiedValues;    @Override    protected void setUp() throws Exception {        descriptives = new DescriptiveStatistics();        summaries = new SummaryStatistics();        certifiedValues = new HashMap<String, Double>();        loadData();    }    private void loadData() throws IOException {        BufferedReader in = null;        try {            URL resourceURL = getClass().getClassLoader().getResource(getResourceName());            in = new BufferedReader(new InputStreamReader(resourceURL.openStream()));            String line = in.readLine();            while (line != null) {                /* this call to StringUtils did little for the                 * following conditional structure                 */                line = line.trim();                // not empty line or comment                if (!("".equals(line) || line.startsWith("#"))) {                    int n = line.indexOf('=');                    if (n == -1) {                        // data value                        double value = Double.parseDouble(line);                        descriptives.addValue(value);                        summaries.addValue(value);                    } else {                        // certified value                        String name = line.substring(0, n).trim();                        String valueString = line.substring(n + 1).trim();                        Double value = Double.valueOf(valueString);                        certifiedValues.put(name, value);                    }                }                line = in.readLine();            }        } finally {            if (in != null) {                in.close();            }        }    }    protected abstract String getResourceName();    protected double getMaximumAbsoluteError() {        return 1.0e-5;    }    @Override    protected void tearDown() throws Exception {        descriptives.clear();        descriptives = null;        summaries.clear();        summaries = null;        certifiedValues.clear();        certifiedValues = null;    }    public void testCertifiedValues() {        for (String name : certifiedValues.keySet()) {            Double expectedValue = certifiedValues.get(name);            Double summariesValue = getProperty(summaries, name);            if (summariesValue != null) {                TestUtils.assertEquals("summary value for " + name + " is incorrect.",                                       summariesValue.doubleValue(), expectedValue.doubleValue(),                                       getMaximumAbsoluteError());            }            Double descriptivesValue = getProperty(descriptives, name);            if (descriptivesValue != null) {                TestUtils.assertEquals("descriptive value for " + name + " is incorrect.",                                       descriptivesValue.doubleValue(), expectedValue.doubleValue(),                                       getMaximumAbsoluteError());            }        }    }    protected Double getProperty(Object bean, String name) {        try {            // Get the value of prop            String prop = "get" + name.substring(0,1).toUpperCase() + name.substring(1);            Method meth = bean.getClass().getMethod(prop, new Class[0]);            Object property = meth.invoke(bean, new Object[0]);            if (meth.getReturnType().equals(Double.TYPE)) {                return (Double) property;            } else if (meth.getReturnType().equals(Long.TYPE)) {                return Double.valueOf(((Long) property).doubleValue());            } else {                fail("wrong type: " + meth.getReturnType().getName());            }        } catch (NoSuchMethodException nsme) {            // ignored        } catch (InvocationTargetException ite) {            fail(ite.getMessage());        } catch (IllegalAccessException iae) {            fail(iae.getMessage());        }        return null;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.data;/** * @version $Revision$ $Date$ */public class LotteryTest extends CertifiedDataAbstractTest {    @Override    protected String getResourceName() {        return "org/apache/commons/math/stat/data/Lottery.txt";    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.data;/** * @version $Revision$ $Date$ */public class LewTest extends CertifiedDataAbstractTest {    @Override    protected String getResourceName() {        return "org/apache/commons/math/stat/data/Lew.txt";    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.ranking;import org.apache.commons.math.TestUtils;import org.apache.commons.math.random.JDKRandomGenerator;import org.apache.commons.math.random.RandomGenerator;import junit.framework.TestCase;/** * Test cases for NaturalRanking class * * @since 2.0 * @version $Revision$ $Date$ */public class NaturalRankingTest extends TestCase {    private final double[] exampleData = { 20, 17, 30, 42.3, 17, 50,            Double.NaN, Double.NEGATIVE_INFINITY, 17 };    private final double[] tiesFirst = { 0, 0, 2, 1, 4 };    private final double[] tiesLast = { 4, 4, 1, 0 };    private final double[] multipleNaNs = { 0, 1, Double.NaN, Double.NaN };    private final double[] multipleTies = { 3, 2, 5, 5, 6, 6, 1 };    private final double[] allSame = { 0, 0, 0, 0 };    public NaturalRankingTest(String arg0) {        super(arg0);    }    @Override    protected void setUp() throws Exception {        super.setUp();    }    @Override    protected void tearDown() throws Exception {        super.tearDown();    }    public void testDefault() { // Ties averaged, NaNs maximal        NaturalRanking ranking = new NaturalRanking();        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 5, 3, 6, 7, 3, 8, 9, 1, 3 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 1.5, 1.5, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 3.5, 3.5, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 1, 2, 3.5, 3.5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 4.5, 4.5, 6.5, 6.5, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 2.5, 2.5, 2.5, 2.5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    public void testNaNsMaximalTiesMinimum() {        NaturalRanking ranking = new NaturalRanking(TiesStrategy.MINIMUM);        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 5, 2, 6, 7, 2, 8, 9, 1, 2 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 1, 1, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 3, 3, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 1, 2, 3, 3 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 4, 4, 6, 6, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 1, 1, 1, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    public void testNaNsRemovedTiesSequential() {        NaturalRanking ranking = new NaturalRanking(NaNStrategy.REMOVED,                TiesStrategy.SEQUENTIAL);        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 5, 2, 6, 7, 3, 8, 1, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 1, 2, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 3, 4, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 1, 2 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 4, 5, 6, 7, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 1, 2, 3, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    public void testNaNsMinimalTiesMaximum() {        NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL,                TiesStrategy.MAXIMUM);        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 6, 5, 7, 8, 5, 9, 2, 2, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 2, 2, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 4, 4, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 3, 4, 2, 2 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 5, 5, 7, 7, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 4, 4, 4, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    public void testNaNsMinimalTiesAverage() {        NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL);        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 6, 4, 7, 8, 4, 9, 1.5, 1.5, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 1.5, 1.5, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 3.5, 3.5, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 3, 4, 1.5, 1.5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 4.5, 4.5, 6.5, 6.5, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 2.5, 2.5, 2.5, 2.5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    public void testNaNsFixedTiesRandom() {        RandomGenerator randomGenerator = new JDKRandomGenerator();        randomGenerator.setSeed(1000);        NaturalRanking ranking = new NaturalRanking(NaNStrategy.FIXED,                randomGenerator);        double[] ranks = ranking.rank(exampleData);        double[] correctRanks = { 5, 4, 6, 7, 3, 8, Double.NaN, 1, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesFirst);        correctRanks = new double[] { 1, 1, 4, 3, 5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(tiesLast);        correctRanks = new double[] { 3, 4, 2, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleNaNs);        correctRanks = new double[] { 1, 2, Double.NaN, Double.NaN };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(multipleTies);        correctRanks = new double[] { 3, 2, 5, 5, 7, 6, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranks = ranking.rank(allSame);        correctRanks = new double[] { 1, 3, 4, 4 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }    public void testNaNsAndInfs() {        double[] data = { 0, Double.POSITIVE_INFINITY, Double.NaN,                Double.NEGATIVE_INFINITY };        NaturalRanking ranking = new NaturalRanking(NaNStrategy.MAXIMAL);        double[] ranks = ranking.rank(data);        double[] correctRanks = new double[] { 2, 3.5, 3.5, 1 };        TestUtils.assertEquals(correctRanks, ranks, 0d);        ranking = new NaturalRanking(NaNStrategy.MINIMAL);        ranks = ranking.rank(data);        correctRanks = new double[] { 3, 4, 1.5, 1.5 };        TestUtils.assertEquals(correctRanks, ranks, 0d);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat;import java.io.BufferedReader;import java.io.InputStreamReader;import junit.framework.TestCase;import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;import org.apache.commons.math.stat.descriptive.SummaryStatistics;/** * Certified data test cases. * @version $Revision$ $Date$ */public class CertifiedDataTest extends TestCase  {    protected double mean = Double.NaN;    protected double std = Double.NaN;    /**     * Certified Data Test Constructor     * @param name     */    public CertifiedDataTest(String name) {        super(name);    }    /**     * Test SummaryStatistics - implementations that do not store the data     * and use single pass algorithms to compute statistics    */    public void testSummaryStatistics() throws Exception {        SummaryStatistics u = new SummaryStatistics();        loadStats("data/PiDigits.txt", u);        assertEquals("PiDigits: std", std, u.getStandardDeviation(), 1E-13);        assertEquals("PiDigits: mean", mean, u.getMean(), 1E-13);        loadStats("data/Mavro.txt", u);        assertEquals("Mavro: std", std, u.getStandardDeviation(), 1E-14);        assertEquals("Mavro: mean", mean, u.getMean(), 1E-14);        loadStats("data/Michelso.txt", u);        assertEquals("Michelso: std", std, u.getStandardDeviation(), 1E-13);        assertEquals("Michelso: mean", mean, u.getMean(), 1E-13);        loadStats("data/NumAcc1.txt", u);        assertEquals("NumAcc1: std", std, u.getStandardDeviation(), 1E-14);        assertEquals("NumAcc1: mean", mean, u.getMean(), 1E-14);        loadStats("data/NumAcc2.txt", u);        assertEquals("NumAcc2: std", std, u.getStandardDeviation(), 1E-14);        assertEquals("NumAcc2: mean", mean, u.getMean(), 1E-14);    }    /**     * Test DescriptiveStatistics - implementations that store full array of     * values and execute multi-pass algorithms     */    public void testDescriptiveStatistics() throws Exception {        DescriptiveStatistics u = new DescriptiveStatistics();        loadStats("data/PiDigits.txt", u);        assertEquals("PiDigits: std", std, u.getStandardDeviation(), 1E-14);        assertEquals("PiDigits: mean", mean, u.getMean(), 1E-14);        loadStats("data/Mavro.txt", u);        assertEquals("Mavro: std", std, u.getStandardDeviation(), 1E-14);        assertEquals("Mavro: mean", mean, u.getMean(), 1E-14);        loadStats("data/Michelso.txt", u);        assertEquals("Michelso: std", std, u.getStandardDeviation(), 1E-14);        assertEquals("Michelso: mean", mean, u.getMean(), 1E-14);        loadStats("data/NumAcc1.txt", u);        assertEquals("NumAcc1: std", std, u.getStandardDeviation(), 1E-14);        assertEquals("NumAcc1: mean", mean, u.getMean(), 1E-14);        loadStats("data/NumAcc2.txt", u);        assertEquals("NumAcc2: std", std, u.getStandardDeviation(), 1E-14);        assertEquals("NumAcc2: mean", mean, u.getMean(), 1E-14);    }    /**     * loads a DescriptiveStatistics off of a test file     * @param file     * @param statistical summary     */    private void loadStats(String resource, Object u) throws Exception {        DescriptiveStatistics d = null;        SummaryStatistics s = null;        if (u instanceof DescriptiveStatistics) {            d = (DescriptiveStatistics) u;        } else {            s = (SummaryStatistics) u;        }        u.getClass().getDeclaredMethod(                "clear", new Class[]{}).invoke(u, new Object[]{});        mean = Double.NaN;        std = Double.NaN;        BufferedReader in =            new BufferedReader(                    new InputStreamReader(                            CertifiedDataTest.class.getResourceAsStream(resource)));        String line = null;        for (int j = 0; j < 60; j++) {            line = in.readLine();            if (j == 40) {                mean =                    Double.parseDouble(                            line.substring(line.lastIndexOf(":") + 1).trim());            }            if (j == 41) {                std =                    Double.parseDouble(                            line.substring(line.lastIndexOf(":") + 1).trim());            }        }        line = in.readLine();        while (line != null) {            if (d != null) {                d.addValue(Double.parseDouble(line.trim()));            }  else {                s.addValue(Double.parseDouble(line.trim()));            }            line = in.readLine();        }        in.close();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat;import java.io.BufferedReader;import java.io.IOException;import java.io.StringReader;import java.util.Iterator;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;/** * Test cases for the {@link Frequency} class. * * @version $Revision$ $Date$ */public final class FrequencyTest extends TestCase {    private long oneL = 1;    private long twoL = 2;    private long threeL = 3;    private int oneI = 1;    private int twoI = 2;    private int threeI=3;    private double tolerance = 10E-15;    private Frequency f = null;    public FrequencyTest(String name) {        super(name);    }    @Override    public void setUp() {        f = new Frequency();    }    /** test freq counts */    @SuppressWarnings("deprecation")    public void testCounts() {        assertEquals("total count",0,f.getSumFreq());        f.addValue(oneL);        f.addValue(twoL);        f.addValue(1);        f.addValue(oneI);        assertEquals("one frequency count",3,f.getCount(1));        assertEquals("two frequency count",1,f.getCount(2));        assertEquals("three frequency count",0,f.getCount(3));        assertEquals("total count",4,f.getSumFreq());        assertEquals("zero cumulative frequency", 0, f.getCumFreq(0));        assertEquals("one cumulative frequency", 3,  f.getCumFreq(1));        assertEquals("two cumulative frequency", 4,  f.getCumFreq(2));        assertEquals("Integer argument cum freq",4, f.getCumFreq(Integer.valueOf(2)));        assertEquals("five cumulative frequency", 4,  f.getCumFreq(5));        assertEquals("foo cumulative frequency", 0,  f.getCumFreq("foo"));        f.clear();        assertEquals("total count",0,f.getSumFreq());        // userguide examples -------------------------------------------------------------------        f.addValue("one");        f.addValue("One");        f.addValue("oNe");        f.addValue("Z");        assertEquals("one cumulative frequency", 1 ,  f.getCount("one"));        assertEquals("Z cumulative pct", 0.5,  f.getCumPct("Z"), tolerance);        assertEquals("z cumulative pct", 1.0,  f.getCumPct("z"), tolerance);        assertEquals("Ot cumulative pct", 0.25,  f.getCumPct("Ot"), tolerance);        f.clear();        f = null;        Frequency f = new Frequency();        f.addValue(1);        f.addValue(Integer.valueOf(1));        f.addValue(Long.valueOf(1));        f.addValue(2);        f.addValue(Integer.valueOf(-1));        assertEquals("1 count", 3, f.getCount(1));        assertEquals("1 count", 3, f.getCount(Integer.valueOf(1)));        assertEquals("0 cum pct", 0.2, f.getCumPct(0), tolerance);        assertEquals("1 pct", 0.6, f.getPct(Integer.valueOf(1)), tolerance);        assertEquals("-2 cum pct", 0, f.getCumPct(-2), tolerance);        assertEquals("10 cum pct", 1, f.getCumPct(10), tolerance);        f = null;        f = new Frequency(String.CASE_INSENSITIVE_ORDER);        f.addValue("one");        f.addValue("One");        f.addValue("oNe");        f.addValue("Z");        assertEquals("one count", 3 ,  f.getCount("one"));        assertEquals("Z cumulative pct -- case insensitive", 1 ,  f.getCumPct("Z"), tolerance);        assertEquals("z cumulative pct -- case insensitive", 1 ,  f.getCumPct("z"), tolerance);        f = null;        f = new Frequency();        assertEquals(0L, f.getCount('a'));        assertEquals(0L, f.getCumFreq('b'));        TestUtils.assertEquals(Double.NaN, f.getPct('a'), 0.0);        TestUtils.assertEquals(Double.NaN, f.getCumPct('b'), 0.0);        f.addValue('a');        f.addValue('b');        f.addValue('c');        f.addValue('d');        assertEquals(1L, f.getCount('a'));        assertEquals(2L, f.getCumFreq('b'));        assertEquals(0.25, f.getPct('a'), 0.0);        assertEquals(0.5, f.getCumPct('b'), 0.0);        assertEquals(1.0, f.getCumPct('e'), 0.0);    }    /** test pcts */    @SuppressWarnings("deprecation")    public void testPcts() {        f.addValue(oneL);        f.addValue(twoL);        f.addValue(oneI);        f.addValue(twoI);        f.addValue(threeL);        f.addValue(threeL);        f.addValue(3);        f.addValue(threeI);        assertEquals("one pct",0.25,f.getPct(1),tolerance);        assertEquals("two pct",0.25,f.getPct(Long.valueOf(2)),tolerance);        assertEquals("three pct",0.5,f.getPct(threeL),tolerance);        // MATH-329        assertEquals("three (Object) pct",0.5,f.getPct((Object) (Integer.valueOf(3))),tolerance);        assertEquals("five pct",0,f.getPct(5),tolerance);        assertEquals("foo pct",0,f.getPct("foo"),tolerance);        assertEquals("one cum pct",0.25,f.getCumPct(1),tolerance);        assertEquals("two cum pct",0.50,f.getCumPct(Long.valueOf(2)),tolerance);        assertEquals("Integer argument",0.50,f.getCumPct(Integer.valueOf(2)),tolerance);        assertEquals("three cum pct",1.0,f.getCumPct(threeL),tolerance);        assertEquals("five cum pct",1.0,f.getCumPct(5),tolerance);        assertEquals("zero cum pct",0.0,f.getCumPct(0),tolerance);        assertEquals("foo cum pct",0,f.getCumPct("foo"),tolerance);    }    /** test adding incomparable values */    @SuppressWarnings("deprecation")    public void testAdd() {        char aChar = 'a';        char bChar = 'b';        String aString = "a";        f.addValue(aChar);        f.addValue(bChar);        try {            f.addValue(aString);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            f.addValue(2);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        assertEquals("a pct",0.5,f.getPct(aChar),tolerance);        assertEquals("b cum pct",1.0,f.getCumPct(bChar),tolerance);        assertEquals("a string pct",0.0,f.getPct(aString),tolerance);        assertEquals("a string cum pct",0.0,f.getCumPct(aString),tolerance);        f = new Frequency();        f.addValue("One");        try {            f.addValue(new Integer("One"));            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }    // Check what happens when non-Comparable objects are added    @SuppressWarnings("deprecation")    public void testAddNonComparable(){        try {            f.addValue(new Object()); // This was previously OK            fail("Expected IllegalArgumentException");        } catch (IllegalArgumentException expected) {        }        f.clear();        f.addValue(1);        try {            f.addValue(new Object());            fail("Expected IllegalArgumentException");        } catch (IllegalArgumentException expected) {        }    }    /** test empty table */    public void testEmptyTable() {        assertEquals("freq sum, empty table", 0, f.getSumFreq());        assertEquals("count, empty table", 0, f.getCount(0));        assertEquals("count, empty table",0, f.getCount(Integer.valueOf(0)));        assertEquals("cum freq, empty table", 0, f.getCumFreq(0));        assertEquals("cum freq, empty table", 0, f.getCumFreq("x"));        assertTrue("pct, empty table", Double.isNaN(f.getPct(0)));        assertTrue("pct, empty table", Double.isNaN(f.getPct(Integer.valueOf(0))));        assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(0)));        assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(Integer.valueOf(0))));    }    /**     * Tests toString()     */    public void testToString(){        f.addValue(oneL);        f.addValue(twoL);        f.addValue(oneI);        f.addValue(twoI);        String s = f.toString();        //System.out.println(s);        assertNotNull(s);        BufferedReader reader = new BufferedReader(new StringReader(s));        try {            String line = reader.readLine(); // header line            assertNotNull(line);            line = reader.readLine(); // one's or two's line            assertNotNull(line);            line = reader.readLine(); // one's or two's line            assertNotNull(line);            line = reader.readLine(); // no more elements            assertNull(line);        } catch(IOException ex){            fail(ex.getMessage());        }    }    @SuppressWarnings("deprecation")    public void testIntegerValues() {        Comparable<?> obj1 = null;        obj1 = Integer.valueOf(1);        Integer int1 = Integer.valueOf(1);        f.addValue(obj1);        f.addValue(int1);        f.addValue(2);        f.addValue(Long.valueOf(2));        assertEquals("Integer 1 count", 2, f.getCount(1));        assertEquals("Integer 1 count", 2, f.getCount(Integer.valueOf(1)));        assertEquals("Integer 1 count", 2, f.getCount(Long.valueOf(1)));        assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(1), tolerance);        assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(Long.valueOf(1)), tolerance);        assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(Integer.valueOf(1)), tolerance);        Iterator<?> it = f.valuesIterator();        while (it.hasNext()) {            assertTrue(it.next() instanceof Long);        }    }    public void testSerial() {        f.addValue(oneL);        f.addValue(twoL);        f.addValue(oneI);        f.addValue(twoI);        assertEquals(f, TestUtils.serializeAndRecover(f));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;/** * Test cases for the {@link StatUtils} class. * @version $Revision$ $Date$ */public final class StatUtilsTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double min = 1;    private double max = 3;    private double tolerance = 10E-15;    private double nan = Double.NaN;    public StatUtilsTest(String name) {        super(name);    }    /** test stats */    public void testStats() {        double[] values = new double[] { one, two, two, three };        assertEquals("sum", sum, StatUtils.sum(values), tolerance);        assertEquals("sumsq", sumSq, StatUtils.sumSq(values), tolerance);        assertEquals("var", var, StatUtils.variance(values), tolerance);        assertEquals("var with mean", var, StatUtils.variance(values, mean), tolerance);        assertEquals("mean", mean, StatUtils.mean(values), tolerance);        assertEquals("min", min, StatUtils.min(values), tolerance);        assertEquals("max", max, StatUtils.max(values), tolerance);    }    public void testN0andN1Conditions() throws Exception {        double[] values = new double[0];        assertTrue(            "Mean of n = 0 set should be NaN",            Double.isNaN(StatUtils.mean(values)));        assertTrue(            "Variance of n = 0 set should be NaN",            Double.isNaN(StatUtils.variance(values)));        values = new double[] { one };        assertTrue(            "Mean of n = 1 set should be value of single item n1",            StatUtils.mean(values) == one);        assertTrue(            "Variance of n = 1 set should be zero",            StatUtils.variance(values) == 0);    }    public void testArrayIndexConditions() throws Exception {        double[] values = { 1.0, 2.0, 3.0, 4.0 };        assertEquals(            "Sum not expected",            5.0,            StatUtils.sum(values, 1, 2),            Double.MIN_VALUE);        assertEquals(            "Sum not expected",            3.0,            StatUtils.sum(values, 0, 2),            Double.MIN_VALUE);        assertEquals(            "Sum not expected",            7.0,            StatUtils.sum(values, 2, 2),            Double.MIN_VALUE);        try {            StatUtils.sum(values, 2, 3);            assertTrue("Didn't throw exception", false);        } catch (Exception e) {            assertTrue(true);        }        try {            StatUtils.sum(values, -1, 2);            assertTrue("Didn't throw exception", false);        } catch (Exception e) {            assertTrue(true);        }    }    public void testSumSq() {        double[] x = null;        // test null        try {            StatUtils.sumSq(x);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }        try {            StatUtils.sumSq(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }        // test empty        x = new double[] {};        TestUtils.assertEquals(0, StatUtils.sumSq(x), tolerance);        TestUtils.assertEquals(0, StatUtils.sumSq(x, 0, 0), tolerance);        // test one        x = new double[] {two};        TestUtils.assertEquals(4, StatUtils.sumSq(x), tolerance);        TestUtils.assertEquals(4, StatUtils.sumSq(x, 0, 1), tolerance);        // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(18, StatUtils.sumSq(x), tolerance);        TestUtils.assertEquals(8, StatUtils.sumSq(x, 1, 2), tolerance);    }    public void testProduct() {        double[] x = null;        // test null        try {            StatUtils.product(x);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }        try {            StatUtils.product(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }        // test empty        x = new double[] {};        TestUtils.assertEquals(1, StatUtils.product(x), tolerance);        TestUtils.assertEquals(1, StatUtils.product(x, 0, 0), tolerance);        // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.product(x), tolerance);        TestUtils.assertEquals(two, StatUtils.product(x, 0, 1), tolerance);        // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(12, StatUtils.product(x), tolerance);        TestUtils.assertEquals(4, StatUtils.product(x, 1, 2), tolerance);    }    public void testSumLog() {        double[] x = null;        // test null        try {            StatUtils.sumLog(x);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }        try {            StatUtils.sumLog(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }        // test empty        x = new double[] {};        TestUtils.assertEquals(0, StatUtils.sumLog(x), tolerance);        TestUtils.assertEquals(0, StatUtils.sumLog(x, 0, 0), tolerance);        // test one        x = new double[] {two};        TestUtils.assertEquals(FastMath.log(two), StatUtils.sumLog(x), tolerance);        TestUtils.assertEquals(FastMath.log(two), StatUtils.sumLog(x, 0, 1), tolerance);        // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(FastMath.log(one) + 2.0 * FastMath.log(two) + FastMath.log(three), StatUtils.sumLog(x), tolerance);        TestUtils.assertEquals(2.0 * FastMath.log(two), StatUtils.sumLog(x, 1, 2), tolerance);    }    public void testMean() {        double[] x = null;        try {            StatUtils.mean(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }        // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.mean(x, 0, 0), tolerance);        // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.mean(x, 0, 1), tolerance);        // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(2.5, StatUtils.mean(x, 2, 2), tolerance);    }    public void testVariance() {        double[] x = null;        try {            StatUtils.variance(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }        // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.variance(x, 0, 0), tolerance);        // test one        x = new double[] {two};        TestUtils.assertEquals(0.0, StatUtils.variance(x, 0, 1), tolerance);        // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(0.5, StatUtils.variance(x, 2, 2), tolerance);        // test precomputed mean        x = new double[] {one, two, two, three};        TestUtils.assertEquals(0.5, StatUtils.variance(x,2.5, 2, 2), tolerance);    }    public void testMax() {        double[] x = null;        try {            StatUtils.max(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }        // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.max(x, 0, 0), tolerance);        // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.max(x, 0, 1), tolerance);        // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(three, StatUtils.max(x, 1, 3), tolerance);        // test first nan is ignored        x = new double[] {nan, two, three};        TestUtils.assertEquals(three, StatUtils.max(x), tolerance);        // test middle nan is ignored        x = new double[] {one, nan, three};        TestUtils.assertEquals(three, StatUtils.max(x), tolerance);        // test last nan is ignored        x = new double[] {one, two, nan};        TestUtils.assertEquals(two, StatUtils.max(x), tolerance);        // test all nan returns nan        x = new double[] {nan, nan, nan};        TestUtils.assertEquals(nan, StatUtils.max(x), tolerance);    }    public void testMin() {        double[] x = null;        try {            StatUtils.min(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }        // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.min(x, 0, 0), tolerance);        // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.min(x, 0, 1), tolerance);        // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(two, StatUtils.min(x, 1, 3), tolerance);        // test first nan is ignored        x = new double[] {nan, two, three};        TestUtils.assertEquals(two, StatUtils.min(x), tolerance);        // test middle nan is ignored        x = new double[] {one, nan, three};        TestUtils.assertEquals(one, StatUtils.min(x), tolerance);        // test last nan is ignored        x = new double[] {one, two, nan};        TestUtils.assertEquals(one, StatUtils.min(x), tolerance);        // test all nan returns nan        x = new double[] {nan, nan, nan};        TestUtils.assertEquals(nan, StatUtils.min(x), tolerance);    }    public void testPercentile() {        double[] x = null;        // test null        try {            StatUtils.percentile(x, .25);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }        try {            StatUtils.percentile(x, 0, 4, 0.25);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }        // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 25), tolerance);        TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 0, 0, 25), tolerance);        // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.percentile(x, 25), tolerance);        TestUtils.assertEquals(two, StatUtils.percentile(x, 0, 1, 25), tolerance);        // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(2.5, StatUtils.percentile(x, 70), tolerance);        TestUtils.assertEquals(2.5, StatUtils.percentile(x, 1, 3, 62.5), tolerance);    }    public void testDifferenceStats() throws Exception {        double sample1[] = {1d, 2d, 3d, 4d};        double sample2[] = {1d, 3d, 4d, 2d};        double diff[] = {0d, -1d, -1d, 2d};        double small[] = {1d, 4d};        double meanDifference = StatUtils.meanDifference(sample1, sample2);        assertEquals(StatUtils.sumDifference(sample1, sample2), StatUtils.sum(diff), tolerance);        assertEquals(meanDifference, StatUtils.mean(diff), tolerance);        assertEquals(StatUtils.varianceDifference(sample1, sample2, meanDifference),                StatUtils.variance(diff), tolerance);        try {            StatUtils.meanDifference(sample1, small);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            StatUtils.varianceDifference(sample1, small, meanDifference);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            double[] single = {1.0};            StatUtils.varianceDifference(single, single, meanDifference);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testGeometricMean() throws Exception {        double[] test = null;        try {            StatUtils.geometricMean(test);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        test = new double[] {2, 4, 6, 8};        assertEquals(FastMath.exp(0.25d * StatUtils.sumLog(test)),                StatUtils.geometricMean(test), Double.MIN_VALUE);        assertEquals(FastMath.exp(0.5 * StatUtils.sumLog(test, 0, 2)),                StatUtils.geometricMean(test, 0, 2), Double.MIN_VALUE);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry;import org.apache.commons.math.geometry.CardanEulerSingularityException;import org.apache.commons.math.geometry.NotARotationMatrixException;import org.apache.commons.math.geometry.Rotation;import org.apache.commons.math.geometry.RotationOrder;import org.apache.commons.math.geometry.Vector3D;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.util.MathUtils;import junit.framework.*;public class RotationTest  extends TestCase {  public RotationTest(String name) {    super(name);  }  public void testIdentity() {    Rotation r = Rotation.IDENTITY;    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);    checkAngle(r.getAngle(), 0);    r = new Rotation(-1, 0, 0, 0, false);    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);    checkAngle(r.getAngle(), 0);    r = new Rotation(42, 0, 0, 0, true);    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);    checkAngle(r.getAngle(), 0);  }  public void testAxisAngle() {    Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * FastMath.PI / 3);    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_J);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_K);    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_I);    double s = 1 / FastMath.sqrt(3);    checkVector(r.getAxis(), new Vector3D(s, s, s));    checkAngle(r.getAngle(), 2 * FastMath.PI / 3);    try {      new Rotation(new Vector3D(0, 0, 0), 2 * FastMath.PI / 3);      fail("an exception should have been thrown");    } catch (ArithmeticException e) {    } catch (Exception e) {      fail("unexpected exception");    }    r = new Rotation(Vector3D.PLUS_K, 1.5 * FastMath.PI);    checkVector(r.getAxis(), new Vector3D(0, 0, -1));    checkAngle(r.getAngle(), 0.5 * FastMath.PI);    r = new Rotation(Vector3D.PLUS_J, FastMath.PI);    checkVector(r.getAxis(), Vector3D.PLUS_J);    checkAngle(r.getAngle(), FastMath.PI);    checkVector(Rotation.IDENTITY.getAxis(), Vector3D.PLUS_I);  }  public void testRevert() {    Rotation r = new Rotation(0.001, 0.36, 0.48, 0.8, true);    Rotation reverted = r.revert();    checkRotation(r.applyTo(reverted), 1, 0, 0, 0);    checkRotation(reverted.applyTo(r), 1, 0, 0, 0);    assertEquals(r.getAngle(), reverted.getAngle(), 1.0e-12);    assertEquals(-1, Vector3D.dotProduct(r.getAxis(), reverted.getAxis()), 1.0e-12);  }  public void testVectorOnePair() {    Vector3D u = new Vector3D(3, 2, 1);    Vector3D v = new Vector3D(-4, 2, 2);    Rotation r = new Rotation(u, v);    checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm()));    checkAngle(new Rotation(u, u.negate()).getAngle(), FastMath.PI);    try {        new Rotation(u, Vector3D.ZERO);        fail("an exception should have been thrown");      } catch (IllegalArgumentException e) {        // expected behavior      } catch (Exception e) {        fail("unexpected exception");    }  }  public void testVectorTwoPairs() {    Vector3D u1 = new Vector3D(3, 0, 0);    Vector3D u2 = new Vector3D(0, 5, 0);    Vector3D v1 = new Vector3D(0, 0, 2);    Vector3D v2 = new Vector3D(-2, 0, 2);    Rotation r = new Rotation(u1, u2, v1, v2);    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.MINUS_I);    r = new Rotation(u1, u2, u1.negate(), u2.negate());    Vector3D axis = r.getAxis();    if (Vector3D.dotProduct(axis, Vector3D.PLUS_K) > 0) {      checkVector(axis, Vector3D.PLUS_K);    } else {      checkVector(axis, Vector3D.MINUS_K);    }    checkAngle(r.getAngle(), FastMath.PI);    double sqrt = FastMath.sqrt(2) / 2;    r = new Rotation(Vector3D.PLUS_I,  Vector3D.PLUS_J,                     new Vector3D(0.5, 0.5,  sqrt),                     new Vector3D(0.5, 0.5, -sqrt));    checkRotation(r, sqrt, 0.5, 0.5, 0);    r = new Rotation(u1, u2, u1, Vector3D.crossProduct(u1, u2));    checkRotation(r, sqrt, -sqrt, 0, 0);    checkRotation(new Rotation(u1, u2, u1, u2), 1, 0, 0, 0);    try {        new Rotation(u1, u2, Vector3D.ZERO, v2);        fail("an exception should have been thrown");    } catch (IllegalArgumentException e) {      // expected behavior    } catch (Exception e) {        fail("unexpected exception");    }  }  public void testMatrix()    throws NotARotationMatrixException {    try {      new Rotation(new double[][] {                     { 0.0, 1.0, 0.0 },                     { 1.0, 0.0, 0.0 }                   }, 1.0e-7);    } catch (NotARotationMatrixException nrme) {      // expected behavior    } catch (Exception e) {      fail("wrong exception caught: " + e.getMessage());    }    try {      new Rotation(new double[][] {                     {  0.445888,  0.797184, -0.407040 },                     {  0.821760, -0.184320,  0.539200 },                     { -0.354816,  0.574912,  0.737280 }                   }, 1.0e-7);    } catch (NotARotationMatrixException nrme) {      // expected behavior    } catch (Exception e) {      fail("wrong exception caught: " + e.getMessage());    }    try {        new Rotation(new double[][] {                       {  0.4,  0.8, -0.4 },                       { -0.4,  0.6,  0.7 },                       {  0.8, -0.2,  0.5 }                     }, 1.0e-15);      } catch (NotARotationMatrixException nrme) {        // expected behavior      } catch (Exception e) {        fail("wrong exception caught: " + e.getMessage());      }    checkRotation(new Rotation(new double[][] {                                 {  0.445888,  0.797184, -0.407040 },                                 { -0.354816,  0.574912,  0.737280 },                                 {  0.821760, -0.184320,  0.539200 }                               }, 1.0e-10),                  0.8, 0.288, 0.384, 0.36);    checkRotation(new Rotation(new double[][] {                                 {  0.539200,  0.737280,  0.407040 },                                 {  0.184320, -0.574912,  0.797184 },                                 {  0.821760, -0.354816, -0.445888 }                              }, 1.0e-10),                  0.36, 0.8, 0.288, 0.384);    checkRotation(new Rotation(new double[][] {                                 { -0.445888,  0.797184, -0.407040 },                                 {  0.354816,  0.574912,  0.737280 },                                 {  0.821760,  0.184320, -0.539200 }                               }, 1.0e-10),                  0.384, 0.36, 0.8, 0.288);    checkRotation(new Rotation(new double[][] {                                 { -0.539200,  0.737280,  0.407040 },                                 { -0.184320, -0.574912,  0.797184 },                                 {  0.821760,  0.354816,  0.445888 }                               }, 1.0e-10),                  0.288, 0.384, 0.36, 0.8);    double[][] m1 = { { 0.0, 1.0, 0.0 },                      { 0.0, 0.0, 1.0 },                      { 1.0, 0.0, 0.0 } };    Rotation r = new Rotation(m1, 1.0e-7);    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_I);    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_J);    double[][] m2 = { { 0.83203, -0.55012, -0.07139 },                      { 0.48293,  0.78164, -0.39474 },                      { 0.27296,  0.29396,  0.91602 } };    r = new Rotation(m2, 1.0e-12);    double[][] m3 = r.getMatrix();    double d00 = m2[0][0] - m3[0][0];    double d01 = m2[0][1] - m3[0][1];    double d02 = m2[0][2] - m3[0][2];    double d10 = m2[1][0] - m3[1][0];    double d11 = m2[1][1] - m3[1][1];    double d12 = m2[1][2] - m3[1][2];    double d20 = m2[2][0] - m3[2][0];    double d21 = m2[2][1] - m3[2][1];    double d22 = m2[2][2] - m3[2][2];    assertTrue(FastMath.abs(d00) < 6.0e-6);    assertTrue(FastMath.abs(d01) < 6.0e-6);    assertTrue(FastMath.abs(d02) < 6.0e-6);    assertTrue(FastMath.abs(d10) < 6.0e-6);    assertTrue(FastMath.abs(d11) < 6.0e-6);    assertTrue(FastMath.abs(d12) < 6.0e-6);    assertTrue(FastMath.abs(d20) < 6.0e-6);    assertTrue(FastMath.abs(d21) < 6.0e-6);    assertTrue(FastMath.abs(d22) < 6.0e-6);    assertTrue(FastMath.abs(d00) > 4.0e-7);    assertTrue(FastMath.abs(d01) > 4.0e-7);    assertTrue(FastMath.abs(d02) > 4.0e-7);    assertTrue(FastMath.abs(d10) > 4.0e-7);    assertTrue(FastMath.abs(d11) > 4.0e-7);    assertTrue(FastMath.abs(d12) > 4.0e-7);    assertTrue(FastMath.abs(d20) > 4.0e-7);    assertTrue(FastMath.abs(d21) > 4.0e-7);    assertTrue(FastMath.abs(d22) > 4.0e-7);    for (int i = 0; i < 3; ++i) {      for (int j = 0; j < 3; ++j) {        double m3tm3 = m3[i][0] * m3[j][0]                     + m3[i][1] * m3[j][1]                     + m3[i][2] * m3[j][2];        if (i == j) {          assertTrue(FastMath.abs(m3tm3 - 1.0) < 1.0e-10);        } else {          assertTrue(FastMath.abs(m3tm3) < 1.0e-10);        }      }    }    checkVector(r.applyTo(Vector3D.PLUS_I),                new Vector3D(m3[0][0], m3[1][0], m3[2][0]));    checkVector(r.applyTo(Vector3D.PLUS_J),                new Vector3D(m3[0][1], m3[1][1], m3[2][1]));    checkVector(r.applyTo(Vector3D.PLUS_K),                new Vector3D(m3[0][2], m3[1][2], m3[2][2]));    double[][] m4 = { { 1.0,  0.0,  0.0 },                      { 0.0, -1.0,  0.0 },                      { 0.0,  0.0, -1.0 } };    r = new Rotation(m4, 1.0e-7);    checkAngle(r.getAngle(), FastMath.PI);    try {      double[][] m5 = { { 0.0, 0.0, 1.0 },                        { 0.0, 1.0, 0.0 },                        { 1.0, 0.0, 0.0 } };      r = new Rotation(m5, 1.0e-7);      fail("got " + r + ", should have caught an exception");    } catch (NotARotationMatrixException e) {      // expected    } catch (Exception e) {      fail("wrong exception caught");    }  }  public void testAngles()    throws CardanEulerSingularityException {    RotationOrder[] CardanOrders = {      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX    };    for (int i = 0; i < CardanOrders.length; ++i) {      for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {        for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) {          for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {            Rotation r = new Rotation(CardanOrders[i], alpha1, alpha2, alpha3);            double[] angles = r.getAngles(CardanOrders[i]);            checkAngle(angles[0], alpha1);            checkAngle(angles[1], alpha2);            checkAngle(angles[2], alpha3);          }        }      }    }    RotationOrder[] EulerOrders = {            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ          };    for (int i = 0; i < EulerOrders.length; ++i) {      for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {        for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.3) {          for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {            Rotation r = new Rotation(EulerOrders[i],                                      alpha1, alpha2, alpha3);            double[] angles = r.getAngles(EulerOrders[i]);            checkAngle(angles[0], alpha1);            checkAngle(angles[1], alpha2);            checkAngle(angles[2], alpha3);          }        }      }    }  }  public void testSingularities() {    RotationOrder[] CardanOrders = {      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX    };    double[] singularCardanAngle = { FastMath.PI / 2, -FastMath.PI / 2 };    for (int i = 0; i < CardanOrders.length; ++i) {      for (int j = 0; j < singularCardanAngle.length; ++j) {        Rotation r = new Rotation(CardanOrders[i], 0.1, singularCardanAngle[j], 0.3);        try {          r.getAngles(CardanOrders[i]);          fail("an exception should have been caught");        } catch (CardanEulerSingularityException cese) {          // expected behavior        } catch (Exception e) {          fail("wrong exception caught: " + e.getMessage());        }      }    }    RotationOrder[] EulerOrders = {            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ          };    double[] singularEulerAngle = { 0, FastMath.PI };    for (int i = 0; i < EulerOrders.length; ++i) {      for (int j = 0; j < singularEulerAngle.length; ++j) {        Rotation r = new Rotation(EulerOrders[i], 0.1, singularEulerAngle[j], 0.3);        try {          r.getAngles(EulerOrders[i]);          fail("an exception should have been caught");        } catch (CardanEulerSingularityException cese) {          // expected behavior        } catch (Exception e) {          fail("wrong exception caught: " + e.getMessage());        }      }    }  }  public void testQuaternion() {    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);    double n = 23.5;    Rotation r2 = new Rotation(n * r1.getQ0(), n * r1.getQ1(),                               n * r1.getQ2(), n * r1.getQ3(),                               true);    for (double x = -0.9; x < 0.9; x += 0.2) {      for (double y = -0.9; y < 0.9; y += 0.2) {        for (double z = -0.9; z < 0.9; z += 0.2) {          Vector3D u = new Vector3D(x, y, z);          checkVector(r2.applyTo(u), r1.applyTo(u));        }      }    }    r1 = new Rotation( 0.288,  0.384,  0.36,  0.8, false);    checkRotation(r1, -r1.getQ0(), -r1.getQ1(), -r1.getQ2(), -r1.getQ3());  }  public void testCompose() {    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);    Rotation r3 = r2.applyTo(r1);    for (double x = -0.9; x < 0.9; x += 0.2) {      for (double y = -0.9; y < 0.9; y += 0.2) {        for (double z = -0.9; z < 0.9; z += 0.2) {          Vector3D u = new Vector3D(x, y, z);          checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));        }      }    }  }  public void testComposeInverse() {    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);    Rotation r3 = r2.applyInverseTo(r1);    for (double x = -0.9; x < 0.9; x += 0.2) {      for (double y = -0.9; y < 0.9; y += 0.2) {        for (double z = -0.9; z < 0.9; z += 0.2) {          Vector3D u = new Vector3D(x, y, z);          checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));        }      }    }  }  public void testApplyInverseTo() {    Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7);    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {      for (double phi = -1.55; phi < 1.55; phi += 0.2) {          Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi),                                    FastMath.sin(lambda) * FastMath.cos(phi),                                    FastMath.sin(phi));          r.applyInverseTo(r.applyTo(u));          checkVector(u, r.applyInverseTo(r.applyTo(u)));          checkVector(u, r.applyTo(r.applyInverseTo(u)));      }    }    r = Rotation.IDENTITY;    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {      for (double phi = -1.55; phi < 1.55; phi += 0.2) {          Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi),                                    FastMath.sin(lambda) * FastMath.cos(phi),                                    FastMath.sin(phi));          checkVector(u, r.applyInverseTo(r.applyTo(u)));          checkVector(u, r.applyTo(r.applyInverseTo(u)));      }    }    r = new Rotation(Vector3D.PLUS_K, FastMath.PI);    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {      for (double phi = -1.55; phi < 1.55; phi += 0.2) {          Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi),                                    FastMath.sin(lambda) * FastMath.cos(phi),                                    FastMath.sin(phi));          checkVector(u, r.applyInverseTo(r.applyTo(u)));          checkVector(u, r.applyTo(r.applyInverseTo(u)));      }    }  }  private void checkVector(Vector3D v1, Vector3D v2) {    assertTrue(v1.subtract(v2).getNorm() < 1.0e-10);  }  private void checkAngle(double a1, double a2) {    assertEquals(a1, MathUtils.normalizeAngle(a2, a1), 1.0e-10);  }  private void checkRotation(Rotation r, double q0, double q1, double q2, double q3) {    assertEquals(0, Rotation.distance(r, new Rotation(q0, q1, q2, q3, false)), 1.0e-12);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry;import org.apache.commons.math.geometry.Vector3D;import org.apache.commons.math.util.FastMath;import junit.framework.*;public class Vector3DTest  extends TestCase {  public Vector3DTest(String name) {    super(name);  }  public void testConstructors() {      double r = FastMath.sqrt(2) /2;      checkVector(new Vector3D(2, new Vector3D(FastMath.PI / 3, -FastMath.PI / 4)),                  r, r * FastMath.sqrt(3), -2 * r);      checkVector(new Vector3D(2, Vector3D.PLUS_I,                              -3, Vector3D.MINUS_K),                  2, 0, 3);      checkVector(new Vector3D(2, Vector3D.PLUS_I,                               5, Vector3D.PLUS_J,                              -3, Vector3D.MINUS_K),                  2, 5, 3);      checkVector(new Vector3D(2, Vector3D.PLUS_I,                               5, Vector3D.PLUS_J,                               5, Vector3D.MINUS_J,                               -3, Vector3D.MINUS_K),                  2, 0, 3);  }  public void testCoordinates() {    Vector3D v = new Vector3D(1, 2, 3);    assertTrue(FastMath.abs(v.getX() - 1) < 1.0e-12);    assertTrue(FastMath.abs(v.getY() - 2) < 1.0e-12);    assertTrue(FastMath.abs(v.getZ() - 3) < 1.0e-12);  }  public void testNorm1() {    assertEquals(0.0, Vector3D.ZERO.getNorm1());    assertEquals(6.0, new Vector3D(1, -2, 3).getNorm1(), 0);  }  public void testNorm() {      assertEquals(0.0, Vector3D.ZERO.getNorm());      assertEquals(FastMath.sqrt(14), new Vector3D(1, 2, 3).getNorm(), 1.0e-12);    }  public void testNormInf() {      assertEquals(0.0, Vector3D.ZERO.getNormInf());      assertEquals(3.0, new Vector3D(1, -2, 3).getNormInf(), 0);    }  public void testDistance1() {      Vector3D v1 = new Vector3D(1, -2, 3);      Vector3D v2 = new Vector3D(-4, 2, 0);      assertEquals(0.0, Vector3D.distance1(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);      assertEquals(12.0, Vector3D.distance1(v1, v2), 1.0e-12);      assertEquals(v1.subtract(v2).getNorm1(), Vector3D.distance1(v1, v2), 1.0e-12);  }  public void testDistance() {      Vector3D v1 = new Vector3D(1, -2, 3);      Vector3D v2 = new Vector3D(-4, 2, 0);      assertEquals(0.0, Vector3D.distance(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);      assertEquals(FastMath.sqrt(50), Vector3D.distance(v1, v2), 1.0e-12);      assertEquals(v1.subtract(v2).getNorm(), Vector3D.distance(v1, v2), 1.0e-12);  }  public void testDistanceSq() {      Vector3D v1 = new Vector3D(1, -2, 3);      Vector3D v2 = new Vector3D(-4, 2, 0);      assertEquals(0.0, Vector3D.distanceSq(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);      assertEquals(50.0, Vector3D.distanceSq(v1, v2), 1.0e-12);      assertEquals(Vector3D.distance(v1, v2) * Vector3D.distance(v1, v2),                   Vector3D.distanceSq(v1, v2), 1.0e-12);  }  public void testDistanceInf() {      Vector3D v1 = new Vector3D(1, -2, 3);      Vector3D v2 = new Vector3D(-4, 2, 0);      assertEquals(0.0, Vector3D.distanceInf(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);      assertEquals(5.0, Vector3D.distanceInf(v1, v2), 1.0e-12);      assertEquals(v1.subtract(v2).getNormInf(), Vector3D.distanceInf(v1, v2), 1.0e-12);  }  public void testSubtract() {    Vector3D v1 = new Vector3D(1, 2, 3);    Vector3D v2 = new Vector3D(-3, -2, -1);    v1 = v1.subtract(v2);    checkVector(v1, 4, 4, 4);    checkVector(v2.subtract(v1), -7, -6, -5);    checkVector(v2.subtract(3, v1), -15, -14, -13);  }  public void testAdd() {    Vector3D v1 = new Vector3D(1, 2, 3);    Vector3D v2 = new Vector3D(-3, -2, -1);    v1 = v1.add(v2);    checkVector(v1, -2, 0, 2);    checkVector(v2.add(v1), -5, -2, 1);    checkVector(v2.add(3, v1), -9, -2, 5);  }  public void testScalarProduct() {    Vector3D v = new Vector3D(1, 2, 3);    v = v.scalarMultiply(3);    checkVector(v, 3, 6, 9);    checkVector(v.scalarMultiply(0.5), 1.5, 3, 4.5);  }  public void testVectorialProducts() {    Vector3D v1 = new Vector3D(2, 1, -4);    Vector3D v2 = new Vector3D(3, 1, -1);    assertTrue(FastMath.abs(Vector3D.dotProduct(v1, v2) - 11) < 1.0e-12);    Vector3D v3 = Vector3D.crossProduct(v1, v2);    checkVector(v3, 3, -10, -1);    assertTrue(FastMath.abs(Vector3D.dotProduct(v1, v3)) < 1.0e-12);    assertTrue(FastMath.abs(Vector3D.dotProduct(v2, v3)) < 1.0e-12);  }  public void testAngular() {    assertEquals(0,           Vector3D.PLUS_I.getAlpha(), 1.0e-10);    assertEquals(0,           Vector3D.PLUS_I.getDelta(), 1.0e-10);    assertEquals(FastMath.PI / 2, Vector3D.PLUS_J.getAlpha(), 1.0e-10);    assertEquals(0,           Vector3D.PLUS_J.getDelta(), 1.0e-10);    assertEquals(0,           Vector3D.PLUS_K.getAlpha(), 1.0e-10);    assertEquals(FastMath.PI / 2, Vector3D.PLUS_K.getDelta(), 1.0e-10);    Vector3D u = new Vector3D(-1, 1, -1);    assertEquals(3 * FastMath.PI /4, u.getAlpha(), 1.0e-10);    assertEquals(-1.0 / FastMath.sqrt(3), FastMath.sin(u.getDelta()), 1.0e-10);  }  public void testAngularSeparation() {    Vector3D v1 = new Vector3D(2, -1, 4);    Vector3D  k = v1.normalize();    Vector3D  i = k.orthogonal();    Vector3D v2 = k.scalarMultiply(FastMath.cos(1.2)).add(i.scalarMultiply(FastMath.sin(1.2)));    assertTrue(FastMath.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12);  }  public void testNormalize() {    assertEquals(1.0, new Vector3D(5, -4, 2).normalize().getNorm(), 1.0e-12);    try {        Vector3D.ZERO.normalize();        fail("an exception should have been thrown");    } catch (ArithmeticException ae) {        // expected behavior    } catch (Exception e) {        fail("wrong exception caught: " + e.getMessage());    }  }  public void testOrthogonal() {      Vector3D v1 = new Vector3D(0.1, 2.5, 1.3);      assertEquals(0.0, Vector3D.dotProduct(v1, v1.orthogonal()), 1.0e-12);      Vector3D v2 = new Vector3D(2.3, -0.003, 7.6);      assertEquals(0.0, Vector3D.dotProduct(v2, v2.orthogonal()), 1.0e-12);      Vector3D v3 = new Vector3D(-1.7, 1.4, 0.2);      assertEquals(0.0, Vector3D.dotProduct(v3, v3.orthogonal()), 1.0e-12);      try {          new Vector3D(0, 0, 0).orthogonal();          fail("an exception should have been thrown");      } catch (ArithmeticException ae) {          // expected behavior      } catch (Exception e) {          fail("wrong exception caught: " + e.getMessage());      }  }  public void testAngle() {     assertEquals(0.22572612855273393616,                  Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(4, 5, 6)),                  1.0e-12);     assertEquals(7.98595620686106654517199e-8,                  Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(2, 4, 6.000001)),                  1.0e-12);     assertEquals(3.14159257373023116985197793156,                  Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(-2, -4, -6.000001)),                  1.0e-12);     try {         Vector3D.angle(Vector3D.ZERO, Vector3D.PLUS_I);         fail("an exception should have been thrown");     } catch (ArithmeticException ae) {         // expected behavior     } catch (Exception e) {         fail("wrong exception caught: " + e.getMessage());     }  }  private void checkVector(Vector3D v, double x, double y, double z) {      assertEquals(x, v.getX(), 1.0e-12);      assertEquals(y, v.getY(), 1.0e-12);      assertEquals(z, v.getZ(), 1.0e-12);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry;import java.util.Locale;public class Vector3DFormatTest extends Vector3DFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return '.';    }    @Override    protected Locale getLocale() {        return Locale.US;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry;import java.text.NumberFormat;import java.text.ParseException;import java.text.ParsePosition;import java.util.Locale;import junit.framework.TestCase;import org.apache.commons.math.util.CompositeFormat;public abstract class Vector3DFormatAbstractTest extends TestCase {    Vector3DFormat vector3DFormat = null;    Vector3DFormat vector3DFormatSquare = null;    protected abstract Locale getLocale();    protected abstract char getDecimalCharacter();    @Override    protected void setUp() throws Exception {        vector3DFormat = Vector3DFormat.getInstance(getLocale());        final NumberFormat nf = NumberFormat.getInstance(getLocale());        nf.setMaximumFractionDigits(2);        vector3DFormatSquare = new Vector3DFormat("[", "]", " : ", nf);    }    public void testSimpleNoDecimals() {        Vector3D c = new Vector3D(1, 1, 1);        String expected = "{1; 1; 1}";        String actual = vector3DFormat.format(c);        assertEquals(expected, actual);    }    public void testSimpleWithDecimals() {        Vector3D c = new Vector3D(1.23, 1.43, 1.63);        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = vector3DFormat.format(c);        assertEquals(expected, actual);    }    public void testSimpleWithDecimalsTrunc() {        Vector3D c = new Vector3D(1.2323, 1.4343, 1.6333);        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = vector3DFormat.format(c);        assertEquals(expected, actual);    }    public void testNegativeX() {        Vector3D c = new Vector3D(-1.2323, 1.4343, 1.6333);        String expected =            "{-1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = vector3DFormat.format(c);        assertEquals(expected, actual);    }    public void testNegativeY() {        Vector3D c = new Vector3D(1.2323, -1.4343, 1.6333);        String expected =            "{1"    + getDecimalCharacter() +            "23; -1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = vector3DFormat.format(c);        assertEquals(expected, actual);    }    public void testNegativeZ() {        Vector3D c = new Vector3D(1.2323, 1.4343, -1.6333);        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; -1" + getDecimalCharacter() +            "63}";        String actual = vector3DFormat.format(c);        assertEquals(expected, actual);    }    public void testNonDefaultSetting() {        Vector3D c = new Vector3D(1, 1, 1);        String expected = "[1 : 1 : 1]";        String actual = vector3DFormatSquare.format(c);        assertEquals(expected, actual);    }    public void testStaticFormatVector3D() {        Locale defaultLocal = Locale.getDefault();        Locale.setDefault(getLocale());        Vector3D c = new Vector3D(232.222, -342.33, 432.444);        String expected =            "{232"    + getDecimalCharacter() +            "22; -342" + getDecimalCharacter() +            "33; 432" + getDecimalCharacter() +            "44}";        String actual = Vector3DFormat.formatVector3D(c);        assertEquals(expected, actual);        Locale.setDefault(defaultLocal);    }    public void testNan() {        Vector3D c = Vector3D.NaN;        String expected = "{(NaN); (NaN); (NaN)}";        String actual = vector3DFormat.format(c);        assertEquals(expected, actual);    }    public void testPositiveInfinity() {        Vector3D c = Vector3D.POSITIVE_INFINITY;        String expected = "{(Infinity); (Infinity); (Infinity)}";        String actual = vector3DFormat.format(c);        assertEquals(expected, actual);    }    public void tesNegativeInfinity() {        Vector3D c = Vector3D.NEGATIVE_INFINITY;        String expected = "{(-Infinity); (-Infinity); (-Infinity)}";        String actual = vector3DFormat.format(c);        assertEquals(expected, actual);    }    public void testParseSimpleNoDecimals() {        String source = "{1; 1; 1}";        Vector3D expected = new Vector3D(1, 1, 1);        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseIgnoredWhitespace() {        Vector3D expected = new Vector3D(1, 1, 1);        ParsePosition pos1 = new ParsePosition(0);        String source1 = "{1;1;1}";        assertEquals(expected, vector3DFormat.parseObject(source1, pos1));        assertEquals(source1.length(), pos1.getIndex());        ParsePosition pos2 = new ParsePosition(0);        String source2 = " { 1 ; 1 ; 1 } ";        assertEquals(expected, vector3DFormat.parseObject(source2, pos2));        assertEquals(source2.length() - 1, pos2.getIndex());    }    public void testParseSimpleWithDecimals() {        String source =            "{1" + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        Vector3D expected = new Vector3D(1.23, 1.43, 1.63);        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseSimpleWithDecimalsTrunc() {        String source =            "{1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeX() {        String source =            "{-1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(-1.2323, 1.4343, 1.6333);        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeY() {        String source =            "{1" + getDecimalCharacter() +            "2323; -1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(1.2323, -1.4343, 1.6333);        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeZ() {        String source =            "{1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; -1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(1.2323, 1.4343, -1.6333);        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeAll() {        String source =            "{-1" + getDecimalCharacter() +            "2323; -1" + getDecimalCharacter() +            "4343; -1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(-1.2323, -1.4343, -1.6333);        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseZeroX() {        String source =            "{0" + getDecimalCharacter() +            "0; -1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        Vector3D expected = new Vector3D(0.0, -1.4343, 1.6333);        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNonDefaultSetting() {        String source =            "[1" + getDecimalCharacter() +            "2323 : 1" + getDecimalCharacter() +            "4343 : 1" + getDecimalCharacter() +            "6333]";        Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);        try {            Vector3D actual = (Vector3D) vector3DFormatSquare.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNan() {        String source = "{(NaN); (NaN); (NaN)}";        try {            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);            assertEquals(Vector3D.NaN, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParsePositiveInfinity() {        String source = "{(Infinity); (Infinity); (Infinity)}";        try {            Vector3D actual = (Vector3D)vector3DFormat.parseObject(source);            assertEquals(Vector3D.POSITIVE_INFINITY, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeInfinity() {        String source = "{(-Infinity); (-Infinity); (-Infinity)}";        try {            Vector3D actual = (Vector3D)vector3DFormat.parseObject(source);            assertEquals(Vector3D.NEGATIVE_INFINITY, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testConstructorSingleFormat() {        NumberFormat nf = NumberFormat.getInstance();        Vector3DFormat cf = new Vector3DFormat(nf);        assertNotNull(cf);        assertEquals(nf, cf.getFormat());    }    public void testFormatObject() {        try {            CompositeFormat cf = new Vector3DFormat();            Object object = new Object();            cf.format(object);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }    public void testForgottenPrefix() {        ParsePosition pos = new ParsePosition(0);        assertNull(new Vector3DFormat().parse("1; 1; 1}", pos));        assertEquals(0, pos.getErrorIndex());    }    public void testForgottenSeparator() {        ParsePosition pos = new ParsePosition(0);        assertNull(new Vector3DFormat().parse("{1; 1 1}", pos));        assertEquals(6, pos.getErrorIndex());    }    public void testForgottenSuffix() {        ParsePosition pos = new ParsePosition(0);        assertNull(new Vector3DFormat().parse("{1; 1; 1 ", pos));        assertEquals(8, pos.getErrorIndex());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry;import java.util.Locale;public class FrenchVector3DFormatTest extends Vector3DFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return ',';    }    @Override    protected Locale getLocale() {        return Locale.FRENCH;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.geometry;import java.lang.reflect.Field;import org.apache.commons.math.geometry.RotationOrder;import junit.framework.*;public class RotationOrderTest  extends TestCase {  public RotationOrderTest(String name) {    super(name);  }  public void testName() {    RotationOrder[] orders = {      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX,      RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,      RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ    };    for (int i = 0; i < orders.length; ++i) {      assertEquals(getFieldName(orders[i]), orders[i].toString());    }  }  private String getFieldName(RotationOrder order) {    try {      Field[] fields = RotationOrder.class.getFields();      for (int i = 0; i < fields.length; ++i) {        if (fields[i].get(null) == order) {          return fields[i].getName();        }      }    } catch (IllegalAccessException iae) {      // ignored    }    return "unknown";  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.estimation;import org.apache.commons.math.estimation.EstimatedParameter;import org.apache.commons.math.util.FastMath;import junit.framework.*;@Deprecatedpublic class EstimatedParameterTest  extends TestCase {  public EstimatedParameterTest(String name) {    super(name);  }  public void testConstruction() {    EstimatedParameter p1 = new EstimatedParameter("p1", 1.0);    assertTrue(p1.getName().equals("p1"));    checkValue(p1.getEstimate(), 1.0);    assertTrue(! p1.isBound());    EstimatedParameter p2 = new EstimatedParameter("p2", 2.0, true);    assertTrue(p2.getName().equals("p2"));    checkValue(p2.getEstimate(), 2.0);    assertTrue(p2.isBound());  }  public void testBound() {    EstimatedParameter p = new EstimatedParameter("p", 0.0);    assertTrue(! p.isBound());    p.setBound(true);    assertTrue(p.isBound());    p.setBound(false);    assertTrue(! p.isBound());  }  public void testEstimate() {    EstimatedParameter p = new EstimatedParameter("p", 0.0);    checkValue(p.getEstimate(), 0.0);    for (double e = 0.0; e < 10.0; e += 0.5) {      p.setEstimate(e);      checkValue(p.getEstimate(), e);    }  }  private void checkValue(double value, double expected) {    assertTrue(FastMath.abs(value - expected) < 1.0e-10);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.estimation;import java.util.ArrayList;import java.util.HashSet;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */@Deprecatedpublic class GaussNewtonEstimatorTest  extends TestCase {  public GaussNewtonEstimatorTest(String name) {    super(name);  }  public void testTrivial() throws EstimationException {    LinearProblem problem =      new LinearProblem(new LinearMeasurement[] {        new LinearMeasurement(new double[] {2},                              new EstimatedParameter[] {                                 new EstimatedParameter("p0", 0)                              }, 3.0)      });    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(1.5,                 problem.getUnboundParameters()[0].getEstimate(),                 1.0e-10);   }  public void testQRColumnsPermutation() throws EstimationException {    EstimatedParameter[] x = {       new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 0)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, -1.0 },                            new EstimatedParameter[] { x[0], x[1] },                            4.0),      new LinearMeasurement(new double[] { 2.0 },                            new EstimatedParameter[] { x[1] },                            6.0),      new LinearMeasurement(new double[] { 1.0, -2.0 },                            new EstimatedParameter[] { x[0], x[1] },                            1.0)    });    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(7.0, x[0].getEstimate(), 1.0e-10);    assertEquals(3.0, x[1].getEstimate(), 1.0e-10);  }  public void testNoDependency() throws EstimationException {    EstimatedParameter[] p = new EstimatedParameter[] {      new EstimatedParameter("p0", 0),      new EstimatedParameter("p1", 0),      new EstimatedParameter("p2", 0),      new EstimatedParameter("p3", 0),      new EstimatedParameter("p4", 0),      new EstimatedParameter("p5", 0)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[0] }, 0.0),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[1] }, 1.1),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[2] }, 2.2),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[3] }, 3.3),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[4] }, 4.4),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[5] }, 5.5)    });  GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);  estimator.estimate(problem);  assertEquals(0, estimator.getRMS(problem), 1.0e-10);  for (int i = 0; i < p.length; ++i) {    assertEquals(0.55 * i, p[i].getEstimate(), 1.0e-10);  }}  public void testOneSet() throws EstimationException {    EstimatedParameter[] p = {       new EstimatedParameter("p0", 0),       new EstimatedParameter("p1", 0),       new EstimatedParameter("p2", 0)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0 },                            new EstimatedParameter[] { p[0] },                            1.0),      new LinearMeasurement(new double[] { -1.0, 1.0 },                            new EstimatedParameter[] { p[0], p[1] },                            1.0),      new LinearMeasurement(new double[] { -1.0, 1.0 },                            new EstimatedParameter[] { p[1], p[2] },                            1.0)    });    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(1.0, p[0].getEstimate(), 1.0e-10);    assertEquals(2.0, p[1].getEstimate(), 1.0e-10);    assertEquals(3.0, p[2].getEstimate(), 1.0e-10);  }  public void testTwoSets() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 0),      new EstimatedParameter("p1", 1),      new EstimatedParameter("p2", 2),      new EstimatedParameter("p3", 3),      new EstimatedParameter("p4", 4),      new EstimatedParameter("p5", 5)    };    double epsilon = 1.0e-7;    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      // 4 elements sub-problem      new LinearMeasurement(new double[] {  2.0,  1.0,  4.0 },                            new EstimatedParameter[] { p[0], p[1], p[3] },                            2.0),      new LinearMeasurement(new double[] { -4.0, -2.0,   3.0, -7.0 },                           new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                           -9.0),      new LinearMeasurement(new double[] {  4.0,  1.0,  -2.0,  8.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            2.0),      new LinearMeasurement(new double[] { -3.0, -12.0, -1.0 },                           new EstimatedParameter[] { p[1], p[2], p[3] },                           2.0),      // 2 elements sub-problem      new LinearMeasurement(new double[] { epsilon, 1.0 },                            new EstimatedParameter[] { p[4], p[5] },                            1.0 + epsilon * epsilon),      new LinearMeasurement(new double[] {  1.0, 1.0 },                            new EstimatedParameter[] { p[4], p[5] },                            2.0)    });    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals( 3.0, p[0].getEstimate(), 1.0e-10);    assertEquals( 4.0, p[1].getEstimate(), 1.0e-10);    assertEquals(-1.0, p[2].getEstimate(), 1.0e-10);    assertEquals(-2.0, p[3].getEstimate(), 1.0e-10);    assertEquals( 1.0 + epsilon, p[4].getEstimate(), 1.0e-10);    assertEquals( 1.0 - epsilon, p[5].getEstimate(), 1.0e-10);  }  public void testNonInversible() {    EstimatedParameter[] p = {       new EstimatedParameter("p0", 0),       new EstimatedParameter("p1", 0),       new EstimatedParameter("p2", 0)    };    LinearMeasurement[] m = new LinearMeasurement[] {      new LinearMeasurement(new double[] {  1.0, 2.0, -3.0 },                            new EstimatedParameter[] { p[0], p[1], p[2] },                            1.0),      new LinearMeasurement(new double[] {  2.0, 1.0,  3.0 },                            new EstimatedParameter[] { p[0], p[1], p[2] },                            1.0),      new LinearMeasurement(new double[] { -3.0, -9.0 },                            new EstimatedParameter[] { p[0], p[2] },                            1.0)    };    LinearProblem problem = new LinearProblem(m);    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    try {      estimator.estimate(problem);      fail("an exception should have been caught");    } catch (EstimationException ee) {      // expected behavior    } catch (Exception e) {      fail("wrong exception type caught");    }  }  public void testIllConditioned() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 0),      new EstimatedParameter("p1", 1),      new EstimatedParameter("p2", 2),      new EstimatedParameter("p3", 3)    };    LinearProblem problem1 = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 10.0, 7.0,  8.0,  7.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            32.0),      new LinearMeasurement(new double[] {  7.0, 5.0,  6.0,  5.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            23.0),      new LinearMeasurement(new double[] {  8.0, 6.0, 10.0,  9.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            33.0),      new LinearMeasurement(new double[] {  7.0, 5.0,  9.0, 10.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            31.0)    });    GaussNewtonEstimator estimator1 = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    estimator1.estimate(problem1);    assertEquals(0, estimator1.getRMS(problem1), 1.0e-10);    assertEquals(1.0, p[0].getEstimate(), 1.0e-10);    assertEquals(1.0, p[1].getEstimate(), 1.0e-10);    assertEquals(1.0, p[2].getEstimate(), 1.0e-10);    assertEquals(1.0, p[3].getEstimate(), 1.0e-10);    LinearProblem problem2 = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 10.0, 7.0,  8.1,  7.2 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            32.0),      new LinearMeasurement(new double[] {  7.08, 5.04,  6.0,  5.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            23.0),      new LinearMeasurement(new double[] {  8.0, 5.98, 9.89,  9.0 },                             new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            33.0),      new LinearMeasurement(new double[] {  6.99, 4.99,  9.0, 9.98 },                             new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            31.0)    });    GaussNewtonEstimator estimator2 = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    estimator2.estimate(problem2);    assertEquals(0, estimator2.getRMS(problem2), 1.0e-10);    assertEquals(-81.0, p[0].getEstimate(), 1.0e-8);    assertEquals(137.0, p[1].getEstimate(), 1.0e-8);    assertEquals(-34.0, p[2].getEstimate(), 1.0e-8);    assertEquals( 22.0, p[3].getEstimate(), 1.0e-8);  }  public void testMoreEstimatedParametersSimple() {    EstimatedParameter[] p = {       new EstimatedParameter("p0", 7),       new EstimatedParameter("p1", 6),       new EstimatedParameter("p2", 5),       new EstimatedParameter("p3", 4)     };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 3.0, 2.0 },                             new EstimatedParameter[] { p[0], p[1] },                             7.0),      new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },                             new EstimatedParameter[] { p[1], p[2], p[3] },                             3.0),      new LinearMeasurement(new double[] { 2.0, 1.0 },                             new EstimatedParameter[] { p[0], p[2] },                             5.0)    });    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    try {        estimator.estimate(problem);        fail("an exception should have been caught");    } catch (EstimationException ee) {        // expected behavior    } catch (Exception e) {        fail("wrong exception type caught");    }  }  public void testMoreEstimatedParametersUnsorted() {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 2),      new EstimatedParameter("p1", 2),      new EstimatedParameter("p2", 2),      new EstimatedParameter("p3", 2),      new EstimatedParameter("p4", 2),      new EstimatedParameter("p5", 2)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, 1.0 },                           new EstimatedParameter[] { p[0], p[1] },                           3.0),      new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 },                           new EstimatedParameter[] { p[2], p[3], p[4] },                           12.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                           new EstimatedParameter[] { p[4], p[5] },                           -1.0),      new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },                           new EstimatedParameter[] { p[3], p[2], p[5] },                           7.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                           new EstimatedParameter[] { p[4], p[3] },                           1.0)    });    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    try {        estimator.estimate(problem);        fail("an exception should have been caught");    } catch (EstimationException ee) {        // expected behavior    } catch (Exception e) {        fail("wrong exception type caught");    }  }  public void testRedundantEquations() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 1),      new EstimatedParameter("p1", 1)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, 1.0 },                             new EstimatedParameter[] { p[0], p[1] },                             3.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                             new EstimatedParameter[] { p[0], p[1] },                             1.0),      new LinearMeasurement(new double[] { 1.0, 3.0 },                             new EstimatedParameter[] { p[0], p[1] },                             5.0)    });    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    EstimatedParameter[] all = problem.getAllParameters();    for (int i = 0; i < all.length; ++i) {        assertEquals(all[i].getName().equals("p0") ? 2.0 : 1.0,                     all[i].getEstimate(), 1.0e-10);    }  }  public void testInconsistentEquations() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 1),      new EstimatedParameter("p1", 1)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, 1.0 },                            new EstimatedParameter[] { p[0], p[1] },                            3.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                            new EstimatedParameter[] { p[0], p[1] },                            1.0),      new LinearMeasurement(new double[] { 1.0, 3.0 },                            new EstimatedParameter[] { p[0], p[1] },                            4.0)    });    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    estimator.estimate(problem);    assertTrue(estimator.getRMS(problem) > 0.1);  }  public void testBoundParameters() throws EstimationException {      EstimatedParameter[] p = {        new EstimatedParameter("unbound0", 2, false),        new EstimatedParameter("unbound1", 2, false),        new EstimatedParameter("bound",    2, true)      };      LinearProblem problem = new LinearProblem(new LinearMeasurement[] {        new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 },                              new EstimatedParameter[] { p[0], p[1], p[2] },                              3.0),        new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },                              new EstimatedParameter[] { p[0], p[1], p[2] },                              1.0),        new LinearMeasurement(new double[] { 1.0, 3.0, 2.0 },                              new EstimatedParameter[] { p[0], p[1], p[2] },                              7.0)      });      GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);      estimator.estimate(problem);      assertTrue(estimator.getRMS(problem) < 1.0e-10);      double[][] covariances = estimator.getCovariances(problem);      int i0 = 0, i1 = 1;      if (problem.getUnboundParameters()[0].getName().endsWith("1")) {          i0 = 1;          i1 = 0;      }      assertEquals(11.0 / 24, covariances[i0][i0], 1.0e-10);      assertEquals(-3.0 / 24, covariances[i0][i1], 1.0e-10);      assertEquals(-3.0 / 24, covariances[i1][i0], 1.0e-10);      assertEquals( 3.0 / 24, covariances[i1][i1], 1.0e-10);      double[] errors = estimator.guessParametersErrors(problem);      assertEquals(0, errors[i0], 1.0e-10);      assertEquals(0, errors[i1], 1.0e-10);  }  public void testMaxIterations() {      Circle circle = new Circle(98.680, 47.345);      circle.addPoint( 30.0,  68.0);      circle.addPoint( 50.0,  -6.0);      circle.addPoint(110.0, -20.0);      circle.addPoint( 35.0,  15.0);      circle.addPoint( 45.0,  97.0);      try {        GaussNewtonEstimator estimator = new GaussNewtonEstimator(4, 1.0e-14, 1.0e-14);        estimator.estimate(circle);        fail("an exception should have been caught");      } catch (EstimationException ee) {        // expected behavior      } catch (Exception e) {        fail("wrong exception type caught");      }    }  public void testCircleFitting() throws EstimationException {      Circle circle = new Circle(98.680, 47.345);      circle.addPoint( 30.0,  68.0);      circle.addPoint( 50.0,  -6.0);      circle.addPoint(110.0, -20.0);      circle.addPoint( 35.0,  15.0);      circle.addPoint( 45.0,  97.0);      GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-10, 1.0e-10);      estimator.estimate(circle);      double rms = estimator.getRMS(circle);      assertEquals(1.768262623567235,  FastMath.sqrt(circle.getM()) * rms,  1.0e-10);      assertEquals(69.96016176931406, circle.getRadius(), 1.0e-10);      assertEquals(96.07590211815305, circle.getX(),      1.0e-10);      assertEquals(48.13516790438953, circle.getY(),      1.0e-10);    }  public void testCircleFittingBadInit() {    Circle circle = new Circle(-12, -12);    double[][] points = new double[][] {      {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},      {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},      {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},      {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},      { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},      { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},      {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},      {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},      {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},      {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},      {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},      { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},      { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},      {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},      {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},      {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},      {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},      {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},      { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},      { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},      { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},      {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},      {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},      {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},      {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},      {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},      { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},      { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},      {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}    };    for (int i = 0; i < points.length; ++i) {      circle.addPoint(points[i][0], points[i][1]);    }    GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);    try {        estimator.estimate(circle);        fail("an exception should have been caught");    } catch (EstimationException ee) {        // expected behavior    } catch (Exception e) {        fail("wrong exception type caught");    }}  private static class LinearProblem extends SimpleEstimationProblem {    public LinearProblem(LinearMeasurement[] measurements) {      HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>();      for (int i = 0; i < measurements.length; ++i) {        addMeasurement(measurements[i]);        EstimatedParameter[] parameters = measurements[i].getParameters();        for (int j = 0; j < parameters.length; ++j) {          set.add(parameters[j]);        }      }      for (EstimatedParameter p : set) {        addParameter(p);      }    }  }  private static class LinearMeasurement extends WeightedMeasurement {    public LinearMeasurement(double[] factors, EstimatedParameter[] parameters,                             double setPoint) {      super(1.0, setPoint, true);      this.factors = factors;      this.parameters = parameters;      setIgnored(false);    }    @Override    public double getTheoreticalValue() {      double v = 0;      for (int i = 0; i < factors.length; ++i) {        v += factors[i] * parameters[i].getEstimate();      }      return v;    }    @Override    public double getPartial(EstimatedParameter parameter) {      for (int i = 0; i < parameters.length; ++i) {        if (parameters[i] == parameter) {          return factors[i];        }      }      return 0;    }    public EstimatedParameter[] getParameters() {      return parameters;    }    private double[] factors;    private EstimatedParameter[] parameters;    private static final long serialVersionUID = -3922448707008868580L;  }  private static class Circle implements EstimationProblem {    public Circle(double cx, double cy) {      this.cx = new EstimatedParameter("cx", cx);      this.cy = new EstimatedParameter(new EstimatedParameter("cy", cy));      points  = new ArrayList<PointModel>();    }    public void addPoint(double px, double py) {      points.add(new PointModel(this, px, py));    }    public int getM() {      return points.size();    }    public WeightedMeasurement[] getMeasurements() {      return points.toArray(new PointModel[points.size()]);    }    public EstimatedParameter[] getAllParameters() {      return new EstimatedParameter[] { cx, cy };    }    public EstimatedParameter[] getUnboundParameters() {      return new EstimatedParameter[] { cx, cy };    }    public double getPartialRadiusX() {      double dRdX = 0;      for (PointModel point : points) {        dRdX += point.getPartialDiX();      }      return dRdX / points.size();    }    public double getPartialRadiusY() {      double dRdY = 0;      for (PointModel point : points) {        dRdY += point.getPartialDiY();      }      return dRdY / points.size();    }   public double getRadius() {      double r = 0;      for (PointModel point : points) {        r += point.getCenterDistance();      }      return r / points.size();    }    public double getX() {      return cx.getEstimate();    }    public double getY() {      return cy.getEstimate();    }    private static class PointModel extends WeightedMeasurement {      public PointModel(Circle circle, double px, double py) {        super(1.0, 0.0);        this.px = px;        this.py = py;        this.circle = circle;      }      @Override      public double getPartial(EstimatedParameter parameter) {        if (parameter == circle.cx) {          return getPartialDiX() - circle.getPartialRadiusX();        } else if (parameter == circle.cy) {          return getPartialDiY() - circle.getPartialRadiusY();        }        return 0;      }      public double getCenterDistance() {        double dx = px - circle.cx.getEstimate();        double dy = py - circle.cy.getEstimate();        return FastMath.sqrt(dx * dx + dy * dy);      }      public double getPartialDiX() {        return (circle.cx.getEstimate() - px) / getCenterDistance();      }      public double getPartialDiY() {        return (circle.cy.getEstimate() - py) / getCenterDistance();      }      @Override      public double getTheoreticalValue() {        return getCenterDistance() - circle.getRadius();      }      private double px;      private double py;      private transient final Circle circle;      private static final long serialVersionUID = 1L;    }    private EstimatedParameter cx;    private EstimatedParameter cy;    private ArrayList<PointModel> points;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.estimation;import java.util.ArrayList;import java.util.HashSet;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */@Deprecatedpublic class LevenbergMarquardtEstimatorTest  extends TestCase {  public LevenbergMarquardtEstimatorTest(String name) {    super(name);  }  public void testTrivial() throws EstimationException {    LinearProblem problem =      new LinearProblem(new LinearMeasurement[] {        new LinearMeasurement(new double[] {2},                              new EstimatedParameter[] {                                 new EstimatedParameter("p0", 0)                              }, 3.0)      });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    try {        estimator.guessParametersErrors(problem);        fail("an exception should have been thrown");    } catch (EstimationException ee) {        // expected behavior    } catch (Exception e) {        fail("wrong exception caught");    }    assertEquals(1.5,                 problem.getUnboundParameters()[0].getEstimate(),                 1.0e-10);   }  public void testQRColumnsPermutation() throws EstimationException {    EstimatedParameter[] x = {       new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 0)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, -1.0 },                            new EstimatedParameter[] { x[0], x[1] },                            4.0),      new LinearMeasurement(new double[] { 2.0 },                            new EstimatedParameter[] { x[1] },                            6.0),      new LinearMeasurement(new double[] { 1.0, -2.0 },                            new EstimatedParameter[] { x[0], x[1] },                            1.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(7.0, x[0].getEstimate(), 1.0e-10);    assertEquals(3.0, x[1].getEstimate(), 1.0e-10);  }  public void testNoDependency() throws EstimationException {    EstimatedParameter[] p = new EstimatedParameter[] {      new EstimatedParameter("p0", 0),      new EstimatedParameter("p1", 0),      new EstimatedParameter("p2", 0),      new EstimatedParameter("p3", 0),      new EstimatedParameter("p4", 0),      new EstimatedParameter("p5", 0)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[0] }, 0.0),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[1] }, 1.1),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[2] }, 2.2),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[3] }, 3.3),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[4] }, 4.4),      new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[5] }, 5.5)    });  LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();  estimator.estimate(problem);  assertEquals(0, estimator.getRMS(problem), 1.0e-10);  for (int i = 0; i < p.length; ++i) {    assertEquals(0.55 * i, p[i].getEstimate(), 1.0e-10);  }}  public void testOneSet() throws EstimationException {    EstimatedParameter[] p = {       new EstimatedParameter("p0", 0),       new EstimatedParameter("p1", 0),       new EstimatedParameter("p2", 0)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0 },                            new EstimatedParameter[] { p[0] },                            1.0),      new LinearMeasurement(new double[] { -1.0, 1.0 },                            new EstimatedParameter[] { p[0], p[1] },                            1.0),      new LinearMeasurement(new double[] { -1.0, 1.0 },                            new EstimatedParameter[] { p[1], p[2] },                            1.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(1.0, p[0].getEstimate(), 1.0e-10);    assertEquals(2.0, p[1].getEstimate(), 1.0e-10);    assertEquals(3.0, p[2].getEstimate(), 1.0e-10);  }  public void testTwoSets() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 0),      new EstimatedParameter("p1", 1),      new EstimatedParameter("p2", 2),      new EstimatedParameter("p3", 3),      new EstimatedParameter("p4", 4),      new EstimatedParameter("p5", 5)    };    double epsilon = 1.0e-7;    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      // 4 elements sub-problem      new LinearMeasurement(new double[] {  2.0,  1.0,  4.0 },                            new EstimatedParameter[] { p[0], p[1], p[3] },                            2.0),      new LinearMeasurement(new double[] { -4.0, -2.0,   3.0, -7.0 },                           new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                           -9.0),      new LinearMeasurement(new double[] {  4.0,  1.0,  -2.0,  8.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            2.0),      new LinearMeasurement(new double[] { -3.0, -12.0, -1.0 },                           new EstimatedParameter[] { p[1], p[2], p[3] },                           2.0),      // 2 elements sub-problem      new LinearMeasurement(new double[] { epsilon, 1.0 },                            new EstimatedParameter[] { p[4], p[5] },                            1.0 + epsilon * epsilon),      new LinearMeasurement(new double[] {  1.0, 1.0 },                            new EstimatedParameter[] { p[4], p[5] },                            2.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals( 3.0, p[0].getEstimate(), 1.0e-10);    assertEquals( 4.0, p[1].getEstimate(), 1.0e-10);    assertEquals(-1.0, p[2].getEstimate(), 1.0e-10);    assertEquals(-2.0, p[3].getEstimate(), 1.0e-10);    assertEquals( 1.0 + epsilon, p[4].getEstimate(), 1.0e-10);    assertEquals( 1.0 - epsilon, p[5].getEstimate(), 1.0e-10);  }  public void testNonInversible() throws EstimationException {    EstimatedParameter[] p = {       new EstimatedParameter("p0", 0),       new EstimatedParameter("p1", 0),       new EstimatedParameter("p2", 0)    };    LinearMeasurement[] m = new LinearMeasurement[] {      new LinearMeasurement(new double[] {  1.0, 2.0, -3.0 },                            new EstimatedParameter[] { p[0], p[1], p[2] },                            1.0),      new LinearMeasurement(new double[] {  2.0, 1.0,  3.0 },                            new EstimatedParameter[] { p[0], p[1], p[2] },                            1.0),      new LinearMeasurement(new double[] { -3.0, -9.0 },                            new EstimatedParameter[] { p[0], p[2] },                            1.0)    };    LinearProblem problem = new LinearProblem(m);    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    double initialCost = estimator.getRMS(problem);    estimator.estimate(problem);    assertTrue(estimator.getRMS(problem) < initialCost);    assertTrue(FastMath.sqrt(m.length) * estimator.getRMS(problem) > 0.6);    try {        estimator.getCovariances(problem);        fail("an exception should have been thrown");    } catch (EstimationException ee) {        // expected behavior    } catch (Exception e) {        fail("wrong exception caught");    }   double dJ0 = 2 * (m[0].getResidual() * m[0].getPartial(p[0])                    + m[1].getResidual() * m[1].getPartial(p[0])                    + m[2].getResidual() * m[2].getPartial(p[0]));    double dJ1 = 2 * (m[0].getResidual() * m[0].getPartial(p[1])                    + m[1].getResidual() * m[1].getPartial(p[1]));    double dJ2 = 2 * (m[0].getResidual() * m[0].getPartial(p[2])                    + m[1].getResidual() * m[1].getPartial(p[2])                    + m[2].getResidual() * m[2].getPartial(p[2]));    assertEquals(0, dJ0, 1.0e-10);    assertEquals(0, dJ1, 1.0e-10);    assertEquals(0, dJ2, 1.0e-10);  }  public void testIllConditioned() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 0),      new EstimatedParameter("p1", 1),      new EstimatedParameter("p2", 2),      new EstimatedParameter("p3", 3)    };    LinearProblem problem1 = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 10.0, 7.0,  8.0,  7.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            32.0),      new LinearMeasurement(new double[] {  7.0, 5.0,  6.0,  5.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            23.0),      new LinearMeasurement(new double[] {  8.0, 6.0, 10.0,  9.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            33.0),      new LinearMeasurement(new double[] {  7.0, 5.0,  9.0, 10.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            31.0)    });    LevenbergMarquardtEstimator estimator1 = new LevenbergMarquardtEstimator();    estimator1.estimate(problem1);    assertEquals(0, estimator1.getRMS(problem1), 1.0e-10);    assertEquals(1.0, p[0].getEstimate(), 1.0e-10);    assertEquals(1.0, p[1].getEstimate(), 1.0e-10);    assertEquals(1.0, p[2].getEstimate(), 1.0e-10);    assertEquals(1.0, p[3].getEstimate(), 1.0e-10);    LinearProblem problem2 = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 10.0, 7.0,  8.1,  7.2 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            32.0),      new LinearMeasurement(new double[] {  7.08, 5.04,  6.0,  5.0 },                            new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            23.0),      new LinearMeasurement(new double[] {  8.0, 5.98, 9.89,  9.0 },                             new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            33.0),      new LinearMeasurement(new double[] {  6.99, 4.99,  9.0, 9.98 },                             new EstimatedParameter[] { p[0], p[1], p[2], p[3] },                            31.0)    });    LevenbergMarquardtEstimator estimator2 = new LevenbergMarquardtEstimator();    estimator2.estimate(problem2);    assertEquals(0, estimator2.getRMS(problem2), 1.0e-10);    assertEquals(-81.0, p[0].getEstimate(), 1.0e-8);    assertEquals(137.0, p[1].getEstimate(), 1.0e-8);    assertEquals(-34.0, p[2].getEstimate(), 1.0e-8);    assertEquals( 22.0, p[3].getEstimate(), 1.0e-8);  }  public void testMoreEstimatedParametersSimple() throws EstimationException {    EstimatedParameter[] p = {       new EstimatedParameter("p0", 7),       new EstimatedParameter("p1", 6),       new EstimatedParameter("p2", 5),       new EstimatedParameter("p3", 4)     };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 3.0, 2.0 },                             new EstimatedParameter[] { p[0], p[1] },                             7.0),      new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },                             new EstimatedParameter[] { p[1], p[2], p[3] },                             3.0),      new LinearMeasurement(new double[] { 2.0, 1.0 },                             new EstimatedParameter[] { p[0], p[2] },                             5.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);  }  public void testMoreEstimatedParametersUnsorted() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 2),      new EstimatedParameter("p1", 2),      new EstimatedParameter("p2", 2),      new EstimatedParameter("p3", 2),      new EstimatedParameter("p4", 2),      new EstimatedParameter("p5", 2)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, 1.0 },                           new EstimatedParameter[] { p[0], p[1] },                           3.0),      new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 },                           new EstimatedParameter[] { p[2], p[3], p[4] },                           12.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                           new EstimatedParameter[] { p[4], p[5] },                           -1.0),      new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },                           new EstimatedParameter[] { p[3], p[2], p[5] },                           7.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                           new EstimatedParameter[] { p[4], p[3] },                           1.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(3.0, p[2].getEstimate(), 1.0e-10);    assertEquals(4.0, p[3].getEstimate(), 1.0e-10);    assertEquals(5.0, p[4].getEstimate(), 1.0e-10);    assertEquals(6.0, p[5].getEstimate(), 1.0e-10);  }  public void testRedundantEquations() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 1),      new EstimatedParameter("p1", 1)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, 1.0 },                             new EstimatedParameter[] { p[0], p[1] },                             3.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                             new EstimatedParameter[] { p[0], p[1] },                             1.0),      new LinearMeasurement(new double[] { 1.0, 3.0 },                             new EstimatedParameter[] { p[0], p[1] },                             5.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertEquals(0, estimator.getRMS(problem), 1.0e-10);    assertEquals(2.0, p[0].getEstimate(), 1.0e-10);    assertEquals(1.0, p[1].getEstimate(), 1.0e-10);  }  public void testInconsistentEquations() throws EstimationException {    EstimatedParameter[] p = {      new EstimatedParameter("p0", 1),      new EstimatedParameter("p1", 1)    };    LinearProblem problem = new LinearProblem(new LinearMeasurement[] {      new LinearMeasurement(new double[] { 1.0, 1.0 },                            new EstimatedParameter[] { p[0], p[1] },                            3.0),      new LinearMeasurement(new double[] { 1.0, -1.0 },                            new EstimatedParameter[] { p[0], p[1] },                            1.0),      new LinearMeasurement(new double[] { 1.0, 3.0 },                            new EstimatedParameter[] { p[0], p[1] },                            4.0)    });    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(problem);    assertTrue(estimator.getRMS(problem) > 0.1);  }  public void testControlParameters() {      Circle circle = new Circle(98.680, 47.345);      circle.addPoint( 30.0,  68.0);      circle.addPoint( 50.0,  -6.0);      circle.addPoint(110.0, -20.0);      circle.addPoint( 35.0,  15.0);      circle.addPoint( 45.0,  97.0);      checkEstimate(circle, 0.1, 10, 1.0e-14, 1.0e-16, 1.0e-10, false);      checkEstimate(circle, 0.1, 10, 1.0e-15, 1.0e-17, 1.0e-10, true);      checkEstimate(circle, 0.1,  5, 1.0e-15, 1.0e-16, 1.0e-10, true);      circle.addPoint(300, -300);      checkEstimate(circle, 0.1, 20, 1.0e-18, 1.0e-16, 1.0e-10, true);  }  private void checkEstimate(EstimationProblem problem,                             double initialStepBoundFactor, int maxCostEval,                             double costRelativeTolerance, double parRelativeTolerance,                             double orthoTolerance, boolean shouldFail) {      try {        LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();        estimator.setInitialStepBoundFactor(initialStepBoundFactor);        estimator.setMaxCostEval(maxCostEval);        estimator.setCostRelativeTolerance(costRelativeTolerance);        estimator.setParRelativeTolerance(parRelativeTolerance);        estimator.setOrthoTolerance(orthoTolerance);        estimator.estimate(problem);        assertTrue(! shouldFail);      } catch (EstimationException ee) {        assertTrue(shouldFail);      } catch (Exception e) {        fail("wrong exception type caught");      }    }  public void testCircleFitting() throws EstimationException {      Circle circle = new Circle(98.680, 47.345);      circle.addPoint( 30.0,  68.0);      circle.addPoint( 50.0,  -6.0);      circle.addPoint(110.0, -20.0);      circle.addPoint( 35.0,  15.0);      circle.addPoint( 45.0,  97.0);      LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();      estimator.estimate(circle);      assertTrue(estimator.getCostEvaluations() < 10);      assertTrue(estimator.getJacobianEvaluations() < 10);      double rms = estimator.getRMS(circle);      assertEquals(1.768262623567235,  FastMath.sqrt(circle.getM()) * rms,  1.0e-10);      assertEquals(69.96016176931406, circle.getRadius(), 1.0e-10);      assertEquals(96.07590211815305, circle.getX(),      1.0e-10);      assertEquals(48.13516790438953, circle.getY(),      1.0e-10);      double[][] cov = estimator.getCovariances(circle);      assertEquals(1.839, cov[0][0], 0.001);      assertEquals(0.731, cov[0][1], 0.001);      assertEquals(cov[0][1], cov[1][0], 1.0e-14);      assertEquals(0.786, cov[1][1], 0.001);      double[] errors = estimator.guessParametersErrors(circle);      assertEquals(1.384, errors[0], 0.001);      assertEquals(0.905, errors[1], 0.001);      // add perfect measurements and check errors are reduced      double cx = circle.getX();      double cy = circle.getY();      double  r = circle.getRadius();      for (double d= 0; d < 2 * FastMath.PI; d += 0.01) {          circle.addPoint(cx + r * FastMath.cos(d), cy + r * FastMath.sin(d));      }      estimator = new LevenbergMarquardtEstimator();      estimator.estimate(circle);      cov = estimator.getCovariances(circle);      assertEquals(0.004, cov[0][0], 0.001);      assertEquals(6.40e-7, cov[0][1], 1.0e-9);      assertEquals(cov[0][1], cov[1][0], 1.0e-14);      assertEquals(0.003, cov[1][1], 0.001);      errors = estimator.guessParametersErrors(circle);      assertEquals(0.004, errors[0], 0.001);      assertEquals(0.004, errors[1], 0.001);  }  public void testCircleFittingBadInit() throws EstimationException {    Circle circle = new Circle(-12, -12);    double[][] points = new double[][] {      {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},      {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},      {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},      {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},      { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},      { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},      {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},      {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},      {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},      {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},      {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},      { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},      { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},      {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},      {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},      {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},      {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},      {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},      { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},      { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},      { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},      {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},      {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},      {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},      {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},      {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},      { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},      { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},      {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}    };    for (int i = 0; i < points.length; ++i) {      circle.addPoint(points[i][0], points[i][1]);    }    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.estimate(circle);    assertTrue(estimator.getCostEvaluations() < 15);    assertTrue(estimator.getJacobianEvaluations() < 10);    assertEquals( 0.030184491196225207, estimator.getRMS(circle), 1.0e-9);    assertEquals( 0.2922350065939634,   circle.getRadius(), 1.0e-9);    assertEquals(-0.15173845023862165,  circle.getX(),      1.0e-8);    assertEquals( 0.20750021499570379,  circle.getY(),      1.0e-8);  }  public void testMath199() {      try {          QuadraticProblem problem = new QuadraticProblem();          problem.addPoint (0, -3.182591015485607, 0.0);          problem.addPoint (1, -2.5581184967730577, 4.4E-323);          problem.addPoint (2, -2.1488478161387325, 1.0);          problem.addPoint (3, -1.9122489313410047, 4.4E-323);          problem.addPoint (4, 1.7785661310051026, 0.0);          new LevenbergMarquardtEstimator().estimate(problem);          fail("an exception should have been thrown");      } catch (EstimationException ee) {          // expected behavior      }  }  private static class LinearProblem implements EstimationProblem {    public LinearProblem(LinearMeasurement[] measurements) {      this.measurements = measurements;    }    public WeightedMeasurement[] getMeasurements() {      return measurements;    }    public EstimatedParameter[] getUnboundParameters() {      return getAllParameters();    }    public EstimatedParameter[] getAllParameters() {      HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>();      for (int i = 0; i < measurements.length; ++i) {        EstimatedParameter[] parameters = measurements[i].getParameters();        for (int j = 0; j < parameters.length; ++j) {          set.add(parameters[j]);        }      }      return set.toArray(new EstimatedParameter[set.size()]);    }    private LinearMeasurement[] measurements;  }  private static class LinearMeasurement extends WeightedMeasurement {    public LinearMeasurement(double[] factors, EstimatedParameter[] parameters,                             double setPoint) {      super(1.0, setPoint);      this.factors = factors;      this.parameters = parameters;    }    @Override    public double getTheoreticalValue() {      double v = 0;      for (int i = 0; i < factors.length; ++i) {        v += factors[i] * parameters[i].getEstimate();      }      return v;    }    @Override    public double getPartial(EstimatedParameter parameter) {      for (int i = 0; i < parameters.length; ++i) {        if (parameters[i] == parameter) {          return factors[i];        }      }      return 0;    }    public EstimatedParameter[] getParameters() {      return parameters;    }    private double[] factors;    private EstimatedParameter[] parameters;    private static final long serialVersionUID = -3922448707008868580L;  }  private static class Circle implements EstimationProblem {    public Circle(double cx, double cy) {      this.cx = new EstimatedParameter("cx", cx);      this.cy = new EstimatedParameter("cy", cy);      points  = new ArrayList<PointModel>();    }    public void addPoint(double px, double py) {      points.add(new PointModel(this, px, py));    }    public int getM() {      return points.size();    }    public WeightedMeasurement[] getMeasurements() {      return points.toArray(new PointModel[points.size()]);    }    public EstimatedParameter[] getAllParameters() {      return new EstimatedParameter[] { cx, cy };    }    public EstimatedParameter[] getUnboundParameters() {      return new EstimatedParameter[] { cx, cy };    }    public double getPartialRadiusX() {      double dRdX = 0;      for (PointModel point : points) {        dRdX += point.getPartialDiX();      }      return dRdX / points.size();    }    public double getPartialRadiusY() {      double dRdY = 0;      for (PointModel point : points) {        dRdY += point.getPartialDiY();      }      return dRdY / points.size();    }   public double getRadius() {      double r = 0;      for (PointModel point : points) {        r += point.getCenterDistance();      }      return r / points.size();    }    public double getX() {      return cx.getEstimate();    }    public double getY() {      return cy.getEstimate();    }    private static class PointModel extends WeightedMeasurement {      public PointModel(Circle circle, double px, double py) {        super(1.0, 0.0);        this.px = px;        this.py = py;        this.circle = circle;      }      @Override      public double getPartial(EstimatedParameter parameter) {        if (parameter == circle.cx) {          return getPartialDiX() - circle.getPartialRadiusX();        } else if (parameter == circle.cy) {          return getPartialDiY() - circle.getPartialRadiusY();        }        return 0;      }      public double getCenterDistance() {        double dx = px - circle.cx.getEstimate();        double dy = py - circle.cy.getEstimate();        return FastMath.sqrt(dx * dx + dy * dy);      }      public double getPartialDiX() {        return (circle.cx.getEstimate() - px) / getCenterDistance();      }      public double getPartialDiY() {        return (circle.cy.getEstimate() - py) / getCenterDistance();      }      @Override      public double getTheoreticalValue() {        return getCenterDistance() - circle.getRadius();      }      private double px;      private double py;      private transient final Circle circle;      private static final long serialVersionUID = 1L;    }    private EstimatedParameter cx;    private EstimatedParameter cy;    private ArrayList<PointModel> points;  }  private static class QuadraticProblem extends SimpleEstimationProblem {      private EstimatedParameter a;      private EstimatedParameter b;      private EstimatedParameter c;      public QuadraticProblem() {          a = new EstimatedParameter("a", 0.0);          b = new EstimatedParameter("b", 0.0);          c = new EstimatedParameter("c", 0.0);          addParameter(a);          addParameter(b);          addParameter(c);      }      public void addPoint(double x, double y, double w) {          addMeasurement(new LocalMeasurement(this, x, y, w));      }      public double theoreticalValue(double x) {          return ( (a.getEstimate() * x + b.getEstimate() ) * x + c.getEstimate());      }      private double partial(double x, EstimatedParameter parameter) {          if (parameter == a) {              return x * x;          } else if (parameter == b) {              return x;          } else {              return 1.0;          }      }      private static class LocalMeasurement extends WeightedMeasurement {        private static final long serialVersionUID = 1555043155023729130L;        private final double x;        private transient final QuadraticProblem pb;          // constructor          public LocalMeasurement(QuadraticProblem pb, double x, double y, double w) {              super(w, y);              this.x = x;              this.pb = pb;          }          @Override          public double getTheoreticalValue() {              return pb.theoreticalValue(x);          }          @Override          public double getPartial(EstimatedParameter parameter) {              return pb.partial(x, parameter);          }      }  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.estimation;import org.apache.commons.math.estimation.EstimatedParameter;import org.apache.commons.math.estimation.WeightedMeasurement;import org.apache.commons.math.util.FastMath;import junit.framework.*;@Deprecatedpublic class WeightedMeasurementTest  extends TestCase {  public WeightedMeasurementTest(String name) {    super(name);    p1 = null;    p2 = null;  }  public void testConstruction() {    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);    checkValue(m.getWeight(), 3.0);    checkValue(m.getMeasuredValue(), theoretical() + 0.1);  }  public void testIgnored() {    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);    assertTrue(!m.isIgnored());    m.setIgnored(true);    assertTrue(m.isIgnored());    m.setIgnored(false);    assertTrue(!m.isIgnored());  }  public void testTheory() {    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);    checkValue(m.getTheoreticalValue(), theoretical());    checkValue(m.getResidual(), 0.1);    double oldP1 = p1.getEstimate();    p1.setEstimate(oldP1 + m.getResidual() / m.getPartial(p1));    checkValue(m.getResidual(), 0.0);    p1.setEstimate(oldP1);    checkValue(m.getResidual(), 0.1);    double oldP2 = p2.getEstimate();    p2.setEstimate(oldP2 + m.getResidual() / m.getPartial(p2));    checkValue(m.getResidual(), 0.0);    p2.setEstimate(oldP2);    checkValue(m.getResidual(), 0.1);  }  @Override  public void setUp() {    p1 = new EstimatedParameter("p1", 1.0);    p2 = new EstimatedParameter("p2", 2.0);  }  @Override  public void tearDown() {    p1 = null;    p2 = null;  }  private void checkValue(double value, double expected) {   assertTrue(FastMath.abs(value - expected) < 1.0e-10);  }  private double theoretical() {   return 3 * p1.getEstimate() - p2.getEstimate();  }  private double partial(EstimatedParameter p) {    if (p == p1) {      return 3.0;    } else if (p == p2) {      return -1.0;    } else {      return 0.0;    }  }  private static class MyMeasurement    extends WeightedMeasurement {    public MyMeasurement(double weight, double measuredValue,                         WeightedMeasurementTest testInstance) {      super(weight, measuredValue);      this.testInstance = testInstance;    }    @Override    public double getTheoreticalValue() {      return testInstance.theoretical();    }    @Override    public double getPartial(EstimatedParameter p) {      return testInstance.partial(p);    }    private transient WeightedMeasurementTest testInstance;    private static final long serialVersionUID = -246712922500792332L;  }  private EstimatedParameter p1;  private EstimatedParameter p2;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.estimation;import java.util.Arrays;import org.apache.commons.math.estimation.EstimatedParameter;import org.apache.commons.math.estimation.EstimationException;import org.apache.commons.math.estimation.EstimationProblem;import org.apache.commons.math.estimation.LevenbergMarquardtEstimator;import org.apache.commons.math.estimation.WeightedMeasurement;import org.apache.commons.math.util.FastMath;import junit.framework.*;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */@Deprecatedpublic class MinpackTest  extends TestCase {  public MinpackTest(String name) {    super(name);  }  public void testMinpackLinearFullRank() {    minpackTest(new LinearFullRankFunction(10, 5, 1.0,                                           5.0, 2.23606797749979), false);    minpackTest(new LinearFullRankFunction(50, 5, 1.0,                                           8.06225774829855, 6.70820393249937), false);  }  public void testMinpackLinearRank1() {    minpackTest(new LinearRank1Function(10, 5, 1.0,                                        291.521868819476, 1.4638501094228), false);    minpackTest(new LinearRank1Function(50, 5, 1.0,                                        3101.60039334535, 3.48263016573496), false);  }  public void testMinpackLinearRank1ZeroColsAndRows() {    minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false);    minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false);  }  public void testMinpackRosenbrok() {    minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },                                       FastMath.sqrt(24.2)), false);    minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 },                                       FastMath.sqrt(1795769.0)), false);    minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 },                                       11.0 * FastMath.sqrt(169000121.0)), false);  }  public void testMinpackHelicalValley() {    minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 },                                          50.0), false);    minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 },                                          102.95630140987), false);    minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0},                                          991.261822123701), false);  }  public void testMinpackPowellSingular() {    minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },                                           14.6628782986152), false);    minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 },                                           1270.9838708654), false);    minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 },                                           126887.903284750), false);  }  public void testMinpackFreudensteinRoth() {    minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },                                             20.0124960961895, 6.99887517584575,                                             new double[] {                                               11.4124844654993,                                               -0.896827913731509                                             }), false);    minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },                                             12432.833948863, 6.9988751744895,                                             new double[] {                                               11.4130046614746,                                               -0.896796038685958                                             }), false);    minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },                                             11426454.595762, 6.99887517242903,                                             new double[] {                                               11.4127817857886,                                               -0.89680510749204                                             }), false);  }  public void testMinpackBard() {    minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,                                 new double[] {                                   0.0824105765758334,                                   1.1330366534715,                                   2.34369463894115                                 }), false);    minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539,                                 new double[] {                                   0.840666673818329,                                   -158848033.259565,                                   -164378671.653535                                 }), false);    minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969,                                 new double[] {                                   0.840666673867645,                                   -158946167.205518,                                   -164464906.857771                                 }), false);  }  public void testMinpackKowalikOsborne() {    minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },                                           0.0728915102882945,                                           0.017535837721129,                                           new double[] {                                             0.192807810476249,                                             0.191262653354071,                                             0.123052801046931,                                             0.136053221150517                                           }), false);    minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 },                                           2.97937007555202,                                           0.032052192917937,                                           new double[] {                                             728675.473768287,                                             -14.0758803129393,                                             -32977797.7841797,                                             -20571594.1977912                                           }), false);    minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 },                                           29.9590617016037,                                           0.0175364017658228,                                           new double[] {                                             0.192948328597594,                                             0.188053165007911,                                             0.122430604321144,                                             0.134575665392506                                           }), true);  }  public void testMinpackMeyer() {    minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },                                  41153.4665543031, 9.37794514651874,                                  new double[] {                                    0.00560963647102661,                                    6181.34634628659,                                    345.223634624144                                  }), false);    minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 },                                  4168216.89130846, 792.917871779501,                                  new double[] {                                    1.42367074157994e-11,                                    33695.7133432541,                                    901.268527953801                                  }), true);  }  public void testMinpackWatson() {    minpackTest(new WatsonFunction(6, 0.0,                                   5.47722557505166, 0.0478295939097601,                                   new double[] {                                     -0.0157249615083782, 1.01243488232965,                                     -0.232991722387673,  1.26043101102818,                                     -1.51373031394421,   0.99299727291842                                   }), false);    minpackTest(new WatsonFunction(6, 10.0,                                   6433.12578950026, 0.0478295939096951,                                   new double[] {                                     -0.0157251901386677, 1.01243485860105,                                     -0.232991545843829,  1.26042932089163,                                     -1.51372776706575,   0.99299573426328                                   }), false);    minpackTest(new WatsonFunction(6, 100.0,                                   674256.040605213, 0.047829593911544,                                   new double[] {                                    -0.0157247019712586, 1.01243490925658,                                    -0.232991922761641,  1.26043292929555,                                    -1.51373320452707,   0.99299901922322                                   }), false);    minpackTest(new WatsonFunction(9, 0.0,                                   5.47722557505166, 0.00118311459212420,                                   new double[] {                                    -0.153070644166722e-4, 0.999789703934597,                                     0.0147639634910978,   0.146342330145992,                                     1.00082109454817,    -2.61773112070507,                                     4.10440313943354,    -3.14361226236241,                                     1.05262640378759                                   }), false);    minpackTest(new WatsonFunction(9, 10.0,                                   12088.127069307, 0.00118311459212513,                                   new double[] {                                   -0.153071334849279e-4, 0.999789703941234,                                    0.0147639629786217,   0.146342334818836,                                    1.00082107321386,    -2.61773107084722,                                    4.10440307655564,    -3.14361222178686,                                    1.05262639322589                                   }), false);    minpackTest(new WatsonFunction(9, 100.0,                                   1269109.29043834, 0.00118311459212384,                                   new double[] {                                    -0.153069523352176e-4, 0.999789703958371,                                     0.0147639625185392,   0.146342341096326,                                     1.00082104729164,    -2.61773101573645,                                     4.10440301427286,    -3.14361218602503,                                     1.05262638516774                                   }), false);    minpackTest(new WatsonFunction(12, 0.0,                                   5.47722557505166, 0.217310402535861e-4,                                   new double[] {                                    -0.660266001396382e-8, 1.00000164411833,                                    -0.000563932146980154, 0.347820540050756,                                    -0.156731500244233,    1.05281515825593,                                    -3.24727109519451,     7.2884347837505,                                   -10.271848098614,       9.07411353715783,                                    -4.54137541918194,     1.01201187975044                                   }), false);    minpackTest(new WatsonFunction(12, 10.0,                                   19220.7589790951, 0.217310402518509e-4,                                   new double[] {                                    -0.663710223017410e-8, 1.00000164411787,                                    -0.000563932208347327, 0.347820540486998,                                    -0.156731503955652,    1.05281517654573,                                    -3.2472711515214,      7.28843489430665,                                   -10.2718482369638,      9.07411364383733,                                    -4.54137546533666,     1.01201188830857                                   }), false);    minpackTest(new WatsonFunction(12, 100.0,                                   2018918.04462367, 0.217310402539845e-4,                                   new double[] {                                    -0.663806046485249e-8, 1.00000164411786,                                    -0.000563932210324959, 0.347820540503588,                                    -0.156731504091375,    1.05281517718031,                                    -3.24727115337025,     7.28843489775302,                                   -10.2718482410813,      9.07411364688464,                                    -4.54137546660822,     1.0120118885369                                   }), false);  }  public void testMinpackBox3Dimensional() {    minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },                                            32.1115837449572), false);  }  public void testMinpackJennrichSampson() {    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },                                            64.5856498144943, 11.1517793413499,                                            new double[] {                                             0.257819926636811, 0.257829976764542                                            }), false);  }  public void testMinpackBrownDennis() {    minpackTest(new BrownDennisFunction(20,                                        new double[] { 25.0, 5.0, -5.0, -1.0 },                                        2815.43839161816, 292.954288244866,                                        new double[] {                                         -11.59125141003, 13.2024883984741,                                         -0.403574643314272, 0.236736269844604                                        }), false);    minpackTest(new BrownDennisFunction(20,                                        new double[] { 250.0, 50.0, -50.0, -10.0 },                                        555073.354173069, 292.954270581415,                                        new double[] {                                         -11.5959274272203, 13.2041866926242,                                         -0.403417362841545, 0.236771143410386                                       }), false);    minpackTest(new BrownDennisFunction(20,                                        new double[] { 2500.0, 500.0, -500.0, -100.0 },                                        61211252.2338581, 292.954306151134,                                        new double[] {                                         -11.5902596937374, 13.2020628854665,                                         -0.403688070279258, 0.236665033746463                                        }), false);  }  public void testMinpackChebyquad() {    minpackTest(new ChebyquadFunction(1, 8, 1.0,                                      1.88623796907732, 1.88623796907732,                                      new double[] { 0.5 }), false);    minpackTest(new ChebyquadFunction(1, 8, 10.0,                                      5383344372.34005, 1.88424820499951,                                      new double[] { 0.9817314924684 }), false);    minpackTest(new ChebyquadFunction(1, 8, 100.0,                                      0.118088726698392e19, 1.88424820499347,                                      new double[] { 0.9817314852934 }), false);    minpackTest(new ChebyquadFunction(8, 8, 1.0,                                      0.196513862833975, 0.0593032355046727,                                      new double[] {                                        0.0431536648587336, 0.193091637843267,                                        0.266328593812698,  0.499999334628884,                                        0.500000665371116,  0.733671406187302,                                        0.806908362156733,  0.956846335141266                                      }), false);    minpackTest(new ChebyquadFunction(9, 9, 1.0,                                      0.16994993465202, 0.0,                                      new double[] {                                        0.0442053461357828, 0.199490672309881,                                        0.23561910847106,   0.416046907892598,                                        0.5,                0.583953092107402,                                        0.764380891528940,  0.800509327690119,                                        0.955794653864217                                      }), false);    minpackTest(new ChebyquadFunction(10, 10, 1.0,                                      0.183747831178711, 0.0806471004038253,                                      new double[] {                                        0.0596202671753563, 0.166708783805937,                                        0.239171018813509,  0.398885290346268,                                        0.398883667870681,  0.601116332129320,                                        0.60111470965373,   0.760828981186491,                                        0.833291216194063,  0.940379732824644                                      }), false);  }  public void testMinpackBrownAlmostLinear() {    minpackTest(new BrownAlmostLinearFunction(10, 0.5,                                              16.5302162063499, 0.0,                                              new double[] {                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 1.20569696650138                                              }), false);    minpackTest(new BrownAlmostLinearFunction(10, 5.0,                                              9765624.00089211, 0.0,                                              new double[] {                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 1.20569696650135                                              }), false);    minpackTest(new BrownAlmostLinearFunction(10, 50.0,                                              0.9765625e17, 0.0,                                              new double[] {                                                1.0, 1.0, 1.0, 1.0, 1.0,                                                1.0, 1.0, 1.0, 1.0, 1.0                                              }), false);    minpackTest(new BrownAlmostLinearFunction(30, 0.5,                                              83.476044467848, 0.0,                                              new double[] {                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 1.06737350671578                                              }), false);    minpackTest(new BrownAlmostLinearFunction(40, 0.5,                                              128.026364472323, 0.0,                                              new double[] {                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                0.999999999999121                                              }), false);    }  public void testMinpackOsborne1() {      minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },                                       0.937564021037838, 0.00739249260904843,                                       new double[] {                                         0.375410049244025, 1.93584654543108,                                        -1.46468676748716, 0.0128675339110439,                                         0.0221227011813076                                       }), false);    }  public void testMinpackOsborne2() {    minpackTest(new Osborne2Function(new double[] {                                       1.3, 0.65, 0.65, 0.7, 0.6,                                       3.0, 5.0, 7.0, 2.0, 4.5, 5.5                                     },                                     1.44686540984712, 0.20034404483314,                                     new double[] {                                       1.30997663810096,  0.43155248076,                                       0.633661261602859, 0.599428560991695,                                       0.754179768272449, 0.904300082378518,                                       1.36579949521007, 4.82373199748107,                                       2.39868475104871, 4.56887554791452,                                       5.67534206273052                                     }), false);  }  private void minpackTest(MinpackFunction function, boolean exceptionExpected) {    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();    estimator.setMaxCostEval(100 * (function.getN() + 1));    estimator.setCostRelativeTolerance(FastMath.sqrt(2.22044604926e-16));    estimator.setParRelativeTolerance(FastMath.sqrt(2.22044604926e-16));    estimator.setOrthoTolerance(2.22044604926e-16);    assertTrue(function.checkTheoreticalStartCost(estimator.getRMS(function)));    try {      estimator.estimate(function);      assertFalse(exceptionExpected);    } catch (EstimationException lsse) {      assertTrue(exceptionExpected);    }    assertTrue(function.checkTheoreticalMinCost(estimator.getRMS(function)));    assertTrue(function.checkTheoreticalMinParams());  }  private static abstract class MinpackFunction implements EstimationProblem {    protected MinpackFunction(int m,                              double[] startParams,                              double   theoreticalStartCost,                              double   theoreticalMinCost,                              double[] theoreticalMinParams) {      this.m = m;      this.n = startParams.length;      parameters = new EstimatedParameter[n];      for (int i = 0; i < n; ++i) {        parameters[i] = new EstimatedParameter("p" + i, startParams[i]);      }      this.theoreticalStartCost = theoreticalStartCost;      this.theoreticalMinCost   = theoreticalMinCost;      this.theoreticalMinParams = theoreticalMinParams;      this.costAccuracy         = 1.0e-8;      this.paramsAccuracy       = 1.0e-5;    }    protected static double[] buildArray(int n, double x) {      double[] array = new double[n];      Arrays.fill(array, x);      return array;    }    protected void setCostAccuracy(double costAccuracy) {      this.costAccuracy = costAccuracy;    }    protected void setParamsAccuracy(double paramsAccuracy) {      this.paramsAccuracy = paramsAccuracy;    }    public int getN() {      return parameters.length;    }    public boolean checkTheoreticalStartCost(double rms) {      double threshold = costAccuracy * (1.0 + theoreticalStartCost);      return FastMath.abs(FastMath.sqrt(m) * rms - theoreticalStartCost) <= threshold;    }    public boolean checkTheoreticalMinCost(double rms) {      double threshold = costAccuracy * (1.0 + theoreticalMinCost);     return FastMath.abs(FastMath.sqrt(m) * rms - theoreticalMinCost) <= threshold;    }    public boolean checkTheoreticalMinParams() {      if (theoreticalMinParams != null) {        for (int i = 0; i < theoreticalMinParams.length; ++i) {          double mi = theoreticalMinParams[i];          double vi = parameters[i].getEstimate();          if (FastMath.abs(mi - vi) > (paramsAccuracy * (1.0 + FastMath.abs(mi)))) {            return false;          }        }      }      return true;    }    public WeightedMeasurement[] getMeasurements() {      WeightedMeasurement[] measurements = new WeightedMeasurement[m];      for (int i = 0; i < m; ++i) {        measurements[i] = new MinpackMeasurement(this, i);      }      return measurements;    }    public EstimatedParameter[] getUnboundParameters() {      return parameters;    }    public EstimatedParameter[] getAllParameters() {      return parameters;    }    protected abstract double[][] getJacobian();    protected abstract double[] getResiduals();    private static class MinpackMeasurement extends WeightedMeasurement {      public MinpackMeasurement(MinpackFunction f, int index) {        super(1.0, 0.0);        this.index = index;        this.f = f;      }      @Override      public double getTheoreticalValue() {        // this is obviously NOT efficient as we recompute the whole vector        // each time we need only one element, but it is only for test        // purposes and is simpler to check.        // This implementation should NOT be taken as an example, it is ugly!        return f.getResiduals()[index];      }      @Override      public double getPartial(EstimatedParameter parameter) {        // this is obviously NOT efficient as we recompute the whole jacobian        // each time we need only one element, but it is only for test        // purposes and is simpler to check.        // This implementation should NOT be taken as an example, it is ugly!        for (int j = 0; j < f.n; ++j) {          if (parameter == f.parameters[j]) {            return f.getJacobian()[index][j];          }        }        return 0;      }      private int index;      private transient final MinpackFunction f;      private static final long serialVersionUID = 1L;    }    protected int                  n;    protected int                  m;    protected EstimatedParameter[] parameters;    protected double               theoreticalStartCost;    protected double               theoreticalMinCost;    protected double[]             theoreticalMinParams;    protected double               costAccuracy;    protected double               paramsAccuracy;  }  private static class LinearFullRankFunction extends MinpackFunction {    public LinearFullRankFunction(int m, int n, double x0,                                  double theoreticalStartCost,                                  double theoreticalMinCost) {      super(m, buildArray(n, x0), theoreticalStartCost,            theoreticalMinCost, buildArray(n, -1.0));    }    @Override    protected double[][] getJacobian() {      double t = 2.0 / m;      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = (i == j) ? (1 - t) : -t;        }      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double sum = 0;      for (int i = 0; i < n; ++i) {        sum += parameters[i].getEstimate();      }      double t  = 1 + 2 * sum / m;      double[] f = new double[m];      for (int i = 0; i < n; ++i) {        f[i] = parameters[i].getEstimate() - t;      }      Arrays.fill(f, n, m, -t);      return f;    }  }  private static class LinearRank1Function extends MinpackFunction {    public LinearRank1Function(int m, int n, double x0,                                  double theoreticalStartCost,                                  double theoreticalMinCost) {      super(m, buildArray(n, x0), theoreticalStartCost, theoreticalMinCost, null);    }    @Override    protected double[][] getJacobian() {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = (i + 1) * (j + 1);        }      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double[] f = new double[m];      double sum = 0;      for (int i = 0; i < n; ++i) {        sum += (i + 1) * parameters[i].getEstimate();      }      for (int i = 0; i < m; ++i) {        f[i] = (i + 1) * sum - 1;      }      return f;    }  }  private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction {    public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {      super(m, buildArray(n, x0),            FastMath.sqrt(m + (n+1)*(n-2)*(m-2)*(m-1) * ((n+1)*(n-2)*(2*m-3) - 12) / 24.0),            FastMath.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),            null);    }    @Override    protected double[][] getJacobian() {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        jacobian[i][0] = 0;        for (int j = 1; j < (n - 1); ++j) {          if (i == 0) {            jacobian[i][j] = 0;          } else if (i != (m - 1)) {            jacobian[i][j] = i * (j + 1);          } else {            jacobian[i][j] = 0;          }        }        jacobian[i][n - 1] = 0;      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double[] f = new double[m];      double sum = 0;      for (int i = 1; i < (n - 1); ++i) {        sum += (i + 1) * parameters[i].getEstimate();      }      for (int i = 0; i < (m - 1); ++i) {        f[i] = i * sum - 1;      }      f[m - 1] = -1;      return f;    }  }  private static class RosenbrockFunction extends MinpackFunction {    public RosenbrockFunction(double[] startParams, double theoreticalStartCost) {      super(2, startParams, theoreticalStartCost, 0.0, buildArray(2, 1.0));    }    @Override    protected double[][] getJacobian() {      double x1 = parameters[0].getEstimate();      return new double[][] { { -20 * x1, 10 }, { -1, 0 } };    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      return new double[] { 10 * (x2 - x1 * x1), 1 - x1 };    }  }  private static class HelicalValleyFunction extends MinpackFunction {    public HelicalValleyFunction(double[] startParams,                                 double theoreticalStartCost) {      super(3, startParams, theoreticalStartCost, 0.0,            new double[] { 1.0, 0.0, 0.0 });    }    @Override    protected double[][] getJacobian() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double tmpSquare = x1 * x1 + x2 * x2;      double tmp1 = twoPi * tmpSquare;      double tmp2 = FastMath.sqrt(tmpSquare);      return new double[][] {        {  100 * x2 / tmp1, -100 * x1 / tmp1, 10 },        { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 },        { 0, 0, 1 }      };    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double tmp1;      if (x1 == 0) {        tmp1 = (x2 >= 0) ? 0.25 : -0.25;      } else {        tmp1 = FastMath.atan(x2 / x1) / twoPi;        if (x1 < 0) {          tmp1 += 0.5;        }      }      double tmp2 = FastMath.sqrt(x1 * x1 + x2 * x2);      return new double[] {        10.0 * (x3 - 10 * tmp1),        10.0 * (tmp2 - 1),        x3      };    }    private static final double twoPi = 2.0 * FastMath.PI;  }  private static class PowellSingularFunction extends MinpackFunction {    public PowellSingularFunction(double[] startParams,                                  double theoreticalStartCost) {      super(4, startParams, theoreticalStartCost, 0.0, buildArray(4, 0.0));    }    @Override    protected double[][] getJacobian() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double x4 = parameters[3].getEstimate();      return new double[][] {        { 1, 10, 0, 0 },        { 0, 0, sqrt5, -sqrt5 },        { 0, 2 * (x2 - 2 * x3), -4 * (x2 - 2 * x3), 0 },        { 2 * sqrt10 * (x1 - x4), 0, 0, -2 * sqrt10 * (x1 - x4) }      };    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double x4 = parameters[3].getEstimate();      return new double[] {        x1 + 10 * x2,        sqrt5 * (x3 - x4),        (x2 - 2 * x3) * (x2 - 2 * x3),        sqrt10 * (x1 - x4) * (x1 - x4)      };    }    private static final double sqrt5  = FastMath.sqrt( 5.0);    private static final double sqrt10 = FastMath.sqrt(10.0);  }  private static class FreudensteinRothFunction extends MinpackFunction {    public FreudensteinRothFunction(double[] startParams,                                    double theoreticalStartCost,                                    double theoreticalMinCost,                                    double[] theoreticalMinParams) {      super(2, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    @Override    protected double[][] getJacobian() {      double x2 = parameters[1].getEstimate();      return new double[][] {        { 1, x2 * (10 - 3 * x2) -  2 },        { 1, x2 * ( 2 + 3 * x2) - 14, }      };    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      return new double[] {       -13.0 + x1 + ((5.0 - x2) * x2 -  2.0) * x2,       -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2      };    }  }  private static class BardFunction extends MinpackFunction {    public BardFunction(double x0,                        double theoreticalStartCost,                        double theoreticalMinCost,                        double[] theoreticalMinParams) {      super(15, buildArray(3, x0), theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    @Override    protected double[][] getJacobian() {      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp1 = i  + 1;        double tmp2 = 15 - i;        double tmp3 = (i <= 7) ? tmp1 : tmp2;        double tmp4 = x2 * tmp2 + x3 * tmp3;        tmp4 *= tmp4;        jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 };      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double tmp1 = i + 1;        double tmp2 = 15 - i;        double tmp3 = (i <= 7) ? tmp1 : tmp2;        f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3));      }      return f;    }    private static final double[] y = {      0.14, 0.18, 0.22, 0.25, 0.29,      0.32, 0.35, 0.39, 0.37, 0.58,      0.73, 0.96, 1.34, 2.10, 4.39    };  }  private static class KowalikOsborneFunction extends MinpackFunction {    public KowalikOsborneFunction(double[] startParams,                                  double theoreticalStartCost,                                  double theoreticalMinCost,                                  double[] theoreticalMinParams) {      super(11, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);      if (theoreticalStartCost > 20.0) {        setCostAccuracy(2.0e-4);        setParamsAccuracy(5.0e-3);      }    }    @Override    protected double[][] getJacobian() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double   x4 = parameters[3].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp = v[i] * (v[i] + x3) + x4;        double j1  = -v[i] * (v[i] + x2) / tmp;        double j2  = -v[i] * x1 / tmp;        double j3  = j1 * j2;        double j4  = j3 / v[i];        jacobian[i] = new double[] { j1, j2, j3, j4 };      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double x4 = parameters[3].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4);      }      return f;    }    private static final double[] v = {      4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625    };    private static final double[] y = {      0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627,      0.0456, 0.0342, 0.0323, 0.0235, 0.0246    };  }  private static class MeyerFunction extends MinpackFunction {    public MeyerFunction(double[] startParams,                         double theoreticalStartCost,                         double theoreticalMinCost,                         double[] theoreticalMinParams) {      super(16, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);      if (theoreticalStartCost > 1.0e6) {        setCostAccuracy(7.0e-3);        setParamsAccuracy(2.0e-2);      }    }    @Override    protected double[][] getJacobian() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = 5.0 * (i + 1) + 45.0 + x3;        double tmp1 = x2 / temp;        double tmp2 = FastMath.exp(tmp1);        double tmp3 = x1 * tmp2 / temp;        jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 };      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        f[i] = x1 * FastMath.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];      }     return f;    }    private static final double[] y = {      34780.0, 28610.0, 23650.0, 19630.0,      16370.0, 13720.0, 11540.0,  9744.0,       8261.0,  7030.0,  6005.0,  5147.0,       4427.0,  3820.0,  3307.0,  2872.0    };  }  private static class WatsonFunction extends MinpackFunction {    public WatsonFunction(int n, double x0,                          double theoreticalStartCost,                          double theoreticalMinCost,                          double[] theoreticalMinParams) {      super(31, buildArray(n, x0), theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    @Override    protected double[][] getJacobian() {      double[][] jacobian = new double[m][];      for (int i = 0; i < (m - 2); ++i) {        double div = (i + 1) / 29.0;        double s2  = 0.0;        double dx  = 1.0;        for (int j = 0; j < n; ++j) {          s2 += dx * parameters[j].getEstimate();          dx *= div;        }        double temp= 2 * div * s2;        dx = 1.0 / div;        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = dx * (j - temp);          dx *= div;        }      }      jacobian[m - 2]    = new double[n];      jacobian[m - 2][0] = 1;      jacobian[m - 1]   = new double[n];      jacobian[m - 1][0]= -2 * parameters[0].getEstimate();      jacobian[m - 1][1]= 1;      return jacobian;    }    @Override    protected double[] getResiduals() {     double[] f = new double[m];     for (int i = 0; i < (m - 2); ++i) {       double div = (i + 1) / 29.0;       double s1 = 0;       double dx = 1;       for (int j = 1; j < n; ++j) {         s1 += j * dx * parameters[j].getEstimate();         dx *= div;       }       double s2 =0;       dx =1;       for (int j = 0; j < n; ++j) {         s2 += dx * parameters[j].getEstimate();         dx *= div;       }       f[i] = s1 - s2 * s2 - 1;     }     double x1 = parameters[0].getEstimate();     double x2 = parameters[1].getEstimate();     f[m - 2] = x1;     f[m - 1] = x2 - x1 * x1 - 1;     return f;    }  }  private static class Box3DimensionalFunction extends MinpackFunction {    public Box3DimensionalFunction(int m, double[] startParams,                                   double theoreticalStartCost) {      super(m, startParams, theoreticalStartCost,            0.0, new double[] { 1.0, 10.0, 1.0 });   }    @Override    protected double[][] getJacobian() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp = (i + 1) / 10.0;        jacobian[i] = new double[] {          -tmp * FastMath.exp(-tmp * x1),           tmp * FastMath.exp(-tmp * x2),          FastMath.exp(-i - 1) - FastMath.exp(-tmp)        };      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double tmp = (i + 1) / 10.0;        f[i] = FastMath.exp(-tmp * x1) - FastMath.exp(-tmp * x2)             + (FastMath.exp(-i - 1) - FastMath.exp(-tmp)) * x3;      }      return f;    }  }  private static class JennrichSampsonFunction extends MinpackFunction {    public JennrichSampsonFunction(int m, double[] startParams,                                   double theoreticalStartCost,                                   double theoreticalMinCost,                                   double[] theoreticalMinParams) {      super(m, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    @Override    protected double[][] getJacobian() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double t = i + 1;        jacobian[i] = new double[] { -t * FastMath.exp(t * x1), -t * FastMath.exp(t * x2) };      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = i + 1;        f[i] = 2 + 2 * temp - FastMath.exp(temp * x1) - FastMath.exp(temp * x2);      }      return f;    }  }  private static class BrownDennisFunction extends MinpackFunction {    public BrownDennisFunction(int m, double[] startParams,                               double theoreticalStartCost,                               double theoreticalMinCost,                               double[] theoreticalMinParams) {      super(m, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);      setCostAccuracy(2.5e-8);    }    @Override    protected double[][] getJacobian() {      double   x1 = parameters[0].getEstimate();      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double   x4 = parameters[3].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = (i + 1) / 5.0;        double ti   = FastMath.sin(temp);        double tmp1 = x1 + temp * x2 - FastMath.exp(temp);        double tmp2 = x3 + ti   * x4 - FastMath.cos(temp);        jacobian[i] = new double[] {          2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2        };      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double x4 = parameters[3].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = (i + 1) / 5.0;        double tmp1 = x1 + temp * x2 - FastMath.exp(temp);        double tmp2 = x3 + FastMath.sin(temp) * x4 - FastMath.cos(temp);        f[i] = tmp1 * tmp1 + tmp2 * tmp2;      }      return f;    }  }  private static class ChebyquadFunction extends MinpackFunction {    private static double[] buildChebyquadArray(int n, double factor) {      double[] array = new double[n];      double inv = factor / (n + 1);      for (int i = 0; i < n; ++i) {        array[i] = (i + 1) * inv;      }      return array;    }    public ChebyquadFunction(int n, int m, double factor,                             double theoreticalStartCost,                             double theoreticalMinCost,                             double[] theoreticalMinParams) {      super(m, buildChebyquadArray(n, factor), theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    @Override    protected double[][] getJacobian() {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];      }      double dx = 1.0 / n;      for (int j = 0; j < n; ++j) {        double tmp1 = 1;        double tmp2 = 2 * parameters[j].getEstimate() - 1;        double temp = 2 * tmp2;        double tmp3 = 0;        double tmp4 = 2;        for (int i = 0; i < m; ++i) {          jacobian[i][j] = dx * tmp4;          double ti = 4 * tmp2 + temp * tmp4 - tmp3;          tmp3 = tmp4;          tmp4 = ti;          ti   = temp * tmp2 - tmp1;          tmp1 = tmp2;          tmp2 = ti;        }      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double[] f = new double[m];      for (int j = 0; j < n; ++j) {        double tmp1 = 1;        double tmp2 = 2 * parameters[j].getEstimate() - 1;        double temp = 2 * tmp2;        for (int i = 0; i < m; ++i) {          f[i] += tmp2;          double ti = temp * tmp2 - tmp1;          tmp1 = tmp2;          tmp2 = ti;        }      }      double dx = 1.0 / n;      boolean iev = false;      for (int i = 0; i < m; ++i) {        f[i] *= dx;        if (iev) {          f[i] += 1.0 / (i * (i + 2));        }        iev = ! iev;      }      return f;    }  }  private static class BrownAlmostLinearFunction extends MinpackFunction {    public BrownAlmostLinearFunction(int m, double factor,                                     double theoreticalStartCost,                                     double theoreticalMinCost,                                     double[] theoreticalMinParams) {      super(m, buildArray(m, factor), theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    @Override    protected double[][] getJacobian() {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];      }      double prod = 1;      for (int j = 0; j < n; ++j) {        prod *= parameters[j].getEstimate();        for (int i = 0; i < n; ++i) {          jacobian[i][j] = 1;        }        jacobian[j][j] = 2;      }      for (int j = 0; j < n; ++j) {        EstimatedParameter vj = parameters[j];        double temp = vj.getEstimate();        if (temp == 0) {          temp = 1;          prod = 1;          for (int k = 0; k < n; ++k) {            if (k != j) {              prod *= parameters[k].getEstimate();            }          }        }        jacobian[n - 1][j] = prod / temp;      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double[] f = new double[m];      double sum  = -(n + 1);      double prod = 1;      for (int j = 0; j < n; ++j) {        sum  += parameters[j].getEstimate();        prod *= parameters[j].getEstimate();      }      for (int i = 0; i < n; ++i) {        f[i] = parameters[i].getEstimate() + sum;      }      f[n - 1] = prod - 1;      return f;    }  }  private static class Osborne1Function extends MinpackFunction {    public Osborne1Function(double[] startParams,                            double theoreticalStartCost,                            double theoreticalMinCost,                            double[] theoreticalMinParams) {      super(33, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    @Override    protected double[][] getJacobian() {      double   x2 = parameters[1].getEstimate();      double   x3 = parameters[2].getEstimate();      double   x4 = parameters[3].getEstimate();      double   x5 = parameters[4].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = 10.0 * i;        double tmp1 = FastMath.exp(-temp * x4);        double tmp2 = FastMath.exp(-temp * x5);        jacobian[i] = new double[] {          -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2        };      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double x1 = parameters[0].getEstimate();      double x2 = parameters[1].getEstimate();      double x3 = parameters[2].getEstimate();      double x4 = parameters[3].getEstimate();      double x5 = parameters[4].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = 10.0 * i;        double tmp1 = FastMath.exp(-temp * x4);        double tmp2 = FastMath.exp(-temp * x5);        f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2);      }      return f;    }    private static final double[] y = {      0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751,      0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490,      0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406    };  }  private static class Osborne2Function extends MinpackFunction {    public Osborne2Function(double[] startParams,                            double theoreticalStartCost,                            double theoreticalMinCost,                            double[] theoreticalMinParams) {      super(65, startParams, theoreticalStartCost,            theoreticalMinCost, theoreticalMinParams);    }    @Override    protected double[][] getJacobian() {      double   x01 = parameters[0].getEstimate();      double   x02 = parameters[1].getEstimate();      double   x03 = parameters[2].getEstimate();      double   x04 = parameters[3].getEstimate();      double   x05 = parameters[4].getEstimate();      double   x06 = parameters[5].getEstimate();      double   x07 = parameters[6].getEstimate();      double   x08 = parameters[7].getEstimate();      double   x09 = parameters[8].getEstimate();      double   x10 = parameters[9].getEstimate();      double   x11 = parameters[10].getEstimate();      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = i / 10.0;        double tmp1 = FastMath.exp(-x05 * temp);        double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09));        double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10));        double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11));        jacobian[i] = new double[] {          -tmp1,          -tmp2,          -tmp3,          -tmp4,          temp * x01 * tmp1,          x02 * (temp - x09) * (temp - x09) * tmp2,          x03 * (temp - x10) * (temp - x10) * tmp3,          x04 * (temp - x11) * (temp - x11) * tmp4,          -2 * x02 * x06 * (temp - x09) * tmp2,          -2 * x03 * x07 * (temp - x10) * tmp3,          -2 * x04 * x08 * (temp - x11) * tmp4        };      }      return jacobian;    }    @Override    protected double[] getResiduals() {      double x01 = parameters[0].getEstimate();      double x02 = parameters[1].getEstimate();      double x03 = parameters[2].getEstimate();      double x04 = parameters[3].getEstimate();      double x05 = parameters[4].getEstimate();      double x06 = parameters[5].getEstimate();      double x07 = parameters[6].getEstimate();      double x08 = parameters[7].getEstimate();      double x09 = parameters[8].getEstimate();      double x10 = parameters[9].getEstimate();      double x11 = parameters[10].getEstimate();      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = i / 10.0;        double tmp1 = FastMath.exp(-x05 * temp);        double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09));        double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10));        double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11));        f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4);      }      return f;    }    private static final double[] y = {      1.366, 1.191, 1.112, 1.013, 0.991,      0.885, 0.831, 0.847, 0.786, 0.725,      0.746, 0.679, 0.608, 0.655, 0.616,      0.606, 0.602, 0.626, 0.651, 0.724,      0.649, 0.649, 0.694, 0.644, 0.624,      0.661, 0.612, 0.558, 0.533, 0.495,      0.500, 0.423, 0.395, 0.375, 0.372,      0.391, 0.396, 0.405, 0.428, 0.429,      0.523, 0.562, 0.607, 0.653, 0.672,      0.708, 0.633, 0.668, 0.645, 0.632,      0.591, 0.559, 0.597, 0.625, 0.739,      0.710, 0.729, 0.720, 0.636, 0.581,      0.428, 0.292, 0.162, 0.098, 0.054    };  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class InvalidMatrixExceptionTest extends TestCase {    public void testConstructorMessage(){        String msg = "message";        InvalidMatrixException ex = new InvalidMatrixException(msg);        assertEquals(msg, ex.getMessage());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.TestCase;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.linear.RealVector.Entry;import org.apache.commons.math.util.FastMath;import java.util.Iterator;import java.util.Random;/** * */public class AbstractRealVectorTest extends TestCase {    private double[] vec1 = { 1d, 2d, 3d, 4d, 5d };    private double[] vec2 = { -3d, 0d, 0d, 2d, 1d };    private static class TestVectorImpl extends AbstractRealVector {        private double[] values;        TestVectorImpl(double[] values) {            this.values = values;        }        @Override        public double[] getData() { return values; }        @Override        public AbstractRealVector copy() {            return new TestVectorImpl(values.clone());        }        UnsupportedOperationException unsupported() {            return new UnsupportedOperationException("Test implementation only supports methods necessary for testing");        }        @Override        public RealVector add(RealVector v) throws IllegalArgumentException {            RealVector result = new ArrayRealVector(v);            return result.add(this);        }        @Override        public RealVector subtract(RealVector v) throws IllegalArgumentException {            RealVector result = new ArrayRealVector(v);            return result.subtract(this).mapMultiplyToSelf(-1);        }        @Override        public RealVector mapAddToSelf(double d) {            for(int i=0; i<values.length; i++) {                values[i] += d;            }            return this;        }        @Override        public RealVector mapSubtractToSelf(double d) {            for(int i=0; i<values.length; i++) {                values[i] -= d;            }            return this;        }        @Override        public RealVector mapMultiplyToSelf(double d) {            for(int i=0; i<values.length; i++) {                values[i] *= d;            }            return this;        }        @Override        public RealVector mapDivideToSelf(double d) {            for(int i=0; i<values.length; i++) {                values[i] /= d;            }            return this;        }        @Override        public RealVector mapPowToSelf(double d) {            for(int i=0; i<values.length; i++) {                values[i] = FastMath.pow(values[i], d);            }            return this;        }        @Override        public RealVector mapInvToSelf() {            for(int i=0; i<values.length; i++) {                values[i] = 1/values[i];            }            return this;        }        public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public double dotProduct(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public double getNorm() {            throw unsupported();        }        @Override        public double getL1Norm() {            throw unsupported();        }        @Override        public double getLInfNorm() {            throw unsupported();        }        public RealVector projection(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public double getEntry(int index) throws MatrixIndexException {            return values[index];        }        public void setEntry(int index, double value) throws MatrixIndexException {            values[index] = value;        }        public int getDimension() {            return values.length;        }        public RealVector append(RealVector v) {            throw unsupported();        }        public RealVector append(double d) {            throw unsupported();        }        public RealVector append(double[] a) {            throw unsupported();        }        public RealVector getSubVector(int index, int n) throws MatrixIndexException {            throw unsupported();        }        public boolean isNaN() {            throw unsupported();        }        public boolean isInfinite() {            throw unsupported();        }    }    private static void assertEquals(double[] d1, double[] d2) {        assertEquals(d1.length, d2.length);        for(int i=0; i<d1.length; i++) assertEquals(d1[i], d2[i]);    }    public void testMap() throws Exception {        double[] vec1Squared = { 1d, 4d, 9d, 16d, 25d };        RealVector v = new TestVectorImpl(vec1.clone());        RealVector w = v.map(new UnivariateRealFunction() { public double value(double x) { return x * x; } });        assertEquals(vec1Squared, w.getData());    }    public void testIterator() throws Exception {        RealVector v = new TestVectorImpl(vec2.clone());        Entry e;        int i = 0;        for(Iterator<Entry> it = v.iterator(); it.hasNext() && (e = it.next()) != null; i++) {            assertEquals(vec2[i], e.getValue());        }    }    public void testSparseIterator() throws Exception {        RealVector v = new TestVectorImpl(vec2.clone());        Entry e;        int i = 0;        double[] nonDefaultV2 = { -3d, 2d, 1d };        for(Iterator<Entry> it = v.sparseIterator(); it.hasNext() && (e = it.next()) != null; i++) {            assertEquals(nonDefaultV2[i], e.getValue());        }        double [] onlyOne = {0d, 1.0, 0d};        v = new TestVectorImpl(onlyOne);        for(Iterator<Entry> it = v.sparseIterator(); it.hasNext() && (e = it.next()) != null; ) {            assertEquals(onlyOne[1], e.getValue());        }            }    public void testClone() throws Exception {        double[] d = new double[1000000];        Random r = new Random(1234);        for(int i=0;i<d.length; i++) d[i] = r.nextDouble();        assertTrue(new ArrayRealVector(d).getNorm() > 0);        double[] c = d.clone();        c[0] = 1;        assertNotSame(c[0], d[0]);        d[0] = 1;        assertEquals(new ArrayRealVector(d).getNorm(), new ArrayRealVector(c).getNorm());        long cloneTime = 0;        long setAndAddTime = 0;        for(int i=0; i<10; i++) {          long start = System.nanoTime();          double[] v = d.clone();          for(int j=0; j<v.length; j++) v[j] += 1234.5678;          if(i > 4) cloneTime += System.nanoTime() - start;          start = System.nanoTime();          v = new double[d.length];          for(int j=0; j<v.length; j++) v[j] = d[j] + 1234.5678;          if(i > 4) setAndAddTime += System.nanoTime() - start;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Random;import junit.framework.TestCase;public class QRSolverTest extends TestCase {    double[][] testData3x3NonSingular = {            { 12, -51,   4 },            {  6, 167, -68 },            { -4,  24, -41 }    };    double[][] testData3x3Singular = {            { 1, 2,  2 },            { 2, 4,  6 },            { 4, 8, 12 }    };    double[][] testData3x4 = {            { 12, -51,   4, 1 },            {  6, 167, -68, 2 },            { -4,  24, -41, 3 }    };    double[][] testData4x3 = {            { 12, -51,   4 },            {  6, 167, -68 },            { -4,  24, -41 },            { -5,  34,   7 }    };    public QRSolverTest(String name) {        super(name);    }    /** test rank */    public void testRank() {        DecompositionSolver solver =            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();        assertTrue(solver.isNonSingular());        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();        assertFalse(solver.isNonSingular());        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x4)).getSolver();        assertTrue(solver.isNonSingular());        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData4x3)).getSolver();        assertTrue(solver.isNonSingular());    }    /** test solve dimension errors */    public void testSolveDimensionErrors() {        DecompositionSolver solver =            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);        try {            solver.solve(b);            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumn(0));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumnVector(0));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test solve rank errors */    public void testSolveRankErrors() {        DecompositionSolver solver =            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);        try {            solver.solve(b);            fail("an exception should have been thrown");        } catch (InvalidMatrixException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumn(0));            fail("an exception should have been thrown");        } catch (InvalidMatrixException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumnVector(0));            fail("an exception should have been thrown");        } catch (InvalidMatrixException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test solve */    public void testSolve() {        QRDecomposition decomposition =            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular));        DecompositionSolver solver = decomposition.getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                { -102, 12250 }, { 544, 24500 }, { 167, -36750 }        });        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                { 1, 2515 }, { 2, 422 }, { -3, 898 }        });        // using RealMatrix        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 2.0e-16 * xRef.getNorm());        // using double[]        for (int i = 0; i < b.getColumnDimension(); ++i) {            final double[] x = solver.solve(b.getColumn(i));            final double error = new ArrayRealVector(x).subtract(xRef.getColumnVector(i)).getNorm();            assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());        }        // using ArrayRealVector        for (int i = 0; i < b.getColumnDimension(); ++i) {            final RealVector x = solver.solve(b.getColumnVector(i));            final double error = x.subtract(xRef.getColumnVector(i)).getNorm();            assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());        }        // using RealVector with an alternate implementation        for (int i = 0; i < b.getColumnDimension(); ++i) {            ArrayRealVectorTest.RealVectorTestImpl v =                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));            final RealVector x = solver.solve(v);            final double error = x.subtract(xRef.getColumnVector(i)).getNorm();            assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());        }    }    public void testOverdetermined() {        final Random r    = new Random(5559252868205245l);        int          p    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        int          q    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        RealMatrix   a    = createTestMatrix(r, p, q);        RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);        // build a perturbed system: A.X + noise = B        RealMatrix b = a.multiply(xRef);        final double noise = 0.001;        b.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {            @Override            public double visit(int row, int column, double value) {                return value * (1.0 + noise * (2 * r.nextDouble() - 1));            }        });        // despite perturbation, the least square solution should be pretty good        RealMatrix x = new QRDecompositionImpl(a).getSolver().solve(b);        assertEquals(0, x.subtract(xRef).getNorm(), 0.01 * noise * p * q);    }    public void testUnderdetermined() {        final Random r    = new Random(42185006424567123l);        int          p    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int          q    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        RealMatrix   a    = createTestMatrix(r, p, q);        RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);        RealMatrix   b    = a.multiply(xRef);        RealMatrix   x = new QRDecompositionImpl(a).getSolver().solve(b);        // too many equations, the system cannot be solved at all        assertTrue(x.subtract(xRef).getNorm() / (p * q) > 0.01);        // the last unknown should have been set to 0        assertEquals(0.0, x.getSubMatrix(p, q - 1, 0, x.getColumnDimension() - 1).getNorm());    }    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {        RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);        m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){            @Override            public double visit(int row, int column, double value)                throws MatrixVisitorException {                return 2.0 * r.nextDouble() - 1.0;            }        });        return m;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.apache.commons.math.linear.BiDiagonalTransformer;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class BiDiagonalTransformerTest {    private double[][] testSquare = {            { 24.0 / 25.0, 43.0 / 25.0 },            { 57.0 / 25.0, 24.0 / 25.0 }    };    private double[][] testNonSquare = {        {  -540.0 / 625.0,  963.0 / 625.0, -216.0 / 625.0 },        { -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 },        {  -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 },        {  -360.0 / 625.0,  192.0 / 625.0, 1756.0 / 625.0 },    };    @Test    public void testDimensions() {        checkdimensions(MatrixUtils.createRealMatrix(testSquare));        checkdimensions(MatrixUtils.createRealMatrix(testNonSquare));        checkdimensions(MatrixUtils.createRealMatrix(testNonSquare).transpose());    }    private void checkdimensions(RealMatrix matrix) {        final int m = matrix.getRowDimension();        final int n = matrix.getColumnDimension();        BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix);        Assert.assertEquals(m, transformer.getU().getRowDimension());        Assert.assertEquals(m, transformer.getU().getColumnDimension());        Assert.assertEquals(m, transformer.getB().getRowDimension());        Assert.assertEquals(n, transformer.getB().getColumnDimension());        Assert.assertEquals(n, transformer.getV().getRowDimension());        Assert.assertEquals(n, transformer.getV().getColumnDimension());    }    @Test    public void testAEqualUSVt() {        checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare));        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare));        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare).transpose());    }    private void checkAEqualUSVt(RealMatrix matrix) {        BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix);        RealMatrix u = transformer.getU();        RealMatrix b = transformer.getB();        RealMatrix v = transformer.getV();        double norm = u.multiply(b).multiply(v.transpose()).subtract(matrix).getNorm();        Assert.assertEquals(0, norm, 1.0e-14);    }    @Test    public void testUOrthogonal() {        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getU());        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getU());        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getU());    }    @Test    public void testVOrthogonal() {        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getV());        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getV());        checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getV());    }    private void checkOrthogonal(RealMatrix m) {        RealMatrix mTm = m.transpose().multiply(m);        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());        Assert.assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14);    }    @Test    public void testBBiDiagonal() {        checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getB());        checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getB());        checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getB());    }    private void checkBiDiagonal(RealMatrix m) {        final int rows = m.getRowDimension();        final int cols = m.getColumnDimension();        for (int i = 0; i < rows; ++i) {            for (int j = 0; j < cols; ++j) {                if (rows < cols) {                    if ((i < j) || (i > j + 1)) {                        Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16);                    }                } else {                    if ((i < j - 1) || (i > j)) {                        Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16);                    }                }            }        }    }    @Test    public void testSingularMatrix() {       BiDiagonalTransformer transformer =            new BiDiagonalTransformer(MatrixUtils.createRealMatrix(new double[][] {                { 1.0, 2.0, 3.0 },                { 2.0, 3.0, 4.0 },                { 3.0, 5.0, 7.0 }            }));       final double s3  = FastMath.sqrt(3.0);       final double s14 = FastMath.sqrt(14.0);       final double s1553 = FastMath.sqrt(1553.0);       RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {           {  -1.0 / s14,  5.0 / (s3 * s14),  1.0 / s3 },           {  -2.0 / s14, -4.0 / (s3 * s14),  1.0 / s3 },           {  -3.0 / s14,  1.0 / (s3 * s14), -1.0 / s3 }       });       RealMatrix bRef = MatrixUtils.createRealMatrix(new double[][] {           { -s14, s1553 / s14,   0.0 },           {  0.0, -87 * s3 / (s14 * s1553), -s3 * s14 / s1553 },           {  0.0, 0.0, 0.0 }       });       RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {           { 1.0,   0.0,         0.0        },           { 0.0,  -23 / s1553,  32 / s1553 },           { 0.0,  -32 / s1553, -23 / s1553 }       });       // check values against known references       RealMatrix u = transformer.getU();       Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-14);       RealMatrix b = transformer.getB();       Assert.assertEquals(0, b.subtract(bRef).getNorm(), 1.0e-14);       RealMatrix v = transformer.getV();       Assert.assertEquals(0, v.subtract(vRef).getNorm(), 1.0e-14);       // check the same cached instance is returned the second time       Assert.assertTrue(u == transformer.getU());       Assert.assertTrue(b == transformer.getB());       Assert.assertTrue(v == transformer.getV());    }    @Test    public void testMatricesValues() {       BiDiagonalTransformer transformer =            new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare));       final double s17 = FastMath.sqrt(17.0);        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {                {  -8 / (5 * s17), 19 / (5 * s17) },                { -19 / (5 * s17), -8 / (5 * s17) }        });        RealMatrix bRef = MatrixUtils.createRealMatrix(new double[][] {                { -3 * s17 / 5, 32 * s17 / 85 },                {      0.0,     -5 * s17 / 17 }        });        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {                { 1.0,  0.0 },                { 0.0, -1.0 }        });        // check values against known references        RealMatrix u = transformer.getU();        Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-14);        RealMatrix b = transformer.getB();        Assert.assertEquals(0, b.subtract(bRef).getNorm(), 1.0e-14);        RealMatrix v = transformer.getV();        Assert.assertEquals(0, v.subtract(vRef).getNorm(), 1.0e-14);        // check the same cached instance is returned the second time        Assert.assertTrue(u == transformer.getU());        Assert.assertTrue(b == transformer.getB());        Assert.assertTrue(v == transformer.getV());    }    @Test    public void testUpperOrLower() {        Assert.assertTrue(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).isUpperBiDiagonal());        Assert.assertTrue(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).isUpperBiDiagonal());        Assert.assertFalse(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).isUpperBiDiagonal());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.text.NumberFormat;import java.text.ParseException;import java.text.ParsePosition;import java.util.Locale;import junit.framework.TestCase;import org.apache.commons.math.util.CompositeFormat;public abstract class RealVectorFormatAbstractTest extends TestCase {    RealVectorFormat realVectorFormat = null;    RealVectorFormat realVectorFormatSquare = null;    protected abstract Locale getLocale();    protected abstract char getDecimalCharacter();    @Override    public void setUp() throws Exception {        realVectorFormat = RealVectorFormat.getInstance(getLocale());        final NumberFormat nf = NumberFormat.getInstance(getLocale());        nf.setMaximumFractionDigits(2);        realVectorFormatSquare = new RealVectorFormat("[", "]", " : ", nf);    }    public void testSimpleNoDecimals() {        ArrayRealVector c = new ArrayRealVector(new double[] {1, 1, 1});        String expected = "{1; 1; 1}";        String actual = realVectorFormat.format(c);        assertEquals(expected, actual);    }    public void testSimpleWithDecimals() {        ArrayRealVector c = new ArrayRealVector(new double[] {1.23, 1.43, 1.63});        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = realVectorFormat.format(c);        assertEquals(expected, actual);    }    public void testSimpleWithDecimalsTrunc() {        ArrayRealVector c = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = realVectorFormat.format(c);        assertEquals(expected, actual);    }    public void testNegativeX() {        ArrayRealVector c = new ArrayRealVector(new double[] {-1.2323, 1.4343, 1.6333});        String expected =            "{-1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = realVectorFormat.format(c);        assertEquals(expected, actual);    }    public void testNegativeY() {        ArrayRealVector c = new ArrayRealVector(new double[] {1.2323, -1.4343, 1.6333});        String expected =            "{1"    + getDecimalCharacter() +            "23; -1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        String actual = realVectorFormat.format(c);        assertEquals(expected, actual);    }    public void testNegativeZ() {        ArrayRealVector c = new ArrayRealVector(new double[] {1.2323, 1.4343, -1.6333});        String expected =            "{1"    + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; -1" + getDecimalCharacter() +            "63}";        String actual = realVectorFormat.format(c);        assertEquals(expected, actual);    }    public void testNonDefaultSetting() {        ArrayRealVector c = new ArrayRealVector(new double[] {1, 1, 1});        String expected = "[1 : 1 : 1]";        String actual = realVectorFormatSquare.format(c);        assertEquals(expected, actual);    }    public void testStaticFormatRealVectorImpl() {        Locale defaultLocal = Locale.getDefault();        Locale.setDefault(getLocale());        ArrayRealVector c = new ArrayRealVector(new double[] {232.222, -342.33, 432.444});        String expected =            "{232"    + getDecimalCharacter() +            "22; -342" + getDecimalCharacter() +            "33; 432" + getDecimalCharacter() +            "44}";        String actual = RealVectorFormat.formatRealVector(c);        assertEquals(expected, actual);        Locale.setDefault(defaultLocal);    }    public void testNan() {        ArrayRealVector c = new ArrayRealVector(new double[] {Double.NaN, Double.NaN, Double.NaN});        String expected = "{(NaN); (NaN); (NaN)}";        String actual = realVectorFormat.format(c);        assertEquals(expected, actual);    }    public void testPositiveInfinity() {        ArrayRealVector c = new ArrayRealVector(new double[] {                Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY        });        String expected = "{(Infinity); (Infinity); (Infinity)}";        String actual = realVectorFormat.format(c);        assertEquals(expected, actual);    }    public void tesNegativeInfinity() {        ArrayRealVector c = new ArrayRealVector(new double[] {                Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY        });        String expected = "{(-Infinity); (-Infinity); (-Infinity)}";        String actual = realVectorFormat.format(c);        assertEquals(expected, actual);    }    public void testParseSimpleNoDecimals() {        String source = "{1; 1; 1}";        ArrayRealVector expected = new ArrayRealVector(new double[] {1, 1, 1});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseIgnoredWhitespace() {        ArrayRealVector expected = new ArrayRealVector(new double[] {1, 1, 1});        ParsePosition pos1 = new ParsePosition(0);        String source1 = "{1;1;1}";        assertEquals(expected, realVectorFormat.parseObject(source1, pos1));        assertEquals(source1.length(), pos1.getIndex());        ParsePosition pos2 = new ParsePosition(0);        String source2 = " { 1 ; 1 ; 1 } ";        assertEquals(expected, realVectorFormat.parseObject(source2, pos2));        assertEquals(source2.length() - 1, pos2.getIndex());    }    public void testParseSimpleWithDecimals() {        String source =            "{1" + getDecimalCharacter() +            "23; 1" + getDecimalCharacter() +            "43; 1" + getDecimalCharacter() +            "63}";        ArrayRealVector expected = new ArrayRealVector(new double[] {1.23, 1.43, 1.63});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseSimpleWithDecimalsTrunc() {        String source =            "{1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeX() {        String source =            "{-1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {-1.2323, 1.4343, 1.6333});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeY() {        String source =            "{1" + getDecimalCharacter() +            "2323; -1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, -1.4343, 1.6333});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeZ() {        String source =            "{1" + getDecimalCharacter() +            "2323; 1" + getDecimalCharacter() +            "4343; -1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, -1.6333});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeAll() {        String source =            "{-1" + getDecimalCharacter() +            "2323; -1" + getDecimalCharacter() +            "4343; -1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {-1.2323, -1.4343, -1.6333});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseZeroX() {        String source =            "{0" + getDecimalCharacter() +            "0; -1" + getDecimalCharacter() +            "4343; 1" + getDecimalCharacter() +            "6333}";        ArrayRealVector expected = new ArrayRealVector(new double[] {0.0, -1.4343, 1.6333});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNonDefaultSetting() {        String source =            "[1" + getDecimalCharacter() +            "2323 : 1" + getDecimalCharacter() +            "4343 : 1" + getDecimalCharacter() +            "6333]";        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormatSquare.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNan() {        String source = "{(NaN); (NaN); (NaN)}";        try {            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);            assertEquals(new ArrayRealVector(new double[] {Double.NaN, Double.NaN, Double.NaN}), actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParsePositiveInfinity() {        String source = "{(Infinity); (Infinity); (Infinity)}";        try {            ArrayRealVector actual = (ArrayRealVector)realVectorFormat.parseObject(source);            assertEquals(new ArrayRealVector(new double[] {                    Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY            }), actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeInfinity() {        String source = "{(-Infinity); (-Infinity); (-Infinity)}";        try {            ArrayRealVector actual = (ArrayRealVector)realVectorFormat.parseObject(source);            assertEquals(new ArrayRealVector(new double[] {                    Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY            }), actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNoComponents() {        try {            realVectorFormat.parseObject("{ }");        } catch (ParseException pe) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testParseManyComponents() throws ParseException {        ArrayRealVector parsed =            (ArrayRealVector) realVectorFormat.parseObject("{0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0}");        assertEquals(24, parsed.getDimension());    }    public void testConstructorSingleFormat() {        NumberFormat nf = NumberFormat.getInstance();        RealVectorFormat cf = new RealVectorFormat(nf);        assertNotNull(cf);        assertEquals(nf, cf.getFormat());    }    public void testFormatObject() {        try {            CompositeFormat cf = new RealVectorFormat();            Object object = new Object();            cf.format(object);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }    public void testForgottenPrefix() {        ParsePosition pos = new ParsePosition(0);        final String source = "1; 1; 1}";        assertNull("Should not parse <"+source+">",new RealVectorFormat().parse(source, pos));        assertEquals(0, pos.getErrorIndex());    }    public void testForgottenSeparator() {        ParsePosition pos = new ParsePosition(0);        final String source = "{1; 1 1}";        assertNull("Should not parse <"+source+">",new RealVectorFormat().parse(source, pos));        assertEquals(6, pos.getErrorIndex());    }    public void testForgottenSuffix() {        ParsePosition pos = new ParsePosition(0);        final String source = "{1; 1; 1 ";        assertNull("Should not parse <"+source+">",new RealVectorFormat().parse(source, pos));        assertEquals(8, pos.getErrorIndex());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Locale;public class RealVectorFormatTest extends RealVectorFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return '.';    }    @Override    protected Locale getLocale() {        return Locale.US;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.apache.commons.math.exception.util.LocalizedFormats;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class MatrixIndexExceptionTest extends TestCase {    /**     *     */    public void testParameter(){        MatrixIndexException ex = new MatrixIndexException(LocalizedFormats.INDEX_OUT_OF_RANGE, 12, 0, 5);        assertEquals(12, ex.getArguments()[0]);        assertEquals(0,  ex.getArguments()[1]);        assertEquals(5,  ex.getArguments()[2]);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.TestCase;import org.apache.commons.math.MathException;public class CholeskySolverTest extends TestCase {    private double[][] testData = new double[][] {            {  1,  2,   4,   7,  11 },            {  2, 13,  23,  38,  58 },            {  4, 23,  77, 122, 182 },            {  7, 38, 122, 294, 430 },            { 11, 58, 182, 430, 855 }    };    public CholeskySolverTest(String name) {        super(name);    }    /** test solve dimension errors */    public void testSolveDimensionErrors() throws MathException {        DecompositionSolver solver =            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);        try {            solver.solve(b);            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumn(0));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test solve */    public void testSolve() throws MathException {        DecompositionSolver solver =            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                {   78,  -13,    1 },                {  414,  -62,   -1 },                { 1312, -202,  -37 },                { 2989, -542,  145 },                { 5510, -1465, 201 }        });        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                { 1,  0,  1 },                { 0,  1,  1 },                { 2,  1, -4 },                { 2,  2,  2 },                { 5, -3,  0 }        });        // using RealMatrix        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);        // using double[]        for (int i = 0; i < b.getColumnDimension(); ++i) {            assertEquals(0,                         new ArrayRealVector(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }        // using ArrayRealVector        for (int i = 0; i < b.getColumnDimension(); ++i) {            assertEquals(0,                         solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }        // using RealVector with an alternate implementation        for (int i = 0; i < b.getColumnDimension(); ++i) {            ArrayRealVectorTest.RealVectorTestImpl v =                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));            assertEquals(0,                         solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }    }    /** test determinant */    public void testDeterminant() throws MathException {        assertEquals(7290000.0, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15);    }    private double getDeterminant(RealMatrix m) throws MathException {        return new CholeskyDecompositionImpl(m).getDeterminant();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Arrays;import java.util.Random;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionField;import org.apache.commons.math.exception.MatrixDimensionMismatchException;/** * Test cases for the {@link BlockFieldMatrix} class. * * @version $Revision$ $Date$ */public final class BlockFieldMatrixTest extends TestCase {    // 3 x 3 identity matrix    protected Fraction[][] id = {            {new Fraction(1),new Fraction(0),new Fraction(0)},            {new Fraction(0),new Fraction(1),new Fraction(0)},            {new Fraction(0),new Fraction(0),new Fraction(1)}    };    // Test data for group operations    protected Fraction[][] testData = {            {new Fraction(1),new Fraction(2),new Fraction(3)},            {new Fraction(2),new Fraction(5),new Fraction(3)},            {new Fraction(1),new Fraction(0),new Fraction(8)}    };    protected Fraction[][] testDataLU = {            {new Fraction(2), new Fraction(5), new Fraction(3)},            {new Fraction(1, 2), new Fraction(-5, 2), new Fraction(13, 2)},            {new Fraction(1, 2), new Fraction(1, 5), new Fraction(1, 5)}    };    protected Fraction[][] testDataPlus2 = {            {new Fraction(3),new Fraction(4),new Fraction(5)},            {new Fraction(4),new Fraction(7),new Fraction(5)},            {new Fraction(3),new Fraction(2),new Fraction(10)}    };    protected Fraction[][] testDataMinus = {            {new Fraction(-1),new Fraction(-2),new Fraction(-3)},            {new Fraction(-2),new Fraction(-5),new Fraction(-3)},            {new Fraction(-1),new Fraction(0),new Fraction(-8)}    };    protected Fraction[] testDataRow1 = {new Fraction(1),new Fraction(2),new Fraction(3)};    protected Fraction[] testDataCol3 = {new Fraction(3),new Fraction(3),new Fraction(8)};    protected Fraction[][] testDataInv = {            {new Fraction(-40),new Fraction(16),new Fraction(9)},            {new Fraction(13),new Fraction(-5),new Fraction(-3)},            {new Fraction(5),new Fraction(-2),new Fraction(-1)}    };    protected Fraction[] preMultTest = {new Fraction(8), new Fraction(12), new Fraction(33)};    protected Fraction[][] testData2 = {            {new Fraction(1),new Fraction(2),new Fraction(3)},            {new Fraction(2),new Fraction(5),new Fraction(3)}    };    protected Fraction[][] testData2T = {            {new Fraction(1),new Fraction(2)},            {new Fraction(2),new Fraction(5)},            {new Fraction(3),new Fraction(3)}    };    protected Fraction[][] testDataPlusInv = {            {new Fraction(-39),new Fraction(18),new Fraction(12)},            {new Fraction(15),new Fraction(0),new Fraction(0)},            {new Fraction(6),new Fraction(-2),new Fraction(7)}    };    // lu decomposition tests    protected Fraction[][] luData = {            {new Fraction(2),new Fraction(3),new Fraction(3)},            {new Fraction(0),new Fraction(5),new Fraction(7)},            {new Fraction(6),new Fraction(9),new Fraction(8)}    };    protected Fraction[][] luDataLUDecomposition = {            {new Fraction(6),new Fraction(9),new Fraction(8)},            {new Fraction(0),new Fraction(5),new Fraction(7)},            {new Fraction(1, 3),new Fraction(0),new Fraction(1, 3)}    };    // singular matrices    protected Fraction[][] singular = { {new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(3)} };    protected Fraction[][] bigSingular = {            {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},            {new Fraction(2),new Fraction(5),new Fraction(3),new Fraction(4)},            {new Fraction(7),new Fraction(3),new Fraction(256),new Fraction(1930)},            {new Fraction(3),new Fraction(7),new Fraction(6),new Fraction(8)}    }; // 4th row = 1st + 2nd    protected Fraction[][] detData = {            {new Fraction(1),new Fraction(2),new Fraction(3)},            {new Fraction(4),new Fraction(5),new Fraction(6)},            {new Fraction(7),new Fraction(8),new Fraction(10)}    };    protected Fraction[][] detData2 = { {new Fraction(1), new Fraction(3)}, {new Fraction(2), new Fraction(4)}};    // vectors    protected Fraction[] testVector = {new Fraction(1),new Fraction(2),new Fraction(3)};    protected Fraction[] testVector2 = {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)};    // submatrix accessor tests    protected Fraction[][] subTestData = {            {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)},            {new Fraction(3, 2), new Fraction(5, 2), new Fraction(7, 2), new Fraction(9, 2)},            {new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8)},            {new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7)}    };    // array selections    protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4)}, {new Fraction(4), new Fraction(8)}};    protected Fraction[][] subRows03Cols12 = { {new Fraction(2), new Fraction(3)}, {new Fraction(5), new Fraction(6)}};    protected Fraction[][] subRows03Cols123 = {            {new Fraction(2), new Fraction(3), new Fraction(4)},            {new Fraction(5), new Fraction(6), new Fraction(7)}    };    // effective permutations    protected Fraction[][] subRows20Cols123 = {            {new Fraction(4), new Fraction(6), new Fraction(8)},            {new Fraction(2), new Fraction(3), new Fraction(4)}    };    protected Fraction[][] subRows31Cols31 = {{new Fraction(7), new Fraction(5)}, {new Fraction(9, 2), new Fraction(5, 2)}};    // contiguous ranges    protected Fraction[][] subRows01Cols23 = {{new Fraction(3),new Fraction(4)} , {new Fraction(7, 2), new Fraction(9, 2)}};    protected Fraction[][] subRows23Cols00 = {{new Fraction(2)} , {new Fraction(4)}};    protected Fraction[][] subRows00Cols33 = {{new Fraction(4)}};    // row matrices    protected Fraction[][] subRow0 = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}};    protected Fraction[][] subRow3 = {{new Fraction(4),new Fraction(5),new Fraction(6),new Fraction(7)}};    // column matrices    protected Fraction[][] subColumn1 = {{new Fraction(2)}, {new Fraction(5, 2)}, {new Fraction(4)}, {new Fraction(5)}};    protected Fraction[][] subColumn3 = {{new Fraction(4)}, {new Fraction(9, 2)}, {new Fraction(8)}, {new Fraction(7)}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    public BlockFieldMatrixTest(String name) {        super(name);    }    /** test dimensions */    public void testDimensions() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());    }    /** test copy functions */    public void testCopyFunctions() {        Random r = new Random(66636328996002l);        BlockFieldMatrix<Fraction> m1 = createRandomMatrix(r, 47, 83);        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(m1.getData());        assertEquals(m1, m2);        BlockFieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(m3.getData());        assertEquals(m3, m4);    }    /** test add */    public void testAdd() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);        FieldMatrix<Fraction> mPlusMInv = m.add(mInv);        Fraction[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);            }        }    }    /** test add failure */    public void testAddFail() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);        try {            m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }    }     /** test m-n = m + -n */    public void testPlusMinus() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testDataInv);        TestUtils.assertEquals(m.subtract(m2), m2.scalarMultiply(new Fraction(-1)).add(m));        try {            m.subtract(new BlockFieldMatrix<Fraction>(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test multiply */     public void testMultiply() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);        BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id);        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);        TestUtils.assertEquals(m.multiply(mInv), identity);        TestUtils.assertEquals(mInv.multiply(m), identity);        TestUtils.assertEquals(m.multiply(identity), m);        TestUtils.assertEquals(identity.multiply(mInv), mInv);        TestUtils.assertEquals(m2.multiply(identity), m2);        try {            m.multiply(new BlockFieldMatrix<Fraction>(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testSeveralBlocks() {        FieldMatrix<Fraction> m =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), 37, 41);        for (int i = 0; i < m.getRowDimension(); ++i) {            for (int j = 0; j < m.getColumnDimension(); ++j) {                m.setEntry(i, j, new Fraction(i * 11 + j, 11));            }        }        FieldMatrix<Fraction> mT = m.transpose();        assertEquals(m.getRowDimension(), mT.getColumnDimension());        assertEquals(m.getColumnDimension(), mT.getRowDimension());        for (int i = 0; i < mT.getRowDimension(); ++i) {            for (int j = 0; j < mT.getColumnDimension(); ++j) {                assertEquals(m.getEntry(j, i), mT.getEntry(i, j));            }        }        FieldMatrix<Fraction> mPm = m.add(m);        for (int i = 0; i < mPm.getRowDimension(); ++i) {            for (int j = 0; j < mPm.getColumnDimension(); ++j) {                assertEquals(m.getEntry(i, j).multiply(new Fraction(2)), mPm.getEntry(i, j));            }        }        FieldMatrix<Fraction> mPmMm = mPm.subtract(m);        for (int i = 0; i < mPmMm.getRowDimension(); ++i) {            for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {                assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j));            }        }        FieldMatrix<Fraction> mTm = mT.multiply(m);        for (int i = 0; i < mTm.getRowDimension(); ++i) {            for (int j = 0; j < mTm.getColumnDimension(); ++j) {                Fraction sum = Fraction.ZERO;                for (int k = 0; k < mT.getColumnDimension(); ++k) {                    sum = sum.add(new Fraction(k * 11 + i, 11).multiply(new Fraction(k * 11 + j, 11)));                }                assertEquals(sum, mTm.getEntry(i, j));            }        }        FieldMatrix<Fraction> mmT = m.multiply(mT);        for (int i = 0; i < mmT.getRowDimension(); ++i) {            for (int j = 0; j < mmT.getColumnDimension(); ++j) {                Fraction sum = Fraction.ZERO;                for (int k = 0; k < m.getColumnDimension(); ++k) {                    sum = sum.add(new Fraction(i * 11 + k, 11).multiply(new Fraction(j * 11 + k, 11)));                }                assertEquals(sum, mmT.getEntry(i, j));            }        }        FieldMatrix<Fraction> sub1 = m.getSubMatrix(2, 9, 5, 20);        for (int i = 0; i < sub1.getRowDimension(); ++i) {            for (int j = 0; j < sub1.getColumnDimension(); ++j) {                assertEquals(new Fraction((i + 2) * 11 + (j + 5), 11), sub1.getEntry(i, j));            }        }        FieldMatrix<Fraction> sub2 = m.getSubMatrix(10, 12, 3, 40);        for (int i = 0; i < sub2.getRowDimension(); ++i) {            for (int j = 0; j < sub2.getColumnDimension(); ++j) {                assertEquals(new Fraction((i + 10) * 11 + (j + 3), 11), sub2.getEntry(i, j));            }        }        FieldMatrix<Fraction> sub3 = m.getSubMatrix(30, 34, 0, 5);        for (int i = 0; i < sub3.getRowDimension(); ++i) {            for (int j = 0; j < sub3.getColumnDimension(); ++j) {                assertEquals(new Fraction((i + 30) * 11 + (j + 0), 11), sub3.getEntry(i, j));            }        }        FieldMatrix<Fraction> sub4 = m.getSubMatrix(30, 32, 32, 35);        for (int i = 0; i < sub4.getRowDimension(); ++i) {            for (int j = 0; j < sub4.getColumnDimension(); ++j) {                assertEquals(new Fraction((i + 30) * 11 + (j + 32), 11), sub4.getEntry(i, j));            }        }    }    //Additional Test for BlockFieldMatrix<Fraction>Test.testMultiply    private Fraction[][] d3 = new Fraction[][] {            {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},            {new Fraction(5),new Fraction(6),new Fraction(7),new Fraction(8)}    };    private Fraction[][] d4 = new Fraction[][] {            {new Fraction(1)},            {new Fraction(2)},            {new Fraction(3)},            {new Fraction(4)}    };    private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}};    public void testMultiply2() {       FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);       FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4);       FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5);       TestUtils.assertEquals(m3.multiply(m4), m5);   }    /** test trace */    public void testTrace() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id);        assertEquals(new Fraction(3),m.getTrace());        m = new BlockFieldMatrix<Fraction>(testData2);        try {            m.getTrace();            fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }    }    /** test scalarAdd */    public void testScalarAdd() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(new BlockFieldMatrix<Fraction>(testDataPlus2),                               m.scalarAdd(new Fraction(2)));    }    /** test operate */    public void testOperate() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id);        TestUtils.assertEquals(testVector, m.operate(testVector));        TestUtils.assertEquals(testVector, m.operate(new ArrayFieldVector<Fraction>(testVector)).getData());        m = new BlockFieldMatrix<Fraction>(bigSingular);        try {            m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testOperateLarge() {        int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;        int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;        int r =  BlockFieldMatrix.BLOCK_SIZE / 2;        Random random = new Random(111007463902334l);        FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q);        FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r);        FieldMatrix<Fraction> m1m2 = m1.multiply(m2);        for (int i = 0; i < r; ++i) {            TestUtils.assertEquals(m1m2.getColumn(i), m1.operate(m2.getColumn(i)));        }    }    public void testOperatePremultiplyLarge() {        int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;        int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;        int r =  BlockFieldMatrix.BLOCK_SIZE / 2;        Random random = new Random(111007463902334l);        FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q);        FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r);        FieldMatrix<Fraction> m1m2 = m1.multiply(m2);        for (int i = 0; i < p; ++i) {            TestUtils.assertEquals(m1m2.getRow(i), m2.preMultiply(m1.getRow(i)));        }    }    /** test issue MATH-209 */    public void testMath209() {        FieldMatrix<Fraction> a = new BlockFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(1), new Fraction(2) },                { new Fraction(3), new Fraction(4) },                { new Fraction(5), new Fraction(6) }        });        Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });        assertEquals(a.getRowDimension(), b.length);        assertEquals( new Fraction(3), b[0]);        assertEquals( new Fraction(7), b[1]);        assertEquals(new Fraction(11), b[2]);    }    /** test transpose */    public void testTranspose() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();        TestUtils.assertEquals(mIT, mTI);        m = new BlockFieldMatrix<Fraction>(testData2);        FieldMatrix<Fraction> mt = new BlockFieldMatrix<Fraction>(testData2T);        TestUtils.assertEquals(mt, m.transpose());    }    /** test preMultiply by vector */    public void testPremultiplyVector() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(m.preMultiply(testVector), preMultTest);        TestUtils.assertEquals(m.preMultiply(new ArrayFieldVector<Fraction>(testVector).getData()),                               preMultTest);        m = new BlockFieldMatrix<Fraction>(bigSingular);        try {            m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testPremultiply() {        FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);        FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4);        FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5);        TestUtils.assertEquals(m4.preMultiply(m3), m5);        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);        BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id);        TestUtils.assertEquals(m.preMultiply(mInv), identity);        TestUtils.assertEquals(mInv.preMultiply(m), identity);        TestUtils.assertEquals(m.preMultiply(identity), m);        TestUtils.assertEquals(identity.preMultiply(mInv), mInv);        try {            m.preMultiply(new BlockFieldMatrix<Fraction>(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testGetVectors() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(m.getRow(0), testDataRow1);        TestUtils.assertEquals(m.getColumn(2), testDataCol3);        try {            m.getRow(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }        try {            m.getColumn(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }    }    public void testGetEntry() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        assertEquals(m.getEntry(0,1),new Fraction(2));        try {            m.getEntry(10, 4);            fail ("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    /** test examples in user guide */    public void testExamples() {        // Create a real matrix with two rows and three columns        Fraction[][] matrixData = {                {new Fraction(1),new Fraction(2),new Fraction(3)},                {new Fraction(2),new Fraction(5),new Fraction(3)}        };        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(matrixData);        // One more with three rows, two columns        Fraction[][] matrixData2 = {                {new Fraction(1),new Fraction(2)},                {new Fraction(2),new Fraction(5)},                {new Fraction(1), new Fraction(7)}        };        FieldMatrix<Fraction> n = new BlockFieldMatrix<Fraction>(matrixData2);        // Now multiply m by n        FieldMatrix<Fraction> p = m.multiply(n);        assertEquals(2, p.getRowDimension());        assertEquals(2, p.getColumnDimension());        // Invert p        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();        assertEquals(2, pInverse.getRowDimension());        assertEquals(2, pInverse.getColumnDimension());        // Solve example        Fraction[][] coefficientsData = {                {new Fraction(2), new Fraction(3), new Fraction(-2)},                {new Fraction(-1), new Fraction(7), new Fraction(6)},                {new Fraction(4), new Fraction(-3), new Fraction(-5)}        };        FieldMatrix<Fraction> coefficients = new BlockFieldMatrix<Fraction>(coefficientsData);        Fraction[] constants = {new Fraction(1), new Fraction(-2), new Fraction(1)};        Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);        assertEquals(new Fraction(2).multiply(solution[0]).                     add(new Fraction(3).multiply(solution[1])).                     subtract(new Fraction(2).multiply(solution[2])),                     constants[0]);        assertEquals(new Fraction(-1).multiply(solution[0]).                     add(new Fraction(7).multiply(solution[1])).                     add(new Fraction(6).multiply(solution[2])),                     constants[1]);        assertEquals(new Fraction(4).multiply(solution[0]).                     subtract(new Fraction(3).multiply(solution[1])).                     subtract(new Fraction(5).multiply(solution[2])),                     constants[2]);    }    // test submatrix accessors    public void testGetSubMatrix() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkGetSubMatrix(m, null,  1, 0, 2, 4);        checkGetSubMatrix(m, null, -1, 1, 2, 2);        checkGetSubMatrix(m, null,  1, 0, 2, 2);        checkGetSubMatrix(m, null,  1, 0, 2, 4);        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 });        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 });    }    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,                                   int startRow, int endRow, int startColumn, int endColumn) {        try {            FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);            if (reference != null) {                assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);            } else {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (reference != null) {                throw e;            }        }    }    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,                                   int[] selectedRows, int[] selectedColumns) {        try {            FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);            if (reference != null) {                assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);            } else {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (reference != null) {                throw e;            }        }    }    public void testGetSetMatrixLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        FieldMatrix<Fraction> sub =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n - 4, n - 4).scalarAdd(new Fraction(1));        m.setSubMatrix(sub.getData(), 2, 2);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {                    assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));    }    public void testCopySubMatrix() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkCopy(m, null,  1, 0, 2, 4);        checkCopy(m, null, -1, 1, 2, 2);        checkCopy(m, null,  1, 0, 2, 2);        checkCopy(m, null,  1, 0, 2, 4);        checkCopy(m, null, new int[] {},    new int[] { 0 });        checkCopy(m, null, new int[] { 0 }, new int[] { 4 });    }    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,                           int startRow, int endRow, int startColumn, int endColumn) {        try {            Fraction[][] sub = (reference == null) ?                             new Fraction[1][1] :                             new Fraction[reference.length][reference[0].length];            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);            if (reference != null) {                assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));            } else {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (reference != null) {                throw e;            }        }    }    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,                           int[] selectedRows, int[] selectedColumns) {        try {            Fraction[][] sub = (reference == null) ?                    new Fraction[1][1] :                    new Fraction[reference.length][reference[0].length];            m.copySubMatrix(selectedRows, selectedColumns, sub);            if (reference != null) {                assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));            } else {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (reference != null) {                throw e;            }        }    }    public void testGetRowMatrix() {        FieldMatrix<Fraction> m     = new BlockFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mRow0 = new BlockFieldMatrix<Fraction>(subRow0);        FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3);        assertEquals("Row0", mRow0, m.getRowMatrix(0));        assertEquals("Row3", mRow3, m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowMatrix() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowMatrix(0, mRow3);        assertEquals(mRow3, m.getRowMatrix(0));        try {            m.setRowMatrix(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowMatrix(0, m);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetSetRowMatrixLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        FieldMatrix<Fraction> sub =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), 1, n).scalarAdd(new Fraction(1));        m.setRowMatrix(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        assertEquals(sub, m.getRowMatrix(2));    }    public void testGetColumnMatrix() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mColumn1 = new BlockFieldMatrix<Fraction>(subColumn1);        FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3);        assertEquals(mColumn1, m.getColumnMatrix(1));        assertEquals(mColumn3, m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnMatrix() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3);        assertNotSame(mColumn3, m.getColumnMatrix(1));        m.setColumnMatrix(1, mColumn3);        assertEquals(mColumn3, m.getColumnMatrix(1));        try {            m.setColumnMatrix(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnMatrix(0, m);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetSetColumnMatrixLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        FieldMatrix<Fraction> sub =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, 1).scalarAdd(new Fraction(1));        m.setColumnMatrix(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        assertEquals(sub, m.getColumnMatrix(2));    }    public void testGetRowVector() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);        assertEquals(mRow0, m.getRowVector(0));        assertEquals(mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowVector() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowVector(0, mRow3);        assertEquals(mRow3, m.getRowVector(0));        try {            m.setRowVector(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetSetRowVectorLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        FieldVector<Fraction> sub = new ArrayFieldVector<Fraction>(n, new Fraction(1));        m.setRowVector(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        assertEquals(sub, m.getRowVector(2));    }    public void testGetColumnVector() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);        assertEquals(mColumn1, m.getColumnVector(1));        assertEquals(mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnVector() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);        assertNotSame(mColumn3, m.getColumnVector(1));        m.setColumnVector(1, mColumn3);        assertEquals(mColumn3, m.getColumnVector(1));        try {            m.setColumnVector(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetSetColumnVectorLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        FieldVector<Fraction> sub = new ArrayFieldVector<Fraction>(n, new Fraction(1));        m.setColumnVector(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        assertEquals(sub, m.getColumnVector(2));    }    private FieldVector<Fraction> columnToVector(Fraction[][] column) {        Fraction[] data = new Fraction[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayFieldVector<Fraction>(data, false);    }    public void testGetRow() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        checkArrays(subRow0[0], m.getRow(0));        checkArrays(subRow3[0], m.getRow(3));        try {            m.getRow(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRow(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRow() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        assertTrue(subRow3[0][0] != m.getRow(0)[0]);        m.setRow(0, subRow3[0]);        checkArrays(subRow3[0], m.getRow(0));        try {            m.setRow(-1, subRow3[0]);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRow(0, new Fraction[5]);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetSetRowLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        Fraction[] sub = new Fraction[n];        Arrays.fill(sub, new Fraction(1));        m.setRow(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        checkArrays(sub, m.getRow(2));    }    public void testGetColumn() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        Fraction[] mColumn1 = columnToArray(subColumn1);        Fraction[] mColumn3 = columnToArray(subColumn3);        checkArrays(mColumn1, m.getColumn(1));        checkArrays(mColumn3, m.getColumn(3));        try {            m.getColumn(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumn(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumn() {        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);        Fraction[] mColumn3 = columnToArray(subColumn3);        assertTrue(mColumn3[0] != m.getColumn(1)[0]);        m.setColumn(1, mColumn3);        checkArrays(mColumn3, m.getColumn(1));        try {            m.setColumn(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumn(0, new Fraction[5]);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetSetColumnLarge() {        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);        Fraction[] sub = new Fraction[n];        Arrays.fill(sub, new Fraction(1));        m.setColumn(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    assertEquals(new Fraction(0), m.getEntry(i, j));                } else {                    assertEquals(new Fraction(1), m.getEntry(i, j));                }            }        }        checkArrays(sub, m.getColumn(2));    }    private Fraction[] columnToArray(Fraction[][] column) {        Fraction[] data = new Fraction[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return data;    }    private void checkArrays(Fraction[] expected, Fraction[] actual) {        assertEquals(expected.length, actual.length);        for (int i = 0; i < expected.length; ++i) {            assertEquals(expected[i], actual[i]);        }    }    public void testEqualsAndHashCode() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        BlockFieldMatrix<Fraction> m1 = (BlockFieldMatrix<Fraction>) m.copy();        BlockFieldMatrix<Fraction> mt = (BlockFieldMatrix<Fraction>) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(new BlockFieldMatrix<Fraction>(bigSingular)));    }    public void testToString() {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        assertEquals("BlockFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}", m.toString());    }    public void testSetSubMatrix() throws Exception {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        m.setSubMatrix(detData2,1,1);        FieldMatrix<Fraction> expected = new BlockFieldMatrix<Fraction>            (new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(2),new Fraction(1),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});        assertEquals(expected, m);        m.setSubMatrix(detData2,0,0);        expected = new BlockFieldMatrix<Fraction>            (new Fraction[][] {{new Fraction(1),new Fraction(3),new Fraction(3)},{new Fraction(2),new Fraction(4),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});        assertEquals(expected, m);        m.setSubMatrix(testDataPlus2,0,0);        expected = new BlockFieldMatrix<Fraction>            (new Fraction[][] {{new Fraction(3),new Fraction(4),new Fraction(5)},{new Fraction(4),new Fraction(7),new Fraction(5)},{new Fraction(3),new Fraction(2),new Fraction(10)}});        assertEquals(expected, m);        // javadoc example        BlockFieldMatrix<Fraction> matrix =            new BlockFieldMatrix<Fraction>(new Fraction[][] {                    {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)},                    {new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8)},                    {new Fraction(9), new Fraction(0), new Fraction(1) , new Fraction(2)}            });        matrix.setSubMatrix(new Fraction[][] {                {new Fraction(3), new Fraction(4)},                {new Fraction(5), new Fraction(6)}        }, 1, 1);        expected =            new BlockFieldMatrix<Fraction>(new Fraction[][] {                    {new Fraction(1), new Fraction(2), new Fraction(3),new Fraction(4)},                    {new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8)},                    {new Fraction(9), new Fraction(5) ,new Fraction(6), new Fraction(2)}            });        assertEquals(expected, matrix);        // dimension overflow        try {            m.setSubMatrix(testData,1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // dimension underflow        try {            m.setSubMatrix(testData,-1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        try {            m.setSubMatrix(testData,1,-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // null        try {            m.setSubMatrix(null,1,1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }        // ragged        try {            m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }        // empty        try {            m.setSubMatrix(new Fraction[][] {{}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }    }    public void testWalk() {        int rows    = 150;        int columns = 75;        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInRowOrder(new SetVisitor());        GetVisitor getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(new Fraction(0), m.getEntry(i, 0));            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            assertEquals(new Fraction(0), m.getEntry(0, j));            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInColumnOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(new Fraction(0), m.getEntry(i, 0));            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            assertEquals(new Fraction(0), m.getEntry(0, j));            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(new Fraction(0), m.getEntry(i, 0));            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            assertEquals(new Fraction(0), m.getEntry(0, j));            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(new Fraction(0), m.getEntry(i, 0));            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            assertEquals(new Fraction(0), m.getEntry(0, j));            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }    }    public void testSerial()  {        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);        assertEquals(m,TestUtils.serializeAndRecover(m));    }    private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Fraction> {        public SetVisitor() {            super(Fraction.ZERO);        }        @Override        public Fraction visit(int i, int j, Fraction value) {            return new Fraction(i * 11 + j, 11);        }    }    private static class GetVisitor extends DefaultFieldMatrixPreservingVisitor<Fraction> {        private int count;        public GetVisitor() {            super(Fraction.ZERO);            count = 0;        }        @Override        public void visit(int i, int j, Fraction value) {            ++count;            assertEquals(new Fraction(i * 11 + j, 11), value);        }        public int getCount() {            return count;        }    }    private BlockFieldMatrix<Fraction> createRandomMatrix(Random r, int rows, int columns) {        BlockFieldMatrix<Fraction> m =            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        for (int i = 0; i < rows; ++i) {            for (int j = 0; j < columns; ++j) {                int p = r.nextInt(20) - 10;                int q = r.nextInt(20) - 10;                if (q == 0) {                    q = 1;                }                m.setEntry(i, j, new Fraction(p, q));            }        }        return m;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.MatrixDimensionMismatchException;/** * Test cases for the {@link Array2DRowRealMatrix} class. * * @version $Revision$ $Date$ */public final class Array2DRowRealMatrixTest extends TestCase {    // 3 x 3 identity matrix    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };    // Test data for group operations    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},       {-1d,0d,-8d} };    protected double[] testDataRow1 = {1d,2d,3d};    protected double[] testDataCol3 = {3d,3d,8d};    protected double[][] testDataInv =        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };    protected double[] preMultTest = {8,12,33};    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};    protected double[][] testDataPlusInv =        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };    // lu decomposition tests    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},            {0.33333333333333,0d,0.33333333333333} };    // singular matrices    protected double[][] singular = { {2d,3d}, {2d,3d} };    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};    // vectors    protected double[] testVector = {1,2,3};    protected double[] testVector2 = {1,2,3,4};    // submatrix accessor tests    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},            {2, 4, 6, 8}, {4, 5, 6, 7}};    // array selections    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};    // effective permutations    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};    // contiguous ranges    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};    protected double[][] subRows23Cols00 = {{2} , {4}};    protected double[][] subRows00Cols33 = {{4}};    // row matrices    protected double[][] subRow0 = {{1,2,3,4}};    protected double[][] subRow3 = {{4,5,6,7}};    // column matrices    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    public Array2DRowRealMatrixTest(String name) {        super(name);    }    /** test dimensions */    public void testDimensions() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());    }    /** test copy functions */    public void testCopyFunctions() {        Array2DRowRealMatrix m1 = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(m1.getData());        assertEquals(m2,m1);        Array2DRowRealMatrix m3 = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m4 = new Array2DRowRealMatrix(m3.getData(), false);        assertEquals(m4,m3);    }    /** test add */    public void testAdd() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);        RealMatrix mPlusMInv = m.add(mInv);        double[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                    testDataPlusInv[row][col],sumEntries[row][col],                        entryTolerance);            }        }    }    /** test add failure */    public void testAddFail() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);        try {            m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test norm */    public void testNorm() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);        assertEquals("testData norm",14d,m.getNorm(),entryTolerance);        assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);    }    /** test Frobenius norm */    public void testFrobeniusNorm() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);        assertEquals("testData Frobenius norm", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);        assertEquals("testData2 Frobenius norm", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);    }     /** test m-n = m + -n */    public void testPlusMinus() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testDataInv);        TestUtils.assertEquals("m-n = m + -n",m.subtract(m2),            m2.scalarMultiply(-1d).add(m),entryTolerance);        try {            m.subtract(new Array2DRowRealMatrix(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test multiply */     public void testMultiply() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);        Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id);        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);        TestUtils.assertEquals("inverse multiply",m.multiply(mInv),            identity,entryTolerance);        TestUtils.assertEquals("inverse multiply",mInv.multiply(m),            identity,entryTolerance);        TestUtils.assertEquals("identity multiply",m.multiply(identity),            m,entryTolerance);        TestUtils.assertEquals("identity multiply",identity.multiply(mInv),            mInv,entryTolerance);        TestUtils.assertEquals("identity multiply",m2.multiply(identity),            m2,entryTolerance);        try {            m.multiply(new Array2DRowRealMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    //Additional Test for Array2DRowRealMatrixTest.testMultiply    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};    private double[][] d4 = new double[][] {{1},{2},{3},{4}};    private double[][] d5 = new double[][] {{30},{70}};    public void testMultiply2() {       RealMatrix m3 = new Array2DRowRealMatrix(d3);       RealMatrix m4 = new Array2DRowRealMatrix(d4);       RealMatrix m5 = new Array2DRowRealMatrix(d5);       TestUtils.assertEquals("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);   }    /** test trace */    public void testTrace() {        RealMatrix m = new Array2DRowRealMatrix(id);        assertEquals("identity trace",3d,m.getTrace(),entryTolerance);        m = new Array2DRowRealMatrix(testData2);        try {            m.getTrace();            fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }    }    /** test sclarAdd */    public void testScalarAdd() {        RealMatrix m = new Array2DRowRealMatrix(testData);        TestUtils.assertEquals("scalar add",new Array2DRowRealMatrix(testDataPlus2),            m.scalarAdd(2d),entryTolerance);    }    /** test operate */    public void testOperate() {        RealMatrix m = new Array2DRowRealMatrix(id);        TestUtils.assertEquals("identity operate", testVector,                    m.operate(testVector), entryTolerance);        TestUtils.assertEquals("identity operate", testVector,                    m.operate(new ArrayRealVector(testVector)).getData(), entryTolerance);        m = new Array2DRowRealMatrix(bigSingular);        try {            m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test issue MATH-209 */    public void testMath209() {        RealMatrix a = new Array2DRowRealMatrix(new double[][] {                { 1, 2 }, { 3, 4 }, { 5, 6 }        }, false);        double[] b = a.operate(new double[] { 1, 1 });        assertEquals(a.getRowDimension(), b.length);        assertEquals( 3.0, b[0], 1.0e-12);        assertEquals( 7.0, b[1], 1.0e-12);        assertEquals(11.0, b[2], 1.0e-12);    }    /** test transpose */    public void testTranspose() {        RealMatrix m = new Array2DRowRealMatrix(testData);        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();        TestUtils.assertEquals("inverse-transpose", mIT, mTI, normTolerance);        m = new Array2DRowRealMatrix(testData2);        RealMatrix mt = new Array2DRowRealMatrix(testData2T);        TestUtils.assertEquals("transpose",mt,m.transpose(),normTolerance);    }    /** test preMultiply by vector */    public void testPremultiplyVector() {        RealMatrix m = new Array2DRowRealMatrix(testData);        TestUtils.assertEquals("premultiply", m.preMultiply(testVector),                    preMultTest, normTolerance);        TestUtils.assertEquals("premultiply", m.preMultiply(new ArrayRealVector(testVector).getData()),                    preMultTest, normTolerance);        m = new Array2DRowRealMatrix(bigSingular);        try {            m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testPremultiply() {        RealMatrix m3 = new Array2DRowRealMatrix(d3);        RealMatrix m4 = new Array2DRowRealMatrix(d4);        RealMatrix m5 = new Array2DRowRealMatrix(d5);        TestUtils.assertEquals("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);        Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id);        TestUtils.assertEquals("inverse multiply",m.preMultiply(mInv),                identity,entryTolerance);        TestUtils.assertEquals("inverse multiply",mInv.preMultiply(m),                identity,entryTolerance);        TestUtils.assertEquals("identity multiply",m.preMultiply(identity),                m,entryTolerance);        TestUtils.assertEquals("identity multiply",identity.preMultiply(mInv),                mInv,entryTolerance);        try {            m.preMultiply(new Array2DRowRealMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testGetVectors() {        RealMatrix m = new Array2DRowRealMatrix(testData);        TestUtils.assertEquals("get row",m.getRow(0),testDataRow1,entryTolerance);        TestUtils.assertEquals("get col",m.getColumn(2),testDataCol3,entryTolerance);        try {            m.getRow(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }        try {            m.getColumn(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }    }    public void testGetEntry() {        RealMatrix m = new Array2DRowRealMatrix(testData);        assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);        try {            m.getEntry(10, 4);            fail ("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    /** test examples in user guide */    public void testExamples() {        // Create a real matrix with two rows and three columns        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};        RealMatrix m = new Array2DRowRealMatrix(matrixData);        // One more with three rows, two columns        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};        RealMatrix n = new Array2DRowRealMatrix(matrixData2);        // Now multiply m by n        RealMatrix p = m.multiply(n);        assertEquals(2, p.getRowDimension());        assertEquals(2, p.getColumnDimension());        // Invert p        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();        assertEquals(2, pInverse.getRowDimension());        assertEquals(2, pInverse.getColumnDimension());        // Solve example        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};        RealMatrix coefficients = new Array2DRowRealMatrix(coefficientsData);        double[] constants = {1, -2, 1};        double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);    }    // test submatrix accessors    public void testGetSubMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int startRow, int endRow, int startColumn, int endColumn,                                   boolean mustFail) {        try {            RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);            assertEquals(new Array2DRowRealMatrix(reference), sub);            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int[] selectedRows, int[] selectedColumns,                                   boolean mustFail) {        try {            RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);            assertEquals(new Array2DRowRealMatrix(reference), sub);            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    public void testCopySubMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);        checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, -1, 1, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkCopy(RealMatrix m, double[][] reference,                           int startRow, int endRow, int startColumn, int endColumn,                           boolean mustFail) {        try {            double[][] sub = (reference == null) ?                             new double[1][1] :                             new double[reference.length][reference[0].length];            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);            assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    private void checkCopy(RealMatrix m, double[][] reference,                           int[] selectedRows, int[] selectedColumns,                           boolean mustFail) {        try {            double[][] sub = (reference == null) ?                    new double[1][1] :                    new double[reference.length][reference[0].length];            m.copySubMatrix(selectedRows, selectedColumns, sub);            assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    public void testGetRowMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealMatrix mRow0 = new Array2DRowRealMatrix(subRow0);        RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3);        assertEquals("Row0", mRow0,                m.getRowMatrix(0));        assertEquals("Row3", mRow3,                m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowMatrix(0, mRow3);        assertEquals(mRow3, m.getRowMatrix(0));        try {            m.setRowMatrix(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowMatrix(0, m);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetColumnMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealMatrix mColumn1 = new Array2DRowRealMatrix(subColumn1);        RealMatrix mColumn3 = new Array2DRowRealMatrix(subColumn3);        assertEquals("Column1", mColumn1,                m.getColumnMatrix(1));        assertEquals("Column3", mColumn3,                m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnMatrix() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealMatrix mColumn3 = new Array2DRowRealMatrix(subColumn3);        assertNotSame(mColumn3, m.getColumnMatrix(1));        m.setColumnMatrix(1, mColumn3);        assertEquals(mColumn3, m.getColumnMatrix(1));        try {            m.setColumnMatrix(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnMatrix(0, m);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetRowVector() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealVector mRow0 = new ArrayRealVector(subRow0[0]);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        assertEquals("Row0", mRow0, m.getRowVector(0));        assertEquals("Row3", mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowVector() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowVector(0, mRow3);        assertEquals(mRow3, m.getRowVector(0));        try {            m.setRowVector(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowVector(0, new ArrayRealVector(5));            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetColumnVector() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealVector mColumn1 = columnToVector(subColumn1);        RealVector mColumn3 = columnToVector(subColumn3);        assertEquals("Column1", mColumn1, m.getColumnVector(1));        assertEquals("Column3", mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnVector() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        RealVector mColumn3 = columnToVector(subColumn3);        assertNotSame(mColumn3, m.getColumnVector(1));        m.setColumnVector(1, mColumn3);        assertEquals(mColumn3, m.getColumnVector(1));        try {            m.setColumnVector(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnVector(0, new ArrayRealVector(5));            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    private RealVector columnToVector(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayRealVector(data, false);    }    public void testGetRow() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        checkArrays(subRow0[0], m.getRow(0));        checkArrays(subRow3[0], m.getRow(3));        try {            m.getRow(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRow(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRow() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        assertTrue(subRow3[0][0] != m.getRow(0)[0]);        m.setRow(0, subRow3[0]);        checkArrays(subRow3[0], m.getRow(0));        try {            m.setRow(-1, subRow3[0]);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRow(0, new double[5]);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetColumn() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        double[] mColumn1 = columnToArray(subColumn1);        double[] mColumn3 = columnToArray(subColumn3);        checkArrays(mColumn1, m.getColumn(1));        checkArrays(mColumn3, m.getColumn(3));        try {            m.getColumn(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumn(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumn() {        RealMatrix m = new Array2DRowRealMatrix(subTestData);        double[] mColumn3 = columnToArray(subColumn3);        assertTrue(mColumn3[0] != m.getColumn(1)[0]);        m.setColumn(1, mColumn3);        checkArrays(mColumn3, m.getColumn(1));        try {            m.setColumn(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumn(0, new double[5]);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    private double[] columnToArray(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return data;    }    private void checkArrays(double[] expected, double[] actual) {        assertEquals(expected.length, actual.length);        for (int i = 0; i < expected.length; ++i) {            assertEquals(expected[i], actual[i]);        }    }    public void testEqualsAndHashCode() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        Array2DRowRealMatrix m1 = (Array2DRowRealMatrix) m.copy();        Array2DRowRealMatrix mt = (Array2DRowRealMatrix) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(new Array2DRowRealMatrix(bigSingular)));    }    public void testToString() {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        assertEquals("Array2DRowRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",                m.toString());        m = new Array2DRowRealMatrix();        assertEquals("Array2DRowRealMatrix{}",                m.toString());    }    public void testSetSubMatrix() throws Exception {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        m.setSubMatrix(detData2,1,1);        RealMatrix expected = MatrixUtils.createRealMatrix            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);        m.setSubMatrix(detData2,0,0);        expected = MatrixUtils.createRealMatrix            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);        m.setSubMatrix(testDataPlus2,0,0);        expected = MatrixUtils.createRealMatrix            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});        assertEquals(expected, m);        // dimension overflow        try {            m.setSubMatrix(testData,1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // dimension underflow        try {            m.setSubMatrix(testData,-1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        try {            m.setSubMatrix(testData,1,-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // null        try {            m.setSubMatrix(null,1,1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix();        try {            m2.setSubMatrix(testData,0,1);            fail("expecting IllegalStateException");        } catch (IllegalStateException e) {            // expected        }        try {            m2.setSubMatrix(testData,1,0);            fail("expecting IllegalStateException");        } catch (IllegalStateException e) {            // expected        }        // ragged        try {            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }        // empty        try {            m.setSubMatrix(new double[][] {{}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }    }    public void testWalk() {        int rows    = 150;        int columns = 75;        RealMatrix m = new Array2DRowRealMatrix(rows, columns);        m.walkInRowOrder(new SetVisitor());        GetVisitor getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowRealMatrix(rows, columns);        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);            assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);            assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new Array2DRowRealMatrix(rows, columns);        m.walkInColumnOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowRealMatrix(rows, columns);        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);            assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);            assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new Array2DRowRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);            assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);            assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new Array2DRowRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);            assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);            assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }    }    public void testSerial()  {        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);        assertEquals(m,TestUtils.serializeAndRecover(m));    }    private static class SetVisitor extends DefaultRealMatrixChangingVisitor {        @Override        public double visit(int i, int j, double value) {            return i + j / 1024.0;        }    }    private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {        private int count = 0;        @Override        public void visit(int i, int j, double value) {            ++count;            assertEquals(i + j / 1024.0, value, 0.0);        }        public int getCount() {            return count;        }    }    //--------------- -----------------Protected methods    /** extracts the l  and u matrices from compact lu representation */    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) {        if (!lu.isSquare() ||            lowerData.length != lowerData[0].length ||            upperData.length != upperData[0].length ||            lowerData.length != upperData.length ||            lowerData.length != lu.getRowDimension()) {            throw new IllegalArgumentException("incorrect dimensions");        }        int n = lu.getRowDimension();        for (int i = 0; i < n; i++) {            for (int j = 0; j < n; j++) {                if (j < i) {                    lowerData[i][j] = lu.getEntry(i, j);                    upperData[i][j] = 0d;                } else if (i == j) {                    lowerData[i][j] = 1d;                    upperData[i][j] = lu.getEntry(i, j);                } else {                    lowerData[i][j] = 0d;                    upperData[i][j] = lu.getEntry(i, j);                }            }        }    }    /** Returns the result of applying the given row permutation to the matrix */    protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) {        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {            throw new IllegalArgumentException("dimension mismatch");        }        int n = matrix.getRowDimension();        int m = matrix.getColumnDimension();        double out[][] = new double[m][n];        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                out[i][j] = matrix.getEntry(permutation[i], j);            }        }        return new Array2DRowRealMatrix(out);    }//    /** Useful for debugging *///    private void dumpMatrix(RealMatrix m) {//          for (int i = 0; i < m.getRowDimension(); i++) {//              String os = "";//              for (int j = 0; j < m.getColumnDimension(); j++) {//                  os += m.getEntry(i, j) + " ";//              }//              System.out.println(os);//          }//    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionConversionException;import org.apache.commons.math.fraction.FractionField;import junit.framework.TestCase;/** * Test cases for the {@link SparseFieldVector} class. * * @version $Revision$ $Date$ */public class SparseFieldVectorTest extends TestCase {    //    protected Fraction[][] ma1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)}, {new Fraction(7), new Fraction(8), new Fraction(9)}};    protected Fraction[] vec1 = {new Fraction(1), new Fraction(2), new Fraction(3)};    protected Fraction[] vec2 = {new Fraction(4), new Fraction(5), new Fraction(6)};    protected Fraction[] vec3 = {new Fraction(7), new Fraction(8), new Fraction(9)};    protected Fraction[] vec4 = {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8), new Fraction(9)};    protected Fraction[] vec_null = {new Fraction(0), new Fraction(0), new Fraction(0)};    protected Fraction[] dvec1 = {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8),new Fraction(9)};    protected Fraction[][] mat1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)},{ new Fraction(7), new Fraction(8), new Fraction(9)}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    protected FractionField field = FractionField.getInstance();    public void testMapFunctions() throws FractionConversionException {        SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);        //octave =  v1 .+ 2.0        FieldVector<Fraction> v_mapAdd = v1.mapAdd(new Fraction(2));        Fraction[] result_mapAdd = {new Fraction(3), new Fraction(4), new Fraction(5)};        assertEquals("compare vectors" ,result_mapAdd,v_mapAdd.getData());        //octave =  v1 .+ 2.0        FieldVector<Fraction> v_mapAddToSelf = v1.copy();        v_mapAddToSelf.mapAddToSelf(new Fraction(2));        Fraction[] result_mapAddToSelf = {new Fraction(3), new Fraction(4), new Fraction(5)};        assertEquals("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData());        //octave =  v1 .- 2.0        FieldVector<Fraction> v_mapSubtract = v1.mapSubtract(new Fraction(2));        Fraction[] result_mapSubtract = {new Fraction(-1), new Fraction(0), new Fraction(1)};        assertEquals("compare vectors" ,result_mapSubtract,v_mapSubtract.getData());        //octave =  v1 .- 2.0        FieldVector<Fraction> v_mapSubtractToSelf = v1.copy();        v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));        Fraction[] result_mapSubtractToSelf = {new Fraction(-1), new Fraction(0), new Fraction(1)};        assertEquals("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData());        //octave =  v1 .* 2.0        FieldVector<Fraction> v_mapMultiply = v1.mapMultiply(new Fraction(2));        Fraction[] result_mapMultiply = {new Fraction(2), new Fraction(4), new Fraction(6)};        assertEquals("compare vectors" ,result_mapMultiply,v_mapMultiply.getData());        //octave =  v1 .* 2.0        FieldVector<Fraction> v_mapMultiplyToSelf = v1.copy();        v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));        Fraction[] result_mapMultiplyToSelf = {new Fraction(2), new Fraction(4), new Fraction(6)};        assertEquals("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());        //octave =  v1 ./ 2.0        FieldVector<Fraction> v_mapDivide = v1.mapDivide(new Fraction(2));        Fraction[] result_mapDivide = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)};        assertEquals("compare vectors" ,result_mapDivide,v_mapDivide.getData());        //octave =  v1 ./ 2.0        FieldVector<Fraction> v_mapDivideToSelf = v1.copy();        v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));        Fraction[] result_mapDivideToSelf = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)};        assertEquals("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData());        //octave =  v1 .^-1        FieldVector<Fraction> v_mapInv = v1.mapInv();        Fraction[] result_mapInv = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};        assertEquals("compare vectors" ,result_mapInv,v_mapInv.getData());        //octave =  v1 .^-1        FieldVector<Fraction> v_mapInvToSelf = v1.copy();        v_mapInvToSelf.mapInvToSelf();        Fraction[] result_mapInvToSelf = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};        assertEquals("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData());    }    public void testBasicFunctions() throws FractionConversionException {        SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);        SparseFieldVector<Fraction> v2 = new SparseFieldVector<Fraction>(field,vec2);        SparseFieldVector<Fraction> v2_t = new SparseFieldVector<Fraction>(field,vec2);        //octave =  v1 + v2        FieldVector<Fraction> v_add = v1.add(v2);        Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)};        assertEquals("compare vect" ,v_add.getData(),result_add);        SparseFieldVector<Fraction> vt2 = new SparseFieldVector<Fraction>(field,vec2);        FieldVector<Fraction> v_add_i = v1.add(vt2);        Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)};        assertEquals("compare vect" ,v_add_i.getData(),result_add_i);        //octave =  v1 - v2        SparseFieldVector<Fraction> v_subtract = v1.subtract(v2);        Fraction[] result_subtract = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};        assertClose("compare vect" ,v_subtract.getData(),result_subtract,normTolerance);        FieldVector<Fraction> v_subtract_i = v1.subtract(vt2);        Fraction[] result_subtract_i = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};        assertClose("compare vect" ,v_subtract_i.getData(),result_subtract_i,normTolerance);        // octave v1 .* v2        FieldVector<Fraction>  v_ebeMultiply = v1.ebeMultiply(v2);        Fraction[] result_ebeMultiply = {new Fraction(4), new Fraction(10), new Fraction(18)};        assertClose("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);        FieldVector<Fraction>  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);        Fraction[] result_ebeMultiply_2 = {new Fraction(4), new Fraction(10), new Fraction(18)};        assertClose("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);        // octave v1 ./ v2        FieldVector<Fraction>  v_ebeDivide = v1.ebeDivide(v2);        Fraction[] result_ebeDivide = {new Fraction(0.25d), new Fraction(0.4d), new Fraction(0.5d)};        assertClose("compare vect" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);        FieldVector<Fraction>  v_ebeDivide_2 = v1.ebeDivide(v2_t);        Fraction[] result_ebeDivide_2 = {new Fraction(0.25d), new Fraction(0.4d), new Fraction(0.5d)};        assertClose("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);        // octave  dot(v1,v2)        Fraction dot =  v1.dotProduct(v2);        assertEquals("compare val ",new Fraction(32), dot);        // octave  dot(v1,v2_t)        Fraction dot_2 =  v1.dotProduct(v2_t);        assertEquals("compare val ",new Fraction(32), dot_2);        FieldMatrix<Fraction> m_outerProduct = v1.outerProduct(v2);        assertEquals("compare val ",new Fraction(4), m_outerProduct.getEntry(0,0));        FieldMatrix<Fraction> m_outerProduct_2 = v1.outerProduct(v2_t);        assertEquals("compare val ",new Fraction(4), m_outerProduct_2.getEntry(0,0));    }    public void testMisc() {        SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);        String out1 = v1.toString();        assertTrue("some output ",  out1.length()!=0);        try {            v1.checkVectorDimensions(2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testPredicates() {        SparseFieldVector<Fraction> v = new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) });        v.setEntry(0, field.getZero());        assertEquals(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) }));        assertNotSame(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2), new Fraction(3) }));    }    /** verifies that two vectors are close (sup norm) */    protected void assertEquals(String msg, Fraction[] m, Fraction[] n) {        if (m.length != n.length) {            fail("vectors have different lengths");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " +  i + " elements differ", m[i],n[i]);        }    }    /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, Fraction[] m, Fraction[] n, double tolerance) {        if (m.length != n.length) {            fail("vectors have different lengths");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " +  i + " elements differ", m[i].doubleValue(),n[i].doubleValue(), tolerance);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;/** * Test cases for the {@link OpenMapRealMatrix} class. * * @version $Revision$ $Date: 2008-11-07 06:48:13 -0800 (Fri, 07 Nov *          2008) $ */public final class SparseRealMatrixTest extends TestCase {    // 3 x 3 identity matrix    protected double[][] id = { { 1d, 0d, 0d }, { 0d, 1d, 0d }, { 0d, 0d, 1d } };    // Test data for group operations    protected double[][] testData = { { 1d, 2d, 3d }, { 2d, 5d, 3d },            { 1d, 0d, 8d } };    protected double[][] testDataLU = { { 2d, 5d, 3d }, { .5d, -2.5d, 6.5d },            { 0.5d, 0.2d, .2d } };    protected double[][] testDataPlus2 = { { 3d, 4d, 5d }, { 4d, 7d, 5d },            { 3d, 2d, 10d } };    protected double[][] testDataMinus = { { -1d, -2d, -3d },            { -2d, -5d, -3d }, { -1d, 0d, -8d } };    protected double[] testDataRow1 = { 1d, 2d, 3d };    protected double[] testDataCol3 = { 3d, 3d, 8d };    protected double[][] testDataInv = { { -40d, 16d, 9d }, { 13d, -5d, -3d },            { 5d, -2d, -1d } };    protected double[] preMultTest = { 8, 12, 33 };    protected double[][] testData2 = { { 1d, 2d, 3d }, { 2d, 5d, 3d } };    protected double[][] testData2T = { { 1d, 2d }, { 2d, 5d }, { 3d, 3d } };    protected double[][] testDataPlusInv = { { -39d, 18d, 12d },            { 15d, 0d, 0d }, { 6d, -2d, 7d } };    // lu decomposition tests    protected double[][] luData = { { 2d, 3d, 3d }, { 0d, 5d, 7d }, { 6d, 9d, 8d } };    protected double[][] luDataLUDecomposition = { { 6d, 9d, 8d },            { 0d, 5d, 7d }, { 0.33333333333333, 0d, 0.33333333333333 } };    // singular matrices    protected double[][] singular = { { 2d, 3d }, { 2d, 3d } };    protected double[][] bigSingular = { { 1d, 2d, 3d, 4d },            { 2d, 5d, 3d, 4d }, { 7d, 3d, 256d, 1930d }, { 3d, 7d, 6d, 8d } }; // 4th    // row    // =    // 1st    // +    // 2nd    protected double[][] detData = { { 1d, 2d, 3d }, { 4d, 5d, 6d },            { 7d, 8d, 10d } };    protected double[][] detData2 = { { 1d, 3d }, { 2d, 4d } };    // vectors    protected double[] testVector = { 1, 2, 3 };    protected double[] testVector2 = { 1, 2, 3, 4 };    // submatrix accessor tests    protected double[][] subTestData = { { 1, 2, 3, 4 },            { 1.5, 2.5, 3.5, 4.5 }, { 2, 4, 6, 8 }, { 4, 5, 6, 7 } };    // array selections    protected double[][] subRows02Cols13 = { { 2, 4 }, { 4, 8 } };    protected double[][] subRows03Cols12 = { { 2, 3 }, { 5, 6 } };    protected double[][] subRows03Cols123 = { { 2, 3, 4 }, { 5, 6, 7 } };    // effective permutations    protected double[][] subRows20Cols123 = { { 4, 6, 8 }, { 2, 3, 4 } };    protected double[][] subRows31Cols31 = { { 7, 5 }, { 4.5, 2.5 } };    // contiguous ranges    protected double[][] subRows01Cols23 = { { 3, 4 }, { 3.5, 4.5 } };    protected double[][] subRows23Cols00 = { { 2 }, { 4 } };    protected double[][] subRows00Cols33 = { { 4 } };    // row matrices    protected double[][] subRow0 = { { 1, 2, 3, 4 } };    protected double[][] subRow3 = { { 4, 5, 6, 7 } };    // column matrices    protected double[][] subColumn1 = { { 2 }, { 2.5 }, { 4 }, { 5 } };    protected double[][] subColumn3 = { { 4 }, { 4.5 }, { 8 }, { 7 } };    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    public SparseRealMatrixTest(String name) {        super(name);    }    /** test dimensions */    public void testDimensions() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix m2 = createSparseMatrix(testData2);        assertEquals("testData row dimension", 3, m.getRowDimension());        assertEquals("testData column dimension", 3, m.getColumnDimension());        assertTrue("testData is square", m.isSquare());        assertEquals("testData2 row dimension", m2.getRowDimension(), 2);        assertEquals("testData2 column dimension", m2.getColumnDimension(), 3);        assertTrue("testData2 is not square", !m2.isSquare());    }    /** test copy functions */    public void testCopyFunctions() {        OpenMapRealMatrix m1 = createSparseMatrix(testData);        RealMatrix m2 = m1.copy();        assertEquals(m1.getClass(), m2.getClass());        assertEquals((m2), m1);        OpenMapRealMatrix m3 = createSparseMatrix(testData);        RealMatrix m4 = m3.copy();        assertEquals(m3.getClass(), m4.getClass());        assertEquals((m4), m3);    }    /** test add */    public void testAdd() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix mInv = createSparseMatrix(testDataInv);        OpenMapRealMatrix mDataPlusInv = createSparseMatrix(testDataPlusInv);        RealMatrix mPlusMInv = m.add(mInv);        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                    mDataPlusInv.getEntry(row, col), mPlusMInv.getEntry(row, col),                    entryTolerance);            }        }    }    /** test add failure */    public void testAddFail() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix m2 = createSparseMatrix(testData2);        try {            m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test norm */    public void testNorm() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix m2 = createSparseMatrix(testData2);        assertEquals("testData norm", 14d, m.getNorm(), entryTolerance);        assertEquals("testData2 norm", 7d, m2.getNorm(), entryTolerance);    }    /** test m-n = m + -n */    public void testPlusMinus() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix n = createSparseMatrix(testDataInv);        assertClose("m-n = m + -n", m.subtract(n),            n.scalarMultiply(-1d).add(m), entryTolerance);        try {            m.subtract(createSparseMatrix(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test multiply */    public void testMultiply() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix mInv = createSparseMatrix(testDataInv);        OpenMapRealMatrix identity = createSparseMatrix(id);        OpenMapRealMatrix m2 = createSparseMatrix(testData2);        assertClose("inverse multiply", m.multiply(mInv), identity,                entryTolerance);        assertClose("inverse multiply", m.multiply(new BlockRealMatrix(testDataInv)), identity,                    entryTolerance);        assertClose("inverse multiply", mInv.multiply(m), identity,                entryTolerance);        assertClose("identity multiply", m.multiply(identity), m,                entryTolerance);        assertClose("identity multiply", identity.multiply(mInv), mInv,                entryTolerance);        assertClose("identity multiply", m2.multiply(identity), m2,                entryTolerance);        try {            m.multiply(createSparseMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    // Additional Test for Array2DRowRealMatrixTest.testMultiply    private double[][] d3 = new double[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };    private double[][] d4 = new double[][] { { 1 }, { 2 }, { 3 }, { 4 } };    private double[][] d5 = new double[][] { { 30 }, { 70 } };    public void testMultiply2() {        RealMatrix m3 = createSparseMatrix(d3);        RealMatrix m4 = createSparseMatrix(d4);        RealMatrix m5 = createSparseMatrix(d5);        assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);    }    /** test trace */    public void testTrace() {        RealMatrix m = createSparseMatrix(id);        assertEquals("identity trace", 3d, m.getTrace(), entryTolerance);        m = createSparseMatrix(testData2);        try {            m.getTrace();            fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }    }    /** test sclarAdd */    public void testScalarAdd() {        RealMatrix m = createSparseMatrix(testData);        assertClose("scalar add", createSparseMatrix(testDataPlus2),            m.scalarAdd(2d), entryTolerance);    }    /** test operate */    public void testOperate() {        RealMatrix m = createSparseMatrix(id);        assertClose("identity operate", testVector, m.operate(testVector),                entryTolerance);        assertClose("identity operate", testVector, m.operate(                new ArrayRealVector(testVector)).getData(), entryTolerance);        m = createSparseMatrix(bigSingular);        try {            m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test issue MATH-209 */    public void testMath209() {        RealMatrix a = createSparseMatrix(new double[][] {                { 1, 2 }, { 3, 4 }, { 5, 6 } });        double[] b = a.operate(new double[] { 1, 1 });        assertEquals(a.getRowDimension(), b.length);        assertEquals(3.0, b[0], 1.0e-12);        assertEquals(7.0, b[1], 1.0e-12);        assertEquals(11.0, b[2], 1.0e-12);    }    /** test transpose */    public void testTranspose() {        RealMatrix m = createSparseMatrix(testData);        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();        assertClose("inverse-transpose", mIT, mTI, normTolerance);        m = createSparseMatrix(testData2);        RealMatrix mt = createSparseMatrix(testData2T);        assertClose("transpose",mt,m.transpose(),normTolerance);    }    /** test preMultiply by vector */    public void testPremultiplyVector() {        RealMatrix m = createSparseMatrix(testData);        assertClose("premultiply", m.preMultiply(testVector), preMultTest,            normTolerance);        assertClose("premultiply", m.preMultiply(            new ArrayRealVector(testVector).getData()), preMultTest, normTolerance);        m = createSparseMatrix(bigSingular);        try {            m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testPremultiply() {        RealMatrix m3 = createSparseMatrix(d3);        RealMatrix m4 = createSparseMatrix(d4);        RealMatrix m5 = createSparseMatrix(d5);        assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix mInv = createSparseMatrix(testDataInv);        OpenMapRealMatrix identity = createSparseMatrix(id);        assertClose("inverse multiply", m.preMultiply(mInv), identity,                entryTolerance);        assertClose("inverse multiply", mInv.preMultiply(m), identity,                entryTolerance);        assertClose("identity multiply", m.preMultiply(identity), m,                entryTolerance);        assertClose("identity multiply", identity.preMultiply(mInv), mInv,                entryTolerance);        try {            m.preMultiply(createSparseMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testGetVectors() {        RealMatrix m = createSparseMatrix(testData);        assertClose("get row", m.getRow(0), testDataRow1, entryTolerance);        assertClose("get col", m.getColumn(2), testDataCol3, entryTolerance);        try {            m.getRow(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }        try {            m.getColumn(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }    }    public void testGetEntry() {        RealMatrix m = createSparseMatrix(testData);        assertEquals("get entry", m.getEntry(0, 1), 2d, entryTolerance);        try {            m.getEntry(10, 4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    /** test examples in user guide */    public void testExamples() {        // Create a real matrix with two rows and three columns        double[][] matrixData = { { 1d, 2d, 3d }, { 2d, 5d, 3d } };        RealMatrix m = createSparseMatrix(matrixData);        // One more with three rows, two columns        double[][] matrixData2 = { { 1d, 2d }, { 2d, 5d }, { 1d, 7d } };        RealMatrix n = createSparseMatrix(matrixData2);        // Now multiply m by n        RealMatrix p = m.multiply(n);        assertEquals(2, p.getRowDimension());        assertEquals(2, p.getColumnDimension());        // Invert p        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();        assertEquals(2, pInverse.getRowDimension());        assertEquals(2, pInverse.getColumnDimension());        // Solve example        double[][] coefficientsData = { { 2, 3, -2 }, { -1, 7, 6 },                { 4, -3, -5 } };        RealMatrix coefficients = createSparseMatrix(coefficientsData);        double[] constants = { 1, -2, 1 };        double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);        assertEquals(2 * solution[0] + 3 * solution[1] - 2 * solution[2],                constants[0], 1E-12);        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2],                constants[1], 1E-12);        assertEquals(4 * solution[0] - 3 * solution[1] - 5 * solution[2],                constants[2], 1E-12);    }    // test submatrix accessors    public void testSubMatrix() {        RealMatrix m = createSparseMatrix(subTestData);        RealMatrix mRows23Cols00 = createSparseMatrix(subRows23Cols00);        RealMatrix mRows00Cols33 = createSparseMatrix(subRows00Cols33);        RealMatrix mRows01Cols23 = createSparseMatrix(subRows01Cols23);        RealMatrix mRows02Cols13 = createSparseMatrix(subRows02Cols13);        RealMatrix mRows03Cols12 = createSparseMatrix(subRows03Cols12);        RealMatrix mRows03Cols123 = createSparseMatrix(subRows03Cols123);        RealMatrix mRows20Cols123 = createSparseMatrix(subRows20Cols123);        RealMatrix mRows31Cols31 = createSparseMatrix(subRows31Cols31);        assertEquals("Rows23Cols00", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));        assertEquals("Rows00Cols33", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));        assertEquals("Rows01Cols23", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));        assertEquals("Rows02Cols13", mRows02Cols13,            m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 }));        assertEquals("Rows03Cols12", mRows03Cols12,            m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 }));        assertEquals("Rows03Cols123", mRows03Cols123,            m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 }));        assertEquals("Rows20Cols123", mRows20Cols123,            m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 }));        assertEquals("Rows31Cols31", mRows31Cols31,            m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));        assertEquals("Rows31Cols31", mRows31Cols31,            m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));        try {            m.getSubMatrix(1, 0, 2, 4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(-1, 1, 2, 2);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(1, 0, 2, 2);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(1, 0, 2, 4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(new int[] {}, new int[] { 0 });            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(new int[] { 0 }, new int[] { 4 });            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetRowMatrix() {        RealMatrix m = createSparseMatrix(subTestData);        RealMatrix mRow0 = createSparseMatrix(subRow0);        RealMatrix mRow3 = createSparseMatrix(subRow3);        assertEquals("Row0", mRow0, m.getRowMatrix(0));        assertEquals("Row3", mRow3, m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetColumnMatrix() {        RealMatrix m = createSparseMatrix(subTestData);        RealMatrix mColumn1 = createSparseMatrix(subColumn1);        RealMatrix mColumn3 = createSparseMatrix(subColumn3);        assertEquals("Column1", mColumn1, m.getColumnMatrix(1));        assertEquals("Column3", mColumn3, m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetRowVector() {        RealMatrix m = createSparseMatrix(subTestData);        RealVector mRow0 = new ArrayRealVector(subRow0[0]);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        assertEquals("Row0", mRow0, m.getRowVector(0));        assertEquals("Row3", mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetColumnVector() {        RealMatrix m = createSparseMatrix(subTestData);        RealVector mColumn1 = columnToVector(subColumn1);        RealVector mColumn3 = columnToVector(subColumn3);        assertEquals("Column1", mColumn1, m.getColumnVector(1));        assertEquals("Column3", mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    private RealVector columnToVector(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayRealVector(data, false);    }    public void testEqualsAndHashCode() {        OpenMapRealMatrix m = createSparseMatrix(testData);        OpenMapRealMatrix m1 = m.copy();        OpenMapRealMatrix mt = (OpenMapRealMatrix) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(createSparseMatrix(bigSingular)));    }    public void testToString() {        OpenMapRealMatrix m = createSparseMatrix(testData);        assertEquals("OpenMapRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",            m.toString());        m = new OpenMapRealMatrix(1, 1);        assertEquals("OpenMapRealMatrix{{0.0}}", m.toString());    }    public void testSetSubMatrix() throws Exception {        OpenMapRealMatrix m = createSparseMatrix(testData);        m.setSubMatrix(detData2, 1, 1);        RealMatrix expected = createSparseMatrix(new double[][] {                { 1.0, 2.0, 3.0 }, { 2.0, 1.0, 3.0 }, { 1.0, 2.0, 4.0 } });        assertEquals(expected, m);        m.setSubMatrix(detData2, 0, 0);        expected = createSparseMatrix(new double[][] {                { 1.0, 3.0, 3.0 }, { 2.0, 4.0, 3.0 }, { 1.0, 2.0, 4.0 } });        assertEquals(expected, m);        m.setSubMatrix(testDataPlus2, 0, 0);        expected = createSparseMatrix(new double[][] {                { 3.0, 4.0, 5.0 }, { 4.0, 7.0, 5.0 }, { 3.0, 2.0, 10.0 } });        assertEquals(expected, m);        // javadoc example        OpenMapRealMatrix matrix =            createSparseMatrix(new double[][] {        { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 0, 1, 2 } });        matrix.setSubMatrix(new double[][] { { 3, 4 }, { 5, 6 } }, 1, 1);        expected = createSparseMatrix(new double[][] {                { 1, 2, 3, 4 }, { 5, 3, 4, 8 }, { 9, 5, 6, 2 } });        assertEquals(expected, matrix);        // dimension overflow        try {            m.setSubMatrix(testData, 1, 1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // dimension underflow        try {            m.setSubMatrix(testData, -1, 1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        try {            m.setSubMatrix(testData, 1, -1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // null        try {            m.setSubMatrix(null, 1, 1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }        try {            new OpenMapRealMatrix(0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }        // ragged        try {            m.setSubMatrix(new double[][] { { 1 }, { 2, 3 } }, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }        // empty        try {            m.setSubMatrix(new double[][] { {} }, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }    }    public void testSerial()  {        OpenMapRealMatrix m = createSparseMatrix(testData);        assertEquals(m,TestUtils.serializeAndRecover(m));    }    // --------------- -----------------Protected methods    /** verifies that two matrices are close (1-norm) */    protected void assertClose(String msg, RealMatrix m, RealMatrix n,            double tolerance) {        assertTrue(msg, m.subtract(n).getNorm() < tolerance);    }    /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, double[] m, double[] n,            double tolerance) {        if (m.length != n.length) {            fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " + i + " elements differ", m[i], n[i],                    tolerance);        }    }    private OpenMapRealMatrix createSparseMatrix(double[][] data) {        OpenMapRealMatrix matrix = new OpenMapRealMatrix(data.length, data[0].length);        for (int row = 0; row < data.length; row++) {            for (int col = 0; col < data[row].length; col++) {                matrix.setEntry(row, col, data[row][col]);            }        }        return matrix;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import org.junit.Assert;import org.junit.Test;public class SingularValueSolverTest {    private double[][] testSquare = {            { 24.0 / 25.0, 43.0 / 25.0 },            { 57.0 / 25.0, 24.0 / 25.0 }    };    private static final double normTolerance = 10e-14;    /** test solve dimension errors */    @Test    public void testSolveDimensionErrors() {        DecompositionSolver solver =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);        try {            solver.solve(b);            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            Assert.fail("wrong exception caught");        }        try {            solver.solve(b.getColumn(0));            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            Assert.fail("wrong exception caught");        }        try {            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));            Assert.fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            Assert.fail("wrong exception caught");        }    }    /** test least square solve */    @Test    public void testLeastSquareSolve() {        RealMatrix m =            MatrixUtils.createRealMatrix(new double[][] {                                   { 1.0, 0.0 },                                   { 0.0, 0.0 }                               });        DecompositionSolver solver = new SingularValueDecompositionImpl(m).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {            { 11, 12 }, { 21, 22 }        });        RealMatrix xMatrix = solver.solve(b);        Assert.assertEquals(11, xMatrix.getEntry(0, 0), 1.0e-15);        Assert.assertEquals(12, xMatrix.getEntry(0, 1), 1.0e-15);        Assert.assertEquals(0, xMatrix.getEntry(1, 0), 1.0e-15);        Assert.assertEquals(0, xMatrix.getEntry(1, 1), 1.0e-15);        double[] xCol = solver.solve(b.getColumn(0));        Assert.assertEquals(11, xCol[0], 1.0e-15);        Assert.assertEquals(0, xCol[1], 1.0e-15);        RealVector xColVec = solver.solve(b.getColumnVector(0));        Assert.assertEquals(11, xColVec.getEntry(0), 1.0e-15);        Assert.assertEquals(0, xColVec.getEntry(1), 1.0e-15);        RealVector xColOtherVec = solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));        Assert.assertEquals(11, xColOtherVec.getEntry(0), 1.0e-15);        Assert.assertEquals(0, xColOtherVec.getEntry(1), 1.0e-15);    }    /** test solve */    @Test    public void testSolve() {        DecompositionSolver solver =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                { 1, 2, 3 }, { 0, -5, 1 }        });        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                { -8.0 / 25.0, -263.0 / 75.0, -29.0 / 75.0 },                { 19.0 / 25.0,   78.0 / 25.0,  49.0 / 25.0 }        });        // using RealMatrix        Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), normTolerance);        // using double[]        for (int i = 0; i < b.getColumnDimension(); ++i) {            Assert.assertEquals(0,                         new ArrayRealVector(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }        // using Array2DRowRealMatrix        for (int i = 0; i < b.getColumnDimension(); ++i) {            Assert.assertEquals(0,                         solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }        // using RealMatrix with an alternate implementation        for (int i = 0; i < b.getColumnDimension(); ++i) {            ArrayRealVectorTest.RealVectorTestImpl v =                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));            Assert.assertEquals(0,                         solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }    }    /** test condition number */    @Test    public void testConditionNumber() {        SingularValueDecompositionImpl svd =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));        // replace 1.0e-15 with 1.5e-15        Assert.assertEquals(3.0, svd.getConditionNumber(), 1.5e-15);    }    @Test    public void testMath320B() {        RealMatrix rm = new Array2DRowRealMatrix(new double[][] {            { 1.0, 2.0 }, { 1.0, 2.0 }        });        SingularValueDecomposition svd =            new SingularValueDecompositionImpl(rm);        RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());        Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 2.0e-15);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.io.Serializable;import java.util.Iterator;import junit.framework.TestCase;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;/** * Test cases for the {@link OpenMapRealVector} class. * * @version $Revision$ $Date$ */public class SparseRealVectorTest extends TestCase {    //    protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};    protected double[] vec1 = {1d, 2d, 3d};    protected double[] vec2 = {4d, 5d, 6d};    protected double[] vec3 = {7d, 8d, 9d};    protected double[] vec4 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};    protected double[] vec5 = { -4d, 0d, 3d, 1d, -6d, 3d};    protected double[] vec_null = {0d, 0d, 0d};    protected Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};    protected double[][] mat1 = {{1d, 2d, 3d}, {4d, 5d, 6d},{ 7d, 8d, 9d}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    // Testclass to test the RealVector interface    // only with enough content to support the test    public static class SparseRealVectorTestImpl extends AbstractRealVector implements Serializable {        private static final long serialVersionUID = -6251371752518113791L;        /** Entries of the vector. */        protected double data[];        public SparseRealVectorTestImpl(double[] d) {            data = d.clone();        }        private UnsupportedOperationException unsupported() {            return new UnsupportedOperationException("Not supported, unneeded for test purposes");        }        @Override        public RealVector map(UnivariateRealFunction function) throws FunctionEvaluationException {            throw unsupported();        }        @Override        public RealVector mapToSelf(UnivariateRealFunction function) throws FunctionEvaluationException {            throw unsupported();        }        @Override        public Iterator<Entry> iterator() {            throw unsupported();        }        @Override        public AbstractRealVector copy() {            return new SparseRealVectorTestImpl(data);        }        @Override        public RealVector add(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public RealVector add(double[] v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public RealVector subtract(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public RealVector subtract(double[] v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public RealVector mapAdd(double d) {            throw unsupported();        }        @Override        public RealVector mapAddToSelf(double d) {            throw unsupported();        }        @Override        public RealVector mapSubtract(double d) {            throw unsupported();        }        @Override        public RealVector mapSubtractToSelf(double d) {            throw unsupported();        }        @Override        public RealVector mapMultiply(double d) {            double[] out = new double[data.length];            for (int i = 0; i < data.length; i++) {                out[i] = data[i] * d;            }            return new OpenMapRealVector(out);        }        @Override        public RealVector mapMultiplyToSelf(double d) {            throw unsupported();        }        @Override        public RealVector mapDivide(double d) {            throw unsupported();        }        @Override        public RealVector mapDivideToSelf(double d) {            throw unsupported();        }        @Override        public RealVector mapPow(double d) {            throw unsupported();        }        @Override        public RealVector mapPowToSelf(double d) {            throw unsupported();        }        @Override        public RealVector mapExp() {            throw unsupported();        }        @Override        public RealVector mapExpToSelf() {            throw unsupported();        }        @Override        public RealVector mapExpm1() {            throw unsupported();        }        @Override        public RealVector mapExpm1ToSelf() {            throw unsupported();        }        @Override        public RealVector mapLog() {            throw unsupported();        }        @Override        public RealVector mapLogToSelf() {            throw unsupported();        }        @Override        public RealVector mapLog10() {            throw unsupported();        }        @Override        public RealVector mapLog10ToSelf() {            throw unsupported();        }        @Override        public RealVector mapLog1p() {            throw unsupported();        }        @Override        public RealVector mapLog1pToSelf() {            throw unsupported();        }        @Override        public RealVector mapCosh() {            throw unsupported();        }        @Override        public RealVector mapCoshToSelf() {            throw unsupported();        }        @Override        public RealVector mapSinh() {            throw unsupported();        }        @Override        public RealVector mapSinhToSelf() {            throw unsupported();        }        @Override        public RealVector mapTanh() {            throw unsupported();        }        @Override        public RealVector mapTanhToSelf() {            throw unsupported();        }        @Override        public RealVector mapCos() {            throw unsupported();        }        @Override        public RealVector mapCosToSelf() {            throw unsupported();        }        @Override        public RealVector mapSin() {            throw unsupported();        }        @Override        public RealVector mapSinToSelf() {            throw unsupported();        }        @Override        public RealVector mapTan() {            throw unsupported();        }        @Override        public RealVector mapTanToSelf() {            throw unsupported();        }        @Override        public RealVector mapAcos() {            throw unsupported();        }        @Override        public RealVector mapAcosToSelf() {            throw unsupported();        }        @Override        public RealVector mapAsin() {            throw unsupported();        }        @Override        public RealVector mapAsinToSelf() {            throw unsupported();        }        @Override        public RealVector mapAtan() {            throw unsupported();        }        @Override        public RealVector mapAtanToSelf() {            throw unsupported();        }        @Override        public RealVector mapInv() {            throw unsupported();        }        @Override        public RealVector mapInvToSelf() {            throw unsupported();        }        @Override        public RealVector mapAbs() {            throw unsupported();        }        @Override        public RealVector mapAbsToSelf() {            throw unsupported();        }        @Override        public RealVector mapSqrt() {            throw unsupported();        }        @Override        public RealVector mapSqrtToSelf() {            throw unsupported();        }        @Override        public RealVector mapCbrt() {            throw unsupported();        }        @Override        public RealVector mapCbrtToSelf() {            throw unsupported();        }        @Override        public RealVector mapCeil() {            throw unsupported();        }        @Override        public RealVector mapCeilToSelf() {            throw unsupported();        }        @Override        public RealVector mapFloor() {            throw unsupported();        }        @Override        public RealVector mapFloorToSelf() {            throw unsupported();        }        @Override        public RealVector mapRint() {            throw unsupported();        }        @Override        public RealVector mapRintToSelf() {            throw unsupported();        }        @Override        public RealVector mapSignum() {            throw unsupported();        }        @Override        public RealVector mapSignumToSelf() {            throw unsupported();        }        @Override        public RealVector mapUlp() {            throw unsupported();        }        @Override        public RealVector mapUlpToSelf() {            throw unsupported();        }        public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public RealVector ebeDivide(double[] v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public double[] getData() {            return data.clone();        }        @Override        public double dotProduct(RealVector v) throws IllegalArgumentException {            double dot = 0;            for (int i = 0; i < data.length; i++) {                dot += data[i] * v.getEntry(i);            }            return dot;        }        @Override        public double dotProduct(double[] v) throws IllegalArgumentException {            double dot = 0;            for (int i = 0; i < data.length; i++) {                dot += data[i] * v[i];            }            return dot;        }        @Override        public double getNorm() {            throw unsupported();        }        @Override        public double getL1Norm() {            throw unsupported();        }        @Override        public double getLInfNorm() {            throw unsupported();        }        @Override        public double getDistance(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public double getDistance(double[] v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public double getL1Distance(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public double getL1Distance(double[] v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public double getLInfDistance(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public double getLInfDistance(double[] v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public RealVector unitVector() {            throw unsupported();        }        @Override        public void unitize() {            throw unsupported();        }        public RealVector projection(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public RealVector projection(double[] v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        @Override        public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public double getEntry(int index) throws MatrixIndexException {            return data[index];        }        public int getDimension() {            return data.length;        }        public RealVector append(RealVector v) {            throw unsupported();        }        public RealVector append(double d) {            throw unsupported();        }        public RealVector append(double[] a) {            throw unsupported();        }        public RealVector getSubVector(int index, int n) throws MatrixIndexException {            throw unsupported();        }        public void setEntry(int index, double value) throws MatrixIndexException {            data[index] = value;        }        @Override        public void setSubVector(int index, RealVector v) throws MatrixIndexException {            throw unsupported();        }        @Override        public void setSubVector(int index, double[] v) throws MatrixIndexException {            throw unsupported();        }        @Override        public void set(double value) {            throw unsupported();        }        @Override        public double[] toArray() {            throw unsupported();        }        public boolean isNaN() {            throw unsupported();        }        public boolean isInfinite() {            throw unsupported();        }    }    public void testConstructors() {        OpenMapRealVector v0 = new OpenMapRealVector();        assertEquals("testData len", 0, v0.getDimension());        OpenMapRealVector v1 = new OpenMapRealVector(7);        assertEquals("testData len", 7, v1.getDimension());        assertEquals("testData is 0.0 ", 0.0, v1.getEntry(6));        OpenMapRealVector v3 = new OpenMapRealVector(vec1);        assertEquals("testData len", 3, v3.getDimension());        assertEquals("testData is 2.0 ", 2.0, v3.getEntry(1));        //SparseRealVector v4 = new SparseRealVector(vec4, 3, 2);        //assertEquals("testData len", 2, v4.getDimension());        //assertEquals("testData is 4.0 ", 4.0, v4.getEntry(0));        //try {        //    new SparseRealVector(vec4, 8, 3);        //    fail("IllegalArgumentException expected");        //} catch (IllegalArgumentException ex) {            // expected behavior        //} catch (Exception e) {        //    fail("wrong exception caught");        //}        RealVector v5_i = new OpenMapRealVector(dvec1);        assertEquals("testData len", 9, v5_i.getDimension());        assertEquals("testData is 9.0 ", 9.0, v5_i.getEntry(8));        OpenMapRealVector v5 = new OpenMapRealVector(dvec1);        assertEquals("testData len", 9, v5.getDimension());        assertEquals("testData is 9.0 ", 9.0, v5.getEntry(8));        OpenMapRealVector v7 = new OpenMapRealVector(v1);        assertEquals("testData len", 7, v7.getDimension());        assertEquals("testData is 0.0 ", 0.0, v7.getEntry(6));        SparseRealVectorTestImpl v7_i = new SparseRealVectorTestImpl(vec1);        OpenMapRealVector v7_2 = new OpenMapRealVector(v7_i);        assertEquals("testData len", 3, v7_2.getDimension());        assertEquals("testData is 0.0 ", 2.0d, v7_2.getEntry(1));        OpenMapRealVector v8 = new OpenMapRealVector(v1);        assertEquals("testData len", 7, v8.getDimension());        assertEquals("testData is 0.0 ", 0.0, v8.getEntry(6));    }    public void testDataInOut() {        OpenMapRealVector v1 = new OpenMapRealVector(vec1);        OpenMapRealVector v2 = new OpenMapRealVector(vec2);        OpenMapRealVector v4 = new OpenMapRealVector(vec4);        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2);        RealVector v_append_1 = v1.append(v2);        assertEquals("testData len", 6, v_append_1.getDimension());        assertEquals("testData is 4.0 ", 4.0, v_append_1.getEntry(3));        RealVector v_append_2 = v1.append(2.0);        assertEquals("testData len", 4, v_append_2.getDimension());        assertEquals("testData is 2.0 ", 2.0, v_append_2.getEntry(3));        RealVector v_append_3 = v1.append(vec2);        assertEquals("testData len", 6, v_append_3.getDimension());        assertEquals("testData is  ", 4.0, v_append_3.getEntry(3));        RealVector v_append_4 = v1.append(v2_t);        assertEquals("testData len", 6, v_append_4.getDimension());        assertEquals("testData is 4.0 ", 4.0, v_append_4.getEntry(3));        RealVector vout5 = v4.getSubVector(3, 3);        assertEquals("testData len", 3, vout5.getDimension());        assertEquals("testData is 4.0 ", 5.0, vout5.getEntry(1));        try {            v4.getSubVector(3, 7);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        OpenMapRealVector v_set1 = v1.copy();        v_set1.setEntry(1, 11.0);        assertEquals("testData is 11.0 ", 11.0, v_set1.getEntry(1));        try {            v_set1.setEntry(3, 11.0);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        OpenMapRealVector v_set2 = v4.copy();        v_set2.setSubVector(3, v1);        assertEquals("testData is 1.0 ", 1.0, v_set2.getEntry(3));        assertEquals("testData is 7.0 ", 7.0, v_set2.getEntry(6));        try {            v_set2.setSubVector(7, v1);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        OpenMapRealVector v_set3 = v1.copy();        v_set3.set(13.0);        assertEquals("testData is 13.0 ", 13.0, v_set3.getEntry(2));        try {            v_set3.getEntry(23);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        OpenMapRealVector v_set4 = v4.copy();        v_set4.setSubVector(3, v2_t);        assertEquals("testData is 1.0 ", 4.0, v_set4.getEntry(3));        assertEquals("testData is 7.0 ", 7.0, v_set4.getEntry(6));        try {            v_set4.setSubVector(7, v2_t);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testMapFunctions() {        OpenMapRealVector v1 = new OpenMapRealVector(vec1);        //octave =  v1 .+ 2.0        RealVector v_mapAdd = v1.mapAdd(2.0d);        double[] result_mapAdd = {3d, 4d, 5d};        assertClose("compare vectors" ,result_mapAdd,v_mapAdd.getData(),normTolerance);        //octave =  v1 .+ 2.0        RealVector v_mapAddToSelf = v1.copy();        v_mapAddToSelf.mapAddToSelf(2.0d);        double[] result_mapAddToSelf = {3d, 4d, 5d};        assertClose("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData(),normTolerance);        //octave =  v1 .- 2.0        RealVector v_mapSubtract = v1.mapSubtract(2.0d);        double[] result_mapSubtract = {-1d, 0d, 1d};        assertClose("compare vectors" ,result_mapSubtract,v_mapSubtract.getData(),normTolerance);        //octave =  v1 .- 2.0        RealVector v_mapSubtractToSelf = v1.copy();        v_mapSubtractToSelf.mapSubtractToSelf(2.0d);        double[] result_mapSubtractToSelf = {-1d, 0d, 1d};        assertClose("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData(),normTolerance);        //octave =  v1 .* 2.0        RealVector v_mapMultiply = v1.mapMultiply(2.0d);        double[] result_mapMultiply = {2d, 4d, 6d};        assertClose("compare vectors" ,result_mapMultiply,v_mapMultiply.getData(),normTolerance);        //octave =  v1 .* 2.0        RealVector v_mapMultiplyToSelf = v1.copy();        v_mapMultiplyToSelf.mapMultiplyToSelf(2.0d);        double[] result_mapMultiplyToSelf = {2d, 4d, 6d};        assertClose("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData(),normTolerance);        //octave =  v1 ./ 2.0        RealVector v_mapDivide = v1.mapDivide(2.0d);        double[] result_mapDivide = {.5d, 1d, 1.5d};        assertClose("compare vectors" ,result_mapDivide,v_mapDivide.getData(),normTolerance);        //octave =  v1 ./ 2.0        RealVector v_mapDivideToSelf = v1.copy();        v_mapDivideToSelf.mapDivideToSelf(2.0d);        double[] result_mapDivideToSelf = {.5d, 1d, 1.5d};        assertClose("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData(),normTolerance);        //octave =  v1 .^ 2.0        RealVector v_mapPow = v1.mapPow(2.0d);        double[] result_mapPow = {1d, 4d, 9d};        assertClose("compare vectors" ,result_mapPow,v_mapPow.getData(),normTolerance);        //octave =  v1 .^ 2.0        RealVector v_mapPowToSelf = v1.copy();        v_mapPowToSelf.mapPowToSelf(2.0d);        double[] result_mapPowToSelf = {1d, 4d, 9d};        assertClose("compare vectors" ,result_mapPowToSelf,v_mapPowToSelf.getData(),normTolerance);        //octave =  exp(v1)        RealVector v_mapExp = v1.mapExp();        double[] result_mapExp = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};        assertClose("compare vectors" ,result_mapExp,v_mapExp.getData(),normTolerance);        //octave =  exp(v1)        RealVector v_mapExpToSelf = v1.copy();        v_mapExpToSelf.mapExpToSelf();        double[] result_mapExpToSelf = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};        assertClose("compare vectors" ,result_mapExpToSelf,v_mapExpToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapExpm1 = v1.mapExpm1();        double[] result_mapExpm1 = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};        assertClose("compare vectors" ,result_mapExpm1,v_mapExpm1.getData(),normTolerance);        //octave =  ???        RealVector v_mapExpm1ToSelf = v1.copy();        v_mapExpm1ToSelf.mapExpm1ToSelf();        double[] result_mapExpm1ToSelf = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};        assertClose("compare vectors" ,result_mapExpm1ToSelf,v_mapExpm1ToSelf.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLog = v1.mapLog();        double[] result_mapLog = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};        assertClose("compare vectors" ,result_mapLog,v_mapLog.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLogToSelf = v1.copy();        v_mapLogToSelf.mapLogToSelf();        double[] result_mapLogToSelf = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};        assertClose("compare vectors" ,result_mapLogToSelf,v_mapLogToSelf.getData(),normTolerance);        //octave =  log10(v1)        RealVector v_mapLog10 = v1.mapLog10();        double[] result_mapLog10 = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};        assertClose("compare vectors" ,result_mapLog10,v_mapLog10.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLog10ToSelf = v1.copy();        v_mapLog10ToSelf.mapLog10ToSelf();        double[] result_mapLog10ToSelf = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};        assertClose("compare vectors" ,result_mapLog10ToSelf,v_mapLog10ToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapLog1p = v1.mapLog1p();        double[] result_mapLog1p = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};        assertClose("compare vectors" ,result_mapLog1p,v_mapLog1p.getData(),normTolerance);        //octave =  ???        RealVector v_mapLog1pToSelf = v1.copy();        v_mapLog1pToSelf.mapLog1pToSelf();        double[] result_mapLog1pToSelf = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};        assertClose("compare vectors" ,result_mapLog1pToSelf,v_mapLog1pToSelf.getData(),normTolerance);        //octave =  cosh(v1)        RealVector v_mapCosh = v1.mapCosh();        double[] result_mapCosh = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};        assertClose("compare vectors" ,result_mapCosh,v_mapCosh.getData(),normTolerance);        //octave =  cosh(v1)        RealVector v_mapCoshToSelf = v1.copy();        v_mapCoshToSelf.mapCoshToSelf();        double[] result_mapCoshToSelf = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};        assertClose("compare vectors" ,result_mapCoshToSelf,v_mapCoshToSelf.getData(),normTolerance);        //octave =  sinh(v1)        RealVector v_mapSinh = v1.mapSinh();        double[] result_mapSinh = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};        assertClose("compare vectors" ,result_mapSinh,v_mapSinh.getData(),normTolerance);        //octave =  sinh(v1)        RealVector v_mapSinhToSelf = v1.copy();        v_mapSinhToSelf.mapSinhToSelf();        double[] result_mapSinhToSelf = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};        assertClose("compare vectors" ,result_mapSinhToSelf,v_mapSinhToSelf.getData(),normTolerance);        //octave =  tanh(v1)        RealVector v_mapTanh = v1.mapTanh();        double[] result_mapTanh = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};        assertClose("compare vectors" ,result_mapTanh,v_mapTanh.getData(),normTolerance);        //octave =  tanh(v1)        RealVector v_mapTanhToSelf = v1.copy();        v_mapTanhToSelf.mapTanhToSelf();        double[] result_mapTanhToSelf = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};        assertClose("compare vectors" ,result_mapTanhToSelf,v_mapTanhToSelf.getData(),normTolerance);        //octave =  cos(v1)        RealVector v_mapCos = v1.mapCos();        double[] result_mapCos = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};        assertClose("compare vectors" ,result_mapCos,v_mapCos.getData(),normTolerance);        //octave =  cos(v1)        RealVector v_mapCosToSelf = v1.copy();        v_mapCosToSelf.mapCosToSelf();        double[] result_mapCosToSelf = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};        assertClose("compare vectors" ,result_mapCosToSelf,v_mapCosToSelf.getData(),normTolerance);        //octave =  sin(v1)        RealVector v_mapSin = v1.mapSin();        double[] result_mapSin = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};        assertClose("compare vectors" ,result_mapSin,v_mapSin.getData(),normTolerance);        //octave =  sin(v1)        RealVector v_mapSinToSelf = v1.copy();        v_mapSinToSelf.mapSinToSelf();        double[] result_mapSinToSelf = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};        assertClose("compare vectors" ,result_mapSinToSelf,v_mapSinToSelf.getData(),normTolerance);        //octave =  tan(v1)        RealVector v_mapTan = v1.mapTan();        double[] result_mapTan = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};        assertClose("compare vectors" ,result_mapTan,v_mapTan.getData(),normTolerance);        //octave =  tan(v1)        RealVector v_mapTanToSelf = v1.copy();        v_mapTanToSelf.mapTanToSelf();        double[] result_mapTanToSelf = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};        assertClose("compare vectors" ,result_mapTanToSelf,v_mapTanToSelf.getData(),normTolerance);        double[] vat_a = {0d, 0.5d, 1.0d};        OpenMapRealVector vat = new OpenMapRealVector(vat_a);        //octave =  acos(vat)        RealVector v_mapAcos = vat.mapAcos();        double[] result_mapAcos = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};        assertClose("compare vectors" ,result_mapAcos,v_mapAcos.getData(),normTolerance);        //octave =  acos(vat)        RealVector v_mapAcosToSelf = vat.copy();        v_mapAcosToSelf.mapAcosToSelf();        double[] result_mapAcosToSelf = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};        assertClose("compare vectors" ,result_mapAcosToSelf,v_mapAcosToSelf.getData(),normTolerance);        //octave =  asin(vat)        RealVector v_mapAsin = vat.mapAsin();        double[] result_mapAsin = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};        assertClose("compare vectors" ,result_mapAsin,v_mapAsin.getData(),normTolerance);        //octave =  asin(vat)        RealVector v_mapAsinToSelf = vat.copy();        v_mapAsinToSelf.mapAsinToSelf();        double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};        assertClose("compare vectors" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);        //octave =  atan(vat)        RealVector v_mapAtan = vat.mapAtan();        double[] result_mapAtan = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};        assertClose("compare vectors" ,result_mapAtan,v_mapAtan.getData(),normTolerance);        //octave =  atan(vat)        RealVector v_mapAtanToSelf = vat.copy();        v_mapAtanToSelf.mapAtanToSelf();        double[] result_mapAtanToSelf = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};        assertClose("compare vectors" ,result_mapAtanToSelf,v_mapAtanToSelf.getData(),normTolerance);        //octave =  v1 .^-1        RealVector v_mapInv = v1.mapInv();        double[] result_mapInv = {1d,0.5d,3.333333333333333e-01d};        assertClose("compare vectors" ,result_mapInv,v_mapInv.getData(),normTolerance);        //octave =  v1 .^-1        RealVector v_mapInvToSelf = v1.copy();        v_mapInvToSelf.mapInvToSelf();        double[] result_mapInvToSelf = {1d,0.5d,3.333333333333333e-01d};        assertClose("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData(),normTolerance);        double[] abs_a = {-1.0d, 0.0d, 1.0d};        OpenMapRealVector abs_v = new OpenMapRealVector(abs_a);        //octave =  abs(abs_v)        RealVector v_mapAbs = abs_v.mapAbs();        double[] result_mapAbs = {1d,0d,1d};        assertClose("compare vectors" ,result_mapAbs,v_mapAbs.getData(),normTolerance);        //octave = abs(abs_v)        RealVector v_mapAbsToSelf = abs_v.copy();        v_mapAbsToSelf.mapAbsToSelf();        double[] result_mapAbsToSelf = {1d,0d,1d};        assertClose("compare vectors" ,result_mapAbsToSelf,v_mapAbsToSelf.getData(),normTolerance);        //octave =   sqrt(v1)        RealVector v_mapSqrt = v1.mapSqrt();        double[] result_mapSqrt = {1d,1.414213562373095e+00d,1.732050807568877e+00d};        assertClose("compare vectors" ,result_mapSqrt,v_mapSqrt.getData(),normTolerance);        //octave =  sqrt(v1)        RealVector v_mapSqrtToSelf = v1.copy();        v_mapSqrtToSelf.mapSqrtToSelf();        double[] result_mapSqrtToSelf = {1d,1.414213562373095e+00d,1.732050807568877e+00d};        assertClose("compare vectors" ,result_mapSqrtToSelf,v_mapSqrtToSelf.getData(),normTolerance);        double[] cbrt_a = {-2.0d, 0.0d, 2.0d};        OpenMapRealVector cbrt_v = new OpenMapRealVector(cbrt_a);        //octave =  ???        RealVector v_mapCbrt = cbrt_v.mapCbrt();        double[] result_mapCbrt = {-1.2599210498948732d,0d,1.2599210498948732d};        assertClose("compare vectors" ,result_mapCbrt,v_mapCbrt.getData(),normTolerance);        //octave = ???        RealVector v_mapCbrtToSelf = cbrt_v.copy();        v_mapCbrtToSelf.mapCbrtToSelf();        double[] result_mapCbrtToSelf =  {-1.2599210498948732d,0d,1.2599210498948732d};        assertClose("compare vectors" ,result_mapCbrtToSelf,v_mapCbrtToSelf.getData(),normTolerance);        double[] ceil_a = {-1.1d, 0.9d, 1.1d};        OpenMapRealVector ceil_v = new OpenMapRealVector(ceil_a);        //octave =  ceil(ceil_v)        RealVector v_mapCeil = ceil_v.mapCeil();        double[] result_mapCeil = {-1d,1d,2d};        assertClose("compare vectors" ,result_mapCeil,v_mapCeil.getData(),normTolerance);        //octave = ceil(ceil_v)        RealVector v_mapCeilToSelf = ceil_v.copy();        v_mapCeilToSelf.mapCeilToSelf();        double[] result_mapCeilToSelf =  {-1d,1d,2d};        assertClose("compare vectors" ,result_mapCeilToSelf,v_mapCeilToSelf.getData(),normTolerance);        //octave =  floor(ceil_v)        RealVector v_mapFloor = ceil_v.mapFloor();        double[] result_mapFloor = {-2d,0d,1d};        assertClose("compare vectors" ,result_mapFloor,v_mapFloor.getData(),normTolerance);        //octave = floor(ceil_v)        RealVector v_mapFloorToSelf = ceil_v.copy();        v_mapFloorToSelf.mapFloorToSelf();        double[] result_mapFloorToSelf =  {-2d,0d,1d};        assertClose("compare vectors" ,result_mapFloorToSelf,v_mapFloorToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapRint = ceil_v.mapRint();        double[] result_mapRint = {-1d,1d,1d};        assertClose("compare vectors" ,result_mapRint,v_mapRint.getData(),normTolerance);        //octave = ???        RealVector v_mapRintToSelf = ceil_v.copy();        v_mapRintToSelf.mapRintToSelf();        double[] result_mapRintToSelf =  {-1d,1d,1d};        assertClose("compare vectors" ,result_mapRintToSelf,v_mapRintToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapSignum = ceil_v.mapSignum();        double[] result_mapSignum = {-1d,1d,1d};        assertClose("compare vectors" ,result_mapSignum,v_mapSignum.getData(),normTolerance);        //octave = ???        RealVector v_mapSignumToSelf = ceil_v.copy();        v_mapSignumToSelf.mapSignumToSelf();        double[] result_mapSignumToSelf =  {-1d,1d,1d};        assertClose("compare vectors" ,result_mapSignumToSelf,v_mapSignumToSelf.getData(),normTolerance);        // Is with the used resolutions of limited value as test        //octave =  ???        RealVector v_mapUlp = ceil_v.mapUlp();        double[] result_mapUlp = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};        assertClose("compare vectors" ,result_mapUlp,v_mapUlp.getData(),normTolerance);        //octave = ???        RealVector v_mapUlpToSelf = ceil_v.copy();        v_mapUlpToSelf.mapUlpToSelf();        double[] result_mapUlpToSelf = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};        assertClose("compare vectors" ,result_mapUlpToSelf,v_mapUlpToSelf.getData(),normTolerance);    }    public void testBasicFunctions() {        OpenMapRealVector v1 = new OpenMapRealVector(vec1);        OpenMapRealVector v2 = new OpenMapRealVector(vec2);        OpenMapRealVector v5 = new OpenMapRealVector(vec5);        OpenMapRealVector v_null = new OpenMapRealVector(vec_null);        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2);        // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307        double d_getNorm = v5.getNorm();        assertEquals("compare values  ", 8.4261497731763586307, d_getNorm);        // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17        double d_getL1Norm = v5.getL1Norm();        assertEquals("compare values  ", 17.0, d_getL1Norm);        // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6        double d_getLInfNorm = v5.getLInfNorm();        assertEquals("compare values  ", 6.0, d_getLInfNorm);        //octave =  sqrt(sumsq(v1-v2))        double dist = v1.getDistance(v2);        assertEquals("compare values  ",v1.subtract(v2).getNorm(), dist );        //octave =  sqrt(sumsq(v1-v2))        double dist_2 = v1.getDistance(v2_t);        assertEquals("compare values  ", v1.subtract(v2).getNorm(),dist_2 );        //octave =  ???        double d_getL1Distance = v1. getL1Distance(v2);        assertEquals("compare values  ",9d, d_getL1Distance );        double d_getL1Distance_2 = v1. getL1Distance(v2_t);        assertEquals("compare values  ",9d, d_getL1Distance_2 );        //octave =  ???        double d_getLInfDistance = v1. getLInfDistance(v2);        assertEquals("compare values  ",3d, d_getLInfDistance );        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);        assertEquals("compare values  ",3d, d_getLInfDistance_2 );        //octave =  v1 + v2        OpenMapRealVector v_add = v1.add(v2);        double[] result_add = {5d, 7d, 9d};        assertClose("compare vect" ,v_add.getData(),result_add,normTolerance);        SparseRealVectorTestImpl vt2 = new SparseRealVectorTestImpl(vec2);        RealVector v_add_i = v1.add(vt2);        double[] result_add_i = {5d, 7d, 9d};        assertClose("compare vect" ,v_add_i.getData(),result_add_i,normTolerance);        //octave =  v1 - v2        OpenMapRealVector v_subtract = v1.subtract(v2);        double[] result_subtract = {-3d, -3d, -3d};        assertClose("compare vect" ,v_subtract.getData(),result_subtract,normTolerance);        RealVector v_subtract_i = v1.subtract(vt2);        double[] result_subtract_i = {-3d, -3d, -3d};        assertClose("compare vect" ,v_subtract_i.getData(),result_subtract_i,normTolerance);        // octave v1 .* v2        RealVector  v_ebeMultiply = v1.ebeMultiply(v2);        double[] result_ebeMultiply = {4d, 10d, 18d};        assertClose("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);        double[] result_ebeMultiply_2 = {4d, 10d, 18d};        assertClose("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);        // octave v1 ./ v2        RealVector  v_ebeDivide = v1.ebeDivide(v2);        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};        assertClose("compare vect" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};        assertClose("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);        // octave  dot(v1,v2)        double dot =  v1.dotProduct(v2);        assertEquals("compare val ",32d, dot);        // octave  dot(v1,v2_t)        double dot_2 =  v1.dotProduct(v2_t);        assertEquals("compare val ",32d, dot_2);        RealMatrix m_outerProduct = v1.outerProduct(v2);        assertEquals("compare val ",4d, m_outerProduct.getEntry(0,0));        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);        assertEquals("compare val ",4d, m_outerProduct_2.getEntry(0,0));        RealVector v_unitVector = v1.unitVector();        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());        assertClose("compare vect" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);        try {            v_null.unitVector();            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        OpenMapRealVector v_unitize = v1.copy();        v_unitize.unitize();        assertClose("compare vect" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);        try {            v_null.unitize();            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        RealVector v_projection = v1.projection(v2);        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};        assertClose("compare vect", v_projection.getData(), result_projection, normTolerance);        RealVector v_projection_2 = v1.projection(v2_t);        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};        assertClose("compare vect", v_projection_2.getData(), result_projection_2, normTolerance);    }    public void testMisc() {        OpenMapRealVector v1 = new OpenMapRealVector(vec1);        String out1 = v1.toString();        assertTrue("some output ",  out1.length()!=0);        try {            v1.checkVectorDimensions(2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testPredicates() {        OpenMapRealVector v = new OpenMapRealVector(new double[] { 0, 1, 2 });        assertFalse(v.isNaN());        v.setEntry(1, Double.NaN);        assertTrue(v.isNaN());        assertFalse(v.isInfinite());        v.setEntry(0, Double.POSITIVE_INFINITY);        assertFalse(v.isInfinite()); // NaN has higher priority than infinity        v.setEntry(1, 1);        assertTrue(v.isInfinite());        v.setEntry(0, 0);        assertEquals(v, new OpenMapRealVector(new double[] { 0, 1, 2 }));        assertNotSame(v, new OpenMapRealVector(new double[] { 0, 1, 2 + FastMath.ulp(2)}));        assertNotSame(v, new OpenMapRealVector(new double[] { 0, 1, 2, 3 }));    }    public void testSerial()  {        OpenMapRealVector v = new OpenMapRealVector(new double[] { 0, 1, 2 });        assertEquals(v,TestUtils.serializeAndRecover(v));    }    /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, double[] m, double[] n,            double tolerance) {        if (m.length != n.length) {            fail("vectors have different lengths");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " +  i + " elements differ", m[i],n[i],tolerance);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.math.BigDecimal;import junit.framework.TestCase;/** * Test cases for the {@link BigMatrixImpl} class. * * @version $Revision$ $Date$ */@Deprecatedpublic final class BigMatrixImplTest extends TestCase {    // Test data for String constructors    protected  String[][] testDataString = { {"1","2","3"}, {"2","5","3"}, {"1","0","8"} };    // 3 x 3 identity matrix    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };    // Test data for group operations    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},            {-1d,0d,-8d} };    protected double[] testDataRow1 = {1d,2d,3d};    protected double[] testDataCol3 = {3d,3d,8d};    protected double[][] testDataInv =        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };    protected double[] preMultTest = {8,12,33};    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};    protected double[][] testDataPlusInv =        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };    // lu decomposition tests    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},            {0.33333333333333,0d,0.33333333333333} };    // singular matrices    protected double[][] singular = { {2d,3d}, {2d,3d} };    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},            {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};    // vectors    protected double[] testVector = {1,2,3};    protected double[] testVector2 = {1,2,3,4};    // submatrix accessor tests    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},            {2, 4, 6, 8}, {4, 5, 6, 7}};    // array selections    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};    // effective permutations    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};    // contiguous ranges    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};    protected double[][] subRows23Cols00 = {{2} , {4}};    protected double[][] subRows00Cols33 = {{4}};    // row matrices    protected double[][] subRow0 = {{1,2,3,4}};    protected double[][] subRow3 = {{4,5,6,7}};    // column matrices    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    public BigMatrixImplTest(String name) {        super(name);    }    public static final double[] asDouble(BigDecimal[] data) {        double d[] = new double[data.length];        for (int i=0;i<d.length;i++) {            d[i] = data[i].doubleValue();        }        return d;    }    public static final double[][] asDouble(BigDecimal[][] data) {        double d[][] = new double[data.length][data[0].length];        for (int i=0;i<d.length;i++) {            for (int j=0;j<d[i].length;j++)            d[i][j] = data[i][j].doubleValue();        }        return d;    }    public static final BigDecimal[] asBigDecimal(double [] data) {        BigDecimal d[] = new BigDecimal[data.length];        for (int i=0;i<d.length;i++) {            d[i] = new BigDecimal(data[i]);        }        return d;    }    public static final BigDecimal[][] asBigDecimal(double [][] data) {        BigDecimal d[][] = new BigDecimal[data.length][data[0].length];        for (int i=0;i<d.length;i++) {            for (int j=0;j<data[i].length;j++) {                d[i][j] = new BigDecimal(data[i][j]);            }        }        return d;    }    /** test dimensions */    public void testDimensions() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl m2 = new BigMatrixImpl(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());    }    /** test copy functions */    public void testCopyFunctions() {        BigMatrixImpl m1 = new BigMatrixImpl(testData);        BigMatrixImpl m2 = new BigMatrixImpl(m1.getData());        assertEquals(m2,m1);        BigMatrixImpl m3 = new BigMatrixImpl(testData);        BigMatrixImpl m4 = new BigMatrixImpl(m3.getData(), false);        assertEquals(m4,m3);    }    /** test constructors */    public void testConstructors() {        BigMatrix m1 = new BigMatrixImpl(testData);        BigMatrix m2 = new BigMatrixImpl(testDataString);        BigMatrix m3 = new BigMatrixImpl(asBigDecimal(testData));        BigMatrix m4 = new BigMatrixImpl(asBigDecimal(testData), true);        BigMatrix m5 = new BigMatrixImpl(asBigDecimal(testData), false);        assertClose("double, string", m1, m2, Double.MIN_VALUE);        assertClose("double, BigDecimal", m1, m3, Double.MIN_VALUE);        assertClose("string, BigDecimal", m2, m3, Double.MIN_VALUE);        assertClose("double, BigDecimal/true", m1, m4, Double.MIN_VALUE);        assertClose("double, BigDecimal/false", m1, m5, Double.MIN_VALUE);        try {            new BigMatrixImpl(new String[][] {{"0", "hello", "1"}});            fail("Expecting NumberFormatException");        } catch (NumberFormatException ex) {            // expected        }        try {            new BigMatrixImpl(new String[][] {});            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            new BigMatrixImpl(new String[][] {{},{}});            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            new BigMatrixImpl(new String[][] {{"a", "b"},{"c"}});            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            new BigMatrixImpl(0, 1);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            new BigMatrixImpl(1, 0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }    /** test add */    public void testAdd() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);        BigMatrix mPlusMInv = m.add(mInv);        double[][] sumEntries = asDouble(mPlusMInv.getData());        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                    testDataPlusInv[row][col],sumEntries[row][col],                        entryTolerance);            }        }    }    /** test add failure */    public void testAddFail() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl m2 = new BigMatrixImpl(testData2);        try {            m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test norm */    public void testNorm() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl m2 = new BigMatrixImpl(testData2);        assertEquals("testData norm",14d,m.getNorm().doubleValue(),entryTolerance);        assertEquals("testData2 norm",7d,m2.getNorm().doubleValue(),entryTolerance);    }     /** test m-n = m + -n */    public void testPlusMinus() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl m2 = new BigMatrixImpl(testDataInv);        assertClose("m-n = m + -n",m.subtract(m2),            m2.scalarMultiply(new BigDecimal(-1d)).add(m),entryTolerance);        try {            m.subtract(new BigMatrixImpl(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test multiply */     public void testMultiply() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);        BigMatrixImpl identity = new BigMatrixImpl(id);        BigMatrixImpl m2 = new BigMatrixImpl(testData2);        assertClose("inverse multiply",m.multiply(mInv),            identity,entryTolerance);        assertClose("inverse multiply",mInv.multiply(m),            identity,entryTolerance);        assertClose("identity multiply",m.multiply(identity),            m,entryTolerance);        assertClose("identity multiply",identity.multiply(mInv),            mInv,entryTolerance);        assertClose("identity multiply",m2.multiply(identity),            m2,entryTolerance);        try {            m.multiply(new BigMatrixImpl(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    //Additional Test for BigMatrixImplTest.testMultiply    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};    private double[][] d4 = new double[][] {{1},{2},{3},{4}};    private double[][] d5 = new double[][] {{30},{70}};    public void testMultiply2() {       BigMatrix m3 = new BigMatrixImpl(d3);       BigMatrix m4 = new BigMatrixImpl(d4);       BigMatrix m5 = new BigMatrixImpl(d5);       assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);   }    /** test isSingular */    public void testIsSingular() {        BigMatrixImpl m = new BigMatrixImpl(singular);        assertTrue("singular",m.isSingular());        m = new BigMatrixImpl(bigSingular);        assertTrue("big singular",m.isSingular());        m = new BigMatrixImpl(id);        assertTrue("identity nonsingular",!m.isSingular());        m = new BigMatrixImpl(testData);        assertTrue("testData nonsingular",!m.isSingular());    }    /** test inverse */    public void testInverse() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrix mInv = new BigMatrixImpl(testDataInv);        assertClose("inverse",mInv,m.inverse(),normTolerance);        assertClose("inverse^2",m,m.inverse().inverse(),10E-12);        // Not square        m = new BigMatrixImpl(testData2);        try {            m.inverse();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }        // Singular        m = new BigMatrixImpl(singular);        try {            m.inverse();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }    /** test solve */    public void testSolve() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrix mInv = new BigMatrixImpl(testDataInv);        // being a bit slothful here -- actually testing that X = A^-1 * B        assertClose("inverse-operate",                    asDouble(mInv.operate(asBigDecimal(testVector))),                    asDouble(m.solve(asBigDecimal(testVector))),                    normTolerance);        try {            asDouble(m.solve(asBigDecimal(testVector2)));            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        BigMatrix bs = new BigMatrixImpl(bigSingular);        try {            bs.solve(bs);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // ignored        }        try {            m.solve(bs);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            new BigMatrixImpl(testData2).solve(bs);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            (new BigMatrixImpl(testData2)).luDecompose();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // ignored        }    }    /** test determinant */    public void testDeterminant() {        BigMatrix m = new BigMatrixImpl(bigSingular);        assertEquals("singular determinant",0,m.getDeterminant().doubleValue(),0);        m = new BigMatrixImpl(detData);        assertEquals("nonsingular test",-3d,m.getDeterminant().doubleValue(),normTolerance);        // Examples verified against R (version 1.8.1, Red Hat Linux 9)        m = new BigMatrixImpl(detData2);        assertEquals("nonsingular R test 1",-2d,m.getDeterminant().doubleValue(),normTolerance);        m = new BigMatrixImpl(testData);        assertEquals("nonsingular  R test 2",-1d,m.getDeterminant().doubleValue(),normTolerance);        try {            double d = new BigMatrixImpl(testData2).getDeterminant().doubleValue();            fail("Expecting InvalidMatrixException, got " + d);        } catch (InvalidMatrixException ex) {            // ignored        }    }    /** test trace */    public void testTrace() {        BigMatrix m = new BigMatrixImpl(id);        assertEquals("identity trace",3d,m.getTrace().doubleValue(),entryTolerance);        m = new BigMatrixImpl(testData2);        try {            double t = m.getTrace().doubleValue();            fail("Expecting NonSquareMatrixException, got " + t);        } catch (NonSquareMatrixException ex) {            // ignored        }    }    /** test sclarAdd */    public void testScalarAdd() {        BigMatrix m = new BigMatrixImpl(testData);        assertClose("scalar add",new BigMatrixImpl(testDataPlus2),            m.scalarAdd(new BigDecimal(2d)),entryTolerance);    }    /** test operate */    public void testOperate() {        BigMatrix m = new BigMatrixImpl(id);        double[] x = asDouble(m.operate(asBigDecimal(testVector)));        assertClose("identity operate",testVector,x,entryTolerance);        m = new BigMatrixImpl(bigSingular);        try {            asDouble(m.operate(asBigDecimal(testVector)));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test issue MATH-209 */    public void testMath209() {        BigMatrix a = new BigMatrixImpl(new BigDecimal[][] {                { new BigDecimal(1), new BigDecimal(2) },                { new BigDecimal(3), new BigDecimal(4) },                { new BigDecimal(5), new BigDecimal(6) }        }, false);        BigDecimal[] b = a.operate(new BigDecimal[] { new BigDecimal(1), new BigDecimal(1) });        assertEquals(a.getRowDimension(), b.length);        assertEquals( 3.0, b[0].doubleValue(), 1.0e-12);        assertEquals( 7.0, b[1].doubleValue(), 1.0e-12);        assertEquals(11.0, b[2].doubleValue(), 1.0e-12);    }    /** test transpose */    public void testTranspose() {        BigMatrix m = new BigMatrixImpl(testData);        assertClose("inverse-transpose",m.inverse().transpose(),            m.transpose().inverse(),normTolerance);        m = new BigMatrixImpl(testData2);        BigMatrix mt = new BigMatrixImpl(testData2T);        assertClose("transpose",mt,m.transpose(),normTolerance);    }    /** test preMultiply by vector */    public void testPremultiplyVector() {        BigMatrix m = new BigMatrixImpl(testData);        assertClose("premultiply",asDouble(m.preMultiply(asBigDecimal(testVector))),preMultTest,normTolerance);        m = new BigMatrixImpl(bigSingular);        try {            m.preMultiply(asBigDecimal(testVector));            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testPremultiply() {        BigMatrix m3 = new BigMatrixImpl(d3);        BigMatrix m4 = new BigMatrixImpl(d4);        BigMatrix m5 = new BigMatrixImpl(d5);        assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);        BigMatrixImpl identity = new BigMatrixImpl(id);        new BigMatrixImpl(testData2);        assertClose("inverse multiply",m.preMultiply(mInv),                identity,entryTolerance);        assertClose("inverse multiply",mInv.preMultiply(m),                identity,entryTolerance);        assertClose("identity multiply",m.preMultiply(identity),                m,entryTolerance);        assertClose("identity multiply",identity.preMultiply(mInv),                mInv,entryTolerance);        try {            m.preMultiply(new BigMatrixImpl(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testGetVectors() {        BigMatrix m = new BigMatrixImpl(testData);        assertClose("get row",m.getRowAsDoubleArray(0),testDataRow1,entryTolerance);        assertClose("get col",m.getColumnAsDoubleArray(2),testDataCol3,entryTolerance);        try {            m.getRowAsDoubleArray(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }        try {            m.getColumnAsDoubleArray(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }    }    public void testLUDecomposition() throws Exception {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrix lu = m.getLUMatrix();        assertClose("LU decomposition", lu, new BigMatrixImpl(testDataLU), normTolerance);        verifyDecomposition(m, lu);        m = new BigMatrixImpl(luData);        lu = m.getLUMatrix();        assertClose("LU decomposition", lu, new BigMatrixImpl(luDataLUDecomposition), normTolerance);        verifyDecomposition(m, lu);        m = new BigMatrixImpl(testDataMinus);        lu = m.getLUMatrix();        verifyDecomposition(m, lu);        m = new BigMatrixImpl(id);        lu = m.getLUMatrix();        verifyDecomposition(m, lu);        try {            m = new BigMatrixImpl(bigSingular); // singular            lu = m.getLUMatrix();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }        try {            m = new BigMatrixImpl(testData2);  // not square            lu = m.getLUMatrix();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }   /**    * test submatrix accessors    */    public void testSubMatrix() {        BigMatrix m = new BigMatrixImpl(subTestData);        BigMatrix mRows23Cols00 = new BigMatrixImpl(subRows23Cols00);        BigMatrix mRows00Cols33 = new BigMatrixImpl(subRows00Cols33);        BigMatrix mRows01Cols23 = new BigMatrixImpl(subRows01Cols23);        BigMatrix mRows02Cols13 = new BigMatrixImpl(subRows02Cols13);        BigMatrix mRows03Cols12 = new BigMatrixImpl(subRows03Cols12);        BigMatrix mRows03Cols123 = new BigMatrixImpl(subRows03Cols123);        BigMatrix mRows20Cols123 = new BigMatrixImpl(subRows20Cols123);        BigMatrix mRows31Cols31 = new BigMatrixImpl(subRows31Cols31);        assertEquals("Rows23Cols00", mRows23Cols00,                m.getSubMatrix(2 , 3 , 0, 0));        assertEquals("Rows00Cols33", mRows00Cols33,                m.getSubMatrix(0 , 0 , 3, 3));        assertEquals("Rows01Cols23", mRows01Cols23,                m.getSubMatrix(0 , 1 , 2, 3));        assertEquals("Rows02Cols13", mRows02Cols13,                m.getSubMatrix(new int[] {0,2}, new int[] {1,3}));        assertEquals("Rows03Cols12", mRows03Cols12,                m.getSubMatrix(new int[] {0,3}, new int[] {1,2}));        assertEquals("Rows03Cols123", mRows03Cols123,                m.getSubMatrix(new int[] {0,3}, new int[] {1,2,3}));        assertEquals("Rows20Cols123", mRows20Cols123,                m.getSubMatrix(new int[] {2,0}, new int[] {1,2,3}));        assertEquals("Rows31Cols31", mRows31Cols31,                m.getSubMatrix(new int[] {3,1}, new int[] {3,1}));        assertEquals("Rows31Cols31", mRows31Cols31,                m.getSubMatrix(new int[] {3,1}, new int[] {3,1}));        try {            m.getSubMatrix(1,0,2,4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(-1,1,2,2);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(1,0,2,2);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(1,0,2,4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(new int[] {}, new int[] {0});            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(new int[] {0}, new int[] {4});            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetColumnMatrix() {        BigMatrix m = new BigMatrixImpl(subTestData);        BigMatrix mColumn1 = new BigMatrixImpl(subColumn1);        BigMatrix mColumn3 = new BigMatrixImpl(subColumn3);        assertEquals("Column1", mColumn1,                m.getColumnMatrix(1));        assertEquals("Column3", mColumn3,                m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetRowMatrix() {        BigMatrix m = new BigMatrixImpl(subTestData);        BigMatrix mRow0 = new BigMatrixImpl(subRow0);        BigMatrix mRow3 = new BigMatrixImpl(subRow3);        assertEquals("Row0", mRow0,                m.getRowMatrix(0));        assertEquals("Row3", mRow3,                m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testEqualsAndHashCode() {        BigMatrixImpl m = new BigMatrixImpl(testData);        BigMatrixImpl m1 = (BigMatrixImpl) m.copy();        BigMatrixImpl mt = (BigMatrixImpl) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(new BigMatrixImpl(bigSingular)));        // Different scales make BigDecimals, so matrices unequal        m = new BigMatrixImpl(new String[][] {{"2.0"}});        m1 = new BigMatrixImpl(new String[][] {{"2.00"}});        assertTrue(m.hashCode() != m1.hashCode());        assertFalse(m.equals(m1));    }    public void testToString() {        BigMatrixImpl m = new BigMatrixImpl(testData);        assertEquals("BigMatrixImpl{{1,2,3},{2,5,3},{1,0,8}}",                m.toString());        m = new BigMatrixImpl();        assertEquals("BigMatrixImpl{}",                m.toString());    }    public void testSetSubMatrix() throws Exception {        BigDecimal[][] detData3 =            MatrixUtils.createBigMatrix(detData2).getData();        BigMatrixImpl m = new BigMatrixImpl(testData);        m.setSubMatrix(detData3,1,1);        BigMatrix expected = MatrixUtils.createBigMatrix            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);        m.setSubMatrix(detData3,0,0);        expected = MatrixUtils.createBigMatrix            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);        BigDecimal[][] testDataPlus3 =            MatrixUtils.createBigMatrix(testDataPlus2).getData();        m.setSubMatrix(testDataPlus3,0,0);        expected = MatrixUtils.createBigMatrix        (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});        assertEquals(expected, m);        // javadoc example        BigMatrixImpl matrix = (BigMatrixImpl) MatrixUtils.createBigMatrix            (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});        matrix.setSubMatrix(new BigDecimal[][] {{new BigDecimal(3),            new BigDecimal(4)}, {new BigDecimal(5), new BigDecimal(6)}}, 1, 1);        expected = MatrixUtils.createBigMatrix            (new BigDecimal[][] {{new BigDecimal(1), new BigDecimal(2),             new BigDecimal(3), new BigDecimal(4)}, {new BigDecimal(5),             new BigDecimal(3), new BigDecimal(4), new BigDecimal(8)},             {new BigDecimal(9), new BigDecimal(5) , new BigDecimal(6),              new BigDecimal(2)}});        assertEquals(expected, matrix);        // dimension overflow        try {            m.setSubMatrix(matrix.getData(),1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // null        try {            m.setSubMatrix(null,1,1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }        // ragged        try {            m.setSubMatrix(new BigDecimal[][] {{new BigDecimal(1)},                    {new BigDecimal(2), new BigDecimal(3)}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }        // empty        try {            m.setSubMatrix(new BigDecimal[][] {{}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }    }    //--------------- -----------------Protected methods    /** verifies that two matrices are close (1-norm) */    protected void assertClose(String msg, BigMatrix m, BigMatrix n,        double tolerance) {        assertTrue(msg,m.subtract(n).getNorm().doubleValue() < tolerance);    }    /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, double[] m, double[] n,        double tolerance) {        if (m.length != n.length) {            fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " +  i + " elements differ",                m[i],n[i],tolerance);        }    }    /** extracts the l  and u matrices from compact lu representation */    protected void splitLU(BigMatrix lu, BigDecimal[][] lowerData, BigDecimal[][] upperData) throws InvalidMatrixException {        if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||                lowerData.length != upperData.length                || lowerData.length != lu.getRowDimension()) {            throw new InvalidMatrixException("incorrect dimensions");        }        int n = lu.getRowDimension();        for (int i = 0; i < n; i++) {            for (int j = 0; j < n; j++) {                if (j < i) {                    lowerData[i][j] = lu.getEntry(i, j);                    upperData[i][j] = new BigDecimal(0);                } else if (i == j) {                    lowerData[i][j] = new BigDecimal(1);                    upperData[i][j] = lu.getEntry(i, j);                } else {                    lowerData[i][j] = new BigDecimal(0);                    upperData[i][j] = lu.getEntry(i, j);                }            }        }    }    /** Returns the result of applying the given row permutation to the matrix */    protected BigMatrix permuteRows(BigMatrix matrix, int[] permutation) {        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {            throw new IllegalArgumentException("dimension mismatch");        }        int n = matrix.getRowDimension();        int m = matrix.getColumnDimension();        BigDecimal out[][] = new BigDecimal[m][n];        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                out[i][j] = matrix.getEntry(permutation[i], j);            }        }        return new BigMatrixImpl(out);    }    /** Extracts l and u matrices from lu and verifies that matrix = l times u modulo permutation */    protected void verifyDecomposition(BigMatrix matrix, BigMatrix lu) throws Exception{        int n = matrix.getRowDimension();        BigDecimal[][] lowerData = new BigDecimal[n][n];        BigDecimal[][] upperData = new BigDecimal[n][n];        splitLU(lu, lowerData, upperData);        BigMatrix lower =new BigMatrixImpl(lowerData);        BigMatrix upper = new BigMatrixImpl(upperData);        int[] permutation = ((BigMatrixImpl) matrix).getPermutation();        BigMatrix permuted = permuteRows(matrix, permutation);        assertClose("lu decomposition does not work", permuted,                lower.multiply(upper), normTolerance);    }//    /** Useful for debugging *///    private void dumpMatrix(BigMatrix m) {//          for (int i = 0; i < m.getRowDimension(); i++) {//              String os = "";//              for (int j = 0; j < m.getColumnDimension(); j++) {//                  os += m.getEntry(i, j) + " ";//              }//              System.out.println(os);//          }//    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Random;import junit.framework.TestCase;public class SingularValueDecompositionImplTest extends TestCase {    private double[][] testSquare = {            { 24.0 / 25.0, 43.0 / 25.0 },            { 57.0 / 25.0, 24.0 / 25.0 }    };    private double[][] testNonSquare = {        {  -540.0 / 625.0,  963.0 / 625.0, -216.0 / 625.0 },        { -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 },        {  -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 },        {  -360.0 / 625.0,  192.0 / 625.0, 1756.0 / 625.0 },    };    private static final double normTolerance = 10e-14;    public SingularValueDecompositionImplTest(String name) {        super(name);    }    public void testMoreRows() {        final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };        final int rows    = singularValues.length + 2;        final int columns = singularValues.length;        Random r = new Random(15338437322523l);        SingularValueDecomposition svd =            new SingularValueDecompositionImpl(createTestMatrix(r, rows, columns, singularValues));        double[] computedSV = svd.getSingularValues();        assertEquals(singularValues.length, computedSV.length);        for (int i = 0; i < singularValues.length; ++i) {            assertEquals(singularValues[i], computedSV[i], 1.0e-10);        }    }    public void testMoreColumns() {        final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };        final int rows    = singularValues.length;        final int columns = singularValues.length + 2;        Random r = new Random(732763225836210l);        SingularValueDecomposition svd =            new SingularValueDecompositionImpl(createTestMatrix(r, rows, columns, singularValues));        double[] computedSV = svd.getSingularValues();        assertEquals(singularValues.length, computedSV.length);        for (int i = 0; i < singularValues.length; ++i) {            assertEquals(singularValues[i], computedSV[i], 1.0e-10);        }    }    /** test dimensions */    public void testDimensions() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testSquare);        final int m = matrix.getRowDimension();        final int n = matrix.getColumnDimension();        SingularValueDecomposition svd = new SingularValueDecompositionImpl(matrix);        assertEquals(m, svd.getU().getRowDimension());        assertEquals(m, svd.getU().getColumnDimension());        assertEquals(m, svd.getS().getColumnDimension());        assertEquals(n, svd.getS().getColumnDimension());        assertEquals(n, svd.getV().getRowDimension());        assertEquals(n, svd.getV().getColumnDimension());    }    /** Test based on a dimension 4 Hadamard matrix. */    public void testHadamard() {        RealMatrix matrix = new Array2DRowRealMatrix(new double[][] {                {15.0 / 2.0,  5.0 / 2.0,  9.0 / 2.0,  3.0 / 2.0 },                { 5.0 / 2.0, 15.0 / 2.0,  3.0 / 2.0,  9.0 / 2.0 },                { 9.0 / 2.0,  3.0 / 2.0, 15.0 / 2.0,  5.0 / 2.0 },                { 3.0 / 2.0,  9.0 / 2.0,  5.0 / 2.0, 15.0 / 2.0 }        }, false);        SingularValueDecomposition svd = new SingularValueDecompositionImpl(matrix);        assertEquals(16.0, svd.getSingularValues()[0], 1.0e-14);        assertEquals( 8.0, svd.getSingularValues()[1], 1.0e-14);        assertEquals( 4.0, svd.getSingularValues()[2], 1.0e-14);        assertEquals( 2.0, svd.getSingularValues()[3], 1.0e-14);        RealMatrix fullCovariance = new Array2DRowRealMatrix(new double[][] {                {  85.0 / 1024, -51.0 / 1024, -75.0 / 1024,  45.0 / 1024 },                { -51.0 / 1024,  85.0 / 1024,  45.0 / 1024, -75.0 / 1024 },                { -75.0 / 1024,  45.0 / 1024,  85.0 / 1024, -51.0 / 1024 },                {  45.0 / 1024, -75.0 / 1024, -51.0 / 1024,  85.0 / 1024 }        }, false);        assertEquals(0.0,                     fullCovariance.subtract(svd.getCovariance(0.0)).getNorm(),                     1.0e-14);        RealMatrix halfCovariance = new Array2DRowRealMatrix(new double[][] {                {   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024 },                {  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024 },                {   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024 },                {  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024 }        }, false);        assertEquals(0.0,                     halfCovariance.subtract(svd.getCovariance(6.0)).getNorm(),                     1.0e-14);    }    /** test A = USVt */    public void testAEqualUSVt() {        checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare));        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare));        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare).transpose());    }    public void checkAEqualUSVt(final RealMatrix matrix) {        SingularValueDecomposition svd = new SingularValueDecompositionImpl(matrix);        RealMatrix u = svd.getU();        RealMatrix s = svd.getS();        RealMatrix v = svd.getV();        double norm = u.multiply(s).multiply(v.transpose()).subtract(matrix).getNorm();        assertEquals(0, norm, normTolerance);    }    /** test that U is orthogonal */    public void testUOrthogonal() {        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getU());        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare)).getU());        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getU());    }    /** test that V is orthogonal */    public void testVOrthogonal() {        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getV());        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare)).getV());        checkOrthogonal(new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getV());    }    public void checkOrthogonal(final RealMatrix m) {        RealMatrix mTm = m.transpose().multiply(m);        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());        assertEquals(0, mTm.subtract(id).getNorm(), normTolerance);    }    /** test matrices values */    public void testMatricesValues1() {       SingularValueDecomposition svd =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {                { 3.0 / 5.0, -4.0 / 5.0 },                { 4.0 / 5.0,  3.0 / 5.0 }        });        RealMatrix sRef = MatrixUtils.createRealMatrix(new double[][] {                { 3.0, 0.0 },                { 0.0, 1.0 }        });        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {                { 4.0 / 5.0,  3.0 / 5.0 },                { 3.0 / 5.0, -4.0 / 5.0 }        });        // check values against known references        RealMatrix u = svd.getU();        assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);        RealMatrix s = svd.getS();        assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);        RealMatrix v = svd.getV();        assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);        // check the same cached instance is returned the second time        assertTrue(u == svd.getU());        assertTrue(s == svd.getS());        assertTrue(v == svd.getV());    }    /** test matrices values */    // This test is useless since whereas the columns of U and V are linked    // together, the actual triplet (U,S,V) is not uniquely defined.    public void useless_testMatricesValues2() {        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {            {  0.0 / 5.0,  3.0 / 5.0,  0.0 / 5.0 },            { -4.0 / 5.0,  0.0 / 5.0, -3.0 / 5.0 },            {  0.0 / 5.0,  4.0 / 5.0,  0.0 / 5.0 },            { -3.0 / 5.0,  0.0 / 5.0,  4.0 / 5.0 }        });        RealMatrix sRef = MatrixUtils.createRealMatrix(new double[][] {            { 4.0, 0.0, 0.0 },            { 0.0, 3.0, 0.0 },            { 0.0, 0.0, 2.0 }        });        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {            {  80.0 / 125.0,  -60.0 / 125.0, 75.0 / 125.0 },            {  24.0 / 125.0,  107.0 / 125.0, 60.0 / 125.0 },            { -93.0 / 125.0,  -24.0 / 125.0, 80.0 / 125.0 }        });        // check values against known references        SingularValueDecomposition svd =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testNonSquare));        RealMatrix u = svd.getU();        assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);        RealMatrix s = svd.getS();        assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);        RealMatrix v = svd.getV();        assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);        // check the same cached instance is returned the second time        assertTrue(u == svd.getU());        assertTrue(s == svd.getS());        assertTrue(v == svd.getV());    }    /** test condition number */    public void testConditionNumber() {        SingularValueDecompositionImpl svd =            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));        // replace 1.0e-15 with 1.5e-15        assertEquals(3.0, svd.getConditionNumber(), 1.5e-15);    }    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns,                                        final double[] singularValues) {        final RealMatrix u =            EigenDecompositionImplTest.createOrthogonalMatrix(r, rows);        final RealMatrix d =            EigenDecompositionImplTest.createDiagonalMatrix(singularValues, rows, columns);        final RealMatrix v =            EigenDecompositionImplTest.createOrthogonalMatrix(r, columns);        return u.multiply(d).multiply(v);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionField;public class FieldLUDecompositionImplTest extends TestCase {    private Fraction[][] testData = {            { new Fraction(1), new Fraction(2), new Fraction(3)},            { new Fraction(2), new Fraction(5), new Fraction(3)},            { new Fraction(1), new Fraction(0), new Fraction(8)}    };    private Fraction[][] testDataMinus = {            { new Fraction(-1), new Fraction(-2), new Fraction(-3)},            { new Fraction(-2), new Fraction(-5), new Fraction(-3)},            { new Fraction(-1),  new Fraction(0), new Fraction(-8)}    };    private Fraction[][] luData = {            { new Fraction(2), new Fraction(3), new Fraction(3) },            { new Fraction(2), new Fraction(3), new Fraction(7) },            { new Fraction(6), new Fraction(6), new Fraction(8) }    };    // singular matrices    private Fraction[][] singular = {            { new Fraction(2), new Fraction(3) },            { new Fraction(2), new Fraction(3) }    };    private Fraction[][] bigSingular = {            { new Fraction(1), new Fraction(2),   new Fraction(3),    new Fraction(4) },            { new Fraction(2), new Fraction(5),   new Fraction(3),    new Fraction(4) },            { new Fraction(7), new Fraction(3), new Fraction(256), new Fraction(1930) },            { new Fraction(3), new Fraction(7),   new Fraction(6),    new Fraction(8) }    }; // 4th row = 1st + 2nd    public FieldLUDecompositionImplTest(String name) {        super(name);    }    /** test dimensions */    public void testDimensions() {        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);        FieldLUDecomposition<Fraction> LU = new FieldLUDecompositionImpl<Fraction>(matrix);        assertEquals(testData.length, LU.getL().getRowDimension());        assertEquals(testData.length, LU.getL().getColumnDimension());        assertEquals(testData.length, LU.getU().getRowDimension());        assertEquals(testData.length, LU.getU().getColumnDimension());        assertEquals(testData.length, LU.getP().getRowDimension());        assertEquals(testData.length, LU.getP().getColumnDimension());    }    /** test non-square matrix */    public void testNonSquare() {        try {            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                    { Fraction.ZERO, Fraction.ZERO },                    { Fraction.ZERO, Fraction.ZERO },                    { Fraction.ZERO, Fraction.ZERO }            }));        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test PA = LU */    public void testPAEqualLU() {        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);        FieldLUDecomposition<Fraction> lu = new FieldLUDecompositionImpl<Fraction>(matrix);        FieldMatrix<Fraction> l = lu.getL();        FieldMatrix<Fraction> u = lu.getU();        FieldMatrix<Fraction> p = lu.getP();        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));        matrix = new Array2DRowFieldMatrix<Fraction>(testDataMinus);        lu = new FieldLUDecompositionImpl<Fraction>(matrix);        l = lu.getL();        u = lu.getU();        p = lu.getP();        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), 17, 17);        for (int i = 0; i < matrix.getRowDimension(); ++i) {            matrix.setEntry(i, i, Fraction.ONE);        }        lu = new FieldLUDecompositionImpl<Fraction>(matrix);        l = lu.getL();        u = lu.getU();        p = lu.getP();        TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));        matrix = new Array2DRowFieldMatrix<Fraction>(singular);        lu = new FieldLUDecompositionImpl<Fraction>(matrix);        assertFalse(lu.getSolver().isNonSingular());        assertNull(lu.getL());        assertNull(lu.getU());        assertNull(lu.getP());        matrix = new Array2DRowFieldMatrix<Fraction>(bigSingular);        lu = new FieldLUDecompositionImpl<Fraction>(matrix);        assertFalse(lu.getSolver().isNonSingular());        assertNull(lu.getL());        assertNull(lu.getU());        assertNull(lu.getP());    }    /** test that L is lower triangular with unit diagonal */    public void testLLowerTriangular() {        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);        FieldMatrix<Fraction> l = new FieldLUDecompositionImpl<Fraction>(matrix).getL();        for (int i = 0; i < l.getRowDimension(); i++) {            assertEquals(Fraction.ONE, l.getEntry(i, i));            for (int j = i + 1; j < l.getColumnDimension(); j++) {                assertEquals(Fraction.ZERO, l.getEntry(i, j));            }        }    }    /** test that U is upper triangular */    public void testUUpperTriangular() {        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);        FieldMatrix<Fraction> u = new FieldLUDecompositionImpl<Fraction>(matrix).getU();        for (int i = 0; i < u.getRowDimension(); i++) {            for (int j = 0; j < i; j++) {                assertEquals(Fraction.ZERO, u.getEntry(i, j));            }        }    }    /** test that P is a permutation matrix */    public void testPPermutation() {        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);        FieldMatrix<Fraction> p   = new FieldLUDecompositionImpl<Fraction>(matrix).getP();        FieldMatrix<Fraction> ppT = p.multiply(p.transpose());        FieldMatrix<Fraction> id  =            new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),                                          p.getRowDimension(), p.getRowDimension());        for (int i = 0; i < id.getRowDimension(); ++i) {            id.setEntry(i, i, Fraction.ONE);        }        TestUtils.assertEquals(id, ppT);        for (int i = 0; i < p.getRowDimension(); i++) {            int zeroCount  = 0;            int oneCount   = 0;            int otherCount = 0;            for (int j = 0; j < p.getColumnDimension(); j++) {                final Fraction e = p.getEntry(i, j);                if (e.equals(Fraction.ZERO)) {                    ++zeroCount;                } else if (e.equals(Fraction.ONE)) {                    ++oneCount;                } else {                    ++otherCount;                }            }            assertEquals(p.getColumnDimension() - 1, zeroCount);            assertEquals(1, oneCount);            assertEquals(0, otherCount);        }        for (int j = 0; j < p.getColumnDimension(); j++) {            int zeroCount  = 0;            int oneCount   = 0;            int otherCount = 0;            for (int i = 0; i < p.getRowDimension(); i++) {                final Fraction e = p.getEntry(i, j);                if (e.equals(Fraction.ZERO)) {                    ++zeroCount;                } else if (e.equals(Fraction.ONE)) {                    ++oneCount;                } else {                    ++otherCount;                }            }            assertEquals(p.getRowDimension() - 1, zeroCount);            assertEquals(1, oneCount);            assertEquals(0, otherCount);        }    }    /** test singular */    public void testSingular() {        FieldLUDecomposition<Fraction> lu =            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(testData));        assertTrue(lu.getSolver().isNonSingular());        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(singular));        assertFalse(lu.getSolver().isNonSingular());        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(bigSingular));        assertFalse(lu.getSolver().isNonSingular());    }    /** test matrices values */    public void testMatricesValues1() {       FieldLUDecomposition<Fraction> lu =            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(testData));        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(1), new Fraction(0), new Fraction(0) },                { new Fraction(2), new Fraction(1), new Fraction(0) },                { new Fraction(1), new Fraction(-2), new Fraction(1) }        });        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(1),  new Fraction(2), new Fraction(3) },                { new Fraction(0), new Fraction(1), new Fraction(-3) },                { new Fraction(0),  new Fraction(0), new Fraction(-1) }        });        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(1), new Fraction(0), new Fraction(0) },                { new Fraction(0), new Fraction(1), new Fraction(0) },                { new Fraction(0), new Fraction(0), new Fraction(1) }        });        int[] pivotRef = { 0, 1, 2 };        // check values against known references        FieldMatrix<Fraction> l = lu.getL();        TestUtils.assertEquals(lRef, l);        FieldMatrix<Fraction> u = lu.getU();        TestUtils.assertEquals(uRef, u);        FieldMatrix<Fraction> p = lu.getP();        TestUtils.assertEquals(pRef, p);        int[] pivot = lu.getPivot();        for (int i = 0; i < pivotRef.length; ++i) {            assertEquals(pivotRef[i], pivot[i]);        }        // check the same cached instance is returned the second time        assertTrue(l == lu.getL());        assertTrue(u == lu.getU());        assertTrue(p == lu.getP());    }    /** test matrices values */    public void testMatricesValues2() {       FieldLUDecomposition<Fraction> lu =            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(luData));        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(1), new Fraction(0), new Fraction(0) },                { new Fraction(3), new Fraction(1), new Fraction(0) },                { new Fraction(1), new Fraction(0), new Fraction(1) }        });        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(2), new Fraction(3), new Fraction(3)    },                { new Fraction(0), new Fraction(-3), new Fraction(-1)  },                { new Fraction(0), new Fraction(0), new Fraction(4) }        });        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(1), new Fraction(0), new Fraction(0) },                { new Fraction(0), new Fraction(0), new Fraction(1) },                { new Fraction(0), new Fraction(1), new Fraction(0) }        });        int[] pivotRef = { 0, 2, 1 };        // check values against known references        FieldMatrix<Fraction> l = lu.getL();        TestUtils.assertEquals(lRef, l);        FieldMatrix<Fraction> u = lu.getU();        TestUtils.assertEquals(uRef, u);        FieldMatrix<Fraction> p = lu.getP();        TestUtils.assertEquals(pRef, p);        int[] pivot = lu.getPivot();        for (int i = 0; i < pivotRef.length; ++i) {            assertEquals(pivotRef[i], pivot[i]);        }        // check the same cached instance is returned the second time        assertTrue(l == lu.getL());        assertTrue(u == lu.getU());        assertTrue(p == lu.getP());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.io.Serializable;import java.util.Iterator;import junit.framework.TestCase;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.util.FastMath;/** * Test cases for the {@link ArrayRealVector} class. * * @version $Revision$ $Date$ */public class ArrayRealVectorTest extends TestCase {    //    protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};    protected double[] vec1 = {1d, 2d, 3d};    protected double[] vec2 = {4d, 5d, 6d};    protected double[] vec3 = {7d, 8d, 9d};    protected double[] vec4 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};    protected double[] vec5 = { -4d, 0d, 3d, 1d, -6d, 3d};    protected double[] vec_null = {0d, 0d, 0d};    protected Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};    protected double[][] mat1 = {{1d, 2d, 3d}, {4d, 5d, 6d},{ 7d, 8d, 9d}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    // Testclass to test the RealVector interface    // only with enough content to support the test    public static class RealVectorTestImpl implements RealVector, Serializable {        /** Serializable version identifier. */        private static final long serialVersionUID = 4715341047369582908L;        /** Entries of the vector. */        protected double data[];        public RealVectorTestImpl(double[] d) {            data = d.clone();        }        private UnsupportedOperationException unsupported() {            return new UnsupportedOperationException("Not supported, unneeded for test purposes");        }        public RealVector map(UnivariateRealFunction function) throws FunctionEvaluationException {            throw unsupported();        }        public RealVector mapToSelf(UnivariateRealFunction function) throws FunctionEvaluationException {            throw unsupported();        }        public Iterator<Entry> iterator() {            return new Iterator<Entry>() {                int i = 0;                public boolean hasNext() {                    return i<data.length;                }                public Entry next() {                    final int j = i++;                    Entry e = new Entry() {                        @Override                        public double getValue() {                            return data[j];                        }                        @Override                        public void setValue(double newValue) {                            data[j] = newValue;                        }                    };                    e.setIndex(j);                    return e;                }                public void remove() { }            };        }        public Iterator<Entry> sparseIterator() {            return iterator();        }        public RealVector copy() {            throw unsupported();        }        public RealVector add(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector add(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector subtract(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector subtract(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector mapAdd(double d) {            throw unsupported();        }        public RealVector mapAddToSelf(double d) {            throw unsupported();        }        public RealVector mapSubtract(double d) {            throw unsupported();        }        public RealVector mapSubtractToSelf(double d) {            throw unsupported();        }        public RealVector mapMultiply(double d) {            double[] out = new double[data.length];            for (int i = 0; i < data.length; i++) {                out[i] = data[i] * d;            }            return new ArrayRealVector(out);        }        public RealVector mapMultiplyToSelf(double d) {            throw unsupported();        }        public RealVector mapDivide(double d) {            throw unsupported();        }        public RealVector mapDivideToSelf(double d) {            throw unsupported();        }        public RealVector mapPow(double d) {            throw unsupported();        }        public RealVector mapPowToSelf(double d) {            throw unsupported();        }        public RealVector mapExp() {            throw unsupported();        }        public RealVector mapExpToSelf() {            throw unsupported();        }        public RealVector mapExpm1() {            throw unsupported();        }        public RealVector mapExpm1ToSelf() {            throw unsupported();        }        public RealVector mapLog() {            throw unsupported();        }        public RealVector mapLogToSelf() {            throw unsupported();        }        public RealVector mapLog10() {            throw unsupported();        }        public RealVector mapLog10ToSelf() {            throw unsupported();        }        public RealVector mapLog1p() {            throw unsupported();        }        public RealVector mapLog1pToSelf() {            throw unsupported();        }        public RealVector mapCosh() {            throw unsupported();        }        public RealVector mapCoshToSelf() {            throw unsupported();        }        public RealVector mapSinh() {            throw unsupported();        }        public RealVector mapSinhToSelf() {            throw unsupported();        }        public RealVector mapTanh() {            throw unsupported();        }        public RealVector mapTanhToSelf() {            throw unsupported();        }        public RealVector mapCos() {            throw unsupported();        }        public RealVector mapCosToSelf() {            throw unsupported();        }        public RealVector mapSin() {            throw unsupported();        }        public RealVector mapSinToSelf() {            throw unsupported();        }        public RealVector mapTan() {            throw unsupported();        }        public RealVector mapTanToSelf() {            throw unsupported();        }        public RealVector mapAcos() {            throw unsupported();        }        public RealVector mapAcosToSelf() {            throw unsupported();        }        public RealVector mapAsin() {            throw unsupported();        }        public RealVector mapAsinToSelf() {            throw unsupported();        }        public RealVector mapAtan() {            throw unsupported();        }        public RealVector mapAtanToSelf() {            throw unsupported();        }        public RealVector mapInv() {            throw unsupported();        }        public RealVector mapInvToSelf() {            throw unsupported();        }        public RealVector mapAbs() {            throw unsupported();        }        public RealVector mapAbsToSelf() {            throw unsupported();        }        public RealVector mapSqrt() {            throw unsupported();        }        public RealVector mapSqrtToSelf() {            throw unsupported();        }        public RealVector mapCbrt() {            throw unsupported();        }        public RealVector mapCbrtToSelf() {            throw unsupported();        }        public RealVector mapCeil() {            throw unsupported();        }        public RealVector mapCeilToSelf() {            throw unsupported();        }        public RealVector mapFloor() {            throw unsupported();        }        public RealVector mapFloorToSelf() {            throw unsupported();        }        public RealVector mapRint() {            throw unsupported();        }        public RealVector mapRintToSelf() {            throw unsupported();        }        public RealVector mapSignum() {            throw unsupported();        }        public RealVector mapSignumToSelf() {            throw unsupported();        }        public RealVector mapUlp() {            throw unsupported();        }        public RealVector mapUlpToSelf() {            throw unsupported();        }        public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector ebeDivide(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public double[] getData() {            return data.clone();        }        public double dotProduct(RealVector v) throws IllegalArgumentException {            double dot = 0;            for (int i = 0; i < data.length; i++) {                dot += data[i] * v.getEntry(i);            }            return dot;        }        public double dotProduct(double[] v) throws IllegalArgumentException {            double dot = 0;            for (int i = 0; i < data.length; i++) {                dot += data[i] * v[i];            }            return dot;        }        public double getNorm() {            throw unsupported();        }        public double getL1Norm() {            throw unsupported();        }        public double getLInfNorm() {            throw unsupported();        }        public double getDistance(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public double getDistance(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public double getL1Distance(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public double getL1Distance(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public double getLInfDistance(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public double getLInfDistance(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector unitVector() {            throw unsupported();        }        public void unitize() {            throw unsupported();        }        public RealVector projection(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealVector projection(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {            throw unsupported();        }        public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {            throw unsupported();        }        public double getEntry(int index) throws MatrixIndexException {            return data[index];        }        public int getDimension() {            return data.length;        }        public RealVector append(RealVector v) {            throw unsupported();        }        public RealVector append(double d) {            throw unsupported();        }        public RealVector append(double[] a) {            throw unsupported();        }        public RealVector getSubVector(int index, int n) throws MatrixIndexException {            throw unsupported();        }        public void setEntry(int index, double value) throws MatrixIndexException {            throw unsupported();        }        public void setSubVector(int index, RealVector v) throws MatrixIndexException {            throw unsupported();        }        public void setSubVector(int index, double[] v) throws MatrixIndexException {            throw unsupported();        }        public void set(double value) {            throw unsupported();        }        public double[] toArray() {            throw unsupported();        }        public boolean isNaN() {            throw unsupported();        }        public boolean isInfinite() {            throw unsupported();        }    }    public void testConstructors() {        ArrayRealVector v0 = new ArrayRealVector();        assertEquals("testData len", 0, v0.getDimension());        ArrayRealVector v1 = new ArrayRealVector(7);        assertEquals("testData len", 7, v1.getDimension());        assertEquals("testData is 0.0 ", 0.0, v1.getEntry(6));        ArrayRealVector v2 = new ArrayRealVector(5, 1.23);        assertEquals("testData len", 5, v2.getDimension());        assertEquals("testData is 1.23 ", 1.23, v2.getEntry(4));        ArrayRealVector v3 = new ArrayRealVector(vec1);        assertEquals("testData len", 3, v3.getDimension());        assertEquals("testData is 2.0 ", 2.0, v3.getEntry(1));        ArrayRealVector v3_bis = new ArrayRealVector(vec1, true);        assertEquals("testData len", 3, v3_bis.getDimension());        assertEquals("testData is 2.0 ", 2.0, v3_bis.getEntry(1));        assertNotSame(v3_bis.getDataRef(), vec1);        assertNotSame(v3_bis.getData(), vec1);        ArrayRealVector v3_ter = new ArrayRealVector(vec1, false);        assertEquals("testData len", 3, v3_ter.getDimension());        assertEquals("testData is 2.0 ", 2.0, v3_ter.getEntry(1));        assertSame(v3_ter.getDataRef(), vec1);        assertNotSame(v3_ter.getData(), vec1);        ArrayRealVector v4 = new ArrayRealVector(vec4, 3, 2);        assertEquals("testData len", 2, v4.getDimension());        assertEquals("testData is 4.0 ", 4.0, v4.getEntry(0));        try {            new ArrayRealVector(vec4, 8, 3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        RealVector v5_i = new ArrayRealVector(dvec1);        assertEquals("testData len", 9, v5_i.getDimension());        assertEquals("testData is 9.0 ", 9.0, v5_i.getEntry(8));        ArrayRealVector v5 = new ArrayRealVector(dvec1);        assertEquals("testData len", 9, v5.getDimension());        assertEquals("testData is 9.0 ", 9.0, v5.getEntry(8));        ArrayRealVector v6 = new ArrayRealVector(dvec1, 3, 2);        assertEquals("testData len", 2, v6.getDimension());        assertEquals("testData is 4.0 ", 4.0, v6.getEntry(0));        try {            new ArrayRealVector(dvec1, 8, 3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayRealVector v7 = new ArrayRealVector(v1);        assertEquals("testData len", 7, v7.getDimension());        assertEquals("testData is 0.0 ", 0.0, v7.getEntry(6));        RealVectorTestImpl v7_i = new RealVectorTestImpl(vec1);        ArrayRealVector v7_2 = new ArrayRealVector(v7_i);        assertEquals("testData len", 3, v7_2.getDimension());        assertEquals("testData is 0.0 ", 2.0d, v7_2.getEntry(1));        ArrayRealVector v8 = new ArrayRealVector(v1, true);        assertEquals("testData len", 7, v8.getDimension());        assertEquals("testData is 0.0 ", 0.0, v8.getEntry(6));        assertNotSame("testData not same object ", v1.data, v8.data);        ArrayRealVector v8_2 = new ArrayRealVector(v1, false);        assertEquals("testData len", 7, v8_2.getDimension());        assertEquals("testData is 0.0 ", 0.0, v8_2.getEntry(6));        assertEquals("testData same object ", v1.data, v8_2.data);        ArrayRealVector v9 = new ArrayRealVector(v1, v3);        assertEquals("testData len", 10, v9.getDimension());        assertEquals("testData is 1.0 ", 1.0, v9.getEntry(7));        ArrayRealVector v10 = new ArrayRealVector(v2, new RealVectorTestImpl(vec3));        assertEquals("testData len", 8, v10.getDimension());        assertEquals("testData is 1.23 ", 1.23, v10.getEntry(4));        assertEquals("testData is 7.0 ", 7.0, v10.getEntry(5));        ArrayRealVector v11 = new ArrayRealVector(new RealVectorTestImpl(vec3), v2);        assertEquals("testData len", 8, v11.getDimension());        assertEquals("testData is 9.0 ", 9.0, v11.getEntry(2));        assertEquals("testData is 1.23 ", 1.23, v11.getEntry(3));        ArrayRealVector v12 = new ArrayRealVector(v2, vec3);        assertEquals("testData len", 8, v12.getDimension());        assertEquals("testData is 1.23 ", 1.23, v12.getEntry(4));        assertEquals("testData is 7.0 ", 7.0, v12.getEntry(5));        ArrayRealVector v13 = new ArrayRealVector(vec3, v2);        assertEquals("testData len", 8, v13.getDimension());        assertEquals("testData is 9.0 ", 9.0, v13.getEntry(2));        assertEquals("testData is 1.23 ", 1.23, v13.getEntry(3));        ArrayRealVector v14 = new ArrayRealVector(vec3, vec4);        assertEquals("testData len", 12, v14.getDimension());        assertEquals("testData is 9.0 ", 9.0, v14.getEntry(2));        assertEquals("testData is 1.0 ", 1.0, v14.getEntry(3));        try {            new ArrayRealVector((double[]) null, false);            fail("expected exception");        } catch (NullPointerException npe) {            // expected        } catch (Exception e) {            fail("wrong exception caught");        }        try {            new ArrayRealVector(new double[0], false);            fail("expected exception");        } catch (IllegalArgumentException iae) {            // expected        } catch (Exception e) {            fail("wrong exception caught");        }   }    public void testDataInOut() {        ArrayRealVector v1 = new ArrayRealVector(vec1);        ArrayRealVector v2 = new ArrayRealVector(vec2);        ArrayRealVector v4 = new ArrayRealVector(vec4);        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);        RealVector v_append_1 = v1.append(v2);        assertEquals("testData len", 6, v_append_1.getDimension());        assertEquals("testData is 4.0 ", 4.0, v_append_1.getEntry(3));        RealVector v_append_2 = v1.append(2.0);        assertEquals("testData len", 4, v_append_2.getDimension());        assertEquals("testData is 2.0 ", 2.0, v_append_2.getEntry(3));        RealVector v_append_3 = v1.append(vec2);        assertEquals("testData len", 6, v_append_3.getDimension());        assertEquals("testData is  ", 4.0, v_append_3.getEntry(3));        RealVector v_append_4 = v1.append(v2_t);        assertEquals("testData len", 6, v_append_4.getDimension());        assertEquals("testData is 4.0 ", 4.0, v_append_4.getEntry(3));        RealVector v_append_5 = v1.append((RealVector) v2);        assertEquals("testData len", 6, v_append_5.getDimension());        assertEquals("testData is 4.0 ", 4.0, v_append_5.getEntry(3));        RealVector v_copy = v1.copy();        assertEquals("testData len", 3, v_copy.getDimension());        assertNotSame("testData not same object ", v1.data, v_copy.getData());        double[] a_double = v1.toArray();        assertEquals("testData len", 3, a_double.length);        assertNotSame("testData not same object ", v1.data, a_double);//      ArrayRealVector vout4 = (ArrayRealVector) v1.clone();//      assertEquals("testData len", 3, vout4.getDimension());//      assertEquals("testData not same object ", v1.data, vout4.data);        RealVector vout5 = v4.getSubVector(3, 3);        assertEquals("testData len", 3, vout5.getDimension());        assertEquals("testData is 4.0 ", 5.0, vout5.getEntry(1));        try {            v4.getSubVector(3, 7);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayRealVector v_set1 = (ArrayRealVector) v1.copy();        v_set1.setEntry(1, 11.0);        assertEquals("testData is 11.0 ", 11.0, v_set1.getEntry(1));        try {            v_set1.setEntry(3, 11.0);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayRealVector v_set2 = (ArrayRealVector) v4.copy();        v_set2.set(3, v1);        assertEquals("testData is 1.0 ", 1.0, v_set2.getEntry(3));        assertEquals("testData is 7.0 ", 7.0, v_set2.getEntry(6));        try {            v_set2.set(7, v1);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayRealVector v_set3 = (ArrayRealVector) v1.copy();        v_set3.set(13.0);        assertEquals("testData is 13.0 ", 13.0, v_set3.getEntry(2));        try {            v_set3.getEntry(23);            fail("ArrayIndexOutOfBoundsException expected");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayRealVector v_set4 = (ArrayRealVector) v4.copy();        v_set4.setSubVector(3, v2_t);        assertEquals("testData is 1.0 ", 4.0, v_set4.getEntry(3));        assertEquals("testData is 7.0 ", 7.0, v_set4.getEntry(6));        try {            v_set4.setSubVector(7, v2_t);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayRealVector vout10 = (ArrayRealVector) v1.copy();        ArrayRealVector vout10_2 = (ArrayRealVector) v1.copy();        assertEquals(vout10, vout10_2);        vout10_2.setEntry(0, 1.1);        assertNotSame(vout10, vout10_2);    }    public void testMapFunctions() {        ArrayRealVector v1 = new ArrayRealVector(vec1);        //octave =  v1 .+ 2.0        RealVector v_mapAdd = v1.mapAdd(2.0d);        double[] result_mapAdd = {3d, 4d, 5d};        assertClose("compare vectors" ,result_mapAdd,v_mapAdd.getData(),normTolerance);        //octave =  v1 .+ 2.0        RealVector v_mapAddToSelf = v1.copy();        v_mapAddToSelf.mapAddToSelf(2.0d);        double[] result_mapAddToSelf = {3d, 4d, 5d};        assertClose("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData(),normTolerance);        //octave =  v1 .- 2.0        RealVector v_mapSubtract = v1.mapSubtract(2.0d);        double[] result_mapSubtract = {-1d, 0d, 1d};        assertClose("compare vectors" ,result_mapSubtract,v_mapSubtract.getData(),normTolerance);        //octave =  v1 .- 2.0        RealVector v_mapSubtractToSelf = v1.copy();        v_mapSubtractToSelf.mapSubtractToSelf(2.0d);        double[] result_mapSubtractToSelf = {-1d, 0d, 1d};        assertClose("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData(),normTolerance);        //octave =  v1 .* 2.0        RealVector v_mapMultiply = v1.mapMultiply(2.0d);        double[] result_mapMultiply = {2d, 4d, 6d};        assertClose("compare vectors" ,result_mapMultiply,v_mapMultiply.getData(),normTolerance);        //octave =  v1 .* 2.0        RealVector v_mapMultiplyToSelf = v1.copy();        v_mapMultiplyToSelf.mapMultiplyToSelf(2.0d);        double[] result_mapMultiplyToSelf = {2d, 4d, 6d};        assertClose("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData(),normTolerance);        //octave =  v1 ./ 2.0        RealVector v_mapDivide = v1.mapDivide(2.0d);        double[] result_mapDivide = {.5d, 1d, 1.5d};        assertClose("compare vectors" ,result_mapDivide,v_mapDivide.getData(),normTolerance);        //octave =  v1 ./ 2.0        RealVector v_mapDivideToSelf = v1.copy();        v_mapDivideToSelf.mapDivideToSelf(2.0d);        double[] result_mapDivideToSelf = {.5d, 1d, 1.5d};        assertClose("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData(),normTolerance);        //octave =  v1 .^ 2.0        RealVector v_mapPow = v1.mapPow(2.0d);        double[] result_mapPow = {1d, 4d, 9d};        assertClose("compare vectors" ,result_mapPow,v_mapPow.getData(),normTolerance);        //octave =  v1 .^ 2.0        RealVector v_mapPowToSelf = v1.copy();        v_mapPowToSelf.mapPowToSelf(2.0d);        double[] result_mapPowToSelf = {1d, 4d, 9d};        assertClose("compare vectors" ,result_mapPowToSelf,v_mapPowToSelf.getData(),normTolerance);        //octave =  exp(v1)        RealVector v_mapExp = v1.mapExp();        double[] result_mapExp = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};        assertClose("compare vectors" ,result_mapExp,v_mapExp.getData(),normTolerance);        //octave =  exp(v1)        RealVector v_mapExpToSelf = v1.copy();        v_mapExpToSelf.mapExpToSelf();        double[] result_mapExpToSelf = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};        assertClose("compare vectors" ,result_mapExpToSelf,v_mapExpToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapExpm1 = v1.mapExpm1();        double[] result_mapExpm1 = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};        assertClose("compare vectors" ,result_mapExpm1,v_mapExpm1.getData(),normTolerance);        //octave =  ???        RealVector v_mapExpm1ToSelf = v1.copy();        v_mapExpm1ToSelf.mapExpm1ToSelf();        double[] result_mapExpm1ToSelf = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};        assertClose("compare vectors" ,result_mapExpm1ToSelf,v_mapExpm1ToSelf.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLog = v1.mapLog();        double[] result_mapLog = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};        assertClose("compare vectors" ,result_mapLog,v_mapLog.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLogToSelf = v1.copy();        v_mapLogToSelf.mapLogToSelf();        double[] result_mapLogToSelf = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};        assertClose("compare vectors" ,result_mapLogToSelf,v_mapLogToSelf.getData(),normTolerance);        //octave =  log10(v1)        RealVector v_mapLog10 = v1.mapLog10();        double[] result_mapLog10 = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};        assertClose("compare vectors" ,result_mapLog10,v_mapLog10.getData(),normTolerance);        //octave =  log(v1)        RealVector v_mapLog10ToSelf = v1.copy();        v_mapLog10ToSelf.mapLog10ToSelf();        double[] result_mapLog10ToSelf = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};        assertClose("compare vectors" ,result_mapLog10ToSelf,v_mapLog10ToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapLog1p = v1.mapLog1p();        double[] result_mapLog1p = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};        assertClose("compare vectors" ,result_mapLog1p,v_mapLog1p.getData(),normTolerance);        //octave =  ???        RealVector v_mapLog1pToSelf = v1.copy();        v_mapLog1pToSelf.mapLog1pToSelf();        double[] result_mapLog1pToSelf = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};        assertClose("compare vectors" ,result_mapLog1pToSelf,v_mapLog1pToSelf.getData(),normTolerance);        //octave =  cosh(v1)        RealVector v_mapCosh = v1.mapCosh();        double[] result_mapCosh = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};        assertClose("compare vectors" ,result_mapCosh,v_mapCosh.getData(),normTolerance);        //octave =  cosh(v1)        RealVector v_mapCoshToSelf = v1.copy();        v_mapCoshToSelf.mapCoshToSelf();        double[] result_mapCoshToSelf = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};        assertClose("compare vectors" ,result_mapCoshToSelf,v_mapCoshToSelf.getData(),normTolerance);        //octave =  sinh(v1)        RealVector v_mapSinh = v1.mapSinh();        double[] result_mapSinh = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};        assertClose("compare vectors" ,result_mapSinh,v_mapSinh.getData(),normTolerance);        //octave =  sinh(v1)        RealVector v_mapSinhToSelf = v1.copy();        v_mapSinhToSelf.mapSinhToSelf();        double[] result_mapSinhToSelf = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};        assertClose("compare vectors" ,result_mapSinhToSelf,v_mapSinhToSelf.getData(),normTolerance);        //octave =  tanh(v1)        RealVector v_mapTanh = v1.mapTanh();        double[] result_mapTanh = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};        assertClose("compare vectors" ,result_mapTanh,v_mapTanh.getData(),normTolerance);        //octave =  tanh(v1)        RealVector v_mapTanhToSelf = v1.copy();        v_mapTanhToSelf.mapTanhToSelf();        double[] result_mapTanhToSelf = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};        assertClose("compare vectors" ,result_mapTanhToSelf,v_mapTanhToSelf.getData(),normTolerance);        //octave =  cos(v1)        RealVector v_mapCos = v1.mapCos();        double[] result_mapCos = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};        assertClose("compare vectors" ,result_mapCos,v_mapCos.getData(),normTolerance);        //octave =  cos(v1)        RealVector v_mapCosToSelf = v1.copy();        v_mapCosToSelf.mapCosToSelf();        double[] result_mapCosToSelf = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};        assertClose("compare vectors" ,result_mapCosToSelf,v_mapCosToSelf.getData(),normTolerance);        //octave =  sin(v1)        RealVector v_mapSin = v1.mapSin();        double[] result_mapSin = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};        assertClose("compare vectors" ,result_mapSin,v_mapSin.getData(),normTolerance);        //octave =  sin(v1)        RealVector v_mapSinToSelf = v1.copy();        v_mapSinToSelf.mapSinToSelf();        double[] result_mapSinToSelf = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};        assertClose("compare vectors" ,result_mapSinToSelf,v_mapSinToSelf.getData(),normTolerance);        //octave =  tan(v1)        RealVector v_mapTan = v1.mapTan();        double[] result_mapTan = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};        assertClose("compare vectors" ,result_mapTan,v_mapTan.getData(),normTolerance);        //octave =  tan(v1)        RealVector v_mapTanToSelf = v1.copy();        v_mapTanToSelf.mapTanToSelf();        double[] result_mapTanToSelf = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};        assertClose("compare vectors" ,result_mapTanToSelf,v_mapTanToSelf.getData(),normTolerance);        double[] vat_a = {0d, 0.5d, 1.0d};        ArrayRealVector vat = new ArrayRealVector(vat_a);        //octave =  acos(vat)        RealVector v_mapAcos = vat.mapAcos();        double[] result_mapAcos = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};        assertClose("compare vectors" ,result_mapAcos,v_mapAcos.getData(),normTolerance);        //octave =  acos(vat)        RealVector v_mapAcosToSelf = vat.copy();        v_mapAcosToSelf.mapAcosToSelf();        double[] result_mapAcosToSelf = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};        assertClose("compare vectors" ,result_mapAcosToSelf,v_mapAcosToSelf.getData(),normTolerance);        //octave =  asin(vat)        RealVector v_mapAsin = vat.mapAsin();        double[] result_mapAsin = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};        assertClose("compare vectors" ,result_mapAsin,v_mapAsin.getData(),normTolerance);        //octave =  asin(vat)        RealVector v_mapAsinToSelf = vat.copy();        v_mapAsinToSelf.mapAsinToSelf();        double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};        assertClose("compare vectors" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);        //octave =  atan(vat)        RealVector v_mapAtan = vat.mapAtan();        double[] result_mapAtan = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};        assertClose("compare vectors" ,result_mapAtan,v_mapAtan.getData(),normTolerance);        //octave =  atan(vat)        RealVector v_mapAtanToSelf = vat.copy();        v_mapAtanToSelf.mapAtanToSelf();        double[] result_mapAtanToSelf = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};        assertClose("compare vectors" ,result_mapAtanToSelf,v_mapAtanToSelf.getData(),normTolerance);        //octave =  v1 .^-1        RealVector v_mapInv = v1.mapInv();        double[] result_mapInv = {1d,0.5d,3.333333333333333e-01d};        assertClose("compare vectors" ,result_mapInv,v_mapInv.getData(),normTolerance);        //octave =  v1 .^-1        RealVector v_mapInvToSelf = v1.copy();        v_mapInvToSelf.mapInvToSelf();        double[] result_mapInvToSelf = {1d,0.5d,3.333333333333333e-01d};        assertClose("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData(),normTolerance);        double[] abs_a = {-1.0d, 0.0d, 1.0d};        ArrayRealVector abs_v = new ArrayRealVector(abs_a);        //octave =  abs(abs_v)        RealVector v_mapAbs = abs_v.mapAbs();        double[] result_mapAbs = {1d,0d,1d};        assertClose("compare vectors" ,result_mapAbs,v_mapAbs.getData(),normTolerance);        //octave = abs(abs_v)        RealVector v_mapAbsToSelf = abs_v.copy();        v_mapAbsToSelf.mapAbsToSelf();        double[] result_mapAbsToSelf = {1d,0d,1d};        assertClose("compare vectors" ,result_mapAbsToSelf,v_mapAbsToSelf.getData(),normTolerance);        //octave =   sqrt(v1)        RealVector v_mapSqrt = v1.mapSqrt();        double[] result_mapSqrt = {1d,1.414213562373095e+00d,1.732050807568877e+00d};        assertClose("compare vectors" ,result_mapSqrt,v_mapSqrt.getData(),normTolerance);        //octave =  sqrt(v1)        RealVector v_mapSqrtToSelf = v1.copy();        v_mapSqrtToSelf.mapSqrtToSelf();        double[] result_mapSqrtToSelf = {1d,1.414213562373095e+00d,1.732050807568877e+00d};        assertClose("compare vectors" ,result_mapSqrtToSelf,v_mapSqrtToSelf.getData(),normTolerance);        double[] cbrt_a = {-2.0d, 0.0d, 2.0d};        ArrayRealVector cbrt_v = new ArrayRealVector(cbrt_a);        //octave =  ???        RealVector v_mapCbrt = cbrt_v.mapCbrt();        double[] result_mapCbrt = {-1.2599210498948732d,0d,1.2599210498948732d};        assertClose("compare vectors" ,result_mapCbrt,v_mapCbrt.getData(),normTolerance);        //octave = ???        RealVector v_mapCbrtToSelf = cbrt_v.copy();        v_mapCbrtToSelf.mapCbrtToSelf();        double[] result_mapCbrtToSelf =  {-1.2599210498948732d,0d,1.2599210498948732d};        assertClose("compare vectors" ,result_mapCbrtToSelf,v_mapCbrtToSelf.getData(),normTolerance);        double[] ceil_a = {-1.1d, 0.9d, 1.1d};        ArrayRealVector ceil_v = new ArrayRealVector(ceil_a);        //octave =  ceil(ceil_v)        RealVector v_mapCeil = ceil_v.mapCeil();        double[] result_mapCeil = {-1d,1d,2d};        assertClose("compare vectors" ,result_mapCeil,v_mapCeil.getData(),normTolerance);        //octave = ceil(ceil_v)        RealVector v_mapCeilToSelf = ceil_v.copy();        v_mapCeilToSelf.mapCeilToSelf();        double[] result_mapCeilToSelf =  {-1d,1d,2d};        assertClose("compare vectors" ,result_mapCeilToSelf,v_mapCeilToSelf.getData(),normTolerance);        //octave =  floor(ceil_v)        RealVector v_mapFloor = ceil_v.mapFloor();        double[] result_mapFloor = {-2d,0d,1d};        assertClose("compare vectors" ,result_mapFloor,v_mapFloor.getData(),normTolerance);        //octave = floor(ceil_v)        RealVector v_mapFloorToSelf = ceil_v.copy();        v_mapFloorToSelf.mapFloorToSelf();        double[] result_mapFloorToSelf =  {-2d,0d,1d};        assertClose("compare vectors" ,result_mapFloorToSelf,v_mapFloorToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapRint = ceil_v.mapRint();        double[] result_mapRint = {-1d,1d,1d};        assertClose("compare vectors" ,result_mapRint,v_mapRint.getData(),normTolerance);        //octave = ???        RealVector v_mapRintToSelf = ceil_v.copy();        v_mapRintToSelf.mapRintToSelf();        double[] result_mapRintToSelf =  {-1d,1d,1d};        assertClose("compare vectors" ,result_mapRintToSelf,v_mapRintToSelf.getData(),normTolerance);        //octave =  ???        RealVector v_mapSignum = ceil_v.mapSignum();        double[] result_mapSignum = {-1d,1d,1d};        assertClose("compare vectors" ,result_mapSignum,v_mapSignum.getData(),normTolerance);        //octave = ???        RealVector v_mapSignumToSelf = ceil_v.copy();        v_mapSignumToSelf.mapSignumToSelf();        double[] result_mapSignumToSelf =  {-1d,1d,1d};        assertClose("compare vectors" ,result_mapSignumToSelf,v_mapSignumToSelf.getData(),normTolerance);        // Is with the used resolutions of limited value as test        //octave =  ???        RealVector v_mapUlp = ceil_v.mapUlp();        double[] result_mapUlp = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};        assertClose("compare vectors" ,result_mapUlp,v_mapUlp.getData(),normTolerance);        //octave = ???        RealVector v_mapUlpToSelf = ceil_v.copy();        v_mapUlpToSelf.mapUlpToSelf();        double[] result_mapUlpToSelf = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};        assertClose("compare vectors" ,result_mapUlpToSelf,v_mapUlpToSelf.getData(),normTolerance);    }    public void testBasicFunctions() {        ArrayRealVector v1 = new ArrayRealVector(vec1);        ArrayRealVector v2 = new ArrayRealVector(vec2);        ArrayRealVector v5 = new ArrayRealVector(vec5);        ArrayRealVector v_null = new ArrayRealVector(vec_null);        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);        // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307        double d_getNorm = v5.getNorm();        assertEquals("compare values  ", 8.4261497731763586307, d_getNorm);        // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17        double d_getL1Norm = v5.getL1Norm();        assertEquals("compare values  ", 17.0, d_getL1Norm);        // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6        double d_getLInfNorm = v5.getLInfNorm();        assertEquals("compare values  ", 6.0, d_getLInfNorm);        //octave =  sqrt(sumsq(v1-v2))        double dist = v1.getDistance(v2);        assertEquals("compare values  ",v1.subtract(v2).getNorm(), dist );        //octave =  sqrt(sumsq(v1-v2))        double dist_2 = v1.getDistance(v2_t);        assertEquals("compare values  ", v1.subtract(v2).getNorm(),dist_2 );        //octave =  sqrt(sumsq(v1-v2))        double dist_3 = v1.getDistance((RealVector) v2);        assertEquals("compare values  ", v1.subtract(v2).getNorm(),dist_3 );        //octave =  ???        double d_getL1Distance = v1. getL1Distance(v2);        assertEquals("compare values  ",9d, d_getL1Distance );        double d_getL1Distance_2 = v1. getL1Distance(v2_t);        assertEquals("compare values  ",9d, d_getL1Distance_2 );        double d_getL1Distance_3 = v1. getL1Distance((RealVector) v2);        assertEquals("compare values  ",9d, d_getL1Distance_3 );        //octave =  ???        double d_getLInfDistance = v1. getLInfDistance(v2);        assertEquals("compare values  ",3d, d_getLInfDistance );        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);        assertEquals("compare values  ",3d, d_getLInfDistance_2 );        double d_getLInfDistance_3 = v1. getLInfDistance((RealVector) v2);        assertEquals("compare values  ",3d, d_getLInfDistance_3 );        //octave =  v1 + v2        ArrayRealVector v_add = v1.add(v2);        double[] result_add = {5d, 7d, 9d};        assertClose("compare vect" ,v_add.getData(),result_add,normTolerance);        RealVectorTestImpl vt2 = new RealVectorTestImpl(vec2);        RealVector v_add_i = v1.add(vt2);        double[] result_add_i = {5d, 7d, 9d};        assertClose("compare vect" ,v_add_i.getData(),result_add_i,normTolerance);        //octave =  v1 - v2        ArrayRealVector v_subtract = v1.subtract(v2);        double[] result_subtract = {-3d, -3d, -3d};        assertClose("compare vect" ,v_subtract.getData(),result_subtract,normTolerance);        RealVector v_subtract_i = v1.subtract(vt2);        double[] result_subtract_i = {-3d, -3d, -3d};        assertClose("compare vect" ,v_subtract_i.getData(),result_subtract_i,normTolerance);        // octave v1 .* v2        ArrayRealVector  v_ebeMultiply = v1.ebeMultiply(v2);        double[] result_ebeMultiply = {4d, 10d, 18d};        assertClose("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);        double[] result_ebeMultiply_2 = {4d, 10d, 18d};        assertClose("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);        RealVector  v_ebeMultiply_3 = v1.ebeMultiply((RealVector) v2);        double[] result_ebeMultiply_3 = {4d, 10d, 18d};        assertClose("compare vect" ,v_ebeMultiply_3.getData(),result_ebeMultiply_3,normTolerance);        // octave v1 ./ v2        ArrayRealVector  v_ebeDivide = v1.ebeDivide(v2);        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};        assertClose("compare vect" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};        assertClose("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);        RealVector  v_ebeDivide_3 = v1.ebeDivide((RealVector) v2);        double[] result_ebeDivide_3 = {0.25d, 0.4d, 0.5d};        assertClose("compare vect" ,v_ebeDivide_3.getData(),result_ebeDivide_3,normTolerance);        // octave  dot(v1,v2)        double dot =  v1.dotProduct(v2);        assertEquals("compare val ",32d, dot);        // octave  dot(v1,v2_t)        double dot_2 =  v1.dotProduct(v2_t);        assertEquals("compare val ",32d, dot_2);        RealMatrix m_outerProduct = v1.outerProduct(v2);        assertEquals("compare val ",4d, m_outerProduct.getEntry(0,0));        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);        assertEquals("compare val ",4d, m_outerProduct_2.getEntry(0,0));        RealMatrix m_outerProduct_3 = v1.outerProduct((RealVector) v2);        assertEquals("compare val ",4d, m_outerProduct_3.getEntry(0,0));        RealVector v_unitVector = v1.unitVector();        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());        assertClose("compare vect" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);        try {            v_null.unitVector();            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayRealVector v_unitize = (ArrayRealVector)v1.copy();        v_unitize.unitize();        assertClose("compare vect" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);        try {            v_null.unitize();            fail("Expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayRealVector v_projection = v1.projection(v2);        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};        assertClose("compare vect", v_projection.getData(), result_projection, normTolerance);        RealVector v_projection_2 = v1.projection(v2_t);        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};        assertClose("compare vect", v_projection_2.getData(), result_projection_2, normTolerance);        RealVector v_projection_3 = v1.projection(v2.getData());        double[] result_projection_3 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};        assertClose("compare vect", v_projection_3.getData(), result_projection_3, normTolerance);    }    public void testMisc() {        ArrayRealVector v1 = new ArrayRealVector(vec1);        ArrayRealVector v4 = new ArrayRealVector(vec4);        RealVector v4_2 = new ArrayRealVector(vec4);        String out1 = v1.toString();        assertTrue("some output ",  out1.length()!=0);        /*         double[] dout1 = v1.copyOut();        assertEquals("testData len", 3, dout1.length);        assertNotSame("testData not same object ", v1.data, dout1);         */        try {            v1.checkVectorDimensions(2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }       try {            v1.checkVectorDimensions(v4);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            v1.checkVectorDimensions(v4_2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testPredicates() {        ArrayRealVector v = new ArrayRealVector(new double[] { 0, 1, 2 });        assertFalse(v.isNaN());        v.setEntry(1, Double.NaN);        assertTrue(v.isNaN());        assertFalse(v.isInfinite());        v.setEntry(0, Double.POSITIVE_INFINITY);        assertFalse(v.isInfinite());        v.setEntry(1, 1);        assertTrue(v.isInfinite());        v.setEntry(0, 1);        assertFalse(v.isInfinite());        v.setEntry(0, 0);        assertEquals(v, new ArrayRealVector(new double[] { 0, 1, 2 }));        assertNotSame(v, new ArrayRealVector(new double[] { 0, 1, 2 + FastMath.ulp(2)}));        assertNotSame(v, new ArrayRealVector(new double[] { 0, 1, 2, 3 }));        assertEquals(new ArrayRealVector(new double[] { Double.NaN, 1, 2 }).hashCode(),                     new ArrayRealVector(new double[] { 0, Double.NaN, 2 }).hashCode());        assertTrue(new ArrayRealVector(new double[] { Double.NaN, 1, 2 }).hashCode() !=                   new ArrayRealVector(new double[] { 0, 1, 2 }).hashCode());        assertTrue(v.equals(v));        assertTrue(v.equals(v.copy()));        assertFalse(v.equals(null));        assertFalse(v.equals(v.getDataRef()));        assertFalse(v.equals(v.getSubVector(0, v.getDimension() - 1)));        assertTrue(v.equals(v.getSubVector(0, v.getDimension())));    }    public void testSerial()  {        ArrayRealVector v = new ArrayRealVector(new double[] { 0, 1, 2 });        assertEquals(v,TestUtils.serializeAndRecover(v));    }    public void testMinMax()  {        ArrayRealVector v1 = new ArrayRealVector(new double[] { 0, -6, 4, 12, 7 });        assertEquals(1,  v1.getMinIndex());        assertEquals(-6, v1.getMinValue(), 1.0e-12);        assertEquals(3,  v1.getMaxIndex());        assertEquals(12, v1.getMaxValue(), 1.0e-12);        ArrayRealVector v2 = new ArrayRealVector(new double[] { Double.NaN, 3, Double.NaN, -2 });        assertEquals(3,  v2.getMinIndex());        assertEquals(-2, v2.getMinValue(), 1.0e-12);        assertEquals(1,  v2.getMaxIndex());        assertEquals(3, v2.getMaxValue(), 1.0e-12);        ArrayRealVector v3 = new ArrayRealVector(new double[] { Double.NaN, Double.NaN });        assertEquals(-1,  v3.getMinIndex());        assertTrue(Double.isNaN(v3.getMinValue()));        assertEquals(-1,  v3.getMaxIndex());        assertTrue(Double.isNaN(v3.getMaxValue()));        ArrayRealVector v4 = new ArrayRealVector(new double[0]);        assertEquals(-1,  v4.getMinIndex());        assertTrue(Double.isNaN(v4.getMinValue()));        assertEquals(-1,  v4.getMaxIndex());        assertTrue(Double.isNaN(v4.getMaxValue()));    }    /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, double[] m, double[] n,            double tolerance) {        if (m.length != n.length) {            fail("vectors have different lengths");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " +  i + " elements differ", m[i],n[i],tolerance);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Random;import junit.framework.TestCase;import org.apache.commons.math.util.MathUtils;public class EigenSolverTest extends TestCase {    private double[] refValues;    private RealMatrix matrix;    public EigenSolverTest(String name) {        super(name);    }    /** test non invertible matrix */    public void testNonInvertible() {        Random r = new Random(9994100315209l);        RealMatrix m =            EigenDecompositionImplTest.createTestMatrix(r, new double[] { 1.0, 0.0, -1.0, -2.0, -3.0 });        DecompositionSolver es = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN).getSolver();        assertFalse(es.isNonSingular());        try {            es.getInverse();            fail("an exception should have been thrown");        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test invertible matrix */    public void testInvertible() {        Random r = new Random(9994100315209l);        RealMatrix m =            EigenDecompositionImplTest.createTestMatrix(r, new double[] { 1.0, 0.5, -1.0, -2.0, -3.0 });        DecompositionSolver es = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN).getSolver();        assertTrue(es.isNonSingular());        RealMatrix inverse = es.getInverse();        RealMatrix error =            m.multiply(inverse).subtract(MatrixUtils.createRealIdentityMatrix(m.getRowDimension()));        assertEquals(0, error.getNorm(), 4.0e-15);    }    /** test solve dimension errors */    public void testSolveDimensionErrors() {        DecompositionSolver es = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);        try {            es.solve(b);            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            es.solve(b.getColumn(0));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            es.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test solve */    public void testSolve() {        RealMatrix m = MatrixUtils.createRealMatrix(new double[][] {                { 91,  5, 29, 32, 40, 14 },                {  5, 34, -1,  0,  2, -1 },                { 29, -1, 12,  9, 21,  8 },                { 32,  0,  9, 14,  9,  0 },                { 40,  2, 21,  9, 51, 19 },                { 14, -1,  8,  0, 19, 14 }        });        DecompositionSolver es = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                { 1561, 269, 188 },                {   69, -21,  70 },                {  739, 108,  63 },                {  324,  86,  59 },                { 1624, 194, 107 },                {  796,  69,  36 }        });        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                { 1,   2, 1 },                { 2,  -1, 2 },                { 4,   2, 3 },                { 8,  -1, 0 },                { 16,  2, 0 },                { 32, -1, 0 }        });        // using RealMatrix        RealMatrix solution=es.solve(b);        assertEquals(0, solution.subtract(xRef).getNorm(), 2.5e-12);        // using double[]        for (int i = 0; i < b.getColumnDimension(); ++i) {            assertEquals(0,                         new ArrayRealVector(es.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),                         2.0e-11);        }        // using Array2DRowRealMatrix        for (int i = 0; i < b.getColumnDimension(); ++i) {            assertEquals(0,                         es.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),                         2.0e-11);        }        // using RealMatrix with an alternate implementation        for (int i = 0; i < b.getColumnDimension(); ++i) {            ArrayRealVectorTest.RealVectorTestImpl v =                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));            assertEquals(0,                         es.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),                         2.0e-11);        }    }    @Override    public void setUp() {        refValues = new double[] {                2.003, 2.002, 2.001, 1.001, 1.000, 0.001        };        matrix = EigenDecompositionImplTest.createTestMatrix(new Random(35992629946426l), refValues);    }    @Override    public void tearDown() {        refValues = null;        matrix    = null;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Locale;public class FrenchRealVectorFormatTest extends RealVectorFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return ',';    }    @Override    protected Locale getLocale() {        return Locale.FRENCH;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.MatrixDimensionMismatchException;/** * Test cases for the {@link RealMatrixImpl} class. * * @version $Revision$ $Date$ */@Deprecatedpublic final class RealMatrixImplTest extends TestCase {    // 3 x 3 identity matrix    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };    // Test data for group operations    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},       {-1d,0d,-8d} };    protected double[] testDataRow1 = {1d,2d,3d};    protected double[] testDataCol3 = {3d,3d,8d};    protected double[][] testDataInv =        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };    protected double[] preMultTest = {8,12,33};    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};    protected double[][] testDataPlusInv =        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };    // lu decomposition tests    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},            {0.33333333333333,0d,0.33333333333333} };    // singular matrices    protected double[][] singular = { {2d,3d}, {2d,3d} };    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};    // vectors    protected double[] testVector = {1,2,3};    protected double[] testVector2 = {1,2,3,4};    // submatrix accessor tests    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},            {2, 4, 6, 8}, {4, 5, 6, 7}};    // array selections    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};    // effective permutations    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};    // contiguous ranges    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};    protected double[][] subRows23Cols00 = {{2} , {4}};    protected double[][] subRows00Cols33 = {{4}};    // row matrices    protected double[][] subRow0 = {{1,2,3,4}};    protected double[][] subRow3 = {{4,5,6,7}};    // column matrices    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    public RealMatrixImplTest(String name) {        super(name);    }    /** test dimensions */    public void testDimensions() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());    }    /** test copy functions */    public void testCopyFunctions() {        RealMatrixImpl m1 = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(m1.getData());        assertEquals(m2,m1);        RealMatrixImpl m3 = new RealMatrixImpl(testData);        RealMatrixImpl m4 = new RealMatrixImpl(m3.getData(), false);        assertEquals(m4,m3);    }    /** test add */    public void testAdd() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);        RealMatrix mPlusMInv = m.add(mInv);        double[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                    testDataPlusInv[row][col],sumEntries[row][col],                        entryTolerance);            }        }    }    /** test add failure */    public void testAddFail() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        try {            m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test norm */    public void testNorm() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertEquals("testData norm",14d,m.getNorm(),entryTolerance);        assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);    }    /** test Frobenius norm */    public void testFrobeniusNorm() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertEquals("testData Frobenius norm", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);        assertEquals("testData2 Frobenius norm", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);    }     /** test m-n = m + -n */    public void testPlusMinus() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testDataInv);        TestUtils.assertEquals("m-n = m + -n",m.subtract(m2),            m2.scalarMultiply(-1d).add(m),entryTolerance);        try {            m.subtract(new RealMatrixImpl(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test multiply */     public void testMultiply() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);        RealMatrixImpl identity = new RealMatrixImpl(id);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        TestUtils.assertEquals("inverse multiply",m.multiply(mInv),            identity,entryTolerance);        TestUtils.assertEquals("inverse multiply",mInv.multiply(m),            identity,entryTolerance);        TestUtils.assertEquals("identity multiply",m.multiply(identity),            m,entryTolerance);        TestUtils.assertEquals("identity multiply",identity.multiply(mInv),            mInv,entryTolerance);        TestUtils.assertEquals("identity multiply",m2.multiply(identity),            m2,entryTolerance);        try {            m.multiply(new RealMatrixImpl(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    //Additional Test for RealMatrixImplTest.testMultiply    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};    private double[][] d4 = new double[][] {{1},{2},{3},{4}};    private double[][] d5 = new double[][] {{30},{70}};    public void testMultiply2() {       RealMatrix m3 = new RealMatrixImpl(d3);       RealMatrix m4 = new RealMatrixImpl(d4);       RealMatrix m5 = new RealMatrixImpl(d5);       TestUtils.assertEquals("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);   }    /** test trace */    public void testTrace() {        RealMatrix m = new RealMatrixImpl(id);        assertEquals("identity trace",3d,m.getTrace(),entryTolerance);        m = new RealMatrixImpl(testData2);        try {            m.getTrace();            fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }    }    /** test sclarAdd */    public void testScalarAdd() {        RealMatrix m = new RealMatrixImpl(testData);        TestUtils.assertEquals("scalar add",new RealMatrixImpl(testDataPlus2),            m.scalarAdd(2d),entryTolerance);    }    /** test operate */    public void testOperate() {        RealMatrix m = new RealMatrixImpl(id);        TestUtils.assertEquals("identity operate", testVector,                    m.operate(testVector), entryTolerance);        TestUtils.assertEquals("identity operate", testVector,                    m.operate(new ArrayRealVector(testVector)).getData(), entryTolerance);        m = new RealMatrixImpl(bigSingular);        try {            m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test issue MATH-209 */    public void testMath209() {        RealMatrix a = new RealMatrixImpl(new double[][] {                { 1, 2 }, { 3, 4 }, { 5, 6 }        }, false);        double[] b = a.operate(new double[] { 1, 1 });        assertEquals(a.getRowDimension(), b.length);        assertEquals( 3.0, b[0], 1.0e-12);        assertEquals( 7.0, b[1], 1.0e-12);        assertEquals(11.0, b[2], 1.0e-12);    }    /** test transpose */    public void testTranspose() {        RealMatrix m = new RealMatrixImpl(testData);        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();        TestUtils.assertEquals("inverse-transpose", mIT, mTI, normTolerance);        m = new RealMatrixImpl(testData2);        RealMatrix mt = new RealMatrixImpl(testData2T);        TestUtils.assertEquals("transpose",mt,m.transpose(),normTolerance);    }    /** test preMultiply by vector */    public void testPremultiplyVector() {        RealMatrix m = new RealMatrixImpl(testData);        TestUtils.assertEquals("premultiply", m.preMultiply(testVector),                    preMultTest, normTolerance);        TestUtils.assertEquals("premultiply", m.preMultiply(new ArrayRealVector(testVector).getData()),                    preMultTest, normTolerance);        m = new RealMatrixImpl(bigSingular);        try {            m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testPremultiply() {        RealMatrix m3 = new RealMatrixImpl(d3);        RealMatrix m4 = new RealMatrixImpl(d4);        RealMatrix m5 = new RealMatrixImpl(d5);        TestUtils.assertEquals("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);        RealMatrixImpl identity = new RealMatrixImpl(id);        TestUtils.assertEquals("inverse multiply",m.preMultiply(mInv),                identity,entryTolerance);        TestUtils.assertEquals("inverse multiply",mInv.preMultiply(m),                identity,entryTolerance);        TestUtils.assertEquals("identity multiply",m.preMultiply(identity),                m,entryTolerance);        TestUtils.assertEquals("identity multiply",identity.preMultiply(mInv),                mInv,entryTolerance);        try {            m.preMultiply(new RealMatrixImpl(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testGetVectors() {        RealMatrix m = new RealMatrixImpl(testData);        TestUtils.assertEquals("get row",m.getRow(0),testDataRow1,entryTolerance);        TestUtils.assertEquals("get col",m.getColumn(2),testDataCol3,entryTolerance);        try {            m.getRow(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }        try {            m.getColumn(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }    }    public void testGetEntry() {        RealMatrix m = new RealMatrixImpl(testData);        assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);        try {            m.getEntry(10, 4);            fail ("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    /** test examples in user guide */    public void testExamples() {        // Create a real matrix with two rows and three columns        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};        RealMatrix m = new RealMatrixImpl(matrixData);        // One more with three rows, two columns        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};        RealMatrix n = new RealMatrixImpl(matrixData2);        // Now multiply m by n        RealMatrix p = m.multiply(n);        assertEquals(2, p.getRowDimension());        assertEquals(2, p.getColumnDimension());        // Invert p        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();        assertEquals(2, pInverse.getRowDimension());        assertEquals(2, pInverse.getColumnDimension());        // Solve example        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};        RealMatrix coefficients = new RealMatrixImpl(coefficientsData);        double[] constants = {1, -2, 1};        double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);    }    // test submatrix accessors    public void testGetSubMatrix() {        RealMatrix m = new RealMatrixImpl(subTestData);        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int startRow, int endRow, int startColumn, int endColumn,                                   boolean mustFail) {        try {            RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);            assertEquals(new RealMatrixImpl(reference), sub);            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int[] selectedRows, int[] selectedColumns,                                   boolean mustFail) {        try {            RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);            assertEquals(new RealMatrixImpl(reference), sub);            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    public void testCopySubMatrix() {        RealMatrix m = new RealMatrixImpl(subTestData);        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);        checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, -1, 1, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 2, true);        checkCopy(m, null,  1, 0, 2, 4, true);        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);    }    private void checkCopy(RealMatrix m, double[][] reference,                           int startRow, int endRow, int startColumn, int endColumn,                           boolean mustFail) {        try {            double[][] sub = (reference == null) ?                             new double[1][1] :                             new double[reference.length][reference[0].length];            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);            assertEquals(new RealMatrixImpl(reference), new RealMatrixImpl(sub));            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    private void checkCopy(RealMatrix m, double[][] reference,                           int[] selectedRows, int[] selectedColumns,                           boolean mustFail) {        try {            double[][] sub = (reference == null) ?                    new double[1][1] :                    new double[reference.length][reference[0].length];            m.copySubMatrix(selectedRows, selectedColumns, sub);            assertEquals(new RealMatrixImpl(reference), new RealMatrixImpl(sub));            if (mustFail) {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (!mustFail) {                throw e;            }        }    }    public void testGetRowMatrix() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealMatrix mRow0 = new RealMatrixImpl(subRow0);        RealMatrix mRow3 = new RealMatrixImpl(subRow3);        assertEquals("Row0", mRow0,                m.getRowMatrix(0));        assertEquals("Row3", mRow3,                m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowMatrix() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealMatrix mRow3 = new RealMatrixImpl(subRow3);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowMatrix(0, mRow3);        assertEquals(mRow3, m.getRowMatrix(0));        try {            m.setRowMatrix(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowMatrix(0, m);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetColumnMatrix() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealMatrix mColumn1 = new RealMatrixImpl(subColumn1);        RealMatrix mColumn3 = new RealMatrixImpl(subColumn3);        assertEquals("Column1", mColumn1,                m.getColumnMatrix(1));        assertEquals("Column3", mColumn3,                m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnMatrix() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealMatrix mColumn3 = new RealMatrixImpl(subColumn3);        assertNotSame(mColumn3, m.getColumnMatrix(1));        m.setColumnMatrix(1, mColumn3);        assertEquals(mColumn3, m.getColumnMatrix(1));        try {            m.setColumnMatrix(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnMatrix(0, m);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetRowVector() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealVector mRow0 = new ArrayRealVector(subRow0[0]);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        assertEquals("Row0", mRow0, m.getRowVector(0));        assertEquals("Row3", mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowVector() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowVector(0, mRow3);        assertEquals(mRow3, m.getRowVector(0));        try {            m.setRowVector(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowVector(0, new ArrayRealVector(5));            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetColumnVector() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealVector mColumn1 = columnToVector(subColumn1);        RealVector mColumn3 = columnToVector(subColumn3);        assertEquals("Column1", mColumn1, m.getColumnVector(1));        assertEquals("Column3", mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnVector() {        RealMatrix m = new RealMatrixImpl(subTestData);        RealVector mColumn3 = columnToVector(subColumn3);        assertNotSame(mColumn3, m.getColumnVector(1));        m.setColumnVector(1, mColumn3);        assertEquals(mColumn3, m.getColumnVector(1));        try {            m.setColumnVector(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnVector(0, new ArrayRealVector(5));            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    private RealVector columnToVector(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayRealVector(data, false);    }    public void testGetRow() {        RealMatrix m = new RealMatrixImpl(subTestData);        checkArrays(subRow0[0], m.getRow(0));        checkArrays(subRow3[0], m.getRow(3));        try {            m.getRow(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRow(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRow() {        RealMatrix m = new RealMatrixImpl(subTestData);        assertTrue(subRow3[0][0] != m.getRow(0)[0]);        m.setRow(0, subRow3[0]);        checkArrays(subRow3[0], m.getRow(0));        try {            m.setRow(-1, subRow3[0]);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRow(0, new double[5]);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetColumn() {        RealMatrix m = new RealMatrixImpl(subTestData);        double[] mColumn1 = columnToArray(subColumn1);        double[] mColumn3 = columnToArray(subColumn3);        checkArrays(mColumn1, m.getColumn(1));        checkArrays(mColumn3, m.getColumn(3));        try {            m.getColumn(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumn(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumn() {        RealMatrix m = new RealMatrixImpl(subTestData);        double[] mColumn3 = columnToArray(subColumn3);        assertTrue(mColumn3[0] != m.getColumn(1)[0]);        m.setColumn(1, mColumn3);        checkArrays(mColumn3, m.getColumn(1));        try {            m.setColumn(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumn(0, new double[5]);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    private double[] columnToArray(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return data;    }    private void checkArrays(double[] expected, double[] actual) {        assertEquals(expected.length, actual.length);        for (int i = 0; i < expected.length; ++i) {            assertEquals(expected[i], actual[i]);        }    }    public void testEqualsAndHashCode() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m1 = (RealMatrixImpl) m.copy();        RealMatrixImpl mt = (RealMatrixImpl) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(new RealMatrixImpl(bigSingular)));    }    public void testToString() {        RealMatrixImpl m = new RealMatrixImpl(testData);        assertEquals("RealMatrixImpl{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",                m.toString());        m = new RealMatrixImpl();        assertEquals("RealMatrixImpl{}",                m.toString());    }    public void testSetSubMatrix() throws Exception {        RealMatrixImpl m = new RealMatrixImpl(testData);        m.setSubMatrix(detData2,1,1);        RealMatrix expected = MatrixUtils.createRealMatrix            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);        m.setSubMatrix(detData2,0,0);        expected = MatrixUtils.createRealMatrix            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);        m.setSubMatrix(testDataPlus2,0,0);        expected = MatrixUtils.createRealMatrix            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});        assertEquals(expected, m);        // dimension overflow        try {            m.setSubMatrix(testData,1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // dimension underflow        try {            m.setSubMatrix(testData,-1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        try {            m.setSubMatrix(testData,1,-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // null        try {            m.setSubMatrix(null,1,1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }        RealMatrixImpl m2 = new RealMatrixImpl();        try {            m2.setSubMatrix(testData,0,1);            fail("expecting IllegalStateException");        } catch (IllegalStateException e) {            // expected        }        try {            m2.setSubMatrix(testData,1,0);            fail("expecting IllegalStateException");        } catch (IllegalStateException e) {            // expected        }        // ragged        try {            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }        // empty        try {            m.setSubMatrix(new double[][] {{}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }    }    public void testWalk() {        int rows    = 150;        int columns = 75;        RealMatrix m = new RealMatrixImpl(rows, columns);        m.walkInRowOrder(new SetVisitor());        GetVisitor getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new RealMatrixImpl(rows, columns);        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);            assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);            assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new RealMatrixImpl(rows, columns);        m.walkInColumnOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new RealMatrixImpl(rows, columns);        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);            assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);            assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new RealMatrixImpl(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new RealMatrixImpl(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);            assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);            assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new RealMatrixImpl(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new RealMatrixImpl(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);            assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);            assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }    }    public void testSerial()  {        RealMatrixImpl m = new RealMatrixImpl(testData);        assertEquals(m,TestUtils.serializeAndRecover(m));    }    private static class SetVisitor extends DefaultRealMatrixChangingVisitor {        @Override        public double visit(int i, int j, double value) {            return i + j / 1024.0;        }    }    private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {        private int count = 0;        @Override        public void visit(int i, int j, double value) {            ++count;            assertEquals(i + j / 1024.0, value, 0.0);        }        public int getCount() {            return count;        }    }    //--------------- -----------------Protected methods    /** extracts the l  and u matrices from compact lu representation */    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData)  {        if (!lu.isSquare() ||            lowerData.length != lowerData[0].length ||            upperData.length != upperData[0].length ||            lowerData.length != upperData.length ||            lowerData.length != lu.getRowDimension()) {            throw new IllegalArgumentException("incorrect dimensions");        }        int n = lu.getRowDimension();        for (int i = 0; i < n; i++) {            for (int j = 0; j < n; j++) {                if (j < i) {                    lowerData[i][j] = lu.getEntry(i, j);                    upperData[i][j] = 0d;                } else if (i == j) {                    lowerData[i][j] = 1d;                    upperData[i][j] = lu.getEntry(i, j);                } else {                    lowerData[i][j] = 0d;                    upperData[i][j] = lu.getEntry(i, j);                }            }        }    }    /** Returns the result of applying the given row permutation to the matrix */    protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) {        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {            throw new IllegalArgumentException("dimension mismatch");        }        int n = matrix.getRowDimension();        int m = matrix.getColumnDimension();        double out[][] = new double[m][n];        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                out[i][j] = matrix.getEntry(permutation[i], j);            }        }        return new RealMatrixImpl(out);    }//    /** Useful for debugging *///    private void dumpMatrix(RealMatrix m) {//          for (int i = 0; i < m.getRowDimension(); i++) {//              String os = "";//              for (int j = 0; j < m.getColumnDimension(); j++) {//                  os += m.getEntry(i, j) + " ";//              }//              System.out.println(os);//          }//    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.math.BigDecimal;import junit.framework.TestCase;import org.apache.commons.math.fraction.BigFraction;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionConversionException;import org.apache.commons.math.fraction.FractionField;/** * Test cases for the {@link MatrixUtils} class. * * @version $Revision$ $Date$ */public final class MatrixUtilsTest extends TestCase {    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    protected double[][] nullMatrix = null;    protected double[] row = {1,2,3};    protected BigDecimal[] bigRow =        {new BigDecimal(1),new BigDecimal(2),new BigDecimal(3)};    protected String[] stringRow = {"1", "2", "3"};    protected Fraction[] fractionRow =        {new Fraction(1),new Fraction(2),new Fraction(3)};    protected double[][] rowMatrix = {{1,2,3}};    protected BigDecimal[][] bigRowMatrix =        {{new BigDecimal(1), new BigDecimal(2), new BigDecimal(3)}};    protected String[][] stringRowMatrix = {{"1", "2", "3"}};    protected Fraction[][] fractionRowMatrix =        {{new Fraction(1), new Fraction(2), new Fraction(3)}};    protected double[] col = {0,4,6};    protected BigDecimal[] bigCol =        {new BigDecimal(0),new BigDecimal(4),new BigDecimal(6)};    protected String[] stringCol = {"0","4","6"};    protected Fraction[] fractionCol =        {new Fraction(0),new Fraction(4),new Fraction(6)};    protected double[] nullDoubleArray = null;    protected double[][] colMatrix = {{0},{4},{6}};    protected BigDecimal[][] bigColMatrix =        {{new BigDecimal(0)},{new BigDecimal(4)},{new BigDecimal(6)}};    protected String[][] stringColMatrix = {{"0"}, {"4"}, {"6"}};    protected Fraction[][] fractionColMatrix =        {{new Fraction(0)},{new Fraction(4)},{new Fraction(6)}};    public MatrixUtilsTest(String name) {        super(name);    }    public void testCreateRealMatrix() {        assertEquals(new BlockRealMatrix(testData),                MatrixUtils.createRealMatrix(testData));        try {            MatrixUtils.createRealMatrix(new double[][] {{1}, {1,2}});  // ragged            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createRealMatrix(new double[][] {{}, {}});  // no columns            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createRealMatrix(null);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }    public void testcreateFieldMatrix() {        assertEquals(new Array2DRowFieldMatrix<Fraction>(asFraction(testData)),                     MatrixUtils.createFieldMatrix(asFraction(testData)));        assertEquals(new Array2DRowFieldMatrix<Fraction>(fractionColMatrix),                     MatrixUtils.createFieldMatrix(fractionColMatrix));        try {            MatrixUtils.createFieldMatrix(asFraction(new double[][] {{1}, {1,2}}));  // ragged            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createFieldMatrix(asFraction(new double[][] {{}, {}}));  // no columns            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createFieldMatrix((Fraction[][])null);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }    @Deprecated    public void testCreateBigMatrix() {        assertEquals(new BigMatrixImpl(testData),                MatrixUtils.createBigMatrix(testData));        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), true),                MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), false));        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), false),                MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), true));        assertEquals(new BigMatrixImpl(bigColMatrix),                MatrixUtils.createBigMatrix(bigColMatrix));        assertEquals(new BigMatrixImpl(stringColMatrix),                MatrixUtils.createBigMatrix(stringColMatrix));        try {            MatrixUtils.createBigMatrix(new double[][] {{1}, {1,2}});  // ragged            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createBigMatrix(new double[][] {{}, {}});  // no columns            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createBigMatrix(nullMatrix);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }    public void testCreateRowRealMatrix() {        assertEquals(MatrixUtils.createRowRealMatrix(row),                     new BlockRealMatrix(rowMatrix));        try {            MatrixUtils.createRowRealMatrix(new double[] {});  // empty            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createRowRealMatrix(null);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }    public void testCreateRowFieldMatrix() {        assertEquals(MatrixUtils.createRowFieldMatrix(asFraction(row)),                     new Array2DRowFieldMatrix<Fraction>(asFraction(rowMatrix)));        assertEquals(MatrixUtils.createRowFieldMatrix(fractionRow),                     new Array2DRowFieldMatrix<Fraction>(fractionRowMatrix));        try {            MatrixUtils.createRowFieldMatrix(new Fraction[] {});  // empty            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createRowFieldMatrix((Fraction[]) null);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }    @Deprecated    public void testCreateRowBigMatrix() {        assertEquals(MatrixUtils.createRowBigMatrix(row),                new BigMatrixImpl(rowMatrix));        assertEquals(MatrixUtils.createRowBigMatrix(bigRow),                new BigMatrixImpl(bigRowMatrix));        assertEquals(MatrixUtils.createRowBigMatrix(stringRow),                new BigMatrixImpl(stringRowMatrix));        try {            MatrixUtils.createRowBigMatrix(new double[] {});  // empty            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createRowBigMatrix(nullDoubleArray);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }    public void testCreateColumnRealMatrix() {        assertEquals(MatrixUtils.createColumnRealMatrix(col),                     new BlockRealMatrix(colMatrix));        try {            MatrixUtils.createColumnRealMatrix(new double[] {});  // empty            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createColumnRealMatrix(null);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }    public void testCreateColumnFieldMatrix() {        assertEquals(MatrixUtils.createColumnFieldMatrix(asFraction(col)),                     new Array2DRowFieldMatrix<Fraction>(asFraction(colMatrix)));        assertEquals(MatrixUtils.createColumnFieldMatrix(fractionCol),                     new Array2DRowFieldMatrix<Fraction>(fractionColMatrix));        try {            MatrixUtils.createColumnFieldMatrix(new Fraction[] {});  // empty            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createColumnFieldMatrix((Fraction[]) null);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }    @Deprecated    public void testCreateColumnBigMatrix() {        assertEquals(MatrixUtils.createColumnBigMatrix(col),                new BigMatrixImpl(colMatrix));        assertEquals(MatrixUtils.createColumnBigMatrix(bigCol),                new BigMatrixImpl(bigColMatrix));        assertEquals(MatrixUtils.createColumnBigMatrix(stringCol),                new BigMatrixImpl(stringColMatrix));        try {            MatrixUtils.createColumnBigMatrix(new double[] {});  // empty            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            MatrixUtils.createColumnBigMatrix(nullDoubleArray);  // null            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }    /**     * Verifies that the matrix is an identity matrix     */    protected void checkIdentityMatrix(RealMatrix m) {        for (int i = 0; i < m.getRowDimension(); i++) {            for (int j =0; j < m.getColumnDimension(); j++) {                if (i == j) {                    assertEquals(m.getEntry(i, j), 1d, 0);                } else {                    assertEquals(m.getEntry(i, j), 0d, 0);                }            }        }    }    public void testCreateIdentityMatrix() {        checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(3));        checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(2));        checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(1));        try {            MatrixUtils.createRealIdentityMatrix(0);        } catch (IllegalArgumentException ex) {            // expected        }    }    /**     * Verifies that the matrix is an identity matrix     */    protected void checkIdentityFieldMatrix(FieldMatrix<Fraction> m) {        for (int i = 0; i < m.getRowDimension(); i++) {            for (int j =0; j < m.getColumnDimension(); j++) {                if (i == j) {                    assertEquals(m.getEntry(i, j), Fraction.ONE);                } else {                    assertEquals(m.getEntry(i, j), Fraction.ZERO);                }            }        }    }    public void testcreateFieldIdentityMatrix() {        checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 3));        checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 2));        checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 1));        try {            MatrixUtils.createRealIdentityMatrix(0);        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testBigFractionConverter() {        BigFraction[][] bfData = {                { new BigFraction(1), new BigFraction(2), new BigFraction(3) },                { new BigFraction(2), new BigFraction(5), new BigFraction(3) },                { new BigFraction(1), new BigFraction(0), new BigFraction(8) }        };        FieldMatrix<BigFraction> m = new Array2DRowFieldMatrix<BigFraction>(bfData, false);        RealMatrix converted = MatrixUtils.bigFractionMatrixToRealMatrix(m);        RealMatrix reference = new Array2DRowRealMatrix(testData, false);        assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0);    }    public void testFractionConverter() {        Fraction[][] fData = {                { new Fraction(1), new Fraction(2), new Fraction(3) },                { new Fraction(2), new Fraction(5), new Fraction(3) },                { new Fraction(1), new Fraction(0), new Fraction(8) }        };        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(fData, false);        RealMatrix converted = MatrixUtils.fractionMatrixToRealMatrix(m);        RealMatrix reference = new Array2DRowRealMatrix(testData, false);        assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0);    }    public static final Fraction[][] asFraction(double[][] data) {        Fraction d[][] = new Fraction[data.length][];        try {            for (int i = 0; i < data.length; ++i) {                double[] dataI = data[i];                Fraction[] dI  = new Fraction[dataI.length];                for (int j = 0; j < dataI.length; ++j) {                    dI[j] = new Fraction(dataI[j]);                }                d[i] = dI;            }        } catch (FractionConversionException fce) {            fail(fce.getMessage());        }        return d;    }    public static final Fraction[] asFraction(double[] data) {        Fraction d[] = new Fraction[data.length];        try {            for (int i = 0; i < data.length; ++i) {                d[i] = new Fraction(data[i]);            }        } catch (FractionConversionException fce) {            fail(fce.getMessage());        }        return d;    }    /**     * Verifies that the matrix is an identity matrix     */    @Deprecated    protected void checkIdentityBigMatrix(BigMatrix m) {        for (int i = 0; i < m.getRowDimension(); i++) {            for (int j =0; j < m.getColumnDimension(); j++) {                if (i == j) {                    assertEquals(m.getEntry(i, j), BigMatrixImpl.ONE);                } else {                    assertEquals(m.getEntry(i, j), BigMatrixImpl.ZERO);                }            }        }    }    @Deprecated    public void testCreateBigIdentityMatrix() {        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(3));        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(2));        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(1));        try {            MatrixUtils.createRealIdentityMatrix(0);        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.TestCase;public class LUDecompositionImplTest extends TestCase {    private double[][] testData = {            { 1.0, 2.0, 3.0},            { 2.0, 5.0, 3.0},            { 1.0, 0.0, 8.0}    };    private double[][] testDataMinus = {            { -1.0, -2.0, -3.0},            { -2.0, -5.0, -3.0},            { -1.0,  0.0, -8.0}    };    private double[][] luData = {            { 2.0, 3.0, 3.0 },            { 0.0, 5.0, 7.0 },            { 6.0, 9.0, 8.0 }    };    // singular matrices    private double[][] singular = {            { 2.0, 3.0 },            { 2.0, 3.0 }    };    private double[][] bigSingular = {            { 1.0, 2.0,   3.0,    4.0 },            { 2.0, 5.0,   3.0,    4.0 },            { 7.0, 3.0, 256.0, 1930.0 },            { 3.0, 7.0,   6.0,    8.0 }    }; // 4th row = 1st + 2nd    private static final double entryTolerance = 10e-16;    private static final double normTolerance = 10e-14;    public LUDecompositionImplTest(String name) {        super(name);    }    /** test dimensions */    public void testDimensions() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        LUDecomposition LU = new LUDecompositionImpl(matrix);        assertEquals(testData.length, LU.getL().getRowDimension());        assertEquals(testData.length, LU.getL().getColumnDimension());        assertEquals(testData.length, LU.getU().getRowDimension());        assertEquals(testData.length, LU.getU().getColumnDimension());        assertEquals(testData.length, LU.getP().getRowDimension());        assertEquals(testData.length, LU.getP().getColumnDimension());    }    /** test non-square matrix */    public void testNonSquare() {        try {            new LUDecompositionImpl(MatrixUtils.createRealMatrix(new double[3][2]));        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test PA = LU */    public void testPAEqualLU() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        LUDecomposition lu = new LUDecompositionImpl(matrix);        RealMatrix l = lu.getL();        RealMatrix u = lu.getU();        RealMatrix p = lu.getP();        double norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();        assertEquals(0, norm, normTolerance);        matrix = MatrixUtils.createRealMatrix(testDataMinus);        lu = new LUDecompositionImpl(matrix);        l = lu.getL();        u = lu.getU();        p = lu.getP();        norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();        assertEquals(0, norm, normTolerance);        matrix = MatrixUtils.createRealIdentityMatrix(17);        lu = new LUDecompositionImpl(matrix);        l = lu.getL();        u = lu.getU();        p = lu.getP();        norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();        assertEquals(0, norm, normTolerance);        matrix = MatrixUtils.createRealMatrix(singular);        lu = new LUDecompositionImpl(matrix);        assertFalse(lu.getSolver().isNonSingular());        assertNull(lu.getL());        assertNull(lu.getU());        assertNull(lu.getP());        matrix = MatrixUtils.createRealMatrix(bigSingular);        lu = new LUDecompositionImpl(matrix);        assertFalse(lu.getSolver().isNonSingular());        assertNull(lu.getL());        assertNull(lu.getU());        assertNull(lu.getP());    }    /** test that L is lower triangular with unit diagonal */    public void testLLowerTriangular() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        RealMatrix l = new LUDecompositionImpl(matrix).getL();        for (int i = 0; i < l.getRowDimension(); i++) {            assertEquals(l.getEntry(i, i), 1, entryTolerance);            for (int j = i + 1; j < l.getColumnDimension(); j++) {                assertEquals(l.getEntry(i, j), 0, entryTolerance);            }        }    }    /** test that U is upper triangular */    public void testUUpperTriangular() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        RealMatrix u = new LUDecompositionImpl(matrix).getU();        for (int i = 0; i < u.getRowDimension(); i++) {            for (int j = 0; j < i; j++) {                assertEquals(u.getEntry(i, j), 0, entryTolerance);            }        }    }    /** test that P is a permutation matrix */    public void testPPermutation() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        RealMatrix p   = new LUDecompositionImpl(matrix).getP();        RealMatrix ppT = p.multiply(p.transpose());        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(p.getRowDimension());        assertEquals(0, ppT.subtract(id).getNorm(), normTolerance);        for (int i = 0; i < p.getRowDimension(); i++) {            int zeroCount  = 0;            int oneCount   = 0;            int otherCount = 0;            for (int j = 0; j < p.getColumnDimension(); j++) {                final double e = p.getEntry(i, j);                if (e == 0) {                    ++zeroCount;                } else if (e == 1) {                    ++oneCount;                } else {                    ++otherCount;                }            }            assertEquals(p.getColumnDimension() - 1, zeroCount);            assertEquals(1, oneCount);            assertEquals(0, otherCount);        }        for (int j = 0; j < p.getColumnDimension(); j++) {            int zeroCount  = 0;            int oneCount   = 0;            int otherCount = 0;            for (int i = 0; i < p.getRowDimension(); i++) {                final double e = p.getEntry(i, j);                if (e == 0) {                    ++zeroCount;                } else if (e == 1) {                    ++oneCount;                } else {                    ++otherCount;                }            }            assertEquals(p.getRowDimension() - 1, zeroCount);            assertEquals(1, oneCount);            assertEquals(0, otherCount);        }    }    /** test singular */    public void testSingular() {        LUDecomposition lu =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData));        assertTrue(lu.getSolver().isNonSingular());        lu = new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular));        assertFalse(lu.getSolver().isNonSingular());        lu = new LUDecompositionImpl(MatrixUtils.createRealMatrix(bigSingular));        assertFalse(lu.getSolver().isNonSingular());    }    /** test matrices values */    public void testMatricesValues1() {       LUDecomposition lu =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData));        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {                { 1.0, 0.0, 0.0 },                { 0.5, 1.0, 0.0 },                { 0.5, 0.2, 1.0 }        });        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {                { 2.0,  5.0, 3.0 },                { 0.0, -2.5, 6.5 },                { 0.0,  0.0, 0.2 }        });        RealMatrix pRef = MatrixUtils.createRealMatrix(new double[][] {                { 0.0, 1.0, 0.0 },                { 0.0, 0.0, 1.0 },                { 1.0, 0.0, 0.0 }        });        int[] pivotRef = { 1, 2, 0 };        // check values against known references        RealMatrix l = lu.getL();        assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);        RealMatrix u = lu.getU();        assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);        RealMatrix p = lu.getP();        assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);        int[] pivot = lu.getPivot();        for (int i = 0; i < pivotRef.length; ++i) {            assertEquals(pivotRef[i], pivot[i]);        }        // check the same cached instance is returned the second time        assertTrue(l == lu.getL());        assertTrue(u == lu.getU());        assertTrue(p == lu.getP());    }    /** test matrices values */    public void testMatricesValues2() {       LUDecomposition lu =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(luData));        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {                {    1.0,    0.0, 0.0 },                {    0.0,    1.0, 0.0 },                { 1.0 / 3.0, 0.0, 1.0 }        });        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {                { 6.0, 9.0,    8.0    },                { 0.0, 5.0,    7.0    },                { 0.0, 0.0, 1.0 / 3.0 }        });        RealMatrix pRef = MatrixUtils.createRealMatrix(new double[][] {                { 0.0, 0.0, 1.0 },                { 0.0, 1.0, 0.0 },                { 1.0, 0.0, 0.0 }        });        int[] pivotRef = { 2, 1, 0 };        // check values against known references        RealMatrix l = lu.getL();        assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);        RealMatrix u = lu.getU();        assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);        RealMatrix p = lu.getP();        assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);        int[] pivot = lu.getPivot();        for (int i = 0; i < pivotRef.length; ++i) {            assertEquals(pivotRef[i], pivot[i]);        }        // check the same cached instance is returned the second time        assertTrue(l == lu.getL());        assertTrue(u == lu.getU());        assertTrue(p == lu.getP());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.TestCase;import org.apache.commons.math.Field;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionConversionException;import org.apache.commons.math.fraction.FractionField;/** * Test cases for the {@link SparseFieldMatrix} class. * * @version $Revision$ $Date$ */public class SparseFieldMatrixTest extends TestCase {    // 3 x 3 identity matrix    protected Fraction[][] id = { {new Fraction(1), new Fraction(0), new Fraction(0) }, { new Fraction(0), new Fraction(1), new Fraction(0) }, { new Fraction(0), new Fraction(0), new Fraction(1) } };    // Test data for group operations    protected Fraction[][] testData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) },            { new Fraction(1), new Fraction(0), new Fraction(8) } };    protected Fraction[][] testDataLU = null;    protected Fraction[][] testDataPlus2 = { { new Fraction(3), new Fraction(4), new Fraction(5) }, { new Fraction(4), new Fraction(7), new Fraction(5) },            { new Fraction(3), new Fraction(2), new Fraction(10) } };    protected Fraction[][] testDataMinus = { { new Fraction(-1), new Fraction(-2), new Fraction(-3) },            { new Fraction(-2), new Fraction(-5), new Fraction(-3) }, { new Fraction(-1), new Fraction(0), new Fraction(-8) } };    protected Fraction[] testDataRow1 = { new Fraction(1), new Fraction(2), new Fraction(3) };    protected Fraction[] testDataCol3 = { new Fraction(3), new Fraction(3), new Fraction(8) };    protected Fraction[][] testDataInv = { { new Fraction(-40), new Fraction(16), new Fraction(9) }, { new Fraction(13), new Fraction(-5), new Fraction(-3) },            { new Fraction(5), new Fraction(-2), new Fraction(-1) } };    protected Fraction[] preMultTest = { new Fraction(8), new Fraction(12), new Fraction(33) };    protected Fraction[][] testData2 = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) } };    protected Fraction[][] testData2T = { { new Fraction(1), new Fraction(2) }, { new Fraction(2), new Fraction(5) }, { new Fraction(3), new Fraction(3) } };    protected Fraction[][] testDataPlusInv = { { new Fraction(-39), new Fraction(18), new Fraction(12) },            { new Fraction(15), new Fraction(0), new Fraction(0) }, { new Fraction(6), new Fraction(-2), new Fraction(7) } };    // lu decomposition tests    protected Fraction[][] luData = { { new Fraction(2), new Fraction(3), new Fraction(3) }, { new Fraction(0), new Fraction(5), new Fraction(7) }, { new Fraction(6), new Fraction(9), new Fraction(8) } };    protected Fraction[][] luDataLUDecomposition = null;    // singular matrices    protected Fraction[][] singular = { { new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(3) } };    protected Fraction[][] bigSingular = { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) },            { new Fraction(2), new Fraction(5), new Fraction(3), new Fraction(4) }, { new Fraction(7), new Fraction(3), new Fraction(256), new Fraction(1930) }, { new Fraction(3), new Fraction(7), new Fraction(6), new Fraction(8) } }; // 4th    // row    // =    // 1st    // +    // 2nd    protected Fraction[][] detData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(4), new Fraction(5), new Fraction(6) },            { new Fraction(7), new Fraction(8), new Fraction(10) } };    protected Fraction[][] detData2 = { { new Fraction(1), new Fraction(3) }, { new Fraction(2), new Fraction(4) } };    // vectors    protected Fraction[] testVector = { new Fraction(1), new Fraction(2), new Fraction(3) };    protected Fraction[] testVector2 = { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) };    // submatrix accessor tests    protected Fraction[][] subTestData = null;    // array selections    protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4) }, { new Fraction(4), new Fraction(8) } };    protected Fraction[][] subRows03Cols12 = { { new Fraction(2), new Fraction(3) }, { new Fraction(5), new Fraction(6) } };    protected Fraction[][] subRows03Cols123 = { { new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7) } };    // effective permutations    protected Fraction[][] subRows20Cols123 = { { new Fraction(4), new Fraction(6), new Fraction(8) }, { new Fraction(2), new Fraction(3), new Fraction(4) } };    protected Fraction[][] subRows31Cols31 = null;    // contiguous ranges    protected Fraction[][] subRows01Cols23 = null;    protected Fraction[][] subRows23Cols00 = { { new Fraction(2) }, { new Fraction(4) } };    protected Fraction[][] subRows00Cols33 = { { new Fraction(4) } };    // row matrices    protected Fraction[][] subRow0 = { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) } };    protected Fraction[][] subRow3 = { { new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7) } };    // column matrices    protected Fraction[][] subColumn1 = null;    protected Fraction[][] subColumn3 = null;    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    protected Field<Fraction> field = FractionField.getInstance();    public SparseFieldMatrixTest(String name) {        super(name);        setupFractionArrays();    }    private void setupFractionArrays() {        try {            testDataLU = new Fraction[][]{ { new Fraction(2), new Fraction(5), new Fraction(3) }, { new Fraction(.5d), new Fraction(-2.5d), new Fraction(6.5d) },                    { new Fraction(0.5d), new Fraction(0.2d), new Fraction(.2d) } };            luDataLUDecomposition = new Fraction[][]{ { new Fraction(6), new Fraction(9), new Fraction(8) },                { new Fraction(0), new Fraction(5), new Fraction(7) }, { new Fraction(0.33333333333333), new Fraction(0), new Fraction(0.33333333333333) } };            subTestData = new Fraction [][]{ { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) },                    { new Fraction(1.5), new Fraction(2.5), new Fraction(3.5), new Fraction(4.5) }, { new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8) }, { new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7) } };            subRows31Cols31 = new Fraction[][]{ { new Fraction(7), new Fraction(5) }, { new Fraction(4.5), new Fraction(2.5) } };            subRows01Cols23 = new Fraction[][]{ { new Fraction(3), new Fraction(4) }, { new Fraction(3.5), new Fraction(4.5) } };            subColumn1 = new Fraction [][]{ { new Fraction(2) }, { new Fraction(2.5) }, { new Fraction(4) }, { new Fraction(5) } };            subColumn3 = new Fraction[][]{ { new Fraction(4) }, { new Fraction(4.5) }, { new Fraction(8) }, { new Fraction(7) } };        } catch (FractionConversionException e) {            // ignore, can't happen        }    }    /** test dimensions */    public void testDimensions() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);        assertEquals("testData row dimension", 3, m.getRowDimension());        assertEquals("testData column dimension", 3, m.getColumnDimension());        assertTrue("testData is square", m.isSquare());        assertEquals("testData2 row dimension", m2.getRowDimension(), 2);        assertEquals("testData2 column dimension", m2.getColumnDimension(), 3);        assertTrue("testData2 is not square", !m2.isSquare());    }    /** test copy functions */    public void testCopyFunctions() {        SparseFieldMatrix<Fraction> m1 = createSparseMatrix(testData);        FieldMatrix<Fraction> m2 = m1.copy();        assertEquals(m1.getClass(), m2.getClass());        assertEquals((m2), m1);        SparseFieldMatrix<Fraction> m3 = createSparseMatrix(testData);        FieldMatrix<Fraction> m4 = m3.copy();        assertEquals(m3.getClass(), m4.getClass());        assertEquals((m4), m3);    }    /** test add */    public void testAdd() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv);        SparseFieldMatrix<Fraction> mDataPlusInv = createSparseMatrix(testDataPlusInv);        FieldMatrix<Fraction> mPlusMInv = m.add(mInv);        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                    mDataPlusInv.getEntry(row, col).doubleValue(), mPlusMInv.getEntry(row, col).doubleValue(),                    entryTolerance);            }        }    }    /** test add failure */    public void testAddFail() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);        try {            m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test m-n = m + -n */    public void testPlusMinus() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> n = createSparseMatrix(testDataInv);        assertClose("m-n = m + -n", m.subtract(n),            n.scalarMultiply(new Fraction(-1)).add(m), entryTolerance);        try {            m.subtract(createSparseMatrix(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test multiply */    public void testMultiply() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv);        SparseFieldMatrix<Fraction> identity = createSparseMatrix(id);        SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);        assertClose("inverse multiply", m.multiply(mInv), identity,                entryTolerance);        assertClose("inverse multiply", m.multiply(new Array2DRowFieldMatrix<Fraction>(testDataInv)), identity,                    entryTolerance);        assertClose("inverse multiply", mInv.multiply(m), identity,                entryTolerance);        assertClose("identity multiply", m.multiply(identity), m,                entryTolerance);        assertClose("identity multiply", identity.multiply(mInv), mInv,                entryTolerance);        assertClose("identity multiply", m2.multiply(identity), m2,                entryTolerance);        try {            m.multiply(createSparseMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    // Additional Test for Array2DRowRealMatrixTest.testMultiply    private Fraction[][] d3 = new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8) } };    private Fraction[][] d4 = new Fraction[][] { { new Fraction(1) }, { new Fraction(2) }, { new Fraction(3) }, { new Fraction(4) } };    private Fraction[][] d5 = new Fraction[][] { { new Fraction(30) }, { new Fraction(70) } };    public void testMultiply2() {        FieldMatrix<Fraction> m3 = createSparseMatrix(d3);        FieldMatrix<Fraction> m4 = createSparseMatrix(d4);        FieldMatrix<Fraction> m5 = createSparseMatrix(d5);        assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);    }    /** test trace */    public void testTrace() {        FieldMatrix<Fraction> m = createSparseMatrix(id);        assertEquals("identity trace", 3d, m.getTrace().doubleValue(), entryTolerance);        m = createSparseMatrix(testData2);        try {            m.getTrace();            fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }    }    /** test sclarAdd */    public void testScalarAdd() {        FieldMatrix<Fraction> m = createSparseMatrix(testData);        assertClose("scalar add", createSparseMatrix(testDataPlus2),            m.scalarAdd(new Fraction(2)), entryTolerance);    }    /** test operate */    public void testOperate() {        FieldMatrix<Fraction> m = createSparseMatrix(id);        assertClose("identity operate", testVector, m.operate(testVector),                entryTolerance);        assertClose("identity operate", testVector, m.operate(                new ArrayFieldVector<Fraction>(testVector)).getData(), entryTolerance);        m = createSparseMatrix(bigSingular);        try {            m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test issue MATH-209 */    public void testMath209() {        FieldMatrix<Fraction> a = createSparseMatrix(new Fraction[][] {                { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } });        Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });        assertEquals(a.getRowDimension(), b.length);        assertEquals(3.0, b[0].doubleValue(), 1.0e-12);        assertEquals(7.0, b[1].doubleValue(), 1.0e-12);        assertEquals(11.0, b[2].doubleValue(), 1.0e-12);    }    /** test transpose */    public void testTranspose() {        FieldMatrix<Fraction> m = createSparseMatrix(testData);        FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();        assertClose("inverse-transpose", mIT, mTI, normTolerance);        m = createSparseMatrix(testData2);        FieldMatrix<Fraction> mt = createSparseMatrix(testData2T);        assertClose("transpose",mt,m.transpose(),normTolerance);    }    /** test preMultiply by vector */    public void testPremultiplyVector() {        FieldMatrix<Fraction> m = createSparseMatrix(testData);        assertClose("premultiply", m.preMultiply(testVector), preMultTest,            normTolerance);        assertClose("premultiply", m.preMultiply(            new ArrayFieldVector<Fraction>(testVector).getData()), preMultTest, normTolerance);        m = createSparseMatrix(bigSingular);        try {            m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testPremultiply() {        FieldMatrix<Fraction> m3 = createSparseMatrix(d3);        FieldMatrix<Fraction> m4 = createSparseMatrix(d4);        FieldMatrix<Fraction> m5 = createSparseMatrix(d5);        assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv);        SparseFieldMatrix<Fraction> identity = createSparseMatrix(id);        assertClose("inverse multiply", m.preMultiply(mInv), identity,                entryTolerance);        assertClose("inverse multiply", mInv.preMultiply(m), identity,                entryTolerance);        assertClose("identity multiply", m.preMultiply(identity), m,                entryTolerance);        assertClose("identity multiply", identity.preMultiply(mInv), mInv,                entryTolerance);        try {            m.preMultiply(createSparseMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testGetVectors() {        FieldMatrix<Fraction> m = createSparseMatrix(testData);        assertClose("get row", m.getRow(0), testDataRow1, entryTolerance);        assertClose("get col", m.getColumn(2), testDataCol3, entryTolerance);        try {            m.getRow(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }        try {            m.getColumn(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }    }    public void testGetEntry() {        FieldMatrix<Fraction> m = createSparseMatrix(testData);        assertEquals("get entry", m.getEntry(0, 1).doubleValue(), 2d, entryTolerance);        try {            m.getEntry(10, 4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    /** test examples in user guide */    public void testExamples() {        // Create a real matrix with two rows and three columns        Fraction[][] matrixData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) } };        FieldMatrix<Fraction> m = createSparseMatrix(matrixData);        // One more with three rows, two columns        Fraction[][] matrixData2 = { { new Fraction(1), new Fraction(2) }, { new Fraction(2), new Fraction(5) }, { new Fraction(1), new Fraction(7) } };        FieldMatrix<Fraction> n = createSparseMatrix(matrixData2);        // Now multiply m by n        FieldMatrix<Fraction> p = m.multiply(n);        assertEquals(2, p.getRowDimension());        assertEquals(2, p.getColumnDimension());        // Invert p        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();        assertEquals(2, pInverse.getRowDimension());        assertEquals(2, pInverse.getColumnDimension());        // Solve example        Fraction[][] coefficientsData = { { new Fraction(2), new Fraction(3), new Fraction(-2) }, { new Fraction(-1), new Fraction(7), new Fraction(6) },                { new Fraction(4), new Fraction(-3), new Fraction(-5) } };        FieldMatrix<Fraction> coefficients = createSparseMatrix(coefficientsData);        Fraction[] constants = { new Fraction(1), new Fraction(-2), new Fraction(1) };        Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);        assertEquals((new Fraction(2).multiply((solution[0])).add(new Fraction(3).multiply(solution[1])).subtract(new Fraction(2).multiply(solution[2]))).doubleValue(),                constants[0].doubleValue(), 1E-12);        assertEquals(((new Fraction(-1).multiply(solution[0])).add(new Fraction(7).multiply(solution[1])).add(new Fraction(6).multiply(solution[2]))).doubleValue(),                constants[1].doubleValue(), 1E-12);        assertEquals(((new Fraction(4).multiply(solution[0])).subtract(new Fraction(3).multiply( solution[1])).subtract(new Fraction(5).multiply(solution[2]))).doubleValue(),                constants[2].doubleValue(), 1E-12);    }    // test submatrix accessors    public void testSubMatrix() {        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);        FieldMatrix<Fraction> mRows23Cols00 = createSparseMatrix(subRows23Cols00);        FieldMatrix<Fraction> mRows00Cols33 = createSparseMatrix(subRows00Cols33);        FieldMatrix<Fraction> mRows01Cols23 = createSparseMatrix(subRows01Cols23);        FieldMatrix<Fraction> mRows02Cols13 = createSparseMatrix(subRows02Cols13);        FieldMatrix<Fraction> mRows03Cols12 = createSparseMatrix(subRows03Cols12);        FieldMatrix<Fraction> mRows03Cols123 = createSparseMatrix(subRows03Cols123);        FieldMatrix<Fraction> mRows20Cols123 = createSparseMatrix(subRows20Cols123);        FieldMatrix<Fraction> mRows31Cols31 = createSparseMatrix(subRows31Cols31);        assertEquals("Rows23Cols00", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));        assertEquals("Rows00Cols33", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));        assertEquals("Rows01Cols23", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));        assertEquals("Rows02Cols13", mRows02Cols13,            m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 }));        assertEquals("Rows03Cols12", mRows03Cols12,            m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 }));        assertEquals("Rows03Cols123", mRows03Cols123,            m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 }));        assertEquals("Rows20Cols123", mRows20Cols123,            m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 }));        assertEquals("Rows31Cols31", mRows31Cols31,            m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));        assertEquals("Rows31Cols31", mRows31Cols31,            m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));        try {            m.getSubMatrix(1, 0, 2, 4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(-1, 1, 2, 2);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(1, 0, 2, 2);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(1, 0, 2, 4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(new int[] {}, new int[] { 0 });            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getSubMatrix(new int[] { 0 }, new int[] { 4 });            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetRowMatrix() {        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);        FieldMatrix<Fraction> mRow0 = createSparseMatrix(subRow0);        FieldMatrix<Fraction> mRow3 = createSparseMatrix(subRow3);        assertEquals("Row0", mRow0, m.getRowMatrix(0));        assertEquals("Row3", mRow3, m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetColumnMatrix() {        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);        FieldMatrix<Fraction> mColumn1 = createSparseMatrix(subColumn1);        FieldMatrix<Fraction> mColumn3 = createSparseMatrix(subColumn3);        assertEquals("Column1", mColumn1, m.getColumnMatrix(1));        assertEquals("Column3", mColumn3, m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetRowVector() {        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);        FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);        assertEquals("Row0", mRow0, m.getRowVector(0));        assertEquals("Row3", mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testGetColumnVector() {        FieldMatrix<Fraction> m = createSparseMatrix(subTestData);        FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);        assertEquals("Column1", mColumn1, m.getColumnVector(1));        assertEquals("Column3", mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    private FieldVector<Fraction> columnToVector(Fraction[][] column) {        Fraction[] data = new Fraction[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayFieldVector<Fraction>(data, false);    }    public void testEqualsAndHashCode() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        SparseFieldMatrix<Fraction> m1 = (SparseFieldMatrix<Fraction>) m.copy();        SparseFieldMatrix<Fraction> mt = (SparseFieldMatrix<Fraction>) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(createSparseMatrix(bigSingular)));    }    /* Disable for now    public void testToString() {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        assertEquals("SparseFieldMatrix<Fraction>{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",            m.toString());        m = new SparseFieldMatrix<Fraction>(field, 1, 1);        assertEquals("SparseFieldMatrix<Fraction>{{0.0}}", m.toString());    }    */    public void testSetSubMatrix() throws Exception {        SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);        m.setSubMatrix(detData2, 1, 1);        FieldMatrix<Fraction> expected = createSparseMatrix(new Fraction[][] {                { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(1), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } });        assertEquals(expected, m);        m.setSubMatrix(detData2, 0, 0);        expected = createSparseMatrix(new Fraction[][] {                { new Fraction(1), new Fraction(3), new Fraction(3) }, { new Fraction(2), new Fraction(4), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } });        assertEquals(expected, m);        m.setSubMatrix(testDataPlus2, 0, 0);        expected = createSparseMatrix(new Fraction[][] {                { new Fraction(3), new Fraction(4), new Fraction(5) }, { new Fraction(4), new Fraction(7), new Fraction(5) }, { new Fraction(3), new Fraction(2), new Fraction(10) } });        assertEquals(expected, m);        // javadoc example        SparseFieldMatrix<Fraction> matrix =            createSparseMatrix(new Fraction[][] {        { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8) }, { new Fraction(9), new Fraction(0), new Fraction(1), new Fraction(2) } });        matrix.setSubMatrix(new Fraction[][] { { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } }, 1, 1);        expected = createSparseMatrix(new Fraction[][] {                { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8) }, { new Fraction(9), new Fraction(5), new Fraction(6), new Fraction(2) } });        assertEquals(expected, matrix);        // dimension overflow        try {            m.setSubMatrix(testData, 1, 1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // dimension underflow        try {            m.setSubMatrix(testData, -1, 1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        try {            m.setSubMatrix(testData, 1, -1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // null        try {            m.setSubMatrix(null, 1, 1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }        try {            new SparseFieldMatrix<Fraction>(field, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }        // ragged        try {            m.setSubMatrix(new Fraction[][] { { new Fraction(1) }, { new Fraction(2), new Fraction(3) } }, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }        // empty        try {            m.setSubMatrix(new Fraction[][] { {} }, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }    }    // --------------- -----------------Protected methods    /** verifies that two matrices are close (1-norm) */    protected void assertClose(String msg, FieldMatrix<Fraction> m, FieldMatrix<Fraction> n,            double tolerance) {        for(int i=0; i < m.getRowDimension(); i++){            for(int j=0; j < m.getColumnDimension(); j++){                assertEquals(msg, m.getEntry(i,j).doubleValue(), n.getEntry(i,j).doubleValue(), tolerance);            }        }    }    /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, Fraction[] m, Fraction[] n,            double tolerance) {        if (m.length != n.length) {            fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " + i + " elements differ", m[i].doubleValue(), n[i].doubleValue(),                    tolerance);        }    }    private SparseFieldMatrix<Fraction> createSparseMatrix(Fraction[][] data) {        SparseFieldMatrix<Fraction> matrix = new SparseFieldMatrix<Fraction>(field, data.length, data[0].length);        for (int row = 0; row < data.length; row++) {            for (int col = 0; col < data[row].length; col++) {                matrix.setEntry(row, col, data[row][col]);            }        }        return matrix;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Arrays;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;public class TriDiagonalTransformerTest extends TestCase {    private double[][] testSquare5 = {            { 1, 2, 3, 1, 1 },            { 2, 1, 1, 3, 1 },            { 3, 1, 1, 1, 2 },            { 1, 3, 1, 2, 1 },            { 1, 1, 2, 1, 3 }    };    private double[][] testSquare3 = {            { 1, 3, 4 },            { 3, 2, 2 },            { 4, 2, 0 }    };    public TriDiagonalTransformerTest(String name) {        super(name);    }    public void testNonSquare() {        try {            new TriDiagonalTransformer(MatrixUtils.createRealMatrix(new double[3][2]));            fail("an exception should have been thrown");        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testAEqualQTQt() {        checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare5));        checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare3));    }    private void checkAEqualQTQt(RealMatrix matrix) {        TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);        RealMatrix q  = transformer.getQ();        RealMatrix qT = transformer.getQT();        RealMatrix t  = transformer.getT();        double norm = q.multiply(t).multiply(qT).subtract(matrix).getNorm();        assertEquals(0, norm, 4.0e-15);    }    public void testNoAccessBelowDiagonal() {        checkNoAccessBelowDiagonal(testSquare5);        checkNoAccessBelowDiagonal(testSquare3);    }    private void checkNoAccessBelowDiagonal(double[][] data) {        double[][] modifiedData = new double[data.length][];        for (int i = 0; i < data.length; ++i) {            modifiedData[i] = data[i].clone();            Arrays.fill(modifiedData[i], 0, i, Double.NaN);        }        RealMatrix matrix = MatrixUtils.createRealMatrix(modifiedData);        TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);        RealMatrix q  = transformer.getQ();        RealMatrix qT = transformer.getQT();        RealMatrix t  = transformer.getT();        double norm = q.multiply(t).multiply(qT).subtract(MatrixUtils.createRealMatrix(data)).getNorm();        assertEquals(0, norm, 4.0e-15);    }    public void testQOrthogonal() {        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQ());        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQ());    }    public void testQTOrthogonal() {        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQT());        checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQT());    }    private void checkOrthogonal(RealMatrix m) {        RealMatrix mTm = m.transpose().multiply(m);        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());        assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-15);    }    public void testTTriDiagonal() {        checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getT());        checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getT());    }    private void checkTriDiagonal(RealMatrix m) {        final int rows = m.getRowDimension();        final int cols = m.getColumnDimension();        for (int i = 0; i < rows; ++i) {            for (int j = 0; j < cols; ++j) {                if ((i < j - 1) || (i > j + 1)) {                    assertEquals(0, m.getEntry(i, j), 1.0e-16);                }            }        }    }    public void testMatricesValues5() {        checkMatricesValues(testSquare5,                            new double[][] {                                { 1.0,  0.0,                 0.0,                  0.0,                   0.0 },                                { 0.0, -0.5163977794943222,  0.016748280772542083, 0.839800693771262,     0.16669620021405473 },                                { 0.0, -0.7745966692414833, -0.4354553000860955,  -0.44989322880603355,  -0.08930153582895772 },                                { 0.0, -0.2581988897471611,  0.6364346693566014,  -0.30263204032131164,   0.6608313651342882 },                                { 0.0, -0.2581988897471611,  0.6364346693566009,  -0.027289660803112598, -0.7263191580755246 }                            },                            new double[] { 1, 4.4, 1.433099579242636, -0.89537362758743, 2.062274048344794 },                            new double[] { -FastMath.sqrt(15), -3.0832882879592476, 0.6082710842351517, 1.1786086405912128 });    }    public void testMatricesValues3() {        checkMatricesValues(testSquare3,                            new double[][] {                                {  1.0,  0.0,  0.0 },                                {  0.0, -0.6,  0.8 },                                {  0.0, -0.8, -0.6 },                            },                            new double[] { 1, 2.64, -0.64 },                            new double[] { -5, -1.52 });    }    private void checkMatricesValues(double[][] matrix, double[][] qRef,                                     double[] mainDiagnonal,                                     double[] secondaryDiagonal) {        TriDiagonalTransformer transformer =            new TriDiagonalTransformer(MatrixUtils.createRealMatrix(matrix));        // check values against known references        RealMatrix q = transformer.getQ();        assertEquals(0, q.subtract(MatrixUtils.createRealMatrix(qRef)).getNorm(), 1.0e-14);        RealMatrix t = transformer.getT();        double[][] tData = new double[mainDiagnonal.length][mainDiagnonal.length];        for (int i = 0; i < mainDiagnonal.length; ++i) {            tData[i][i] = mainDiagnonal[i];            if (i > 0) {                tData[i][i - 1] = secondaryDiagonal[i - 1];            }            if (i < secondaryDiagonal.length) {                tData[i][i + 1] = secondaryDiagonal[i];            }        }        assertEquals(0, t.subtract(MatrixUtils.createRealMatrix(tData)).getNorm(), 1.0e-14);        // check the same cached instance is returned the second time        assertTrue(q == transformer.getQ());        assertTrue(t == transformer.getT());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Arrays;import java.util.Random;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.MatrixDimensionMismatchException;/** * Test cases for the {@link BlockRealMatrix} class. * * @version $Revision$ $Date$ */public final class BlockRealMatrixTest extends TestCase {    // 3 x 3 identity matrix    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };    // Test data for group operations    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},       {-1d,0d,-8d} };    protected double[] testDataRow1 = {1d,2d,3d};    protected double[] testDataCol3 = {3d,3d,8d};    protected double[][] testDataInv =        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };    protected double[] preMultTest = {8,12,33};    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};    protected double[][] testDataPlusInv =        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };    // lu decomposition tests    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},            {0.33333333333333,0d,0.33333333333333} };    // singular matrices    protected double[][] singular = { {2d,3d}, {2d,3d} };    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};    // vectors    protected double[] testVector = {1,2,3};    protected double[] testVector2 = {1,2,3,4};    // submatrix accessor tests    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},            {2, 4, 6, 8}, {4, 5, 6, 7}};    // array selections    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};    // effective permutations    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};    // contiguous ranges    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};    protected double[][] subRows23Cols00 = {{2} , {4}};    protected double[][] subRows00Cols33 = {{4}};    // row matrices    protected double[][] subRow0 = {{1,2,3,4}};    protected double[][] subRow3 = {{4,5,6,7}};    // column matrices    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    public BlockRealMatrixTest(String name) {        super(name);    }    /** test dimensions */    public void testDimensions() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m2 = new BlockRealMatrix(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());    }    /** test copy functions */    public void testCopyFunctions() {        Random r = new Random(66636328996002l);        BlockRealMatrix m1 = createRandomMatrix(r, 47, 83);        BlockRealMatrix m2 = new BlockRealMatrix(m1.getData());        assertEquals(m1, m2);        BlockRealMatrix m3 = new BlockRealMatrix(testData);        BlockRealMatrix m4 = new BlockRealMatrix(m3.getData());        assertEquals(m3, m4);    }    /** test add */    public void testAdd() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);        RealMatrix mPlusMInv = m.add(mInv);        double[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                    testDataPlusInv[row][col],sumEntries[row][col],                        entryTolerance);            }        }    }    /** test add failure */    public void testAddFail() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m2 = new BlockRealMatrix(testData2);        try {            m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test norm */    public void testNorm() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m2 = new BlockRealMatrix(testData2);        assertEquals("testData norm",14d,m.getNorm(),entryTolerance);        assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);    }    /** test Frobenius norm */    public void testFrobeniusNorm() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m2 = new BlockRealMatrix(testData2);        assertEquals("testData Frobenius norm", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);        assertEquals("testData2 Frobenius norm", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);    }     /** test m-n = m + -n */    public void testPlusMinus() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m2 = new BlockRealMatrix(testDataInv);        assertClose(m.subtract(m2), m2.scalarMultiply(-1d).add(m), entryTolerance);        try {            m.subtract(new BlockRealMatrix(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test multiply */     public void testMultiply() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);        BlockRealMatrix identity = new BlockRealMatrix(id);        BlockRealMatrix m2 = new BlockRealMatrix(testData2);        assertClose(m.multiply(mInv), identity, entryTolerance);        assertClose(mInv.multiply(m), identity, entryTolerance);        assertClose(m.multiply(identity), m, entryTolerance);        assertClose(identity.multiply(mInv), mInv, entryTolerance);        assertClose(m2.multiply(identity), m2, entryTolerance);        try {            m.multiply(new BlockRealMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testSeveralBlocks() {        RealMatrix m = new BlockRealMatrix(35, 71);        for (int i = 0; i < m.getRowDimension(); ++i) {            for (int j = 0; j < m.getColumnDimension(); ++j) {                m.setEntry(i, j, i + j / 1024.0);            }        }        RealMatrix mT = m.transpose();        assertEquals(m.getRowDimension(), mT.getColumnDimension());        assertEquals(m.getColumnDimension(), mT.getRowDimension());        for (int i = 0; i < mT.getRowDimension(); ++i) {            for (int j = 0; j < mT.getColumnDimension(); ++j) {                assertEquals(m.getEntry(j, i), mT.getEntry(i, j), 0);            }        }        RealMatrix mPm = m.add(m);        for (int i = 0; i < mPm.getRowDimension(); ++i) {            for (int j = 0; j < mPm.getColumnDimension(); ++j) {                assertEquals(2 * m.getEntry(i, j), mPm.getEntry(i, j), 0);            }        }        RealMatrix mPmMm = mPm.subtract(m);        for (int i = 0; i < mPmMm.getRowDimension(); ++i) {            for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {                assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j), 0);            }        }        RealMatrix mTm = mT.multiply(m);        for (int i = 0; i < mTm.getRowDimension(); ++i) {            for (int j = 0; j < mTm.getColumnDimension(); ++j) {                double sum = 0;                for (int k = 0; k < mT.getColumnDimension(); ++k) {                    sum += (k + i / 1024.0) * (k + j / 1024.0);                }                assertEquals(sum, mTm.getEntry(i, j), 0);            }        }        RealMatrix mmT = m.multiply(mT);        for (int i = 0; i < mmT.getRowDimension(); ++i) {            for (int j = 0; j < mmT.getColumnDimension(); ++j) {                double sum = 0;                for (int k = 0; k < m.getColumnDimension(); ++k) {                    sum += (i + k / 1024.0) * (j + k / 1024.0);                }                assertEquals(sum, mmT.getEntry(i, j), 0);            }        }        RealMatrix sub1 = m.getSubMatrix(2, 9, 5, 20);        for (int i = 0; i < sub1.getRowDimension(); ++i) {            for (int j = 0; j < sub1.getColumnDimension(); ++j) {                assertEquals((i + 2) + (j + 5) / 1024.0, sub1.getEntry(i, j), 0);            }        }        RealMatrix sub2 = m.getSubMatrix(10, 12, 3, 70);        for (int i = 0; i < sub2.getRowDimension(); ++i) {            for (int j = 0; j < sub2.getColumnDimension(); ++j) {                assertEquals((i + 10) + (j + 3) / 1024.0, sub2.getEntry(i, j), 0);            }        }        RealMatrix sub3 = m.getSubMatrix(30, 34, 0, 5);        for (int i = 0; i < sub3.getRowDimension(); ++i) {            for (int j = 0; j < sub3.getColumnDimension(); ++j) {                assertEquals((i + 30) + (j + 0) / 1024.0, sub3.getEntry(i, j), 0);            }        }        RealMatrix sub4 = m.getSubMatrix(30, 32, 62, 65);        for (int i = 0; i < sub4.getRowDimension(); ++i) {            for (int j = 0; j < sub4.getColumnDimension(); ++j) {                assertEquals((i + 30) + (j + 62) / 1024.0, sub4.getEntry(i, j), 0);            }        }    }    //Additional Test for BlockRealMatrixTest.testMultiply    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};    private double[][] d4 = new double[][] {{1},{2},{3},{4}};    private double[][] d5 = new double[][] {{30},{70}};    public void testMultiply2() {       RealMatrix m3 = new BlockRealMatrix(d3);       RealMatrix m4 = new BlockRealMatrix(d4);       RealMatrix m5 = new BlockRealMatrix(d5);       assertClose(m3.multiply(m4), m5, entryTolerance);   }    /** test trace */    public void testTrace() {        RealMatrix m = new BlockRealMatrix(id);        assertEquals("identity trace",3d,m.getTrace(),entryTolerance);        m = new BlockRealMatrix(testData2);        try {            m.getTrace();            fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }    }    /** test scalarAdd */    public void testScalarAdd() {        RealMatrix m = new BlockRealMatrix(testData);        assertClose(new BlockRealMatrix(testDataPlus2), m.scalarAdd(2d), entryTolerance);    }    /** test operate */    public void testOperate() {        RealMatrix m = new BlockRealMatrix(id);        assertClose(testVector, m.operate(testVector), entryTolerance);        assertClose(testVector, m.operate(new ArrayRealVector(testVector)).getData(), entryTolerance);        m = new BlockRealMatrix(bigSingular);        try {            m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testOperateLarge() {        int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2;        int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2;        int r =  3 * BlockRealMatrix.BLOCK_SIZE;        Random random = new Random(111007463902334l);        RealMatrix m1 = createRandomMatrix(random, p, q);        RealMatrix m2 = createRandomMatrix(random, q, r);        RealMatrix m1m2 = m1.multiply(m2);        for (int i = 0; i < r; ++i) {            checkArrays(m1m2.getColumn(i), m1.operate(m2.getColumn(i)));        }    }    public void testOperatePremultiplyLarge() {        int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2;        int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2;        int r =  3 * BlockRealMatrix.BLOCK_SIZE;        Random random = new Random(111007463902334l);        RealMatrix m1 = createRandomMatrix(random, p, q);        RealMatrix m2 = createRandomMatrix(random, q, r);        RealMatrix m1m2 = m1.multiply(m2);        for (int i = 0; i < p; ++i) {            checkArrays(m1m2.getRow(i), m2.preMultiply(m1.getRow(i)));        }    }    /** test issue MATH-209 */    public void testMath209() {        RealMatrix a = new BlockRealMatrix(new double[][] {                { 1, 2 }, { 3, 4 }, { 5, 6 }        });        double[] b = a.operate(new double[] { 1, 1 });        assertEquals(a.getRowDimension(), b.length);        assertEquals( 3.0, b[0], 1.0e-12);        assertEquals( 7.0, b[1], 1.0e-12);        assertEquals(11.0, b[2], 1.0e-12);    }    /** test transpose */    public void testTranspose() {        RealMatrix m = new BlockRealMatrix(testData);        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();        assertClose(mIT, mTI, normTolerance);        m = new BlockRealMatrix(testData2);        RealMatrix mt = new BlockRealMatrix(testData2T);        assertClose(mt, m.transpose(), normTolerance);    }    /** test preMultiply by vector */    public void testPremultiplyVector() {        RealMatrix m = new BlockRealMatrix(testData);        assertClose(m.preMultiply(testVector), preMultTest, normTolerance);        assertClose(m.preMultiply(new ArrayRealVector(testVector).getData()),                    preMultTest, normTolerance);        m = new BlockRealMatrix(bigSingular);        try {            m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testPremultiply() {        RealMatrix m3 = new BlockRealMatrix(d3);        RealMatrix m4 = new BlockRealMatrix(d4);        RealMatrix m5 = new BlockRealMatrix(d5);        assertClose(m4.preMultiply(m3), m5, entryTolerance);        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);        BlockRealMatrix identity = new BlockRealMatrix(id);        assertClose(m.preMultiply(mInv), identity, entryTolerance);        assertClose(mInv.preMultiply(m), identity, entryTolerance);        assertClose(m.preMultiply(identity), m, entryTolerance);        assertClose(identity.preMultiply(mInv), mInv, entryTolerance);        try {            m.preMultiply(new BlockRealMatrix(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testGetVectors() {        RealMatrix m = new BlockRealMatrix(testData);        assertClose(m.getRow(0), testDataRow1, entryTolerance);        assertClose(m.getColumn(2), testDataCol3, entryTolerance);        try {            m.getRow(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }        try {            m.getColumn(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }    }    public void testGetEntry() {        RealMatrix m = new BlockRealMatrix(testData);        assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance);        try {            m.getEntry(10, 4);            fail ("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    /** test examples in user guide */    public void testExamples() {        // Create a real matrix with two rows and three columns        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};        RealMatrix m = new BlockRealMatrix(matrixData);        // One more with three rows, two columns        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};        RealMatrix n = new BlockRealMatrix(matrixData2);        // Now multiply m by n        RealMatrix p = m.multiply(n);        assertEquals(2, p.getRowDimension());        assertEquals(2, p.getColumnDimension());        // Invert p        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();        assertEquals(2, pInverse.getRowDimension());        assertEquals(2, pInverse.getColumnDimension());        // Solve example        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};        RealMatrix coefficients = new BlockRealMatrix(coefficientsData);        double[] constants = {1, -2, 1};        double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);    }    // test submatrix accessors    public void testGetSubMatrix() {        RealMatrix m = new BlockRealMatrix(subTestData);        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkGetSubMatrix(m, null,  1, 0, 2, 4);        checkGetSubMatrix(m, null, -1, 1, 2, 2);        checkGetSubMatrix(m, null,  1, 0, 2, 2);        checkGetSubMatrix(m, null,  1, 0, 2, 4);        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 });        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 });    }    private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int startRow, int endRow, int startColumn, int endColumn) {        try {            RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);            if (reference != null) {                assertEquals(new BlockRealMatrix(reference), sub);            } else {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (reference != null) {                throw e;            }        }    }    private void checkGetSubMatrix(RealMatrix m, double[][] reference,                                   int[] selectedRows, int[] selectedColumns) {        try {            RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);            if (reference != null) {                assertEquals(new BlockRealMatrix(reference), sub);            } else {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (reference != null) {                throw e;            }        }    }    public void testGetSetMatrixLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        RealMatrix sub = new BlockRealMatrix(n - 4, n - 4).scalarAdd(1);        m.setSubMatrix(sub.getData(), 2, 2);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));    }    public void testCopySubMatrix() {        RealMatrix m = new BlockRealMatrix(subTestData);        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkCopy(m, null,  1, 0, 2, 4);        checkCopy(m, null, -1, 1, 2, 2);        checkCopy(m, null,  1, 0, 2, 2);        checkCopy(m, null,  1, 0, 2, 4);        checkCopy(m, null, new int[] {},    new int[] { 0 });        checkCopy(m, null, new int[] { 0 }, new int[] { 4 });    }    private void checkCopy(RealMatrix m, double[][] reference,                           int startRow, int endRow, int startColumn, int endColumn) {        try {            double[][] sub = (reference == null) ?                             new double[1][1] :                             new double[reference.length][reference[0].length];            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);            if (reference != null) {                assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));            } else {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (reference != null) {                throw e;            }        }    }    private void checkCopy(RealMatrix m, double[][] reference,                           int[] selectedRows, int[] selectedColumns) {        try {            double[][] sub = (reference == null) ?                    new double[1][1] :                    new double[reference.length][reference[0].length];            m.copySubMatrix(selectedRows, selectedColumns, sub);            if (reference != null) {                assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));            } else {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (reference != null) {                throw e;            }        }    }    public void testGetRowMatrix() {        RealMatrix m     = new BlockRealMatrix(subTestData);        RealMatrix mRow0 = new BlockRealMatrix(subRow0);        RealMatrix mRow3 = new BlockRealMatrix(subRow3);        assertEquals("Row0", mRow0, m.getRowMatrix(0));        assertEquals("Row3", mRow3, m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowMatrix() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealMatrix mRow3 = new BlockRealMatrix(subRow3);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowMatrix(0, mRow3);        assertEquals(mRow3, m.getRowMatrix(0));        try {            m.setRowMatrix(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowMatrix(0, m);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetSetRowMatrixLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        RealMatrix sub = new BlockRealMatrix(1, n).scalarAdd(1);        m.setRowMatrix(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        assertEquals(sub, m.getRowMatrix(2));    }    public void testGetColumnMatrix() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealMatrix mColumn1 = new BlockRealMatrix(subColumn1);        RealMatrix mColumn3 = new BlockRealMatrix(subColumn3);        assertEquals(mColumn1, m.getColumnMatrix(1));        assertEquals(mColumn3, m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnMatrix() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealMatrix mColumn3 = new BlockRealMatrix(subColumn3);        assertNotSame(mColumn3, m.getColumnMatrix(1));        m.setColumnMatrix(1, mColumn3);        assertEquals(mColumn3, m.getColumnMatrix(1));        try {            m.setColumnMatrix(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnMatrix(0, m);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetSetColumnMatrixLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        RealMatrix sub = new BlockRealMatrix(n, 1).scalarAdd(1);        m.setColumnMatrix(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        assertEquals(sub, m.getColumnMatrix(2));    }    public void testGetRowVector() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealVector mRow0 = new ArrayRealVector(subRow0[0]);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        assertEquals(mRow0, m.getRowVector(0));        assertEquals(mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowVector() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealVector mRow3 = new ArrayRealVector(subRow3[0]);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowVector(0, mRow3);        assertEquals(mRow3, m.getRowVector(0));        try {            m.setRowVector(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowVector(0, new ArrayRealVector(5));            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetSetRowVectorLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        RealVector sub = new ArrayRealVector(n, 1.0);        m.setRowVector(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        assertEquals(sub, m.getRowVector(2));    }    public void testGetColumnVector() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealVector mColumn1 = columnToVector(subColumn1);        RealVector mColumn3 = columnToVector(subColumn3);        assertEquals(mColumn1, m.getColumnVector(1));        assertEquals(mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnVector() {        RealMatrix m = new BlockRealMatrix(subTestData);        RealVector mColumn3 = columnToVector(subColumn3);        assertNotSame(mColumn3, m.getColumnVector(1));        m.setColumnVector(1, mColumn3);        assertEquals(mColumn3, m.getColumnVector(1));        try {            m.setColumnVector(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnVector(0, new ArrayRealVector(5));            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetSetColumnVectorLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        RealVector sub = new ArrayRealVector(n, 1.0);        m.setColumnVector(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        assertEquals(sub, m.getColumnVector(2));    }    private RealVector columnToVector(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayRealVector(data, false);    }    public void testGetRow() {        RealMatrix m = new BlockRealMatrix(subTestData);        checkArrays(subRow0[0], m.getRow(0));        checkArrays(subRow3[0], m.getRow(3));        try {            m.getRow(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRow(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRow() {        RealMatrix m = new BlockRealMatrix(subTestData);        assertTrue(subRow3[0][0] != m.getRow(0)[0]);        m.setRow(0, subRow3[0]);        checkArrays(subRow3[0], m.getRow(0));        try {            m.setRow(-1, subRow3[0]);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRow(0, new double[5]);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetSetRowLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        double[] sub = new double[n];        Arrays.fill(sub, 1.0);        m.setRow(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (i != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        checkArrays(sub, m.getRow(2));    }    public void testGetColumn() {        RealMatrix m = new BlockRealMatrix(subTestData);        double[] mColumn1 = columnToArray(subColumn1);        double[] mColumn3 = columnToArray(subColumn3);        checkArrays(mColumn1, m.getColumn(1));        checkArrays(mColumn3, m.getColumn(3));        try {            m.getColumn(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumn(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumn() {        RealMatrix m = new BlockRealMatrix(subTestData);        double[] mColumn3 = columnToArray(subColumn3);        assertTrue(mColumn3[0] != m.getColumn(1)[0]);        m.setColumn(1, mColumn3);        checkArrays(mColumn3, m.getColumn(1));        try {            m.setColumn(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumn(0, new double[5]);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetSetColumnLarge() {        int n = 3 * BlockRealMatrix.BLOCK_SIZE;        RealMatrix m = new BlockRealMatrix(n, n);        double[] sub = new double[n];        Arrays.fill(sub, 1.0);        m.setColumn(2, sub);        for (int i = 0; i < n; ++i) {            for (int j = 0; j < n; ++j) {                if (j != 2) {                    assertEquals(0.0, m.getEntry(i, j), 0.0);                } else {                    assertEquals(1.0, m.getEntry(i, j), 0.0);                }            }        }        checkArrays(sub, m.getColumn(2));    }    private double[] columnToArray(double[][] column) {        double[] data = new double[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return data;    }    private void checkArrays(double[] expected, double[] actual) {        assertEquals(expected.length, actual.length);        for (int i = 0; i < expected.length; ++i) {            assertEquals(expected[i], actual[i]);        }    }    public void testEqualsAndHashCode() {        BlockRealMatrix m = new BlockRealMatrix(testData);        BlockRealMatrix m1 = m.copy();        BlockRealMatrix mt = m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(new BlockRealMatrix(bigSingular)));    }    public void testToString() {        BlockRealMatrix m = new BlockRealMatrix(testData);        assertEquals("BlockRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}",                m.toString());    }    public void testSetSubMatrix() throws Exception {        BlockRealMatrix m = new BlockRealMatrix(testData);        m.setSubMatrix(detData2,1,1);        RealMatrix expected = new BlockRealMatrix            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);        m.setSubMatrix(detData2,0,0);        expected = new BlockRealMatrix            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});        assertEquals(expected, m);        m.setSubMatrix(testDataPlus2,0,0);        expected = new BlockRealMatrix            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});        assertEquals(expected, m);        // javadoc example        BlockRealMatrix matrix = new BlockRealMatrix            (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});        matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1);        expected = new BlockRealMatrix            (new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}});        assertEquals(expected, matrix);        // dimension overflow        try {            m.setSubMatrix(testData,1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // dimension underflow        try {            m.setSubMatrix(testData,-1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        try {            m.setSubMatrix(testData,1,-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // null        try {            m.setSubMatrix(null,1,1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }        // ragged        try {            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }        // empty        try {            m.setSubMatrix(new double[][] {{}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }    }    public void testWalk() {        int rows    = 150;        int columns = 75;        RealMatrix m = new BlockRealMatrix(rows, columns);        m.walkInRowOrder(new SetVisitor());        GetVisitor getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new BlockRealMatrix(rows, columns);        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);            assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);            assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new BlockRealMatrix(rows, columns);        m.walkInColumnOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new BlockRealMatrix(rows, columns);        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);            assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);            assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new BlockRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new BlockRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);            assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);            assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }        m = new BlockRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new BlockRealMatrix(rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(0.0, m.getEntry(i, 0), 0);            assertEquals(0.0, m.getEntry(i, columns - 1), 0);        }        for (int j = 0; j < columns; ++j) {            assertEquals(0.0, m.getEntry(0, j), 0);            assertEquals(0.0, m.getEntry(rows - 1, j), 0);        }    }    public void testSerial()  {        BlockRealMatrix m = new BlockRealMatrix(testData);        assertEquals(m,TestUtils.serializeAndRecover(m));    }    private static class SetVisitor extends DefaultRealMatrixChangingVisitor {        @Override        public double visit(int i, int j, double value) {            return i + j / 1024.0;        }    }    private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {        private int count = 0;        @Override        public void visit(int i, int j, double value) {            ++count;            assertEquals(i + j / 1024.0, value, 0.0);        }        public int getCount() {            return count;        }    }    //--------------- -----------------Protected methods    /** verifies that two matrices are close (1-norm) */    protected void assertClose(RealMatrix m, RealMatrix n, double tolerance) {        assertTrue(m.subtract(n).getNorm() < tolerance);    }    /** verifies that two vectors are close (sup norm) */    protected void assertClose(double[] m, double[] n, double tolerance) {        if (m.length != n.length) {            fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            assertEquals(m[i], n[i], tolerance);        }    }    private BlockRealMatrix createRandomMatrix(Random r, int rows, int columns) {        BlockRealMatrix m = new BlockRealMatrix(rows, columns);        for (int i = 0; i < rows; ++i) {            for (int j = 0; j < columns; ++j) {                m.setEntry(i, j, 200 * r.nextDouble() - 100);            }        }        return m;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.io.Serializable;import java.lang.reflect.Array;import junit.framework.TestCase;import org.apache.commons.math.Field;import org.apache.commons.math.FieldElement;import org.apache.commons.math.TestUtils;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionField;/** * Test cases for the {@link ArrayFieldVector} class. * * @version $Revision$ $Date$ */public class ArrayFieldVectorTest extends TestCase {    //    protected Fraction[][] ma1 = {            {new Fraction(1), new Fraction(2), new Fraction(3)},            {new Fraction(4), new Fraction(5), new Fraction(6)},            {new Fraction(7), new Fraction(8), new Fraction(9)}    };    protected Fraction[] vec1 = {new Fraction(1), new Fraction(2), new Fraction(3)};    protected Fraction[] vec2 = {new Fraction(4), new Fraction(5), new Fraction(6)};    protected Fraction[] vec3 = {new Fraction(7), new Fraction(8), new Fraction(9)};    protected Fraction[] vec4 = { new Fraction(1), new Fraction(2), new Fraction(3),                                  new Fraction(4), new Fraction(5), new Fraction(6),                                  new Fraction(7), new Fraction(8), new Fraction(9)};    protected Fraction[] vec_null = {new Fraction(0), new Fraction(0), new Fraction(0)};    protected Fraction[] dvec1 = {new Fraction(1), new Fraction(2), new Fraction(3),                                  new Fraction(4), new Fraction(5), new Fraction(6),                                  new Fraction(7), new Fraction(8), new Fraction(9)};    protected Fraction[][] mat1 = {            {new Fraction(1), new Fraction(2), new Fraction(3)},            {new Fraction(4), new Fraction(5), new Fraction(6)},            {new Fraction(7), new Fraction(8), new Fraction(9)}    };    // Testclass to test the FieldVector<Fraction> interface    // only with enough content to support the test    public static class FieldVectorTestImpl<T extends FieldElement<T>>        implements FieldVector<T>, Serializable {        private static final long serialVersionUID = 3970959016014158539L;        private final Field<T> field;        /** Entries of the vector. */        protected T[] data;        /** Build an array of elements.         * @param length size of the array to build         * @return a new array         */        @SuppressWarnings("unchecked") // field is of type T        private T[] buildArray(final int length) {            return (T[]) Array.newInstance(field.getZero().getClass(), length);        }        public FieldVectorTestImpl(T[] d) {            field = d[0].getField();            data = d.clone();        }        public Field<T> getField() {            return field;        }        private UnsupportedOperationException unsupported() {            return new UnsupportedOperationException("Not supported, unneeded for test purposes");        }        public FieldVector<T> copy() {            throw unsupported();        }        public FieldVector<T> add(FieldVector<T> v) throws IllegalArgumentException {            throw unsupported();        }        public FieldVector<T> add(T[] v) throws IllegalArgumentException {            throw unsupported();        }        public FieldVector<T> subtract(FieldVector<T> v) throws IllegalArgumentException {            throw unsupported();        }        public FieldVector<T> subtract(T[] v) throws IllegalArgumentException {            throw unsupported();        }        public FieldVector<T> mapAdd(T d) {            throw unsupported();        }        public FieldVector<T> mapAddToSelf(T d) {            throw unsupported();        }        public FieldVector<T> mapSubtract(T d) {            throw unsupported();        }        public FieldVector<T> mapSubtractToSelf(T d) {            throw unsupported();        }        public FieldVector<T> mapMultiply(T d) {            T[] out = buildArray(data.length);            for (int i = 0; i < data.length; i++) {                out[i] = data[i].multiply(d);            }            return new FieldVectorTestImpl<T>(out);        }        public FieldVector<T> mapMultiplyToSelf(T d) {            throw unsupported();        }        public FieldVector<T> mapDivide(T d) {            throw unsupported();        }        public FieldVector<T> mapDivideToSelf(T d) {            throw unsupported();        }        public FieldVector<T> mapInv() {            throw unsupported();        }        public FieldVector<T> mapInvToSelf() {            throw unsupported();        }        public FieldVector<T> ebeMultiply(FieldVector<T> v) throws IllegalArgumentException {            throw unsupported();        }        public FieldVector<T> ebeMultiply(T[] v) throws IllegalArgumentException {            throw unsupported();        }        public FieldVector<T> ebeDivide(FieldVector<T> v) throws IllegalArgumentException {            throw unsupported();        }        public FieldVector<T> ebeDivide(T[] v) throws IllegalArgumentException {            throw unsupported();        }        public T[] getData() {            return data.clone();        }        public T dotProduct(FieldVector<T> v) throws IllegalArgumentException {            T dot = field.getZero();            for (int i = 0; i < data.length; i++) {                dot = dot.add(data[i].multiply(v.getEntry(i)));            }            return dot;        }        public T dotProduct(T[] v) throws IllegalArgumentException {            T dot = field.getZero();            for (int i = 0; i < data.length; i++) {                dot = dot.add(data[i].multiply(v[i]));            }            return dot;        }        public FieldVector<T> projection(FieldVector<T> v) throws IllegalArgumentException {            throw unsupported();        }        public FieldVector<T> projection(T[] v) throws IllegalArgumentException {            throw unsupported();        }        public FieldMatrix<T> outerProduct(FieldVector<T> v) throws IllegalArgumentException {            throw unsupported();        }        public FieldMatrix<T> outerProduct(T[] v) throws IllegalArgumentException {            throw unsupported();        }        public T getEntry(int index) throws MatrixIndexException {            return data[index];        }        public int getDimension() {            return data.length;        }        public FieldVector<T> append(FieldVector<T> v) {            throw unsupported();        }        public FieldVector<T> append(T d) {            throw unsupported();        }        public FieldVector<T> append(T[] a) {            throw unsupported();        }        public FieldVector<T> getSubVector(int index, int n) throws MatrixIndexException {            throw unsupported();        }        public void setEntry(int index, T value) throws MatrixIndexException {            throw unsupported();        }        public void setSubVector(int index, FieldVector<T> v) throws MatrixIndexException {            throw unsupported();        }        public void setSubVector(int index, T[] v) throws MatrixIndexException {            throw unsupported();        }        public void set(T value) {            throw unsupported();        }        public T[] toArray() {            throw unsupported();        }    }    public void testConstructors() {        ArrayFieldVector<Fraction> v0 = new ArrayFieldVector<Fraction>(FractionField.getInstance());        assertEquals(0, v0.getDimension());        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(FractionField.getInstance(), 7);        assertEquals(7, v1.getDimension());        assertEquals(new Fraction(0), v1.getEntry(6));        ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(5, new Fraction(123, 100));        assertEquals(5, v2.getDimension());        assertEquals(new Fraction(123, 100), v2.getEntry(4));        ArrayFieldVector<Fraction> v3 = new ArrayFieldVector<Fraction>(vec1);        assertEquals(3, v3.getDimension());        assertEquals(new Fraction(2), v3.getEntry(1));        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4, 3, 2);        assertEquals(2, v4.getDimension());        assertEquals(new Fraction(4), v4.getEntry(0));        try {            new ArrayFieldVector<Fraction>(vec4, 8, 3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        FieldVector<Fraction> v5_i = new ArrayFieldVector<Fraction>(dvec1);        assertEquals(9, v5_i.getDimension());        assertEquals(new Fraction(9), v5_i.getEntry(8));        ArrayFieldVector<Fraction> v5 = new ArrayFieldVector<Fraction>(dvec1);        assertEquals(9, v5.getDimension());        assertEquals(new Fraction(9), v5.getEntry(8));        ArrayFieldVector<Fraction> v6 = new ArrayFieldVector<Fraction>(dvec1, 3, 2);        assertEquals(2, v6.getDimension());        assertEquals(new Fraction(4), v6.getEntry(0));        try {            new ArrayFieldVector<Fraction>(dvec1, 8, 3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayFieldVector<Fraction> v7 = new ArrayFieldVector<Fraction>(v1);        assertEquals(7, v7.getDimension());        assertEquals(new Fraction(0), v7.getEntry(6));        FieldVectorTestImpl<Fraction> v7_i = new FieldVectorTestImpl<Fraction>(vec1);        ArrayFieldVector<Fraction> v7_2 = new ArrayFieldVector<Fraction>(v7_i);        assertEquals(3, v7_2.getDimension());        assertEquals(new Fraction(2), v7_2.getEntry(1));        ArrayFieldVector<Fraction> v8 = new ArrayFieldVector<Fraction>(v1, true);        assertEquals(7, v8.getDimension());        assertEquals(new Fraction(0), v8.getEntry(6));        assertNotSame("testData not same object ", v1.data, v8.data);        ArrayFieldVector<Fraction> v8_2 = new ArrayFieldVector<Fraction>(v1, false);        assertEquals(7, v8_2.getDimension());        assertEquals(new Fraction(0), v8_2.getEntry(6));        assertEquals(v1.data, v8_2.data);        ArrayFieldVector<Fraction> v9 = new ArrayFieldVector<Fraction>(v1, v3);        assertEquals(10, v9.getDimension());        assertEquals(new Fraction(1), v9.getEntry(7));    }    public void testDataInOut() {        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);        ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(vec2);        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4);        FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2);        FieldVector<Fraction> v_append_1 = v1.append(v2);        assertEquals(6, v_append_1.getDimension());        assertEquals(new Fraction(4), v_append_1.getEntry(3));        FieldVector<Fraction> v_append_2 = v1.append(new Fraction(2));        assertEquals(4, v_append_2.getDimension());        assertEquals(new Fraction(2), v_append_2.getEntry(3));        FieldVector<Fraction> v_append_3 = v1.append(vec2);        assertEquals(6, v_append_3.getDimension());        assertEquals(new Fraction(4), v_append_3.getEntry(3));        FieldVector<Fraction> v_append_4 = v1.append(v2_t);        assertEquals(6, v_append_4.getDimension());        assertEquals(new Fraction(4), v_append_4.getEntry(3));        FieldVector<Fraction> v_copy = v1.copy();        assertEquals(3, v_copy.getDimension());        assertNotSame("testData not same object ", v1.data, v_copy.getData());        Fraction[] a_frac = v1.toArray();        assertEquals(3, a_frac.length);        assertNotSame("testData not same object ", v1.data, a_frac);//      ArrayFieldVector<Fraction> vout4 = (ArrayFieldVector<Fraction>) v1.clone();//      assertEquals(3, vout4.getDimension());//      assertEquals(v1.data, vout4.data);        FieldVector<Fraction> vout5 = v4.getSubVector(3, 3);        assertEquals(3, vout5.getDimension());        assertEquals(new Fraction(5), vout5.getEntry(1));        try {            v4.getSubVector(3, 7);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayFieldVector<Fraction> v_set1 = (ArrayFieldVector<Fraction>) v1.copy();        v_set1.setEntry(1, new Fraction(11));        assertEquals(new Fraction(11), v_set1.getEntry(1));        try {            v_set1.setEntry(3, new Fraction(11));            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayFieldVector<Fraction> v_set2 = (ArrayFieldVector<Fraction>) v4.copy();        v_set2.set(3, v1);        assertEquals(new Fraction(1), v_set2.getEntry(3));        assertEquals(new Fraction(7), v_set2.getEntry(6));        try {            v_set2.set(7, v1);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayFieldVector<Fraction> v_set3 = (ArrayFieldVector<Fraction>) v1.copy();        v_set3.set(new Fraction(13));        assertEquals(new Fraction(13), v_set3.getEntry(2));        try {            v_set3.getEntry(23);            fail("ArrayIndexOutOfBoundsException expected");        } catch (ArrayIndexOutOfBoundsException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayFieldVector<Fraction> v_set4 = (ArrayFieldVector<Fraction>) v4.copy();        v_set4.setSubVector(3, v2_t);        assertEquals(new Fraction(4), v_set4.getEntry(3));        assertEquals(new Fraction(7), v_set4.getEntry(6));        try {            v_set4.setSubVector(7, v2_t);            fail("MatrixIndexException expected");        } catch (MatrixIndexException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        ArrayFieldVector<Fraction> vout10 = (ArrayFieldVector<Fraction>) v1.copy();        ArrayFieldVector<Fraction> vout10_2 = (ArrayFieldVector<Fraction>) v1.copy();        assertEquals(vout10, vout10_2);        vout10_2.setEntry(0, new Fraction(11, 10));        assertNotSame(vout10, vout10_2);    }    public void testMapFunctions() {        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);        //octave =  v1 .+ 2.0        FieldVector<Fraction> v_mapAdd = v1.mapAdd(new Fraction(2));        Fraction[] result_mapAdd = {new Fraction(3), new Fraction(4), new Fraction(5)};        checkArray("compare vectors" ,result_mapAdd,v_mapAdd.getData());        //octave =  v1 .+ 2.0        FieldVector<Fraction> v_mapAddToSelf = v1.copy();        v_mapAddToSelf.mapAddToSelf(new Fraction(2));        Fraction[] result_mapAddToSelf = {new Fraction(3), new Fraction(4), new Fraction(5)};        checkArray("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData());        //octave =  v1 .- 2.0        FieldVector<Fraction> v_mapSubtract = v1.mapSubtract(new Fraction(2));        Fraction[] result_mapSubtract = {new Fraction(-1), new Fraction(0), new Fraction(1)};        checkArray("compare vectors" ,result_mapSubtract,v_mapSubtract.getData());        //octave =  v1 .- 2.0        FieldVector<Fraction> v_mapSubtractToSelf = v1.copy();        v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));        Fraction[] result_mapSubtractToSelf = {new Fraction(-1), new Fraction(0), new Fraction(1)};        checkArray("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData());        //octave =  v1 .* 2.0        FieldVector<Fraction> v_mapMultiply = v1.mapMultiply(new Fraction(2));        Fraction[] result_mapMultiply = {new Fraction(2), new Fraction(4), new Fraction(6)};        checkArray("compare vectors" ,result_mapMultiply,v_mapMultiply.getData());        //octave =  v1 .* 2.0        FieldVector<Fraction> v_mapMultiplyToSelf = v1.copy();        v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));        Fraction[] result_mapMultiplyToSelf = {new Fraction(2), new Fraction(4), new Fraction(6)};        checkArray("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());        //octave =  v1 ./ 2.0        FieldVector<Fraction> v_mapDivide = v1.mapDivide(new Fraction(2));        Fraction[] result_mapDivide = {new Fraction(1, 2), new Fraction(1), new Fraction(3, 2)};        checkArray("compare vectors" ,result_mapDivide,v_mapDivide.getData());        //octave =  v1 ./ 2.0        FieldVector<Fraction> v_mapDivideToSelf = v1.copy();        v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));        Fraction[] result_mapDivideToSelf = {new Fraction(1, 2), new Fraction(1), new Fraction(3, 2)};        checkArray("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData());        //octave =  v1 .^-1        FieldVector<Fraction> v_mapInv = v1.mapInv();        Fraction[] result_mapInv = {new Fraction(1),new Fraction(1, 2),new Fraction(1, 3)};        checkArray("compare vectors" ,result_mapInv,v_mapInv.getData());        //octave =  v1 .^-1        FieldVector<Fraction> v_mapInvToSelf = v1.copy();        v_mapInvToSelf.mapInvToSelf();        Fraction[] result_mapInvToSelf = {new Fraction(1),new Fraction(1, 2),new Fraction(1, 3)};        checkArray("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData());    }    public void testBasicFunctions() {        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);        ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(vec2);        new ArrayFieldVector<Fraction>(vec_null);        FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2);        //octave =  v1 + v2        ArrayFieldVector<Fraction> v_add = v1.add(v2);        Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)};        checkArray("compare vect" ,v_add.getData(),result_add);        FieldVectorTestImpl<Fraction> vt2 = new FieldVectorTestImpl<Fraction>(vec2);        FieldVector<Fraction> v_add_i = v1.add(vt2);        Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)};        checkArray("compare vect" ,v_add_i.getData(),result_add_i);        //octave =  v1 - v2        ArrayFieldVector<Fraction> v_subtract = v1.subtract(v2);        Fraction[] result_subtract = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};        checkArray("compare vect" ,v_subtract.getData(),result_subtract);        FieldVector<Fraction> v_subtract_i = v1.subtract(vt2);        Fraction[] result_subtract_i = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};        checkArray("compare vect" ,v_subtract_i.getData(),result_subtract_i);        // octave v1 .* v2        ArrayFieldVector<Fraction>  v_ebeMultiply = v1.ebeMultiply(v2);        Fraction[] result_ebeMultiply = {new Fraction(4), new Fraction(10), new Fraction(18)};        checkArray("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply);        FieldVector<Fraction>  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);        Fraction[] result_ebeMultiply_2 = {new Fraction(4), new Fraction(10), new Fraction(18)};        checkArray("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2);        // octave v1 ./ v2        ArrayFieldVector<Fraction>  v_ebeDivide = v1.ebeDivide(v2);        Fraction[] result_ebeDivide = {new Fraction(1, 4), new Fraction(2, 5), new Fraction(1, 2)};        checkArray("compare vect" ,v_ebeDivide.getData(),result_ebeDivide);        FieldVector<Fraction>  v_ebeDivide_2 = v1.ebeDivide(v2_t);        Fraction[] result_ebeDivide_2 = {new Fraction(1, 4), new Fraction(2, 5), new Fraction(1, 2)};        checkArray("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2);        // octave  dot(v1,v2)        Fraction dot =  v1.dotProduct(v2);        assertEquals("compare val ",new Fraction(32), dot);        // octave  dot(v1,v2_t)        Fraction dot_2 =  v1.dotProduct(v2_t);        assertEquals("compare val ",new Fraction(32), dot_2);        FieldMatrix<Fraction> m_outerProduct = v1.outerProduct(v2);        assertEquals("compare val ",new Fraction(4), m_outerProduct.getEntry(0,0));        FieldMatrix<Fraction> m_outerProduct_2 = v1.outerProduct(v2_t);        assertEquals("compare val ",new Fraction(4), m_outerProduct_2.getEntry(0,0));        ArrayFieldVector<Fraction> v_projection = v1.projection(v2);        Fraction[] result_projection = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)};        checkArray("compare vect", v_projection.getData(), result_projection);        FieldVector<Fraction> v_projection_2 = v1.projection(v2_t);        Fraction[] result_projection_2 = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)};        checkArray("compare vect", v_projection_2.getData(), result_projection_2);    }    public void testMisc() {        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4);        FieldVector<Fraction> v4_2 = new ArrayFieldVector<Fraction>(vec4);        String out1 = v1.toString();        assertTrue("some output ",  out1.length()!=0);        /*         Fraction[] dout1 = v1.copyOut();        assertEquals(3, dout1.length);        assertNotSame("testData not same object ", v1.data, dout1);         */        try {            v1.checkVectorDimensions(2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }       try {            v1.checkVectorDimensions(v4);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            v1.checkVectorDimensions(v4_2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testSerial()  {        ArrayFieldVector<Fraction> v = new ArrayFieldVector<Fraction>(vec1);        assertEquals(v,TestUtils.serializeAndRecover(v));    }    /** verifies that two vectors are equals */    protected void checkArray(String msg, Fraction[] m, Fraction[] n) {        if (m.length != n.length) {            fail("vectors have different lengths");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " +  i + " elements differ", m[i],n[i]);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.fraction.Fraction;import org.apache.commons.math.fraction.FractionField;import org.apache.commons.math.exception.MatrixDimensionMismatchException;/** * Test cases for the {@link Array2DRowFieldMatrix} class. * * @version $Revision$ $Date$ */public final class FieldMatrixImplTest extends TestCase {    // 3 x 3 identity matrix    protected Fraction[][] id = { {new Fraction(1),new Fraction(0),new Fraction(0)}, {new Fraction(0),new Fraction(1),new Fraction(0)}, {new Fraction(0),new Fraction(0),new Fraction(1)} };    // Test data for group operations    protected Fraction[][] testData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)}, {new Fraction(1),new Fraction(0),new Fraction(8)} };    protected Fraction[][] testDataLU = {{new Fraction(2), new Fraction(5), new Fraction(3)}, {new Fraction(1, 2), new Fraction(-5, 2), new Fraction(13, 2)}, {new Fraction(1, 2), new Fraction(1, 5), new Fraction(1, 5)}};    protected Fraction[][] testDataPlus2 = { {new Fraction(3),new Fraction(4),new Fraction(5)}, {new Fraction(4),new Fraction(7),new Fraction(5)}, {new Fraction(3),new Fraction(2),new Fraction(10)} };    protected Fraction[][] testDataMinus = { {new Fraction(-1),new Fraction(-2),new Fraction(-3)}, {new Fraction(-2),new Fraction(-5),new Fraction(-3)},       {new Fraction(-1),new Fraction(0),new Fraction(-8)} };    protected Fraction[] testDataRow1 = {new Fraction(1),new Fraction(2),new Fraction(3)};    protected Fraction[] testDataCol3 = {new Fraction(3),new Fraction(3),new Fraction(8)};    protected Fraction[][] testDataInv =        { {new Fraction(-40),new Fraction(16),new Fraction(9)}, {new Fraction(13),new Fraction(-5),new Fraction(-3)}, {new Fraction(5),new Fraction(-2),new Fraction(-1)} };    protected Fraction[] preMultTest = {new Fraction(8),new Fraction(12),new Fraction(33)};    protected Fraction[][] testData2 ={ {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)}};    protected Fraction[][] testData2T = { {new Fraction(1),new Fraction(2)}, {new Fraction(2),new Fraction(5)}, {new Fraction(3),new Fraction(3)}};    protected Fraction[][] testDataPlusInv =        { {new Fraction(-39),new Fraction(18),new Fraction(12)}, {new Fraction(15),new Fraction(0),new Fraction(0)}, {new Fraction(6),new Fraction(-2),new Fraction(7)} };    // lu decomposition tests    protected Fraction[][] luData = { {new Fraction(2),new Fraction(3),new Fraction(3)}, {new Fraction(0),new Fraction(5),new Fraction(7)}, {new Fraction(6),new Fraction(9),new Fraction(8)} };    protected Fraction[][] luDataLUDecomposition = { {new Fraction(6),new Fraction(9),new Fraction(8)}, {new Fraction(0),new Fraction(5),new Fraction(7)},            {new Fraction(1, 3),new Fraction(0),new Fraction(1, 3)} };    // singular matrices    protected Fraction[][] singular = { {new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(3)} };    protected Fraction[][] bigSingular = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}, {new Fraction(2),new Fraction(5),new Fraction(3),new Fraction(4)},        {new Fraction(7),new Fraction(3),new Fraction(256),new Fraction(1930)}, {new Fraction(3),new Fraction(7),new Fraction(6),new Fraction(8)}}; // 4th row = 1st + 2nd    protected Fraction[][] detData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(4),new Fraction(5),new Fraction(6)}, {new Fraction(7),new Fraction(8),new Fraction(10)} };    protected Fraction[][] detData2 = { {new Fraction(1), new Fraction(3)}, {new Fraction(2), new Fraction(4)}};    // vectors    protected Fraction[] testVector = {new Fraction(1),new Fraction(2),new Fraction(3)};    protected Fraction[] testVector2 = {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)};    // submatrix accessor tests    protected Fraction[][] subTestData = {{new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)}, {new Fraction(3, 2), new Fraction(5, 2), new Fraction(7, 2), new Fraction(9, 2)},            {new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8)}, {new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7)}};    // array selections    protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4)}, {new Fraction(4), new Fraction(8)}};    protected Fraction[][] subRows03Cols12 = { {new Fraction(2), new Fraction(3)}, {new Fraction(5), new Fraction(6)}};    protected Fraction[][] subRows03Cols123 = { {new Fraction(2), new Fraction(3), new Fraction(4)} , {new Fraction(5), new Fraction(6), new Fraction(7)}};    // effective permutations    protected Fraction[][] subRows20Cols123 = { {new Fraction(4), new Fraction(6), new Fraction(8)} , {new Fraction(2), new Fraction(3), new Fraction(4)}};    protected Fraction[][] subRows31Cols31 = {{new Fraction(7), new Fraction(5)}, {new Fraction(9, 2), new Fraction(5, 2)}};    // contiguous ranges    protected Fraction[][] subRows01Cols23 = {{new Fraction(3),new Fraction(4)} , {new Fraction(7, 2), new Fraction(9, 2)}};    protected Fraction[][] subRows23Cols00 = {{new Fraction(2)} , {new Fraction(4)}};    protected Fraction[][] subRows00Cols33 = {{new Fraction(4)}};    // row matrices    protected Fraction[][] subRow0 = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}};    protected Fraction[][] subRow3 = {{new Fraction(4),new Fraction(5),new Fraction(6),new Fraction(7)}};    // column matrices    protected Fraction[][] subColumn1 = {{new Fraction(2)}, {new Fraction(5, 2)}, {new Fraction(4)}, {new Fraction(5)}};    protected Fraction[][] subColumn3 = {{new Fraction(4)}, {new Fraction(9, 2)}, {new Fraction(8)}, {new Fraction(7)}};    // tolerances    protected double entryTolerance = 10E-16;    protected double normTolerance = 10E-14;    public FieldMatrixImplTest(String name) {        super(name);    }    /** test dimensions */    public void testDimensions() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());    }    /** test copy functions */    public void testCopyFunctions() {        Array2DRowFieldMatrix<Fraction> m1 = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(m1.getData());        assertEquals(m2,m1);        Array2DRowFieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(m3.getData(), false);        assertEquals(m4,m3);    }    /** test add */    public void testAdd() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);        FieldMatrix<Fraction> mPlusMInv = m.add(mInv);        Fraction[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);            }        }    }    /** test add failure */    public void testAddFail() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);        try {            m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }    }     /** test m-n = m + -n */    public void testPlusMinus() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testDataInv);        TestUtils.assertEquals(m.subtract(m2),m2.scalarMultiply(new Fraction(-1)).add(m));        try {            m.subtract(new Array2DRowFieldMatrix<Fraction>(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test multiply */     public void testMultiply() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);        Array2DRowFieldMatrix<Fraction> identity = new Array2DRowFieldMatrix<Fraction>(id);        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);        TestUtils.assertEquals(m.multiply(mInv), identity);        TestUtils.assertEquals(mInv.multiply(m), identity);        TestUtils.assertEquals(m.multiply(identity), m);        TestUtils.assertEquals(identity.multiply(mInv), mInv);        TestUtils.assertEquals(m2.multiply(identity), m2);        try {            m.multiply(new Array2DRowFieldMatrix<Fraction>(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    //Additional Test for Array2DRowFieldMatrix<Fraction>Test.testMultiply    private Fraction[][] d3 = new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},{new Fraction(5),new Fraction(6),new Fraction(7),new Fraction(8)}};    private Fraction[][] d4 = new Fraction[][] {{new Fraction(1)},{new Fraction(2)},{new Fraction(3)},{new Fraction(4)}};    private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}};    public void testMultiply2() {       FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3);       FieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(d4);       FieldMatrix<Fraction> m5 = new Array2DRowFieldMatrix<Fraction>(d5);       TestUtils.assertEquals(m3.multiply(m4), m5);   }    /** test trace */    public void testTrace() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(id);        assertEquals("identity trace",new Fraction(3),m.getTrace());        m = new Array2DRowFieldMatrix<Fraction>(testData2);        try {            m.getTrace();            fail("Expecting NonSquareMatrixException");        } catch (NonSquareMatrixException ex) {            // ignored        }    }    /** test sclarAdd */    public void testScalarAdd() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(new Array2DRowFieldMatrix<Fraction>(testDataPlus2), m.scalarAdd(new Fraction(2)));    }    /** test operate */    public void testOperate() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(id);        TestUtils.assertEquals(testVector, m.operate(testVector));        TestUtils.assertEquals(testVector, m.operate(new ArrayFieldVector<Fraction>(testVector)).getData());        m = new Array2DRowFieldMatrix<Fraction>(bigSingular);        try {            m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    /** test issue MATH-209 */    public void testMath209() {        FieldMatrix<Fraction> a = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {                { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) }        }, false);        Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });        assertEquals(a.getRowDimension(), b.length);        assertEquals( new Fraction(3), b[0]);        assertEquals( new Fraction(7), b[1]);        assertEquals(new Fraction(11), b[2]);    }    /** test transpose */    public void testTranspose() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();        TestUtils.assertEquals(mIT, mTI);        m = new Array2DRowFieldMatrix<Fraction>(testData2);        FieldMatrix<Fraction> mt = new Array2DRowFieldMatrix<Fraction>(testData2T);        TestUtils.assertEquals(mt, m.transpose());    }    /** test preMultiply by vector */    public void testPremultiplyVector() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(m.preMultiply(testVector), preMultTest);        TestUtils.assertEquals(m.preMultiply(new ArrayFieldVector<Fraction>(testVector).getData()),                               preMultTest);        m = new Array2DRowFieldMatrix<Fraction>(bigSingular);        try {            m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testPremultiply() {        FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3);        FieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(d4);        FieldMatrix<Fraction> m5 = new Array2DRowFieldMatrix<Fraction>(d5);        TestUtils.assertEquals(m4.preMultiply(m3), m5);        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);        Array2DRowFieldMatrix<Fraction> identity = new Array2DRowFieldMatrix<Fraction>(id);        TestUtils.assertEquals(m.preMultiply(mInv), identity);        TestUtils.assertEquals(mInv.preMultiply(m), identity);        TestUtils.assertEquals(m.preMultiply(identity), m);        TestUtils.assertEquals(identity.preMultiply(mInv), mInv);        try {            m.preMultiply(new Array2DRowFieldMatrix<Fraction>(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testGetVectors() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        TestUtils.assertEquals(m.getRow(0), testDataRow1);        TestUtils.assertEquals(m.getColumn(2), testDataCol3);        try {            m.getRow(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }        try {            m.getColumn(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // ignored        }    }    public void testGetEntry() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        assertEquals("get entry",m.getEntry(0,1),new Fraction(2));        try {            m.getEntry(10, 4);            fail ("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    /** test examples in user guide */    public void testExamples() {        // Create a real matrix with two rows and three columns        Fraction[][] matrixData = {                {new Fraction(1),new Fraction(2),new Fraction(3)},                {new Fraction(2),new Fraction(5),new Fraction(3)}        };        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(matrixData);        // One more with three rows, two columns        Fraction[][] matrixData2 = {                {new Fraction(1),new Fraction(2)},                {new Fraction(2),new Fraction(5)},                {new Fraction(1), new Fraction(7)}        };        FieldMatrix<Fraction> n = new Array2DRowFieldMatrix<Fraction>(matrixData2);        // Now multiply m by n        FieldMatrix<Fraction> p = m.multiply(n);        assertEquals(2, p.getRowDimension());        assertEquals(2, p.getColumnDimension());        // Invert p        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();        assertEquals(2, pInverse.getRowDimension());        assertEquals(2, pInverse.getColumnDimension());        // Solve example        Fraction[][] coefficientsData = {                {new Fraction(2), new Fraction(3), new Fraction(-2)},                {new Fraction(-1), new Fraction(7), new Fraction(6)},                {new Fraction(4), new Fraction(-3), new Fraction(-5)}        };        FieldMatrix<Fraction> coefficients = new Array2DRowFieldMatrix<Fraction>(coefficientsData);        Fraction[] constants = {new Fraction(1), new Fraction(-2), new Fraction(1)};        Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);        assertEquals(new Fraction(2).multiply(solution[0]).                     add(new Fraction(3).multiply(solution[1])).                     subtract(new Fraction(2).multiply(solution[2])), constants[0]);        assertEquals(new Fraction(-1).multiply(solution[0]).                     add(new Fraction(7).multiply(solution[1])).                     add(new Fraction(6).multiply(solution[2])), constants[1]);        assertEquals(new Fraction(4).multiply(solution[0]).                     subtract(new Fraction(3).multiply(solution[1])).                     subtract(new Fraction(5).multiply(solution[2])), constants[2]);    }    // test submatrix accessors    public void testGetSubMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkGetSubMatrix(m, null,  1, 0, 2, 4);        checkGetSubMatrix(m, null, -1, 1, 2, 2);        checkGetSubMatrix(m, null,  1, 0, 2, 2);        checkGetSubMatrix(m, null,  1, 0, 2, 4);        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 });        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 });    }    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,                                   int startRow, int endRow, int startColumn, int endColumn) {        try {            FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);            if (reference != null) {                assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);            } else {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (reference != null) {                throw e;            }        }    }    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,                                   int[] selectedRows, int[] selectedColumns) {        try {            FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);            if (reference != null) {                assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);            } else {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (reference != null) {                throw e;            }        }    }    public void testCopySubMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });        checkCopy(m, null,  1, 0, 2, 4);        checkCopy(m, null, -1, 1, 2, 2);        checkCopy(m, null,  1, 0, 2, 2);        checkCopy(m, null,  1, 0, 2, 4);        checkCopy(m, null, new int[] {},    new int[] { 0 });        checkCopy(m, null, new int[] { 0 }, new int[] { 4 });    }    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,                           int startRow, int endRow, int startColumn, int endColumn) {        try {            Fraction[][] sub = (reference == null) ?                             new Fraction[1][1] :                             new Fraction[reference.length][reference[0].length];            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);            if (reference != null) {                assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));            } else {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (reference != null) {                throw e;            }        }    }    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,                           int[] selectedRows, int[] selectedColumns) {        try {            Fraction[][] sub = (reference == null) ?                    new Fraction[1][1] :                    new Fraction[reference.length][reference[0].length];            m.copySubMatrix(selectedRows, selectedColumns, sub);            if (reference != null) {                assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));            } else {                fail("Expecting MatrixIndexException");            }        } catch (MatrixIndexException e) {            if (reference != null) {                throw e;            }        }    }    public void testGetRowMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mRow0 = new Array2DRowFieldMatrix<Fraction>(subRow0);        FieldMatrix<Fraction> mRow3 = new Array2DRowFieldMatrix<Fraction>(subRow3);        assertEquals("Row0", mRow0,                m.getRowMatrix(0));        assertEquals("Row3", mRow3,                m.getRowMatrix(3));        try {            m.getRowMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mRow3 = new Array2DRowFieldMatrix<Fraction>(subRow3);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowMatrix(0, mRow3);        assertEquals(mRow3, m.getRowMatrix(0));        try {            m.setRowMatrix(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowMatrix(0, m);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetColumnMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mColumn1 = new Array2DRowFieldMatrix<Fraction>(subColumn1);        FieldMatrix<Fraction> mColumn3 = new Array2DRowFieldMatrix<Fraction>(subColumn3);        assertEquals("Column1", mColumn1,                m.getColumnMatrix(1));        assertEquals("Column3", mColumn3,                m.getColumnMatrix(3));        try {            m.getColumnMatrix(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnMatrix(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnMatrix() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldMatrix<Fraction> mColumn3 = new Array2DRowFieldMatrix<Fraction>(subColumn3);        assertNotSame(mColumn3, m.getColumnMatrix(1));        m.setColumnMatrix(1, mColumn3);        assertEquals(mColumn3, m.getColumnMatrix(1));        try {            m.setColumnMatrix(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnMatrix(0, m);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetRowVector() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);        assertEquals("Row0", mRow0, m.getRowVector(0));        assertEquals("Row3", mRow3, m.getRowVector(3));        try {            m.getRowVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRowVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRowVector() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);        assertNotSame(mRow3, m.getRowMatrix(0));        m.setRowVector(0, mRow3);        assertEquals(mRow3, m.getRowVector(0));        try {            m.setRowVector(-1, mRow3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRowVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetColumnVector() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);        assertEquals("Column1", mColumn1, m.getColumnVector(1));        assertEquals("Column3", mColumn3, m.getColumnVector(3));        try {            m.getColumnVector(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumnVector(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumnVector() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);        assertNotSame(mColumn3, m.getColumnVector(1));        m.setColumnVector(1, mColumn3);        assertEquals(mColumn3, m.getColumnVector(1));        try {            m.setColumnVector(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumnVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    private FieldVector<Fraction> columnToVector(Fraction[][] column) {        Fraction[] data = new Fraction[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return new ArrayFieldVector<Fraction>(data, false);    }    public void testGetRow() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        checkArrays(subRow0[0], m.getRow(0));        checkArrays(subRow3[0], m.getRow(3));        try {            m.getRow(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getRow(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetRow() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        assertTrue(subRow3[0][0] != m.getRow(0)[0]);        m.setRow(0, subRow3[0]);        checkArrays(subRow3[0], m.getRow(0));        try {            m.setRow(-1, subRow3[0]);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setRow(0, new Fraction[5]);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    public void testGetColumn() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        Fraction[] mColumn1 = columnToArray(subColumn1);        Fraction[] mColumn3 = columnToArray(subColumn3);        checkArrays(mColumn1, m.getColumn(1));        checkArrays(mColumn3, m.getColumn(3));        try {            m.getColumn(-1);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.getColumn(4);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }    }    public void testSetColumn() {        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);        Fraction[] mColumn3 = columnToArray(subColumn3);        assertTrue(mColumn3[0] != m.getColumn(1)[0]);        m.setColumn(1, mColumn3);        checkArrays(mColumn3, m.getColumn(1));        try {            m.setColumn(-1, mColumn3);            fail("Expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            // expected        }        try {            m.setColumn(0, new Fraction[5]);            fail("Expecting MatrixDimensionMismatchException");        } catch (MatrixDimensionMismatchException ex) {            // expected        }    }    private Fraction[] columnToArray(Fraction[][] column) {        Fraction[] data = new Fraction[column.length];        for (int i = 0; i < data.length; ++i) {            data[i] = column[i][0];        }        return data;    }    private void checkArrays(Fraction[] expected, Fraction[] actual) {        assertEquals(expected.length, actual.length);        for (int i = 0; i < expected.length; ++i) {            assertEquals(expected[i], actual[i]);        }    }    public void testEqualsAndHashCode() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        Array2DRowFieldMatrix<Fraction> m1 = (Array2DRowFieldMatrix<Fraction>) m.copy();        Array2DRowFieldMatrix<Fraction> mt = (Array2DRowFieldMatrix<Fraction>) m.transpose();        assertTrue(m.hashCode() != mt.hashCode());        assertEquals(m.hashCode(), m1.hashCode());        assertEquals(m, m);        assertEquals(m, m1);        assertFalse(m.equals(null));        assertFalse(m.equals(mt));        assertFalse(m.equals(new Array2DRowFieldMatrix<Fraction>(bigSingular)));    }    public void testToString() {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        assertEquals("Array2DRowFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}", m.toString());        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance());        assertEquals("Array2DRowFieldMatrix{}", m.toString());    }    public void testSetSubMatrix() throws Exception {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        m.setSubMatrix(detData2,1,1);        FieldMatrix<Fraction> expected = new Array2DRowFieldMatrix<Fraction>            (new Fraction[][] {                    {new Fraction(1),new Fraction(2),new Fraction(3)},                    {new Fraction(2),new Fraction(1),new Fraction(3)},                    {new Fraction(1),new Fraction(2),new Fraction(4)}             });        assertEquals(expected, m);        m.setSubMatrix(detData2,0,0);        expected = new Array2DRowFieldMatrix<Fraction>            (new Fraction[][] {                    {new Fraction(1),new Fraction(3),new Fraction(3)},                    {new Fraction(2),new Fraction(4),new Fraction(3)},                    {new Fraction(1),new Fraction(2),new Fraction(4)}             });        assertEquals(expected, m);        m.setSubMatrix(testDataPlus2,0,0);        expected = new Array2DRowFieldMatrix<Fraction>            (new Fraction[][] {                    {new Fraction(3),new Fraction(4),new Fraction(5)},                    {new Fraction(4),new Fraction(7),new Fraction(5)},                    {new Fraction(3),new Fraction(2),new Fraction(10)}             });        assertEquals(expected, m);        // dimension overflow        try {            m.setSubMatrix(testData,1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // dimension underflow        try {            m.setSubMatrix(testData,-1,1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        try {            m.setSubMatrix(testData,1,-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException e) {            // expected        }        // null        try {            m.setSubMatrix(null,1,1);            fail("expecting NullPointerException");        } catch (NullPointerException e) {            // expected        }        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance());        try {            m2.setSubMatrix(testData,0,1);            fail("expecting IllegalStateException");        } catch (IllegalStateException e) {            // expected        }        try {            m2.setSubMatrix(testData,1,0);            fail("expecting IllegalStateException");        } catch (IllegalStateException e) {            // expected        }        // ragged        try {            m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }        // empty        try {            m.setSubMatrix(new Fraction[][] {{}}, 0, 0);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException e) {            // expected        }    }    public void testWalk() {        int rows    = 150;        int columns = 75;        FieldMatrix<Fraction> m =            new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInRowOrder(new SetVisitor());        GetVisitor getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(new Fraction(0), m.getEntry(i, 0));            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            assertEquals(new Fraction(0), m.getEntry(0, j));            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInColumnOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(new Fraction(0), m.getEntry(i, 0));            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            assertEquals(new Fraction(0), m.getEntry(0, j));            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(new Fraction(0), m.getEntry(i, 0));            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            assertEquals(new Fraction(0), m.getEntry(0, j));            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor());        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor);        assertEquals(rows * columns, getVisitor.getCount());        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);        getVisitor = new GetVisitor();        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());        for (int i = 0; i < rows; ++i) {            assertEquals(new Fraction(0), m.getEntry(i, 0));            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));        }        for (int j = 0; j < columns; ++j) {            assertEquals(new Fraction(0), m.getEntry(0, j));            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));        }    }    public void testSerial()  {        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);        assertEquals(m,TestUtils.serializeAndRecover(m));    }    private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Fraction> {        public SetVisitor() {            super(Fraction.ZERO);        }        @Override        public Fraction visit(int i, int j, Fraction value) {            return new Fraction(i * 1024 + j, 1024);        }    }    private static class GetVisitor extends DefaultFieldMatrixPreservingVisitor<Fraction> {        private int count;        public GetVisitor() {            super(Fraction.ZERO);            count = 0;        }        @Override        public void visit(int i, int j, Fraction value) {            ++count;            assertEquals(new Fraction(i * 1024 + j, 1024), value);        }        public int getCount() {            return count;        }    }    //--------------- -----------------Protected methods    /** extracts the l  and u matrices from compact lu representation */    protected void splitLU(FieldMatrix<Fraction> lu,                           Fraction[][] lowerData,                           Fraction[][] upperData) {        if (!lu.isSquare() ||            lowerData.length != lowerData[0].length ||            upperData.length != upperData[0].length ||            lowerData.length != upperData.length ||            lowerData.length != lu.getRowDimension()) {            throw new IllegalArgumentException("incorrect dimensions");        }        int n = lu.getRowDimension();        for (int i = 0; i < n; i++) {            for (int j = 0; j < n; j++) {                if (j < i) {                    lowerData[i][j] = lu.getEntry(i, j);                    upperData[i][j] = Fraction.ZERO;                } else if (i == j) {                    lowerData[i][j] = Fraction.ONE;                    upperData[i][j] = lu.getEntry(i, j);                } else {                    lowerData[i][j] = Fraction.ZERO;                    upperData[i][j] = lu.getEntry(i, j);                }            }        }    }    /** Returns the result of applying the given row permutation to the matrix */    protected FieldMatrix<Fraction> permuteRows(FieldMatrix<Fraction> matrix, int[] permutation) {        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {            throw new IllegalArgumentException("dimension mismatch");        }        int n = matrix.getRowDimension();        int m = matrix.getColumnDimension();        Fraction out[][] = new Fraction[m][n];        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                out[i][j] = matrix.getEntry(permutation[i], j);            }        }        return new Array2DRowFieldMatrix<Fraction>(out);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.TestCase;public class LUSolverTest extends TestCase {    private double[][] testData = {            { 1.0, 2.0, 3.0},            { 2.0, 5.0, 3.0},            { 1.0, 0.0, 8.0}    };    private double[][] luData = {            { 2.0, 3.0, 3.0 },            { 0.0, 5.0, 7.0 },            { 6.0, 9.0, 8.0 }    };    // singular matrices    private double[][] singular = {            { 2.0, 3.0 },            { 2.0, 3.0 }    };    private double[][] bigSingular = {            { 1.0, 2.0,   3.0,    4.0 },            { 2.0, 5.0,   3.0,    4.0 },            { 7.0, 3.0, 256.0, 1930.0 },            { 3.0, 7.0,   6.0,    8.0 }    }; // 4th row = 1st + 2nd    public LUSolverTest(String name) {        super(name);    }    /** test threshold impact */    public void testThreshold() {        final RealMatrix matrix = MatrixUtils.createRealMatrix(new double[][] {                                                       { 1.0, 2.0, 3.0},                                                       { 2.0, 5.0, 3.0},                                                       { 4.000001, 9.0, 9.0}                                                     });        assertFalse(new LUDecompositionImpl(matrix, 1.0e-5).getSolver().isNonSingular());        assertTrue(new LUDecompositionImpl(matrix, 1.0e-10).getSolver().isNonSingular());    }    /** test singular */    public void testSingular() {        DecompositionSolver solver =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();        assertTrue(solver.isNonSingular());        solver = new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular)).getSolver();        assertFalse(solver.isNonSingular());        solver = new LUDecompositionImpl(MatrixUtils.createRealMatrix(bigSingular)).getSolver();        assertFalse(solver.isNonSingular());    }    /** test solve dimension errors */    public void testSolveDimensionErrors() {        DecompositionSolver solver =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);        try {            solver.solve(b);            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumn(0));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));            fail("an exception should have been thrown");        } catch (IllegalArgumentException iae) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test solve singularity errors */    public void testSolveSingularityErrors() {        DecompositionSolver solver =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(singular)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);        try {            solver.solve(b);            fail("an exception should have been thrown");        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumn(0));            fail("an exception should have been thrown");        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(b.getColumnVector(0));            fail("an exception should have been thrown");        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));            fail("an exception should have been thrown");        } catch (InvalidMatrixException ime) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /** test solve */    public void testSolve() {        DecompositionSolver solver =            new LUDecompositionImpl(MatrixUtils.createRealMatrix(testData)).getSolver();        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {                { 1, 0 }, { 2, -5 }, { 3, 1 }        });        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {                { 19, -71 }, { -6, 22 }, { -2, 9 }        });        // using RealMatrix        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);        // using double[]        for (int i = 0; i < b.getColumnDimension(); ++i) {            assertEquals(0,                         new ArrayRealVector(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }        // using ArrayRealVector        for (int i = 0; i < b.getColumnDimension(); ++i) {            assertEquals(0,                         solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }        // using RealVector with an alternate implementation        for (int i = 0; i < b.getColumnDimension(); ++i) {            ArrayRealVectorTest.RealVectorTestImpl v =                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));            assertEquals(0,                         solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),                         1.0e-13);        }    }    /** test determinant */    public void testDeterminant() {        assertEquals( -1, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15);        assertEquals(-10, getDeterminant(MatrixUtils.createRealMatrix(luData)), 1.0e-14);        assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(singular)), 1.0e-17);        assertEquals(  0, getDeterminant(MatrixUtils.createRealMatrix(bigSingular)), 1.0e-10);    }    private double getDeterminant(RealMatrix m) {        return new LUDecompositionImpl(m).getDeterminant();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Random;import junit.framework.TestCase;public class QRDecompositionImplTest extends TestCase {    double[][] testData3x3NonSingular = {            { 12, -51, 4 },            { 6, 167, -68 },            { -4, 24, -41 }, };    double[][] testData3x3Singular = {            { 1, 4, 7, },            { 2, 5, 8, },            { 3, 6, 9, }, };    double[][] testData3x4 = {            { 12, -51, 4, 1 },            { 6, 167, -68, 2 },            { -4, 24, -41, 3 }, };    double[][] testData4x3 = {            { 12, -51, 4, },            { 6, 167, -68, },            { -4, 24, -41, },            { -5, 34, 7, }, };    private static final double entryTolerance = 10e-16;    private static final double normTolerance = 10e-14;    public QRDecompositionImplTest(String name) {        super(name);    }    /** test dimensions */    public void testDimensions() {        checkDimension(MatrixUtils.createRealMatrix(testData3x3NonSingular));        checkDimension(MatrixUtils.createRealMatrix(testData4x3));        checkDimension(MatrixUtils.createRealMatrix(testData3x4));        Random r = new Random(643895747384642l);        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        checkDimension(createTestMatrix(r, p, q));        checkDimension(createTestMatrix(r, q, p));    }    private void checkDimension(RealMatrix m) {        int rows = m.getRowDimension();        int columns = m.getColumnDimension();        QRDecomposition qr = new QRDecompositionImpl(m);        assertEquals(rows,    qr.getQ().getRowDimension());        assertEquals(rows,    qr.getQ().getColumnDimension());        assertEquals(rows,    qr.getR().getRowDimension());        assertEquals(columns, qr.getR().getColumnDimension());    }    /** test A = QR */    public void testAEqualQR() {        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3NonSingular));        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3Singular));        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x4));        checkAEqualQR(MatrixUtils.createRealMatrix(testData4x3));        Random r = new Random(643895747384642l);        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        checkAEqualQR(createTestMatrix(r, p, q));        checkAEqualQR(createTestMatrix(r, q, p));    }    private void checkAEqualQR(RealMatrix m) {        QRDecomposition qr = new QRDecompositionImpl(m);        double norm = qr.getQ().multiply(qr.getR()).subtract(m).getNorm();        assertEquals(0, norm, normTolerance);    }    /** test the orthogonality of Q */    public void testQOrthogonal() {        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3NonSingular));        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3Singular));        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x4));        checkQOrthogonal(MatrixUtils.createRealMatrix(testData4x3));        Random r = new Random(643895747384642l);        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        checkQOrthogonal(createTestMatrix(r, p, q));        checkQOrthogonal(createTestMatrix(r, q, p));    }    private void checkQOrthogonal(RealMatrix m) {        QRDecomposition qr = new QRDecompositionImpl(m);        RealMatrix eye = MatrixUtils.createRealIdentityMatrix(m.getRowDimension());        double norm = qr.getQT().multiply(qr.getQ()).subtract(eye).getNorm();        assertEquals(0, norm, normTolerance);    }    /** test that R is upper triangular */    public void testRUpperTriangular() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());        matrix = MatrixUtils.createRealMatrix(testData3x4);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());        matrix = MatrixUtils.createRealMatrix(testData4x3);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());        Random r = new Random(643895747384642l);        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        matrix = createTestMatrix(r, p, q);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());        matrix = createTestMatrix(r, p, q);        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());    }    private void checkUpperTriangular(RealMatrix m) {        m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {            @Override            public void visit(int row, int column, double value) {                if (column < row) {                    assertEquals(0.0, value, entryTolerance);                }            }        });    }    /** test that H is trapezoidal */    public void testHTrapezoidal() {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());        matrix = MatrixUtils.createRealMatrix(testData3x4);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());        matrix = MatrixUtils.createRealMatrix(testData4x3);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());        Random r = new Random(643895747384642l);        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;        matrix = createTestMatrix(r, p, q);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());        matrix = createTestMatrix(r, p, q);        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());    }    private void checkTrapezoidal(RealMatrix m) {        m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {            @Override            public void visit(int row, int column, double value) {                if (column > row) {                    assertEquals(0.0, value, entryTolerance);                }            }        });    }    /** test matrices values */    public void testMatricesValues() {        QRDecomposition qr =            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular));        RealMatrix qRef = MatrixUtils.createRealMatrix(new double[][] {                { -12.0 / 14.0,   69.0 / 175.0,  -58.0 / 175.0 },                {  -6.0 / 14.0, -158.0 / 175.0,    6.0 / 175.0 },                {   4.0 / 14.0,  -30.0 / 175.0, -165.0 / 175.0 }        });        RealMatrix rRef = MatrixUtils.createRealMatrix(new double[][] {                { -14.0,  -21.0, 14.0 },                {   0.0, -175.0, 70.0 },                {   0.0,    0.0, 35.0 }        });        RealMatrix hRef = MatrixUtils.createRealMatrix(new double[][] {                { 26.0 / 14.0, 0.0, 0.0 },                {  6.0 / 14.0, 648.0 / 325.0, 0.0 },                { -4.0 / 14.0,  36.0 / 325.0, 2.0 }        });        // check values against known references        RealMatrix q = qr.getQ();        assertEquals(0, q.subtract(qRef).getNorm(), 1.0e-13);        RealMatrix qT = qr.getQT();        assertEquals(0, qT.subtract(qRef.transpose()).getNorm(), 1.0e-13);        RealMatrix r = qr.getR();        assertEquals(0, r.subtract(rRef).getNorm(), 1.0e-13);        RealMatrix h = qr.getH();        assertEquals(0, h.subtract(hRef).getNorm(), 1.0e-13);        // check the same cached instance is returned the second time        assertTrue(q == qr.getQ());        assertTrue(r == qr.getR());        assertTrue(h == qr.getH());    }    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {        RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);        m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){            @Override            public double visit(int row, int column, double value)                throws MatrixVisitorException {                return 2.0 * r.nextDouble() - 1.0;            }        });        return m;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import org.apache.commons.math.MathException;import org.apache.commons.math.linear.CholeskyDecomposition;import org.apache.commons.math.linear.CholeskyDecompositionImpl;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.NonSquareMatrixException;import org.apache.commons.math.linear.NotPositiveDefiniteMatrixException;import org.apache.commons.math.linear.NotSymmetricMatrixException;import org.apache.commons.math.linear.RealMatrix;import org.junit.Test;public class CholeskyDecompositionImplTest {    private double[][] testData = new double[][] {            {  1,  2,   4,   7,  11 },            {  2, 13,  23,  38,  58 },            {  4, 23,  77, 122, 182 },            {  7, 38, 122, 294, 430 },            { 11, 58, 182, 430, 855 }    };    /** test dimensions */    @Test    public void testDimensions() throws MathException {        CholeskyDecomposition llt =            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData));        assertEquals(testData.length, llt.getL().getRowDimension());        assertEquals(testData.length, llt.getL().getColumnDimension());        assertEquals(testData.length, llt.getLT().getRowDimension());        assertEquals(testData.length, llt.getLT().getColumnDimension());    }    /** test non-square matrix */    @Test(expected = NonSquareMatrixException.class)    public void testNonSquare() throws MathException {        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[3][2]));    }    /** test non-symmetric matrix */    @Test(expected = NotSymmetricMatrixException.class)    public void testNotSymmetricMatrixException() throws MathException {        double[][] changed = testData.clone();        changed[0][changed[0].length - 1] += 1.0e-5;        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(changed));    }    /** test non positive definite matrix */    @Test(expected = NotPositiveDefiniteMatrixException.class)    public void testNotPositiveDefinite() throws MathException {        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {                { 14, 11, 13, 15, 24 },                { 11, 34, 13, 8,  25 },                { 13, 13, 14, 15, 21 },                { 15, 8,  15, 18, 23 },                { 24, 25, 21, 23, 45 }        }));    }    @Test(expected = NotPositiveDefiniteMatrixException.class)    public void testMath274() throws MathException {        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {                { 0.40434286, -0.09376327, 0.30328980, 0.04909388 },                {-0.09376327,  0.10400408, 0.07137959, 0.04762857 },                { 0.30328980,  0.07137959, 0.30458776, 0.04882449 },                { 0.04909388,  0.04762857, 0.04882449, 0.07543265 }        }));    }    /** test A = LLT */    @Test    public void testAEqualLLT() throws MathException {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        CholeskyDecomposition llt = new CholeskyDecompositionImpl(matrix);        RealMatrix l  = llt.getL();        RealMatrix lt = llt.getLT();        double norm = l.multiply(lt).subtract(matrix).getNorm();        assertEquals(0, norm, 1.0e-15);    }    /** test that L is lower triangular */    @Test    public void testLLowerTriangular() throws MathException {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        RealMatrix l = new CholeskyDecompositionImpl(matrix).getL();        for (int i = 0; i < l.getRowDimension(); i++) {            for (int j = i + 1; j < l.getColumnDimension(); j++) {                assertEquals(0.0, l.getEntry(i, j), 0.0);            }        }    }    /** test that LT is transpose of L */    @Test    public void testLTTransposed() throws MathException {        RealMatrix matrix = MatrixUtils.createRealMatrix(testData);        CholeskyDecomposition llt = new CholeskyDecompositionImpl(matrix);        RealMatrix l  = llt.getL();        RealMatrix lt = llt.getLT();        double norm = l.subtract(lt.transpose()).getNorm();        assertEquals(0, norm, 1.0e-15);    }    /** test matrices values */    @Test    public void testMatricesValues() throws MathException {        RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] {                {  1,  0,  0,  0,  0 },                {  2,  3,  0,  0,  0 },                {  4,  5,  6,  0,  0 },                {  7,  8,  9, 10,  0 },                { 11, 12, 13, 14, 15 }        });       CholeskyDecomposition llt =            new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(testData));        // check values against known references        RealMatrix l = llt.getL();        assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);        RealMatrix lt = llt.getLT();        assertEquals(0, lt.subtract(lRef.transpose()).getNorm(), 1.0e-13);        // check the same cached instance is returned the second time        assertTrue(l  == llt.getL());        assertTrue(lt == llt.getLT());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import java.util.Arrays;import java.util.Random;import junit.framework.TestCase;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.util.MathUtils;public class EigenDecompositionImplTest extends TestCase {    private double[] refValues;    private RealMatrix matrix;    public EigenDecompositionImplTest(String name) {        super(name);    }    public void testDimension1() {        RealMatrix matrix =            MatrixUtils.createRealMatrix(new double[][] { { 1.5 } });        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        assertEquals(1.5, ed.getRealEigenvalue(0), 1.0e-15);    }    public void testDimension2() {        RealMatrix matrix =            MatrixUtils.createRealMatrix(new double[][] {                    { 59.0, 12.0 },                    { 12.0, 66.0 }            });        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        assertEquals(75.0, ed.getRealEigenvalue(0), 1.0e-15);        assertEquals(50.0, ed.getRealEigenvalue(1), 1.0e-15);    }    public void testDimension3() {        RealMatrix matrix =            MatrixUtils.createRealMatrix(new double[][] {                                   {  39632.0, -4824.0, -16560.0 },                                   {  -4824.0,  8693.0,   7920.0 },                                   { -16560.0,  7920.0,  17300.0 }                               });        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        assertEquals(50000.0, ed.getRealEigenvalue(0), 3.0e-11);        assertEquals(12500.0, ed.getRealEigenvalue(1), 3.0e-11);        assertEquals( 3125.0, ed.getRealEigenvalue(2), 3.0e-11);    }    public void testDimension3MultipleRoot() {        RealMatrix matrix =            MatrixUtils.createRealMatrix(new double[][] {                    {  5,   10,   15 },                    { 10,   20,   30 },                    { 15,   30,   45 }            });        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        assertEquals(70.0, ed.getRealEigenvalue(0), 3.0e-11);        assertEquals(0.0,  ed.getRealEigenvalue(1), 3.0e-11);        assertEquals(0.0,  ed.getRealEigenvalue(2), 3.0e-11);    }    public void testDimension4WithSplit() {        RealMatrix matrix =            MatrixUtils.createRealMatrix(new double[][] {                                   {  0.784, -0.288,  0.000,  0.000 },                                   { -0.288,  0.616,  0.000,  0.000 },                                   {  0.000,  0.000,  0.164, -0.048 },                                   {  0.000,  0.000, -0.048,  0.136 }                               });        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);        assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);        assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);        assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);    }    public void testDimension4WithoutSplit() {        RealMatrix matrix =            MatrixUtils.createRealMatrix(new double[][] {                                   {  0.5608, -0.2016,  0.1152, -0.2976 },                                   { -0.2016,  0.4432, -0.2304,  0.1152 },                                   {  0.1152, -0.2304,  0.3088, -0.1344 },                                   { -0.2976,  0.1152, -0.1344,  0.3872 }                               });        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);        assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);        assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);        assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);    }    // the following test triggered an ArrayIndexOutOfBoundsException in commons-math 2.0    public void testMath308() {        double[] mainTridiagonal = {            22.330154644539597, 46.65485522478641, 17.393672330044705, 54.46687435351116, 80.17800767709437        };        double[] secondaryTridiagonal = {            13.04450406501361, -5.977590941539671, 2.9040909856707517, 7.1570352792841225        };        // the reference values have been computed using routine DSTEMR        // from the fortran library LAPACK version 3.2.1        double[] refEigenValues = {            82.044413207204002, 53.456697699894512, 52.536278520113882, 18.847969733754262, 14.138204224043099        };        RealVector[] refEigenVectors = {            new ArrayRealVector(new double[] { -0.000462690386766, -0.002118073109055,  0.011530080757413,  0.252322434584915,  0.967572088232592 }),            new ArrayRealVector(new double[] {  0.314647769490148,  0.750806415553905, -0.167700312025760, -0.537092972407375,  0.143854968127780 }),            new ArrayRealVector(new double[] {  0.222368839324646,  0.514921891363332, -0.021377019336614,  0.801196801016305, -0.207446991247740 }),            new ArrayRealVector(new double[] { -0.713933751051495,  0.190582113553930, -0.671410443368332,  0.056056055955050, -0.006541576993581 }),            new ArrayRealVector(new double[] { -0.584677060845929,  0.367177264979103,  0.721453187784497, -0.052971054621812,  0.005740715188257 })        };        EigenDecomposition decomposition =            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);        double[] eigenValues = decomposition.getRealEigenvalues();        for (int i = 0; i < refEigenValues.length; ++i) {            assertEquals(refEigenValues[i], eigenValues[i], 1.0e-5);            assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 2.0e-7);        }    }    public void testMathpbx02() {        double[] mainTridiagonal = {              7484.860960227216, 18405.28129035345, 13855.225609560746,             10016.708722343366, 559.8117399576674, 6750.190788301587,                71.21428769782159        };        double[] secondaryTridiagonal = {             -4175.088570476366,1975.7955858241994,5193.178422374075,              1995.286659169179,75.34535882933804,-234.0808002076056        };        // the reference values have been computed using routine DSTEMR        // from the fortran library LAPACK version 3.2.1        double[] refEigenValues = {                20654.744890306974412,16828.208208485466457,                6893.155912634994820,6757.083016675340332,                5887.799885688558788,64.309089923240379,                57.992628792736340        };        RealVector[] refEigenVectors = {                new ArrayRealVector(new double[] {-0.270356342026904, 0.852811091326997, 0.399639490702077, 0.198794657813990, 0.019739323307666, 0.000106983022327, -0.000001216636321}),                new ArrayRealVector(new double[] {0.179995273578326,-0.402807848153042,0.701870993525734,0.555058211014888,0.068079148898236,0.000509139115227,-0.000007112235617}),                new ArrayRealVector(new double[] {-0.399582721284727,-0.056629954519333,-0.514406488522827,0.711168164518580,0.225548081276367,0.125943999652923,-0.004321507456014}),                new ArrayRealVector(new double[] {0.058515721572821,0.010200130057739,0.063516274916536,-0.090696087449378,-0.017148420432597,0.991318870265707,-0.034707338554096}),                new ArrayRealVector(new double[] {0.855205995537564,0.327134656629775,-0.265382397060548,0.282690729026706,0.105736068025572,-0.009138126622039,0.000367751821196}),                new ArrayRealVector(new double[] {-0.002913069901144,-0.005177515777101,0.041906334478672,-0.109315918416258,0.436192305456741,0.026307315639535,0.891797507436344}),                new ArrayRealVector(new double[] {-0.005738311176435,-0.010207611670378,0.082662420517928,-0.215733886094368,0.861606487840411,-0.025478530652759,-0.451080697503958})        };        // the following line triggers the exception        EigenDecomposition decomposition =            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);        double[] eigenValues = decomposition.getRealEigenvalues();        for (int i = 0; i < refEigenValues.length; ++i) {            assertEquals(refEigenValues[i], eigenValues[i], 1.0e-3);            if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {                assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);            } else {                assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);            }        }    }    public void testMathpbx03() {        double[] mainTridiagonal = {            1809.0978259647177,3395.4763425956166,1832.1894584712693,3804.364873592377,            806.0482458637571,2403.656427234185,28.48691431556015        };        double[] secondaryTridiagonal = {            -656.8932064545833,-469.30804108920734,-1021.7714889369421,            -1152.540497328983,-939.9765163817368,-12.885877015422391        };        // the reference values have been computed using routine DSTEMR        // from the fortran library LAPACK version 3.2.1        double[] refEigenValues = {            4603.121913685183245,3691.195818048970978,2743.442955402465032,1657.596442107321764,            1336.797819095331306,30.129865209677519,17.035352085224986        };        RealVector[] refEigenVectors = {            new ArrayRealVector(new double[] {-0.036249830202337,0.154184732411519,-0.346016328392363,0.867540105133093,-0.294483395433451,0.125854235969548,-0.000354507444044}),            new ArrayRealVector(new double[] {-0.318654191697157,0.912992309960507,-0.129270874079777,-0.184150038178035,0.096521712579439,-0.070468788536461,0.000247918177736}),            new ArrayRealVector(new double[] {-0.051394668681147,0.073102235876933,0.173502042943743,-0.188311980310942,-0.327158794289386,0.905206581432676,-0.004296342252659}),            new ArrayRealVector(new double[] {0.838150199198361,0.193305209055716,-0.457341242126146,-0.166933875895419,0.094512811358535,0.119062381338757,-0.000941755685226}),            new ArrayRealVector(new double[] {0.438071395458547,0.314969169786246,0.768480630802146,0.227919171600705,-0.193317045298647,-0.170305467485594,0.001677380536009}),            new ArrayRealVector(new double[] {-0.003726503878741,-0.010091946369146,-0.067152015137611,-0.113798146542187,-0.313123000097908,-0.118940107954918,0.932862311396062}),            new ArrayRealVector(new double[] {0.009373003194332,0.025570377559400,0.170955836081348,0.291954519805750,0.807824267665706,0.320108347088646,0.360202112392266}),        };        // the following line triggers the exception        EigenDecomposition decomposition =            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);        double[] eigenValues = decomposition.getRealEigenvalues();        for (int i = 0; i < refEigenValues.length; ++i) {            assertEquals(refEigenValues[i], eigenValues[i], 1.0e-4);            if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {                assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);            } else {                assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);            }        }    }    /** test a matrix already in tridiagonal form. */    public void testTridiagonal() {        Random r = new Random(4366663527842l);        double[] ref = new double[30];        for (int i = 0; i < ref.length; ++i) {            if (i < 5) {                ref[i] = 2 * r.nextDouble() - 1;            } else {                ref[i] = 0.0001 * r.nextDouble() + 6;            }        }        Arrays.sort(ref);        TriDiagonalTransformer t =            new TriDiagonalTransformer(createTestMatrix(r, ref));        EigenDecomposition ed =            new EigenDecompositionImpl(t.getMainDiagonalRef(),                                       t.getSecondaryDiagonalRef(),                                       MathUtils.SAFE_MIN);        double[] eigenValues = ed.getRealEigenvalues();        assertEquals(ref.length, eigenValues.length);        for (int i = 0; i < ref.length; ++i) {            assertEquals(ref[ref.length - i - 1], eigenValues[i], 2.0e-14);        }    }    /** test dimensions */    public void testDimensions() {        final int m = matrix.getRowDimension();        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        assertEquals(m, ed.getV().getRowDimension());        assertEquals(m, ed.getV().getColumnDimension());        assertEquals(m, ed.getD().getColumnDimension());        assertEquals(m, ed.getD().getColumnDimension());        assertEquals(m, ed.getVT().getRowDimension());        assertEquals(m, ed.getVT().getColumnDimension());    }    /** test eigenvalues */    public void testEigenvalues() {        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        double[] eigenValues = ed.getRealEigenvalues();        assertEquals(refValues.length, eigenValues.length);        for (int i = 0; i < refValues.length; ++i) {            assertEquals(refValues[i], eigenValues[i], 3.0e-15);        }    }    /** test eigenvalues for a big matrix. */    public void testBigMatrix() {        Random r = new Random(17748333525117l);        double[] bigValues = new double[200];        for (int i = 0; i < bigValues.length; ++i) {            bigValues[i] = 2 * r.nextDouble() - 1;        }        Arrays.sort(bigValues);        EigenDecomposition ed =            new EigenDecompositionImpl(createTestMatrix(r, bigValues), MathUtils.SAFE_MIN);        double[] eigenValues = ed.getRealEigenvalues();        assertEquals(bigValues.length, eigenValues.length);        for (int i = 0; i < bigValues.length; ++i) {            assertEquals(bigValues[bigValues.length - i - 1], eigenValues[i], 2.0e-14);        }    }    /** test eigenvectors */    public void testEigenvectors() {        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        for (int i = 0; i < matrix.getRowDimension(); ++i) {            double lambda = ed.getRealEigenvalue(i);            RealVector v  = ed.getEigenvector(i);            RealVector mV = matrix.operate(v);            assertEquals(0, mV.subtract(v.mapMultiplyToSelf(lambda)).getNorm(), 1.0e-13);        }    }    /** test A = VDVt */    public void testAEqualVDVt() {        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);        RealMatrix v  = ed.getV();        RealMatrix d  = ed.getD();        RealMatrix vT = ed.getVT();        double norm = v.multiply(d).multiply(vT).subtract(matrix).getNorm();        assertEquals(0, norm, 6.0e-13);    }    /** test that V is orthogonal */    public void testVOrthogonal() {        RealMatrix v = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN).getV();        RealMatrix vTv = v.transpose().multiply(v);        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension());        assertEquals(0, vTv.subtract(id).getNorm(), 2.0e-13);    }    /** test diagonal matrix */    public void testDiagonal() {        double[] diagonal = new double[] { -3.0, -2.0, 2.0, 5.0 };        RealMatrix m = createDiagonalMatrix(diagonal, diagonal.length, diagonal.length);        EigenDecomposition ed = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN);        assertEquals(diagonal[0], ed.getRealEigenvalue(3), 2.0e-15);        assertEquals(diagonal[1], ed.getRealEigenvalue(2), 2.0e-15);        assertEquals(diagonal[2], ed.getRealEigenvalue(1), 2.0e-15);        assertEquals(diagonal[3], ed.getRealEigenvalue(0), 2.0e-15);    }    /**     * Matrix with eigenvalues {8, -1, -1}     */    public void testRepeatedEigenvalue() {        RealMatrix repeated = MatrixUtils.createRealMatrix(new double[][] {                {3,  2,  4},                {2,  0,  2},                {4,  2,  3}        });        EigenDecomposition ed = new EigenDecompositionImpl(repeated, MathUtils.SAFE_MIN);        checkEigenValues((new double[] {8, -1, -1}), ed, 1E-12);        checkEigenVector((new double[] {2, 1, 2}), ed, 1E-12);    }    /**     * Matrix with eigenvalues {2, 0, 12}     */    public void testDistinctEigenvalues() {        RealMatrix distinct = MatrixUtils.createRealMatrix(new double[][] {                {3, 1, -4},                {1, 3, -4},                {-4, -4, 8}        });        EigenDecomposition ed = new EigenDecompositionImpl(distinct, MathUtils.SAFE_MIN);        checkEigenValues((new double[] {2, 0, 12}), ed, 1E-12);        checkEigenVector((new double[] {1, -1, 0}), ed, 1E-12);        checkEigenVector((new double[] {1, 1, 1}), ed, 1E-12);        checkEigenVector((new double[] {-1, -1, 2}), ed, 1E-12);    }    /**     * Verifies operation on indefinite matrix     */    public void testZeroDivide() {        RealMatrix indefinite = MatrixUtils.createRealMatrix(new double [][] {                { 0.0, 1.0, -1.0 },                { 1.0, 1.0, 0.0 },                { -1.0,0.0, 1.0 }        });        EigenDecomposition ed = new EigenDecompositionImpl(indefinite, MathUtils.SAFE_MIN);        checkEigenValues((new double[] {2, 1, -1}), ed, 1E-12);        double isqrt3 = 1/FastMath.sqrt(3.0);        checkEigenVector((new double[] {isqrt3,isqrt3,-isqrt3}), ed, 1E-12);        double isqrt2 = 1/FastMath.sqrt(2.0);        checkEigenVector((new double[] {0.0,-isqrt2,-isqrt2}), ed, 1E-12);        double isqrt6 = 1/FastMath.sqrt(6.0);        checkEigenVector((new double[] {2*isqrt6,-isqrt6,isqrt6}), ed, 1E-12);    }    /**     * Verifies that the given EigenDecomposition has eigenvalues equivalent to     * the targetValues, ignoring the order of the values and allowing     * values to differ by tolerance.     */    protected void checkEigenValues(double[] targetValues,            EigenDecomposition ed, double tolerance) {        double[] observed = ed.getRealEigenvalues();        for (int i = 0; i < observed.length; i++) {            assertTrue(isIncludedValue(observed[i], targetValues, tolerance));            assertTrue(isIncludedValue(targetValues[i], observed, tolerance));        }    }    /**     * Returns true iff there is an entry within tolerance of value in     * searchArray.     */    private boolean isIncludedValue(double value, double[] searchArray,            double tolerance) {       boolean found = false;       int i = 0;       while (!found && i < searchArray.length) {           if (FastMath.abs(value - searchArray[i]) < tolerance) {               found = true;           }           i++;       }       return found;    }    /**     * Returns true iff eigenVector is a scalar multiple of one of the columns     * of ed.getV().  Does not try linear combinations - i.e., should only be     * used to find vectors in one-dimensional eigenspaces.     */    protected void checkEigenVector(double[] eigenVector,            EigenDecomposition ed, double tolerance) {        assertTrue(isIncludedColumn(eigenVector, ed.getV(), tolerance));    }    /**     * Returns true iff there is a column that is a scalar multiple of column     * in searchMatrix (modulo tolerance)     */    private boolean isIncludedColumn(double[] column, RealMatrix searchMatrix,            double tolerance) {        boolean found = false;        int i = 0;        while (!found && i < searchMatrix.getColumnDimension()) {            double multiplier = 1.0;            boolean matching = true;            int j = 0;            while (matching && j < searchMatrix.getRowDimension()) {                double colEntry = searchMatrix.getEntry(j, i);                // Use the first entry where both are non-zero as scalar                if (FastMath.abs(multiplier - 1.0) <= FastMath.ulp(1.0) && FastMath.abs(colEntry) > 1E-14                        && FastMath.abs(column[j]) > 1e-14) {                    multiplier = colEntry / column[j];                }                if (FastMath.abs(column[j] * multiplier - colEntry) > tolerance) {                    matching = false;                }                j++;            }            found = matching;            i++;        }        return found;    }    @Override    public void setUp() {        refValues = new double[] {                2.003, 2.002, 2.001, 1.001, 1.000, 0.001        };        matrix = createTestMatrix(new Random(35992629946426l), refValues);    }    @Override    public void tearDown() {        refValues = null;        matrix    = null;    }    static RealMatrix createTestMatrix(final Random r, final double[] eigenValues) {        final int n = eigenValues.length;        final RealMatrix v = createOrthogonalMatrix(r, n);        final RealMatrix d = createDiagonalMatrix(eigenValues, n, n);        return v.multiply(d).multiply(v.transpose());    }    public static RealMatrix createOrthogonalMatrix(final Random r, final int size) {        final double[][] data = new double[size][size];        for (int i = 0; i < size; ++i) {            final double[] dataI = data[i];            double norm2 = 0;            do {                // generate randomly row I                for (int j = 0; j < size; ++j) {                    dataI[j] = 2 * r.nextDouble() - 1;                }                // project the row in the subspace orthogonal to previous rows                for (int k = 0; k < i; ++k) {                    final double[] dataK = data[k];                    double dotProduct = 0;                    for (int j = 0; j < size; ++j) {                        dotProduct += dataI[j] * dataK[j];                    }                    for (int j = 0; j < size; ++j) {                        dataI[j] -= dotProduct * dataK[j];                    }                }                // normalize the row                norm2 = 0;                for (final double dataIJ : dataI) {                    norm2 += dataIJ * dataIJ;                }                final double inv = 1.0 / FastMath.sqrt(norm2);                for (int j = 0; j < size; ++j) {                    dataI[j] *= inv;                }            } while (norm2 * size < 0.01);        }        return MatrixUtils.createRealMatrix(data);    }    public static RealMatrix createDiagonalMatrix(final double[] diagonal,                                                  final int rows, final int columns) {        final double[][] dData = new double[rows][columns];        for (int i = 0; i < FastMath.min(rows, columns); ++i) {            dData[i][i] = diagonal[i];        }        return MatrixUtils.createRealMatrix(dData);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.dfp;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public class DfpDecTest {    private DfpField field;    private Dfp pinf;    private Dfp ninf;    @Before    public void setUp() {        // Some basic setup.  Define some constants and clear the status flags        field = new DfpField(20);        pinf = new DfpDec(field, 1).divide(new DfpDec(field, 0));        ninf = new DfpDec(field, -1).divide(new DfpDec(field, 0));        ninf.getField().clearIEEEFlags();    }    @After    public void tearDown() {        field = null;        pinf    = null;        ninf    = null;    }    // Generic test function.  Takes params x and y and tests them for     // equality.  Then checks the status flags against the flags argument.    // If the test fail, it prints the desc string    private void test(Dfp x, Dfp y, int flags, String desc) {        boolean b = x.equals(y);        if (!x.equals(y) && !x.unequal(y))  // NaNs involved             b = (x.toString().equals(y.toString()));        if (x.equals(new DfpDec(field, 0)))  // distinguish +/- zero            b = (b && (x.toString().equals(y.toString())));        b = (b && x.getField().getIEEEFlags() == flags);        if (!b)            Assert.assertTrue("assersion failed "+desc+" x = "+x.toString()+" flags = "+x.getField().getIEEEFlags(), b);        x.getField().clearIEEEFlags();    }    @Test    public void testRound()    {        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);        test(new DfpDec(field, "12345678901234567890"),             new DfpDec(field, "12345678901234568000"),             DfpField.FLAG_INEXACT, "Round #1");        test(new DfpDec(field, "0.12345678901234567890"),             new DfpDec(field, "0.12345678901234568"),             DfpField.FLAG_INEXACT, "Round #2");        test(new DfpDec(field, "0.12345678901234567500"),             new DfpDec(field, "0.12345678901234568"),             DfpField.FLAG_INEXACT, "Round #3");        test(new DfpDec(field, "0.12345678901234568500"),             new DfpDec(field, "0.12345678901234568"),             DfpField.FLAG_INEXACT, "Round #4");        test(new DfpDec(field, "0.12345678901234568501"),             new DfpDec(field, "0.12345678901234569"),             DfpField.FLAG_INEXACT, "Round #5");        test(new DfpDec(field, "0.12345678901234568499"),             new DfpDec(field, "0.12345678901234568"),             DfpField.FLAG_INEXACT, "Round #6");        test(new DfpDec(field, "1.2345678901234567890"),             new DfpDec(field, "1.2345678901234568"),             DfpField.FLAG_INEXACT, "Round #7");        test(new DfpDec(field, "1.2345678901234567500"),             new DfpDec(field, "1.2345678901234568"),             DfpField.FLAG_INEXACT, "Round #8");        test(new DfpDec(field, "1.2345678901234568500"),             new DfpDec(field, "1.2345678901234568"),             DfpField.FLAG_INEXACT, "Round #9");        test(new DfpDec(field, "1.2345678901234568000").add(new DfpDec(field, ".0000000000000000501")),             new DfpDec(field, "1.2345678901234569"),             DfpField.FLAG_INEXACT, "Round #10");        test(new DfpDec(field, "1.2345678901234568499"),             new DfpDec(field, "1.2345678901234568"),             DfpField.FLAG_INEXACT, "Round #11");        test(new DfpDec(field, "12.345678901234567890"),             new DfpDec(field, "12.345678901234568"),             DfpField.FLAG_INEXACT, "Round #12");        test(new DfpDec(field, "12.345678901234567500"),             new DfpDec(field, "12.345678901234568"),             DfpField.FLAG_INEXACT, "Round #13");        test(new DfpDec(field, "12.345678901234568500"),             new DfpDec(field, "12.345678901234568"),             DfpField.FLAG_INEXACT, "Round #14");        test(new DfpDec(field, "12.345678901234568").add(new DfpDec(field, ".000000000000000501")),             new DfpDec(field, "12.345678901234569"),             DfpField.FLAG_INEXACT, "Round #15");        test(new DfpDec(field, "12.345678901234568499"),             new DfpDec(field, "12.345678901234568"),             DfpField.FLAG_INEXACT, "Round #16");        test(new DfpDec(field, "123.45678901234567890"),             new DfpDec(field, "123.45678901234568"),             DfpField.FLAG_INEXACT, "Round #17");        test(new DfpDec(field, "123.45678901234567500"),             new DfpDec(field, "123.45678901234568"),             DfpField.FLAG_INEXACT, "Round #18");        test(new DfpDec(field, "123.45678901234568500"),             new DfpDec(field, "123.45678901234568"),             DfpField.FLAG_INEXACT, "Round #19");        test(new DfpDec(field, "123.456789012345685").add(new DfpDec(field, ".00000000000000501")),             new DfpDec(field, "123.45678901234569"),             DfpField.FLAG_INEXACT, "Round #20");        test(new DfpDec(field, "123.45678901234568499"),             new DfpDec(field, "123.45678901234568"),             DfpField.FLAG_INEXACT, "Round #21");        field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN);        // Round down        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.9")),             new DfpDec(field, "12345678901234567"),             DfpField.FLAG_INEXACT, "Round #22");        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.99999999")),             new DfpDec(field, "12345678901234567"),             DfpField.FLAG_INEXACT, "Round #23");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.99999999")),             new DfpDec(field, "-12345678901234567"),             DfpField.FLAG_INEXACT, "Round #24");        field.setRoundingMode(DfpField.RoundingMode.ROUND_UP);        // Round up        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.1")),             new DfpDec(field, "12345678901234568"),             DfpField.FLAG_INEXACT, "Round #25");        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.0001")),             new DfpDec(field, "12345678901234568"),             DfpField.FLAG_INEXACT, "Round #26");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.1")),             new DfpDec(field, "-12345678901234568"),             DfpField.FLAG_INEXACT, "Round #27");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.0001")),             new DfpDec(field, "-12345678901234568"),             DfpField.FLAG_INEXACT, "Round #28");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "0")),             new DfpDec(field, "-12345678901234567"),             0, "Round #28.5");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP);        // Round half up        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.499999999999")),             new DfpDec(field, "12345678901234567"),             DfpField.FLAG_INEXACT, "Round #29");        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.50000001")),             new DfpDec(field, "12345678901234568"),             DfpField.FLAG_INEXACT, "Round #30");        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.5")),             new DfpDec(field, "12345678901234568"),             DfpField.FLAG_INEXACT, "Round #30.5");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.499999999999")),             new DfpDec(field, "-12345678901234567"),             DfpField.FLAG_INEXACT, "Round #31");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.50000001")),             new DfpDec(field, "-12345678901234568"),             DfpField.FLAG_INEXACT, "Round #32");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN);        // Round half down        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.5001")),             new DfpDec(field, "12345678901234568"),             DfpField.FLAG_INEXACT, "Round #33");        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.5000")),             new DfpDec(field, "12345678901234567"),             DfpField.FLAG_INEXACT, "Round #34");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.5001")),             new DfpDec(field, "-12345678901234568"),             DfpField.FLAG_INEXACT, "Round #35");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.6")),             new DfpDec(field, "-12345678901234568"),             DfpField.FLAG_INEXACT, "Round #35.5");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.5000")),             new DfpDec(field, "-12345678901234567"),             DfpField.FLAG_INEXACT, "Round #36");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD);        // Round half odd        test(new DfpDec(field, "12345678901234568").add(new DfpDec(field, "0.5000")),             new DfpDec(field, "12345678901234569"),             DfpField.FLAG_INEXACT, "Round #37");        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.5000")),             new DfpDec(field, "12345678901234567"),             DfpField.FLAG_INEXACT, "Round #38");        test(new DfpDec(field, "-12345678901234568").add(new DfpDec(field, "-0.5000")),             new DfpDec(field, "-12345678901234569"),             DfpField.FLAG_INEXACT, "Round #39");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.5000")),             new DfpDec(field, "-12345678901234567"),             DfpField.FLAG_INEXACT, "Round #40");        field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL);        // Round ceil        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.0001")),             new DfpDec(field, "12345678901234568"),             DfpField.FLAG_INEXACT, "Round #41");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.9999")),             new DfpDec(field, "-12345678901234567"),             DfpField.FLAG_INEXACT, "Round #42");        field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR);        // Round floor        test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.9999")),             new DfpDec(field, "12345678901234567"),             DfpField.FLAG_INEXACT, "Round #43");        test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.0001")),             new DfpDec(field, "-12345678901234568"),             DfpField.FLAG_INEXACT, "Round #44");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);  // reset    }    @Test    public void testRoundDecimal10()    {        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);        test(new Decimal10(field, "1234567891234567890"),             new Decimal10(field, "1234567891000000000"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #1");        test(new Decimal10(field, "0.1234567891634567890"),             new Decimal10(field, "0.1234567892"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #2");        test(new Decimal10(field, "0.1234567891500000000"),             new Decimal10(field, "0.1234567892"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #3");        test(new Decimal10(field, "0.1234567890500"),             new Decimal10(field, "0.1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #4");        test(new Decimal10(field, "0.1234567890501"),             new Decimal10(field, "0.1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #5");        test(new Decimal10(field, "0.1234567890499"),             new Decimal10(field, "0.1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #6");        test(new Decimal10(field, "1.234567890890"),             new Decimal10(field, "1.234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #7");        test(new Decimal10(field, "1.234567891500"),             new Decimal10(field, "1.234567892"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #8");        test(new Decimal10(field, "1.234567890500"),             new Decimal10(field, "1.234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #9");        test(new Decimal10(field, "1.234567890000").add(new Decimal10(field, ".000000000501")),             new Decimal10(field, "1.234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #10");        test(new Decimal10(field, "1.234567890499"),             new Decimal10(field, "1.234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #11");        test(new Decimal10(field, "12.34567890890"),             new Decimal10(field, "12.34567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #12");        test(new Decimal10(field, "12.34567891500"),             new Decimal10(field, "12.34567892"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #13");        test(new Decimal10(field, "12.34567890500"),             new Decimal10(field, "12.34567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #14");        test(new Decimal10(field, "12.34567890").add(new Decimal10(field, ".00000000501")),             new Decimal10(field, "12.34567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #15");        test(new Decimal10(field, "12.34567890499"),             new Decimal10(field, "12.34567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #16");        test(new Decimal10(field, "123.4567890890"),             new Decimal10(field, "123.4567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #17");        test(new Decimal10(field, "123.4567891500"),             new Decimal10(field, "123.4567892"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #18");        test(new Decimal10(field, "123.4567890500"),             new Decimal10(field, "123.4567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #19");        test(new Decimal10(field, "123.4567890").add(new Decimal10(field, ".0000000501")),             new Decimal10(field, "123.4567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #20");        test(new Decimal10(field, "123.4567890499"),             new Decimal10(field, "123.4567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #21");        field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN);        // RoundDecimal10 down        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.9")),             new Decimal10(field, "1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #22");        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.99999999")),             new Decimal10(field, "1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #23");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.99999999")),             new Decimal10(field, "-1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #24");        field.setRoundingMode(DfpField.RoundingMode.ROUND_UP);        // RoundDecimal10 up        test(new Decimal10(field, 1234567890).add(new Decimal10(field, "0.1")),             new Decimal10(field, 1234567891l),             DfpField.FLAG_INEXACT, "RoundDecimal10 #25");        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.0001")),             new Decimal10(field, "1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #26");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.1")),             new Decimal10(field, "-1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #27");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.0001")),             new Decimal10(field, "-1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #28");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "0")),             new Decimal10(field, "-1234567890"),             0, "RoundDecimal10 #28.5");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP);        // RoundDecimal10 half up        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.4999999999")),             new Decimal10(field, "1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #29");        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.50000001")),             new Decimal10(field, "1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #30");        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.5")),             new Decimal10(field, "1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #30.5");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.4999999999")),             new Decimal10(field, "-1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #31");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.50000001")),             new Decimal10(field, "-1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #32");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN);        // RoundDecimal10 half down        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.5001")),             new Decimal10(field, "1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #33");        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.5000")),             new Decimal10(field, "1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #34");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.5001")),             new Decimal10(field, "-1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #35");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.6")),             new Decimal10(field, "-1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #35.5");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.5000")),             new Decimal10(field, "-1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #36");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD);        // RoundDecimal10 half odd        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.5000")),             new Decimal10(field, "1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #37");        test(new Decimal10(field, "1234567891").add(new Decimal10(field, "0.5000")),             new Decimal10(field, "1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #38");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.5000")),             new Decimal10(field, "-1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #39");        test(new Decimal10(field, "-1234567891").add(new Decimal10(field, "-0.5000")),             new Decimal10(field, "-1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #40");        field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL);        // RoundDecimal10 ceil        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.0001")),             new Decimal10(field, "1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #41");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.9999")),             new Decimal10(field, "-1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #42");        field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR);        // RoundDecimal10 floor        test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.9999")),             new Decimal10(field, "1234567890"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #43");        test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.0001")),             new Decimal10(field, "-1234567891"),             DfpField.FLAG_INEXACT, "RoundDecimal10 #44");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);  // reset    }    @Test    public void testNextAfter()    {        test(new DfpDec(field, 1).nextAfter(pinf),             new DfpDec(field, "1.0000000000000001"),             0, "NextAfter #1");        test(new DfpDec(field, "1.0000000000000001").nextAfter(ninf),             new DfpDec(field, 1),             0, "NextAfter #1.5");        test(new DfpDec(field, 1).nextAfter(ninf),             new DfpDec(field, "0.99999999999999999"),             0, "NextAfter #2");        test(new DfpDec(field, "0.99999999999999999").nextAfter(new DfpDec(field, 2)),             new DfpDec(field, 1),             0, "NextAfter #3");        test(new DfpDec(field, -1).nextAfter(ninf),             new DfpDec(field, "-1.0000000000000001"),             0, "NextAfter #4");        test(new DfpDec(field, -1).nextAfter(pinf),             new DfpDec(field, "-0.99999999999999999"),             0, "NextAfter #5");        test(new DfpDec(field, "-0.99999999999999999").nextAfter(new DfpDec(field, -2)),             new DfpDec(field, (byte) -1),             0, "NextAfter #6");        test(new DfpDec(field, (byte) 2).nextAfter(new DfpDec(field, 2)),             new DfpDec(field, 2l),             0, "NextAfter #7");        test(new DfpDec(field, 0).nextAfter(new DfpDec(field, 0)),             new DfpDec(field, 0),             0, "NextAfter #8");        test(new DfpDec(field, -2).nextAfter(new DfpDec(field, -2)),             new DfpDec(field, -2),             0, "NextAfter #9");        test(new DfpDec(field, 0).nextAfter(new DfpDec(field, 1)),             new DfpDec(field, "1e-131092"),             DfpField.FLAG_UNDERFLOW, "NextAfter #10");        test(new DfpDec(field, 0).nextAfter(new DfpDec(field, -1)),             new DfpDec(field, "-1e-131092"),             DfpField.FLAG_UNDERFLOW, "NextAfter #11");        test(new DfpDec(field, "-1e-131092").nextAfter(pinf),             new DfpDec(field, "-0"),             DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, "Next After #12");        test(new DfpDec(field, "1e-131092").nextAfter(ninf),              new DfpDec(field, "0"),             DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, "Next After #13");        test(new DfpDec(field, "9.9999999999999999e131078").nextAfter(pinf),             pinf,             DfpField.FLAG_OVERFLOW|DfpField.FLAG_INEXACT, "Next After #14");    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.dfp;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public class DfpTest {    private DfpField field;    private Dfp pinf;    private Dfp ninf;    private Dfp nan;    private Dfp snan;    private Dfp qnan;    @Before    public void setUp() {        // Some basic setup.  Define some constants and clear the status flags        field = new DfpField(20);        pinf = field.newDfp("1").divide(field.newDfp("0"));        ninf = field.newDfp("-1").divide(field.newDfp("0"));        nan = field.newDfp("0").divide(field.newDfp("0"));        snan = field.newDfp((byte)1, Dfp.SNAN);        qnan = field.newDfp((byte)1, Dfp.QNAN);        ninf.getField().clearIEEEFlags();    }    @After    public void tearDown() {        field = null;        pinf    = null;        ninf    = null;        nan     = null;        snan    = null;        qnan    = null;    }    // Generic test function.  Takes params x and y and tests them for     // equality.  Then checks the status flags against the flags argument.    // If the test fail, it prints the desc string    private void test(Dfp x, Dfp y, int flags, String desc)    {        boolean b = x.equals(y);        if (!x.equals(y) && !x.unequal(y))  // NaNs involved             b = (x.toString().equals(y.toString()));        if (x.equals(field.newDfp("0")))  // distinguish +/- zero            b = (b && (x.toString().equals(y.toString())));        b = (b && x.getField().getIEEEFlags() == flags);        if (!b)            Assert.assertTrue("assersion failed "+desc+" x = "+x.toString()+" flags = "+x.getField().getIEEEFlags(), b);        x.getField().clearIEEEFlags();    }    @Test    public void testByteConstructor() {        Assert.assertEquals("0.", new Dfp(field, (byte) 0).toString());        Assert.assertEquals("1.", new Dfp(field, (byte) 1).toString());        Assert.assertEquals("-1.", new Dfp(field, (byte) -1).toString());        Assert.assertEquals("-128.", new Dfp(field, Byte.MIN_VALUE).toString());        Assert.assertEquals("127.", new Dfp(field, Byte.MAX_VALUE).toString());    }    @Test    public void testIntConstructor() {        Assert.assertEquals("0.", new Dfp(field, 0).toString());        Assert.assertEquals("1.", new Dfp(field, 1).toString());        Assert.assertEquals("-1.", new Dfp(field, -1).toString());        Assert.assertEquals("1234567890.", new Dfp(field, 1234567890).toString());        Assert.assertEquals("-1234567890.", new Dfp(field, -1234567890).toString());        Assert.assertEquals("-2147483648.", new Dfp(field, Integer.MIN_VALUE).toString());        Assert.assertEquals("2147483647.", new Dfp(field, Integer.MAX_VALUE).toString());    }    @Test    public void testLongConstructor() {        Assert.assertEquals("0.", new Dfp(field, 0l).toString());        Assert.assertEquals("1.", new Dfp(field, 1l).toString());        Assert.assertEquals("-1.", new Dfp(field, -1l).toString());        Assert.assertEquals("1234567890.", new Dfp(field, 1234567890l).toString());        Assert.assertEquals("-1234567890.", new Dfp(field, -1234567890l).toString());        Assert.assertEquals("-9223372036854775808.", new Dfp(field, Long.MIN_VALUE).toString());        Assert.assertEquals("9223372036854775807.", new Dfp(field, Long.MAX_VALUE).toString());    }    /*     *  Test addition     */    @Test    public void testAdd()    {        test(field.newDfp("1").add(field.newDfp("1")),      // Basic tests   1+1 = 2             field.newDfp("2"),              0, "Add #1");        test(field.newDfp("1").add(field.newDfp("-1")),     // 1 + (-1) = 0             field.newDfp("0"),              0, "Add #2");        test(field.newDfp("-1").add(field.newDfp("1")),     // (-1) + 1 = 0             field.newDfp("0"),              0, "Add #3");        test(field.newDfp("-1").add(field.newDfp("-1")),     // (-1) + (-1) = -2             field.newDfp("-2"),              0, "Add #4");        // rounding mode is round half even        test(field.newDfp("1").add(field.newDfp("1e-16")),     // rounding on add             field.newDfp("1.0000000000000001"),              0, "Add #5");        test(field.newDfp("1").add(field.newDfp("1e-17")),     // rounding on add             field.newDfp("1"),              DfpField.FLAG_INEXACT, "Add #6");        test(field.newDfp("0.90999999999999999999").add(field.newDfp("0.1")),     // rounding on add             field.newDfp("1.01"),              DfpField.FLAG_INEXACT, "Add #7");        test(field.newDfp(".10000000000000005000").add(field.newDfp(".9")),     // rounding on add             field.newDfp("1."),              DfpField.FLAG_INEXACT, "Add #8");        test(field.newDfp(".10000000000000015000").add(field.newDfp(".9")),     // rounding on add             field.newDfp("1.0000000000000002"),              DfpField.FLAG_INEXACT, "Add #9");        test(field.newDfp(".10000000000000014999").add(field.newDfp(".9")),     // rounding on add             field.newDfp("1.0000000000000001"),              DfpField.FLAG_INEXACT, "Add #10");        test(field.newDfp(".10000000000000015001").add(field.newDfp(".9")),     // rounding on add             field.newDfp("1.0000000000000002"),              DfpField.FLAG_INEXACT, "Add #11");        test(field.newDfp(".11111111111111111111").add(field.newDfp("11.1111111111111111")), // rounding on add             field.newDfp("11.22222222222222222222"),              DfpField.FLAG_INEXACT, "Add #12");        test(field.newDfp(".11111111111111111111").add(field.newDfp("1111111111111111.1111")), // rounding on add             field.newDfp("1111111111111111.2222"),              DfpField.FLAG_INEXACT, "Add #13");        test(field.newDfp(".11111111111111111111").add(field.newDfp("11111111111111111111")), // rounding on add             field.newDfp("11111111111111111111"),              DfpField.FLAG_INEXACT, "Add #14");        test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("-1e131052")), // overflow on add             field.newDfp("9.9999999999999999998e131071"),              0, "Add #15");        test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("1e131052")), // overflow on add             pinf,              DfpField.FLAG_OVERFLOW, "Add #16");        test(field.newDfp("-9.9999999999999999999e131071").add(field.newDfp("-1e131052")), // overflow on add             ninf,              DfpField.FLAG_OVERFLOW, "Add #17");        test(field.newDfp("-9.9999999999999999999e131071").add(field.newDfp("1e131052")), // overflow on add             field.newDfp("-9.9999999999999999998e131071"),              0, "Add #18");        test(field.newDfp("1e-131072").add(field.newDfp("1e-131072")), // underflow on add             field.newDfp("2e-131072"),              0, "Add #19");        test(field.newDfp("1.0000000000000001e-131057").add(field.newDfp("-1e-131057")), // underflow on add             field.newDfp("1e-131073"),              DfpField.FLAG_UNDERFLOW, "Add #20");        test(field.newDfp("1.1e-131072").add(field.newDfp("-1e-131072")), // underflow on add             field.newDfp("1e-131073"),              DfpField.FLAG_UNDERFLOW, "Add #21");        test(field.newDfp("1.0000000000000001e-131072").add(field.newDfp("-1e-131072")), // underflow on add             field.newDfp("1e-131088"),              DfpField.FLAG_UNDERFLOW, "Add #22");        test(field.newDfp("1.0000000000000001e-131078").add(field.newDfp("-1e-131078")), // underflow on add             field.newDfp("0"),              DfpField.FLAG_UNDERFLOW, "Add #23");        test(field.newDfp("1.0").add(field.newDfp("-1e-20")), // loss of precision on alignment?             field.newDfp("0.99999999999999999999"),              0, "Add #23.1");        test(field.newDfp("-0.99999999999999999999").add(field.newDfp("1")), // proper normalization?             field.newDfp("0.00000000000000000001"),              0, "Add #23.2");        test(field.newDfp("1").add(field.newDfp("0")), // adding zeros             field.newDfp("1"),              0, "Add #24");        test(field.newDfp("0").add(field.newDfp("0")), // adding zeros             field.newDfp("0"),              0, "Add #25");        test(field.newDfp("-0").add(field.newDfp("0")), // adding zeros             field.newDfp("0"),              0, "Add #26");        test(field.newDfp("0").add(field.newDfp("-0")), // adding zeros             field.newDfp("0"),              0, "Add #27");        test(field.newDfp("-0").add(field.newDfp("-0")), // adding zeros             field.newDfp("-0"),              0, "Add #28");        test(field.newDfp("1e-20").add(field.newDfp("0")), // adding zeros             field.newDfp("1e-20"),              0, "Add #29");        test(field.newDfp("1e-40").add(field.newDfp("0")), // adding zeros             field.newDfp("1e-40"),              0, "Add #30");        test(pinf.add(ninf), // adding infinities             nan,              DfpField.FLAG_INVALID, "Add #31");        test(ninf.add(pinf), // adding infinities             nan,              DfpField.FLAG_INVALID, "Add #32");        test(ninf.add(ninf), // adding infinities             ninf,              0, "Add #33");        test(pinf.add(pinf), // adding infinities             pinf,              0, "Add #34");        test(pinf.add(field.newDfp("0")), // adding infinities             pinf,              0, "Add #35");        test(pinf.add(field.newDfp("-1e131071")), // adding infinities             pinf,              0, "Add #36");        test(pinf.add(field.newDfp("1e131071")), // adding infinities             pinf,              0, "Add #37");        test(field.newDfp("0").add(pinf), // adding infinities             pinf,              0, "Add #38");        test(field.newDfp("-1e131071").add(pinf), // adding infinities             pinf,              0, "Add #39");        test(field.newDfp("1e131071").add(pinf), // adding infinities             pinf,              0, "Add #40");        test(ninf.add(field.newDfp("0")), // adding infinities             ninf,              0, "Add #41");        test(ninf.add(field.newDfp("-1e131071")), // adding infinities             ninf,              0, "Add #42");        test(ninf.add(field.newDfp("1e131071")), // adding infinities             ninf,              0, "Add #43");        test(field.newDfp("0").add(ninf), // adding infinities             ninf,              0, "Add #44");        test(field.newDfp("-1e131071").add(ninf), // adding infinities             ninf,              0, "Add #45");        test(field.newDfp("1e131071").add(ninf), // adding infinities             ninf,              0, "Add #46");        test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("5e131051")),  // overflow             pinf,             DfpField.FLAG_OVERFLOW, "Add #47");        test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("4.9999999999999999999e131051")),  // overflow             field.newDfp("9.9999999999999999999e131071"),             DfpField.FLAG_INEXACT, "Add #48");        test(nan.add(field.newDfp("1")),             nan,             0, "Add #49");        test(field.newDfp("1").add(nan),             nan,             0, "Add #50");        test(field.newDfp("12345678123456781234").add(field.newDfp("0.12345678123456781234")),             field.newDfp("12345678123456781234"),             DfpField.FLAG_INEXACT, "Add #51");        test(field.newDfp("12345678123456781234").add(field.newDfp("123.45678123456781234")),             field.newDfp("12345678123456781357"),             DfpField.FLAG_INEXACT, "Add #52");        test(field.newDfp("123.45678123456781234").add(field.newDfp("12345678123456781234")),             field.newDfp("12345678123456781357"),             DfpField.FLAG_INEXACT, "Add #53");        test(field.newDfp("12345678123456781234").add(field.newDfp(".00001234567812345678")),             field.newDfp("12345678123456781234"),             DfpField.FLAG_INEXACT, "Add #54");        test(field.newDfp("12345678123456781234").add(field.newDfp(".00000000123456781234")),             field.newDfp("12345678123456781234"),             DfpField.FLAG_INEXACT, "Add #55");        test(field.newDfp("-0").add(field.newDfp("-0")),             field.newDfp("-0"),             0, "Add #56");         test(field.newDfp("0").add(field.newDfp("-0")),             field.newDfp("0"),             0, "Add #57");         test(field.newDfp("-0").add(field.newDfp("0")),             field.newDfp("0"),             0, "Add #58");         test(field.newDfp("0").add(field.newDfp("0")),             field.newDfp("0"),             0, "Add #59");     }    ////////////////////////////////////////////////////////////////////////////////////////////////////////    // Test comparisons    // utility function to help test comparisons    private void cmptst(Dfp a, Dfp b, String op, boolean result, double num)    {        if (op == "equal")            if (a.equals(b) != result)                Assert.fail("assersion failed.  "+op+" compare #"+num);        if (op == "unequal")            if (a.unequal(b) != result)                Assert.fail("assersion failed.  "+op+" compare #"+num);        if (op == "lessThan")            if (a.lessThan(b) != result)                Assert.fail("assersion failed.  "+op+" compare #"+num);        if (op == "greaterThan")            if (a.greaterThan(b) != result)                Assert.fail("assersion failed.  "+op+" compare #"+num);    }    @Test    public void  testCompare()    {        // test equal() comparison        // check zero vs. zero        field.clearIEEEFlags();        cmptst(field.newDfp("0"), field.newDfp("0"), "equal", true, 1);         // 0 == 0        cmptst(field.newDfp("0"), field.newDfp("-0"), "equal", true, 2);        // 0 == -0        cmptst(field.newDfp("-0"), field.newDfp("-0"), "equal", true, 3);       // -0 == -0        cmptst(field.newDfp("-0"), field.newDfp("0"), "equal", true, 4);        // -0 == 0        // check zero vs normal numbers        cmptst(field.newDfp("0"), field.newDfp("1"), "equal", false, 5);         // 0 == 1        cmptst(field.newDfp("1"), field.newDfp("0"), "equal", false, 6);         // 1 == 0        cmptst(field.newDfp("-1"), field.newDfp("0"), "equal", false, 7);        // -1 == 0        cmptst(field.newDfp("0"), field.newDfp("-1"), "equal", false, 8);        // 0 == -1        cmptst(field.newDfp("0"), field.newDfp("1e-131072"), "equal", false, 9); // 0 == 1e-131072        // check flags         if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        cmptst(field.newDfp("0"), field.newDfp("1e-131078"), "equal", false, 10); // 0 == 1e-131078        // check flags  -- underflow should be set        if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        field.clearIEEEFlags();        cmptst(field.newDfp("0"), field.newDfp("1e+131071"), "equal", false, 11); // 0 == 1e+131071        // check zero vs infinities        cmptst(field.newDfp("0"), pinf, "equal", false, 12);    // 0 == pinf        cmptst(field.newDfp("0"), ninf, "equal", false, 13);    // 0 == ninf        cmptst(field.newDfp("-0"), pinf, "equal", false, 14);   // -0 == pinf        cmptst(field.newDfp("-0"), ninf, "equal", false, 15);   // -0 == ninf        cmptst(pinf, field.newDfp("0"), "equal", false, 16);    // pinf == 0        cmptst(ninf, field.newDfp("0"), "equal", false, 17);    // ninf == 0        cmptst(pinf, field.newDfp("-0"), "equal", false, 18);   // pinf == -0        cmptst(ninf, field.newDfp("-0"), "equal", false, 19);   // ninf == -0        cmptst(ninf, pinf, "equal", false, 19.10);     // ninf == pinf        cmptst(pinf, ninf, "equal", false, 19.11);     // pinf == ninf        cmptst(pinf, pinf, "equal", true, 19.12);     // pinf == pinf        cmptst(ninf, ninf, "equal", true, 19.13);     // ninf == ninf        // check some normal numbers        cmptst(field.newDfp("1"), field.newDfp("1"), "equal", true, 20);   // 1 == 1        cmptst(field.newDfp("1"), field.newDfp("-1"), "equal", false, 21);   // 1 == -1        cmptst(field.newDfp("-1"), field.newDfp("-1"), "equal", true, 22);   // -1 == -1        cmptst(field.newDfp("1"), field.newDfp("1.0000000000000001"), "equal", false, 23);   // 1 == 1.0000000000000001        // The tests below checks to ensure that comparisons don't set FLAG_INEXACT        // 100000 == 1.0000000000000001        cmptst(field.newDfp("1e20"), field.newDfp("1.0000000000000001"), "equal", false, 24);        if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        cmptst(field.newDfp("0.000001"), field.newDfp("1e-6"), "equal", true, 25);        // check some nans -- nans shouldnt equal anything        cmptst(snan, snan, "equal", false, 27);        cmptst(qnan, qnan, "equal", false, 28);        cmptst(snan, qnan, "equal", false, 29);        cmptst(qnan, snan, "equal", false, 30);        cmptst(qnan, field.newDfp("0"), "equal", false, 31);        cmptst(snan, field.newDfp("0"), "equal", false, 32);        cmptst(field.newDfp("0"), snan, "equal", false, 33);        cmptst(field.newDfp("0"), qnan, "equal", false, 34);        cmptst(qnan, pinf, "equal", false, 35);        cmptst(snan, pinf, "equal", false, 36);        cmptst(pinf, snan, "equal", false, 37);        cmptst(pinf, qnan, "equal", false, 38);        cmptst(qnan, ninf, "equal", false, 39);        cmptst(snan, ninf, "equal", false, 40);        cmptst(ninf, snan, "equal", false, 41);        cmptst(ninf, qnan, "equal", false, 42);        cmptst(qnan, field.newDfp("-1"), "equal", false, 43);        cmptst(snan, field.newDfp("-1"), "equal", false, 44);        cmptst(field.newDfp("-1"), snan, "equal", false, 45);        cmptst(field.newDfp("-1"), qnan, "equal", false, 46);        cmptst(qnan, field.newDfp("1"), "equal", false, 47);        cmptst(snan, field.newDfp("1"), "equal", false, 48);        cmptst(field.newDfp("1"), snan, "equal", false, 49);        cmptst(field.newDfp("1"), qnan, "equal", false, 50);        cmptst(snan.negate(), snan, "equal", false, 51);        cmptst(qnan.negate(), qnan, "equal", false, 52);        //        // Tests for un equal  -- do it all over again        //        cmptst(field.newDfp("0"), field.newDfp("0"), "unequal", false, 1);         // 0 == 0        cmptst(field.newDfp("0"), field.newDfp("-0"), "unequal", false, 2);        // 0 == -0        cmptst(field.newDfp("-0"), field.newDfp("-0"), "unequal", false, 3);       // -0 == -0        cmptst(field.newDfp("-0"), field.newDfp("0"), "unequal", false, 4);        // -0 == 0        // check zero vs normal numbers        cmptst(field.newDfp("0"), field.newDfp("1"), "unequal", true, 5);         // 0 == 1        cmptst(field.newDfp("1"), field.newDfp("0"), "unequal", true, 6);         // 1 == 0        cmptst(field.newDfp("-1"), field.newDfp("0"), "unequal", true, 7);        // -1 == 0        cmptst(field.newDfp("0"), field.newDfp("-1"), "unequal", true, 8);        // 0 == -1        cmptst(field.newDfp("0"), field.newDfp("1e-131072"), "unequal", true, 9); // 0 == 1e-131072        // check flags         if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        cmptst(field.newDfp("0"), field.newDfp("1e-131078"), "unequal", true, 10); // 0 == 1e-131078        // check flags  -- underflow should be set        if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        field.clearIEEEFlags();        cmptst(field.newDfp("0"), field.newDfp("1e+131071"), "unequal", true, 11); // 0 == 1e+131071        // check zero vs infinities        cmptst(field.newDfp("0"), pinf, "unequal", true, 12);    // 0 == pinf        cmptst(field.newDfp("0"), ninf, "unequal", true, 13);    // 0 == ninf        cmptst(field.newDfp("-0"), pinf, "unequal", true, 14);   // -0 == pinf        cmptst(field.newDfp("-0"), ninf, "unequal", true, 15);   // -0 == ninf        cmptst(pinf, field.newDfp("0"), "unequal", true, 16);    // pinf == 0        cmptst(ninf, field.newDfp("0"), "unequal", true, 17);    // ninf == 0        cmptst(pinf, field.newDfp("-0"), "unequal", true, 18);   // pinf == -0        cmptst(ninf, field.newDfp("-0"), "unequal", true, 19);   // ninf == -0        cmptst(ninf, pinf, "unequal", true, 19.10);     // ninf == pinf        cmptst(pinf, ninf, "unequal", true, 19.11);     // pinf == ninf        cmptst(pinf, pinf, "unequal", false, 19.12);     // pinf == pinf        cmptst(ninf, ninf, "unequal", false, 19.13);     // ninf == ninf        // check some normal numbers        cmptst(field.newDfp("1"), field.newDfp("1"), "unequal", false, 20);   // 1 == 1        cmptst(field.newDfp("1"), field.newDfp("-1"), "unequal", true, 21);   // 1 == -1        cmptst(field.newDfp("-1"), field.newDfp("-1"), "unequal", false, 22);   // -1 == -1        cmptst(field.newDfp("1"), field.newDfp("1.0000000000000001"), "unequal", true, 23);   // 1 == 1.0000000000000001        // The tests below checks to ensure that comparisons don't set FLAG_INEXACT        // 100000 == 1.0000000000000001        cmptst(field.newDfp("1e20"), field.newDfp("1.0000000000000001"), "unequal", true, 24);        if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        cmptst(field.newDfp("0.000001"), field.newDfp("1e-6"), "unequal", false, 25);        // check some nans -- nans shouldnt be unequal to anything        cmptst(snan, snan, "unequal", false, 27);        cmptst(qnan, qnan, "unequal", false, 28);        cmptst(snan, qnan, "unequal", false, 29);        cmptst(qnan, snan, "unequal", false, 30);        cmptst(qnan, field.newDfp("0"), "unequal", false, 31);        cmptst(snan, field.newDfp("0"), "unequal", false, 32);        cmptst(field.newDfp("0"), snan, "unequal", false, 33);        cmptst(field.newDfp("0"), qnan, "unequal", false, 34);        cmptst(qnan, pinf, "unequal", false, 35);        cmptst(snan, pinf, "unequal", false, 36);        cmptst(pinf, snan, "unequal", false, 37);        cmptst(pinf, qnan, "unequal", false, 38);        cmptst(qnan, ninf, "unequal", false, 39);        cmptst(snan, ninf, "unequal", false, 40);        cmptst(ninf, snan, "unequal", false, 41);        cmptst(ninf, qnan, "unequal", false, 42);        cmptst(qnan, field.newDfp("-1"), "unequal", false, 43);        cmptst(snan, field.newDfp("-1"), "unequal", false, 44);        cmptst(field.newDfp("-1"), snan, "unequal", false, 45);        cmptst(field.newDfp("-1"), qnan, "unequal", false, 46);        cmptst(qnan, field.newDfp("1"), "unequal", false, 47);        cmptst(snan, field.newDfp("1"), "unequal", false, 48);        cmptst(field.newDfp("1"), snan, "unequal", false, 49);        cmptst(field.newDfp("1"), qnan, "unequal", false, 50);        cmptst(snan.negate(), snan, "unequal", false, 51);        cmptst(qnan.negate(), qnan, "unequal", false, 52);        if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare unequal flags = "+field.getIEEEFlags());        //        // Tests for lessThan  -- do it all over again        //        cmptst(field.newDfp("0"), field.newDfp("0"), "lessThan", false, 1);         // 0 < 0        cmptst(field.newDfp("0"), field.newDfp("-0"), "lessThan", false, 2);        // 0 < -0        cmptst(field.newDfp("-0"), field.newDfp("-0"), "lessThan", false, 3);       // -0 < -0        cmptst(field.newDfp("-0"), field.newDfp("0"), "lessThan", false, 4);        // -0 < 0        // check zero vs normal numbers        cmptst(field.newDfp("0"), field.newDfp("1"), "lessThan", true, 5);         // 0 < 1        cmptst(field.newDfp("1"), field.newDfp("0"), "lessThan", false, 6);         // 1 < 0        cmptst(field.newDfp("-1"), field.newDfp("0"), "lessThan", true, 7);        // -1 < 0        cmptst(field.newDfp("0"), field.newDfp("-1"), "lessThan", false, 8);        // 0 < -1        cmptst(field.newDfp("0"), field.newDfp("1e-131072"), "lessThan", true, 9); // 0 < 1e-131072        // check flags         if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        cmptst(field.newDfp("0"), field.newDfp("1e-131078"), "lessThan", true, 10); // 0 < 1e-131078        // check flags  -- underflow should be set        if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        field.clearIEEEFlags();        cmptst(field.newDfp("0"), field.newDfp("1e+131071"), "lessThan", true, 11); // 0 < 1e+131071        // check zero vs infinities        cmptst(field.newDfp("0"), pinf, "lessThan", true, 12);    // 0 < pinf        cmptst(field.newDfp("0"), ninf, "lessThan", false, 13);    // 0 < ninf        cmptst(field.newDfp("-0"), pinf, "lessThan", true, 14);   // -0 < pinf        cmptst(field.newDfp("-0"), ninf, "lessThan", false, 15);   // -0 < ninf        cmptst(pinf, field.newDfp("0"), "lessThan", false, 16);    // pinf < 0        cmptst(ninf, field.newDfp("0"), "lessThan", true, 17);    // ninf < 0        cmptst(pinf, field.newDfp("-0"), "lessThan", false, 18);   // pinf < -0        cmptst(ninf, field.newDfp("-0"), "lessThan", true, 19);   // ninf < -0        cmptst(ninf, pinf, "lessThan", true, 19.10);     // ninf < pinf        cmptst(pinf, ninf, "lessThan", false, 19.11);     // pinf < ninf        cmptst(pinf, pinf, "lessThan", false, 19.12);     // pinf < pinf        cmptst(ninf, ninf, "lessThan", false, 19.13);     // ninf < ninf        // check some normal numbers        cmptst(field.newDfp("1"), field.newDfp("1"), "lessThan", false, 20);   // 1 < 1        cmptst(field.newDfp("1"), field.newDfp("-1"), "lessThan", false, 21);   // 1 < -1        cmptst(field.newDfp("-1"), field.newDfp("-1"), "lessThan", false, 22);   // -1 < -1        cmptst(field.newDfp("1"), field.newDfp("1.0000000000000001"), "lessThan", true, 23);   // 1 < 1.0000000000000001        // The tests below checks to ensure that comparisons don't set FLAG_INEXACT        // 100000 < 1.0000000000000001        cmptst(field.newDfp("1e20"), field.newDfp("1.0000000000000001"), "lessThan", false, 24);        if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        cmptst(field.newDfp("0.000001"), field.newDfp("1e-6"), "lessThan", false, 25);        // check some nans -- nans shouldnt be lessThan to anything        cmptst(snan, snan, "lessThan", false, 27);        cmptst(qnan, qnan, "lessThan", false, 28);        cmptst(snan, qnan, "lessThan", false, 29);        cmptst(qnan, snan, "lessThan", false, 30);        cmptst(qnan, field.newDfp("0"), "lessThan", false, 31);        cmptst(snan, field.newDfp("0"), "lessThan", false, 32);        cmptst(field.newDfp("0"), snan, "lessThan", false, 33);        cmptst(field.newDfp("0"), qnan, "lessThan", false, 34);        cmptst(qnan, pinf, "lessThan", false, 35);        cmptst(snan, pinf, "lessThan", false, 36);        cmptst(pinf, snan, "lessThan", false, 37);        cmptst(pinf, qnan, "lessThan", false, 38);        cmptst(qnan, ninf, "lessThan", false, 39);        cmptst(snan, ninf, "lessThan", false, 40);        cmptst(ninf, snan, "lessThan", false, 41);        cmptst(ninf, qnan, "lessThan", false, 42);        cmptst(qnan, field.newDfp("-1"), "lessThan", false, 43);        cmptst(snan, field.newDfp("-1"), "lessThan", false, 44);        cmptst(field.newDfp("-1"), snan, "lessThan", false, 45);        cmptst(field.newDfp("-1"), qnan, "lessThan", false, 46);        cmptst(qnan, field.newDfp("1"), "lessThan", false, 47);        cmptst(snan, field.newDfp("1"), "lessThan", false, 48);        cmptst(field.newDfp("1"), snan, "lessThan", false, 49);        cmptst(field.newDfp("1"), qnan, "lessThan", false, 50);        cmptst(snan.negate(), snan, "lessThan", false, 51);        cmptst(qnan.negate(), qnan, "lessThan", false, 52);        //lessThan compares with nans should raise FLAG_INVALID        if (field.getIEEEFlags() != DfpField.FLAG_INVALID)            Assert.fail("assersion failed.  compare lessThan flags = "+field.getIEEEFlags());        field.clearIEEEFlags();        //        // Tests for greaterThan  -- do it all over again        //        cmptst(field.newDfp("0"), field.newDfp("0"), "greaterThan", false, 1);         // 0 > 0        cmptst(field.newDfp("0"), field.newDfp("-0"), "greaterThan", false, 2);        // 0 > -0        cmptst(field.newDfp("-0"), field.newDfp("-0"), "greaterThan", false, 3);       // -0 > -0        cmptst(field.newDfp("-0"), field.newDfp("0"), "greaterThan", false, 4);        // -0 > 0        // check zero vs normal numbers        cmptst(field.newDfp("0"), field.newDfp("1"), "greaterThan", false, 5);         // 0 > 1        cmptst(field.newDfp("1"), field.newDfp("0"), "greaterThan", true, 6);         // 1 > 0        cmptst(field.newDfp("-1"), field.newDfp("0"), "greaterThan", false, 7);        // -1 > 0        cmptst(field.newDfp("0"), field.newDfp("-1"), "greaterThan", true, 8);        // 0 > -1        cmptst(field.newDfp("0"), field.newDfp("1e-131072"), "greaterThan", false, 9); // 0 > 1e-131072        // check flags         if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        cmptst(field.newDfp("0"), field.newDfp("1e-131078"), "greaterThan", false, 10); // 0 > 1e-131078        // check flags  -- underflow should be set        if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        field.clearIEEEFlags();        cmptst(field.newDfp("0"), field.newDfp("1e+131071"), "greaterThan", false, 11); // 0 > 1e+131071        // check zero vs infinities        cmptst(field.newDfp("0"), pinf, "greaterThan", false, 12);    // 0 > pinf        cmptst(field.newDfp("0"), ninf, "greaterThan", true, 13);    // 0 > ninf        cmptst(field.newDfp("-0"), pinf, "greaterThan", false, 14);   // -0 > pinf        cmptst(field.newDfp("-0"), ninf, "greaterThan", true, 15);   // -0 > ninf        cmptst(pinf, field.newDfp("0"), "greaterThan", true, 16);    // pinf > 0        cmptst(ninf, field.newDfp("0"), "greaterThan", false, 17);    // ninf > 0        cmptst(pinf, field.newDfp("-0"), "greaterThan", true, 18);   // pinf > -0        cmptst(ninf, field.newDfp("-0"), "greaterThan", false, 19);   // ninf > -0        cmptst(ninf, pinf, "greaterThan", false, 19.10);     // ninf > pinf        cmptst(pinf, ninf, "greaterThan", true, 19.11);     // pinf > ninf        cmptst(pinf, pinf, "greaterThan", false, 19.12);     // pinf > pinf        cmptst(ninf, ninf, "greaterThan", false, 19.13);     // ninf > ninf        // check some normal numbers        cmptst(field.newDfp("1"), field.newDfp("1"), "greaterThan", false, 20);   // 1 > 1        cmptst(field.newDfp("1"), field.newDfp("-1"), "greaterThan", true, 21);   // 1 > -1        cmptst(field.newDfp("-1"), field.newDfp("-1"), "greaterThan", false, 22);   // -1 > -1        cmptst(field.newDfp("1"), field.newDfp("1.0000000000000001"), "greaterThan", false, 23);   // 1 > 1.0000000000000001        // The tests below checks to ensure that comparisons don't set FLAG_INEXACT        // 100000 > 1.0000000000000001        cmptst(field.newDfp("1e20"), field.newDfp("1.0000000000000001"), "greaterThan", true, 24);        if (field.getIEEEFlags() != 0)            Assert.fail("assersion failed.  compare flags = "+field.getIEEEFlags());        cmptst(field.newDfp("0.000001"), field.newDfp("1e-6"), "greaterThan", false, 25);        // check some nans -- nans shouldnt be greaterThan to anything        cmptst(snan, snan, "greaterThan", false, 27);        cmptst(qnan, qnan, "greaterThan", false, 28);        cmptst(snan, qnan, "greaterThan", false, 29);        cmptst(qnan, snan, "greaterThan", false, 30);        cmptst(qnan, field.newDfp("0"), "greaterThan", false, 31);        cmptst(snan, field.newDfp("0"), "greaterThan", false, 32);        cmptst(field.newDfp("0"), snan, "greaterThan", false, 33);        cmptst(field.newDfp("0"), qnan, "greaterThan", false, 34);        cmptst(qnan, pinf, "greaterThan", false, 35);        cmptst(snan, pinf, "greaterThan", false, 36);        cmptst(pinf, snan, "greaterThan", false, 37);        cmptst(pinf, qnan, "greaterThan", false, 38);        cmptst(qnan, ninf, "greaterThan", false, 39);        cmptst(snan, ninf, "greaterThan", false, 40);        cmptst(ninf, snan, "greaterThan", false, 41);        cmptst(ninf, qnan, "greaterThan", false, 42);        cmptst(qnan, field.newDfp("-1"), "greaterThan", false, 43);        cmptst(snan, field.newDfp("-1"), "greaterThan", false, 44);        cmptst(field.newDfp("-1"), snan, "greaterThan", false, 45);        cmptst(field.newDfp("-1"), qnan, "greaterThan", false, 46);        cmptst(qnan, field.newDfp("1"), "greaterThan", false, 47);        cmptst(snan, field.newDfp("1"), "greaterThan", false, 48);        cmptst(field.newDfp("1"), snan, "greaterThan", false, 49);        cmptst(field.newDfp("1"), qnan, "greaterThan", false, 50);        cmptst(snan.negate(), snan, "greaterThan", false, 51);        cmptst(qnan.negate(), qnan, "greaterThan", false, 52);        //greaterThan compares with nans should raise FLAG_INVALID        if (field.getIEEEFlags() != DfpField.FLAG_INVALID)            Assert.fail("assersion failed.  compare greaterThan flags = "+field.getIEEEFlags());        field.clearIEEEFlags();    }    //    // Test multiplication    //    @Test    public void testMultiply()    {        test(field.newDfp("1").multiply(field.newDfp("1")),      // Basic tests   1*1 = 1             field.newDfp("1"),              0, "Multiply #1");        test(field.newDfp("1").multiply(1),             // Basic tests   1*1 = 1             field.newDfp("1"),              0, "Multiply #2");        test(field.newDfp("-1").multiply(field.newDfp("1")),     // Basic tests   -1*1 = -1             field.newDfp("-1"),              0, "Multiply #3");        test(field.newDfp("-1").multiply(1),            // Basic tests   -1*1 = -1             field.newDfp("-1"),              0, "Multiply #4");        // basic tests with integers        test(field.newDfp("2").multiply(field.newDfp("3")),             field.newDfp("6"),              0, "Multiply #5");        test(field.newDfp("2").multiply(3),             field.newDfp("6"),              0, "Multiply #6");        test(field.newDfp("-2").multiply(field.newDfp("3")),             field.newDfp("-6"),              0, "Multiply #7");        test(field.newDfp("-2").multiply(3),             field.newDfp("-6"),              0, "Multiply #8");        test(field.newDfp("2").multiply(field.newDfp("-3")),             field.newDfp("-6"),              0, "Multiply #9");        test(field.newDfp("-2").multiply(field.newDfp("-3")),             field.newDfp("6"),              0, "Multiply #10");        //multiply by zero        test(field.newDfp("-2").multiply(field.newDfp("0")),             field.newDfp("-0"),              0, "Multiply #11");        test(field.newDfp("-2").multiply(0),             field.newDfp("-0"),              0, "Multiply #12");        test(field.newDfp("2").multiply(field.newDfp("0")),             field.newDfp("0"),              0, "Multiply #13");        test(field.newDfp("2").multiply(0),             field.newDfp("0"),              0, "Multiply #14");        test(field.newDfp("2").multiply(pinf),             pinf,             0, "Multiply #15");        test(field.newDfp("2").multiply(ninf),             ninf,             0, "Multiply #16");        test(field.newDfp("-2").multiply(pinf),             ninf,             0, "Multiply #17");        test(field.newDfp("-2").multiply(ninf),             pinf,             0, "Multiply #18");        test(ninf.multiply(field.newDfp("-2")),             pinf,             0, "Multiply #18.1");        test(field.newDfp("5e131071").multiply(2),             pinf,             DfpField.FLAG_OVERFLOW, "Multiply #19");                test(field.newDfp("5e131071").multiply(field.newDfp("1.999999999999999")),             field.newDfp("9.9999999999999950000e131071"),             0, "Multiply #20");                test(field.newDfp("-5e131071").multiply(2),             ninf,             DfpField.FLAG_OVERFLOW, "Multiply #22");                test(field.newDfp("-5e131071").multiply(field.newDfp("1.999999999999999")),             field.newDfp("-9.9999999999999950000e131071"),             0, "Multiply #23");                test(field.newDfp("1e-65539").multiply(field.newDfp("1e-65539")),             field.newDfp("1e-131078"),             DfpField.FLAG_UNDERFLOW, "Multiply #24");        test(field.newDfp("1").multiply(nan),             nan,             0, "Multiply #25");        test(nan.multiply(field.newDfp("1")),             nan,             0, "Multiply #26");        test(nan.multiply(pinf),             nan,             0, "Multiply #27");        test(pinf.multiply(nan),             nan,             0, "Multiply #27");        test(pinf.multiply(field.newDfp("0")),             nan,             DfpField.FLAG_INVALID, "Multiply #28");        test(field.newDfp("0").multiply(pinf),             nan,             DfpField.FLAG_INVALID, "Multiply #29");        test(pinf.multiply(pinf),             pinf,             0, "Multiply #30");        test(ninf.multiply(pinf),             ninf,             0, "Multiply #31");        test(pinf.multiply(ninf),             ninf,             0, "Multiply #32");        test(ninf.multiply(ninf),             pinf,             0, "Multiply #33");        test(pinf.multiply(1),             pinf,             0, "Multiply #34");        test(pinf.multiply(0),             nan,             DfpField.FLAG_INVALID, "Multiply #35");        test(nan.multiply(1),             nan,             0, "Multiply #36");        test(field.newDfp("1").multiply(10000),  // out of range             nan,             DfpField.FLAG_INVALID, "Multiply #37");        test(field.newDfp("1").multiply(-1),  // out of range             nan,             DfpField.FLAG_INVALID, "Multiply #38");    }    @Test    public void testDivide()    {        test(field.newDfp("1").divide(nan),      // divide by NaN = NaN             nan,              0, "Divide #1");        test(nan.divide(field.newDfp("1")),      // NaN / number = NaN             nan,              0, "Divide #2");        test(pinf.divide(field.newDfp("1")),             pinf,             0, "Divide #3");        test(pinf.divide(field.newDfp("-1")),             ninf,             0, "Divide #4");        test(pinf.divide(pinf),             nan,             DfpField.FLAG_INVALID, "Divide #5");        test(ninf.divide(pinf),             nan,             DfpField.FLAG_INVALID, "Divide #6");        test(pinf.divide(ninf),             nan,             DfpField.FLAG_INVALID, "Divide #7");        test(ninf.divide(ninf),             nan,             DfpField.FLAG_INVALID, "Divide #8");        test(field.newDfp("0").divide(field.newDfp("0")),             nan,             DfpField.FLAG_DIV_ZERO, "Divide #9");        test(field.newDfp("1").divide(field.newDfp("0")),             pinf,             DfpField.FLAG_DIV_ZERO, "Divide #10");        test(field.newDfp("1").divide(field.newDfp("-0")),             ninf,             DfpField.FLAG_DIV_ZERO, "Divide #11");        test(field.newDfp("-1").divide(field.newDfp("0")),             ninf,             DfpField.FLAG_DIV_ZERO, "Divide #12");        test(field.newDfp("-1").divide(field.newDfp("-0")),             pinf,             DfpField.FLAG_DIV_ZERO, "Divide #13");        test(field.newDfp("1").divide(field.newDfp("3")),             field.newDfp("0.33333333333333333333"),             DfpField.FLAG_INEXACT, "Divide #14");        test(field.newDfp("1").divide(field.newDfp("6")),             field.newDfp("0.16666666666666666667"),             DfpField.FLAG_INEXACT, "Divide #15");        test(field.newDfp("10").divide(field.newDfp("6")),             field.newDfp("1.6666666666666667"),             DfpField.FLAG_INEXACT, "Divide #16");        test(field.newDfp("100").divide(field.newDfp("6")),             field.newDfp("16.6666666666666667"),             DfpField.FLAG_INEXACT, "Divide #17");        test(field.newDfp("1000").divide(field.newDfp("6")),             field.newDfp("166.6666666666666667"),             DfpField.FLAG_INEXACT, "Divide #18");        test(field.newDfp("10000").divide(field.newDfp("6")),             field.newDfp("1666.6666666666666667"),             DfpField.FLAG_INEXACT, "Divide #19");        test(field.newDfp("1").divide(field.newDfp("1")),             field.newDfp("1"),             0, "Divide #20");        test(field.newDfp("1").divide(field.newDfp("-1")),             field.newDfp("-1"),             0, "Divide #21");        test(field.newDfp("-1").divide(field.newDfp("1")),             field.newDfp("-1"),             0, "Divide #22");        test(field.newDfp("-1").divide(field.newDfp("-1")),             field.newDfp("1"),             0, "Divide #23");        test(field.newDfp("1e-65539").divide(field.newDfp("1e65539")),             field.newDfp("1e-131078"),             DfpField.FLAG_UNDERFLOW, "Divide #24");        test(field.newDfp("1e65539").divide(field.newDfp("1e-65539")),             pinf,             DfpField.FLAG_OVERFLOW, "Divide #24");        test(field.newDfp("2").divide(field.newDfp("1.5")),     // test trial-divisor too high             field.newDfp("1.3333333333333333"),             DfpField.FLAG_INEXACT, "Divide #25");        test(field.newDfp("2").divide(pinf),             field.newDfp("0"),             0, "Divide #26");        test(field.newDfp("2").divide(ninf),             field.newDfp("-0"),             0, "Divide #27");        test(field.newDfp("0").divide(field.newDfp("1")),             field.newDfp("0"),             0, "Divide #28");    }    @Test    public void testDivideInt()    {        test(nan.divide(1),      // NaN / number = NaN             nan,              0, "DivideInt #1");        test(pinf.divide(1),             pinf,             0, "DivideInt #2");        test(field.newDfp("0").divide(0),             nan,             DfpField.FLAG_DIV_ZERO, "DivideInt #3");        test(field.newDfp("1").divide(0),             pinf,             DfpField.FLAG_DIV_ZERO, "DivideInt #4");        test(field.newDfp("-1").divide(0),             ninf,             DfpField.FLAG_DIV_ZERO, "DivideInt #5");        test(field.newDfp("1").divide(3),             field.newDfp("0.33333333333333333333"),             DfpField.FLAG_INEXACT, "DivideInt #6");        test(field.newDfp("1").divide(6),             field.newDfp("0.16666666666666666667"),             DfpField.FLAG_INEXACT, "DivideInt #7");        test(field.newDfp("10").divide(6),             field.newDfp("1.6666666666666667"),             DfpField.FLAG_INEXACT, "DivideInt #8");        test(field.newDfp("100").divide(6),             field.newDfp("16.6666666666666667"),             DfpField.FLAG_INEXACT, "DivideInt #9");        test(field.newDfp("1000").divide(6),             field.newDfp("166.6666666666666667"),             DfpField.FLAG_INEXACT, "DivideInt #10");        test(field.newDfp("10000").divide(6),             field.newDfp("1666.6666666666666667"),             DfpField.FLAG_INEXACT, "DivideInt #20");        test(field.newDfp("1").divide(1),             field.newDfp("1"),             0, "DivideInt #21");        test(field.newDfp("1e-131077").divide(10),             field.newDfp("1e-131078"),             DfpField.FLAG_UNDERFLOW, "DivideInt #22");        test(field.newDfp("0").divide(1),             field.newDfp("0"),             0, "DivideInt #23");        test(field.newDfp("1").divide(10000),             nan,             DfpField.FLAG_INVALID, "DivideInt #24");        test(field.newDfp("1").divide(-1),             nan,             DfpField.FLAG_INVALID, "DivideInt #25");    }    @Test    public void testNextAfter()    {        test(field.newDfp("1").nextAfter(pinf),             field.newDfp("1.0000000000000001"),             0, "NextAfter #1");        test(field.newDfp("1.0000000000000001").nextAfter(ninf),             field.newDfp("1"),             0, "NextAfter #1.5");        test(field.newDfp("1").nextAfter(ninf),             field.newDfp("0.99999999999999999999"),             0, "NextAfter #2");        test(field.newDfp("0.99999999999999999999").nextAfter(field.newDfp("2")),             field.newDfp("1"),             0, "NextAfter #3");        test(field.newDfp("-1").nextAfter(ninf),             field.newDfp("-1.0000000000000001"),             0, "NextAfter #4");        test(field.newDfp("-1").nextAfter(pinf),             field.newDfp("-0.99999999999999999999"),             0, "NextAfter #5");        test(field.newDfp("-0.99999999999999999999").nextAfter(field.newDfp("-2")),             field.newDfp("-1"),             0, "NextAfter #6");        test(field.newDfp("2").nextAfter(field.newDfp("2")),             field.newDfp("2"),             0, "NextAfter #7");        test(field.newDfp("0").nextAfter(field.newDfp("0")),             field.newDfp("0"),             0, "NextAfter #8");        test(field.newDfp("-2").nextAfter(field.newDfp("-2")),             field.newDfp("-2"),             0, "NextAfter #9");        test(field.newDfp("0").nextAfter(field.newDfp("1")),             field.newDfp("1e-131092"),             DfpField.FLAG_UNDERFLOW, "NextAfter #10");        test(field.newDfp("0").nextAfter(field.newDfp("-1")),             field.newDfp("-1e-131092"),             DfpField.FLAG_UNDERFLOW, "NextAfter #11");        test(field.newDfp("-1e-131092").nextAfter(pinf),             field.newDfp("-0"),             DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, "Next After #12");        test(field.newDfp("1e-131092").nextAfter(ninf),              field.newDfp("0"),             DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, "Next After #13");        test(field.newDfp("9.9999999999999999999e131078").nextAfter(pinf),             pinf,             DfpField.FLAG_OVERFLOW|DfpField.FLAG_INEXACT, "Next After #14");    }    @Test    public void testToString()    {        Assert.assertEquals("toString #1", "Infinity", pinf.toString());        Assert.assertEquals("toString #2", "-Infinity", ninf.toString());        Assert.assertEquals("toString #3", "NaN", nan.toString());        Assert.assertEquals("toString #4", "NaN", field.newDfp((byte) 1, (byte) Dfp.QNAN).toString());        Assert.assertEquals("toString #5", "NaN", field.newDfp((byte) 1, (byte) Dfp.SNAN).toString());        Assert.assertEquals("toString #6", "1.2300000000000000e100", field.newDfp("1.23e100").toString());        Assert.assertEquals("toString #7", "-1.2300000000000000e100", field.newDfp("-1.23e100").toString());        Assert.assertEquals("toString #8", "12345678.1234", field.newDfp("12345678.1234").toString());        Assert.assertEquals("toString #9", "0.00001234", field.newDfp("0.00001234").toString());    }    @Test    public void testRound()    {        field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN);        // Round down        test(field.newDfp("12345678901234567890").add(field.newDfp("0.9")),             field.newDfp("12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #1");        test(field.newDfp("12345678901234567890").add(field.newDfp("0.99999999")),             field.newDfp("12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #2");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.99999999")),             field.newDfp("-12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #3");        field.setRoundingMode(DfpField.RoundingMode.ROUND_UP);        // Round up        test(field.newDfp("12345678901234567890").add(field.newDfp("0.1")),             field.newDfp("12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #4");        test(field.newDfp("12345678901234567890").add(field.newDfp("0.0001")),             field.newDfp("12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #5");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.1")),             field.newDfp("-12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #6");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.0001")),             field.newDfp("-12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #7");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP);        // Round half up        test(field.newDfp("12345678901234567890").add(field.newDfp("0.4999")),             field.newDfp("12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #8");        test(field.newDfp("12345678901234567890").add(field.newDfp("0.5000")),             field.newDfp("12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #9");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.4999")),             field.newDfp("-12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #10");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5000")),             field.newDfp("-12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #11");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN);        // Round half down        test(field.newDfp("12345678901234567890").add(field.newDfp("0.5001")),             field.newDfp("12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #12");        test(field.newDfp("12345678901234567890").add(field.newDfp("0.5000")),             field.newDfp("12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #13");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5001")),             field.newDfp("-12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #14");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5000")),             field.newDfp("-12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #15");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD);        // Round half odd        test(field.newDfp("12345678901234567890").add(field.newDfp("0.5000")),             field.newDfp("12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #16");        test(field.newDfp("12345678901234567891").add(field.newDfp("0.5000")),             field.newDfp("12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #17");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5000")),             field.newDfp("-12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #18");        test(field.newDfp("-12345678901234567891").add(field.newDfp("-0.5000")),             field.newDfp("-12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #19");        field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL);        // Round ceil        test(field.newDfp("12345678901234567890").add(field.newDfp("0.0001")),             field.newDfp("12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #20");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.9999")),             field.newDfp("-12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #21");        field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR);        // Round floor        test(field.newDfp("12345678901234567890").add(field.newDfp("0.9999")),             field.newDfp("12345678901234567890"),             DfpField.FLAG_INEXACT, "Round #22");        test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.0001")),             field.newDfp("-12345678901234567891"),             DfpField.FLAG_INEXACT, "Round #23");        field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);  // reset    }    @Test    public void testCeil()    {        test(field.newDfp("1234.0000000000000001").ceil(),             field.newDfp("1235"),             DfpField.FLAG_INEXACT, "Ceil #1");    }    @Test    public void testFloor()    {        test(field.newDfp("1234.9999999999999999").floor(),             field.newDfp("1234"),             DfpField.FLAG_INEXACT, "Floor #1");    }    @Test    public void testRint()    {        test(field.newDfp("1234.50000000001").rint(),             field.newDfp("1235"),             DfpField.FLAG_INEXACT, "Rint #1");        test(field.newDfp("1234.5000").rint(),             field.newDfp("1234"),             DfpField.FLAG_INEXACT, "Rint #2");        test(field.newDfp("1235.5000").rint(),             field.newDfp("1236"),             DfpField.FLAG_INEXACT, "Rint #3");    }    @Test    public void testCopySign()    {        test(Dfp.copysign(field.newDfp("1234."), field.newDfp("-1")),             field.newDfp("-1234"),             0, "CopySign #1");        test(Dfp.copysign(field.newDfp("-1234."), field.newDfp("-1")),             field.newDfp("-1234"),             0, "CopySign #2");        test(Dfp.copysign(field.newDfp("-1234."), field.newDfp("1")),             field.newDfp("1234"),             0, "CopySign #3");        test(Dfp.copysign(field.newDfp("1234."), field.newDfp("1")),             field.newDfp("1234"),             0, "CopySign #4");    }    @Test    public void testIntValue()    {        Assert.assertEquals("intValue #1", 1234, field.newDfp("1234").intValue());        Assert.assertEquals("intValue #2", -1234, field.newDfp("-1234").intValue());        Assert.assertEquals("intValue #3", 1234, field.newDfp("1234.5").intValue());        Assert.assertEquals("intValue #4", 1235, field.newDfp("1234.500001").intValue());        Assert.assertEquals("intValue #5", 2147483647, field.newDfp("1e1000").intValue());        Assert.assertEquals("intValue #6", -2147483648, field.newDfp("-1e1000").intValue());    }    @Test    public void testLog10K()    {        Assert.assertEquals("log10K #1", 1, field.newDfp("123456").log10K());        Assert.assertEquals("log10K #2", 2, field.newDfp("123456789").log10K());        Assert.assertEquals("log10K #3", 0, field.newDfp("2").log10K());        Assert.assertEquals("log10K #3", 0, field.newDfp("1").log10K());        Assert.assertEquals("log10K #4", -1, field.newDfp("0.1").log10K());    }    @Test    public void testPower10K()    {        Dfp d = field.newDfp();        test(d.power10K(0), field.newDfp("1"), 0, "Power10 #1");        test(d.power10K(1), field.newDfp("10000"), 0, "Power10 #2");        test(d.power10K(2), field.newDfp("100000000"), 0, "Power10 #3");        test(d.power10K(-1), field.newDfp("0.0001"), 0, "Power10 #4");        test(d.power10K(-2), field.newDfp("0.00000001"), 0, "Power10 #5");        test(d.power10K(-3), field.newDfp("0.000000000001"), 0, "Power10 #6");    }    @Test    public void testLog10()    {        Assert.assertEquals("log10 #1", 1, field.newDfp("12").log10());        Assert.assertEquals("log10 #2", 2, field.newDfp("123").log10());        Assert.assertEquals("log10 #3", 3, field.newDfp("1234").log10());        Assert.assertEquals("log10 #4", 4, field.newDfp("12345").log10());        Assert.assertEquals("log10 #5", 5, field.newDfp("123456").log10());        Assert.assertEquals("log10 #6", 6, field.newDfp("1234567").log10());        Assert.assertEquals("log10 #6", 7, field.newDfp("12345678").log10());        Assert.assertEquals("log10 #7", 8, field.newDfp("123456789").log10());        Assert.assertEquals("log10 #8", 9, field.newDfp("1234567890").log10());        Assert.assertEquals("log10 #9", 10, field.newDfp("12345678901").log10());        Assert.assertEquals("log10 #10", 11, field.newDfp("123456789012").log10());        Assert.assertEquals("log10 #11", 12, field.newDfp("1234567890123").log10());        Assert.assertEquals("log10 #12", 0, field.newDfp("2").log10());        Assert.assertEquals("log10 #13", 0, field.newDfp("1").log10());        Assert.assertEquals("log10 #14", -1, field.newDfp("0.12").log10());        Assert.assertEquals("log10 #15", -2, field.newDfp("0.012").log10());    }    @Test    public void testPower10()    {        Dfp d = field.newDfp();        test(d.power10(0), field.newDfp("1"), 0, "Power10 #1");        test(d.power10(1), field.newDfp("10"), 0, "Power10 #2");        test(d.power10(2), field.newDfp("100"), 0, "Power10 #3");        test(d.power10(3), field.newDfp("1000"), 0, "Power10 #4");        test(d.power10(4), field.newDfp("10000"), 0, "Power10 #5");        test(d.power10(5), field.newDfp("100000"), 0, "Power10 #6");        test(d.power10(6), field.newDfp("1000000"), 0, "Power10 #7");        test(d.power10(7), field.newDfp("10000000"), 0, "Power10 #8");        test(d.power10(8), field.newDfp("100000000"), 0, "Power10 #9");        test(d.power10(9), field.newDfp("1000000000"), 0, "Power10 #10");        test(d.power10(-1), field.newDfp(".1"), 0, "Power10 #11");        test(d.power10(-2), field.newDfp(".01"), 0, "Power10 #12");        test(d.power10(-3), field.newDfp(".001"), 0, "Power10 #13");        test(d.power10(-4), field.newDfp(".0001"), 0, "Power10 #14");        test(d.power10(-5), field.newDfp(".00001"), 0, "Power10 #15");        test(d.power10(-6), field.newDfp(".000001"), 0, "Power10 #16");        test(d.power10(-7), field.newDfp(".0000001"), 0, "Power10 #17");        test(d.power10(-8), field.newDfp(".00000001"), 0, "Power10 #18");        test(d.power10(-9), field.newDfp(".000000001"), 0, "Power10 #19");        test(d.power10(-10), field.newDfp(".0000000001"), 0, "Power10 #20");    }    @Test    public void testRemainder()    {        test(field.newDfp("10").remainder(field.newDfp("3")),             field.newDfp("1"),             DfpField.FLAG_INEXACT, "Remainder #1");        test(field.newDfp("9").remainder(field.newDfp("3")),             field.newDfp("0"),             0, "Remainder #2");        test(field.newDfp("-9").remainder(field.newDfp("3")),             field.newDfp("-0"),             0, "Remainder #3");    }    @Test    public void testSqrt()    {        test(field.newDfp("0").sqrt(),             field.newDfp("0"),             0, "Sqrt #1");        test(field.newDfp("-0").sqrt(),             field.newDfp("-0"),             0, "Sqrt #2");        test(field.newDfp("1").sqrt(),             field.newDfp("1"),             0, "Sqrt #3");        test(field.newDfp("2").sqrt(),             field.newDfp("1.4142135623730950"),             DfpField.FLAG_INEXACT, "Sqrt #4");        test(field.newDfp("3").sqrt(),             field.newDfp("1.7320508075688773"),             DfpField.FLAG_INEXACT, "Sqrt #5");        test(field.newDfp("5").sqrt(),             field.newDfp("2.2360679774997897"),             DfpField.FLAG_INEXACT, "Sqrt #6");        test(field.newDfp("500").sqrt(),             field.newDfp("22.3606797749978970"),             DfpField.FLAG_INEXACT, "Sqrt #6.2");        test(field.newDfp("50000").sqrt(),             field.newDfp("223.6067977499789696"),             DfpField.FLAG_INEXACT, "Sqrt #6.3");        test(field.newDfp("-1").sqrt(),             nan,             DfpField.FLAG_INVALID, "Sqrt #7");        test(pinf.sqrt(),             pinf,             0, "Sqrt #8");        test(field.newDfp((byte) 1, (byte) Dfp.QNAN).sqrt(),             nan,             0, "Sqrt #9");        test(field.newDfp((byte) 1, (byte) Dfp.SNAN).sqrt(),             nan,             DfpField.FLAG_INVALID, "Sqrt #9");    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.dfp;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public class DfpMathTest {    private DfpField factory;    private Dfp pinf;    private Dfp ninf;    private Dfp nan;    private Dfp qnan;    @Before    public void setUp() {        // Some basic setup.  Define some constants and clear the status flags        factory = new DfpField(20);        pinf = factory.newDfp("1").divide(factory.newDfp("0"));        ninf = factory.newDfp("-1").divide(factory.newDfp("0"));        nan = factory.newDfp("0").divide(factory.newDfp("0"));        qnan = factory.newDfp((byte)1, Dfp.QNAN);        ninf.getField().clearIEEEFlags();        // force loading of dfpmath        Dfp pi = factory.getPi();        pi.getField().clearIEEEFlags();    }    @After    public void tearDown() {        pinf = null;        ninf = null;        nan  = null;        qnan = null;    }    // Generic test function.  Takes params x and y and tests them for     // equality.  Then checks the status flags against the flags argument.    // If the test fail, it prints the desc string    private void test(Dfp x, Dfp y, int flags, String desc)    {        boolean b = x.equals(y);        if (!x.equals(y) && !x.unequal(y))  // NaNs involved             b = (x.toString().equals(y.toString()));        if (x.equals(factory.newDfp("0")))  // distinguish +/- zero            b = (b && (x.toString().equals(y.toString())));        b = (b && x.getField().getIEEEFlags() == flags);        if (!b)            Assert.assertTrue("assersion failed "+desc+" x = "+x.toString()+" flags = "+x.getField().getIEEEFlags(), b);        x.getField().clearIEEEFlags();    }    @Test    public void testPow()      {        // Test special cases  exponent of zero        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("0")),                   factory.newDfp("1"),              0, "pow #1");        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("-0")),                   factory.newDfp("1"),              0, "pow #2");        test(DfpMath.pow(factory.newDfp("2"), factory.newDfp("0")),                   factory.newDfp("1"),              0, "pow #3");        test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("-0")),                   factory.newDfp("1"),              0, "pow #4");        test(DfpMath.pow(pinf, factory.newDfp("-0")),                   factory.newDfp("1"),              0, "pow #5");        test(DfpMath.pow(pinf, factory.newDfp("0")),             factory.newDfp("1"),              0, "pow #6");        test(DfpMath.pow(ninf, factory.newDfp("-0")),                   factory.newDfp("1"),              0, "pow #7");        test(DfpMath.pow(ninf, factory.newDfp("0")),             factory.newDfp("1"),              0, "pow #8");        test(DfpMath.pow(qnan, factory.newDfp("0")),             factory.newDfp("1"),              0, "pow #8");        // exponent of one        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("1")),             factory.newDfp("0"),              0, "pow #9");        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("1")),                   factory.newDfp("-0"),              0, "pow #10");        test(DfpMath.pow(factory.newDfp("2"), factory.newDfp("1")),             factory.newDfp("2"),              0, "pow #11");        test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("1")),             factory.newDfp("-2"),              0, "pow #12");        test(DfpMath.pow(pinf, factory.newDfp("1")),                   pinf,              0, "pow #13");        test(DfpMath.pow(ninf, factory.newDfp("1")),             ninf,              0, "pow #14");        test(DfpMath.pow(qnan, factory.newDfp("1")),             qnan,              DfpField.FLAG_INVALID, "pow #14.1");        // exponent of NaN        test(DfpMath.pow(factory.newDfp("0"), qnan),             qnan,              DfpField.FLAG_INVALID, "pow #15");        test(DfpMath.pow(factory.newDfp("-0"), qnan),                   qnan,              DfpField.FLAG_INVALID, "pow #16");        test(DfpMath.pow(factory.newDfp("2"), qnan),             qnan,              DfpField.FLAG_INVALID, "pow #17");        test(DfpMath.pow(factory.newDfp("-2"), qnan),             qnan,              DfpField.FLAG_INVALID, "pow #18");        test(DfpMath.pow(pinf, qnan),                   qnan,              DfpField.FLAG_INVALID, "pow #19");        test(DfpMath.pow(ninf, qnan),             qnan,              DfpField.FLAG_INVALID, "pow #20");        test(DfpMath.pow(qnan, qnan),             qnan,              DfpField.FLAG_INVALID, "pow #21");        // radix of NaN        test(DfpMath.pow(qnan, factory.newDfp("1")),             qnan,              DfpField.FLAG_INVALID, "pow #22");        test(DfpMath.pow(qnan, factory.newDfp("-1")),                   qnan,             DfpField.FLAG_INVALID, "pow #23");        test(DfpMath.pow(qnan, pinf),             qnan,             DfpField.FLAG_INVALID, "pow #24");        test(DfpMath.pow(qnan, ninf),             qnan,              DfpField.FLAG_INVALID, "pow #25");        test(DfpMath.pow(qnan, qnan),             qnan,              DfpField.FLAG_INVALID, "pow #26");        // (x > 1) ^ pinf = pinf,    (x < -1) ^ pinf = pinf        test(DfpMath.pow(factory.newDfp("2"), pinf),             pinf,              0, "pow #27");        test(DfpMath.pow(factory.newDfp("-2"), pinf),                   pinf,             0, "pow #28");        test(DfpMath.pow(pinf, pinf),             pinf,             0, "pow #29");        test(DfpMath.pow(ninf, pinf),             pinf,              0, "pow #30");        // (x > 1) ^ ninf = +0,    (x < -1) ^ ninf = +0        test(DfpMath.pow(factory.newDfp("2"), ninf),             factory.getZero(),              0, "pow #31");        test(DfpMath.pow(factory.newDfp("-2"), ninf),                   factory.getZero(),             0, "pow #32");        test(DfpMath.pow(pinf, ninf),             factory.getZero(),             0, "pow #33");        test(DfpMath.pow(ninf, ninf),             factory.getZero(),              0, "pow #34");        // (-1 < x < 1) ^ pinf = 0        test(DfpMath.pow(factory.newDfp("0.5"), pinf),             factory.getZero(),              0, "pow #35");        test(DfpMath.pow(factory.newDfp("-0.5"), pinf),                   factory.getZero(),             0, "pow #36");        // (-1 < x < 1) ^ ninf = pinf         test(DfpMath.pow(factory.newDfp("0.5"), ninf),             pinf,              0, "pow #37");        test(DfpMath.pow(factory.newDfp("-0.5"), ninf),                   pinf,             0, "pow #38");        // +/- 1  ^ +/-inf  = NaN        test(DfpMath.pow(factory.getOne(), pinf),             qnan,              DfpField.FLAG_INVALID, "pow #39");        test(DfpMath.pow(factory.getOne(), ninf),                   qnan,             DfpField.FLAG_INVALID, "pow #40");        test(DfpMath.pow(factory.newDfp("-1"), pinf),             qnan,              DfpField.FLAG_INVALID, "pow #41");        test(DfpMath.pow(factory.getOne().negate(), ninf),                   qnan,             DfpField.FLAG_INVALID, "pow #42");        // +0  ^ +anything except 0, NAN  = +0        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("1")),             factory.newDfp("0"),             0, "pow #43");        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("1e30")),             factory.newDfp("0"),             0, "pow #44");        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("1e-30")),             factory.newDfp("0"),             0, "pow #45");        test(DfpMath.pow(factory.newDfp("0"), pinf),             factory.newDfp("0"),             0, "pow #46");        // -0  ^ +anything except 0, NAN, odd integer  = +0        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("2")),             factory.newDfp("0"),             0, "pow #47");        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("1e30")),             factory.newDfp("0"),             0, "pow #48");        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("1e-30")),             factory.newDfp("0"),             DfpField.FLAG_INEXACT, "pow #49");        test(DfpMath.pow(factory.newDfp("-0"), pinf),             factory.newDfp("0"),             0, "pow #50");        // +0  ^ -anything except 0, NAN  = +INF        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("-1")),             pinf,             0, "pow #51");        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("-1e30")),             pinf,             0, "pow #52");        test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("-1e-30")),             pinf,             0, "pow #53");        test(DfpMath.pow(factory.newDfp("0"), ninf),             pinf,             0, "pow #54");        // -0  ^ -anything except 0, NAN, odd integer  = +INF        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-2")),             pinf,             0, "pow #55");        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-1e30")),             pinf,             0, "pow #56");        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-1e-30")),             pinf,             DfpField.FLAG_INEXACT, "pow #57");        test(DfpMath.pow(factory.newDfp("-0"), ninf),             pinf,             0, "pow #58");        // -0  ^ -odd integer   =  -INF        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-1")),             ninf,             DfpField.FLAG_INEXACT, "pow #59");        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-12345")),             ninf,             DfpField.FLAG_INEXACT, "pow #60");        // -0  ^ +odd integer   =  -0        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("3")),             factory.newDfp("-0"),             DfpField.FLAG_INEXACT, "pow #61");        test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("12345")),             factory.newDfp("-0"),             DfpField.FLAG_INEXACT, "pow #62");        // pinf  ^ +anything   = pinf         test(DfpMath.pow(pinf, factory.newDfp("3")),             pinf,             0, "pow #63");        test(DfpMath.pow(pinf, factory.newDfp("1e30")),             pinf,             0, "pow #64");        test(DfpMath.pow(pinf, factory.newDfp("1e-30")),             pinf,             0, "pow #65");        test(DfpMath.pow(pinf, pinf),             pinf,             0, "pow #66");        // pinf  ^ -anything   = +0         test(DfpMath.pow(pinf, factory.newDfp("-3")),             factory.getZero(),             0, "pow #67");        test(DfpMath.pow(pinf, factory.newDfp("-1e30")),             factory.getZero(),             0, "pow #68");        test(DfpMath.pow(pinf, factory.newDfp("-1e-30")),             factory.getZero(),             0, "pow #69");        test(DfpMath.pow(pinf, ninf),             factory.getZero(),             0, "pow #70");        // ninf  ^ anything   = -0 ^ -anything        // ninf  ^ -anything except 0, NAN, odd integer  = +0        test(DfpMath.pow(ninf, factory.newDfp("-2")),             factory.newDfp("0"),             0, "pow #71");        test(DfpMath.pow(ninf, factory.newDfp("-1e30")),             factory.newDfp("0"),             0, "pow #72");        test(DfpMath.pow(ninf, factory.newDfp("-1e-30")),             factory.newDfp("0"),             DfpField.FLAG_INEXACT, "pow #73");        test(DfpMath.pow(ninf, ninf),             factory.newDfp("0"),             0, "pow #74");        // ninf  ^ +anything except 0, NAN, odd integer  = +INF        test(DfpMath.pow(ninf, factory.newDfp("2")),             pinf,             0, "pow #75");        test(DfpMath.pow(ninf, factory.newDfp("1e30")),             pinf,             0, "pow #76");        test(DfpMath.pow(ninf, factory.newDfp("1e-30")),             pinf,             DfpField.FLAG_INEXACT, "pow #77");        test(DfpMath.pow(ninf, pinf),             pinf,             0, "pow #78");        // ninf  ^ +odd integer   =  -INF        test(DfpMath.pow(ninf, factory.newDfp("3")),             ninf,             DfpField.FLAG_INEXACT, "pow #79");        test(DfpMath.pow(ninf, factory.newDfp("12345")),             ninf,             DfpField.FLAG_INEXACT, "pow #80");        // ninf  ^ -odd integer   =  -0        test(DfpMath.pow(ninf, factory.newDfp("-3")),             factory.newDfp("-0"),             DfpField.FLAG_INEXACT, "pow #81");        test(DfpMath.pow(ninf, factory.newDfp("-12345")),             factory.newDfp("-0"),             DfpField.FLAG_INEXACT, "pow #82");        // -anything ^ integer         test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("3")),             factory.newDfp("-8"),             DfpField.FLAG_INEXACT, "pow #83");        test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("16")),             factory.newDfp("65536"),             0, "pow #84");        test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("-3")),             factory.newDfp("-0.125"),             DfpField.FLAG_INEXACT, "pow #85");        test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("-4")),             factory.newDfp("0.0625"),             0, "pow #86");        // -anything ^ noninteger = NaN        test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("-4.1")),             qnan,             DfpField.FLAG_INVALID|DfpField.FLAG_INEXACT, "pow #87");        // Some fractional cases.        test(DfpMath.pow(factory.newDfp("2"),factory.newDfp("1.5")),             factory.newDfp("2.8284271247461901"),              DfpField.FLAG_INEXACT, "pow #88");    }    @Test    public void testSin()    {        test(DfpMath.sin(pinf),             nan,             DfpField.FLAG_INVALID|DfpField.FLAG_INEXACT, "sin #1");        test(DfpMath.sin(nan),             nan,             DfpField.FLAG_INVALID|DfpField.FLAG_INEXACT, "sin #2");        test(DfpMath.sin(factory.getZero()),             factory.getZero(),             DfpField.FLAG_INEXACT, "sin #3");        test(DfpMath.sin(factory.getPi()),             factory.getZero(),             DfpField.FLAG_INEXACT, "sin #4");        test(DfpMath.sin(factory.getPi().negate()),             factory.newDfp("-0"),             DfpField.FLAG_INEXACT, "sin #5");        test(DfpMath.sin(factory.getPi().multiply(2)),             factory.getZero(),             DfpField.FLAG_INEXACT, "sin #6");        test(DfpMath.sin(factory.getPi().divide(2)),             factory.getOne(),             DfpField.FLAG_INEXACT, "sin #7");        test(DfpMath.sin(factory.getPi().divide(2).negate()),             factory.getOne().negate(),             DfpField.FLAG_INEXACT, "sin #8");        test(DfpMath.sin(DfpMath.atan(factory.getOne())),  // pi/4             factory.newDfp("0.5").sqrt(),             DfpField.FLAG_INEXACT, "sin #9");        test(DfpMath.sin(DfpMath.atan(factory.getOne())).negate(),  // -pi/4             factory.newDfp("0.5").sqrt().negate(),             DfpField.FLAG_INEXACT, "sin #10");        test(DfpMath.sin(DfpMath.atan(factory.getOne())).negate(),  // -pi/4             factory.newDfp("0.5").sqrt().negate(),             DfpField.FLAG_INEXACT, "sin #11");        test(DfpMath.sin(factory.newDfp("0.1")),             factory.newDfp("0.0998334166468281523"),             DfpField.FLAG_INEXACT, "sin #12");        test(DfpMath.sin(factory.newDfp("0.2")),             factory.newDfp("0.19866933079506121546"),             DfpField.FLAG_INEXACT, "sin #13");        test(DfpMath.sin(factory.newDfp("0.3")),             factory.newDfp("0.2955202066613395751"),             DfpField.FLAG_INEXACT, "sin #14");        test(DfpMath.sin(factory.newDfp("0.4")),             factory.newDfp("0.38941834230865049166"),             DfpField.FLAG_INEXACT, "sin #15");        test(DfpMath.sin(factory.newDfp("0.5")),             factory.newDfp("0.47942553860420300026"),  // off by one ULP             DfpField.FLAG_INEXACT, "sin #16");        test(DfpMath.sin(factory.newDfp("0.6")),             factory.newDfp("0.56464247339503535721"),  // off by one ULP             DfpField.FLAG_INEXACT, "sin #17");        test(DfpMath.sin(factory.newDfp("0.7")),             factory.newDfp("0.64421768723769105367"),               DfpField.FLAG_INEXACT, "sin #18");        test(DfpMath.sin(factory.newDfp("0.8")),                     factory.newDfp("0.71735609089952276163"),             DfpField.FLAG_INEXACT, "sin #19");        test(DfpMath.sin(factory.newDfp("0.9")),        // off by one ULP             factory.newDfp("0.78332690962748338847"),             DfpField.FLAG_INEXACT, "sin #20");        test(DfpMath.sin(factory.newDfp("1.0")),             factory.newDfp("0.84147098480789650666"),             DfpField.FLAG_INEXACT, "sin #21");        test(DfpMath.sin(factory.newDfp("1.1")),             factory.newDfp("0.89120736006143533995"),             DfpField.FLAG_INEXACT, "sin #22");        test(DfpMath.sin(factory.newDfp("1.2")),             factory.newDfp("0.93203908596722634968"),             DfpField.FLAG_INEXACT, "sin #23");        test(DfpMath.sin(factory.newDfp("1.3")),             factory.newDfp("0.9635581854171929647"),             DfpField.FLAG_INEXACT, "sin #24");        test(DfpMath.sin(factory.newDfp("1.4")),             factory.newDfp("0.98544972998846018066"),             DfpField.FLAG_INEXACT, "sin #25");        test(DfpMath.sin(factory.newDfp("1.5")),             factory.newDfp("0.99749498660405443096"),             DfpField.FLAG_INEXACT, "sin #26");        test(DfpMath.sin(factory.newDfp("1.6")),             factory.newDfp("0.99957360304150516323"),             DfpField.FLAG_INEXACT, "sin #27");    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import java.math.BigDecimal;import java.math.BigInteger;import java.text.NumberFormat;import java.text.ParseException;import java.util.Locale;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;public class BigFractionFormatTest extends TestCase {    BigFractionFormat properFormat = null;    BigFractionFormat improperFormat = null;    protected Locale getLocale() {        return Locale.getDefault();    }    @Override    protected void setUp() throws Exception {        properFormat = BigFractionFormat.getProperInstance(getLocale());        improperFormat = BigFractionFormat.getImproperInstance(getLocale());    }    public void testFormat() {        BigFraction c = new BigFraction(1, 2);        String expected = "1 / 2";        String actual = properFormat.format(c);        assertEquals(expected, actual);        actual = improperFormat.format(c);        assertEquals(expected, actual);    }    public void testFormatNegative() {        BigFraction c = new BigFraction(-1, 2);        String expected = "-1 / 2";        String actual = properFormat.format(c);        assertEquals(expected, actual);        actual = improperFormat.format(c);        assertEquals(expected, actual);    }    public void testFormatZero() {        BigFraction c = new BigFraction(0, 1);        String expected = "0 / 1";        String actual = properFormat.format(c);        assertEquals(expected, actual);        actual = improperFormat.format(c);        assertEquals(expected, actual);    }    public void testFormatImproper() {        BigFraction c = new BigFraction(5, 3);        String actual = properFormat.format(c);        assertEquals("1 2 / 3", actual);        actual = improperFormat.format(c);        assertEquals("5 / 3", actual);    }    public void testFormatImproperNegative() {        BigFraction c = new BigFraction(-5, 3);        String actual = properFormat.format(c);        assertEquals("-1 2 / 3", actual);        actual = improperFormat.format(c);        assertEquals("-5 / 3", actual);    }    public void testParse() {        String source = "1 / 2";        try {            BigFraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(BigInteger.ONE, c.getNumerator());            assertEquals(BigInteger.valueOf(2l), c.getDenominator());            c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(BigInteger.ONE, c.getNumerator());            assertEquals(BigInteger.valueOf(2l), c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseInteger() {        String source = "10";        try {            BigFraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(BigInteger.TEN, c.getNumerator());            assertEquals(BigInteger.ONE, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }        try {            BigFraction c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(BigInteger.TEN, c.getNumerator());            assertEquals(BigInteger.ONE, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseInvalid() {        String source = "a";        String msg = "should not be able to parse '10 / a'.";        try {            properFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }        try {            improperFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }    }    public void testParseInvalidDenominator() {        String source = "10 / a";        String msg = "should not be able to parse '10 / a'.";        try {            properFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }        try {            improperFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }    }    public void testParseNegative() {        try {            String source = "-1 / 2";            BigFraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumeratorAsInt());            assertEquals(2, c.getDenominatorAsInt());            c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumeratorAsInt());            assertEquals(2, c.getDenominatorAsInt());            source = "1 / -2";            c = properFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumeratorAsInt());            assertEquals(2, c.getDenominatorAsInt());            c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumeratorAsInt());            assertEquals(2, c.getDenominatorAsInt());        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseProper() {        String source = "1 2 / 3";        try {            BigFraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(5, c.getNumeratorAsInt());            assertEquals(3, c.getDenominatorAsInt());        } catch (ParseException ex) {            fail(ex.getMessage());        }        try {            improperFormat.parse(source);            fail("invalid improper fraction.");        } catch (ParseException ex) {            // success        }    }    public void testParseProperNegative() {        String source = "-1 2 / 3";        try {            BigFraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(-5, c.getNumeratorAsInt());            assertEquals(3, c.getDenominatorAsInt());        } catch (ParseException ex) {            fail(ex.getMessage());        }        try {            improperFormat.parse(source);            fail("invalid improper fraction.");        } catch (ParseException ex) {            // success        }    }    public void testParseProperInvalidMinus() {        String source = "2 -2 / 3";        try {            properFormat.parse(source);            fail("invalid minus in improper fraction.");        } catch (ParseException ex) {            // expected        }        source = "2 2 / -3";        try {            properFormat.parse(source);            fail("invalid minus in improper fraction.");        } catch (ParseException ex) {            // expected        }    }    public void testParseBig() throws ParseException {        BigFraction f1 =            improperFormat.parse("167213075789791382630275400487886041651764456874403" +                                 " / " +                                 "53225575123090058458126718248444563466137046489291");        assertEquals(FastMath.PI, f1.doubleValue(), 0.0);        BigFraction f2 =            properFormat.parse("3 " +                               "7536350420521207255895245742552351253353317406530" +                               " / " +                               "53225575123090058458126718248444563466137046489291");        assertEquals(FastMath.PI, f2.doubleValue(), 0.0);        assertEquals(f1, f2);        BigDecimal pi =            new BigDecimal("3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068");        assertEquals(pi, f1.bigDecimalValue(99, BigDecimal.ROUND_HALF_EVEN));    }    public void testNumeratorFormat() {        NumberFormat old = properFormat.getNumeratorFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        properFormat.setNumeratorFormat(nf);        assertEquals(nf, properFormat.getNumeratorFormat());        properFormat.setNumeratorFormat(old);        old = improperFormat.getNumeratorFormat();        nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        improperFormat.setNumeratorFormat(nf);        assertEquals(nf, improperFormat.getNumeratorFormat());        improperFormat.setNumeratorFormat(old);    }    public void testDenominatorFormat() {        NumberFormat old = properFormat.getDenominatorFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        properFormat.setDenominatorFormat(nf);        assertEquals(nf, properFormat.getDenominatorFormat());        properFormat.setDenominatorFormat(old);        old = improperFormat.getDenominatorFormat();        nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        improperFormat.setDenominatorFormat(nf);        assertEquals(nf, improperFormat.getDenominatorFormat());        improperFormat.setDenominatorFormat(old);    }    public void testWholeFormat() {        ProperBigFractionFormat format = (ProperBigFractionFormat)properFormat;        NumberFormat old = format.getWholeFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        format.setWholeFormat(nf);        assertEquals(nf, format.getWholeFormat());        format.setWholeFormat(old);    }    public void testLongFormat() {        assertEquals("10 / 1", improperFormat.format(10l));    }    public void testDoubleFormat() {        assertEquals("1 / 16", improperFormat.format(0.0625));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import org.apache.commons.math.ConvergenceException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class FractionTest extends TestCase {    private void assertFraction(int expectedNumerator, int expectedDenominator, Fraction actual) {        assertEquals(expectedNumerator, actual.getNumerator());        assertEquals(expectedDenominator, actual.getDenominator());    }    public void testConstructor() {        assertFraction(0, 1, new Fraction(0, 1));        assertFraction(0, 1, new Fraction(0, 2));        assertFraction(0, 1, new Fraction(0, -1));        assertFraction(1, 2, new Fraction(1, 2));        assertFraction(1, 2, new Fraction(2, 4));        assertFraction(-1, 2, new Fraction(-1, 2));        assertFraction(-1, 2, new Fraction(1, -2));        assertFraction(-1, 2, new Fraction(-2, 4));        assertFraction(-1, 2, new Fraction(2, -4));        // overflow        try {            new Fraction(Integer.MIN_VALUE, -1);            fail();        } catch (ArithmeticException ex) {            // success        }        try {            new Fraction(1, Integer.MIN_VALUE);            fail();        } catch (ArithmeticException ex) {            // success        }        try {            assertFraction(0, 1, new Fraction(0.00000000000001));            assertFraction(2, 5, new Fraction(0.40000000000001));            assertFraction(15, 1, new Fraction(15.0000000000001));        } catch (ConvergenceException ex) {            fail(ex.getMessage());        }    }    public void testGoldenRatio() {        try {            // the golden ratio is notoriously a difficult number for continuous fraction            new Fraction((1 + FastMath.sqrt(5)) / 2, 1.0e-12, 25);            fail("an exception should have been thrown");        } catch (ConvergenceException ce) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    // MATH-179    public void testDoubleConstructor() throws ConvergenceException  {        assertFraction(1, 2, new Fraction((double)1 / (double)2));        assertFraction(1, 3, new Fraction((double)1 / (double)3));        assertFraction(2, 3, new Fraction((double)2 / (double)3));        assertFraction(1, 4, new Fraction((double)1 / (double)4));        assertFraction(3, 4, new Fraction((double)3 / (double)4));        assertFraction(1, 5, new Fraction((double)1 / (double)5));        assertFraction(2, 5, new Fraction((double)2 / (double)5));        assertFraction(3, 5, new Fraction((double)3 / (double)5));        assertFraction(4, 5, new Fraction((double)4 / (double)5));        assertFraction(1, 6, new Fraction((double)1 / (double)6));        assertFraction(5, 6, new Fraction((double)5 / (double)6));        assertFraction(1, 7, new Fraction((double)1 / (double)7));        assertFraction(2, 7, new Fraction((double)2 / (double)7));        assertFraction(3, 7, new Fraction((double)3 / (double)7));        assertFraction(4, 7, new Fraction((double)4 / (double)7));        assertFraction(5, 7, new Fraction((double)5 / (double)7));        assertFraction(6, 7, new Fraction((double)6 / (double)7));        assertFraction(1, 8, new Fraction((double)1 / (double)8));        assertFraction(3, 8, new Fraction((double)3 / (double)8));        assertFraction(5, 8, new Fraction((double)5 / (double)8));        assertFraction(7, 8, new Fraction((double)7 / (double)8));        assertFraction(1, 9, new Fraction((double)1 / (double)9));        assertFraction(2, 9, new Fraction((double)2 / (double)9));        assertFraction(4, 9, new Fraction((double)4 / (double)9));        assertFraction(5, 9, new Fraction((double)5 / (double)9));        assertFraction(7, 9, new Fraction((double)7 / (double)9));        assertFraction(8, 9, new Fraction((double)8 / (double)9));        assertFraction(1, 10, new Fraction((double)1 / (double)10));        assertFraction(3, 10, new Fraction((double)3 / (double)10));        assertFraction(7, 10, new Fraction((double)7 / (double)10));        assertFraction(9, 10, new Fraction((double)9 / (double)10));        assertFraction(1, 11, new Fraction((double)1 / (double)11));        assertFraction(2, 11, new Fraction((double)2 / (double)11));        assertFraction(3, 11, new Fraction((double)3 / (double)11));        assertFraction(4, 11, new Fraction((double)4 / (double)11));        assertFraction(5, 11, new Fraction((double)5 / (double)11));        assertFraction(6, 11, new Fraction((double)6 / (double)11));        assertFraction(7, 11, new Fraction((double)7 / (double)11));        assertFraction(8, 11, new Fraction((double)8 / (double)11));        assertFraction(9, 11, new Fraction((double)9 / (double)11));        assertFraction(10, 11, new Fraction((double)10 / (double)11));    }    // MATH-181    public void testDigitLimitConstructor() throws ConvergenceException  {        assertFraction(2, 5, new Fraction(0.4,   9));        assertFraction(2, 5, new Fraction(0.4,  99));        assertFraction(2, 5, new Fraction(0.4, 999));        assertFraction(3, 5,      new Fraction(0.6152,    9));        assertFraction(8, 13,     new Fraction(0.6152,   99));        assertFraction(510, 829,  new Fraction(0.6152,  999));        assertFraction(769, 1250, new Fraction(0.6152, 9999));    }    public void testIntegerOverflow() {        checkIntegerOverflow(0.75000000001455192);        checkIntegerOverflow(1.0e10);    }    private void checkIntegerOverflow(double a) {        try {            new Fraction(a, 1.0e-12, 1000);            fail("an exception should have been thrown");        } catch (ConvergenceException ce) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testEpsilonLimitConstructor() throws ConvergenceException  {        assertFraction(2, 5, new Fraction(0.4, 1.0e-5, 100));        assertFraction(3, 5,      new Fraction(0.6152, 0.02, 100));        assertFraction(8, 13,     new Fraction(0.6152, 1.0e-3, 100));        assertFraction(251, 408,  new Fraction(0.6152, 1.0e-4, 100));        assertFraction(251, 408,  new Fraction(0.6152, 1.0e-5, 100));        assertFraction(510, 829,  new Fraction(0.6152, 1.0e-6, 100));        assertFraction(769, 1250, new Fraction(0.6152, 1.0e-7, 100));    }    public void testCompareTo() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(1, 3);        Fraction third = new Fraction(1, 2);        assertEquals(0, first.compareTo(first));        assertEquals(0, first.compareTo(third));        assertEquals(1, first.compareTo(second));        assertEquals(-1, second.compareTo(first));        // these two values are different approximations of PI        // the first  one is approximately PI - 3.07e-18        // the second one is approximately PI + 1.936e-17        Fraction pi1 = new Fraction(1068966896, 340262731);        Fraction pi2 = new Fraction( 411557987, 131002976);        assertEquals(-1, pi1.compareTo(pi2));        assertEquals( 1, pi2.compareTo(pi1));        assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);    }    public void testDoubleValue() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(1, 3);        assertEquals(0.5, first.doubleValue(), 0.0);        assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);    }    public void testFloatValue() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(1, 3);        assertEquals(0.5f, first.floatValue(), 0.0f);        assertEquals((float)(1.0 / 3.0), second.floatValue(), 0.0f);    }    public void testIntValue() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(3, 2);        assertEquals(0, first.intValue());        assertEquals(1, second.intValue());    }    public void testLongValue() {        Fraction first = new Fraction(1, 2);        Fraction second = new Fraction(3, 2);        assertEquals(0L, first.longValue());        assertEquals(1L, second.longValue());    }    public void testConstructorDouble() {        try {            assertFraction(1, 2, new Fraction(0.5));            assertFraction(1, 3, new Fraction(1.0 / 3.0));            assertFraction(17, 100, new Fraction(17.0 / 100.0));            assertFraction(317, 100, new Fraction(317.0 / 100.0));            assertFraction(-1, 2, new Fraction(-0.5));            assertFraction(-1, 3, new Fraction(-1.0 / 3.0));            assertFraction(-17, 100, new Fraction(17.0 / -100.0));            assertFraction(-317, 100, new Fraction(-317.0 / 100.0));        } catch (ConvergenceException ex) {            fail(ex.getMessage());        }    }    public void testAbs() {        Fraction a = new Fraction(10, 21);        Fraction b = new Fraction(-10, 21);        Fraction c = new Fraction(10, -21);        assertFraction(10, 21, a.abs());        assertFraction(10, 21, b.abs());        assertFraction(10, 21, c.abs());    }    public void testReciprocal() {        Fraction f = null;        f = new Fraction(50, 75);        f = f.reciprocal();        assertEquals(3, f.getNumerator());        assertEquals(2, f.getDenominator());        f = new Fraction(4, 3);        f = f.reciprocal();        assertEquals(3, f.getNumerator());        assertEquals(4, f.getDenominator());        f = new Fraction(-15, 47);        f = f.reciprocal();        assertEquals(-47, f.getNumerator());        assertEquals(15, f.getDenominator());        f = new Fraction(0, 3);        try {            f = f.reciprocal();            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}        // large values        f = new Fraction(Integer.MAX_VALUE, 1);        f = f.reciprocal();        assertEquals(1, f.getNumerator());        assertEquals(Integer.MAX_VALUE, f.getDenominator());    }    public void testNegate() {        Fraction f = null;        f = new Fraction(50, 75);        f = f.negate();        assertEquals(-2, f.getNumerator());        assertEquals(3, f.getDenominator());        f = new Fraction(-50, 75);        f = f.negate();        assertEquals(2, f.getNumerator());        assertEquals(3, f.getDenominator());        // large values        f = new Fraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE);        f = f.negate();        assertEquals(Integer.MIN_VALUE+2, f.getNumerator());        assertEquals(Integer.MAX_VALUE, f.getDenominator());        f = new Fraction(Integer.MIN_VALUE, 1);        try {            f = f.negate();            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}    }    public void testAdd() {        Fraction a = new Fraction(1, 2);        Fraction b = new Fraction(2, 3);        assertFraction(1, 1, a.add(a));        assertFraction(7, 6, a.add(b));        assertFraction(7, 6, b.add(a));        assertFraction(4, 3, b.add(b));        Fraction f1 = new Fraction(Integer.MAX_VALUE - 1, 1);        Fraction f2 = Fraction.ONE;        Fraction f = f1.add(f2);        assertEquals(Integer.MAX_VALUE, f.getNumerator());        assertEquals(1, f.getDenominator());        f = f1.add(1);        assertEquals(Integer.MAX_VALUE, f.getNumerator());        assertEquals(1, f.getDenominator());        f1 = new Fraction(-1, 13*13*2*2);        f2 = new Fraction(-2, 13*17*2);        f = f1.add(f2);        assertEquals(13*13*17*2*2, f.getDenominator());        assertEquals(-17 - 2*13*2, f.getNumerator());        try {            f.add(null);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {}        // if this fraction is added naively, it will overflow.        // check that it doesn't.        f1 = new Fraction(1,32768*3);        f2 = new Fraction(1,59049);        f = f1.add(f2);        assertEquals(52451, f.getNumerator());        assertEquals(1934917632, f.getDenominator());        f1 = new Fraction(Integer.MIN_VALUE, 3);        f2 = new Fraction(1,3);        f = f1.add(f2);        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());        assertEquals(3, f.getDenominator());        f1 = new Fraction(Integer.MAX_VALUE - 1, 1);        f2 = Fraction.ONE;        f = f1.add(f2);        assertEquals(Integer.MAX_VALUE, f.getNumerator());        assertEquals(1, f.getDenominator());        try {            f = f.add(Fraction.ONE); // should overflow            fail("expecting ArithmeticException but got: " + f.toString());        } catch (ArithmeticException ex) {}        // denominator should not be a multiple of 2 or 3 to trigger overflow        f1 = new Fraction(Integer.MIN_VALUE, 5);        f2 = new Fraction(-1,5);        try {            f = f1.add(f2); // should overflow            fail("expecting ArithmeticException but got: " + f.toString());        } catch (ArithmeticException ex) {}        try {            f= new Fraction(-Integer.MAX_VALUE, 1);            f = f.add(f);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}        try {            f= new Fraction(-Integer.MAX_VALUE, 1);            f = f.add(f);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}        f1 = new Fraction(3,327680);        f2 = new Fraction(2,59049);        try {            f = f1.add(f2); // should overflow            fail("expecting ArithmeticException but got: " + f.toString());        } catch (ArithmeticException ex) {}    }    public void testDivide() {        Fraction a = new Fraction(1, 2);        Fraction b = new Fraction(2, 3);        assertFraction(1, 1, a.divide(a));        assertFraction(3, 4, a.divide(b));        assertFraction(4, 3, b.divide(a));        assertFraction(1, 1, b.divide(b));        Fraction f1 = new Fraction(3, 5);        Fraction f2 = Fraction.ZERO;        try {            f1.divide(f2);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}        f1 = new Fraction(0, 5);        f2 = new Fraction(2, 7);        Fraction f = f1.divide(f2);        assertSame(Fraction.ZERO, f);        f1 = new Fraction(2, 7);        f2 = Fraction.ONE;        f = f1.divide(f2);        assertEquals(2, f.getNumerator());        assertEquals(7, f.getDenominator());        f1 = new Fraction(1, Integer.MAX_VALUE);        f = f1.divide(f1);        assertEquals(1, f.getNumerator());        assertEquals(1, f.getDenominator());        f1 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        f2 = new Fraction(1, Integer.MAX_VALUE);        f = f1.divide(f2);        assertEquals(Integer.MIN_VALUE, f.getNumerator());        assertEquals(1, f.getDenominator());        try {            f.divide(null);            fail("IllegalArgumentException");        } catch (IllegalArgumentException ex) {}        try {            f1 = new Fraction(1, Integer.MAX_VALUE);            f = f1.divide(f1.reciprocal());  // should overflow            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}        try {            f1 = new Fraction(1, -Integer.MAX_VALUE);            f = f1.divide(f1.reciprocal());  // should overflow            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}        f1 = new Fraction(6, 35);        f  = f1.divide(15);        assertEquals(2, f.getNumerator());        assertEquals(175, f.getDenominator());    }    public void testMultiply() {        Fraction a = new Fraction(1, 2);        Fraction b = new Fraction(2, 3);        assertFraction(1, 4, a.multiply(a));        assertFraction(1, 3, a.multiply(b));        assertFraction(1, 3, b.multiply(a));        assertFraction(4, 9, b.multiply(b));        Fraction f1 = new Fraction(Integer.MAX_VALUE, 1);        Fraction f2 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        Fraction f = f1.multiply(f2);        assertEquals(Integer.MIN_VALUE, f.getNumerator());        assertEquals(1, f.getDenominator());        try {            f.multiply(null);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {}        f1 = new Fraction(6, 35);        f  = f1.multiply(15);        assertEquals(18, f.getNumerator());        assertEquals(7, f.getDenominator());    }    public void testSubtract() {        Fraction a = new Fraction(1, 2);        Fraction b = new Fraction(2, 3);        assertFraction(0, 1, a.subtract(a));        assertFraction(-1, 6, a.subtract(b));        assertFraction(1, 6, b.subtract(a));        assertFraction(0, 1, b.subtract(b));        Fraction f = new Fraction(1,1);        try {            f.subtract(null);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {}        // if this fraction is subtracted naively, it will overflow.        // check that it doesn't.        Fraction f1 = new Fraction(1,32768*3);        Fraction f2 = new Fraction(1,59049);        f = f1.subtract(f2);        assertEquals(-13085, f.getNumerator());        assertEquals(1934917632, f.getDenominator());        f1 = new Fraction(Integer.MIN_VALUE, 3);        f2 = new Fraction(1,3).negate();        f = f1.subtract(f2);        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());        assertEquals(3, f.getDenominator());        f1 = new Fraction(Integer.MAX_VALUE, 1);        f2 = Fraction.ONE;        f = f1.subtract(f2);        assertEquals(Integer.MAX_VALUE-1, f.getNumerator());        assertEquals(1, f.getDenominator());        f = f1.subtract(1);        assertEquals(Integer.MAX_VALUE-1, f.getNumerator());        assertEquals(1, f.getDenominator());        try {            f1 = new Fraction(1, Integer.MAX_VALUE);            f2 = new Fraction(1, Integer.MAX_VALUE - 1);            f = f1.subtract(f2);            fail("expecting ArithmeticException");  //should overflow        } catch (ArithmeticException ex) {}        // denominator should not be a multiple of 2 or 3 to trigger overflow        f1 = new Fraction(Integer.MIN_VALUE, 5);        f2 = new Fraction(1,5);        try {            f = f1.subtract(f2); // should overflow            fail("expecting ArithmeticException but got: " + f.toString());        } catch (ArithmeticException ex) {}        try {            f= new Fraction(Integer.MIN_VALUE, 1);            f = f.subtract(Fraction.ONE);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}        try {            f= new Fraction(Integer.MAX_VALUE, 1);            f = f.subtract(Fraction.ONE.negate());            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {}        f1 = new Fraction(3,327680);        f2 = new Fraction(2,59049);        try {            f = f1.subtract(f2); // should overflow            fail("expecting ArithmeticException but got: " + f.toString());        } catch (ArithmeticException ex) {}    }    public void testEqualsAndHashCode() {        Fraction zero  = new Fraction(0,1);        Fraction nullFraction = null;        assertTrue( zero.equals(zero));        assertFalse(zero.equals(nullFraction));        assertFalse(zero.equals(Double.valueOf(0)));        Fraction zero2 = new Fraction(0,2);        assertTrue(zero.equals(zero2));        assertEquals(zero.hashCode(), zero2.hashCode());        Fraction one = new Fraction(1,1);        assertFalse((one.equals(zero) ||zero.equals(one)));    }    public void testGetReducedFraction() {        Fraction threeFourths = new Fraction(3, 4);        assertTrue(threeFourths.equals(Fraction.getReducedFraction(6, 8)));        assertTrue(Fraction.ZERO.equals(Fraction.getReducedFraction(0, -1)));        try {            Fraction.getReducedFraction(1, 0);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected        }        assertEquals(Fraction.getReducedFraction                (2, Integer.MIN_VALUE).getNumerator(),-1);        assertEquals(Fraction.getReducedFraction                (1, -1).getNumerator(), -1);    }    public void testToString() {        assertEquals("0", new Fraction(0, 3).toString());        assertEquals("3", new Fraction(6, 2).toString());        assertEquals("2 / 3", new Fraction(18, 27).toString());    }    public void testSerial() throws FractionConversionException {        Fraction[] fractions = {            new Fraction(3, 4), Fraction.ONE, Fraction.ZERO,            new Fraction(17), new Fraction(FastMath.PI, 1000),            new Fraction(-5, 2)        };        for (Fraction fraction : fractions) {            assertEquals(fraction, TestUtils.serializeAndRecover(fraction));        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import java.math.BigDecimal;import java.math.BigInteger;import org.apache.commons.math.ConvergenceException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.exception.NullArgumentException;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;public class BigFractionTest extends TestCase {    private void assertFraction(int expectedNumerator, int expectedDenominator, BigFraction actual) {        assertEquals(expectedNumerator, actual.getNumeratorAsInt());        assertEquals(expectedDenominator, actual.getDenominatorAsInt());    }    private void assertFraction(long expectedNumerator, long expectedDenominator, BigFraction actual) {        assertEquals(expectedNumerator, actual.getNumeratorAsLong());        assertEquals(expectedDenominator, actual.getDenominatorAsLong());    }    public void testConstructor() {        assertFraction(0, 1, new BigFraction(0, 1));        assertFraction(0, 1, new BigFraction(0l, 2l));        assertFraction(0, 1, new BigFraction(0, -1));        assertFraction(1, 2, new BigFraction(1, 2));        assertFraction(1, 2, new BigFraction(2, 4));        assertFraction(-1, 2, new BigFraction(-1, 2));        assertFraction(-1, 2, new BigFraction(1, -2));        assertFraction(-1, 2, new BigFraction(-2, 4));        assertFraction(-1, 2, new BigFraction(2, -4));        assertFraction(11, 1, new BigFraction(11));        assertFraction(11, 1, new BigFraction(11l));        assertFraction(11, 1, new BigFraction(new BigInteger("11")));        try {            assertFraction(0, 1, new BigFraction(0.00000000000001, 1.0e-5, 100));            assertFraction(2, 5, new BigFraction(0.40000000000001, 1.0e-5, 100));            assertFraction(15, 1, new BigFraction(15.0000000000001, 1.0e-5, 100));        } catch (ConvergenceException ex) {            fail(ex.getMessage());        }        assertEquals(0.00000000000001, new BigFraction(0.00000000000001).doubleValue(), 0.0);        assertEquals(0.40000000000001, new BigFraction(0.40000000000001).doubleValue(), 0.0);        assertEquals(15.0000000000001, new BigFraction(15.0000000000001).doubleValue(), 0.0);        assertFraction(3602879701896487l, 9007199254740992l, new BigFraction(0.40000000000001));        assertFraction(1055531162664967l, 70368744177664l, new BigFraction(15.0000000000001));        try {            new BigFraction(null, BigInteger.ONE);        } catch (NullArgumentException npe) {            // expected        }        try {            new BigFraction(BigInteger.ONE, null);        } catch (NullArgumentException npe) {            // expected        }        try {            new BigFraction(BigInteger.ONE, BigInteger.ZERO);        } catch (ArithmeticException npe) {            // expected        }        try {            new BigFraction(2.0 * Integer.MAX_VALUE, 1.0e-5, 100000);        } catch (FractionConversionException fce) {            // expected        }    }    public void testGoldenRatio() {        try {            // the golden ratio is notoriously a difficult number for continuous            // fraction            new BigFraction((1 + FastMath.sqrt(5)) / 2, 1.0e-12, 25);            fail("an exception should have been thrown");        } catch (ConvergenceException ce) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    // MATH-179    public void testDoubleConstructor() throws ConvergenceException {        assertFraction(1, 2, new BigFraction((double) 1 / (double) 2, 1.0e-5, 100));        assertFraction(1, 3, new BigFraction((double) 1 / (double) 3, 1.0e-5, 100));        assertFraction(2, 3, new BigFraction((double) 2 / (double) 3, 1.0e-5, 100));        assertFraction(1, 4, new BigFraction((double) 1 / (double) 4, 1.0e-5, 100));        assertFraction(3, 4, new BigFraction((double) 3 / (double) 4, 1.0e-5, 100));        assertFraction(1, 5, new BigFraction((double) 1 / (double) 5, 1.0e-5, 100));        assertFraction(2, 5, new BigFraction((double) 2 / (double) 5, 1.0e-5, 100));        assertFraction(3, 5, new BigFraction((double) 3 / (double) 5, 1.0e-5, 100));        assertFraction(4, 5, new BigFraction((double) 4 / (double) 5, 1.0e-5, 100));        assertFraction(1, 6, new BigFraction((double) 1 / (double) 6, 1.0e-5, 100));        assertFraction(5, 6, new BigFraction((double) 5 / (double) 6, 1.0e-5, 100));        assertFraction(1, 7, new BigFraction((double) 1 / (double) 7, 1.0e-5, 100));        assertFraction(2, 7, new BigFraction((double) 2 / (double) 7, 1.0e-5, 100));        assertFraction(3, 7, new BigFraction((double) 3 / (double) 7, 1.0e-5, 100));        assertFraction(4, 7, new BigFraction((double) 4 / (double) 7, 1.0e-5, 100));        assertFraction(5, 7, new BigFraction((double) 5 / (double) 7, 1.0e-5, 100));        assertFraction(6, 7, new BigFraction((double) 6 / (double) 7, 1.0e-5, 100));        assertFraction(1, 8, new BigFraction((double) 1 / (double) 8, 1.0e-5, 100));        assertFraction(3, 8, new BigFraction((double) 3 / (double) 8, 1.0e-5, 100));        assertFraction(5, 8, new BigFraction((double) 5 / (double) 8, 1.0e-5, 100));        assertFraction(7, 8, new BigFraction((double) 7 / (double) 8, 1.0e-5, 100));        assertFraction(1, 9, new BigFraction((double) 1 / (double) 9, 1.0e-5, 100));        assertFraction(2, 9, new BigFraction((double) 2 / (double) 9, 1.0e-5, 100));        assertFraction(4, 9, new BigFraction((double) 4 / (double) 9, 1.0e-5, 100));        assertFraction(5, 9, new BigFraction((double) 5 / (double) 9, 1.0e-5, 100));        assertFraction(7, 9, new BigFraction((double) 7 / (double) 9, 1.0e-5, 100));        assertFraction(8, 9, new BigFraction((double) 8 / (double) 9, 1.0e-5, 100));        assertFraction(1, 10, new BigFraction((double) 1 / (double) 10, 1.0e-5, 100));        assertFraction(3, 10, new BigFraction((double) 3 / (double) 10, 1.0e-5, 100));        assertFraction(7, 10, new BigFraction((double) 7 / (double) 10, 1.0e-5, 100));        assertFraction(9, 10, new BigFraction((double) 9 / (double) 10, 1.0e-5, 100));        assertFraction(1, 11, new BigFraction((double) 1 / (double) 11, 1.0e-5, 100));        assertFraction(2, 11, new BigFraction((double) 2 / (double) 11, 1.0e-5, 100));        assertFraction(3, 11, new BigFraction((double) 3 / (double) 11, 1.0e-5, 100));        assertFraction(4, 11, new BigFraction((double) 4 / (double) 11, 1.0e-5, 100));        assertFraction(5, 11, new BigFraction((double) 5 / (double) 11, 1.0e-5, 100));        assertFraction(6, 11, new BigFraction((double) 6 / (double) 11, 1.0e-5, 100));        assertFraction(7, 11, new BigFraction((double) 7 / (double) 11, 1.0e-5, 100));        assertFraction(8, 11, new BigFraction((double) 8 / (double) 11, 1.0e-5, 100));        assertFraction(9, 11, new BigFraction((double) 9 / (double) 11, 1.0e-5, 100));        assertFraction(10, 11, new BigFraction((double) 10 / (double) 11, 1.0e-5, 100));    }    // MATH-181    public void testDigitLimitConstructor() throws ConvergenceException {        assertFraction(2, 5, new BigFraction(0.4, 9));        assertFraction(2, 5, new BigFraction(0.4, 99));        assertFraction(2, 5, new BigFraction(0.4, 999));        assertFraction(3, 5, new BigFraction(0.6152, 9));        assertFraction(8, 13, new BigFraction(0.6152, 99));        assertFraction(510, 829, new BigFraction(0.6152, 999));        assertFraction(769, 1250, new BigFraction(0.6152, 9999));    }    public void testEpsilonLimitConstructor() throws ConvergenceException {        assertFraction(2, 5, new BigFraction(0.4, 1.0e-5, 100));        assertFraction(3, 5, new BigFraction(0.6152, 0.02, 100));        assertFraction(8, 13, new BigFraction(0.6152, 1.0e-3, 100));        assertFraction(251, 408, new BigFraction(0.6152, 1.0e-4, 100));        assertFraction(251, 408, new BigFraction(0.6152, 1.0e-5, 100));        assertFraction(510, 829, new BigFraction(0.6152, 1.0e-6, 100));        assertFraction(769, 1250, new BigFraction(0.6152, 1.0e-7, 100));    }    public void testCompareTo() {        BigFraction first = new BigFraction(1, 2);        BigFraction second = new BigFraction(1, 3);        BigFraction third = new BigFraction(1, 2);        assertEquals(0, first.compareTo(first));        assertEquals(0, first.compareTo(third));        assertEquals(1, first.compareTo(second));        assertEquals(-1, second.compareTo(first));        // these two values are different approximations of PI        // the first  one is approximately PI - 3.07e-18        // the second one is approximately PI + 1.936e-17        BigFraction pi1 = new BigFraction(1068966896, 340262731);        BigFraction pi2 = new BigFraction( 411557987, 131002976);        assertEquals(-1, pi1.compareTo(pi2));        assertEquals( 1, pi2.compareTo(pi1));        assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);    }    public void testDoubleValue() {        BigFraction first = new BigFraction(1, 2);        BigFraction second = new BigFraction(1, 3);        assertEquals(0.5, first.doubleValue(), 0.0);        assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);    }    public void testFloatValue() {        BigFraction first = new BigFraction(1, 2);        BigFraction second = new BigFraction(1, 3);        assertEquals(0.5f, first.floatValue(), 0.0f);        assertEquals((float) (1.0 / 3.0), second.floatValue(), 0.0f);    }    public void testIntValue() {        BigFraction first = new BigFraction(1, 2);        BigFraction second = new BigFraction(3, 2);        assertEquals(0, first.intValue());        assertEquals(1, second.intValue());    }    public void testLongValue() {        BigFraction first = new BigFraction(1, 2);        BigFraction second = new BigFraction(3, 2);        assertEquals(0L, first.longValue());        assertEquals(1L, second.longValue());    }    public void testConstructorDouble() {        assertFraction(1, 2, new BigFraction(0.5));        assertFraction(6004799503160661l, 18014398509481984l, new BigFraction(1.0 / 3.0));        assertFraction(6124895493223875l, 36028797018963968l, new BigFraction(17.0 / 100.0));        assertFraction(1784551352345559l, 562949953421312l, new BigFraction(317.0 / 100.0));        assertFraction(-1, 2, new BigFraction(-0.5));        assertFraction(-6004799503160661l, 18014398509481984l, new BigFraction(-1.0 / 3.0));        assertFraction(-6124895493223875l, 36028797018963968l, new BigFraction(17.0 / -100.0));        assertFraction(-1784551352345559l, 562949953421312l, new BigFraction(-317.0 / 100.0));        for (double v : new double[] { Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY}) {            try {                new BigFraction(v);                fail("expected exception");            } catch (IllegalArgumentException iae) {                // expected            }        }        assertEquals(1l, new BigFraction(Double.MAX_VALUE).getDenominatorAsLong());        assertEquals(1l, new BigFraction(Double.longBitsToDouble(0x0010000000000000L)).getNumeratorAsLong());        assertEquals(1l, new BigFraction(Double.MIN_VALUE).getNumeratorAsLong());    }    public void testAbs() {        BigFraction a = new BigFraction(10, 21);        BigFraction b = new BigFraction(-10, 21);        BigFraction c = new BigFraction(10, -21);        assertFraction(10, 21, a.abs());        assertFraction(10, 21, b.abs());        assertFraction(10, 21, c.abs());    }    public void testReciprocal() {        BigFraction f = null;        f = new BigFraction(50, 75);        f = f.reciprocal();        assertEquals(3, f.getNumeratorAsInt());        assertEquals(2, f.getDenominatorAsInt());        f = new BigFraction(4, 3);        f = f.reciprocal();        assertEquals(3, f.getNumeratorAsInt());        assertEquals(4, f.getDenominatorAsInt());        f = new BigFraction(-15, 47);        f = f.reciprocal();        assertEquals(-47, f.getNumeratorAsInt());        assertEquals(15, f.getDenominatorAsInt());        f = new BigFraction(0, 3);        try {            f = f.reciprocal();            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {        }        // large values        f = new BigFraction(Integer.MAX_VALUE, 1);        f = f.reciprocal();        assertEquals(1, f.getNumeratorAsInt());        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());    }    public void testNegate() {        BigFraction f = null;        f = new BigFraction(50, 75);        f = f.negate();        assertEquals(-2, f.getNumeratorAsInt());        assertEquals(3, f.getDenominatorAsInt());        f = new BigFraction(-50, 75);        f = f.negate();        assertEquals(2, f.getNumeratorAsInt());        assertEquals(3, f.getDenominatorAsInt());        // large values        f = new BigFraction(Integer.MAX_VALUE - 1, Integer.MAX_VALUE);        f = f.negate();        assertEquals(Integer.MIN_VALUE + 2, f.getNumeratorAsInt());        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());    }    public void testAdd() {        BigFraction a = new BigFraction(1, 2);        BigFraction b = new BigFraction(2, 3);        assertFraction(1, 1, a.add(a));        assertFraction(7, 6, a.add(b));        assertFraction(7, 6, b.add(a));        assertFraction(4, 3, b.add(b));        BigFraction f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);        BigFraction f2 = BigFraction.ONE;        BigFraction f = f1.add(f2);        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f1 = new BigFraction(-1, 13 * 13 * 2 * 2);        f2 = new BigFraction(-2, 13 * 17 * 2);        f = f1.add(f2);        assertEquals(13 * 13 * 17 * 2 * 2, f.getDenominatorAsInt());        assertEquals(-17 - 2 * 13 * 2, f.getNumeratorAsInt());        try {            f.add((BigFraction) null);            fail("expecting NullArgumentException");        } catch (NullArgumentException ex) {        }        // if this fraction is added naively, it will overflow.        // check that it doesn't.        f1 = new BigFraction(1, 32768 * 3);        f2 = new BigFraction(1, 59049);        f = f1.add(f2);        assertEquals(52451, f.getNumeratorAsInt());        assertEquals(1934917632, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MIN_VALUE, 3);        f2 = new BigFraction(1, 3);        f = f1.add(f2);        assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt());        assertEquals(3, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);        f = f1.add(BigInteger.ONE);        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f = f.add(BigInteger.ZERO);        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);        f = f1.add(1);        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f = f.add(0);        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MAX_VALUE - 1, 1);        f = f1.add(1l);        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f = f.add(0l);        assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());    }    public void testDivide() {        BigFraction a = new BigFraction(1, 2);        BigFraction b = new BigFraction(2, 3);        assertFraction(1, 1, a.divide(a));        assertFraction(3, 4, a.divide(b));        assertFraction(4, 3, b.divide(a));        assertFraction(1, 1, b.divide(b));        BigFraction f1 = new BigFraction(3, 5);        BigFraction f2 = BigFraction.ZERO;        try {            f1.divide(f2);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {        }        f1 = new BigFraction(0, 5);        f2 = new BigFraction(2, 7);        BigFraction f = f1.divide(f2);        assertSame(BigFraction.ZERO, f);        f1 = new BigFraction(2, 7);        f2 = BigFraction.ONE;        f = f1.divide(f2);        assertEquals(2, f.getNumeratorAsInt());        assertEquals(7, f.getDenominatorAsInt());        f1 = new BigFraction(1, Integer.MAX_VALUE);        f = f1.divide(f1);        assertEquals(1, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        f2 = new BigFraction(1, Integer.MAX_VALUE);        f = f1.divide(f2);        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        try {            f.divide((BigFraction) null);            fail("expecting NullArgumentException");        } catch (NullArgumentException ex) {        }        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        f = f1.divide(BigInteger.valueOf(Integer.MIN_VALUE));        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());        assertEquals(1, f.getNumeratorAsInt());        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        f = f1.divide(Integer.MIN_VALUE);        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());        assertEquals(1, f.getNumeratorAsInt());        f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        f = f1.divide((long) Integer.MIN_VALUE);        assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt());        assertEquals(1, f.getNumeratorAsInt());    }    public void testMultiply() {        BigFraction a = new BigFraction(1, 2);        BigFraction b = new BigFraction(2, 3);        assertFraction(1, 4, a.multiply(a));        assertFraction(1, 3, a.multiply(b));        assertFraction(1, 3, b.multiply(a));        assertFraction(4, 9, b.multiply(b));        BigFraction f1 = new BigFraction(Integer.MAX_VALUE, 1);        BigFraction f2 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);        BigFraction f = f1.multiply(f2);        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f = f2.multiply(Integer.MAX_VALUE);        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        f = f2.multiply((long) Integer.MAX_VALUE);        assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());        try {            f.multiply((BigFraction) null);            fail("expecting NullArgumentException");        } catch (NullArgumentException ex) {        }    }    public void testSubtract() {        BigFraction a = new BigFraction(1, 2);        BigFraction b = new BigFraction(2, 3);        assertFraction(0, 1, a.subtract(a));        assertFraction(-1, 6, a.subtract(b));        assertFraction(1, 6, b.subtract(a));        assertFraction(0, 1, b.subtract(b));        BigFraction f = new BigFraction(1, 1);        try {            f.subtract((BigFraction) null);            fail("expecting NullArgumentException");        } catch (NullArgumentException ex) {        }        // if this fraction is subtracted naively, it will overflow.        // check that it doesn't.        BigFraction f1 = new BigFraction(1, 32768 * 3);        BigFraction f2 = new BigFraction(1, 59049);        f = f1.subtract(f2);        assertEquals(-13085, f.getNumeratorAsInt());        assertEquals(1934917632, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MIN_VALUE, 3);        f2 = new BigFraction(1, 3).negate();        f = f1.subtract(f2);        assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt());        assertEquals(3, f.getDenominatorAsInt());        f1 = new BigFraction(Integer.MAX_VALUE, 1);        f2 = BigFraction.ONE;        f = f1.subtract(f2);        assertEquals(Integer.MAX_VALUE - 1, f.getNumeratorAsInt());        assertEquals(1, f.getDenominatorAsInt());    }    public void testBigDecimalValue() {        assertEquals(new BigDecimal(0.5), new BigFraction(1, 2).bigDecimalValue());        assertEquals(new BigDecimal("0.0003"), new BigFraction(3, 10000).bigDecimalValue());        assertEquals(new BigDecimal("0"), new BigFraction(1, 3).bigDecimalValue(BigDecimal.ROUND_DOWN));        assertEquals(new BigDecimal("0.333"), new BigFraction(1, 3).bigDecimalValue(3, BigDecimal.ROUND_DOWN));    }    public void testEqualsAndHashCode() {        BigFraction zero = new BigFraction(0, 1);        BigFraction nullFraction = null;        assertTrue(zero.equals(zero));        assertFalse(zero.equals(nullFraction));        assertFalse(zero.equals(Double.valueOf(0)));        BigFraction zero2 = new BigFraction(0, 2);        assertTrue(zero.equals(zero2));        assertEquals(zero.hashCode(), zero2.hashCode());        BigFraction one = new BigFraction(1, 1);        assertFalse((one.equals(zero) || zero.equals(one)));        assertTrue(one.equals(BigFraction.ONE));    }    public void testGetReducedFraction() {        BigFraction threeFourths = new BigFraction(3, 4);        assertTrue(threeFourths.equals(BigFraction.getReducedFraction(6, 8)));        assertTrue(BigFraction.ZERO.equals(BigFraction.getReducedFraction(0, -1)));        try {            BigFraction.getReducedFraction(1, 0);            fail("expecting ArithmeticException");        } catch (ArithmeticException ex) {            // expected        }        assertEquals(BigFraction.getReducedFraction(2, Integer.MIN_VALUE).getNumeratorAsInt(), -1);        assertEquals(BigFraction.getReducedFraction(1, -1).getNumeratorAsInt(), -1);    }    public void testPow() {        assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(13));        assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(13l));        assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(BigInteger.valueOf(13l)));        assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(0));        assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(0l));        assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(BigInteger.valueOf(0l)));        assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(-13));        assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(-13l));        assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(BigInteger.valueOf(-13l)));    }    public void testMath340() {        BigFraction fractionA = new BigFraction(0.00131);        BigFraction fractionB = new BigFraction(.37).reciprocal();        BigFraction errorResult = fractionA.multiply(fractionB);        BigFraction correctResult = new BigFraction(fractionA.getNumerator().multiply(fractionB.getNumerator()),                                                    fractionA.getDenominator().multiply(fractionB.getDenominator()));        assertEquals(correctResult, errorResult);    }    public void testSerial() throws FractionConversionException {        BigFraction[] fractions = {            new BigFraction(3, 4), BigFraction.ONE, BigFraction.ZERO,            new BigFraction(17), new BigFraction(FastMath.PI, 1000),            new BigFraction(-5, 2)        };        for (BigFraction fraction : fractions) {            assertEquals(fraction, TestUtils.serializeAndRecover(fraction));        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import org.apache.commons.math.TestUtils;import org.junit.Test;public class BigFractionFieldTest {    @Test    public void testZero() {        assertEquals(BigFraction.ZERO, BigFractionField.getInstance().getZero());    }    @Test    public void testOne() {        assertEquals(BigFraction.ONE, BigFractionField.getInstance().getOne());    }    @Test    public void testSerial() {        // deserializing the singleton should give the singleton itself back        BigFractionField field = BigFractionField.getInstance();        assertTrue(field == TestUtils.serializeAndRecover(field));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import java.text.NumberFormat;import java.text.ParseException;import java.util.Locale;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;public class FractionFormatTest extends TestCase {    FractionFormat properFormat = null;    FractionFormat improperFormat = null;    protected Locale getLocale() {        return Locale.getDefault();    }    @Override    protected void setUp() throws Exception {        properFormat = FractionFormat.getProperInstance(getLocale());        improperFormat = FractionFormat.getImproperInstance(getLocale());    }    public void testFormat() {        Fraction c = new Fraction(1, 2);        String expected = "1 / 2";        String actual = properFormat.format(c);        assertEquals(expected, actual);        actual = improperFormat.format(c);        assertEquals(expected, actual);    }    public void testFormatNegative() {        Fraction c = new Fraction(-1, 2);        String expected = "-1 / 2";        String actual = properFormat.format(c);        assertEquals(expected, actual);        actual = improperFormat.format(c);        assertEquals(expected, actual);    }    public void testFormatZero() {        Fraction c = new Fraction(0, 1);        String expected = "0 / 1";        String actual = properFormat.format(c);        assertEquals(expected, actual);        actual = improperFormat.format(c);        assertEquals(expected, actual);    }    public void testFormatImproper() {        Fraction c = new Fraction(5, 3);        String actual = properFormat.format(c);        assertEquals("1 2 / 3", actual);        actual = improperFormat.format(c);        assertEquals("5 / 3", actual);    }    public void testFormatImproperNegative() {        Fraction c = new Fraction(-5, 3);        String actual = properFormat.format(c);        assertEquals("-1 2 / 3", actual);        actual = improperFormat.format(c);        assertEquals("-5 / 3", actual);    }    public void testParse() {        String source = "1 / 2";        try {            Fraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(1, c.getNumerator());            assertEquals(2, c.getDenominator());            c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(1, c.getNumerator());            assertEquals(2, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseInteger() {        String source = "10";        try {            Fraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(10, c.getNumerator());            assertEquals(1, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }        try {            Fraction c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(10, c.getNumerator());            assertEquals(1, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseInvalid() {        String source = "a";        String msg = "should not be able to parse '10 / a'.";        try {            properFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }        try {            improperFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }    }    public void testParseInvalidDenominator() {        String source = "10 / a";        String msg = "should not be able to parse '10 / a'.";        try {            properFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }        try {            improperFormat.parse(source);            fail(msg);        } catch (ParseException ex) {            // success        }    }    public void testParseNegative() {        try {            String source = "-1 / 2";            Fraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumerator());            assertEquals(2, c.getDenominator());            c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumerator());            assertEquals(2, c.getDenominator());            source = "1 / -2";            c = properFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumerator());            assertEquals(2, c.getDenominator());            c = improperFormat.parse(source);            assertNotNull(c);            assertEquals(-1, c.getNumerator());            assertEquals(2, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseProper() {        String source = "1 2 / 3";        try {            Fraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(5, c.getNumerator());            assertEquals(3, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }        try {            improperFormat.parse(source);            fail("invalid improper fraction.");        } catch (ParseException ex) {            // success        }    }    public void testParseProperNegative() {        String source = "-1 2 / 3";        try {            Fraction c = properFormat.parse(source);            assertNotNull(c);            assertEquals(-5, c.getNumerator());            assertEquals(3, c.getDenominator());        } catch (ParseException ex) {            fail(ex.getMessage());        }        try {            improperFormat.parse(source);            fail("invalid improper fraction.");        } catch (ParseException ex) {            // success        }    }    public void testParseProperInvalidMinus() {        String source = "2 -2 / 3";        try {            properFormat.parse(source);            fail("invalid minus in improper fraction.");        } catch (ParseException ex) {            // expected        }        source = "2 2 / -3";        try {            properFormat.parse(source);            fail("invalid minus in improper fraction.");        } catch (ParseException ex) {            // expected        }    }    public void testNumeratorFormat() {        NumberFormat old = properFormat.getNumeratorFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        properFormat.setNumeratorFormat(nf);        assertEquals(nf, properFormat.getNumeratorFormat());        properFormat.setNumeratorFormat(old);        old = improperFormat.getNumeratorFormat();        nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        improperFormat.setNumeratorFormat(nf);        assertEquals(nf, improperFormat.getNumeratorFormat());        improperFormat.setNumeratorFormat(old);    }    public void testDenominatorFormat() {        NumberFormat old = properFormat.getDenominatorFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        properFormat.setDenominatorFormat(nf);        assertEquals(nf, properFormat.getDenominatorFormat());        properFormat.setDenominatorFormat(old);        old = improperFormat.getDenominatorFormat();        nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        improperFormat.setDenominatorFormat(nf);        assertEquals(nf, improperFormat.getDenominatorFormat());        improperFormat.setDenominatorFormat(old);    }    public void testWholeFormat() {        ProperFractionFormat format = (ProperFractionFormat)properFormat;        NumberFormat old = format.getWholeFormat();        NumberFormat nf = NumberFormat.getInstance();        nf.setParseIntegerOnly(true);        format.setWholeFormat(nf);        assertEquals(nf, format.getWholeFormat());        format.setWholeFormat(old);    }    public void testLongFormat() {        assertEquals("10 / 1", improperFormat.format(10l));    }    public void testDoubleFormat() {        assertEquals("355 / 113", improperFormat.format(FastMath.PI));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.fraction;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import org.apache.commons.math.TestUtils;import org.junit.Test;public class FractionFieldTest {    @Test    public void testZero() {        assertEquals(Fraction.ZERO, FractionField.getInstance().getZero());    }    @Test    public void testOne() {        assertEquals(Fraction.ONE, FractionField.getInstance().getOne());    }    @Test    public void testSerial() {        // deserializing the singleton should give the singleton itself back        FractionField field = FractionField.getInstance();        assertTrue(field == TestUtils.serializeAndRecover(field));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.util.FastMath;/** * Test cases for WeibullDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */public class WeibullDistributionTest extends ContinuousDistributionAbstractTest  {    /**     * Constructor for CauchyDistributionTest.     * @param arg0     */    public WeibullDistributionTest(String arg0) {        super(arg0);    }    //-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public WeibullDistribution makeDistribution() {        return new WeibullDistributionImpl(1.2, 2.1);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 2.9.2        return new double[] {0.00664355180993, 0.0454328283309, 0.0981162737374, 0.176713524579, 0.321946865392,                10.5115496887, 7.4976304671, 6.23205600701, 5.23968436955, 4.2079028257};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0.180535929306, 0.262801138133, 0.301905425199, 0.330899152971,          0.353441418887, 0.000788590320203, 0.00737060094841, 0.0177576041516, 0.0343043442574, 0.065664589369};    }    //---------------------------- Additional test cases -------------------------    public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0.0, 1.0});        setInverseCumulativeTestValues(                new double[] {0.0, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }    public void testAlpha() {        WeibullDistribution distribution = (WeibullDistribution) getDistribution();        double expected = FastMath.random();        distribution.setShape(expected);        assertEquals(expected, distribution.getShape(), 0.0);    }    public void testBeta() {        WeibullDistribution distribution = (WeibullDistribution) getDistribution();        double expected = FastMath.random();        distribution.setScale(expected);        assertEquals(expected, distribution.getScale(), 0.0);    }    public void testSetAlpha() {        WeibullDistribution distribution = (WeibullDistribution) getDistribution();        try {            distribution.setShape(0.0);            fail("Can not have 0.0 alpha.");        } catch (IllegalArgumentException ex) {            // success        }        try {            distribution.setShape(-1.0);            fail("Can not have negative alpha.");        } catch (IllegalArgumentException ex) {            // success        }    }    public void testSetBeta() {        WeibullDistribution distribution = (WeibullDistribution) getDistribution();        try {            distribution.setScale(0.0);            fail("Can not have 0.0 beta.");        } catch (IllegalArgumentException ex) {            // success        }        try {            distribution.setScale(-1.0);            fail("Can not have negative beta.");        } catch (IllegalArgumentException ex) {            // success        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for PascalDistribution. * Extends IntegerDistributionAbstractTest.  See class javadoc for * IntegerDistributionAbstractTest for details. * * @version $Revision$ $Date$ */public class PascalDistributionTest extends IntegerDistributionAbstractTest {    /**     * Constructor for PascalDistributionTest.     * @param name     */    public PascalDistributionTest(String name) {        super(name);    }    // --------------------- Override tolerance  --------------    protected double defaultTolerance = NormalDistributionImpl.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;    @Override    protected void setUp() throws Exception {        super.setUp();        setTolerance(defaultTolerance);    }    //-------------- Implementations for abstract methods -----------------------    /** Creates the default discrete distribution instance to use in tests. */    @Override    public IntegerDistribution makeDistribution() {        return new PascalDistributionImpl(10,0.70);    }    /** Creates the default probability density test input values */    @Override    public int[] makeDensityTestPoints() {      return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {      return new double[] {0, 0.0282475249, 0.0847425747, 0.139825248255, 0.167790297906, 0.163595540458,              0.137420253985, 0.103065190489, 0.070673273478, 0.0450542118422, 0.0270325271053,              0.0154085404500, 0.0084046584273};    }    /** Creates the default cumulative probability density test input values */    @Override    public int[] makeCumulativeTestPoints() {      return makeDensityTestPoints();    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {      return new double[] {0, 0.0282475249, 0.1129900996, 0.252815347855, 0.420605645761, 0.584201186219,              0.721621440204, 0.824686630693, 0.895359904171, 0.940414116013, 0.967446643119,              0.982855183569, 0.991259841996};        }    /** Creates the default inverse cumulative probability test input values */    @Override    public double[] makeInverseCumulativeTestPoints() {      return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,          0.990d, 0.975d, 0.950d, 0.900d, 1};        }    /** Creates the default inverse cumulative probability density test expected values */    @Override    public int[] makeInverseCumulativeTestValues() {      return new int[] {-1, -1, -1, -1, 0, 0, 13, 10, 9, 8, 7, Integer.MAX_VALUE};    }    //----------------- Additional test cases ---------------------------------    /** Test degenerate case p = 0   */    public void testDegenerate0() throws Exception {        setDistribution(new PascalDistributionImpl(5,0.0d));        setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });        setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 0d});        setDensityTestPoints(new int[] {-1, 0, 1, 10, 11});        setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 1});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }    /** Test degenerate case p = 1   */    public void testDegenerate1() throws Exception {        setDistribution(new PascalDistributionImpl(5,1.0d));        setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });        setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10});        setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {-1, -1});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.TestUtils;/** * Test cases for HyperGeometriclDistribution. * Extends IntegerDistributionAbstractTest.  See class javadoc for * IntegerDistributionAbstractTest for details. * * @version $Revision$ $Date$ */public class HypergeometricDistributionTest extends IntegerDistributionAbstractTest {    /**     * Constructor for ChiSquareDistributionTest.     * @param name     */    public HypergeometricDistributionTest(String name) {        super(name);    }//-------------- Implementations for abstract methods -----------------------    /** Creates the default discrete distribution instance to use in tests. */    @Override    public IntegerDistribution makeDistribution() {        return new HypergeometricDistributionImpl(10,5, 5);    }    /** Creates the default probability density test input values */    @Override    public int[] makeDensityTestPoints() {        return new int[] {-1, 0, 1, 2, 3, 4, 5, 10};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0d, 0.003968d, 0.099206d, 0.396825d, 0.396825d,                0.099206d, 0.003968d, 0d};    }    /** Creates the default cumulative probability density test input values */    @Override    public int[] makeCumulativeTestPoints() {        return makeDensityTestPoints();    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0d, .003968d, .103175d, .50000d, .896825d, .996032d,                1.00000d, 1d};    }    /** Creates the default inverse cumulative probability test input values */    @Override    public double[] makeInverseCumulativeTestPoints() {        return new double[] {0d, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d, 1d};    }    /** Creates the default inverse cumulative probability density test expected values */    @Override    public int[] makeInverseCumulativeTestValues() {        return new int[] {-1, -1, 0, 0, 0, 0, 4, 3, 3, 3, 3, 5};    }    //-------------------- Additional test cases ------------------------------    /** Verify that if there are no failures, mass is concentrated on sampleSize */    public void testDegenerateNoFailures() throws Exception {        setDistribution(new HypergeometricDistributionImpl(5,5,3));        setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });        setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});        setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {2, 2});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }    /** Verify that if there are no successes, mass is concentrated on 0 */    public void testDegenerateNoSuccesses() throws Exception {        setDistribution(new HypergeometricDistributionImpl(5,0,3));        setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });        setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});        setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {-1, -1});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }    /** Verify that if sampleSize = populationSize, mass is concentrated on numberOfSuccesses */    public void testDegenerateFullSample() throws Exception {        setDistribution(new HypergeometricDistributionImpl(5,3,5));        setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });        setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});        setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});        setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});        setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});        setInverseCumulativeTestValues(new int[] {2, 2});        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }    public void testPopulationSize() {        HypergeometricDistribution dist = new HypergeometricDistributionImpl(5,3,5);        try {            dist.setPopulationSize(-1);            fail("negative population size.  IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }        dist.setPopulationSize(10);        assertEquals(10, dist.getPopulationSize());    }    public void testLargeValues() {        int populationSize = 3456;        int sampleSize = 789;        int numberOfSucceses = 101;        double[][] data = {            {0.0, 2.75646034603961e-12, 2.75646034603961e-12, 1.0},            {1.0, 8.55705370142386e-11, 8.83269973602783e-11, 0.999999999997244},            {2.0, 1.31288129219665e-9, 1.40120828955693e-9, 0.999999999911673},            {3.0, 1.32724172984193e-8, 1.46736255879763e-8, 0.999999998598792},            {4.0, 9.94501711734089e-8, 1.14123796761385e-7, 0.999999985326375},            {5.0, 5.89080768883643e-7, 7.03204565645028e-7, 0.999999885876203},            {20.0, 0.0760051397707708, 0.27349758476299, 0.802507555007781},            {21.0, 0.087144222047629, 0.360641806810619, 0.72650241523701},            {22.0, 0.0940378846881819, 0.454679691498801, 0.639358193189381},            {23.0, 0.0956897500614809, 0.550369441560282, 0.545320308501199},            {24.0, 0.0919766921922999, 0.642346133752582, 0.449630558439718},            {25.0, 0.083641637261095, 0.725987771013677, 0.357653866247418},            {96.0, 5.93849188852098e-57, 1.0, 6.01900244560712e-57},            {97.0, 7.96593036832547e-59, 1.0, 8.05105570861321e-59},            {98.0, 8.44582921934367e-61, 1.0, 8.5125340287733e-61},            {99.0, 6.63604297068222e-63, 1.0, 6.670480942963e-63},            {100.0, 3.43501099007557e-65, 1.0, 3.4437972280786e-65},            {101.0, 8.78623800302957e-68, 1.0, 8.78623800302957e-68},        };        testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);    }    private void testHypergeometricDistributionProbabilities(int populationSize, int sampleSize, int numberOfSucceses, double[][] data) {        HypergeometricDistributionImpl dist = new HypergeometricDistributionImpl(populationSize, numberOfSucceses, sampleSize);        for (int i = 0; i < data.length; ++i) {            int x = (int)data[i][0];            double pdf = data[i][1];            double actualPdf = dist.probability(x);            TestUtils.assertRelativelyEquals("Expected equals for <"+x+"> pdf",pdf, actualPdf, 1.0e-9);            double cdf = data[i][2];            double actualCdf = dist.cumulativeProbability(x);            TestUtils.assertRelativelyEquals("Expected equals for <"+x+"> cdf",cdf, actualCdf, 1.0e-9);            double cdf1 = data[i][3];            double actualCdf1 = dist.upperCumulativeProbability(x);            TestUtils.assertRelativelyEquals("Expected equals for <"+x+"> cdf1",cdf1, actualCdf1, 1.0e-9);        }    }    public void testMoreLargeValues() {        int populationSize = 26896;        int sampleSize = 895;        int numberOfSucceses = 55;        double[][] data = {            {0.0, 0.155168304750504, 0.155168304750504, 1.0},            {1.0, 0.29437545000746, 0.449543754757964, 0.844831695249496},            {2.0, 0.273841321577003, 0.723385076334967, 0.550456245242036},            {3.0, 0.166488572570786, 0.889873648905753, 0.276614923665033},            {4.0, 0.0743969744713231, 0.964270623377076, 0.110126351094247},            {5.0, 0.0260542785784855, 0.990324901955562, 0.0357293766229237},            {20.0, 3.57101101678792e-16, 1.0, 3.78252101622096e-16},            {21.0, 2.00551638598312e-17, 1.0, 2.11509999433041e-17},            {22.0, 1.04317070180562e-18, 1.0, 1.09583608347287e-18},            {23.0, 5.03153504903308e-20, 1.0, 5.266538166725e-20},            {24.0, 2.2525984149695e-21, 1.0, 2.35003117691919e-21},            {25.0, 9.3677424515947e-23, 1.0, 9.74327619496943e-23},            {50.0, 9.83633962945521e-69, 1.0, 9.8677629437617e-69},            {51.0, 3.13448949497553e-71, 1.0, 3.14233143064882e-71},            {52.0, 7.82755221928122e-74, 1.0, 7.84193567329055e-74},            {53.0, 1.43662126065532e-76, 1.0, 1.43834540093295e-76},            {54.0, 1.72312692517348e-79, 1.0, 1.7241402776278e-79},            {55.0, 1.01335245432581e-82, 1.0, 1.01335245432581e-82},        };        testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * Abstract base class for {@link IntegerDistribution} tests. * <p> * To create a concrete test class for an integer distribution implementation, *  implement makeDistribution() to return a distribution instance to use in *  tests and each of the test data generation methods below.  In each case, the *  test points and test values arrays returned represent parallel arrays of *  inputs and expected values for the distribution returned by makeDistribution(). *  <p> *  makeDensityTestPoints() -- arguments used to test probability density calculation *  makeDensityTestValues() -- expected probability densities *  makeCumulativeTestPoints() -- arguments used to test cumulative probabilities *  makeCumulativeTestValues() -- expected cumulative probabilites *  makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf evaluation *  makeInverseCumulativeTestValues() -- expected inverse cdf values * <p> *  To implement additional test cases with different distribution instances and test data, *  use the setXxx methods for the instance data in test cases and call the verifyXxx methods *  to verify results. * * @version $Revision$ $Date$ */public abstract class IntegerDistributionAbstractTest extends TestCase {//-------------------- Private test instance data -------------------------    /** Discrete distribution instance used to perform tests */    private IntegerDistribution distribution;    /** Tolerance used in comparing expected and returned values */    private double tolerance = 1E-4;    /** Arguments used to test probability density calculations */    private int[] densityTestPoints;    /** Values used to test probability density calculations */    private double[] densityTestValues;    /** Arguments used to test cumulative probability density calculations */    private int[] cumulativeTestPoints;    /** Values used to test cumulative probability density calculations */    private double[] cumulativeTestValues;    /** Arguments used to test inverse cumulative probability density calculations */    private double[] inverseCumulativeTestPoints;    /** Values used to test inverse cumulative probability density calculations */    private int[] inverseCumulativeTestValues;    //-------------------------------------------------------------------------    /**     * Constructor for IntegerDistributionAbstractTest.     * @param name     */    public IntegerDistributionAbstractTest(String name) {        super(name);    }    //-------------------- Abstract methods -----------------------------------    /** Creates the default discrete distribution instance to use in tests. */    public abstract IntegerDistribution makeDistribution();    /** Creates the default probability density test input values */    public abstract int[] makeDensityTestPoints();    /** Creates the default probability density test expected values */    public abstract double[] makeDensityTestValues();    /** Creates the default cumulative probability density test input values */    public abstract int[] makeCumulativeTestPoints();    /** Creates the default cumulative probability density test expected values */    public abstract double[] makeCumulativeTestValues();    /** Creates the default inverse cumulative probability test input values */    public abstract double[] makeInverseCumulativeTestPoints();    /** Creates the default inverse cumulative probability density test expected values */    public abstract int[] makeInverseCumulativeTestValues();    //-------------------- Setup / tear down ----------------------------------    /**     * Setup sets all test instance data to default values     */    @Override    protected void setUp() throws Exception {        super.setUp();        distribution = makeDistribution();        densityTestPoints = makeDensityTestPoints();        densityTestValues = makeDensityTestValues();        cumulativeTestPoints = makeCumulativeTestPoints();        cumulativeTestValues = makeCumulativeTestValues();        inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();        inverseCumulativeTestValues = makeInverseCumulativeTestValues();    }    /**     * Cleans up test instance data     */    @Override    protected void tearDown() throws Exception {        super.tearDown();        distribution = null;        densityTestPoints = null;        densityTestValues = null;        cumulativeTestPoints = null;        cumulativeTestValues = null;        inverseCumulativeTestPoints = null;        inverseCumulativeTestValues = null;    }    //-------------------- Verification methods -------------------------------    /**     * Verifies that probability density calculations match expected values     * using current test instance data     */    protected void verifyDensities() throws Exception {        for (int i = 0; i < densityTestPoints.length; i++) {            assertEquals("Incorrect density value returned for " + densityTestPoints[i],                    densityTestValues[i],                    distribution.probability(densityTestPoints[i]), tolerance);        }    }    /**     * Verifies that cumulative probability density calculations match expected values     * using current test instance data     */    protected void verifyCumulativeProbabilities() throws Exception {        for (int i = 0; i < cumulativeTestPoints.length; i++) {            assertEquals("Incorrect cumulative probability value returned for " + cumulativeTestPoints[i],                    cumulativeTestValues[i],                    distribution.cumulativeProbability(cumulativeTestPoints[i]), tolerance);        }    }    /**     * Verifies that inverse cumulative probability density calculations match expected values     * using current test instance data     */    protected void verifyInverseCumulativeProbabilities() throws Exception {        for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {            assertEquals("Incorrect inverse cumulative probability value returned for "                    + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i],                    distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]));        }    }    //------------------------ Default test cases -----------------------------    /**     * Verifies that probability density calculations match expected values     * using default test instance data     */    public void testDensities() throws Exception {        verifyDensities();    }    /**     * Verifies that cumulative probability density calculations match expected values     * using default test instance data     */    public void testCumulativeProbabilities() throws Exception {        verifyCumulativeProbabilities();    }    /**     * Verifies that floating point arguments are correctly handled by     * cumulativeProbablility(-,-)     * JIRA: MATH-184     */    public void testFloatingPointArguments() throws Exception {        for (int i = 0; i < cumulativeTestPoints.length; i++) {            double arg = cumulativeTestPoints[i];            assertEquals(                    "Incorrect cumulative probability value returned for " +                    cumulativeTestPoints[i],                    cumulativeTestValues[i],                    distribution.cumulativeProbability(arg), tolerance);            if (i < cumulativeTestPoints.length - 1) {                double arg2 = cumulativeTestPoints[i + 1];                assertEquals("Inconsistent probability for discrete range " +                        "[ " + arg + "," + arg2 + " ]",                   distribution.cumulativeProbability(                           cumulativeTestPoints[i],                           cumulativeTestPoints[i + 1]),                   distribution.cumulativeProbability(arg, arg2), tolerance);                arg = arg - FastMath.random();                arg2 = arg2 + FastMath.random();                assertEquals("Inconsistent probability for discrete range " +                        "[ " + arg + "," + arg2 + " ]",                   distribution.cumulativeProbability(                           cumulativeTestPoints[i],                           cumulativeTestPoints[i + 1]),                   distribution.cumulativeProbability(arg, arg2), tolerance);            }        }        int one = 1;        int ten = 10;        int two = 2;        double oned = one;        double twod = two;        double tend = ten;        assertEquals(distribution.cumulativeProbability(one, two),                distribution.cumulativeProbability(oned, twod), tolerance);        assertEquals(distribution.cumulativeProbability(one, two),                distribution.cumulativeProbability(oned - tolerance,                        twod + 0.9), tolerance);        assertEquals(distribution.cumulativeProbability(two, ten),                distribution.cumulativeProbability(twod, tend), tolerance);        assertEquals(distribution.cumulativeProbability(two, ten),                distribution.cumulativeProbability(twod - tolerance,                        tend + 0.9), tolerance);    }    /**     * Verifies that inverse cumulative probability density calculations match expected values     * using default test instance data     */    public void testInverseCumulativeProbabilities() throws Exception {        verifyInverseCumulativeProbabilities();    }    /**     * Verifies that illegal arguments are correctly handled     */    public void testIllegalArguments() throws Exception {        try {            distribution.cumulativeProbability(1, 0);            fail("Expecting IllegalArgumentException for bad cumulativeProbability interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            distribution.inverseCumulativeProbability(-1);            fail("Expecting IllegalArgumentException for p = -1");        } catch (IllegalArgumentException ex) {            // expected        }        try {            distribution.inverseCumulativeProbability(2);            fail("Expecting IllegalArgumentException for p = 2");        } catch (IllegalArgumentException ex) {            // expected        }    }        /**     * Test sampling     */    public void testSampling() throws Exception {        int[] densityPoints = makeDensityTestPoints();        double[] densityValues = makeDensityTestValues();        int sampleSize = 1000;        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);        AbstractIntegerDistribution distribution = (AbstractIntegerDistribution) makeDistribution();        double[] expectedCounts = new double[length];        long[] observedCounts = new long[length];        for (int i = 0; i < length; i++) {            expectedCounts[i] = sampleSize * densityValues[i];        }        distribution.reseedRandomGenerator(1000); // Use fixed seed        int[] sample = distribution.sample(sampleSize);        for (int i = 0; i < sampleSize; i++) {          for (int j = 0; j < length; j++) {              if (sample[i] == densityPoints[j]) {                  observedCounts[j]++;              }          }        }        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);    }    //------------------ Getters / Setters for test instance data -----------    /**     * @return Returns the cumulativeTestPoints.     */    protected int[] getCumulativeTestPoints() {        return cumulativeTestPoints;    }    /**     * @param cumulativeTestPoints The cumulativeTestPoints to set.     */    protected void setCumulativeTestPoints(int[] cumulativeTestPoints) {        this.cumulativeTestPoints = cumulativeTestPoints;    }    /**     * @return Returns the cumulativeTestValues.     */    protected double[] getCumulativeTestValues() {        return cumulativeTestValues;    }    /**     * @param cumulativeTestValues The cumulativeTestValues to set.     */    protected void setCumulativeTestValues(double[] cumulativeTestValues) {        this.cumulativeTestValues = cumulativeTestValues;    }    /**     * @return Returns the densityTestPoints.     */    protected int[] getDensityTestPoints() {        return densityTestPoints;    }    /**     * @param densityTestPoints The densityTestPoints to set.     */    protected void setDensityTestPoints(int[] densityTestPoints) {        this.densityTestPoints = densityTestPoints;    }    /**     * @return Returns the densityTestValues.     */    protected double[] getDensityTestValues() {        return densityTestValues;    }    /**     * @param densityTestValues The densityTestValues to set.     */    protected void setDensityTestValues(double[] densityTestValues) {        this.densityTestValues = densityTestValues;    }    /**     * @return Returns the distribution.     */    protected IntegerDistribution getDistribution() {        return distribution;    }    /**     * @param distribution The distribution to set.     */    protected void setDistribution(IntegerDistribution distribution) {        this.distribution = distribution;    }    /**     * @return Returns the inverseCumulativeTestPoints.     */    protected double[] getInverseCumulativeTestPoints() {        return inverseCumulativeTestPoints;    }    /**     * @param inverseCumulativeTestPoints The inverseCumulativeTestPoints to set.     */    protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) {        this.inverseCumulativeTestPoints = inverseCumulativeTestPoints;    }    /**     * @return Returns the inverseCumulativeTestValues.     */    protected int[] getInverseCumulativeTestValues() {        return inverseCumulativeTestValues;    }    /**     * @param inverseCumulativeTestValues The inverseCumulativeTestValues to set.     */    protected void setInverseCumulativeTestValues(int[] inverseCumulativeTestValues) {        this.inverseCumulativeTestValues = inverseCumulativeTestValues;    }    /**     * @return Returns the tolerance.     */    protected double getTolerance() {        return tolerance;    }    /**     * @param tolerance The tolerance to set.     */    protected void setTolerance(double tolerance) {        this.tolerance = tolerance;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for TDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */public class TDistributionTest extends ContinuousDistributionAbstractTest {    /**     * Constructor for TDistributionTest.     * @param name     */    public TDistributionTest(String name) {        super(name);    }//-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public TDistribution makeDistribution() {        return new TDistributionImpl(5.0);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 2.9.2        return new double[] {-5.89342953136, -3.36492999891, -2.57058183564, -2.01504837333, -1.47588404882,                5.89342953136, 3.36492999891, 2.57058183564, 2.01504837333, 1.47588404882};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999,                0.990, 0.975, 0.950, 0.900};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0.000756494565517, 0.0109109752919, 0.0303377878006, 0.0637967988952, 0.128289492005,                0.000756494565517, 0.0109109752919, 0.0303377878006, 0.0637967988952, 0.128289492005};    }    // --------------------- Override tolerance  --------------    @Override    protected void setUp() throws Exception {        super.setUp();        setTolerance(1E-9);    }    //---------------------------- Additional test cases -------------------------    /**     * @see <a href="http://issues.apache.org/bugzilla/show_bug.cgi?id=27243">     *      Bug report that prompted this unit test.</a>     */    public void testCumulativeProbabilityAgaintStackOverflow() throws Exception {        TDistributionImpl td = new TDistributionImpl(5.);        td.cumulativeProbability(.1);        td.cumulativeProbability(.01);    }    public void testSmallDf() throws Exception {        setDistribution(new TDistributionImpl(1d));        // quantiles computed using R version 2.9.2        setCumulativeTestPoints(new double[] {-318.308838986, -31.8205159538, -12.7062047362,                -6.31375151468, -3.07768353718, 318.308838986, 31.8205159538, 12.7062047362,                 6.31375151468, 3.07768353718});        setDensityTestValues(new double[] {3.14158231817e-06, 0.000314055924703, 0.00195946145194,                0.00778959736375, 0.0303958893917, 3.14158231817e-06, 0.000314055924703,                0.00195946145194, 0.00778959736375, 0.0303958893917});        setInverseCumulativeTestValues(getCumulativeTestPoints());        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();        verifyDensities();    }    public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0, 1});        setInverseCumulativeTestValues(                new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }    public void testDfAccessors() {        TDistribution distribution = (TDistribution) getDistribution();        assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);        distribution.setDegreesOfFreedom(4d);        assertEquals(4d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);        try {            distribution.setDegreesOfFreedom(0d);            fail("Expecting IllegalArgumentException for df = 0");        } catch (IllegalArgumentException ex) {            // expected        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.util.FastMath;/** * Test cases for CauchyDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */public class CauchyDistributionTest extends ContinuousDistributionAbstractTest  {    /**     * Constructor for CauchyDistributionTest.     * @param arg0     */    public CauchyDistributionTest(String arg0) {        super(arg0);    }    // --------------------- Override tolerance  --------------    protected double defaultTolerance = NormalDistributionImpl.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;    @Override    protected void setUp() throws Exception {        super.setUp();        setTolerance(defaultTolerance);    }    //-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public CauchyDistribution makeDistribution() {        return new CauchyDistributionImpl(1.2, 2.1);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R 2.9.2        return new double[] {-667.24856187, -65.6230835029, -25.4830299460, -12.0588781808,                -5.26313542807, 669.64856187, 68.0230835029, 27.8830299460, 14.4588781808, 7.66313542807};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999,                0.990, 0.975, 0.950, 0.900};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {1.49599158008e-06, 0.000149550440335, 0.000933076881878, 0.00370933207799, 0.0144742330437,                1.49599158008e-06, 0.000149550440335, 0.000933076881878, 0.00370933207799, 0.0144742330437};    }    //---------------------------- Additional test cases -------------------------    public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0.0, 1.0});        setInverseCumulativeTestValues(                new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }    public void testMedian() {        CauchyDistribution distribution = (CauchyDistribution) getDistribution();        double expected = FastMath.random();        distribution.setMedian(expected);        assertEquals(expected, distribution.getMedian(), 0.0);    }    public void testScale() {        CauchyDistribution distribution = (CauchyDistribution) getDistribution();        double expected = FastMath.random();        distribution.setScale(expected);        assertEquals(expected, distribution.getScale(), 0.0);    }    public void testSetScale() {        CauchyDistribution distribution = (CauchyDistribution) getDistribution();        try {            distribution.setScale(0.0);            fail("Can not have 0.0 scale.");        } catch (IllegalArgumentException ex) {            // success        }        try {            distribution.setScale(-1.0);            fail("Can not have negative scale.");        } catch (IllegalArgumentException ex) {            // success        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for FDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */public class FDistributionTest extends ContinuousDistributionAbstractTest {    /**     * Constructor for FDistributionTest.     * @param name     */    public FDistributionTest(String name) {        super(name);    }    //-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public FDistribution makeDistribution() {        return new FDistributionImpl(5.0, 6.0);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 2.9.2        return new double[] {0.0346808448626, 0.0937009113303, 0.143313661184, 0.202008445998, 0.293728320107,                20.8026639595, 8.74589525602, 5.98756512605, 4.38737418741, 3.10751166664};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0.0689156576706, 0.236735653193, 0.364074131941, 0.481570789649, 0.595880479994,                0.000133443915657, 0.00286681303403, 0.00969192007502, 0.0242883861471, 0.0605491314658};    }    // --------------------- Override tolerance  --------------    @Override    protected void setUp() throws Exception {        super.setUp();        setTolerance(1e-9);    }    //---------------------------- Additional test cases -------------------------    public void testCumulativeProbabilityExtremes() throws Exception {        setCumulativeTestPoints(new double[] {-2, 0});        setCumulativeTestValues(new double[] {0, 0});        verifyCumulativeProbabilities();    }    public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0, 1});        setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }    public void testDfAccessors() {        FDistribution distribution = (FDistribution) getDistribution();        assertEquals(5d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);        distribution.setNumeratorDegreesOfFreedom(4d);        assertEquals(4d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);        assertEquals(6d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);        distribution.setDenominatorDegreesOfFreedom(4d);        assertEquals(4d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE);        try {            distribution.setNumeratorDegreesOfFreedom(0d);            fail("Expecting IllegalArgumentException for df = 0");        } catch (IllegalArgumentException ex) {            // expected        }        try {            distribution.setDenominatorDegreesOfFreedom(0d);            fail("Expecting IllegalArgumentException for df = 0");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testLargeDegreesOfFreedom() throws Exception {        org.apache.commons.math.distribution.FDistributionImpl fd =            new org.apache.commons.math.distribution.FDistributionImpl(                100000., 100000.);        double p = fd.cumulativeProbability(.999);        double x = fd.inverseCumulativeProbability(p);        assertEquals(.999, x, 1.0e-5);    }    public void testSmallDegreesOfFreedom() throws Exception {        org.apache.commons.math.distribution.FDistributionImpl fd =            new org.apache.commons.math.distribution.FDistributionImpl(                1.0, 1.0);        double p = fd.cumulativeProbability(0.975);        double x = fd.inverseCumulativeProbability(p);        assertEquals(0.975, x, 1.0e-5);        fd.setDenominatorDegreesOfFreedom(2.0);        p = fd.cumulativeProbability(0.975);        x = fd.inverseCumulativeProbability(p);        assertEquals(0.975, x, 1.0e-5);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.exception.NotStrictlyPositiveException;/** * Test cases for GammaDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */public class GammaDistributionTest extends ContinuousDistributionAbstractTest {    /**     * Constructor for GammaDistributionTest.     * @param name     */    public GammaDistributionTest(String name) {        super(name);    }    //-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public GammaDistribution makeDistribution() {        return new GammaDistributionImpl(4d, 2d);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 2.9.2        return new double[] {0.857104827257, 1.64649737269, 2.17973074725, 2.7326367935, 3.48953912565,                26.1244815584, 20.0902350297, 17.5345461395, 15.5073130559, 13.3615661365};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0.00427280075546, 0.0204117166709, 0.0362756163658, 0.0542113174239, 0.0773195272491,                0.000394468852816, 0.00366559696761, 0.00874649473311, 0.0166712508128, 0.0311798227954};    }    // --------------------- Override tolerance  --------------    @Override    protected void setUp() throws Exception {        super.setUp();        setTolerance(1e-9);    }    //---------------------------- Additional test cases -------------------------    public void testParameterAccessors() {        GammaDistribution distribution = (GammaDistribution) getDistribution();        assertEquals(4d, distribution.getAlpha(), 0);        assertEquals(2d, distribution.getBeta(), 0);    }    public void testPreconditions() {        try {            GammaDistribution distribution = new GammaDistributionImpl(0, 1);            fail("Expecting NotStrictlyPositiveException for alpha = 0");        } catch (NotStrictlyPositiveException ex) {            // Expected.        }        try {            GammaDistribution distribution = new GammaDistributionImpl(1, 0);            fail("Expecting NotStrictlyPositiveException for alpha = 0");        } catch (NotStrictlyPositiveException ex) {            // Expected.        }    }    public void testProbabilities() throws Exception {        testProbability(-1.000, 4.0, 2.0, .0000);        testProbability(15.501, 4.0, 2.0, .9499);        testProbability(0.504, 4.0, 1.0, .0018);        testProbability(10.011, 1.0, 2.0, .9933);        testProbability(5.000, 2.0, 2.0, .7127);    }    public void testValues() throws Exception {        testValue(15.501, 4.0, 2.0, .9499);        testValue(0.504, 4.0, 1.0, .0018);        testValue(10.011, 1.0, 2.0, .9933);        testValue(5.000, 2.0, 2.0, .7127);    }    private void testProbability(double x, double a, double b, double expected) throws Exception {        GammaDistribution distribution = new GammaDistributionImpl( a, b );        double actual = distribution.cumulativeProbability(x);        assertEquals("probability for " + x, expected, actual, 10e-4);    }    private void testValue(double expected, double a, double b, double p) throws Exception {        GammaDistribution distribution = new GammaDistributionImpl( a, b );        double actual = distribution.inverseCumulativeProbability(p);        assertEquals("critical value for " + p, expected, actual, 10e-4);    }    public void testDensity() {        double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};        // R2.5: print(dgamma(x, shape=1, rate=1), digits=10)        checkDensity(1, 1, x, new double[]{0.000000000000, 0.999999000001, 0.606530659713, 0.367879441171, 0.135335283237, 0.006737946999});        // R2.5: print(dgamma(x, shape=2, rate=1), digits=10)        checkDensity(2, 1, x, new double[]{0.000000000000, 0.000000999999, 0.303265329856, 0.367879441171, 0.270670566473, 0.033689734995});        // R2.5: print(dgamma(x, shape=4, rate=1), digits=10)        checkDensity(4, 1, x, new double[]{0.000000000e+00, 1.666665000e-19, 1.263605541e-02, 6.131324020e-02, 1.804470443e-01, 1.403738958e-01});        // R2.5: print(dgamma(x, shape=4, rate=10), digits=10)        checkDensity(4, 10, x, new double[]{0.000000000e+00, 1.666650000e-15, 1.403738958e+00, 7.566654960e-02, 2.748204830e-05, 4.018228850e-17});        // R2.5: print(dgamma(x, shape=.1, rate=10), digits=10)        checkDensity(0.1, 10, x, new double[]{0.000000000e+00, 3.323953832e+04, 1.663849010e-03, 6.007786726e-06, 1.461647647e-10, 5.996008322e-24});        // R2.5: print(dgamma(x, shape=.1, rate=20), digits=10)        checkDensity(0.1, 20, x, new double[]{0.000000000e+00, 3.562489883e+04, 1.201557345e-05, 2.923295295e-10, 3.228910843e-19, 1.239484589e-45});        // R2.5: print(dgamma(x, shape=.1, rate=4), digits=10)        checkDensity(0.1, 4, x, new double[]{0.000000000e+00, 3.032938388e+04, 3.049322494e-02, 2.211502311e-03, 2.170613371e-05, 5.846590589e-11});        // R2.5: print(dgamma(x, shape=.1, rate=1), digits=10)        checkDensity(0.1, 1, x, new double[]{0.000000000e+00, 2.640334143e+04, 1.189704437e-01, 3.866916944e-02, 7.623306235e-03, 1.663849010e-04});    }    private void checkDensity(double alpha, double rate, double[] x, double[] expected) {        GammaDistribution d = new GammaDistributionImpl(alpha, 1 / rate);        for (int i = 0; i < x.length; i++) {            assertEquals(expected[i], d.density(x[i]), 1e-5);        }    }    public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0, 1});        setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import junit.framework.TestCase;import org.apache.commons.math.MathException;public class BetaDistributionTest extends TestCase {    public void testCumulative() throws MathException {        double[] x = new double[]{-0.1, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1};        // all test data computed using R 2.5        checkCumulative(0.1, 0.1,                x, new double[]{                0.0000000000, 0.0000000000, 0.4063850939, 0.4397091902, 0.4628041861,                0.4821200456, 0.5000000000, 0.5178799544, 0.5371958139, 0.5602908098,                0.5936149061, 1.0000000000, 1.0000000000});        checkCumulative(0.1, 0.5,                x, new double[]{                0.0000000000, 0.0000000000, 0.7048336221, 0.7593042194, 0.7951765304,                0.8234948385, 0.8480017124, 0.8706034370, 0.8926585878, 0.9156406404,                0.9423662883, 1.0000000000, 1.0000000000});        checkCumulative(0.1, 1.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.7943282347, 0.8513399225, 0.8865681506,                0.9124435366, 0.9330329915, 0.9502002165, 0.9649610951, 0.9779327685,                0.9895192582, 1.0000000000, 1.0000000000});        checkCumulative(0.1, 2.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.8658177758, 0.9194471163, 0.9486279211,                0.9671901487, 0.9796846411, 0.9882082252, 0.9939099280, 0.9974914239,                0.9994144508, 1.0000000000, 1.0000000000});        checkCumulative(0.1, 4.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.9234991121, 0.9661958941, 0.9842285085,                0.9928444112, 0.9970040660, 0.9989112804, 0.9996895625, 0.9999440793,                0.9999967829, 1.0000000000, 1.0000000000});        checkCumulative(0.5, 0.1,                x, new double[]{                0.00000000000, 0.00000000000, 0.05763371168, 0.08435935962,                0.10734141216, 0.12939656302, 0.15199828760, 0.17650516146,                0.20482346963, 0.24069578055, 0.29516637795, 1.00000000000, 1.00000000000});        checkCumulative(0.5, 0.5,                x, new double[]{                0.0000000000, 0.0000000000, 0.2048327647, 0.2951672353, 0.3690101196,                0.4359057832, 0.5000000000, 0.5640942168, 0.6309898804, 0.7048327647,                0.7951672353, 1.0000000000, 1.0000000000});        checkCumulative(0.5, 1.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.3162277660, 0.4472135955, 0.5477225575,                0.6324555320, 0.7071067812, 0.7745966692, 0.8366600265, 0.8944271910,                0.9486832981, 1.0000000000, 1.0000000000});        checkCumulative(0.5, 2.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.4585302607, 0.6260990337, 0.7394254526,                0.8221921916, 0.8838834765, 0.9295160031, 0.9621590305, 0.9838699101,                0.9961174630, 1.0000000000, 1.0000000000});        checkCumulative(0.5, 4.0,                x, new double[]{                0.0000000000, 0.0000000000, 0.6266250826, 0.8049844719, 0.8987784842,                0.9502644369, 0.9777960959, 0.9914837366, 0.9974556254, 0.9995223859,                0.9999714889, 1.0000000000, 1.0000000000});        checkCumulative(1.0, 0.1,                x, new double[]{                0.00000000000, 0.00000000000, 0.01048074179, 0.02206723146,                0.03503890488, 0.04979978349, 0.06696700846, 0.08755646344,                0.11343184943, 0.14866007748, 0.20567176528, 1.00000000000, 1.00000000000});        checkCumulative(1.0, 0.5,                x, new double[]{                0.00000000000, 0.00000000000, 0.05131670195, 0.10557280900,                0.16333997347, 0.22540333076, 0.29289321881, 0.36754446797,                0.45227744249, 0.55278640450, 0.68377223398, 1.00000000000, 1.00000000000});        checkCumulative(1, 1,                x, new double[]{                0.0, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0});        checkCumulative(1, 2,                x, new double[]{                0.00, 0.00, 0.19, 0.36, 0.51, 0.64, 0.75, 0.84, 0.91, 0.96, 0.99, 1.00, 1.00});        checkCumulative(1, 4,                x, new double[]{                0.0000, 0.0000, 0.3439, 0.5904, 0.7599, 0.8704, 0.9375, 0.9744, 0.9919,                0.9984, 0.9999, 1.0000, 1.0000});        checkCumulative(2.0, 0.1,                x, new double[]{                0.0000000000000, 0.0000000000000, 0.0005855492117, 0.0025085760862,                0.0060900720266, 0.0117917748341, 0.0203153588864, 0.0328098512512,                0.0513720788952, 0.0805528836776, 0.1341822241505, 1.0000000000000, 1.0000000000000});        checkCumulative(2, 1,                x, new double[]{                0.00, 0.00, 0.01, 0.04, 0.09, 0.16, 0.25, 0.36, 0.49, 0.64, 0.81, 1.00, 1.00});        checkCumulative(2.0, 0.5,                x, new double[]{                0.000000000000, 0.000000000000, 0.003882537047, 0.016130089900,                0.037840969486, 0.070483996910, 0.116116523517, 0.177807808356,                0.260574547368, 0.373900966300, 0.541469739276, 1.000000000000, 1.000000000000});        checkCumulative(2, 2,                x, new double[]{                0.000, 0.000, 0.028, 0.104, 0.216, 0.352, 0.500, 0.648, 0.784, 0.896, 0.972, 1.000, 1.000});        checkCumulative(2, 4,                x, new double[]{                0.00000, 0.00000, 0.08146, 0.26272, 0.47178, 0.66304, 0.81250, 0.91296,                0.96922, 0.99328, 0.99954, 1.00000, 1.00000});        checkCumulative(4.0, 0.1,                x, new double[]{                0.000000000e+00, 0.000000000e+00, 3.217128269e-06, 5.592070271e-05,                3.104375474e-04, 1.088719595e-03, 2.995933981e-03, 7.155588777e-03,                1.577149153e-02, 3.380410585e-02, 7.650088789e-02, 1.000000000e+00, 1.000000000e+00});        checkCumulative(4.0, 0.5,                x, new double[]{                0.000000000e+00, 0.000000000e+00, 2.851114863e-05, 4.776140576e-04,                2.544374616e-03, 8.516263371e-03, 2.220390414e-02, 4.973556312e-02,                1.012215158e-01, 1.950155281e-01, 3.733749174e-01, 1.000000000e+00, 1.000000000e+00});        checkCumulative(4, 1,                x, new double[]{                0.0000, 0.0000, 0.0001, 0.0016, 0.0081, 0.0256, 0.0625, 0.1296, 0.2401,                0.4096, 0.6561, 1.0000, 1.0000});        checkCumulative(4, 2,                x, new double[]{                0.00000, 0.00000, 0.00046, 0.00672, 0.03078, 0.08704, 0.18750, 0.33696,                0.52822, 0.73728, 0.91854, 1.00000, 1.00000});        checkCumulative(4, 4,                x, new double[]{                0.000000, 0.000000, 0.002728, 0.033344, 0.126036, 0.289792, 0.500000,                0.710208, 0.873964, 0.966656, 0.997272, 1.000000, 1.000000});    }    private void checkCumulative(double alpha, double beta, double[] x, double[] cumes) throws MathException {        BetaDistribution d = new BetaDistributionImpl(alpha, beta);        for (int i = 0; i < x.length; i++) {            assertEquals(cumes[i], d.cumulativeProbability(x[i]), 1e-8);        }        for (int i = 1; i < x.length - 1; i++) {            assertEquals(x[i], d.inverseCumulativeProbability(cumes[i]), 1e-5);        }    }    public void testDensity() throws MathException {        double[] x = new double[]{1e-6, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9};        checkDensity(0.1, 0.1,                x, new double[]{                12741.2357380649, 0.4429889586665234, 2.639378715e-01, 2.066393611e-01,                1.832401831e-01, 1.766302780e-01, 1.832404579e-01, 2.066400696e-01,                2.639396531e-01, 4.429925026e-01});        checkDensity(0.1, 0.5,                x, new double[]{                2.218377102e+04, 7.394524202e-01, 4.203020268e-01, 3.119435533e-01,                2.600787829e-01, 2.330648626e-01, 2.211408259e-01, 2.222728708e-01,                2.414013907e-01, 3.070567405e-01});        checkDensity(0.1, 1.0,                x, new double[]{                2.511886432e+04, 7.943210858e-01, 4.256680458e-01, 2.955218303e-01,                2.281103709e-01, 1.866062624e-01, 1.583664652e-01, 1.378514078e-01,                1.222414585e-01, 1.099464743e-01});        checkDensity(0.1, 2.0,                x, new double[]{                2.763072312e+04, 7.863770012e-01, 3.745874120e-01, 2.275514842e-01,                1.505525939e-01, 1.026332391e-01, 6.968107049e-02, 4.549081293e-02,                2.689298641e-02, 1.209399123e-02});        checkDensity(0.1, 4.0,                x, new double[]{                2.997927462e+04, 6.911058917e-01, 2.601128486e-01, 1.209774010e-01,                5.880564714e-02, 2.783915474e-02, 1.209657335e-02, 4.442148268e-03,                1.167143939e-03, 1.312171805e-04});        checkDensity(0.5, 0.1,                x, new double[]{                88.3152184726, 0.3070542841, 0.2414007269, 0.2222727015,                0.2211409364, 0.2330652355, 0.2600795198, 0.3119449793,                0.4203052841, 0.7394649088});        checkDensity(0.5, 0.5,                x, new double[]{                318.3100453389, 1.0610282383, 0.7957732234, 0.6946084565,                0.6497470636, 0.6366197724, 0.6497476051, 0.6946097796,                0.7957762075, 1.0610376697});        checkDensity(0.5, 1.0,                x, new double[]{                500.0000000000, 1.5811309244, 1.1180311937, 0.9128694077,                0.7905684268, 0.7071060741, 0.6454966865, 0.5976138778,                0.5590166450, 0.5270459839});        checkDensity(0.5, 2.0,                x, new double[]{                749.99925000000, 2.134537420613655, 1.34163575536, 0.95851150881,                0.71151039830, 0.53032849490, 0.38729704363, 0.26892534859,                0.16770415497, 0.07905610701});        checkDensity(0.5, 4.0,                x, new double[]{                1.093746719e+03, 2.52142232809988, 1.252190241e+00, 6.849343920e-01,                3.735417140e-01, 1.933481570e-01, 9.036885833e-02, 3.529621669e-02,                9.782644546e-03, 1.152878503e-03});        checkDensity(1.0, 0.1,                x, new double[]{                0.1000000900, 0.1099466942, 0.1222417336, 0.1378517623, 0.1583669403,                0.1866069342, 0.2281113974, 0.2955236034, 0.4256718768,                0.7943353837});        checkDensity(1.0, 0.5,                x, new double[]{                0.5000002500, 0.5270465695, 0.5590173438, 0.5976147315, 0.6454977623,                0.7071074883, 0.7905704033, 0.9128724506,                1.1180367838, 1.5811467358});        checkDensity(1, 1,                x, new double[]{                1, 1, 1,                1, 1, 1, 1,                1, 1, 1});        checkDensity(1, 2,                x, new double[]{                1.999998, 1.799998, 1.599998, 1.399998, 1.199998, 0.999998, 0.799998,                0.599998, 0.399998,                0.199998});        checkDensity(1, 4,                x, new double[]{                3.999988000012, 2.915990280011, 2.047992320010, 1.371994120008,                0.863995680007, 0.499997000006, 0.255998080005, 0.107998920004,                0.031999520002, 0.003999880001});        checkDensity(2.0, 0.1,                x, new double[]{                1.100000990e-07, 1.209425730e-02, 2.689331586e-02, 4.549123318e-02,                6.968162794e-02, 1.026340191e-01, 1.505537732e-01, 2.275534997e-01,                3.745917198e-01, 7.863929037e-01});        checkDensity(2.0, 0.5,                x, new double[]{                7.500003750e-07, 7.905777599e-02, 1.677060417e-01, 2.689275256e-01,                3.872996256e-01, 5.303316769e-01, 7.115145488e-01, 9.585174425e-01,                1.341645818e+00, 2.134537420613655});        checkDensity(2, 1,                x, new double[]{                0.000002, 0.200002, 0.400002, 0.600002, 0.800002, 1.000002, 1.200002,                1.400002, 1.600002,                1.800002});        checkDensity(2, 2,                x, new double[]{                5.9999940e-06, 5.4000480e-01, 9.6000360e-01, 1.2600024e+00,                1.4400012e+00, 1.5000000e+00, 1.4399988e+00, 1.2599976e+00,                9.5999640e-01, 5.3999520e-01});        checkDensity(2, 4,                x, new double[]{                0.00001999994, 1.45800971996, 2.04800255997, 2.05799803998,                1.72799567999, 1.24999500000, 0.76799552000, 0.37799676001,                0.12799824001, 0.01799948000});        checkDensity(4.0, 0.1,                x, new double[]{                1.193501074e-19, 1.312253162e-04, 1.167181580e-03, 4.442248535e-03,                1.209679109e-02, 2.783958903e-02, 5.880649983e-02, 1.209791638e-01,                2.601171405e-01, 6.911229392e-01});        checkDensity(4.0, 0.5,                x, new double[]{                1.093750547e-18, 1.152948959e-03, 9.782950259e-03, 3.529697305e-02,                9.037036449e-02, 1.933508639e-01, 3.735463833e-01, 6.849425461e-01,                1.252205894e+00, 2.52142232809988});        checkDensity(4, 1,                x, new double[]{                4.000000000e-18, 4.000120001e-03, 3.200048000e-02, 1.080010800e-01,                2.560019200e-01, 5.000030000e-01, 8.640043200e-01, 1.372005880e+00,                2.048007680e+00, 2.916009720e+00});        checkDensity(4, 2,                x, new double[]{                1.999998000e-17, 1.800052000e-02, 1.280017600e-01, 3.780032400e-01,                7.680044800e-01, 1.250005000e+00, 1.728004320e+00, 2.058001960e+00,                2.047997440e+00, 1.457990280e+00});        checkDensity(4, 4,                x, new double[]{                1.399995800e-16, 1.020627216e-01, 5.734464512e-01, 1.296547409e+00,                1.935364838e+00, 2.187500000e+00, 1.935355162e+00, 1.296532591e+00,                5.734335488e-01, 1.020572784e-01});    }    private void checkDensity(double alpha, double beta, double[] x, double[] expected) throws MathException {        BetaDistribution d = new BetaDistributionImpl(alpha, beta);        for (int i = 0; i < x.length; i++) {            assertEquals(String.format("density at x=%.1f for alpha=%.1f, beta=%.1f", x[i], alpha, beta), expected[i], d.density(x[i]), 1e-5);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for {@link ZipfDistribution}. * Extends IntegerDistributionAbstractTest.  See class javadoc for * IntegerDistributionAbstractTest for details. * * @version $Revision$ $Date$ */public class ZipfDistributionTest extends IntegerDistributionAbstractTest {    public ZipfDistributionTest(String name) {        super(name);    }    //-------------- Implementations for abstract methods -----------------------    /** Creates the default discrete distribution instance to use in tests. */    @Override    public IntegerDistribution makeDistribution() {        return new ZipfDistributionImpl(10, 1);    }    /** Creates the default probability density test input values */    @Override    public int[] makeDensityTestPoints() {        return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0d, 0d, 0.3414d, 0.1707d, 0.1138d, 0.0854d, 0.0683d,                0.0569d, 0.0488d, 0.0427d, 0.0379d, 0.0341d, 0d};    }    /** Creates the default cumulative probability density test input values */    @Override    public int[] makeCumulativeTestPoints() {        return makeDensityTestPoints();    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0d, 0.0000d, 0.3414d, 0.5121d, 0.6259d, 0.7113d,                0.7796d, 0.8365d, 0.8852d, 0.9279d, 0.9659d, 1d, 1d};        }    /** Creates the default inverse cumulative probability test input values */    @Override    public double[] makeInverseCumulativeTestPoints() {        return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.3414d, 0.3415d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d, 1};        }    /** Creates the default inverse cumulative probability density test expected values */    @Override    public int[] makeInverseCumulativeTestValues() {        return new int[] {0, 0, 0, 0, 0, 0, 1, 9, 9, 9, 8, 7, 10};    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.MathException;import org.apache.commons.math.util.FastMath;/** * Test cases for NormalDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */public class NormalDistributionTest extends ContinuousDistributionAbstractTest  {    /**     * Constructor for NormalDistributionTest.     * @param arg0     */    public NormalDistributionTest(String arg0) {        super(arg0);    }    //-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public NormalDistribution makeDistribution() {        return new NormalDistributionImpl(2.1, 1.4);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R        return new double[] {-2.226325228634938d, -1.156887023657177d, -0.643949578356075d, -0.2027950777320613d, 0.305827808237559d,                6.42632522863494d, 5.35688702365718d, 4.843949578356074d, 4.40279507773206d, 3.89417219176244d};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0.00240506434076, 0.0190372444310, 0.0417464784322, 0.0736683145538, 0.125355951380,                0.00240506434076, 0.0190372444310, 0.0417464784322, 0.0736683145538, 0.125355951380};    }    // --------------------- Override tolerance  --------------    protected double defaultTolerance = NormalDistributionImpl.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;    @Override    protected void setUp() throws Exception {        super.setUp();        setTolerance(defaultTolerance);    }    //---------------------------- Additional test cases -------------------------    private void verifyQuantiles() throws Exception {        NormalDistribution distribution = (NormalDistribution) getDistribution();        double mu = distribution.getMean();        double sigma = distribution.getStandardDeviation();        setCumulativeTestPoints( new double[] {mu - 2 *sigma, mu - sigma,                mu, mu + sigma, mu + 2 * sigma,  mu + 3 * sigma, mu + 4 * sigma,                mu + 5 * sigma});        // Quantiles computed using R (same as Mathematica)        setCumulativeTestValues(new double[] {0.02275013194817921, 0.158655253931457, 0.5, 0.841344746068543,                0.977249868051821, 0.99865010196837, 0.999968328758167,  0.999999713348428});        verifyCumulativeProbabilities();    }    public void testQuantiles() throws Exception {        setDensityTestValues(new double[] {0.0385649760808, 0.172836231799, 0.284958771715, 0.172836231799, 0.0385649760808,                0.00316560600853, 9.55930184035e-05, 1.06194251052e-06});        verifyQuantiles();        verifyDensities();        setDistribution(new NormalDistributionImpl(0, 1));        setDensityTestValues(new double[] {0.0539909665132, 0.241970724519, 0.398942280401, 0.241970724519, 0.0539909665132,                0.00443184841194, 0.000133830225765, 1.48671951473e-06});        verifyQuantiles();        verifyDensities();        setDistribution(new NormalDistributionImpl(0, 0.1));        setDensityTestValues(new double[] {0.539909665132, 2.41970724519, 3.98942280401, 2.41970724519,                0.539909665132, 0.0443184841194, 0.00133830225765, 1.48671951473e-05});        verifyQuantiles();        verifyDensities();    }    public void testInverseCumulativeProbabilityExtremes() throws Exception {        setInverseCumulativeTestPoints(new double[] {0, 1});        setInverseCumulativeTestValues(                new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});        verifyInverseCumulativeProbabilities();    }    public void testGetMean() {        NormalDistribution distribution = (NormalDistribution) getDistribution();        assertEquals(2.1, distribution.getMean(), 0);    }    public void testSetMean() throws Exception {        double mu = FastMath.random();        NormalDistribution distribution = (NormalDistribution) getDistribution();        distribution.setMean(mu);        verifyQuantiles();    }    public void testGetStandardDeviation() {        NormalDistribution distribution = (NormalDistribution) getDistribution();        assertEquals(1.4, distribution.getStandardDeviation(), 0);    }    public void testSetStandardDeviation() throws Exception {        double sigma = 0.1d + FastMath.random();        NormalDistribution distribution = (NormalDistribution) getDistribution();        distribution.setStandardDeviation(sigma);        assertEquals(sigma, distribution.getStandardDeviation(), 0);        verifyQuantiles();        try {            distribution.setStandardDeviation(0);            fail("Expecting IllegalArgumentException for sd = 0");        } catch (IllegalArgumentException ex) {            // Expected        }    }    public void testDensity() {        double [] x = new double[]{-2, -1, 0, 1, 2};        // R 2.5: print(dnorm(c(-2,-1,0,1,2)), digits=10)        checkDensity(0, 1, x, new double[]{0.05399096651, 0.24197072452, 0.39894228040, 0.24197072452, 0.05399096651});        // R 2.5: print(dnorm(c(-2,-1,0,1,2), mean=1.1), digits=10)        checkDensity(1.1, 1, x, new double[]{0.003266819056,0.043983595980,0.217852177033,0.396952547477,0.266085249899});    }    private void checkDensity(double mean, double sd, double[] x, double[] expected) {        NormalDistribution d = new NormalDistributionImpl(mean, sd);        for (int i = 0; i < x.length; i++) {            assertEquals(expected[i], d.density(x[i]), 1e-9);        }    }    /**     * Check to make sure top-coding of extreme values works correctly.     * Verifies fix for JIRA MATH-167     */    public void testExtremeValues() throws Exception {        NormalDistribution distribution = (NormalDistribution) getDistribution();        distribution.setMean(0);        distribution.setStandardDeviation(1);        for (int i = 0; i < 100; i+=5) { // make sure no convergence exception            double lowerTail = distribution.cumulativeProbability(-i);            double upperTail = distribution.cumulativeProbability(i);            if (i < 10) { // make sure not top-coded                assertTrue(lowerTail > 0.0d);                assertTrue(upperTail < 1.0d);            }            else { // make sure top coding not reversed                assertTrue(lowerTail < 0.00001);                assertTrue(upperTail > 0.99999);            }        }   }    public void testMath280() throws MathException {        NormalDistribution normal = new NormalDistributionImpl(0,1);        double result = normal.inverseCumulativeProbability(0.9986501019683698);        assertEquals(3.0, result, defaultTolerance);        result = normal.inverseCumulativeProbability(0.841344746068543);        assertEquals(1.0, result, defaultTolerance);        result = normal.inverseCumulativeProbability(0.9999683287581673);        assertEquals(4.0, result, defaultTolerance);        result = normal.inverseCumulativeProbability(0.9772498680518209);        assertEquals(2.0, result, defaultTolerance);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.NotStrictlyPositiveException;/** * Test cases for ExponentialDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */public class ExponentialDistributionTest extends ContinuousDistributionAbstractTest {    /**     * Constructor for ExponentialDistributionTest.     * @param name     */    public ExponentialDistributionTest(String name) {        super(name);    }    // --------------------- Override tolerance  --------------    @Override    protected void setUp() throws Exception {        super.setUp();        setTolerance(1E-9);    }    //-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public ExponentialDistribution makeDistribution() {        return new ExponentialDistributionImpl(5.0);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 2.9.2        return new double[] {0.00500250166792, 0.0502516792675, 0.126589039921, 0.256466471938,                0.526802578289, 34.5387763949, 23.0258509299, 18.4443972706, 14.9786613678, 11.5129254650};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999,                0.990, 0.975, 0.950, 0.900};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0.1998, 0.198, 0.195, 0.19, 0.18, 0.000200000000000,                0.00200000000002, 0.00499999999997, 0.00999999999994, 0.0199999999999};    }    //------------ Additional tests -------------------------------------------    public void testCumulativeProbabilityExtremes() throws Exception {        setCumulativeTestPoints(new double[] {-2, 0});        setCumulativeTestValues(new double[] {0, 0});        verifyCumulativeProbabilities();    }    public void testInverseCumulativeProbabilityExtremes() throws Exception {         setInverseCumulativeTestPoints(new double[] {0, 1});         setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});         verifyInverseCumulativeProbabilities();    }    public void testCumulativeProbability2() throws Exception {        double actual = getDistribution().cumulativeProbability(0.25, 0.75);        assertEquals(0.0905214, actual, 10e-4);    }    public void testDensity() {        ExponentialDistribution d1 = new ExponentialDistributionImpl(1);        assertEquals(0.0, d1.density(-1e-9));        assertEquals(1.0, d1.density(0.0));        assertEquals(0.0, d1.density(1000.0));        assertEquals(FastMath.exp(-1), d1.density(1.0));        assertEquals(FastMath.exp(-2), d1.density(2.0));        ExponentialDistribution d2 = new ExponentialDistributionImpl(3);        assertEquals(1/3.0, d2.density(0.0));        // computed using  print(dexp(1, rate=1/3), digits=10) in R 2.5        assertEquals(0.2388437702, d2.density(1.0), 1e-8);        // computed using  print(dexp(2, rate=1/3), digits=10) in R 2.5        assertEquals(0.1711390397, d2.density(2.0), 1e-8);    }    public void testMeanAccessors() {        ExponentialDistribution distribution = (ExponentialDistribution) getDistribution();        assertEquals(5d, distribution.getMean(), Double.MIN_VALUE);    }    public void testPreconditions() {        try {            ExponentialDistribution distribution = new ExponentialDistributionImpl(0);        } catch (NotStrictlyPositiveException e) {            // Expected.        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for BinomialDistribution. Extends IntegerDistributionAbstractTest. * See class javadoc for IntegerDistributionAbstractTest for details. * * @version $Revision$ $Date: 2009-09-05 12:36:48 -0500 (Sat, 05 Sep *          2009) $ */public class BinomialDistributionTest extends IntegerDistributionAbstractTest {    /**     * Constructor for BinomialDistributionTest.     *     * @param name     */    public BinomialDistributionTest(String name) {        super(name);    }    // -------------- Implementations for abstract methods    // -----------------------    /** Creates the default discrete distribution instance to use in tests. */    @Override    public IntegerDistribution makeDistribution() {        return new BinomialDistributionImpl(10, 0.70);    }    /** Creates the default probability density test input values */    @Override    public int[] makeDensityTestPoints() {        return new int[] { -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] { 0d, 0.0000059049d, 0.000137781d, 0.0014467d,                0.00900169d, 0.0367569d, 0.102919d, 0.200121d, 0.266828d,                0.233474d, 0.121061d, 0.0282475d, 0d };    }    /** Creates the default cumulative probability density test input values */    @Override    public int[] makeCumulativeTestPoints() {        return makeDensityTestPoints();    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] { 0d, 0.0000d, 0.0001d, 0.0016d, 0.0106d, 0.0473d,                0.1503d, 0.3504d, 0.6172d, 0.8507d, 0.9718d, 1d, 1d };    }    /** Creates the default inverse cumulative probability test input values */    @Override    public double[] makeInverseCumulativeTestPoints() {        return new double[] { 0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d,                0.999d, 0.990d, 0.975d, 0.950d, 0.900d, 1 };    }    /**     * Creates the default inverse cumulative probability density test expected     * values     */    @Override    public int[] makeInverseCumulativeTestValues() {        return new int[] { -1, 1, 2, 3, 4, 4, 9, 9, 9, 8, 8, Integer.MAX_VALUE };    }    // ----------------- Additional test cases ---------------------------------    /** Test degenerate case p = 0 */    public void testDegenerate0() throws Exception {        setDistribution(new BinomialDistributionImpl(5, 0.0d));        setCumulativeTestPoints(new int[] { -1, 0, 1, 5, 10 });        setCumulativeTestValues(new double[] { 0d, 1d, 1d, 1d, 1d });        setDensityTestPoints(new int[] { -1, 0, 1, 10, 11 });        setDensityTestValues(new double[] { 0d, 1d, 0d, 0d, 0d });        setInverseCumulativeTestPoints(new double[] { 0.1d, 0.5d });        setInverseCumulativeTestValues(new int[] { -1, -1 });        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }    /** Test degenerate case p = 1 */    public void testDegenerate1() throws Exception {        setDistribution(new BinomialDistributionImpl(5, 1.0d));        setCumulativeTestPoints(new int[] { -1, 0, 1, 2, 5, 10 });        setCumulativeTestValues(new double[] { 0d, 0d, 0d, 0d, 1d, 1d });        setDensityTestPoints(new int[] { -1, 0, 1, 2, 5, 10 });        setDensityTestValues(new double[] { 0d, 0d, 0d, 0d, 1d, 0d });        setInverseCumulativeTestPoints(new double[] { 0.1d, 0.5d });        setInverseCumulativeTestValues(new int[] { 4, 4 });        verifyDensities();        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.MathException;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.exception.NotStrictlyPositiveException;/** * <code>PoissonDistributionTest</code> * * @version $Revision$ $Date$ */public class PoissonDistributionTest extends IntegerDistributionAbstractTest {    /**     * Poisson parameter value for the test distribution.     */    private static final double DEFAULT_TEST_POISSON_PARAMETER = 4.0;    /**     * Constructor.     * @param name     */    public PoissonDistributionTest(String name) {        super(name);        setTolerance(1e-12);    }    /**     * Creates the default discrete distribution instance to use in tests.     */    @Override    public IntegerDistribution makeDistribution() {        return new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);    }    /**     * Creates the default probability density test input values.     */    @Override    public int[] makeDensityTestPoints() {        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};    }    /**     * Creates the default probability density test expected values.     * These and all other test values are generated by R, version 1.8.1     */    @Override    public double[] makeDensityTestValues() {        return new double[] { 0d, 0.0183156388887d,  0.073262555555d,                0.14652511111d, 0.195366814813d, 0.195366814813,                0.156293451851d, 0.00529247667642d, 8.27746364655e-09};    }    /**     * Creates the default cumulative probability density test input values.     */    @Override    public int[] makeCumulativeTestPoints() {        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20 };    }    /**     * Creates the default cumulative probability density test expected values.     */    @Override    public double[] makeCumulativeTestValues() {        return new double[] { 0d,  0.0183156388887d, 0.0915781944437d,                0.238103305554d, 0.433470120367d, 0.62883693518,                0.78513038703d,  0.99716023388d, 0.999999998077 };    }    /**     * Creates the default inverse cumulative probability test input values.     * Increased 3rd and 7th values slightly as computed cumulative     * probabilities for corresponding values exceeds the target value (still     * within tolerance).     */    @Override    public double[] makeInverseCumulativeTestPoints() {        return new double[] { 0d,  0.018315638889d, 0.0915781944437d,                0.238103305554d, 0.433470120367d, 0.62883693518,                0.78513038704d,  0.99716023388d, 0.999999998077 };    }    /**     * Creates the default inverse cumulative probability density test expected values.     */    @Override    public int[] makeInverseCumulativeTestValues() {        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};    }    /**     * Test the normal approximation of the Poisson distribution by     * calculating P(90 &le; X &le; 110) for X = Po(100) and     * P(9900 &le; X &le; 10200) for X  = Po(10000)     */    public void testNormalApproximateProbability() throws Exception {        PoissonDistribution dist = new PoissonDistributionImpl(100);        double result = dist.normalApproximateProbability(110)                - dist.normalApproximateProbability(89);        assertEquals(0.706281887248, result, 1E-10);        dist = new PoissonDistributionImpl(10000);        result = dist.normalApproximateProbability(10200)        - dist.normalApproximateProbability(9899);        assertEquals(0.820070051552, result, 1E-10);    }    /**     * Test the degenerate cases of a 0.0 and 1.0 inverse cumulative probability.     * @throws Exception     */    public void testDegenerateInverseCumulativeProbability() throws Exception {        PoissonDistribution dist = new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);        assertEquals(Integer.MAX_VALUE, dist.inverseCumulativeProbability(1.0d));        assertEquals(-1, dist.inverseCumulativeProbability(0d));    }    public void testMean() {        PoissonDistribution dist;        try {            dist = new PoissonDistributionImpl(-1);            fail("negative mean: NotStrictlyPositiveException expected");        } catch(NotStrictlyPositiveException ex) {            // Expected.        }        dist = new PoissonDistributionImpl(10.0);        assertEquals(10.0, dist.getMean(), 0.0);    }    public void testLargeMeanCumulativeProbability() {        double mean = 1.0;        while (mean <= 10000000.0) {            PoissonDistribution dist = new PoissonDistributionImpl(mean);            double x = mean * 2.0;            double dx = x / 10.0;            double p = Double.NaN;            double sigma = FastMath.sqrt(mean);            while (x >= 0) {                try {                    p = dist.cumulativeProbability(x);                    assertFalse("NaN cumulative probability returned for mean = " +                            mean + " x = " + x,Double.isNaN(p));                    if (x > mean - 2 * sigma) {                        assertTrue("Zero cum probaility returned for mean = " +                                mean + " x = " + x, p > 0);                    }                } catch (MathException ex) {                    fail("mean of " + mean + " and x of " + x + " caused " + ex.getMessage());                }                x -= dx;            }            mean *= 10.0;        }    }    /**     * JIRA: MATH-282     */    public void testCumulativeProbabilitySpecial() throws Exception {        PoissonDistribution dist;        dist = new PoissonDistributionImpl(9120);        checkProbability(dist, 9075);        checkProbability(dist, 9102);        dist = new PoissonDistributionImpl(5058);        checkProbability(dist, 5044);        dist = new PoissonDistributionImpl(6986);        checkProbability(dist, 6950);    }    private void checkProbability(PoissonDistribution dist, double x) throws Exception {        double p = dist.cumulativeProbability(x);        assertFalse("NaN cumulative probability returned for mean = " +                dist.getMean() + " x = " + x, Double.isNaN(p));        assertTrue("Zero cum probability returned for mean = " +                dist.getMean() + " x = " + x, p > 0);    }    public void testLargeMeanInverseCumulativeProbability() throws Exception {        double mean = 1.0;        while (mean <= 100000.0) { // Extended test value: 1E7.  Reduced to limit run time.            PoissonDistribution dist = new PoissonDistributionImpl(mean);            double p = 0.1;            double dp = p;            while (p < .99) {                double ret = Double.NaN;                try {                    ret = dist.inverseCumulativeProbability(p);                    // Verify that returned value satisties definition                    assertTrue(p >= dist.cumulativeProbability(ret));                    assertTrue(p < dist.cumulativeProbability(ret + 1));                } catch (MathException ex) {                    fail("mean of " + mean + " and p of " + p + " caused " + ex.getMessage());                }                p += dp;            }            mean *= 10.0;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;/** * Test cases for ChiSquareDistribution. * Extends ContinuousDistributionAbstractTest.  See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */public class ChiSquareDistributionTest extends ContinuousDistributionAbstractTest {    /**     * Constructor for ChiSquareDistributionTest.     * @param name     */    public ChiSquareDistributionTest(String name) {        super(name);    }    //-------------- Implementations for abstract methods -----------------------    /** Creates the default continuous distribution instance to use in tests. */    @Override    public ChiSquaredDistribution makeDistribution() {        return new ChiSquaredDistributionImpl(5.0);    }    /** Creates the default cumulative probability distribution test input values */    @Override    public double[] makeCumulativeTestPoints() {        // quantiles computed using R version 2.9.2        return new double[] {0.210212602629, 0.554298076728, 0.831211613487, 1.14547622606, 1.61030798696,                20.5150056524, 15.0862724694, 12.8325019940, 11.0704976935, 9.23635689978};    }    /** Creates the default cumulative probability density test expected values */    @Override    public double[] makeCumulativeTestValues() {        return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900};    }    /** Creates the default inverse cumulative probability test input values */    @Override    public double[] makeInverseCumulativeTestPoints() {        return new double[] {0, 0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,                0.990d, 0.975d, 0.950d, 0.900d, 1};    }    /** Creates the default inverse cumulative probability density test expected values */    @Override    public double[] makeInverseCumulativeTestValues() {        return new double[] {0, 0.210212602629, 0.554298076728, 0.831211613487, 1.14547622606, 1.61030798696,                20.5150056524, 15.0862724694, 12.8325019940, 11.0704976935, 9.23635689978,                Double.POSITIVE_INFINITY};    }    /** Creates the default probability density test expected values */    @Override    public double[] makeDensityTestValues() {        return new double[] {0.0115379817652, 0.0415948507811, 0.0665060119842, 0.0919455953114, 0.121472591024,                0.000433630076361, 0.00412780610309, 0.00999340341045, 0.0193246438937, 0.0368460089216};    } // --------------------- Override tolerance  --------------    @Override    protected void setUp() throws Exception {        super.setUp();        setTolerance(1e-9);    } //---------------------------- Additional test cases -------------------------    public void testSmallDf() throws Exception {        setDistribution(new ChiSquaredDistributionImpl(0.1d));        setTolerance(1E-4);        // quantiles computed using R version 1.8.1 (linux version)        setCumulativeTestPoints(new double[] {1.168926E-60, 1.168926E-40, 1.063132E-32,                1.144775E-26, 1.168926E-20, 5.472917, 2.175255, 1.13438,                0.5318646, 0.1526342});        setInverseCumulativeTestValues(getCumulativeTestPoints());        setInverseCumulativeTestPoints(getCumulativeTestValues());        verifyCumulativeProbabilities();        verifyInverseCumulativeProbabilities();    }    public void testDfAccessors() {        ChiSquaredDistribution distribution = (ChiSquaredDistribution) getDistribution();        assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);    }    public void testDensity() {        double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};        //R 2.5: print(dchisq(x, df=1), digits=10)        checkDensity(1, x, new double[]{0.00000000000, 398.94208093034, 0.43939128947, 0.24197072452, 0.10377687436, 0.01464498256});        //R 2.5: print(dchisq(x, df=0.1), digits=10)        checkDensity(0.1, x, new double[]{0.000000000e+00, 2.486453997e+04, 7.464238732e-02, 3.009077718e-02, 9.447299159e-03, 8.827199396e-04});        //R 2.5: print(dchisq(x, df=2), digits=10)        checkDensity(2, x, new double[]{0.00000000000, 0.49999975000, 0.38940039154, 0.30326532986, 0.18393972059, 0.04104249931});        //R 2.5: print(dchisq(x, df=10), digits=10)        checkDensity(10, x, new double[]{0.000000000e+00, 1.302082682e-27, 6.337896998e-05, 7.897534632e-04, 7.664155024e-03, 6.680094289e-02});    }    private void checkDensity(double df, double[] x, double[] expected) {        ChiSquaredDistribution d = new ChiSquaredDistributionImpl(df);        for (int i = 0; i < x.length; i++) {            assertEquals(expected[i], d.density(x[i]), 1e-5);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import junit.framework.TestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;/** * Abstract base class for {@link ContinuousDistribution} tests. * <p> * To create a concrete test class for a continuous distribution * implementation, first implement makeDistribution() to return a distribution * instance to use in tests. Then implement each of the test data generation * methods below.  In each case, the test points and test values arrays * returned represent parallel arrays of inputs and expected values for the * distribution returned by makeDistribution().  Default implementations * are provided for the makeInverseXxx methods that just invert the mapping * defined by the arrays returned by the makeCumulativeXxx methods. * <p> * makeCumulativeTestPoints() -- arguments used to test cumulative probabilities * makeCumulativeTestValues() -- expected cumulative probabilites * makeDensityTestValues() -- expected density values at cumulativeTestPoints * makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf * makeInverseCumulativeTestValues() -- expected inverse cdf values * <p> * To implement additional test cases with different distribution instances and * test data, use the setXxx methods for the instance data in test cases and * call the verifyXxx methods to verify results. * <p> * Error tolerance can be overriden by implementing getTolerance(). * <p> * Test data should be validated against reference tables or other packages * where possible, and the source of the reference data and/or validation * should be documented in the test cases.  A framework for validating * distribution data against R is included in the /src/test/R source tree. * <p> * See {@link NormalDistributionTest} and {@link ChiSquareDistributionTest} * for examples. * * @version $Revision$ $Date$ */public abstract class ContinuousDistributionAbstractTest extends TestCase {//-------------------- Private test instance data -------------------------    /**  Distribution instance used to perform tests */    private ContinuousDistribution distribution;    /** Tolerance used in comparing expected and returned values */    private double tolerance = 1E-4;    /** Arguments used to test cumulative probability density calculations */    private double[] cumulativeTestPoints;    /** Values used to test cumulative probability density calculations */    private double[] cumulativeTestValues;    /** Arguments used to test inverse cumulative probability density calculations */    private double[] inverseCumulativeTestPoints;    /** Values used to test inverse cumulative probability density calculations */    private double[] inverseCumulativeTestValues;    /** Values used to test density calculations */    private double[] densityTestValues;    //-------------------------------------------------------------------------    /**     * Constructor for ContinuousDistributionAbstractTest.     * @param name     */    public ContinuousDistributionAbstractTest(String name) {        super(name);    }    //-------------------- Abstract methods -----------------------------------    /** Creates the default continuous distribution instance to use in tests. */    public abstract ContinuousDistribution makeDistribution();    /** Creates the default cumulative probability test input values */    public abstract double[] makeCumulativeTestPoints();    /** Creates the default cumulative probability test expected values */    public abstract double[] makeCumulativeTestValues();    /** Creates the default density test expected values */    public abstract double[] makeDensityTestValues();    //---- Default implementations of inverse test data generation methods ----    /** Creates the default inverse cumulative probability test input values */    public double[] makeInverseCumulativeTestPoints() {        return makeCumulativeTestValues();    }    /** Creates the default inverse cumulative probability density test expected values */    public double[] makeInverseCumulativeTestValues() {        return makeCumulativeTestPoints();    }    //-------------------- Setup / tear down ----------------------------------    /**     * Setup sets all test instance data to default values     */    @Override    protected void setUp() throws Exception {        super.setUp();        distribution = makeDistribution();        cumulativeTestPoints = makeCumulativeTestPoints();        cumulativeTestValues = makeCumulativeTestValues();        inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();        inverseCumulativeTestValues = makeInverseCumulativeTestValues();        densityTestValues = makeDensityTestValues();    }    /**     * Cleans up test instance data     */    @Override    protected void tearDown() throws Exception {        super.tearDown();        distribution = null;        cumulativeTestPoints = null;        cumulativeTestValues = null;        inverseCumulativeTestPoints = null;        inverseCumulativeTestValues = null;        densityTestValues = null;    }    //-------------------- Verification methods -------------------------------    /**     * Verifies that cumulative probability density calculations match expected values     * using current test instance data     */    protected void verifyCumulativeProbabilities() throws Exception {        for (int i = 0; i < cumulativeTestPoints.length; i++) {            TestUtils.assertEquals("Incorrect cumulative probability value returned for "                + cumulativeTestPoints[i], cumulativeTestValues[i],                distribution.cumulativeProbability(cumulativeTestPoints[i]),                getTolerance());        }    }    /**     * Verifies that inverse cumulative probability density calculations match expected values     * using current test instance data     */    protected void verifyInverseCumulativeProbabilities() throws Exception {        for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {            TestUtils.assertEquals("Incorrect inverse cumulative probability value returned for "                + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i],                 distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]),                 getTolerance());        }    }    /**     * Verifies that density calculations match expected values     */    protected void verifyDensities() throws Exception {        for (int i = 0; i < cumulativeTestPoints.length; i++) {            TestUtils.assertEquals("Incorrect probability density value returned for "                + cumulativeTestPoints[i], densityTestValues[i],                 //TODO: remove cast when density(double) is added to ContinuousDistribution                 ((AbstractContinuousDistribution) distribution).density(cumulativeTestPoints[i]),                 getTolerance());        }    }    //------------------------ Default test cases -----------------------------    /**     * Verifies that cumulative probability density calculations match expected values     * using default test instance data     */    public void testCumulativeProbabilities() throws Exception {        verifyCumulativeProbabilities();    }    /**     * Verifies that inverse cumulative probability density calculations match expected values     * using default test instance data     */    public void testInverseCumulativeProbabilities() throws Exception {        verifyInverseCumulativeProbabilities();    }    /**     * Verifies that density calculations return expected values     * for default test instance data     */    public void testDensities() throws Exception {        verifyDensities();    }    /**     * Verifies that probability computations are consistent     */    public void testConsistency() throws Exception {        for (int i=1; i < cumulativeTestPoints.length; i++) {            // check that cdf(x, x) = 0            TestUtils.assertEquals(0d,               distribution.cumulativeProbability                 (cumulativeTestPoints[i], cumulativeTestPoints[i]), tolerance);            // check that P(a < X < b) = P(X < b) - P(X < a)            double upper = FastMath.max(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);            double lower = FastMath.min(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);            double diff = distribution.cumulativeProbability(upper) -                distribution.cumulativeProbability(lower);            double direct = distribution.cumulativeProbability(lower, upper);            TestUtils.assertEquals("Inconsistent cumulative probabilities for ("                    + lower + "," + upper + ")", diff, direct, tolerance);        }    }    /**     * Verifies that illegal arguments are correctly handled     */    public void testIllegalArguments() throws Exception {        try {            distribution.cumulativeProbability(1, 0);            fail("Expecting IllegalArgumentException for bad cumulativeProbability interval");        } catch (IllegalArgumentException ex) {            // expected        }        try {            distribution.inverseCumulativeProbability(-1);            fail("Expecting IllegalArgumentException for p = -1");        } catch (IllegalArgumentException ex) {            // expected        }        try {            distribution.inverseCumulativeProbability(2);            fail("Expecting IllegalArgumentException for p = 2");        } catch (IllegalArgumentException ex) {            // expected        }    }        /**     * Test sampling     */    public void testSampling() throws Exception {        AbstractContinuousDistribution dist = (AbstractContinuousDistribution) makeDistribution();        final int sampleSize = 1000;        double[] sample = dist.sample(sampleSize);        double[] quartiles = TestUtils.getDistributionQuartiles(dist);        double[] expected = {250, 250, 250, 250};        long[] counts = new long[4];        dist.reseedRandomGenerator(1000);  // Use fixed seed        for (int i = 0; i < sampleSize; i++) {            TestUtils.updateCounts(sample[i], counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);    }    //------------------ Getters / Setters for test instance data -----------    /**     * @return Returns the cumulativeTestPoints.     */    protected double[] getCumulativeTestPoints() {        return cumulativeTestPoints;    }    /**     * @param cumulativeTestPoints The cumulativeTestPoints to set.     */    protected void setCumulativeTestPoints(double[] cumulativeTestPoints) {        this.cumulativeTestPoints = cumulativeTestPoints;    }    /**     * @return Returns the cumulativeTestValues.     */    protected double[] getCumulativeTestValues() {        return cumulativeTestValues;    }    /**     * @param cumulativeTestValues The cumulativeTestValues to set.     */    protected void setCumulativeTestValues(double[] cumulativeTestValues) {        this.cumulativeTestValues = cumulativeTestValues;    }    protected double[] getDensityTestValues() {        return densityTestValues;    }    protected void setDensityTestValues(double[] densityTestValues) {        this.densityTestValues = densityTestValues;    }    /**     * @return Returns the distribution.     */    protected ContinuousDistribution getDistribution() {        return distribution;    }    /**     * @param distribution The distribution to set.     */    protected void setDistribution(AbstractContinuousDistribution distribution) {        this.distribution = distribution;    }    /**     * @return Returns the inverseCumulativeTestPoints.     */    protected double[] getInverseCumulativeTestPoints() {        return inverseCumulativeTestPoints;    }    /**     * @param inverseCumulativeTestPoints The inverseCumulativeTestPoints to set.     */    protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) {        this.inverseCumulativeTestPoints = inverseCumulativeTestPoints;    }    /**     * @return Returns the inverseCumulativeTestValues.     */    protected double[] getInverseCumulativeTestValues() {        return inverseCumulativeTestValues;    }    /**     * @param inverseCumulativeTestValues The inverseCumulativeTestValues to set.     */    protected void setInverseCumulativeTestValues(double[] inverseCumulativeTestValues) {        this.inverseCumulativeTestValues = inverseCumulativeTestValues;    }    /**     * @return Returns the tolerance.     */    protected double getTolerance() {        return tolerance;    }    /**     * @param tolerance The tolerance to set.     */    protected void setTolerance(double tolerance) {        this.tolerance = tolerance;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.events;import junit.framework.Assert;import org.apache.commons.math.ConvergenceException;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;import org.apache.commons.math.ode.sampling.DummyStepInterpolator;import org.junit.Test;public class EventStateTest {    // JIRA: MATH-322    @Test    public void closeEvents()        throws EventException, ConvergenceException, DerivativeException {        final double r1  = 90.0;        final double r2  = 135.0;        final double gap = r2 - r1;        EventHandler closeEventsGenerator = new EventHandler() {            public void resetState(double t, double[] y) {            }            public double g(double t, double[] y) {                return (t - r1) * (r2 - t);            }            public int eventOccurred(double t, double[] y, boolean increasing) {                return CONTINUE;            }        };        final double tolerance = 0.1;        EventState es = new EventState(closeEventsGenerator, 1.5 * gap, tolerance, 10);        double t0 = r1 - 0.5 * gap;        es.reinitializeBegin(t0, new double[0]);        AbstractStepInterpolator interpolator =            new DummyStepInterpolator(new double[0], new double[0], true);        interpolator.storeTime(t0);        interpolator.shift();        interpolator.storeTime(0.5 * (r1 + r2));        Assert.assertTrue(es.evaluateStep(interpolator));        Assert.assertEquals(r1, es.getEventTime(), tolerance);        es.stepAccepted(es.getEventTime(), new double[0]);        interpolator.shift();        interpolator.storeTime(r2 + 0.4 * gap);        Assert.assertTrue(es.evaluateStep(interpolator));        Assert.assertEquals(r2, es.getEventTime(), tolerance);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.jacobians;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;import org.apache.commons.math.stat.descriptive.SummaryStatistics;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class FirstOrderIntegratorWithJacobiansTest {    @Test    public void testLowAccuracyExternalDifferentiation()        throws IntegratorException, DerivativeException {        // this test does not really test FirstOrderIntegratorWithJacobians,        // it only shows that WITHOUT this class, attempting to recover        // the jacobians from external differentiation on simple integration        // results with low accuracy gives very poor results. In fact,        // the curves dy/dp = g(b) when b varies from 2.88 to 3.08 are        // essentially noise.        // This test is taken from Hairer, Norsett and Wanner book        // Solving Ordinary Differential Equations I (Nonstiff problems),        // the curves dy/dp = g(b) are in figure 6.5        FirstOrderIntegrator integ =            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });        double hP = 1.0e-12;        SummaryStatistics residualsP0 = new SummaryStatistics();        SummaryStatistics residualsP1 = new SummaryStatistics();        for (double b = 2.88; b < 3.08; b += 0.001) {            Brusselator brusselator = new Brusselator(b);            double[] y = { 1.3, b };            integ.integrate(brusselator, 0, y, 20.0, y);            double[] yP = { 1.3, b + hP };            brusselator.setParameter(0, b + hP);            integ.integrate(brusselator, 0, yP, 20.0, yP);            residualsP0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0());            residualsP1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1());        }        Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) > 600);        Assert.assertTrue(residualsP0.getStandardDeviation() > 30);        Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) > 800);        Assert.assertTrue(residualsP1.getStandardDeviation() > 50);    }    @Test    public void testHighAccuracyExternalDifferentiation()        throws IntegratorException, DerivativeException {        FirstOrderIntegrator integ =            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });        double hP = 1.0e-12;        SummaryStatistics residualsP0 = new SummaryStatistics();        SummaryStatistics residualsP1 = new SummaryStatistics();        for (double b = 2.88; b < 3.08; b += 0.001) {            Brusselator brusselator = new Brusselator(b);            double[] y = { 1.3, b };            integ.integrate(brusselator, 0, y, 20.0, y);            double[] yP = { 1.3, b + hP };            brusselator.setParameter(0, b + hP);            integ.integrate(brusselator, 0, yP, 20.0, yP);            residualsP0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0());            residualsP1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1());        }        Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) > 0.02);        Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.03);        Assert.assertTrue(residualsP0.getStandardDeviation() > 0.003);        Assert.assertTrue(residualsP0.getStandardDeviation() < 0.004);        Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) > 0.04);        Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05);        Assert.assertTrue(residualsP1.getStandardDeviation() > 0.007);        Assert.assertTrue(residualsP1.getStandardDeviation() < 0.008);    }    @Test    public void testInternalDifferentiation()        throws IntegratorException, DerivativeException {        FirstOrderIntegrator integ =            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });        double hP = 1.0e-12;        SummaryStatistics residualsP0 = new SummaryStatistics();        SummaryStatistics residualsP1 = new SummaryStatistics();        for (double b = 2.88; b < 3.08; b += 0.001) {            Brusselator brusselator = new Brusselator(b);            brusselator.setParameter(0, b);            double[] z = { 1.3, b };            double[][] dZdZ0 = new double[2][2];            double[][] dZdP  = new double[2][1];            double hY = 1.0e-12;            FirstOrderIntegratorWithJacobians extInt =                new FirstOrderIntegratorWithJacobians(integ, brusselator, new double[] { b },                                                      new double[] { hY, hY }, new double[] { hP });            extInt.setMaxEvaluations(5000);            extInt.integrate(0, z, new double[][] { { 0.0 }, { 1.0 } }, 20.0, z, dZdZ0, dZdP);            Assert.assertEquals(5000, extInt.getMaxEvaluations());            Assert.assertTrue(extInt.getEvaluations() > 1500);            Assert.assertTrue(extInt.getEvaluations() < 2100);            Assert.assertEquals(4 * integ.getEvaluations(), extInt.getEvaluations());            residualsP0.addValue(dZdP[0][0] - brusselator.dYdP0());            residualsP1.addValue(dZdP[1][0] - brusselator.dYdP1());        }        Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.02);        Assert.assertTrue(residualsP0.getStandardDeviation() < 0.003);        Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05);        Assert.assertTrue(residualsP1.getStandardDeviation() < 0.01);    }    @Test    public void testAnalyticalDifferentiation()        throws IntegratorException, DerivativeException {        FirstOrderIntegrator integ =            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });        SummaryStatistics residualsP0 = new SummaryStatistics();        SummaryStatistics residualsP1 = new SummaryStatistics();        for (double b = 2.88; b < 3.08; b += 0.001) {            Brusselator brusselator = new Brusselator(b);            brusselator.setParameter(0, b);            double[] z = { 1.3, b };            double[][] dZdZ0 = new double[2][2];            double[][] dZdP  = new double[2][1];            FirstOrderIntegratorWithJacobians extInt =                new FirstOrderIntegratorWithJacobians(integ, brusselator);            extInt.setMaxEvaluations(5000);            extInt.integrate(0, z, new double[][] { { 0.0 }, { 1.0 } }, 20.0, z, dZdZ0, dZdP);            Assert.assertEquals(5000, extInt.getMaxEvaluations());            Assert.assertTrue(extInt.getEvaluations() > 350);            Assert.assertTrue(extInt.getEvaluations() < 510);            Assert.assertEquals(integ.getEvaluations(), extInt.getEvaluations());            residualsP0.addValue(dZdP[0][0] - brusselator.dYdP0());            residualsP1.addValue(dZdP[1][0] - brusselator.dYdP1());        }        Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.014);        Assert.assertTrue(residualsP0.getStandardDeviation() < 0.003);        Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05);        Assert.assertTrue(residualsP1.getStandardDeviation() < 0.01);    }    @Test    public void testFinalResult() throws IntegratorException, DerivativeException {        FirstOrderIntegrator integ =            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });        double[] y = new double[] { 0.0, 1.0 };        Circle circle = new Circle(y, 1.0, 1.0, 0.1);        double[][] dydy0 = new double[2][2];        double[][] dydp  = new double[2][3];        double t = 18 * FastMath.PI;        FirstOrderIntegratorWithJacobians extInt =            new FirstOrderIntegratorWithJacobians(integ, circle);        extInt.integrate(0, y, circle.exactDyDp(0), t, y, dydy0, dydp);        for (int i = 0; i < y.length; ++i) {            Assert.assertEquals(circle.exactY(t)[i], y[i], 1.0e-9);        }        for (int i = 0; i < dydy0.length; ++i) {            for (int j = 0; j < dydy0[i].length; ++j) {                Assert.assertEquals(circle.exactDyDy0(t)[i][j], dydy0[i][j], 1.0e-9);            }        }        for (int i = 0; i < dydp.length; ++i) {            for (int j = 0; j < dydp[i].length; ++j) {                Assert.assertEquals(circle.exactDyDp(t)[i][j], dydp[i][j], 1.0e-7);            }        }    }    @Test    public void testStepHandlerResult() throws IntegratorException, DerivativeException {        FirstOrderIntegrator integ =            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });        double[] y = new double[] { 0.0, 1.0 };        final Circle circle = new Circle(y, 1.0, 1.0, 0.1);        double[][] dydy0 = new double[2][2];        double[][] dydp  = new double[2][3];        double t = 18 * FastMath.PI;        final FirstOrderIntegratorWithJacobians extInt =            new FirstOrderIntegratorWithJacobians(integ, circle);        extInt.addStepHandler(new StepHandlerWithJacobians() {            public void reset() {            }            public boolean requiresDenseOutput() {                return false;            }            public void handleStep(StepInterpolatorWithJacobians interpolator, boolean isLast)                throws DerivativeException {                double     t     = interpolator.getCurrentTime();                double[]   y     = interpolator.getInterpolatedY();                double[][] dydy0 = interpolator.getInterpolatedDyDy0();                double[][] dydp  = interpolator.getInterpolatedDyDp();                Assert.assertEquals(interpolator.getPreviousTime(), extInt.getCurrentStepStart(), 1.0e-10);                Assert.assertTrue(extInt.getCurrentSignedStepsize() < 0.5);                for (int i = 0; i < y.length; ++i) {                    Assert.assertEquals(circle.exactY(t)[i], y[i], 1.0e-9);                }                for (int i = 0; i < dydy0.length; ++i) {                    for (int j = 0; j < dydy0[i].length; ++j) {                        Assert.assertEquals(circle.exactDyDy0(t)[i][j], dydy0[i][j], 1.0e-9);                    }                }                for (int i = 0; i < dydp.length; ++i) {                    for (int j = 0; j < dydp[i].length; ++j) {                        Assert.assertEquals(circle.exactDyDp(t)[i][j], dydp[i][j], 3.0e-8);                    }                }                double[]   yDot     = interpolator.getInterpolatedYDot();                double[][] dydy0Dot = interpolator.getInterpolatedDyDy0Dot();                double[][] dydpDot  = interpolator.getInterpolatedDyDpDot();                for (int i = 0; i < yDot.length; ++i) {                    Assert.assertEquals(circle.exactYDot(t)[i], yDot[i], 1.0e-10);                }                for (int i = 0; i < dydy0Dot.length; ++i) {                    for (int j = 0; j < dydy0Dot[i].length; ++j) {                        Assert.assertEquals(circle.exactDyDy0Dot(t)[i][j], dydy0Dot[i][j], 1.0e-10);                    }                }                for (int i = 0; i < dydpDot.length; ++i) {                    for (int j = 0; j < dydpDot[i].length; ++j) {                        Assert.assertEquals(circle.exactDyDpDot(t)[i][j], dydpDot[i][j], 3.0e-9);                    }                }            }        });        extInt.integrate(0, y, circle.exactDyDp(0), t, y, dydy0, dydp);    }    @Test    public void testEventHandler() throws IntegratorException, DerivativeException {        FirstOrderIntegrator integ =            new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });        double[] y = new double[] { 0.0, 1.0 };        final Circle circle = new Circle(y, 1.0, 1.0, 0.1);        double[][] dydy0 = new double[2][2];        double[][] dydp  = new double[2][3];        double t = 18 * FastMath.PI;        final FirstOrderIntegratorWithJacobians extInt =            new FirstOrderIntegratorWithJacobians(integ, circle);        extInt.addEventHandler(new EventHandlerWithJacobians() {            public int eventOccurred(double t, double[] y, double[][] dydy0,                                     double[][] dydp, boolean increasing) {                Assert.assertEquals(0.1, y[1], 1.0e-11);                Assert.assertTrue(!increasing);                return STOP;            }            public double g(double t, double[] y, double[][] dydy0,                            double[][] dydp) {                return y[1] - 0.1;            }            public void resetState(double t, double[] y, double[][] dydy0,                                   double[][] dydp) {            }        }, 10.0, 1.0e-10, 1000);        double stopTime = extInt.integrate(0, y, circle.exactDyDp(0), t, y, dydy0, dydp);        Assert.assertTrue(stopTime < 5.0 * FastMath.PI);    }    private static class Brusselator implements ParameterizedODE, ODEWithJacobians {        private double b;        public Brusselator(double b) {            this.b = b;        }        public int getDimension() {            return 2;        }        public void setParameter(int i, double p) {            b = p;        }        public int getParametersDimension() {            return 1;        }        public void computeDerivatives(double t, double[] y, double[] yDot) {            double prod = y[0] * y[0] * y[1];            yDot[0] = 1 + prod - (b + 1) * y[0];            yDot[1] = b * y[0] - prod;        }        public void computeJacobians(double t, double[] y, double[] yDot, double[][] dFdY, double[][] dFdP) {            double p = 2 * y[0] * y[1];            double y02 = y[0] * y[0];            dFdY[0][0] = p - (1 + b);            dFdY[0][1] = y02;            dFdY[1][0] = b - p;            dFdY[1][1] = -y02;            dFdP[0][0] = -y[0];            dFdP[1][0] = y[0];        }        public double dYdP0() {            return -1088.232716447743 + (1050.775747149553 + (-339.012934631828 + 36.52917025056327 * b) * b) * b;        }        public double dYdP1() {            return 1502.824469929139 + (-1438.6974831849952 + (460.959476642384 - 49.43847385647082 * b) * b) * b;        }    }    /** ODE representing a point moving on a circle with provided center and angular rate. */    private static class Circle implements ODEWithJacobians {        private final double[] y0;        private double cx;        private double cy;        private double omega;        public Circle(double[] y0, double cx, double cy, double omega) {            this.y0    = y0.clone();            this.cx    = cx;            this.cy    = cy;            this.omega = omega;        }        public int getDimension() {            return 2;        }        public int getParametersDimension() {            return 3;        }        public void computeDerivatives(double t, double[] y, double[] yDot) {            yDot[0] = omega * (cy - y[1]);            yDot[1] = omega * (y[0] - cx);        }        public void computeJacobians(double t, double[] y, double[] yDot, double[][] dFdY, double[][] dFdP) {            dFdY[0][0] = 0;            dFdY[0][1] = -omega;            dFdY[1][0] = omega;            dFdY[1][1] = 0;            dFdP[0][0] = 0;            dFdP[0][1] = omega;            dFdP[0][2] = cy - y[1];            dFdP[1][0] = -omega;            dFdP[1][1] = 0;            dFdP[1][2] = y[0] - cx;        }        public double[] exactY(double t) {            double cos = FastMath.cos(omega * t);            double sin = FastMath.sin(omega * t);            double dx0 = y0[0] - cx;            double dy0 = y0[1] - cy;            return new double[] {                cx + cos * dx0 - sin * dy0,                cy + sin * dx0 + cos * dy0            };        }        public double[][] exactDyDy0(double t) {            double cos = FastMath.cos(omega * t);            double sin = FastMath.sin(omega * t);            return new double[][] {                { cos, -sin },                { sin,  cos }            };        }        public double[][] exactDyDp(double t) {            double cos = FastMath.cos(omega * t);            double sin = FastMath.sin(omega * t);            double dx0 = y0[0] - cx;            double dy0 = y0[1] - cy;            return new double[][] {                { 1 - cos, sin,    -t * (sin * dx0 + cos * dy0) },                { -sin,    1 - cos, t * (cos * dx0 - sin * dy0) }            };        }        public double[] exactYDot(double t) {            double oCos = omega * FastMath.cos(omega * t);            double oSin = omega * FastMath.sin(omega * t);            double dx0 = y0[0] - cx;            double dy0 = y0[1] - cy;            return new double[] {                -oSin * dx0 - oCos * dy0,                 oCos * dx0 - oSin * dy0            };        }        public double[][] exactDyDy0Dot(double t) {            double oCos = omega * FastMath.cos(omega * t);            double oSin = omega * FastMath.sin(omega * t);            return new double[][] {                { -oSin, -oCos },                {  oCos, -oSin }            };        }        public double[][] exactDyDpDot(double t) {            double cos  = FastMath.cos(omega * t);            double sin  = FastMath.sin(omega * t);            double oCos = omega * cos;            double oSin = omega * sin;            double dx0  = y0[0] - cx;            double dy0  = y0[1] - cy;            return new double[][] {                {  oSin, oCos, -sin * dx0 - cos * dy0 - t * ( oCos * dx0 - oSin * dy0) },                { -oCos, oSin,  cos * dx0 - sin * dy0 + t * (-oSin * dx0 - oCos * dy0) }            };        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import junit.framework.TestCase;import org.apache.commons.math.ConvergenceException;import org.apache.commons.math.exception.util.LocalizedFormats;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.TestProblem4;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventException;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;public class HighamHall54IntegratorTest  extends TestCase {  public HighamHall54IntegratorTest(String name) {    super(name);  }  public void testWrongDerivative() {    try {      HighamHall54Integrator integrator =          new HighamHall54Integrator(0.0, 1.0, 1.0e-10, 1.0e-10);      FirstOrderDifferentialEquations equations =          new FirstOrderDifferentialEquations() {            private static final long serialVersionUID = -1157081786301178032L;            public void computeDerivatives(double t, double[] y, double[] dot)            throws DerivativeException {            if (t < -0.5) {                throw new DerivativeException(LocalizedFormats.SIMPLE_MESSAGE, "oops");            } else {                throw new DerivativeException(new RuntimeException("oops"));           }          }          public int getDimension() {              return 1;          }      };      try  {        integrator.integrate(equations, -1.0, new double[1], 0.0, new double[1]);        fail("an exception should have been thrown");      } catch(DerivativeException de) {        // expected behavior      }      try  {        integrator.integrate(equations, 0.0, new double[1], 1.0, new double[1]);        fail("an exception should have been thrown");      } catch(DerivativeException de) {        // expected behavior      }    } catch (Exception e) {      fail("wrong exception caught: " + e.getMessage());    }  }  public void testMinStep() {    try {      TestProblem1 pb = new TestProblem1();      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              vecAbsoluteTolerance,                                                              vecRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testIncreasingTolerance()    throws DerivativeException, IntegratorException {    int previousCalls = Integer.MAX_VALUE;    for (int i = -12; i < -2; ++i) {      TestProblem1 pb = new TestProblem1();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = FastMath.pow(10.0, i);      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      // the 1.3 factor is only valid for this test      // and has been obtained from trial and error      // there is no general relation between local and global errors      assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      int calls = pb.getCalls();      assertEquals(integ.getEvaluations(), calls);      assertTrue(calls <= previousCalls);      previousCalls = calls;    }  }  public void testBackward()      throws DerivativeException, IntegratorException {      TestProblem5 pb = new TestProblem5();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertTrue(handler.getLastError() < 5.0e-7);      assertTrue(handler.getMaximalValueError() < 5.0e-7);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      assertEquals("Higham-Hall 5(4)", integ.getName());  }  public void testEvents()    throws DerivativeException, IntegratorException {    TestProblem4 pb = new TestProblem4();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                            scalAbsoluteTolerance,                                                            scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    EventHandler[] functions = pb.getEventsHandlers();    for (int l = 0; l < functions.length; ++l) {      integ.addEventHandler(functions[l],                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);    }    assertEquals(functions.length, integ.getEventHandlers().size());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getMaximalValueError() < 1.0e-7);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);    integ.clearEventHandlers();    assertEquals(0, integ.getEventHandlers().size());  }  public void testEventsErrors() {      final TestProblem1 pb = new TestProblem1();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ =          new HighamHall54Integrator(minStep, maxStep,                                     scalAbsoluteTolerance, scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.addEventHandler(new EventHandler() {        public int eventOccurred(double t, double[] y, boolean increasing) {          return EventHandler.CONTINUE;        }        public double g(double t, double[] y) throws EventException {          double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;          double offset = t - middle;          if (offset > 0) {            throw new EventException(LocalizedFormats.EVALUATION_FAILED, t);          }          return offset;        }        public void resetState(double t, double[] y) {        }        private static final long serialVersionUID = 935652725339916361L;      }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);      try {        integ.integrate(pb,                        pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        fail("an exception should have been thrown");      } catch (IntegratorException ie) {        // expected behavior      } catch (Exception e) {        fail("wrong exception type caught");      }  }  public void testEventsNoConvergence() {    final TestProblem1 pb = new TestProblem1();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ =        new HighamHall54Integrator(minStep, maxStep,                                   scalAbsoluteTolerance, scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.addEventHandler(new EventHandler() {      public int eventOccurred(double t, double[] y, boolean increasing) {        return EventHandler.CONTINUE;      }      public double g(double t, double[] y) {        double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;        double offset = t - middle;        return (offset > 0) ? (offset + 0.5) : (offset - 0.5);      }      public void resetState(double t, double[] y) {      }      private static final long serialVersionUID = 935652725339916361L;    }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 3);    try {      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch (IntegratorException ie) {       assertTrue(ie.getCause() != null);       assertTrue(ie.getCause() instanceof ConvergenceException);    } catch (Exception e) {      fail("wrong exception type caught");    }}  public void testSanityChecks() {    try {      final TestProblem3 pb  = new TestProblem3(0.9);      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      try {        FirstOrderIntegrator integ =            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);        integ.integrate(pb, pb.getInitialTime(), new double[6],                        pb.getFinalTime(), new double[pb.getDimension()]);        fail("an exception should have been thrown");      } catch (IntegratorException ie) {        // expected behavior      }      try {        FirstOrderIntegrator integ =            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[6]);        fail("an exception should have been thrown");      } catch (IntegratorException ie) {        // expected behavior      }      try {        FirstOrderIntegrator integ =            new HighamHall54Integrator(minStep, maxStep, new double[2], new double[4]);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        fail("an exception should have been thrown");      } catch (IntegratorException ie) {        // expected behavior      }      try {        FirstOrderIntegrator integ =            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[2]);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        fail("an exception should have been thrown");      } catch (IntegratorException ie) {        // expected behavior      }      try {        FirstOrderIntegrator integ =            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getInitialTime(), new double[pb.getDimension()]);        fail("an exception should have been thrown");      } catch (IntegratorException ie) {        // expected behavior      }    } catch (Exception e) {      fail("wrong exception caught: " + e.getMessage());    }  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double[] vecAbsoluteTolerance = { 1.0e-8, 1.0e-8, 1.0e-10, 1.0e-10 };    double[] vecRelativeTolerance = { 1.0e-10, 1.0e-10, 1.0e-8, 1.0e-8 };    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,                                                            vecAbsoluteTolerance,                                                            vecRelativeTolerance);    integ.addStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertEquals("Higham-Hall 5(4)", integ.getName());  }  private static class KeplerHandler implements StepHandler {    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      nbSteps = 0;      maxError = 0;    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      nbSteps = 0;      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) throws DerivativeException {      ++nbSteps;      double[] interpolatedY = interpolator.getInterpolatedState();      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }      if (isLast) {        assertTrue(maxError < 4.2e-11);        assertTrue(nbSteps < 670);      }    }    private TestProblem3 pb;    private int nbSteps;    private double maxError;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.TestProblem4;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;import org.apache.commons.math.ode.sampling.DummyStepHandler;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;import junit.framework.*;public class DormandPrince853IntegratorTest  extends TestCase {  public DormandPrince853IntegratorTest(String name) {    super(name);  }  public void testMissedEndEvent() throws IntegratorException, DerivativeException {      final double   t0     = 1878250320.0000029;      final double   tEvent = 1878250379.9999986;      final double[] k  = { 1.0e-4, 1.0e-5, 1.0e-6 };      FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {          public int getDimension() {              return k.length;          }          public void computeDerivatives(double t, double[] y, double[] yDot) {              for (int i = 0; i < y.length; ++i) {                  yDot[i] = k[i] * y[i];              }          }      };      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 100.0,                                                                             1.0e-10, 1.0e-10);      double[] y0   = new double[k.length];      for (int i = 0; i < y0.length; ++i) {          y0[i] = i + 1;      }      double[] y    = new double[k.length];      integrator.setInitialStepSize(60.0);      double finalT = integrator.integrate(ode, t0, y0, tEvent, y);      Assert.assertEquals(tEvent, finalT, 5.0e-6);      for (int i = 0; i < y.length; ++i) {          Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);      }      integrator.setInitialStepSize(60.0);      integrator.addEventHandler(new EventHandler() {          public void resetState(double t, double[] y) {          }          public double g(double t, double[] y) {              return t - tEvent;          }          public int eventOccurred(double t, double[] y, boolean increasing) {              Assert.assertEquals(tEvent, t, 5.0e-6);              return CONTINUE;          }      }, Double.POSITIVE_INFINITY, 1.0e-20, 100);      finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);      Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);      for (int i = 0; i < y.length; ++i) {          Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);      }  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,                                                                             1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()+10],                           1.0, new double[pb.getDimension()+10]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testNullIntervalCheck() {    try  {      TestProblem1 pb = new TestProblem1();      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,                                                                             1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()],                           0.0, new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testMinStep() {    try {      TestProblem1 pb = new TestProblem1();      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                  vecAbsoluteTolerance,                                                                  vecRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testIncreasingTolerance()    throws DerivativeException, IntegratorException {    int previousCalls = Integer.MAX_VALUE;    for (int i = -12; i < -2; ++i) {      TestProblem1 pb = new TestProblem1();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = FastMath.pow(10.0, i);      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                  scalAbsoluteTolerance,                                                                  scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      // the 1.3 factor is only valid for this test      // and has been obtained from trial and error      // there is no general relation between local and global errors      assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      int calls = pb.getCalls();      assertEquals(integ.getEvaluations(), calls);      assertTrue(calls <= previousCalls);      previousCalls = calls;    }  }  public void testBackward()      throws DerivativeException, IntegratorException {      TestProblem5 pb = new TestProblem5();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                  scalAbsoluteTolerance,                                                                  scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertTrue(handler.getLastError() < 8.1e-8);      assertTrue(handler.getMaximalValueError() < 1.1e-7);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      assertEquals("Dormand-Prince 8 (5, 3)", integ.getName());  }  public void testEvents()    throws DerivativeException, IntegratorException {    TestProblem4 pb = new TestProblem4();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-9;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                scalAbsoluteTolerance,                                                                scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    EventHandler[] functions = pb.getEventsHandlers();    for (int l = 0; l < functions.length; ++l) {      integ.addEventHandler(functions[l],                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);    }    assertEquals(functions.length, integ.getEventHandlers().size());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getMaximalValueError() < 5.0e-8);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);    integ.clearEventHandlers();    assertEquals(0, integ.getEventHandlers().size());  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                scalAbsoluteTolerance,                                                                scalRelativeTolerance);    integ.addStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertEquals(integ.getEvaluations(), pb.getCalls());    assertTrue(pb.getCalls() < 3300);  }  public void testVariableSteps()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);    integ.addStepHandler(new VariableHandler());    double stopTime = integ.integrate(pb,                                      pb.getInitialTime(), pb.getInitialState(),                                      pb.getFinalTime(), new double[pb.getDimension()]);    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);    assertEquals("Dormand-Prince 8 (5, 3)", integ.getName());  }  public void testNoDenseOutput()    throws DerivativeException, IntegratorException {    TestProblem1 pb1 = new TestProblem1();    TestProblem1 pb2 = pb1.copy();    double minStep = 0.1 * (pb1.getFinalTime() - pb1.getInitialTime());    double maxStep = pb1.getFinalTime() - pb1.getInitialTime();    double scalAbsoluteTolerance = 1.0e-4;    double scalRelativeTolerance = 1.0e-4;    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                scalAbsoluteTolerance,                                                                scalRelativeTolerance);    integ.addStepHandler(DummyStepHandler.getInstance());    integ.integrate(pb1,                    pb1.getInitialTime(), pb1.getInitialState(),                    pb1.getFinalTime(), new double[pb1.getDimension()]);    int callsWithoutDenseOutput = pb1.getCalls();    assertEquals(integ.getEvaluations(), callsWithoutDenseOutput);    integ.addStepHandler(new InterpolatingStepHandler());    integ.integrate(pb2,                    pb2.getInitialTime(), pb2.getInitialState(),                    pb2.getFinalTime(), new double[pb2.getDimension()]);    int callsWithDenseOutput = pb2.getCalls();    assertEquals(integ.getEvaluations(), callsWithDenseOutput);    assertTrue(callsWithDenseOutput > callsWithoutDenseOutput);  }  public void testUnstableDerivative()  throws DerivativeException, IntegratorException {    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);    FirstOrderIntegrator integ =      new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0);    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);    double[] y = { Double.NaN };    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);    assertEquals(8.0, y[0], 1.0e-12);  }  private static class KeplerHandler implements StepHandler {    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public boolean requiresDenseOutput() {      return true;    }    public void reset() {      nbSteps = 0;      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast)    throws DerivativeException {      ++nbSteps;      for (int a = 1; a < 10; ++a) {        double prev   = interpolator.getPreviousTime();        double curr   = interpolator.getCurrentTime();        double interp = ((10 - a) * prev + a * curr) / 10;        interpolator.setInterpolatedTime(interp);        double[] interpolatedY = interpolator.getInterpolatedState ();        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());        double dx = interpolatedY[0] - theoreticalY[0];        double dy = interpolatedY[1] - theoreticalY[1];        double error = dx * dx + dy * dy;        if (error > maxError) {          maxError = error;        }      }      if (isLast) {        assertTrue(maxError < 2.4e-10);        assertTrue(nbSteps < 150);      }    }    private int nbSteps;    private double maxError;    private TestProblem3 pb;  }  private static class VariableHandler implements StepHandler {    public VariableHandler() {      reset();    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      firstTime = true;      minStep = 0;      maxStep = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) {      double step = FastMath.abs(interpolator.getCurrentTime()                             - interpolator.getPreviousTime());      if (firstTime) {        minStep   = FastMath.abs(step);        maxStep   = minStep;        firstTime = false;      } else {        if (step < minStep) {          minStep = step;        }        if (step > maxStep) {          maxStep = step;        }      }      if (isLast) {        assertTrue(minStep < (1.0 / 100.0));        assertTrue(maxStep > (1.0 / 2.0));      }    }    private boolean firstTime = true;    private double  minStep = 0;    private double  maxStep = 0;  }  private static class InterpolatingStepHandler implements StepHandler {    public boolean requiresDenseOutput() {      return true;    }    public void reset() {    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast)    throws DerivativeException {      double prev = interpolator.getPreviousTime();      double curr = interpolator.getCurrentTime();      interpolator.setInterpolatedTime(0.5*(prev + curr));    }  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import junit.framework.*;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemAbstract;import org.apache.commons.math.ode.TestProblemFactory;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.nonstiff.MidpointIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;public class MidpointIntegratorTest  extends TestCase {  public MidpointIntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      new MidpointIntegrator(0.01).integrate(pb,                                             0.0, new double[pb.getDimension()+10],                                             1.0, new double[pb.getDimension()+10]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testDecreasingSteps()    throws DerivativeException, IntegratorException  {    TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousError = Double.NaN;      for (int i = 4; i < 10; ++i) {        TestProblemAbstract pb = problems[k].copy();        double step = (pb.getFinalTime() - pb.getInitialTime())          * FastMath.pow(2.0, -i);        FirstOrderIntegrator integ = new MidpointIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        EventHandler[] functions = pb.getEventsHandlers();        for (int l = 0; l < functions.length; ++l) {          integ.addEventHandler(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);        }        double stopTime = integ.integrate(pb,                                          pb.getInitialTime(), pb.getInitialState(),                                          pb.getFinalTime(), new double[pb.getDimension()]);        if (functions.length == 0) {            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);        }        double error = handler.getMaximalValueError();        if (i > 4) {          assertTrue(error < FastMath.abs(previousError));        }        previousError = error;        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      }    }  }  public void testSmallStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb  = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new MidpointIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() < 2.0e-7);    assertTrue(handler.getMaximalValueError() < 1.0e-6);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals("midpoint", integ.getName());  }  public void testBigStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb  = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new MidpointIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() > 0.01);    assertTrue(handler.getMaximalValueError() > 0.05);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);  }  public void testBackward()      throws DerivativeException, IntegratorException {      TestProblem5 pb = new TestProblem5();      double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new MidpointIntegrator(step);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertTrue(handler.getLastError() < 6.0e-4);      assertTrue(handler.getMaximalValueError() < 6.0e-4);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      assertEquals("midpoint", integ.getName());  }  public void testStepSize()    throws DerivativeException, IntegratorException {      final double step = 1.23456;      FirstOrderIntegrator integ = new MidpointIntegrator(step);      integ.addStepHandler(new StepHandler() {          public void handleStep(StepInterpolator interpolator, boolean isLast) {              if (! isLast) {                  assertEquals(step,                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),                               1.0e-12);              }          }          public boolean requiresDenseOutput() {              return false;          }          public void reset() {          }      });      integ.integrate(new FirstOrderDifferentialEquations() {          private static final long serialVersionUID = 0L;          public void computeDerivatives(double t, double[] y, double[] dot) {              dot[0] = 1.0;          }          public int getDimension() {              return 1;          }      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.TestProblem4;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemAbstract;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;import org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;import junit.framework.*;public class DormandPrince54IntegratorTest  extends TestCase {  public DormandPrince54IntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      DormandPrince54Integrator integrator = new DormandPrince54Integrator(0.0, 1.0,                                                                           1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()+10],                           1.0, new double[pb.getDimension()+10]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testMinStep() {    try {      TestProblem1 pb = new TestProblem1();      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                 vecAbsoluteTolerance,                                                                 vecRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testSmallLastStep()    throws DerivativeException, IntegratorException {    TestProblemAbstract pb = new TestProblem5();    double minStep = 1.25;    double maxStep = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());    double scalAbsoluteTolerance = 6.0e-4;    double scalRelativeTolerance = 6.0e-4;    AdaptiveStepsizeIntegrator integ =      new DormandPrince54Integrator(minStep, maxStep,                                    scalAbsoluteTolerance,                                    scalRelativeTolerance);    DP54SmallLastHandler handler = new DP54SmallLastHandler(minStep);    integ.addStepHandler(handler);    integ.setInitialStepSize(1.7);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.wasLastSeen());    assertEquals("Dormand-Prince 5(4)", integ.getName());  }  public void testBackward()      throws DerivativeException, IntegratorException {      TestProblem5 pb = new TestProblem5();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                 scalAbsoluteTolerance,                                                                 scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertTrue(handler.getLastError() < 2.0e-7);      assertTrue(handler.getMaximalValueError() < 2.0e-7);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      assertEquals("Dormand-Prince 5(4)", integ.getName());  }  private static class DP54SmallLastHandler implements StepHandler {    public DP54SmallLastHandler(double minStep) {      lastSeen = false;      this.minStep = minStep;    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {    }    public void handleStep(StepInterpolator interpolator, boolean isLast) {      if (isLast) {        lastSeen = true;        double h = interpolator.getCurrentTime() - interpolator.getPreviousTime();        assertTrue(FastMath.abs(h) < minStep);      }    }    public boolean wasLastSeen() {      return lastSeen;    }    private boolean lastSeen;    private double  minStep;  }  public void testIncreasingTolerance()    throws DerivativeException, IntegratorException {    int previousCalls = Integer.MAX_VALUE;    for (int i = -12; i < -2; ++i) {      TestProblem1 pb = new TestProblem1();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = FastMath.pow(10.0, i);      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      EmbeddedRungeKuttaIntegrator integ =          new DormandPrince54Integrator(minStep, maxStep,                                        scalAbsoluteTolerance, scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.setSafety(0.8);      integ.setMaxGrowth(5.0);      integ.setMinReduction(0.3);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertEquals(0.8, integ.getSafety(), 1.0e-12);      assertEquals(5.0, integ.getMaxGrowth(), 1.0e-12);      assertEquals(0.3, integ.getMinReduction(), 1.0e-12);      // the 0.7 factor is only valid for this test      // and has been obtained from trial and error      // there is no general relation between local and global errors      assertTrue(handler.getMaximalValueError() < (0.7 * scalAbsoluteTolerance));      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      int calls = pb.getCalls();      assertEquals(integ.getEvaluations(), calls);      assertTrue(calls <= previousCalls);      previousCalls = calls;    }  }  public void testEvents()    throws DerivativeException, IntegratorException {    TestProblem4 pb = new TestProblem4();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    EventHandler[] functions = pb.getEventsHandlers();    for (int l = 0; l < functions.length; ++l) {      integ.addEventHandler(functions[l],                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);    }    assertEquals(functions.length, integ.getEventHandlers().size());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getMaximalValueError() < 5.0e-6);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);    integ.clearEventHandlers();    assertEquals(0, integ.getEventHandlers().size());  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);    integ.addStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertEquals(integ.getEvaluations(), pb.getCalls());    assertTrue(pb.getCalls() < 2800);  }  public void testVariableSteps()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                               scalAbsoluteTolerance,                                                               scalRelativeTolerance);    integ.addStepHandler(new VariableHandler());    double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                      pb.getFinalTime(), new double[pb.getDimension()]);    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);  }  private static class KeplerHandler implements StepHandler {    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public boolean requiresDenseOutput() {      return true;    }    public void reset() {      nbSteps = 0;      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast)    throws DerivativeException {      ++nbSteps;      for (int a = 1; a < 10; ++a) {        double prev   = interpolator.getPreviousTime();        double curr   = interpolator.getCurrentTime();        double interp = ((10 - a) * prev + a * curr) / 10;        interpolator.setInterpolatedTime(interp);        double[] interpolatedY = interpolator.getInterpolatedState ();        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());        double dx = interpolatedY[0] - theoreticalY[0];        double dy = interpolatedY[1] - theoreticalY[1];        double error = dx * dx + dy * dy;        if (error > maxError) {          maxError = error;        }      }      if (isLast) {        assertTrue(maxError < 7.0e-10);        assertTrue(nbSteps < 400);      }    }    private int nbSteps;    private double maxError;    private TestProblem3 pb;  }  private static class VariableHandler implements StepHandler {    public VariableHandler() {      firstTime = true;      minStep = 0;      maxStep = 0;    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      firstTime = true;      minStep = 0;      maxStep = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) {      double step = FastMath.abs(interpolator.getCurrentTime()                             - interpolator.getPreviousTime());      if (firstTime) {        minStep   = FastMath.abs(step);        maxStep   = minStep;        firstTime = false;      } else {        if (step < minStep) {          minStep = step;        }        if (step > maxStep) {          maxStep = step;        }      }      if (isLast) {        assertTrue(minStep < (1.0 / 450.0));        assertTrue(maxStep > (1.0 / 4.2));      }    }    private boolean firstTime;    private double  minStep;    private double  maxStep;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.junit.Test;public class ClassicalRungeKuttaStepInterpolatorTest {  @Test  public void derivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    assertTrue(bos.size () > 700000);    assertTrue(bos.size () < 701000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError > 0.005);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Test;public class DormandPrince54StepInterpolatorTest {  @Test  public void derivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3(0.1);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                    scalAbsoluteTolerance,                                                                    scalRelativeTolerance);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                    scalAbsoluteTolerance,                                                                    scalRelativeTolerance);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    assertTrue(bos.size () > 119500);    assertTrue(bos.size () < 120500);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 7.0e-10);  }  @Test  public void checkClone()    throws DerivativeException, IntegratorException {      TestProblem3 pb = new TestProblem3(0.9);      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = scalAbsoluteTolerance;      DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,                                                                      scalAbsoluteTolerance,                                                                      scalRelativeTolerance);      integ.addStepHandler(new StepHandler() {        public void handleStep(StepInterpolator interpolator, boolean isLast)          throws DerivativeException {              StepInterpolator cloned = interpolator.copy();              double tA = cloned.getPreviousTime();              double tB = cloned.getCurrentTime();              double halfStep = FastMath.abs(tB - tA) / 2;              assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);              assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);              for (int i = 0; i < 10; ++i) {                  double t = (i * tB + (9 - i) * tA) / 9;                  interpolator.setInterpolatedTime(t);                  assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));                  cloned.setInterpolatedTime(t);                  assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);                  double[] referenceState = interpolator.getInterpolatedState();                  double[] cloneState     = cloned.getInterpolatedState();                  for (int j = 0; j < referenceState.length; ++j) {                      assertEquals(referenceState[j], cloneState[j], 1.0e-12);                  }              }          }          public boolean requiresDenseOutput() {              return true;          }          public void reset() {          }      });      integ.integrate(pb,              pb.getInitialTime(), pb.getInitialState(),              pb.getFinalTime(), new double[pb.getDimension()]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblem6;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.util.FastMath;import org.junit.Test;public class AdamsBashforthIntegratorTest {    @Test(expected=IntegratorException.class)    public void dimensionCheck() throws DerivativeException, IntegratorException {        TestProblem1 pb = new TestProblem1();        FirstOrderIntegrator integ =            new AdamsBashforthIntegrator(2, 0.0, 1.0, 1.0e-10, 1.0e-10);        integ.integrate(pb,                        0.0, new double[pb.getDimension()+10],                        1.0, new double[pb.getDimension()+10]);    }    @Test(expected=IntegratorException.class)    public void testMinStep() throws DerivativeException, IntegratorException {          TestProblem1 pb = new TestProblem1();          double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());          double maxStep = pb.getFinalTime() - pb.getInitialTime();          double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };          double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };          FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, minStep, maxStep,                                                                    vecAbsoluteTolerance,                                                                    vecRelativeTolerance);          TestProblemHandler handler = new TestProblemHandler(pb, integ);          integ.addStepHandler(handler);          integ.integrate(pb,                          pb.getInitialTime(), pb.getInitialState(),                          pb.getFinalTime(), new double[pb.getDimension()]);    }    @Test    public void testIncreasingTolerance()        throws DerivativeException, IntegratorException {        int previousCalls = Integer.MAX_VALUE;        for (int i = -12; i < -5; ++i) {            TestProblem1 pb = new TestProblem1();            double minStep = 0;            double maxStep = pb.getFinalTime() - pb.getInitialTime();            double scalAbsoluteTolerance = FastMath.pow(10.0, i);            double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;            FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, minStep, maxStep,                                                                      scalAbsoluteTolerance,                                                                      scalRelativeTolerance);            TestProblemHandler handler = new TestProblemHandler(pb, integ);            integ.addStepHandler(handler);            integ.integrate(pb,                            pb.getInitialTime(), pb.getInitialState(),                            pb.getFinalTime(), new double[pb.getDimension()]);            // the 31 and 36 factors are only valid for this test            // and has been obtained from trial and error            // there is no general relation between local and global errors            assertTrue(handler.getMaximalValueError() > (31.0 * scalAbsoluteTolerance));            assertTrue(handler.getMaximalValueError() < (36.0 * scalAbsoluteTolerance));            assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);            int calls = pb.getCalls();            assertEquals(integ.getEvaluations(), calls);            assertTrue(calls <= previousCalls);            previousCalls = calls;        }    }    @Test(expected = DerivativeException.class)    public void exceedMaxEvaluations() throws DerivativeException, IntegratorException {        TestProblem1 pb  = new TestProblem1();        double range = pb.getFinalTime() - pb.getInitialTime();        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(2, 0, range, 1.0e-12, 1.0e-12);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        integ.setMaxEvaluations(650);        integ.integrate(pb,                        pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);    }    @Test    public void backward() throws DerivativeException, IntegratorException {        TestProblem5 pb = new TestProblem5();        double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());        FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, 0, range, 1.0e-12, 1.0e-12);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        assertTrue(handler.getLastError() < 1.0e-8);        assertTrue(handler.getMaximalValueError() < 1.0e-8);        assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);        assertEquals("Adams-Bashforth", integ.getName());    }    @Test    public void polynomial() throws DerivativeException, IntegratorException {        TestProblem6 pb = new TestProblem6();        double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());        for (int nSteps = 1; nSteps < 8; ++nSteps) {            AdamsBashforthIntegrator integ =                new AdamsBashforthIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-10, 1.0e-10);            TestProblemHandler handler = new TestProblemHandler(pb, integ);            integ.addStepHandler(handler);            integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                            pb.getFinalTime(), new double[pb.getDimension()]);            if (nSteps < 4) {                assertTrue(integ.getEvaluations() > 160);            } else {                assertTrue(integ.getEvaluations() < 80);            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Test;public class EulerStepInterpolatorTest {  @Test  public void noReset() throws DerivativeException {    double[]   y    =   { 0.0, 1.0, -2.0 };    double[][] yDot = { { 1.0, 2.0, -2.0 } };    EulerStepInterpolator interpolator = new EulerStepInterpolator();    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    double[] result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {      assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);    }  }  @Test  public void interpolationAtBounds()    throws DerivativeException {    double   t0 = 0;    double[] y0 = {0.0, 1.0, -2.0};    double[] y = y0.clone();    double[][] yDot = { new double[y0.length] };    EulerStepInterpolator interpolator = new EulerStepInterpolator();    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);    interpolator.storeTime(t0);    double dt = 1.0;    y[0] =  1.0;    y[1] =  3.0;    y[2] = -4.0;    yDot[0][0] = (y[0] - y0[0]) / dt;    yDot[0][1] = (y[1] - y0[1]) / dt;    yDot[0][2] = (y[2] - y0[2]) / dt;    interpolator.shift();    interpolator.storeTime(t0 + dt);    interpolator.setInterpolatedTime(interpolator.getPreviousTime());    double[] result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {      assertTrue(FastMath.abs(result[i] - y0[i]) < 1.0e-10);    }    interpolator.setInterpolatedTime(interpolator.getCurrentTime());    result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {      assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);    }  }  @Test  public void interpolationInside()  throws DerivativeException {    double[]   y    =   { 1.0, 3.0, -4.0 };    double[][] yDot = { { 1.0, 2.0, -2.0 } };    EulerStepInterpolator interpolator = new EulerStepInterpolator();    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    interpolator.setInterpolatedTime(0.1);    double[] result = interpolator.getInterpolatedState();    assertTrue(FastMath.abs(result[0] - 0.1) < 1.0e-10);    assertTrue(FastMath.abs(result[1] - 1.2) < 1.0e-10);    assertTrue(FastMath.abs(result[2] + 2.2) < 1.0e-10);    interpolator.setInterpolatedTime(0.5);    result = interpolator.getInterpolatedState();    assertTrue(FastMath.abs(result[0] - 0.5) < 1.0e-10);    assertTrue(FastMath.abs(result[1] - 2.0) < 1.0e-10);    assertTrue(FastMath.abs(result[2] + 3.0) < 1.0e-10);  }  @Test  public void derivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    EulerIntegrator integ = new EulerIntegrator(step);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    EulerIntegrator integ = new EulerIntegrator(step);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 0.001);  }  private static class DummyIntegrator extends RungeKuttaIntegrator {      protected DummyIntegrator(RungeKuttaStepInterpolator prototype) {          super("dummy", new double[0], new double[0][0], new double[0], prototype, Double.NaN);      }  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import junit.framework.*;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemAbstract;import org.apache.commons.math.ode.TestProblemFactory;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;public class ClassicalRungeKuttaIntegratorTest  extends TestCase {  public ClassicalRungeKuttaIntegratorTest(String name) {    super(name);  }  public void testMissedEndEvent() throws IntegratorException, DerivativeException {      final double   t0     = 1878250320.0000029;      final double   tEvent = 1878250379.9999986;      final double[] k      = { 1.0e-4, 1.0e-5, 1.0e-6 };      FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {          public int getDimension() {              return k.length;          }          public void computeDerivatives(double t, double[] y, double[] yDot) {              for (int i = 0; i < y.length; ++i) {                  yDot[i] = k[i] * y[i];              }          }      };      ClassicalRungeKuttaIntegrator integrator = new ClassicalRungeKuttaIntegrator(60.0);      double[] y0   = new double[k.length];      for (int i = 0; i < y0.length; ++i) {          y0[i] = i + 1;      }      double[] y    = new double[k.length];      double finalT = integrator.integrate(ode, t0, y0, tEvent, y);      Assert.assertEquals(tEvent, finalT, 5.0e-6);      for (int i = 0; i < y.length; ++i) {          Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);      }      integrator.addEventHandler(new EventHandler() {          public void resetState(double t, double[] y) {          }          public double g(double t, double[] y) {              return t - tEvent;          }          public int eventOccurred(double t, double[] y, boolean increasing) {              Assert.assertEquals(tEvent, t, 5.0e-6);              return CONTINUE;          }      }, Double.POSITIVE_INFINITY, 1.0e-20, 100);      finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);      Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);      for (int i = 0; i < y.length; ++i) {          Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);      }  }  public void testSanityChecks() {    try  {      TestProblem1 pb = new TestProblem1();      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,                                                        0.0, new double[pb.getDimension()+10],                                                        1.0, new double[pb.getDimension()]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }    try  {        TestProblem1 pb = new TestProblem1();        new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,                                                          0.0, new double[pb.getDimension()],                                                          1.0, new double[pb.getDimension()+10]);          fail("an exception should have been thrown");      } catch(DerivativeException de) {        fail("wrong exception caught");      } catch(IntegratorException ie) {      }    try  {      TestProblem1 pb = new TestProblem1();      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,                                                        0.0, new double[pb.getDimension()],                                                        0.0, new double[pb.getDimension()]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testDecreasingSteps()    throws DerivativeException, IntegratorException  {    TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousError = Double.NaN;      for (int i = 4; i < 10; ++i) {        TestProblemAbstract pb = problems[k].copy();        double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i);        FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        EventHandler[] functions = pb.getEventsHandlers();        for (int l = 0; l < functions.length; ++l) {          integ.addEventHandler(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);        }        assertEquals(functions.length, integ.getEventHandlers().size());        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                          pb.getFinalTime(), new double[pb.getDimension()]);        if (functions.length == 0) {            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);        }        double error = handler.getMaximalValueError();        if (i > 4) {          assertTrue(error < FastMath.abs(previousError));        }        previousError = error;        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);        integ.clearEventHandlers();        assertEquals(0, integ.getEventHandlers().size());      }    }  }  public void testSmallStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() < 2.0e-13);    assertTrue(handler.getMaximalValueError() < 4.0e-12);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals("classical Runge-Kutta", integ.getName());  }  public void testBigStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() > 0.0004);    assertTrue(handler.getMaximalValueError() > 0.005);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);  }  public void testBackward()    throws DerivativeException, IntegratorException {    TestProblem5 pb = new TestProblem5();    double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() < 5.0e-10);    assertTrue(handler.getMaximalValueError() < 7.0e-10);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals("classical Runge-Kutta", integ.getName());  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);    integ.addStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);  }  private static class KeplerHandler implements StepHandler {    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) throws DerivativeException {      double[] interpolatedY = interpolator.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }      if (isLast) {        // even with more than 1000 evaluations per period,        // RK4 is not able to integrate such an eccentric        // orbit with a good accuracy        assertTrue(maxError > 0.005);      }    }    private double maxError = 0;    private TestProblem3 pb;  }  public void testStepSize()    throws DerivativeException, IntegratorException {      final double step = 1.23456;      FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);      integ.addStepHandler(new StepHandler() {          public void handleStep(StepInterpolator interpolator, boolean isLast) {              if (! isLast) {                  assertEquals(step,                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),                               1.0e-12);              }          }          public boolean requiresDenseOutput() {              return false;          }          public void reset() {          }      });      integ.integrate(new FirstOrderDifferentialEquations() {          private static final long serialVersionUID = 0L;          public void computeDerivatives(double t, double[] y, double[] dot) {              dot[0] = 1.0;          }          public int getDimension() {              return 1;          }      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.junit.Test;public class MidpointStepInterpolatorTest {  @Test  public void testDerivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    MidpointIntegrator integ = new MidpointIntegrator(step);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    MidpointIntegrator integ = new MidpointIntegrator(step);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    assertTrue(bos.size () > 98000);    assertTrue(bos.size () < 99000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 1.0e-6);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.TestProblem4;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemAbstract;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;import junit.framework.*;public class GraggBulirschStoerIntegratorTest  extends TestCase {  public GraggBulirschStoerIntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      AdaptiveStepsizeIntegrator integrator =        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()+10],                           1.0, new double[pb.getDimension()+10]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testNullIntervalCheck() {    try  {      TestProblem1 pb = new TestProblem1();      GraggBulirschStoerIntegrator integrator =        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);      integrator.integrate(pb,                           0.0, new double[pb.getDimension()],                           0.0, new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testMinStep() {    try {      TestProblem5 pb  = new TestProblem5();      double minStep   = 0.1 * FastMath.abs(pb.getFinalTime() - pb.getInitialTime());      double maxStep   = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());      double[] vecAbsoluteTolerance = { 1.0e-20, 1.0e-21 };      double[] vecRelativeTolerance = { 1.0e-20, 1.0e-21 };      FirstOrderIntegrator integ =        new GraggBulirschStoerIntegrator(minStep, maxStep,                                         vecAbsoluteTolerance, vecRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testBackward()      throws DerivativeException, IntegratorException {      TestProblem5 pb = new TestProblem5();      double minStep = 0;      double maxStep = pb.getFinalTime() - pb.getInitialTime();      double scalAbsoluteTolerance = 1.0e-8;      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;      FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,                                                                    scalAbsoluteTolerance,                                                                    scalRelativeTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertTrue(handler.getLastError() < 9.0e-10);      assertTrue(handler.getMaximalValueError() < 9.0e-10);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      assertEquals("Gragg-Bulirsch-Stoer", integ.getName());  }  public void testIncreasingTolerance()    throws DerivativeException, IntegratorException {    int previousCalls = Integer.MAX_VALUE;    for (int i = -12; i < -4; ++i) {      TestProblem1 pb     = new TestProblem1();      double minStep      = 0;      double maxStep      = pb.getFinalTime() - pb.getInitialTime();      double absTolerance = FastMath.pow(10.0, i);      double relTolerance = absTolerance;      FirstOrderIntegrator integ =        new GraggBulirschStoerIntegrator(minStep, maxStep,                                         absTolerance, relTolerance);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb,                      pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      // the coefficients are only valid for this test      // and have been obtained from trial and error      // there is no general relation between local and global errors      double ratio =  handler.getMaximalValueError() / absTolerance;      assertTrue(ratio < 2.4);      assertTrue(ratio > 0.02);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      int calls = pb.getCalls();      assertEquals(integ.getEvaluations(), calls);      assertTrue(calls <= previousCalls);      previousCalls = calls;    }  }  public void testIntegratorControls()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3(0.999);    GraggBulirschStoerIntegrator integ =        new GraggBulirschStoerIntegrator(0, pb.getFinalTime() - pb.getInitialTime(),                1.0e-8, 1.0e-10);    double errorWithDefaultSettings = getMaxError(integ, pb);    // stability control    integ.setStabilityCheck(true, 2, 1, 0.99);    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));    integ.setStabilityCheck(true, -1, -1, -1);    integ.setStepsizeControl(0.5, 0.99, 0.1, 2.5);    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));    integ.setStepsizeControl(-1, -1, -1, -1);    integ.setOrderControl(10, 0.7, 0.95);    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));    integ.setOrderControl(-1, -1, -1);    integ.setInterpolationControl(true, 3);    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));    integ.setInterpolationControl(true, -1);  }  private double getMaxError(FirstOrderIntegrator integrator, TestProblemAbstract pb)    throws DerivativeException, IntegratorException {      TestProblemHandler handler = new TestProblemHandler(pb, integrator);      integrator.addStepHandler(handler);      integrator.integrate(pb,                           pb.getInitialTime(), pb.getInitialState(),                           pb.getFinalTime(), new double[pb.getDimension()]);      return handler.getMaximalValueError();  }  public void testEvents()    throws DerivativeException, IntegratorException {    TestProblem4 pb = new TestProblem4();    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-10;    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;    FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,                                                                  scalAbsoluteTolerance,                                                                  scalRelativeTolerance);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    EventHandler[] functions = pb.getEventsHandlers();    for (int l = 0; l < functions.length; ++l) {      integ.addEventHandler(functions[l],                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);    }    assertEquals(functions.length, integ.getEventHandlers().size());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getMaximalValueError() < 5.0e-8);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);    integ.clearEventHandlers();    assertEquals(0, integ.getEventHandlers().size());  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb = new TestProblem3(0.9);    double minStep        = 0;    double maxStep        = pb.getFinalTime() - pb.getInitialTime();    double absTolerance   = 1.0e-6;    double relTolerance   = 1.0e-6;    FirstOrderIntegrator integ =      new GraggBulirschStoerIntegrator(minStep, maxStep,                                       absTolerance, relTolerance);    integ.addStepHandler(new KeplerStepHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertEquals(integ.getEvaluations(), pb.getCalls());    assertTrue(pb.getCalls() < 2150);  }  public void testVariableSteps()    throws DerivativeException, IntegratorException {    final TestProblem3 pb = new TestProblem3(0.9);    double minStep        = 0;    double maxStep        = pb.getFinalTime() - pb.getInitialTime();    double absTolerance   = 1.0e-8;    double relTolerance   = 1.0e-8;    FirstOrderIntegrator integ =      new GraggBulirschStoerIntegrator(minStep, maxStep,                                       absTolerance, relTolerance);    integ.addStepHandler(new VariableStepHandler());    double stopTime = integ.integrate(pb,                                      pb.getInitialTime(), pb.getInitialState(),                                      pb.getFinalTime(), new double[pb.getDimension()]);    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);    assertEquals("Gragg-Bulirsch-Stoer", integ.getName());  }  public void testUnstableDerivative()    throws DerivativeException, IntegratorException {    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);    FirstOrderIntegrator integ =      new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0);    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);    double[] y = { Double.NaN };    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);    assertEquals(8.0, y[0], 1.0e-12);  }  private static class KeplerStepHandler implements StepHandler {    public KeplerStepHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public boolean requiresDenseOutput() {      return true;    }    public void reset() {      nbSteps = 0;      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast)    throws DerivativeException {      ++nbSteps;      for (int a = 1; a < 100; ++a) {        double prev   = interpolator.getPreviousTime();        double curr   = interpolator.getCurrentTime();        double interp = ((100 - a) * prev + a * curr) / 100;        interpolator.setInterpolatedTime(interp);        double[] interpolatedY = interpolator.getInterpolatedState ();        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());        double dx = interpolatedY[0] - theoreticalY[0];        double dy = interpolatedY[1] - theoreticalY[1];        double error = dx * dx + dy * dy;        if (error > maxError) {          maxError = error;        }      }      if (isLast) {        assertTrue(maxError < 2.7e-6);        assertTrue(nbSteps < 80);      }    }    private int nbSteps;    private double maxError;    private TestProblem3 pb;  }  public static class VariableStepHandler implements StepHandler {    public VariableStepHandler() {      reset();    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      firstTime = true;      minStep = 0;      maxStep = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) {      double step = FastMath.abs(interpolator.getCurrentTime()                             - interpolator.getPreviousTime());      if (firstTime) {        minStep   = FastMath.abs(step);        maxStep   = minStep;        firstTime = false;      } else {        if (step < minStep) {          minStep = step;        }        if (step > maxStep) {          maxStep = step;        }      }      if (isLast) {        assertTrue(minStep < 8.2e-3);        assertTrue(maxStep > 1.7);      }    }    private boolean firstTime;    private double  minStep;    private double  maxStep;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Test;public class GraggBulirschStoerStepInterpolatorTest {  @Test  public void derivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep   = 0;    double maxStep   = pb.getFinalTime() - pb.getInitialTime();    double absTolerance = 1.0e-8;    double relTolerance = 1.0e-8;    GraggBulirschStoerIntegrator integ =      new GraggBulirschStoerIntegrator(minStep, maxStep,                                       absTolerance, relTolerance);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-8);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb  = new TestProblem3(0.9);    double minStep   = 0;    double maxStep   = pb.getFinalTime() - pb.getInitialTime();    double absTolerance = 1.0e-8;    double relTolerance = 1.0e-8;    GraggBulirschStoerIntegrator integ =      new GraggBulirschStoerIntegrator(minStep, maxStep,                                       absTolerance, relTolerance);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    assertTrue(bos.size () > 33000);    assertTrue(bos.size () < 34000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 5.0e-10);  }  @Test  public void checklone()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,                                                                          scalAbsoluteTolerance,                                                                          scalRelativeTolerance);    integ.addStepHandler(new StepHandler() {        public void handleStep(StepInterpolator interpolator, boolean isLast)        throws DerivativeException {            StepInterpolator cloned = interpolator.copy();            double tA = cloned.getPreviousTime();            double tB = cloned.getCurrentTime();            double halfStep = FastMath.abs(tB - tA) / 2;            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);            for (int i = 0; i < 10; ++i) {                double t = (i * tB + (9 - i) * tA) / 9;                interpolator.setInterpolatedTime(t);                assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));                cloned.setInterpolatedTime(t);                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);                double[] referenceState = interpolator.getInterpolatedState();                double[] cloneState     = cloned.getInterpolatedState();                for (int j = 0; j < referenceState.length; ++j) {                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);                }            }        }        public boolean requiresDenseOutput() {            return true;        }        public void reset() {        }    });    integ.integrate(pb,            pb.getInitialTime(), pb.getInitialState(),            pb.getFinalTime(), new double[pb.getDimension()]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertTrue;import java.util.Random;import java.io.ByteArrayOutputStream;import java.io.ByteArrayInputStream;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.IOException;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.nonstiff.GillIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.junit.Test;public class GillStepInterpolatorTest {  @Test  public void testDerivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    GillIntegrator integ = new GillIntegrator(step);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    GillIntegrator integ = new GillIntegrator(step);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    assertTrue(bos.size () > 700000);    assertTrue(bos.size () < 701000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 0.003);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.junit.Test;public class ThreeEighthesStepInterpolatorTest {  @Test  public void derivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    assertTrue(bos.size () > 700000);    assertTrue(bos.size () < 701000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError > 0.005);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import junit.framework.*;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemAbstract;import org.apache.commons.math.ode.TestProblemFactory;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;public class ThreeEighthesIntegratorTest  extends TestCase {  public ThreeEighthesIntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      new ThreeEighthesIntegrator(0.01).integrate(pb,                                                  0.0, new double[pb.getDimension()+10],                                                  1.0, new double[pb.getDimension()+10]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testDecreasingSteps()    throws DerivativeException, IntegratorException  {    TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousError = Double.NaN;      for (int i = 4; i < 10; ++i) {        TestProblemAbstract pb = problems[k].copy();        double step = (pb.getFinalTime() - pb.getInitialTime())          * FastMath.pow(2.0, -i);        FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        EventHandler[] functions = pb.getEventsHandlers();        for (int l = 0; l < functions.length; ++l) {          integ.addEventHandler(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);        }        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                          pb.getFinalTime(), new double[pb.getDimension()]);        if (functions.length == 0) {            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);        }        double error = handler.getMaximalValueError();        if (i > 4) {          assertTrue(error < FastMath.abs(previousError));        }        previousError = error;        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      }    }  } public void testSmallStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() < 2.0e-13);    assertTrue(handler.getMaximalValueError() < 4.0e-12);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals("3/8", integ.getName());  }  public void testBigStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() > 0.0004);    assertTrue(handler.getMaximalValueError() > 0.005);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);  }  public void testBackward()      throws DerivativeException, IntegratorException {      TestProblem5 pb = new TestProblem5();      double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertTrue(handler.getLastError() < 5.0e-10);      assertTrue(handler.getMaximalValueError() < 7.0e-10);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      assertEquals("3/8", integ.getName());  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);    integ.addStepHandler(new KeplerHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);  }  private static class KeplerHandler implements StepHandler {    public KeplerHandler(TestProblem3 pb) {      this.pb = pb;      maxError = 0;    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) throws DerivativeException {      double[] interpolatedY = interpolator.getInterpolatedState();      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }      if (isLast) {        // even with more than 1000 evaluations per period,        // RK4 is not able to integrate such an eccentric        // orbit with a good accuracy        assertTrue(maxError > 0.005);      }    }    private TestProblem3 pb;    private double maxError = 0;  }  public void testStepSize()    throws DerivativeException, IntegratorException {      final double step = 1.23456;      FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);      integ.addStepHandler(new StepHandler() {          public void handleStep(StepInterpolator interpolator, boolean isLast) {              if (! isLast) {                  assertEquals(step,                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),                               1.0e-12);              }          }          public boolean requiresDenseOutput() {              return false;          }          public void reset() {          }      });      integ.integrate(new FirstOrderDifferentialEquations() {          public void computeDerivatives(double t, double[] y, double[] dot) {              dot[0] = 1.0;          }          public int getDimension() {              return 1;          }      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Test;public class DormandPrince853StepInterpolatorTest {  @Test  public void derivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3(0.1);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                      scalAbsoluteTolerance,                                                                      scalRelativeTolerance);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                      scalAbsoluteTolerance,                                                                      scalRelativeTolerance);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    assertTrue(bos.size () > 86000);    assertTrue(bos.size () < 87000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 2.4e-10);  }  @Test  public void checklone()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,                                                                      scalAbsoluteTolerance,                                                                      scalRelativeTolerance);    integ.addStepHandler(new StepHandler() {        public void handleStep(StepInterpolator interpolator, boolean isLast)        throws DerivativeException {            StepInterpolator cloned = interpolator.copy();            double tA = cloned.getPreviousTime();            double tB = cloned.getCurrentTime();            double halfStep = FastMath.abs(tB - tA) / 2;            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);            for (int i = 0; i < 10; ++i) {                double t = (i * tB + (9 - i) * tA) / 9;                interpolator.setInterpolatedTime(t);                assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));                cloned.setInterpolatedTime(t);                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);                double[] referenceState = interpolator.getInterpolatedState();                double[] cloneState     = cloned.getInterpolatedState();                for (int j = 0; j < referenceState.length; ++j) {                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);                }            }        }        public boolean requiresDenseOutput() {            return true;        }        public void reset() {        }    });    integ.integrate(pb,            pb.getInitialTime(), pb.getInitialState(),            pb.getFinalTime(), new double[pb.getDimension()]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import junit.framework.*;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemAbstract;import org.apache.commons.math.ode.TestProblemFactory;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.nonstiff.EulerIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;public class EulerIntegratorTest  extends TestCase {  public EulerIntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      new EulerIntegrator(0.01).integrate(pb,                                          0.0, new double[pb.getDimension()+10],                                          1.0, new double[pb.getDimension()+10]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testDecreasingSteps()    throws DerivativeException, IntegratorException {    TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousError = Double.NaN;      for (int i = 4; i < 10; ++i) {        TestProblemAbstract pb  = problems[k].copy();        double step = (pb.getFinalTime() - pb.getInitialTime())          * FastMath.pow(2.0, -i);        FirstOrderIntegrator integ = new EulerIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        EventHandler[] functions = pb.getEventsHandlers();        for (int l = 0; l < functions.length; ++l) {          integ.addEventHandler(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);        }        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                          pb.getFinalTime(), new double[pb.getDimension()]);        if (functions.length == 0) {            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);        }        double error = handler.getMaximalValueError();        if (i > 4) {          assertTrue(error < FastMath.abs(previousError));        }        previousError = error;        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      }    }  }  public void testSmallStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb  = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new EulerIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);   assertTrue(handler.getLastError() < 2.0e-4);   assertTrue(handler.getMaximalValueError() < 1.0e-3);   assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);   assertEquals("Euler", integ.getName());  }  public void testBigStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb  = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new EulerIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() > 0.01);    assertTrue(handler.getMaximalValueError() > 0.2);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);  }  public void testBackward()      throws DerivativeException, IntegratorException {      TestProblem5 pb = new TestProblem5();      double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new EulerIntegrator(step);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertTrue(handler.getLastError() < 0.45);      assertTrue(handler.getMaximalValueError() < 0.45);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      assertEquals("Euler", integ.getName());  }  public void testStepSize()    throws DerivativeException, IntegratorException {      final double step = 1.23456;      FirstOrderIntegrator integ = new EulerIntegrator(step);      integ.addStepHandler(new StepHandler() {        public void handleStep(StepInterpolator interpolator, boolean isLast) {            if (! isLast) {                assertEquals(step,                             interpolator.getCurrentTime() - interpolator.getPreviousTime(),                             1.0e-12);            }        }        public boolean requiresDenseOutput() {            return false;        }        public void reset() {        }      });      integ.integrate(new FirstOrderDifferentialEquations() {                          private static final long serialVersionUID = 0L;                          public void computeDerivatives(double t, double[] y, double[] dot) {                              dot[0] = 1.0;                          }                          public int getDimension() {                              return 1;                          }                      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import junit.framework.*;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblemAbstract;import org.apache.commons.math.ode.TestProblemFactory;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.ode.nonstiff.GillIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;public class GillIntegratorTest  extends TestCase {  public GillIntegratorTest(String name) {    super(name);  }  public void testDimensionCheck() {    try  {      TestProblem1 pb = new TestProblem1();      new GillIntegrator(0.01).integrate(pb,                                         0.0, new double[pb.getDimension()+10],                                         1.0, new double[pb.getDimension()+10]);        fail("an exception should have been thrown");    } catch(DerivativeException de) {      fail("wrong exception caught");    } catch(IntegratorException ie) {    }  }  public void testDecreasingSteps()    throws DerivativeException, IntegratorException  {    TestProblemAbstract[] problems = TestProblemFactory.getProblems();    for (int k = 0; k < problems.length; ++k) {      double previousError = Double.NaN;      for (int i = 5; i < 10; ++i) {        TestProblemAbstract pb = problems[k].copy();        double step = (pb.getFinalTime() - pb.getInitialTime())          * FastMath.pow(2.0, -i);        FirstOrderIntegrator integ = new GillIntegrator(step);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        EventHandler[] functions = pb.getEventsHandlers();        for (int l = 0; l < functions.length; ++l) {          integ.addEventHandler(functions[l],                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);        }        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                                          pb.getFinalTime(), new double[pb.getDimension()]);        if (functions.length == 0) {            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);        }        double error = handler.getMaximalValueError();        if (i > 5) {          assertTrue(error < FastMath.abs(previousError));        }        previousError = error;        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      }    }  }  public void testSmallStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;    FirstOrderIntegrator integ = new GillIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() < 2.0e-13);    assertTrue(handler.getMaximalValueError() < 4.0e-12);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);    assertEquals("Gill", integ.getName());  }  public void testBigStep()    throws DerivativeException, IntegratorException {    TestProblem1 pb = new TestProblem1();    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;    FirstOrderIntegrator integ = new GillIntegrator(step);    TestProblemHandler handler = new TestProblemHandler(pb, integ);    integ.addStepHandler(handler);    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(handler.getLastError() > 0.0004);    assertTrue(handler.getMaximalValueError() > 0.005);    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);  }  public void testBackward()      throws DerivativeException, IntegratorException {      TestProblem5 pb = new TestProblem5();      double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;      FirstOrderIntegrator integ = new GillIntegrator(step);      TestProblemHandler handler = new TestProblemHandler(pb, integ);      integ.addStepHandler(handler);      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                      pb.getFinalTime(), new double[pb.getDimension()]);      assertTrue(handler.getLastError() < 5.0e-10);      assertTrue(handler.getMaximalValueError() < 7.0e-10);      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);      assertEquals("Gill", integ.getName());  }  public void testKepler()    throws DerivativeException, IntegratorException {    final TestProblem3 pb  = new TestProblem3(0.9);    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;    FirstOrderIntegrator integ = new GillIntegrator(step);    integ.addStepHandler(new KeplerStepHandler(pb));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);  }  public void testUnstableDerivative()  throws DerivativeException, IntegratorException {    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);    FirstOrderIntegrator integ = new GillIntegrator(0.3);    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);    double[] y = { Double.NaN };    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);    assertEquals(8.0, y[0], 1.0e-12);  }  private static class KeplerStepHandler implements StepHandler {    public KeplerStepHandler(TestProblem3 pb) {      this.pb = pb;      reset();    }    public boolean requiresDenseOutput() {      return false;    }    public void reset() {      maxError = 0;    }    public void handleStep(StepInterpolator interpolator,                           boolean isLast) throws DerivativeException {      double[] interpolatedY = interpolator.getInterpolatedState();      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }      if (isLast) {        // even with more than 1000 evaluations per period,        // RK4 is not able to integrate such an eccentric        // orbit with a good accuracy        assertTrue(maxError > 0.001);      }    }    private double maxError;    private TestProblem3 pb;  }  public void testStepSize()    throws DerivativeException, IntegratorException {      final double step = 1.23456;      FirstOrderIntegrator integ = new GillIntegrator(step);      integ.addStepHandler(new StepHandler() {          public void handleStep(StepInterpolator interpolator, boolean isLast) {              if (! isLast) {                  assertEquals(step,                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),                               1.0e-12);              }          }          public boolean requiresDenseOutput() {              return false;          }          public void reset() {          }      });      integ.integrate(new FirstOrderDifferentialEquations() {          private static final long serialVersionUID = 0L;          public void computeDerivatives(double t, double[] y, double[] dot) {              dot[0] = 1.0;          }          public int getDimension() {              return 1;          }      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem5;import org.apache.commons.math.ode.TestProblem6;import org.apache.commons.math.ode.TestProblemHandler;import org.apache.commons.math.util.FastMath;import org.junit.Test;public class AdamsMoultonIntegratorTest {    @Test(expected=IntegratorException.class)    public void dimensionCheck() throws DerivativeException, IntegratorException {        TestProblem1 pb = new TestProblem1();        FirstOrderIntegrator integ =            new AdamsMoultonIntegrator(2, 0.0, 1.0, 1.0e-10, 1.0e-10);        integ.integrate(pb,                        0.0, new double[pb.getDimension()+10],                        1.0, new double[pb.getDimension()+10]);    }    @Test(expected=IntegratorException.class)    public void testMinStep() throws DerivativeException, IntegratorException {          TestProblem1 pb = new TestProblem1();          double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());          double maxStep = pb.getFinalTime() - pb.getInitialTime();          double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };          double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };          FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, minStep, maxStep,                                                                  vecAbsoluteTolerance,                                                                  vecRelativeTolerance);          TestProblemHandler handler = new TestProblemHandler(pb, integ);          integ.addStepHandler(handler);          integ.integrate(pb,                          pb.getInitialTime(), pb.getInitialState(),                          pb.getFinalTime(), new double[pb.getDimension()]);    }    @Test    public void testIncreasingTolerance()        throws DerivativeException, IntegratorException {        int previousCalls = Integer.MAX_VALUE;        for (int i = -12; i < -2; ++i) {            TestProblem1 pb = new TestProblem1();            double minStep = 0;            double maxStep = pb.getFinalTime() - pb.getInitialTime();            double scalAbsoluteTolerance = FastMath.pow(10.0, i);            double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;            FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, minStep, maxStep,                                                                    scalAbsoluteTolerance,                                                                    scalRelativeTolerance);            TestProblemHandler handler = new TestProblemHandler(pb, integ);            integ.addStepHandler(handler);            integ.integrate(pb,                            pb.getInitialTime(), pb.getInitialState(),                            pb.getFinalTime(), new double[pb.getDimension()]);            // the 0.15 and 3.0 factors are only valid for this test            // and has been obtained from trial and error            // there is no general relation between local and global errors            assertTrue(handler.getMaximalValueError() > (0.15 * scalAbsoluteTolerance));            assertTrue(handler.getMaximalValueError() < (3.0 * scalAbsoluteTolerance));            assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);            int calls = pb.getCalls();            assertEquals(integ.getEvaluations(), calls);            assertTrue(calls <= previousCalls);            previousCalls = calls;        }    }    @Test(expected = DerivativeException.class)    public void exceedMaxEvaluations() throws DerivativeException, IntegratorException {        TestProblem1 pb  = new TestProblem1();        double range = pb.getFinalTime() - pb.getInitialTime();        AdamsMoultonIntegrator integ = new AdamsMoultonIntegrator(2, 0, range, 1.0e-12, 1.0e-12);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        integ.setMaxEvaluations(650);        integ.integrate(pb,                        pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);    }    @Test    public void backward() throws DerivativeException, IntegratorException {        TestProblem5 pb = new TestProblem5();        double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());        FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, 0, range, 1.0e-12, 1.0e-12);        TestProblemHandler handler = new TestProblemHandler(pb, integ);        integ.addStepHandler(handler);        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        assertTrue(handler.getLastError() < 1.0e-9);        assertTrue(handler.getMaximalValueError() < 1.0e-9);        assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);        assertEquals("Adams-Moulton", integ.getName());    }    @Test    public void polynomial() throws DerivativeException, IntegratorException {        TestProblem6 pb = new TestProblem6();        double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());        for (int nSteps = 1; nSteps < 7; ++nSteps) {            AdamsMoultonIntegrator integ =                new AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);            TestProblemHandler handler = new TestProblemHandler(pb, integ);            integ.addStepHandler(handler);            integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),                            pb.getFinalTime(), new double[pb.getDimension()]);            if (nSteps < 4) {                assertTrue(integ.getEvaluations() > 140);            } else {                assertTrue(integ.getEvaluations() < 90);            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.nonstiff;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;import org.apache.commons.math.util.FastMath;import org.junit.Test;public class HighamHall54StepInterpolatorTest {  @Test  public void derivativesConsistency()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3(0.1);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);    StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.1e-10);  }  @Test  public void serialization()    throws DerivativeException, IntegratorException,           IOException, ClassNotFoundException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    for (StepHandler handler : integ.getStepHandlers()) {        oos.writeObject(handler);    }    assertTrue(bos.size () > 158000);    assertTrue(bos.size () < 159000);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 1.6e-10);  }  @Test  public void checkClone()  throws DerivativeException, IntegratorException {    TestProblem3 pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    double scalAbsoluteTolerance = 1.0e-8;    double scalRelativeTolerance = scalAbsoluteTolerance;    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,                                                              scalAbsoluteTolerance,                                                              scalRelativeTolerance);    integ.addStepHandler(new StepHandler() {        public void handleStep(StepInterpolator interpolator, boolean isLast)        throws DerivativeException {            StepInterpolator cloned = interpolator.copy();            double tA = cloned.getPreviousTime();            double tB = cloned.getCurrentTime();            double halfStep = FastMath.abs(tB - tA) / 2;            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);            for (int i = 0; i < 10; ++i) {                double t = (i * tB + (9 - i) * tA) / 9;                interpolator.setInterpolatedTime(t);                assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));                cloned.setInterpolatedTime(t);                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);                double[] referenceState = interpolator.getInterpolatedState();                double[] cloneState     = cloned.getInterpolatedState();                for (int j = 0; j < referenceState.length; ++j) {                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);                }            }        }        public boolean requiresDenseOutput() {            return true;        }        public void reset() {        }    });    integ.integrate(pb,            pb.getInitialTime(), pb.getInitialState(),            pb.getFinalTime(), new double[pb.getDimension()]);  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.sampling;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem1;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator;import org.junit.Test;public class NordsieckStepInterpolatorTest {    @Test    public void derivativesConsistency()    throws DerivativeException, IntegratorException {        TestProblem3 pb = new TestProblem3();        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(4, 0.0, 1.0, 1.0e-10, 1.0e-10);        StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 7e-10);    }    @Test    public void serialization()    throws DerivativeException, IntegratorException,    IOException, ClassNotFoundException {        TestProblem1 pb = new TestProblem1();        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(4, 0.0, 1.0, 1.0e-10, 1.0e-10);        integ.addStepHandler(new ContinuousOutputModel());        integ.integrate(pb,                        pb.getInitialTime(), pb.getInitialState(),                        pb.getFinalTime(), new double[pb.getDimension()]);        ByteArrayOutputStream bos = new ByteArrayOutputStream();        ObjectOutputStream    oos = new ObjectOutputStream(bos);        for (StepHandler handler : integ.getStepHandlers()) {            oos.writeObject(handler);        }        assertTrue(bos.size () >  20000);        assertTrue(bos.size () <  25000);        ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());        ObjectInputStream     ois = new ObjectInputStream(bis);        ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();        Random random = new Random(347588535632l);        double maxError = 0.0;        for (int i = 0; i < 1000; ++i) {            double r = random.nextDouble();            double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();            cm.setInterpolatedTime(time);            double[] interpolatedY = cm.getInterpolatedState ();            double[] theoreticalY  = pb.computeTheoreticalState(time);            double dx = interpolatedY[0] - theoreticalY[0];            double dy = interpolatedY[1] - theoreticalY[1];            double error = dx * dx + dy * dy;            if (error > maxError) {                maxError = error;            }        }        assertTrue(maxError < 1.0e-6);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.sampling;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.TestProblem3;import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;import org.apache.commons.math.ode.sampling.FixedStepHandler;import org.apache.commons.math.ode.sampling.StepNormalizer;import org.apache.commons.math.util.FastMath;import junit.framework.*;public class StepNormalizerTest  extends TestCase {  public StepNormalizerTest(String name) {    super(name);    pb    = null;    integ = null;  }  public void testBoundaries()    throws DerivativeException, IntegratorException {    double range = pb.getFinalTime() - pb.getInitialTime();    setLastSeen(false);    integ.addStepHandler(new StepNormalizer(range / 10.0,                                       new FixedStepHandler() {                                        private static final long serialVersionUID = 1650337364641626444L;                                        private boolean firstCall = true;                                         public void handleStep(double t,                                                                double[] y,                                                                double[] yDot,                                                                boolean isLast) {                                           if (firstCall) {                                             checkValue(t, pb.getInitialTime());                                             firstCall = false;                                           }                                           if (isLast) {                                             setLastSeen(true);                                             checkValue(t, pb.getFinalTime());                                           }                                         }                                       }));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(lastSeen);  }  public void testBeforeEnd()    throws DerivativeException, IntegratorException {    final double range = pb.getFinalTime() - pb.getInitialTime();    setLastSeen(false);    integ.addStepHandler(new StepNormalizer(range / 10.5,                                       new FixedStepHandler() {                                        private static final long serialVersionUID = 2228457391561277298L;                                        public void handleStep(double t,                                                                double[] y,                                                                double[] yDot,                                                                boolean isLast) {                                           if (isLast) {                                             setLastSeen(true);                                             checkValue(t,                                                        pb.getFinalTime() - range / 21.0);                                           }                                         }                                       }));    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    assertTrue(lastSeen);  }  public void checkValue(double value, double reference) {    assertTrue(FastMath.abs(value - reference) < 1.0e-10);  }  public void setLastSeen(boolean lastSeen) {    this.lastSeen = lastSeen;  }  @Override  public void setUp() {    pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    integ = new DormandPrince54Integrator(minStep, maxStep, 10.e-8, 1.0e-8);    lastSeen = false;  }  @Override  public void tearDown() {    pb    = null;    integ = null;  }  TestProblem3 pb;  FirstOrderIntegrator integ;  boolean lastSeen;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode.sampling;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.ByteArrayOutputStream;import java.io.ByteArrayInputStream;import java.io.ObjectOutputStream;import java.io.ObjectInputStream;import java.io.IOException;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;import org.apache.commons.math.ode.sampling.DummyStepInterpolator;import org.apache.commons.math.util.FastMath;import org.junit.Test;public class DummyStepInterpolatorTest {  @Test  public void testNoReset() throws DerivativeException {    double[]   y    =   { 0.0, 1.0, -2.0 };    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    double[] result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {      assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);    }  }  @Test  public void testFixedState()    throws DerivativeException {    double[]   y    =   { 1.0, 3.0, -4.0 };    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    interpolator.setInterpolatedTime(0.1);    double[] result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {        assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);    }    interpolator.setInterpolatedTime(0.5);    result = interpolator.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {        assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);    }  }  @Test  public void testSerialization()  throws DerivativeException, IOException, ClassNotFoundException {    double[]   y    =   { 0.0, 1.0, -2.0 };    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    oos.writeObject(interpolator);    assertTrue(bos.size () > 150);    assertTrue(bos.size () < 250);    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());    ObjectInputStream     ois = new ObjectInputStream(bis);    DummyStepInterpolator dsi = (DummyStepInterpolator) ois.readObject();    dsi.setInterpolatedTime(0.5);    double[] result = dsi.getInterpolatedState();    for (int i = 0; i < result.length; ++i) {        assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);    }  }  @Test  public void testImpossibleSerialization()  throws IOException {    double[] y = { 0.0, 1.0, -2.0 };    AbstractStepInterpolator interpolator = new BadStepInterpolator(y, true);    interpolator.storeTime(0);    interpolator.shift();    interpolator.storeTime(1);    ByteArrayOutputStream bos = new ByteArrayOutputStream();    ObjectOutputStream    oos = new ObjectOutputStream(bos);    try {        oos.writeObject(interpolator);        fail("an exception should have been thrown");    } catch (IOException ioe) {        // expected behavior        assertEquals(0, ioe.getMessage().length());    } catch (Exception e) {        fail("wrong exception caught");    }  }  private static class BadStepInterpolator extends DummyStepInterpolator {      @SuppressWarnings("unused")      public BadStepInterpolator() {      }      public BadStepInterpolator(double[] y, boolean forward) {          super(y, new double[y.length], forward);      }      @Override      protected void doFinalize()      throws DerivativeException {          throw new DerivativeException(null);      }  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import org.apache.commons.math.util.FastMath;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    y' = -y * </pre> * the solution of this equation is a simple exponential function : * <pre> *   y (t) = y (t0) exp (t0-t) * </pre> * </p> */public class TestProblem1  extends TestProblemAbstract {  /** Serializable version identifier. */  private static final long serialVersionUID = 1977870815289373164L;  /** theoretical state */  private double[] y;  /**   * Simple constructor.   */  public TestProblem1() {    super();    double[] y0 = { 1.0, 0.1 };    setInitialConditions(0.0, y0);    setFinalConditions(4.0);    double[] errorScale = { 1.0, 1.0 };    setErrorScale(errorScale);    y = new double[y0.length];  }  /**   * Copy constructor.   * @param problem problem to copy   */  public TestProblem1(TestProblem1 problem) {    super(problem);    y = problem.y.clone();  }  /** {@inheritDoc} */  @Overridepublic TestProblem1 copy() {    return new TestProblem1(this);  }  @Override  public void doComputeDerivatives(double t, double[] y, double[] yDot) {    // compute the derivatives    for (int i = 0; i < n; ++i)      yDot[i] = -y[i];  }  @Override  public double[] computeTheoreticalState(double t) {    double c = FastMath.exp (t0 - t);    for (int i = 0; i < n; ++i) {      y[i] = c * y0[i];    }    return y;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.ODEIntegrator;import org.apache.commons.math.ode.sampling.StepHandler;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;/** * This class is used to handle steps for the test problems * integrated during the junit tests for the ODE integrators. */public class TestProblemHandler  implements StepHandler {  /** Associated problem. */  private TestProblemAbstract problem;  /** Maximal errors encountered during the integration. */  private double maxValueError;  private double maxTimeError;  /** Error at the end of the integration. */  private double lastError;  /** Time at the end of integration. */  private double lastTime;  /** ODE solver used. */  private ODEIntegrator integrator;  /** Expected start for step. */  private double expectedStepStart;  /**   * Simple constructor.   * @param problem problem for which steps should be handled   * @param integrator ODE solver used   */  public TestProblemHandler(TestProblemAbstract problem, ODEIntegrator integrator) {    this.problem = problem;    this.integrator = integrator;    reset();  }  public boolean requiresDenseOutput() {    return true;  }  public void reset() {    maxValueError = 0;    maxTimeError  = 0;    lastError     = 0;    expectedStepStart = Double.NaN;  }  public void handleStep(StepInterpolator interpolator,                         boolean isLast)    throws DerivativeException {    double start = integrator.getCurrentStepStart();    if (FastMath.abs((start - problem.getInitialTime()) / integrator.getCurrentSignedStepsize()) > 0.001) {        // multistep integrators do not handle the first steps themselves        // so we have to make sure the integrator we look at has really started its work        if (!Double.isNaN(expectedStepStart)) {            maxTimeError = FastMath.max(maxTimeError, FastMath.abs(start - expectedStepStart));        }        expectedStepStart = start + integrator.getCurrentSignedStepsize();    }    double pT = interpolator.getPreviousTime();    double cT = interpolator.getCurrentTime();    double[] errorScale = problem.getErrorScale();    // store the error at the last step    if (isLast) {      double[] interpolatedY = interpolator.getInterpolatedState();      double[] theoreticalY  = problem.computeTheoreticalState(cT);      for (int i = 0; i < interpolatedY.length; ++i) {        double error = FastMath.abs(interpolatedY[i] - theoreticalY[i]);        lastError = FastMath.max(error, lastError);      }      lastTime = cT;    }    // walk through the step    for (int k = 0; k <= 20; ++k) {      double time = pT + (k * (cT - pT)) / 20;      interpolator.setInterpolatedTime(time);      double[] interpolatedY = interpolator.getInterpolatedState();      double[] theoreticalY  = problem.computeTheoreticalState(interpolator.getInterpolatedTime());      // update the errors      for (int i = 0; i < interpolatedY.length; ++i) {        double error = errorScale[i] * FastMath.abs(interpolatedY[i] - theoreticalY[i]);        maxValueError = FastMath.max(error, maxValueError);      }    }  }  /**   * Get the maximal value error encountered during integration.   * @return maximal value error   */  public double getMaximalValueError() {    return maxValueError;  }  /**   * Get the maximal time error encountered during integration.   * @return maximal time error   */  public double getMaximalTimeError() {    return maxTimeError;  }  /**   * Get the error at the end of the integration.   * @return error at the end of the integration   */  public double getLastError() {    return lastError;  }  /**   * Get the time at the end of the integration.   * @return time at the end of the integration.   */  public double getLastTime() {    return lastTime;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;/** * This class is used in the junit tests for the ODE integrators. * <p>This is the same as problem 1 except integration is done * backward in time</p> */public class TestProblem5  extends TestProblem1 {  /** Serializable version identifier. */  private static final long serialVersionUID = 7579233102411804237L;  /**   * Simple constructor.   */  public TestProblem5() {    super();    setFinalConditions(2 * t0 - t1);  }  /** {@inheritDoc} */  @Override  public TestProblem5 copy() {    return new TestProblem5();  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import org.apache.commons.math.ode.FirstOrderDifferentialEquations;import org.apache.commons.math.ode.events.EventHandler;/** * This class is used as the base class of the problems that are * integrated during the junit tests for the ODE integrators. */public abstract class TestProblemAbstract  implements FirstOrderDifferentialEquations {  /** Serializable version identifier. */  private static final long serialVersionUID = -8521928974502839379L;  /** Dimension of the problem. */  protected int n;  /** Number of functions calls. */  protected int calls;  /** Initial time */  protected double t0;  /** Initial state */  protected double[] y0;  /** Final time */  protected double t1;  /** Error scale */  protected double[] errorScale;  /**   * Simple constructor.   */  protected TestProblemAbstract() {    n          = 0;    calls      = 0;    t0         = 0;    y0         = null;    t1         = 0;    errorScale = null;  }  /**   * Copy constructor.   * @param problem problem to copy   */  protected TestProblemAbstract(TestProblemAbstract problem) {    n     = problem.n;    calls = problem.calls;    t0    = problem.t0;    if (problem.y0 == null) {      y0 = null;    } else {      y0 = problem.y0.clone();    }    if (problem.errorScale == null) {      errorScale = null;    } else {      errorScale = problem.errorScale.clone();    }    t1 = problem.t1;  }  /**   * Copy operation.   * @return a copy of the instance   */  public abstract TestProblemAbstract copy();  /**   * Set the initial conditions   * @param t0 initial time   * @param y0 initial state vector   */  protected void setInitialConditions(double t0, double[] y0) {    calls     = 0;    n         = y0.length;    this.t0   = t0;    this.y0   = y0.clone();   }  /**   * Set the final conditions.   * @param t1 final time   */  protected void setFinalConditions(double t1) {    this.t1 = t1;  }  /**   * Set the error scale   * @param errorScale error scale   */  protected void setErrorScale(double[] errorScale) {    this.errorScale = errorScale.clone();  }  public int getDimension() {    return n;  }  /**   * Get the initial time.   * @return initial time   */  public double getInitialTime() {    return t0;  }  /**   * Get the initial state vector.   * @return initial state vector   */  public double[] getInitialState() {    return y0;  }  /**   * Get the final time.   * @return final time   */  public double getFinalTime() {    return t1;  }  /**   * Get the error scale.   * @return error scale   */  public double[] getErrorScale() {    return errorScale;  }  /**   * Get the events handlers.   * @return events handlers   */  public EventHandler[] getEventsHandlers() {    return new EventHandler[0];  }  /**   * Get the number of calls.   * @return nuber of calls   */  public int getCalls() {    return calls;  }  public void computeDerivatives(double t, double[] y, double[] yDot) {    ++calls;    doComputeDerivatives(t, y, yDot);  }  abstract public void doComputeDerivatives(double t, double[] y, double[] yDot);  /**   * Compute the theoretical state at the specified time.   * @param t time at which the state is required   * @return state vector at time t   */  abstract public double[] computeTheoreticalState(double t);}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import junit.framework.*;import java.util.Random;import org.apache.commons.math.ode.ContinuousOutputModel;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderIntegrator;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;import org.apache.commons.math.ode.sampling.DummyStepInterpolator;import org.apache.commons.math.ode.sampling.StepInterpolator;import org.apache.commons.math.util.FastMath;public class ContinuousOutputModelTest  extends TestCase {  public ContinuousOutputModelTest(String name) {    super(name);    pb    = null;    integ = null;  }  public void testBoundaries()    throws DerivativeException, IntegratorException {    integ.addStepHandler(new ContinuousOutputModel());    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandlers().iterator().next();    cm.setInterpolatedTime(2.0 * pb.getInitialTime() - pb.getFinalTime());    cm.setInterpolatedTime(2.0 * pb.getFinalTime() - pb.getInitialTime());    cm.setInterpolatedTime(0.5 * (pb.getFinalTime() + pb.getInitialTime()));  }  public void testRandomAccess()    throws DerivativeException, IntegratorException {    ContinuousOutputModel cm = new ContinuousOutputModel();    integ.addStepHandler(cm);    integ.integrate(pb,                    pb.getInitialTime(), pb.getInitialState(),                    pb.getFinalTime(), new double[pb.getDimension()]);    Random random = new Random(347588535632l);    double maxError = 0.0;    for (int i = 0; i < 1000; ++i) {      double r = random.nextDouble();      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();      cm.setInterpolatedTime(time);      double[] interpolatedY = cm.getInterpolatedState ();      double[] theoreticalY  = pb.computeTheoreticalState(time);      double dx = interpolatedY[0] - theoreticalY[0];      double dy = interpolatedY[1] - theoreticalY[1];      double error = dx * dx + dy * dy;      if (error > maxError) {        maxError = error;      }    }    assertTrue(maxError < 1.0e-9);  }  public void testModelsMerging()    throws DerivativeException, IntegratorException {      // theoretical solution: y[0] = cos(t), y[1] = sin(t)      FirstOrderDifferentialEquations problem =          new FirstOrderDifferentialEquations() {              private static final long serialVersionUID = 2472449657345878299L;              public void computeDerivatives(double t, double[] y, double[] dot)                  throws DerivativeException {                  dot[0] = -y[1];                  dot[1] =  y[0];              }              public int getDimension() {                  return 2;              }          };      // integrate backward from &pi; to 0;      ContinuousOutputModel cm1 = new ContinuousOutputModel();      FirstOrderIntegrator integ1 =          new DormandPrince853Integrator(0, 1.0, 1.0e-8, 1.0e-8);      integ1.addStepHandler(cm1);      integ1.integrate(problem, FastMath.PI, new double[] { -1.0, 0.0 },                       0, new double[2]);      // integrate backward from 2&pi; to &pi;      ContinuousOutputModel cm2 = new ContinuousOutputModel();      FirstOrderIntegrator integ2 =          new DormandPrince853Integrator(0, 0.1, 1.0e-12, 1.0e-12);      integ2.addStepHandler(cm2);      integ2.integrate(problem, 2.0 * FastMath.PI, new double[] { 1.0, 0.0 },                       FastMath.PI, new double[2]);      // merge the two half circles      ContinuousOutputModel cm = new ContinuousOutputModel();      cm.append(cm2);      cm.append(new ContinuousOutputModel());      cm.append(cm1);      // check circle      assertEquals(2.0 * FastMath.PI, cm.getInitialTime(), 1.0e-12);      assertEquals(0, cm.getFinalTime(), 1.0e-12);      assertEquals(cm.getFinalTime(), cm.getInterpolatedTime(), 1.0e-12);      for (double t = 0; t < 2.0 * FastMath.PI; t += 0.1) {          cm.setInterpolatedTime(t);          double[] y = cm.getInterpolatedState();          assertEquals(FastMath.cos(t), y[0], 1.0e-7);          assertEquals(FastMath.sin(t), y[1], 1.0e-7);      }  }  public void testErrorConditions()    throws DerivativeException {      ContinuousOutputModel cm = new ContinuousOutputModel();      cm.handleStep(buildInterpolator(0, new double[] { 0.0, 1.0, -2.0 }, 1), true);      // dimension mismatch      assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0 }, 2.0));      // hole between time ranges      assertTrue(checkAppendError(cm, 10.0, new double[] { 0.0, 1.0, -2.0 }, 20.0));      // propagation direction mismatch      assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 0.0));      // no errors      assertFalse(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 2.0));  }  private boolean checkAppendError(ContinuousOutputModel cm,                                   double t0, double[] y0, double t1)  throws DerivativeException {      try {          ContinuousOutputModel otherCm = new ContinuousOutputModel();          otherCm.handleStep(buildInterpolator(t0, y0, t1), true);          cm.append(otherCm);      } catch(IllegalArgumentException iae) {          //expected behavior          return true;      }      return false;  }  private StepInterpolator buildInterpolator(double t0, double[] y0, double t1) {      DummyStepInterpolator interpolator  = new DummyStepInterpolator(y0, new double[y0.length], t1 >= t0);      interpolator.storeTime(t0);      interpolator.shift();      interpolator.storeTime(t1);      return interpolator;  }  public void checkValue(double value, double reference) {    assertTrue(FastMath.abs(value - reference) < 1.0e-10);  }  @Override  public void setUp() {    pb = new TestProblem3(0.9);    double minStep = 0;    double maxStep = pb.getFinalTime() - pb.getInitialTime();    integ = new DormandPrince54Integrator(minStep, maxStep, 1.0e-8, 1.0e-8);  }  @Override  public void tearDown() {    pb    = null;    integ = null;  }  TestProblem3 pb;  FirstOrderIntegrator integ;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import org.apache.commons.math.util.FastMath;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    y' = t^3 - t y * </pre> * with the initial condition y (0) = 0. The solution of this equation * is the following function : * <pre> *   y (t) = t^2 + 2 (exp (- t^2 / 2) - 1) * </pre> * </p> */public class TestProblem2  extends TestProblemAbstract {  /** Serializable version identifier. */  private static final long serialVersionUID = 8330741783213512366L;  /** theoretical state */  private double[] y;  /**   * Simple constructor.   */  public TestProblem2() {    super();    double[] y0 = { 0.0 };    setInitialConditions(0.0, y0);    setFinalConditions(1.0);    double[] errorScale = { 1.0 };    setErrorScale(errorScale);    y = new double[y0.length];  }  /**   * Copy constructor.   * @param problem problem to copy   */  public TestProblem2(TestProblem2 problem) {    super(problem);    y = problem.y.clone();  }  /** {@inheritDoc} */  @Overridepublic TestProblem2 copy() {    return new TestProblem2(this);  }  @Override  public void doComputeDerivatives(double t, double[] y, double[] yDot) {    // compute the derivatives    for (int i = 0; i < n; ++i)      yDot[i] = t * (t * t - y[i]);  }  @Override  public double[] computeTheoreticalState(double t) {    double t2 = t * t;    double c = t2 + 2 * (FastMath.exp (-0.5 * t2) - 1);    for (int i = 0; i < n; ++i) {      y[i] = c;    }    return y;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    y' = 3x^5 - y * </pre> * when the initial condition is y(0) = -360, the solution of this * equation degenerates to a simple quintic polynomial function : * <pre> *   y (t) = 3x^5 - 15x^4 + 60x^3 - 180x^2 + 360x - 360 * </pre> * </p> */public class TestProblem6  extends TestProblemAbstract {    /** Serializable version identifier. */    private static final long serialVersionUID = 1353409119804352378L;    /** theoretical state */    private double[] y;    /**     * Simple constructor.     */    public TestProblem6() {        super();        double[] y0 = { -360.0 };        setInitialConditions(0.0, y0);        setFinalConditions(1.0);        double[] errorScale = { 1.0 };        setErrorScale(errorScale);        y = new double[y0.length];    }    /**     * Copy constructor.     * @param problem problem to copy     */    public TestProblem6(TestProblem6 problem) {        super(problem);        y = problem.y.clone();    }    /** {@inheritDoc} */    @Override    public TestProblem6 copy() {      return new TestProblem6(this);    }    @Override    public void doComputeDerivatives(double t, double[] y, double[] yDot) {        // compute the derivatives        double t2 = t  * t;        double t4 = t2 * t2;        double t5 = t4 * t;        for (int i = 0; i < n; ++i) {            yDot[i] = 3 * t5 - y[i];        }    }    @Override    public double[] computeTheoreticalState(double t) {        for (int i = 0; i < n; ++i) {            y[i] = ((((3 * t - 15) * t + 60) * t - 180) * t + 360) * t - 360;        }        return y;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import org.apache.commons.math.ode.DerivativeException;import org.apache.commons.math.ode.FirstOrderConverter;import org.apache.commons.math.ode.IntegratorException;import org.apache.commons.math.ode.SecondOrderDifferentialEquations;import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator;import org.apache.commons.math.util.FastMath;import junit.framework.*;public class FirstOrderConverterTest  extends TestCase {  public FirstOrderConverterTest(String name) {    super(name);  }  public void testDoubleDimension() {    for (int i = 1; i < 10; ++i) {      SecondOrderDifferentialEquations eqn2 = new Equations(i, 0.2);      FirstOrderConverter eqn1 = new FirstOrderConverter(eqn2);      assertTrue(eqn1.getDimension() == (2 * eqn2.getDimension()));    }  }  public void testDecreasingSteps()    throws DerivativeException, IntegratorException {    double previousError = Double.NaN;    for (int i = 0; i < 10; ++i) {      double step  = FastMath.pow(2.0, -(i + 1));      double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, step)                   - FastMath.sin(4.0);      if (i > 0) {        assertTrue(FastMath.abs(error) < FastMath.abs(previousError));      }      previousError = error;    }  }  public void testSmallStep()    throws DerivativeException, IntegratorException {    double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 1.0e-4)                   - FastMath.sin(4.0);    assertTrue(FastMath.abs(error) < 1.0e-10);  }  public void testBigStep()    throws DerivativeException, IntegratorException {    double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 0.5)                   - FastMath.sin(4.0);    assertTrue(FastMath.abs(error) > 0.1);  }  private static class Equations    implements SecondOrderDifferentialEquations {     private int n;      private double omega2;      public Equations(int n, double omega) {        this.n = n;        omega2 = omega * omega;      }      public int getDimension() {        return n;      }      public void computeSecondDerivatives(double t, double[] y, double[] yDot,                                           double[] yDDot) {        for (int i = 0; i < n; ++i) {          yDDot[i] = -omega2 * y[i];        }    }  }  private double integrateWithSpecifiedStep(double omega,                                            double t0, double t,                                            double step)  throws DerivativeException, IntegratorException {    double[] y0 = new double[2];    y0[0] = FastMath.sin(omega * t0);    y0[1] = omega * FastMath.cos(omega * t0);    ClassicalRungeKuttaIntegrator i = new ClassicalRungeKuttaIntegrator(step);    double[] y = new double[2];    i.integrate(new FirstOrderConverter(new Equations(1, omega)), t0, y0, t, y);    return y[0];  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import org.apache.commons.math.ode.events.EventHandler;import org.apache.commons.math.util.FastMath;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    x'' = -x * </pre> * And when x decreases down to 0, the state should be changed as follows : * <pre> *   x' -> -x' * </pre> * The theoretical solution of this problem is x = |sin(t+a)| * </p> */public class TestProblem4  extends TestProblemAbstract {  /** Serializable version identifier. */  private static final long serialVersionUID = -5910438521889015745L;  /** Time offset. */  private double a;  /** theoretical state */  private double[] y;  /** Simple constructor. */  public TestProblem4() {    super();    a = 1.2;    double[] y0 = { FastMath.sin(a), FastMath.cos(a) };    setInitialConditions(0.0, y0);    setFinalConditions(15);    double[] errorScale = { 1.0, 0.0 };    setErrorScale(errorScale);    y = new double[y0.length];  }  /**   * Copy constructor.   * @param problem problem to copy   */  public TestProblem4(TestProblem4 problem) {    super(problem);    a = problem.a;    y = problem.y.clone();  }  /** {@inheritDoc} */  @Overridepublic TestProblem4 copy() {    return new TestProblem4(this);  }  @Override  public EventHandler[] getEventsHandlers() {    return new EventHandler[] { new Bounce(), new Stop() };  }  @Override  public void doComputeDerivatives(double t, double[] y, double[] yDot) {    yDot[0] =  y[1];    yDot[1] = -y[0];  }  @Override  public double[] computeTheoreticalState(double t) {    double sin = FastMath.sin(t + a);    double cos = FastMath.cos(t + a);    y[0] = FastMath.abs(sin);    y[1] = (sin >= 0) ? cos : -cos;    return y;  }  private static class Bounce implements EventHandler {    private static final long serialVersionUID = 1356097180027801200L;    private int sign;    public Bounce() {      sign = +1;    }    public double g(double t, double[] y) {      return sign * y[0];    }    public int eventOccurred(double t, double[] y, boolean increasing) {      // this sign change is needed because the state will be reset soon      sign = -sign;      return EventHandler.RESET_STATE;    }    public void resetState(double t, double[] y) {      y[0] = -y[0];      y[1] = -y[1];    }  }  private static class Stop implements EventHandler {    private static final long serialVersionUID = 6975050568227951931L;    public Stop() {    }    public double g(double t, double[] y) {      return t - 12.0;    }    public int eventOccurred(double t, double[] y, boolean increasing) {      return EventHandler.STOP;    }    public void resetState(double t, double[] y) {    }  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;import org.apache.commons.math.util.FastMath;/** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> *    y1'' = -y1/r^3  y1 (0) = 1-e  y1' (0) = 0 *    y2'' = -y2/r^3  y2 (0) = 0    y2' (0) =sqrt((1+e)/(1-e)) *    r = sqrt (y1^2 + y2^2), e = 0.9 * </pre> * This is a two-body problem in the plane which can be solved by * Kepler's equation * <pre> *   y1 (t) = ... * </pre> * </p> */public class TestProblem3  extends TestProblemAbstract {  /** Serializable version identifier. */  private static final long serialVersionUID = 8567328542728919999L;  /** Eccentricity */  double e;  /** theoretical state */  private double[] y;  /**   * Simple constructor.   * @param e eccentricity   */  public TestProblem3(double e) {    super();    this.e = e;    double[] y0 = { 1 - e, 0, 0, FastMath.sqrt((1+e)/(1-e)) };    setInitialConditions(0.0, y0);    setFinalConditions(20.0);    double[] errorScale = { 1.0, 1.0, 1.0, 1.0 };    setErrorScale(errorScale);    y = new double[y0.length];  }  /**   * Simple constructor.   */  public TestProblem3() {    this(0.1);  }  /**   * Copy constructor.   * @param problem problem to copy   */  public TestProblem3(TestProblem3 problem) {    super(problem);    e = problem.e;    y = problem.y.clone();  }  /** {@inheritDoc} */  @Overridepublic TestProblem3 copy() {    return new TestProblem3(this);  }  @Override  public void doComputeDerivatives(double t, double[] y, double[] yDot) {    // current radius    double r2 = y[0] * y[0] + y[1] * y[1];    double invR3 = 1 / (r2 * FastMath.sqrt(r2));    // compute the derivatives    yDot[0] = y[2];    yDot[1] = y[3];    yDot[2] = -invR3  * y[0];    yDot[3] = -invR3  * y[1];  }  @Override  public double[] computeTheoreticalState(double t) {    // solve Kepler's equation    double E = t;    double d = 0;    double corr = 999.0;    for (int i = 0; (i < 50) && (FastMath.abs(corr) > 1.0e-12); ++i) {      double f2  = e * FastMath.sin(E);      double f0  = d - f2;      double f1  = 1 - e * FastMath.cos(E);      double f12 = f1 + f1;      corr  = f0 * f12 / (f1 * f12 - f0 * f2);      d -= corr;      E = t + d;    }    double cosE = FastMath.cos(E);    double sinE = FastMath.sin(E);    y[0] = cosE - e;    y[1] = FastMath.sqrt(1 - e * e) * sinE;    y[2] = -sinE / (1 - e * cosE);    y[3] = FastMath.sqrt(1 - e * e) * cosE / (1 - e * cosE);    return y;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.ode;/** * This class is used in the junit tests for the ODE integrators. */public class TestProblemFactory {  /** Problems pool. */  private static final TestProblemAbstract[] pool = {    new TestProblem1(),    new TestProblem2(),    new TestProblem3(),    new TestProblem4(),    new TestProblem5(),    new TestProblem6()  };  /**   * Private constructor.   * This is a utility class, so there are no instance at all.   */  private TestProblemFactory() {  }  /**   * Get the problems.   * @return array of problems to solve   */  public static TestProblemAbstract[] getProblems() {    return pool;  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import org.junit.Assert;import org.apache.commons.math.stat.descriptive.SummaryStatistics;import org.apache.commons.math.util.FastMath;import org.junit.Test;public class Well1024aTest {    @Test    public void testGaussian() {        Well1024a mt = new Well1024a(42853252100l);        SummaryStatistics sample = new SummaryStatistics();        for (int i = 0; i < 10000; ++i) {            sample.addValue(mt.nextGaussian());        }        Assert.assertEquals(0.0, sample.getMean(), 0.004);        Assert.assertEquals(1.0, sample.getStandardDeviation(), 0.003);    }    @Test    public void testDouble() {        Well1024a mt = new Well1024a(195357343514l);        SummaryStatistics sample = new SummaryStatistics();        for (int i = 0; i < 10000; ++i) {            sample.addValue(mt.nextDouble());        }        Assert.assertEquals(0.5, sample.getMean(), 0.0006);        Assert.assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),                     sample.getStandardDeviation(),                     0.002);    }    @Test    public void testFloat() {        Well1024a mt = new Well1024a(4442733263l);        SummaryStatistics sample = new SummaryStatistics();        for (int i = 0; i < 10000; ++i) {            sample.addValue(mt.nextFloat());        }        Assert.assertEquals(0.5, sample.getMean(), 0.0001);        Assert.assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),                     sample.getStandardDeviation(),                     0.003);    }    @Test(expected=java.lang.IllegalArgumentException.class)    public void testNextIntNeg() {        new Well1024a(1).nextInt(-1);    }    @Test    public void testNextIntN() {        Well1024a mt = new Well1024a(0x12b8a7412bb25el);        for (int n = 1; n < 20; ++n) {            int[] count = new int[n];            for (int k = 0; k < 10000; ++k) {                int l = mt.nextInt(n);                ++count[l];                Assert.assertTrue(l >= 0);                Assert.assertTrue(l <  n);            }            for (int i = 0; i < n; ++i) {                Assert.assertTrue(n * count[i] >  8600);                Assert.assertTrue(n * count[i] < 11200);            }        }    }    @Test    public void testNextInt() {        Well1024a mt = new Well1024a(new int[] { 1, 2, 3, 4, 5 });        int walk = 0;        for (int k = 0; k < 10000; ++k) {           if (mt.nextInt() >= 0) {               ++walk;           } else {               --walk;           }        }        Assert.assertTrue(FastMath.abs(walk) < 70);    }    @Test    public void testNextLong() {        Well1024a mt = new Well1024a(12345);        int walk = 0;        for (int k = 0; k < 10000; ++k) {           if (mt.nextLong() >= 0) {               ++walk;           } else {               --walk;           }        }        Assert.assertTrue(FastMath.abs(walk) < 70);    }    @Test    public void testNexBoolean() {        Well1024a mt = new Well1024a(76342);        int walk = 0;        for (int k = 0; k < 10000; ++k) {           if (mt.nextBoolean()) {               ++walk;           } else {               --walk;           }        }        Assert.assertTrue(FastMath.abs(walk) < 180);    }    @Test    public void testNexBytes() {        Well1024a mt = new Well1024a(0);        int[] count = new int[256];        byte[] bytes = new byte[10];        for (int k = 0; k < 1000000; ++k) {           mt.nextBytes(bytes);           for (byte b : bytes) {               ++count[b + 128];           }        }        int min = Integer.MAX_VALUE;        int max = Integer.MIN_VALUE;        for (int c : count) {            min = FastMath.min(min, c);            max = FastMath.max(max, c);        }        int expected = (1000000 * bytes.length) / count.length;        Assert.assertTrue((expected - 600) < min);        Assert.assertTrue(max < (expected + 600));    }    @Test    public void testReferenceCode() {        Well1024a mt = new Well1024a(new int[] {            740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,          -1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000,           -595495729,  1047766204,  1875773301, -1637793284,  1379017098,   262792705,   191880010,  -251000180,          -1753047622,  -972355720,    90626881,  1644693418,  1503365577,   439653419,  1806361562,  1268823869       });        int[] refInt = {           -1478749726,  -1645579484,  -2075363835,  -2063444174,  -1834148336,  -1769045872,    -40711346,   1717441026,            2130656771,    783441285,    570433609,   1560023451,    653233971,   1368672434,    -72036215,   1071111800,             933776492,     26114960,     49888778,   1808107515,   1092989296,    754848337,   1336994364,  -1987450448,            -691190146,  -1803870839,   1110716866,   1173269113,   -391000050,   2014216908,    180756301,   -382891013,           -1908154585,   1580737629,   1080267957,   -125532248,   2094530239,   2132964485,   -438596348,   -760299445,            1058181869,   2050816800,  -1534429037,    -62552782,    824524142,   -818590371,  -1857695907,   -684762866,            -156556543,   -902759995,   -880795194,  -1387351132,  -1263017515,    448006597,    201038266,   1929826313,            -455367306,    672963027,   2000073013,  -1546842042,    446341090,   1001696686,   -779919012,   -347722602,           -1342821677,   1639571150,   -835315755,   1505585376,    367004975,  -2035864404,  -1786623553,   1249724913,             182435312,   1444514513,   1815333708,   1333772382,    299664001,   -284691169,   2034403374,   1423310887,           -1319051884,   1557286441,   -445198266,   -251809030,   1602786123,    944036382,  -1020529634,    258344235,             685254367,   1838964943,   -156674528,   -979736602,   -538312836,    234643178,    211152102,   -635498640,           -1036733933,  -1347589147,   -565609042,  -1358714165,    508618483,   -786364693,   2071450261,   1206956772,            -678931458,    167690617,    144698821,   1719720781,   1575869280,  -1343221123,  -1766469944,    284991647,            -717305514,    892653651,  -1368347075,   -615701972,   -730369849,   1360396003,  -1869287623,   1778269052,            -586061545,   -699517114,     61530249,  -1860611767,   -519660852,   1841085925,   1555610093,   -399979337,            -790345742,    422355947,   2007965433,   2044952550,  -1712164595,   -102915702,   -693865324,  -1894042487,           -1285020072,   -215883074,     95833252,   1625818040,  -1055951680,    513067085,   1825246558,   -553461652,           -1923361799,  -1869480206,    567232636,  -1751727150,  -1832301399,   -108136455,  -1312244126,     14006795,             850221366,   -382389732,  -1741556188,  -1317464467,   1948314870,    753994471,   1028235947,    342494132,           -1862256693,    723808794,   -234257642,   1609928369,   -802733456,   1315831915,   1436072885,   1224767136,            2144557791,  -1839965886,    224821018,  -1461697757,  -1080386760,   1638573498,  -1188173812,   -325181523,           -1750676219,  -1780415850,    698793362,   -908352052,    299746482,   -161660934,   1938166833,    800297005,              56640033,  -1214932666,  -1248124842,   1822796868,   1777615881,   -718517774,   1908159957,   1733053281,            1851844331,   1283519375,  -1771494956,   2060179999,   1666129209,   1919453531,   -498145770,    697567008,            1855487148,  -1587163491,    565216434,  -1477877933,   -925662919,   -806492585,  -1201439047,  -1424534232,            1788616523,     69414717,    655893636,  -1175978556,     24787512,   -861550001,    439525754,   -190433174,            -383811606,   -508589783,   1441608687,    608181366,   1539467064,    925903122,    697209654,   1878283393,           -1967567432,  -1659677763,   -249658183,    847096354,    397741956,   -125334541,  -1286840731,   1016461908,            -997968592,   1795331475,   1856856501,  -1716726445,   -582181331,   -887091847,    426964855,   -609219941,           -1456232632,   -483467616,   1069260754,    972242064,  -1406786247,   1954194029,     52627891,   1212755081,            2117436668,    281073392,    741537353,   -483063506,   1850906286,   -244876135,   -270818140,   1817568823        };        for (int i = 0; i < refInt.length; ++i) {            Assert.assertEquals(refInt[i], mt.nextInt());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import org.apache.commons.math.stat.descriptive.SummaryStatistics;import org.apache.commons.math.util.FastMath;import org.junit.Test;public class MersenneTwisterTest {    @Test    public void testGaussian() {        MersenneTwister mt = new MersenneTwister(42853252100l);        SummaryStatistics sample = new SummaryStatistics();        for (int i = 0; i < 1000; ++i) {            sample.addValue(mt.nextGaussian());        }        assertEquals(0.0, sample.getMean(), 0.005);        assertEquals(1.0, sample.getStandardDeviation(), 0.025);    }    @Test    public void testDouble() {        MersenneTwister mt = new MersenneTwister(195357343514l);        SummaryStatistics sample = new SummaryStatistics();        for (int i = 0; i < 1000; ++i) {            sample.addValue(mt.nextDouble());        }        assertEquals(0.5, sample.getMean(), 0.02);        assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),                     sample.getStandardDeviation(),                     0.002);    }    @Test    public void testFloat() {        MersenneTwister mt = new MersenneTwister(4442733263l);        SummaryStatistics sample = new SummaryStatistics();        for (int i = 0; i < 1000; ++i) {            sample.addValue(mt.nextFloat());        }        assertEquals(0.5, sample.getMean(), 0.01);        assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),                     sample.getStandardDeviation(),                     0.006);    }    @Test(expected=java.lang.IllegalArgumentException.class)    public void testNextIntNeg() {        new MersenneTwister(1).nextInt(-1);    }    @Test    public void testNextIntN() {        MersenneTwister mt = new MersenneTwister(0x12b8a7412bb25el);        for (int n = 1; n < 20; ++n) {            int[] count = new int[n];            for (int k = 0; k < 10000; ++k) {                int l = mt.nextInt(n);                ++count[l];                assertTrue(l >= 0);                assertTrue(l <  n);            }            for (int i = 0; i < n; ++i) {                assertTrue(n * count[i] >  8600);                assertTrue(n * count[i] < 11200);            }        }    }    @Test    public void testNextInt() {        MersenneTwister mt = new MersenneTwister(new int[] { 1, 2, 3, 4, 5 });        int walk = 0;        for (int k = 0; k < 10000; ++k) {           if (mt.nextInt() >= 0) {               ++walk;           } else {               --walk;           }        }        assertTrue(FastMath.abs(walk) < 120);    }    @Test    public void testNextLong() {        MersenneTwister mt = new MersenneTwister(12345);        int walk = 0;        for (int k = 0; k < 10000; ++k) {           if (mt.nextLong() >= 0) {               ++walk;           } else {               --walk;           }        }        assertTrue(FastMath.abs(walk) < 50);    }    @Test    public void testNexBoolean() {        MersenneTwister mt = new MersenneTwister(76342);        int walk = 0;        for (int k = 0; k < 10000; ++k) {           if (mt.nextBoolean()) {               ++walk;           } else {               --walk;           }        }        assertTrue(FastMath.abs(walk) < 250);    }    @Test    public void testNexBytes() {        MersenneTwister mt = new MersenneTwister(0);        int[] count = new int[256];        byte[] bytes = new byte[10];        for (int k = 0; k < 100000; ++k) {           mt.nextBytes(bytes);           for (byte b : bytes) {               ++count[b + 128];           }        }        int min = Integer.MAX_VALUE;        int max = Integer.MIN_VALUE;        for (int c : count) {            min = FastMath.min(min, c);            max = FastMath.max(max, c);        }        int expected = (100000 * bytes.length) / count.length;        assertTrue((expected - 200) < min);        assertTrue(max < (expected + 200));    }    @Test    public void testMakotoNishimura() {        MersenneTwister mt = new MersenneTwister(new int[] {0x123, 0x234, 0x345, 0x456});        long[] refInt = {            1067595299l,  955945823l,  477289528l, 4107218783l, 4228976476l, 3344332714l, 3355579695l,  227628506l,            810200273l, 2591290167l, 2560260675l, 3242736208l,  646746669l, 1479517882l, 4245472273l, 1143372638l,            3863670494l, 3221021970l, 1773610557l, 1138697238l, 1421897700l, 1269916527l, 2859934041l, 1764463362l,            3874892047l, 3965319921l,   72549643l, 2383988930l, 2600218693l, 3237492380l, 2792901476l,  725331109l,            605841842l,  271258942l,  715137098l, 3297999536l, 1322965544l, 4229579109l, 1395091102l, 3735697720l,            2101727825l, 3730287744l, 2950434330l, 1661921839l, 2895579582l, 2370511479l, 1004092106l, 2247096681l,            2111242379l, 3237345263l, 4082424759l,  219785033l, 2454039889l, 3709582971l,  835606218l, 2411949883l,            2735205030l,  756421180l, 2175209704l, 1873865952l, 2762534237l, 4161807854l, 3351099340l,  181129879l,            3269891896l,  776029799l, 2218161979l, 3001745796l, 1866825872l, 2133627728l,   34862734l, 1191934573l,            3102311354l, 2916517763l, 1012402762l, 2184831317l, 4257399449l, 2899497138l, 3818095062l, 3030756734l,            1282161629l,  420003642l, 2326421477l, 2741455717l, 1278020671l, 3744179621l,  271777016l, 2626330018l,            2560563991l, 3055977700l, 4233527566l, 1228397661l, 3595579322l, 1077915006l, 2395931898l, 1851927286l,            3013683506l, 1999971931l, 3006888962l, 1049781534l, 1488758959l, 3491776230l,  104418065l, 2448267297l,            3075614115l, 3872332600l,  891912190l, 3936547759l, 2269180963l, 2633455084l, 1047636807l, 2604612377l,            2709305729l, 1952216715l,  207593580l, 2849898034l,  670771757l, 2210471108l,  467711165l,  263046873l,            3569667915l, 1042291111l, 3863517079l, 1464270005l, 2758321352l, 3790799816l, 2301278724l, 3106281430l,            7974801l, 2792461636l,  555991332l,  621766759l, 1322453093l,  853629228l,  686962251l, 1455120532l,            957753161l, 1802033300l, 1021534190l, 3486047311l, 1902128914l, 3701138056l, 4176424663l, 1795608698l,            560858864l, 3737752754l, 3141170998l, 1553553385l, 3367807274l,  711546358l, 2475125503l,  262969859l,            251416325l, 2980076994l, 1806565895l,  969527843l, 3529327173l, 2736343040l, 2987196734l, 1649016367l,            2206175811l, 3048174801l, 3662503553l, 3138851612l, 2660143804l, 1663017612l, 1816683231l,  411916003l,            3887461314l, 2347044079l, 1015311755l, 1203592432l, 2170947766l, 2569420716l,  813872093l, 1105387678l,            1431142475l,  220570551l, 4243632715l, 4179591855l, 2607469131l, 3090613241l,  282341803l, 1734241730l,            1391822177l, 1001254810l,  827927915l, 1886687171l, 3935097347l, 2631788714l, 3905163266l,  110554195l,            2447955646l, 3717202975l, 3304793075l, 3739614479l, 3059127468l,  953919171l, 2590123714l, 1132511021l,            3795593679l, 2788030429l,  982155079l, 3472349556l,  859942552l, 2681007391l, 2299624053l,  647443547l,            233600422l,  608168955l, 3689327453l, 1849778220l, 1608438222l, 3968158357l, 2692977776l, 2851872572l,            246750393l, 3582818628l, 3329652309l, 4036366910l, 1012970930l,  950780808l, 3959768744l, 2538550045l,            191422718l, 2658142375l, 3276369011l, 2927737484l, 1234200027l, 1920815603l, 3536074689l, 1535612501l,            2184142071l, 3276955054l,  428488088l, 2378411984l, 4059769550l, 3913744741l, 2732139246l,   64369859l,            3755670074l,  842839565l, 2819894466l, 2414718973l, 1010060670l, 1839715346l, 2410311136l,  152774329l,            3485009480l, 4102101512l, 2852724304l,  879944024l, 1785007662l, 2748284463l, 1354768064l, 3267784736l,            2269127717l, 3001240761l, 3179796763l,  895723219l,  865924942l, 4291570937l,   89355264l, 1471026971l,            4114180745l, 3201939751l, 2867476999l, 2460866060l, 3603874571l, 2238880432l, 3308416168l, 2072246611l,            2755653839l, 3773737248l, 1709066580l, 4282731467l, 2746170170l, 2832568330l,  433439009l, 3175778732l,            26248366l, 2551382801l,  183214346l, 3893339516l, 1928168445l, 1337157619l, 3429096554l, 3275170900l,            1782047316l, 4264403756l, 1876594403l, 4289659572l, 3223834894l, 1728705513l, 4068244734l, 2867840287l,            1147798696l,  302879820l, 1730407747l, 1923824407l, 1180597908l, 1569786639l,  198796327l,  560793173l,            2107345620l, 2705990316l, 3448772106l, 3678374155l,  758635715l,  884524671l,  486356516l, 1774865603l,            3881226226l, 2635213607l, 1181121587l, 1508809820l, 3178988241l, 1594193633l, 1235154121l,  326117244l,            2304031425l,  937054774l, 2687415945l, 3192389340l, 2003740439l, 1823766188l, 2759543402l,   10067710l,            1533252662l, 4132494984l,   82378136l,  420615890l, 3467563163l,  541562091l, 3535949864l, 2277319197l,            3330822853l, 3215654174l, 4113831979l, 4204996991l, 2162248333l, 3255093522l, 2219088909l, 2978279037l,            255818579l, 2859348628l, 3097280311l, 2569721123l, 1861951120l, 2907080079l, 2719467166l,  998319094l,            2521935127l, 2404125338l,  259456032l, 2086860995l, 1839848496l, 1893547357l, 2527997525l, 1489393124l,            2860855349l,   76448234l, 2264934035l,  744914583l, 2586791259l, 1385380501l,   66529922l, 1819103258l,            1899300332l, 2098173828l, 1793831094l,  276463159l,  360132945l, 4178212058l,  595015228l,  177071838l,            2800080290l, 1573557746l, 1548998935l,  378454223l, 1460534296l, 1116274283l, 3112385063l, 3709761796l,            827999348l, 3580042847l, 1913901014l,  614021289l, 4278528023l, 1905177404l,   45407939l, 3298183234l,            1184848810l, 3644926330l, 3923635459l, 1627046213l, 3677876759l,  969772772l, 1160524753l, 1522441192l,            452369933l, 1527502551l,  832490847l, 1003299676l, 1071381111l, 2891255476l,  973747308l, 4086897108l,            1847554542l, 3895651598l, 2227820339l, 1621250941l, 2881344691l, 3583565821l, 3510404498l,  849362119l,            862871471l,  797858058l, 2867774932l, 2821282612l, 3272403146l, 3997979905l,  209178708l, 1805135652l,            6783381l, 2823361423l,  792580494l, 4263749770l,  776439581l, 3798193823l, 2853444094l, 2729507474l,            1071873341l, 1329010206l, 1289336450l, 3327680758l, 2011491779l,   80157208l,  922428856l, 1158943220l,            1667230961l, 2461022820l, 2608845159l,  387516115l, 3345351910l, 1495629111l, 4098154157l, 3156649613l,            3525698599l, 4134908037l,  446713264l, 2137537399l, 3617403512l,  813966752l, 1157943946l, 3734692965l,            1680301658l, 3180398473l, 3509854711l, 2228114612l, 1008102291l,  486805123l,  863791847l, 3189125290l,            1050308116l, 3777341526l, 4291726501l,  844061465l, 1347461791l, 2826481581l,  745465012l, 2055805750l,            4260209475l, 2386693097l, 2980646741l,  447229436l, 2077782664l, 1232942813l, 4023002732l, 1399011509l,            3140569849l, 2579909222l, 3794857471l,  900758066l, 2887199683l, 1720257997l, 3367494931l, 2668921229l,            955539029l, 3818726432l, 1105704962l, 3889207255l, 2277369307l, 2746484505l, 1761846513l, 2413916784l,            2685127085l, 4240257943l, 1166726899l, 4215215715l, 3082092067l, 3960461946l, 1663304043l, 2087473241l,            4162589986l, 2507310778l, 1579665506l,  767234210l,  970676017l,  492207530l, 1441679602l, 1314785090l,            3262202570l, 3417091742l, 1561989210l, 3011406780l, 1146609202l, 3262321040l, 1374872171l, 1634688712l,            1280458888l, 2230023982l,  419323804l, 3262899800l,   39783310l, 1641619040l, 1700368658l, 2207946628l,            2571300939l, 2424079766l,  780290914l, 2715195096l, 3390957695l,  163151474l, 2309534542l, 1860018424l,            555755123l,  280320104l, 1604831083l, 2713022383l, 1728987441l, 3639955502l,  623065489l, 3828630947l,            4275479050l, 3516347383l, 2343951195l, 2430677756l,  635534992l, 3868699749l,  808442435l, 3070644069l,            4282166003l, 2093181383l, 2023555632l, 1568662086l, 3422372620l, 4134522350l, 3016979543l, 3259320234l,            2888030729l, 3185253876l, 4258779643l, 1267304371l, 1022517473l,  815943045l,  929020012l, 2995251018l,            3371283296l, 3608029049l, 2018485115l,  122123397l, 2810669150l, 1411365618l, 1238391329l, 1186786476l,            3155969091l, 2242941310l, 1765554882l,  279121160l, 4279838515l, 1641578514l, 3796324015l,   13351065l,            103516986l, 1609694427l,  551411743l, 2493771609l, 1316337047l, 3932650856l, 4189700203l,  463397996l,            2937735066l, 1855616529l, 2626847990l,   55091862l, 3823351211l,  753448970l, 4045045500l, 1274127772l,            1124182256l,   92039808l, 2126345552l,  425973257l,  386287896l, 2589870191l, 1987762798l, 4084826973l,            2172456685l, 3366583455l, 3602966653l, 2378803535l, 2901764433l, 3716929006l, 3710159000l, 2653449155l,            3469742630l, 3096444476l, 3932564653l, 2595257433l,  318974657l, 3146202484l,  853571438l,  144400272l,            3768408841l,  782634401l, 2161109003l,  570039522l, 1886241521l,   14249488l, 2230804228l, 1604941699l,            3928713335l, 3921942509l, 2155806892l,  134366254l,  430507376l, 1924011722l,  276713377l,  196481886l,            3614810992l, 1610021185l, 1785757066l,  851346168l, 3761148643l, 2918835642l, 3364422385l, 3012284466l,            3735958851l, 2643153892l, 3778608231l, 1164289832l,  205853021l, 2876112231l, 3503398282l, 3078397001l,            3472037921l, 1748894853l, 2740861475l,  316056182l, 1660426908l,  168885906l,  956005527l, 3984354789l,            566521563l, 1001109523l, 1216710575l, 2952284757l, 3834433081l, 3842608301l, 2467352408l, 3974441264l,            3256601745l, 1409353924l, 1329904859l, 2307560293l, 3125217879l, 3622920184l, 3832785684l, 3882365951l,            2308537115l, 2659155028l, 1450441945l, 3532257603l, 3186324194l, 1225603425l, 1124246549l,  175808705l,            3009142319l, 2796710159l, 3651990107l,  160762750l, 1902254979l, 1698648476l, 1134980669l,  497144426l,            3302689335l, 4057485630l, 3603530763l, 4087252587l,  427812652l,  286876201l,  823134128l, 1627554964l,            3745564327l, 2589226092l, 4202024494l,   62878473l, 3275585894l, 3987124064l, 2791777159l, 1916869511l,            2585861905l, 1375038919l, 1403421920l,   60249114l, 3811870450l, 3021498009l, 2612993202l,  528933105l,            2757361321l, 3341402964l, 2621861700l,  273128190l, 4015252178l, 3094781002l, 1621621288l, 2337611177l,            1796718448l, 1258965619l, 4241913140l, 2138560392l, 3022190223l, 4174180924l,  450094611l, 3274724580l,            617150026l, 2704660665l, 1469700689l, 1341616587l,  356715071l, 1188789960l, 2278869135l, 1766569160l,            2795896635l,   57824704l, 2893496380l, 1235723989l, 1630694347l, 3927960522l,  428891364l, 1814070806l,            2287999787l, 4125941184l, 3968103889l, 3548724050l, 1025597707l, 1404281500l, 2002212197l,   92429143l,            2313943944l, 2403086080l, 3006180634l, 3561981764l, 1671860914l, 1768520622l, 1803542985l,  844848113l,            3006139921l, 1410888995l, 1157749833l, 2125704913l, 1789979528l, 1799263423l,  741157179l, 2405862309l,            767040434l, 2655241390l, 3663420179l, 2172009096l, 2511931187l, 1680542666l,  231857466l, 1154981000l,            157168255l, 1454112128l, 3505872099l, 1929775046l, 2309422350l, 2143329496l, 2960716902l,  407610648l,            2938108129l, 2581749599l,  538837155l, 2342628867l,  430543915l,  740188568l, 1937713272l, 3315215132l,            2085587024l, 4030765687l,  766054429l, 3517641839l,  689721775l, 1294158986l, 1753287754l, 4202601348l,            1974852792l,   33459103l, 3568087535l, 3144677435l, 1686130825l, 4134943013l, 3005738435l, 3599293386l,            426570142l,  754104406l, 3660892564l, 1964545167l,  829466833l,  821587464l, 1746693036l, 1006492428l,            1595312919l, 1256599985l, 1024482560l, 1897312280l, 2902903201l,  691790057l, 1037515867l, 3176831208l,            1968401055l, 2173506824l, 1089055278l, 1748401123l, 2941380082l,  968412354l, 1818753861l, 2973200866l,            3875951774l, 1119354008l, 3988604139l, 1647155589l, 2232450826l, 3486058011l, 3655784043l, 3759258462l,            847163678l, 1082052057l,  989516446l, 2871541755l, 3196311070l, 3929963078l,  658187585l, 3664944641l,            2175149170l, 2203709147l, 2756014689l, 2456473919l, 3890267390l, 1293787864l, 2830347984l, 3059280931l,            4158802520l, 1561677400l, 2586570938l,  783570352l, 1355506163l,   31495586l, 3789437343l, 3340549429l,            2092501630l,  896419368l,  671715824l, 3530450081l, 3603554138l, 1055991716l, 3442308219l, 1499434728l,            3130288473l, 3639507000l,   17769680l, 2259741420l,  487032199l, 4227143402l, 3693771256l, 1880482820l,            3924810796l,  381462353l, 4017855991l, 2452034943l, 2736680833l, 2209866385l, 2128986379l,  437874044l,            595759426l,  641721026l, 1636065708l, 3899136933l,  629879088l, 3591174506l,  351984326l, 2638783544l,            2348444281l, 2341604660l, 2123933692l,  143443325l, 1525942256l,  364660499l,  599149312l,  939093251l,            1523003209l,  106601097l,  376589484l, 1346282236l, 1297387043l,  764598052l, 3741218111l,  933457002l,            1886424424l, 3219631016l,  525405256l, 3014235619l,  323149677l, 2038881721l, 4100129043l, 2851715101l,            2984028078l, 1888574695l, 2014194741l, 3515193880l, 4180573530l, 3461824363l, 2641995497l, 3179230245l,            2902294983l, 2217320456l, 4040852155l, 1784656905l, 3311906931l,   87498458l, 2752971818l, 2635474297l,            2831215366l, 3682231106l, 2920043893l, 3772929704l, 2816374944l,  309949752l, 2383758854l,  154870719l,            385111597l, 1191604312l, 1840700563l,  872191186l, 2925548701l, 1310412747l, 2102066999l, 1504727249l,            3574298750l, 1191230036l, 3330575266l, 3180292097l, 3539347721l,  681369118l, 3305125752l, 3648233597l,            950049240l, 4173257693l, 1760124957l,  512151405l,  681175196l,  580563018l, 1169662867l, 4015033554l,            2687781101l,  699691603l, 2673494188l, 1137221356l,  123599888l,  472658308l, 1053598179l, 1012713758l,            3481064843l, 3759461013l, 3981457956l, 3830587662l, 1877191791l, 3650996736l,  988064871l, 3515461600l,            4089077232l, 2225147448l, 1249609188l, 2643151863l, 3896204135l, 2416995901l, 1397735321l, 3460025646l        };        double[] refDouble = {            0.76275443, 0.99000644, 0.98670464, 0.10143112, 0.27933125, 0.69867227, 0.94218740, 0.03427201,            0.78842173, 0.28180608, 0.92179002, 0.20785655, 0.54534773, 0.69644020, 0.38107718, 0.23978165,            0.65286910, 0.07514568, 0.22765211, 0.94872929, 0.74557914, 0.62664415, 0.54708246, 0.90959343,            0.42043116, 0.86334511, 0.19189126, 0.14718544, 0.70259889, 0.63426346, 0.77408121, 0.04531601,            0.04605807, 0.88595519, 0.69398270, 0.05377184, 0.61711170, 0.05565708, 0.10133577, 0.41500776,            0.91810699, 0.22320679, 0.23353705, 0.92871862, 0.98897234, 0.19786706, 0.80558809, 0.06961067,            0.55840445, 0.90479405, 0.63288060, 0.95009721, 0.54948447, 0.20645042, 0.45000959, 0.87050869,            0.70806991, 0.19406895, 0.79286390, 0.49332866, 0.78483914, 0.75145146, 0.12341941, 0.42030252,            0.16728160, 0.59906494, 0.37575460, 0.97815160, 0.39815952, 0.43595080, 0.04952478, 0.33917805,            0.76509902, 0.61034321, 0.90654701, 0.92915732, 0.85365931, 0.18812377, 0.65913428, 0.28814566,            0.59476081, 0.27835931, 0.60722542, 0.68310435, 0.69387186, 0.03699800, 0.65897714, 0.17527003,            0.02889304, 0.86777366, 0.12352068, 0.91439461, 0.32022990, 0.44445731, 0.34903686, 0.74639273,            0.65918367, 0.92492794, 0.31872642, 0.77749724, 0.85413832, 0.76385624, 0.32744211, 0.91326300,            0.27458185, 0.22190155, 0.19865383, 0.31227402, 0.85321225, 0.84243342, 0.78544200, 0.71854080,            0.92503892, 0.82703064, 0.88306297, 0.47284073, 0.70059042, 0.48003761, 0.38671694, 0.60465770,            0.41747204, 0.47163243, 0.72750808, 0.65830223, 0.10955369, 0.64215401, 0.23456345, 0.95944940,            0.72822249, 0.40888451, 0.69980355, 0.26677428, 0.57333635, 0.39791582, 0.85377858, 0.76962816,            0.72004885, 0.90903087, 0.51376506, 0.37732665, 0.12691640, 0.71249738, 0.81217908, 0.37037313,            0.32772374, 0.14238259, 0.05614811, 0.74363008, 0.39773267, 0.94859135, 0.31452454, 0.11730313,            0.62962618, 0.33334237, 0.45547255, 0.10089665, 0.56550662, 0.60539371, 0.16027624, 0.13245301,            0.60959939, 0.04671662, 0.99356286, 0.57660859, 0.40269560, 0.45274629, 0.06699735, 0.85064246,            0.87742744, 0.54508392, 0.87242982, 0.29321385, 0.67660627, 0.68230715, 0.79052073, 0.48592054,            0.25186266, 0.93769755, 0.28565487, 0.47219067, 0.99054882, 0.13155240, 0.47110470, 0.98556600,            0.84397623, 0.12875246, 0.90953202, 0.49129015, 0.23792727, 0.79481194, 0.44337770, 0.96564297,            0.67749118, 0.55684872, 0.27286897, 0.79538393, 0.61965356, 0.22487929, 0.02226018, 0.49248200,            0.42247006, 0.91797788, 0.99250134, 0.23449967, 0.52531508, 0.10246337, 0.78685622, 0.34310922,            0.89892996, 0.40454552, 0.68608407, 0.30752487, 0.83601319, 0.54956031, 0.63777550, 0.82199797,            0.24890696, 0.48801123, 0.48661910, 0.51223987, 0.32969635, 0.31075073, 0.21393155, 0.73453207,            0.15565705, 0.58584522, 0.28976728, 0.97621478, 0.61498701, 0.23891470, 0.28518540, 0.46809591,            0.18371914, 0.37597910, 0.13492176, 0.66849449, 0.82811466, 0.56240330, 0.37548956, 0.27562998,            0.27521910, 0.74096121, 0.77176757, 0.13748143, 0.99747138, 0.92504502, 0.09175241, 0.21389176,            0.21766512, 0.31183245, 0.23271221, 0.21207367, 0.57903312, 0.77523344, 0.13242613, 0.31037988,            0.01204835, 0.71652949, 0.84487594, 0.14982178, 0.57423142, 0.45677888, 0.48420169, 0.53465428,            0.52667473, 0.46880526, 0.49849733, 0.05670710, 0.79022476, 0.03872047, 0.21697212, 0.20443086,            0.28949326, 0.81678186, 0.87629474, 0.92297064, 0.27373097, 0.84625273, 0.51505586, 0.00582792,            0.33295971, 0.91848412, 0.92537226, 0.91760033, 0.07541125, 0.71745848, 0.61158698, 0.00941650,            0.03135554, 0.71527471, 0.24821915, 0.63636652, 0.86159918, 0.26450229, 0.60160194, 0.35557725,            0.24477500, 0.07186456, 0.51757096, 0.62120362, 0.97981062, 0.69954667, 0.21065616, 0.13382753,            0.27693186, 0.59644095, 0.71500764, 0.04110751, 0.95730081, 0.91600724, 0.47704678, 0.26183479,            0.34706971, 0.07545431, 0.29398385, 0.93236070, 0.60486023, 0.48015011, 0.08870451, 0.45548581,            0.91872718, 0.38142712, 0.10668643, 0.01397541, 0.04520355, 0.93822273, 0.18011940, 0.57577277,            0.91427606, 0.30911399, 0.95853475, 0.23611214, 0.69619891, 0.69601980, 0.76765372, 0.58515930,            0.49479057, 0.11288752, 0.97187699, 0.32095365, 0.57563608, 0.40760618, 0.78703383, 0.43261152,            0.90877651, 0.84686346, 0.10599030, 0.72872803, 0.19315490, 0.66152912, 0.10210518, 0.06257876,            0.47950688, 0.47062066, 0.72701157, 0.48915116, 0.66110261, 0.60170685, 0.24516994, 0.12726050,            0.03451185, 0.90864994, 0.83494878, 0.94800035, 0.91035206, 0.14480751, 0.88458997, 0.53498312,            0.15963215, 0.55378627, 0.35171349, 0.28719791, 0.09097957, 0.00667896, 0.32309622, 0.87561479,            0.42534520, 0.91748977, 0.73908457, 0.41793223, 0.99279792, 0.87908370, 0.28458072, 0.59132853,            0.98672190, 0.28547393, 0.09452165, 0.89910674, 0.53681109, 0.37931425, 0.62683489, 0.56609740,            0.24801549, 0.52948179, 0.98328855, 0.66403523, 0.55523786, 0.75886666, 0.84784685, 0.86829981,            0.71448906, 0.84670080, 0.43922919, 0.20771016, 0.64157936, 0.25664246, 0.73055695, 0.86395782,            0.65852932, 0.99061803, 0.40280575, 0.39146298, 0.07291005, 0.97200603, 0.20555729, 0.59616495,            0.08138254, 0.45796388, 0.33681125, 0.33989127, 0.18717090, 0.53545811, 0.60550838, 0.86520709,            0.34290701, 0.72743276, 0.73023855, 0.34195926, 0.65019733, 0.02765254, 0.72575740, 0.32709576,            0.03420866, 0.26061893, 0.56997511, 0.28439072, 0.84422744, 0.77637570, 0.55982168, 0.06720327,            0.58449067, 0.71657369, 0.15819609, 0.58042821, 0.07947911, 0.40193792, 0.11376012, 0.88762938,            0.67532159, 0.71223735, 0.27829114, 0.04806073, 0.21144026, 0.58830274, 0.04140071, 0.43215628,            0.12952729, 0.94668759, 0.87391019, 0.98382450, 0.27750768, 0.90849647, 0.90962737, 0.59269720,            0.96102026, 0.49544979, 0.32007095, 0.62585546, 0.03119821, 0.85953001, 0.22017528, 0.05834068,            0.80731217, 0.53799961, 0.74166948, 0.77426600, 0.43938444, 0.54862081, 0.58575513, 0.15886492,            0.73214332, 0.11649057, 0.77463977, 0.85788827, 0.17061997, 0.66838056, 0.96076133, 0.07949296,            0.68521946, 0.89986254, 0.05667410, 0.12741385, 0.83470977, 0.63969104, 0.46612929, 0.10200126,            0.01194925, 0.10476340, 0.90285217, 0.31221221, 0.32980614, 0.46041971, 0.52024973, 0.05425470,            0.28330912, 0.60426543, 0.00598243, 0.97244013, 0.21135841, 0.78561597, 0.78428734, 0.63422849,            0.32909934, 0.44771136, 0.27380750, 0.14966697, 0.18156268, 0.65686758, 0.28726350, 0.97074787,            0.63676171, 0.96649494, 0.24526295, 0.08297372, 0.54257548, 0.03166785, 0.33735355, 0.15946671,            0.02102971, 0.46228045, 0.11892296, 0.33408336, 0.29875681, 0.29847692, 0.73767569, 0.02080745,            0.62980060, 0.08082293, 0.22993106, 0.25031439, 0.87787525, 0.45150053, 0.13673441, 0.63407612,            0.97907688, 0.52241942, 0.50580158, 0.06273902, 0.05270283, 0.77031811, 0.05113352, 0.24393329,            0.75036441, 0.37436336, 0.22877652, 0.59975358, 0.85707591, 0.88691457, 0.85547165, 0.36641027,            0.58720133, 0.45462835, 0.09243817, 0.32981586, 0.07820411, 0.25421519, 0.36004706, 0.60092307,            0.46192412, 0.36758683, 0.98424170, 0.08019934, 0.68594024, 0.45826386, 0.29962317, 0.79365413,            0.89231296, 0.49478547, 0.87645944, 0.23590734, 0.28106737, 0.75026285, 0.08136314, 0.79582424,            0.76010628, 0.82792971, 0.27947652, 0.72482861, 0.82191216, 0.46171689, 0.79189752, 0.96043686,            0.51609668, 0.88995725, 0.28998963, 0.55191845, 0.03934737, 0.83033700, 0.49553013, 0.98009549,            0.19017594, 0.98347750, 0.33452066, 0.87144372, 0.72106301, 0.71272114, 0.71465963, 0.88361677,            0.85571283, 0.73782329, 0.20920458, 0.34855153, 0.46766817, 0.02780062, 0.74898344, 0.03680650,            0.44866557, 0.77426312, 0.91025891, 0.25195236, 0.87319953, 0.63265037, 0.25552148, 0.27422476,            0.95217406, 0.39281839, 0.66441573, 0.09158900, 0.94515992, 0.07800798, 0.02507888, 0.39901462,            0.17382573, 0.12141278, 0.85502334, 0.19902911, 0.02160210, 0.44460522, 0.14688742, 0.68020336,            0.71323733, 0.60922473, 0.95400380, 0.99611159, 0.90897777, 0.41073520, 0.66206647, 0.32064685,            0.62805003, 0.50677209, 0.52690101, 0.87473387, 0.73918362, 0.39826974, 0.43683919, 0.80459118,            0.32422684, 0.01958019, 0.95319576, 0.98326137, 0.83931735, 0.69060863, 0.33671416, 0.68062550,            0.65152380, 0.33392969, 0.03451730, 0.95227244, 0.68200635, 0.85074171, 0.64721009, 0.51234433,            0.73402047, 0.00969637, 0.93835057, 0.80803854, 0.31485260, 0.20089527, 0.01323282, 0.59933780,            0.31584602, 0.20209563, 0.33754800, 0.68604181, 0.24443049, 0.19952227, 0.78162632, 0.10336988,            0.11360736, 0.23536740, 0.23262256, 0.67803776, 0.48749791, 0.74658435, 0.92156640, 0.56706407,            0.36683221, 0.99157136, 0.23421374, 0.45183767, 0.91609720, 0.85573315, 0.37706276, 0.77042618,            0.30891908, 0.40709595, 0.06944866, 0.61342849, 0.88817388, 0.58734506, 0.98711323, 0.14744128,            0.63242656, 0.87704136, 0.68347125, 0.84446569, 0.43265239, 0.25146321, 0.04130111, 0.34259839,            0.92697368, 0.40878778, 0.56990338, 0.76204273, 0.19820348, 0.66314909, 0.02482844, 0.06669207,            0.50205581, 0.26084093, 0.65139159, 0.41650223, 0.09733904, 0.56344203, 0.62651696, 0.67332139,            0.58037374, 0.47258086, 0.21010758, 0.05713135, 0.89390629, 0.10781246, 0.32037450, 0.07628388,            0.34227964, 0.42190597, 0.58201860, 0.77363549, 0.49595133, 0.86031236, 0.83906769, 0.81098161,            0.26694195, 0.14215941, 0.88210306, 0.53634237, 0.12090720, 0.82480459, 0.75930318, 0.31847147,            0.92768077, 0.01037616, 0.56201727, 0.88107122, 0.35925856, 0.85860762, 0.61109408, 0.70408301,            0.58434977, 0.92192494, 0.62667915, 0.75988365, 0.06858761, 0.36156496, 0.58057195, 0.13636150,            0.57719713, 0.59340255, 0.63530602, 0.22976282, 0.71915530, 0.41162531, 0.63979565, 0.09931342,            0.79344045, 0.10893790, 0.84450224, 0.23122236, 0.99485593, 0.73637397, 0.17276368, 0.13357764,            0.74965804, 0.64991737, 0.61990341, 0.41523170, 0.05878239, 0.05687301, 0.05497131, 0.42868366,            0.42571090, 0.25810502, 0.89642955, 0.30439758, 0.39310223, 0.11357431, 0.04288255, 0.23397550,            0.11200634, 0.85621396, 0.89733974, 0.37508865, 0.42077265, 0.68597384, 0.72781399, 0.19296476,            0.61699087, 0.31667128, 0.67756410, 0.00177323, 0.05725176, 0.79474693, 0.18885238, 0.06724856,            0.68193156, 0.42202167, 0.22082041, 0.28554673, 0.64995708, 0.87851940, 0.29124547, 0.61009521,            0.87374537, 0.05743712, 0.69902994, 0.81925115, 0.45653873, 0.37236821, 0.31118709, 0.52734307,            0.39672836, 0.38185294, 0.30163915, 0.17374510, 0.04913278, 0.90404879, 0.25742801, 0.58266467,            0.97663209, 0.79823377, 0.36437958, 0.15206043, 0.26529938, 0.22690047, 0.05839021, 0.84721160,            0.18622435, 0.37809403, 0.55706977, 0.49828704, 0.47659049, 0.24289680, 0.88477595, 0.07807463,            0.56245739, 0.73490635, 0.21099431, 0.13164942, 0.75840044, 0.66877037, 0.28988183, 0.44046090,            0.24967434, 0.80048356, 0.26029740, 0.30416821, 0.64151867, 0.52067892, 0.12880774, 0.85465381,            0.02690525, 0.19149288, 0.49630295, 0.79682619, 0.43566145, 0.00288078, 0.81484193, 0.03763639,            0.68529083, 0.01339574, 0.38405386, 0.30537067, 0.22994703, 0.44000045, 0.27217985, 0.53831243,            0.02870435, 0.86282045, 0.61831306, 0.09164956, 0.25609707, 0.07445781, 0.72185784, 0.90058883,            0.30070608, 0.94476583, 0.56822213, 0.21933909, 0.96772793, 0.80063440, 0.26307906, 0.31183306,            0.16501252, 0.55436179, 0.68562285, 0.23829083, 0.86511559, 0.57868991, 0.81888344, 0.20126869,            0.93172350, 0.66028129, 0.21786948, 0.78515828, 0.10262106, 0.35390326, 0.79303876, 0.63427924,            0.90479631, 0.31024934, 0.60635447, 0.56198079, 0.63573813, 0.91854197, 0.99701497, 0.83085849,            0.31692291, 0.01925964, 0.97446405, 0.98751283, 0.60944293, 0.13751018, 0.69519957, 0.68956636,            0.56969015, 0.46440193, 0.88341765, 0.36754434, 0.89223647, 0.39786427, 0.85055280, 0.12749961,            0.79452122, 0.89449784, 0.14567830, 0.45716830, 0.74822309, 0.28200437, 0.42546044, 0.17464886,            0.68308746, 0.65496587, 0.52935411, 0.12736159, 0.61523955, 0.81590528, 0.63107864, 0.39786553,            0.20102294, 0.53292914, 0.75485590, 0.59847044, 0.32861691, 0.12125866, 0.58917183, 0.07638293,            0.86845380, 0.29192617, 0.03989733, 0.52180460, 0.32503407, 0.64071852, 0.69516575, 0.74254998,            0.54587026, 0.48713246, 0.32920155, 0.08719954, 0.63497059, 0.54328459, 0.64178757, 0.45583809,            0.70694291, 0.85212760, 0.86074305, 0.33163422, 0.85739792, 0.59908488, 0.74566046, 0.72157152        };        for (int i = 0; i < refInt.length; ++i) {            int r = mt.nextInt();            assertEquals(refInt[i], (r & 0x7fffffffl) | ((r < 0) ? 0x80000000l : 0x0l));        }        for (int i = 0; i < refDouble.length; ++i) {            int r = mt.nextInt();            assertEquals(refDouble[i],                         ((r & 0x7fffffffl) | ((r < 0) ? 0x80000000l : 0x0l)) / 4294967296.0,                         1.0e-8);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import org.junit.Assert;import org.junit.Test;public class Well512aTest {    @Test    public void testReferenceCode() {        Well512a mt = new Well512a(new int[] {            740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,          -1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000       });        int[] refInt = {            1634813289,   1876773016,   -973836208,  -2130023652,  -1045460084,  -1834384857,   1691032973,    609714289,            2033920362,    555915483,      6680992,   1958127415,   1866469645,  -1471336965,   2049178762,   -192324811,           -2056050066,    810879705,   1405046309,   -781317118,   1012782311,  -1045081032,    728377508,   1473511660,             290489070,    326666761,   2018299979,  -1876688058,   1239968501,   1464625040,   2025151042,   -101397407,            1387902041,    210959839,   1366359326,   -476473433,    153180037,  -1607631523,   -506743495,     17888738,             313865008,   -340504498,    586684079,   1243699375,    753162229,   -646761694,   -739189655,   -210120185,           -1856358726,   -628255542,  -1812798197,   1416288088,   1077967722,   -846846208,   1379850409,   -580183344,              -1858959,    210859778,    295841424,   1492774865,  -1415543680,   -344870570,  -1942779197,   1549510646,            -389544849,    314254218,     11784988,  -1311757368,   1719514841,   -764610517,   1296788970,   -994707050,             783854563,    422654144,    387639079,   1219688425,   2144352572,   -834212874,  -1036550358,    935909479,            -568610842,   1327498837,   -588933178,   1910065754,    -40851599,   -182063170,   1302731458,    541311559,           -1647345522,    805224371,  -1721196679,   1518507830,   -952689880,   -433276260,    509675254,   -777259954,            1277810106,    284054896,    936042202,   2036836351,   1956412426,  -1186403024,    287795400,   2135311211,             720485927,   1500695024,   -281656583,  -1277937322,  -1628968482,   1242814831,  -2030700974,   1473867890,             440813549,  -1357033971,     28384076,   1602731216,   -641465746,   -609054347,    635938444,   1472898176,            1476894555,   -747974186,  -1590337055,   -884242108,   -389736197,  -2066984505,   1087103272,  -1236446290,              31657463,   1835715432,   -468439078,  -2132633204,   -434609235,    258308151,   1851926761,  -1630139159,           -1344617241,   1969204215,    619463174,   -174392624,    207475487,  -1619828078,   1327980298,    -83968178,             445951782,  -1786230541,      6279288,   -580982231,   1550645552,   2006533941,    275746007,    455676647,            2019637349,   1115547704,  -1313120106,   -516213449,     73752461,  -1382448112,    398589620,   1319888048,           -1595572334,   1566934536,  -1735685764,  -1509545339,   1458173912,   -549395819,   -618827040,   1516624531,            1900757187,  -1454200688,    965524719,    488355065,  -1869294316,   -810641680,  -2059428251,   1454656431,            1329120541,   -232185900,   -994996943,   1855980910,   -452077812,   1565630611,    759842266,   1241435187,           -1390456063,   1946400597,  -2032319771,    683667881,    905911106,   1983310786,    120010546,    526018017,           -1946881912,    205004987,  -1307250612,   2130980818,   2052864161,    189839787,   1789478047,    406168885,           -1145186347,      8507675,   1277188815,   1492619042,   2009819675,  -1627411598,   -851016743,  -1828234956,            1962622506,   2140398255,    236935165,   -337237772,   1263419111,    516775236,   -335741025,   1391328225,             455979249,  -1457534664,   -657606241,    485648133,   1762116343,   1194889600,    817834937,    321150162,             131159182,    290277758,  -1876924740,  -1770401129,   1291602973,  -1003642974,  -1580211929,   1520422021,            -399171579,    -24315308,    453805396,   -659197747,   -205656847,    466526550,   1444397201,   1178091401,           -1157268826,   -602394028,  -1370668795,   1614896435,   1699071659,   1864753793,   1888518358,  -1721244514,            1812776767,    668822227,   -297283057,   2130183333,  -1169618692,    912860240,  -2028253096,   1244694278        };        for (int i = 0; i < refInt.length; ++i) {            Assert.assertEquals(refInt[i], mt.nextInt());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import org.junit.Assert;import org.junit.Test;public class Well19937cTest {    @Test    public void testReferenceCode() {        int[] base = {              740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,            -1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000,             -595495729,  1047766204,  1875773301, -1637793284,  1379017098,   262792705,   191880010,  -251000180,            -1753047622,  -972355720,    90626881,  1644693418,  1503365577,   439653419,  1806361562,  1268823869         };        int[] init = new int[624];        for (int i = 0; i < init.length; ++i) {            init[i] = base[i % base.length] + i;        }        Well19937c mt = new Well19937c(init);        int[] refInt = {            2128528153,    327121884,    935445371,    -83026433,  -1041143083,   2084595880,  -1073535198,  -1678863790,   -523636021,  -1514837782,   -736786810,   1527711112,  -1051227939,    978703380,    410322163,   1727815703,            -648426354,    636056441,   1954420292,     17754810,   -958628705,  -1091307602,   1793078738,  -1680336346,   1792171272,    941973796,  -2066152330,  -1248758068,  -1061211586,    262020189,   1276960217,   -233886784,            1767509252,  -1811939255,   -406116097,   -742435920,  -1349799525,    240329556,   -332161345,   1488943143,   -332244280,   2093328957,    674753300,  -1930135556,    257111467,     63793650,  -1964335223,   1315849133,            -797349146,   1372022250,  -1451892049,  -1325138957,   -870401239,  -1294317369,     91490879,    386205044,   -704074702,  -1230679067,   1513674392,   -262996240,   1196007314,   1398903796,    803719762,  -1750926831,           -1268814180,   1233515404,   1498313934,   -970591257,    611113671,   -261632474,   1834097325,   1709440492,   -150396854,   2120561003,    -62645660,    479080234,   1535125050,   1823378695,  -1129289329,  -1095198399,            2092564733,     78836308,   -692015409,   1647147229,  -1847922219,   1838279320,   -848333841,  -1375151778,    920238861,   1512628290,   -749439404,    288851918,   -427218675,    679640964,    425700808,  -2077624511,           -1929434455,   -647176419,    650437190,  -1926749131,  -1564744729,    734494454,    108193743,    246246679,    810042628,   1952337771,   1089253730,  -1874275331,   1428419392,   -492969232,   1945270770,   -201265602,            -755490251,   -624426214,   -699605715,   -113446478,    809091299,  -1521531511,   1136505389,   -523660964,    132928433,   1926559713,  -1485314325,   -508322506,     46307756,  -1627479740,   -589386406,  -1855555892,             584299545,   1272841066,   -597242658,    925134545,   1102566453,   -753335037,     -9523218,  -1778632375,    568963646,    764338254,   1259944540,  -2000124642,   1307414525,   -151384482,    807294400,   1993749511,             -15503094,   -709471492,   2104830082,   1387684315,  -1929056119,    224254668,   -733550950,   -889466978,  -1987783335,   -437144026,    995905753,  -1021386158,  -1096313388,  -1014152835,  -1303258241,   1201884788,           -1845042397,   1421462511,    980805867,   2143771251,    481226968,   1790544569,    328448328,   1995857639,    -66668269,  -1411421267,   -222586606,    866950765,   -308713926,  -1048350893,    993222402,  -1139265642,            -871837948,   1145571913,    381928580,     35386691,   1640961123,  -1192981020,    775971009,    594246635,   1603197812,   -575106766,   2023682000,  -1636301903,   -718093720,  -1666421635,  -2146115988,    320593570,             287355418,    454400027,   1112753817,   1751196267,    782077910,  -1478447368,  -1007557264,   -862315517,  -2035355952,   2123515250,   -557641502,  -1789932035,    879640129,     44167603,    791148984,   1382939723,           -2135684233,   1825489580,    937345485,  -1839983359,  -1536880111,  -1472578359,   1548052748,  -1471535862,    -14508727,   1509621398,  -2134967452,   -787485401,    815341660,   -327905128,   1028096737,    866906991,           -1585990806,    859229080,    234806270,    998518056,  -1897890815,   -900923587,   1179856752,   1529572451,    620486106,   1119836556,   1661285564,   2097404633,  -1437490790,    265306115,   -984880135,   1326751968,            1280043536,    680210701,    155786166,   1550973250,   -325781949,   -597789777,     -1939780,   1345275487,   1930450001,    941449704,    669301309,    693651713,   -990721514,    582968326,    976132553,  -1892942099,           -1065070157,   -711990993,   -688974833,  -1026091683,   1115346827,  -1305730749,  -1733626381,   -364566696,    -21761572,    -37152746,   -262011730,   1302722752,  -1806313409,   -767072509,    764112137,   1671157377,            1837645038,  -1021606421,  -1781898911,   -232127459,   -310742675,  -1818095744,  -1128320656,   -705565953,   -354445532,   -523172807,   -433877202,    131904485,    -64292316,    381829280,    229820263,   1797992622,            1359665678,    978481451,   -885267130,  -1415988446,   -356533788,   -961419072,   1938703090,    708344111,    679299953,    744615129,   1328811158,   1257588574,    569216282,   -753296151,  -1519838713,   2016884452,            1062684606,   1561736790,   2028643511,  -1353001615,    886376832,   1466953172,   1664783899,   1290079981,    -57483993,  -1176112430,   1634916316,   1976304475,   1374136869,   -648738039,   1058175869,   -909000745,           -1526439218,    726626991,   2066596202,     64980943,    -26166577,   -885900005,  -1821546816,  -1103727665,    730606315,  -1324948459,   -696956940,  -1300869403,   1171578314,    797249074,  -1600611618,   1928247682,             307164165,  -1482476232,  -1886179640,   1306433392,   1945271359,  -1272113751,  -1285984081,  -2057145549,    795047465,   1262569087,  -1239828121,   1426641636,   -786371495,   2120199316,   1273690652,     74457589,           -1033394229,    338952565,     46122958,   1225741533,   2115308090,    678200841,  -1618264885,   -101162569,  -1628976330,  -1232839500,    468709044,   1876019116,     92723122,    233398255,   -554960844,     38494196,            -406437278,   2083528643,  -1106878615,   -340722557,  -2123964932,    223183343,    108918116,  -1014629054,   -901344544,   -838896840,  -1908460517,  -1763508731,   -926890833,   1703791049,   -667755577,   1694418389,             791641263,   1095689677,   1119202039,  -1419111438,  -2012259010,    188017439,  -1775110395,  -1971099661,  -1688113734,    131472813,   -776304959,   1511388884,   2080864872,  -1733824651,   1992147495,   1119828320,            1065336924,  -1357606762,    462963503,   1180719494,   -202678962,   -892646595,    605869323,   1144255663,    878462678,  -1051371303,    872374876,    631322271,   -172600544,  -1552071375,  -1939570033,    151973117,            1640861022,    310682640,     34192866,   2057773671,  -2004476027,  -1879238973,    582736114,    900581664,   -427390545,  -1232348528,   -535115984,   1321853054,     69386780,  -1729375922,   1418473715,   1022091451,             496799289,    -80757405,  -1903543310,  -1128846846,      1703964,   1984450945,    856753858,   -812919184,    775486323,  -1376056193,    638628840,    314243536,   1030626207,    644050997,     73923896,    362270613,             236584904,   1463240891,   -223614432,    435371594,   -751940030,   -124274553,  -1991092884,   1579624267,   1249632649,    157589625,   -345229739,   -366245207,  -1399995986,   1651729983,   1965074340,  -1108970305,            1163690769,   1732013523,  -1461252895,    669755552,   -476503675,   -264578685,    -32813949,    288222188,    -25734262,    106040916,   1654395626,   -365148479,   2014455846,  -2040447994,   1351639280,   -919975757,           -1970412139,    -47306532,    222377665,   -363434917,  -1091717516,   2090685531,  -1221091649,  -1729649190,  -1239406708,   1064945398,   -105437479,   -419675255,     74701669,    -12862899,   -498269844,   1566898997,           -1872838355,   1596887574,    485902962,    469225597,   -881763553,   1307841032,  -1642872487,   1388543045,    379792876,   1095683384,    840780732,   1934378038,   1851278350,  -1359389423,    130868458,   -313448799,            -663624816,   1031714153,   -608443411,   -205137499,  -1849464427,   1973593637,   1068741808,  -1420655961,   1188762305,    954044841,   -995454462,  -1818101092,  -1937201943,   -324541290,  -1520603933,    572873173,            -554764496,   1051557081,  -1245136076,   -985349536,    329320398,   1787901464,    -37803304,  -1759310177,  -1463492617,  -1861729663,   1251768782,    256937091,   -779036948,  -2049893864,   1256022877,   1228075657,           -1550195255,   -611319853,   1190797155,   2047604112,   -576077160,  -1532843331,  -1324899394,   -159729560,   -622525946,  -1080302767,   -236033484,   1895243903,   -410123689,  -1944154157,   -681781021,   1208453003,             579595878,   1303914051,   -145607082,   -131567277,  -1917288455,    894217359,   -175688726,  -1585480723,    663691440,  -1140068263,   -641711178,   1596080008,    629197693,    976422358,  -1570451095,    525923776,             895046136,   -504151767,   1602553020,  -1233054923,  -1798474837,  -1488857895,   1055782627,    261863143,   1879276655,    488240679,   1910982611,  -1919441259,    370435945,   1265230086,  -1293284428,  -1503576227,            2076963035,  -1379628250,   1157098875,   1984461153,  -1947837397,   1705880124,   1453607404,  -1233649748,   1479943773,   -863878721,   -862415630,   -736723275,    940306358,  -1596000684,  -1174889953,   -615723892,            -885006597,  -1796723178,   1844159055,   -188942309,   2107251811,  -1675486996,  -1009475178,   -859263556,   -431866963,     -9593673,  -1878920923,   -104853791,  -1535224994,    -69315537,    586690130,  -1292234796,            1378749456,   -301873019,   -319297563,   1677205851,    292450579,  -1289441171,   1788113680,   1907606333,   1464711611,  -1372023606,  -1978832445,  -1772259768,   1949124464,   1818322887,  -1138036603,   1249727628,           -1474866449,  -1868013169,  -1384567593,    717007936,    954189997,  -1900561040,    738470389,   -158973180,   1732860784,   1936031206,  -1133354740,  -1173166665,   1432976712,    852636081,   1732064691,  -1831788120,            1273933579,    455403217,   1988395890,    106493468,    506092152,   -610530423,   1698053512,   1311747476,   1969503012,  -1887461759,   1613543073,    903200334,   -737865837,    325656800,  -1234001200,   1492148864,            2009861533,   -368262605,   1091338541,   2076108119,   -961392337,   1835877112,    316250307,   -853333391,  -2125443777,    815363504,   -798707803,   -158146540,    690786114,   -530775684,   1203556940,   1611485582,           -1661412270,    -53184506,   2126287444,   -232222229,   1559486057,    283532250,   1202760418,    932144172,   1082594656,   -570104011,    413509167,   -995027177,   -996477516,      -540544,   -745537167,   -712135469,            -996294983,   -592787198,   1889840948,   1314628747,   -394266926,   -682316577,    456447239,   1728806063,   -396279614,    -43387643,   1915717013,   -861574144,  -1078710588,   -561401249,   1111464540,     63643984,           -1693870413,   -968369980,  -1053148188,    708799038,   1883537988,    373371671,   -156410415,  -1596483236,  -1846890431,    888692915,  -1025632583,  -1666477591,   -343066267,  -2059058792,    641501628,  -1744347292,            1648632991,   1743540146,   2020952406,    164014499,    990508262,   1706408228,  -1236471842,   -347116260,   1843634523,    827255665,    300519853,  -1265974830,   -547247177,   -583064554,  -1995437077,    689210107,             -93151393,    835365056,   1706367315,  -1605902756,    200954895,    431093688,   -277573364,   -928486713,   -552221973,    145432789,   1128919795,   1675095586,   1930359882,   1215849501,  -1447770583,    657776490,            1885869860,  -1629237204,   -868897479,  -1258169760,   1828140195,   -883850439,    463933909,   -347361158,   1478116648,    801176896,  -1501915899,   1017335748,  -1654508882,    123994786,   1588785290,    791166651,           -1523108535,    340411166,   -496474762,  -1189711141,     -7392628,   2045171250,  -1245366209,    834787230,  -1346883181,   2034209454,    737043362,    898803323,   1983089087,  -1845404320,      9585188,  -1180608323,            1665100606,   1949474222,   -211115008,   1151308295,  -2132174259,    913126312,  -2085061672,   1419864120,  -1134542954,    -53833957,   -246913211,    468382370,  -1759479323,   1136686211,   1307012488,  -2036299559,           -1346099736,    314743106,  -1683101865,   -947151948,   -234529696,  -2103334293,   -279256894,     -1484257,  -1053953017,   1801205399,    941594454,   -874119215,   -672865187,    762284205,  -1494975451,    486607927,            -898264389,  -1711861093,   -212572760,   2106484281,  -1610786470,   1352525590,   -837779586,   1568282001,   -593019125,  -1146260782,  -1595879979,   -640781858,   1107692311,   1547132709,  -1928385535,  -2057772805,             634887038,    329772618,    942136006,   -864405576,    501883884,   1537141484,  -1180626836,   1123055420,   1090885851,    421662750,   2033111605,   1710917425,  -1118058244,     74321279,    257328195,  -1199940697,             208625996,   -442341447,    808119183,   1166827075,   1177417517,  -1856155370,  -1464837036,    -60624923,  -1306220638,    -91104698,  -1434621430,    548899241,     37351476,   1478278431,  -1255061434,    248470035,            -104642597,  -1865169521,   1418373655,  -1660810523,  -2129015436,    154612798,    276575732,   1930338442,    179503250,   -929294855,    -39452027,  -1377657544,   1442322193,   1137511318,   -432158653,   -984801987,             743099148,  -1118893528,   -904123623,  -1273146363,  -1884800406,   -803169061,   1254123158,   -484252077,    317646844,    404246525,  -1230293916,   1121445742,    -19657507,    652967153,  -1055406692,   -468950719,           -1493532921,  -1447624258,  -1369679689,  -1517000228,   -145853307,   1518006526,   1591195514,  -1475557146,   -909722097,   2103182976,   -406830579,  -2124025254,  -1804819507,  -1357512858,    567321869,    409048156,             567805180,   1749009386,   1762759722,  -1770324077,   1271140844,    468219092,    955792405,   1911965665,   1876314424,   -718200715,  -1278883927,   1392281730,   -120519585,    851473793,    245054754,    -33369039,            -284877584,   -479534880,   -212346563,   -122017521,  -1461429983,   1331007370,   1788621721,   1739036536,   1446350953,  -1985448033,    685528610,  -1386434659,   1368233993,   2021786790,   1596478397,  -1716635278,           -2011083017,    171876097,   -311529197,    687812052,    377000657,  -1055547517,  -1499047842,  -1818434951,   -120863666,     33888043,  -1387509273,   -541540700,   1162597745,  -1331415338,   1931708792,   -850270000,             663845594,   1536495943,   -322924971,  -1380272203,    261190298,   -204874428,  -2104974031,    883819928,    155808204,  -1454446035,   1323388464,  -1696505728,   1549800285,   1018150463,  -1327715703,  -1582480640,            1013659809,  -1820360082,   1666498787,   1406120540,   -196541482,   1248470531,  -1250433281,    836375878,    177646854,  -1927020253,   2145878321,    689712096,   -596605921,    348283199,   1916993096,    481356808,            -339687826,   1219340319,    718895887,  -2007521340,  -1859185806,   2042164737,    -58146784,    742449142,   1930754708,    780832111,    715056441,  -1393886151,     -8150527,   -599607443,   -537300865,  -1212516084        };        for (int i = 0; i < refInt.length; ++i) {            Assert.assertEquals(refInt[i], mt.nextInt());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import java.util.Random;/** * Test cases for the RandomAdaptor class * * @version $Revision$ $Date$ */public class RandomAdaptorTest extends RandomDataTest {    public RandomAdaptorTest(String name) {        super(name);    }    public void testAdaptor() {        ConstantGenerator generator = new ConstantGenerator();        Random random = RandomAdaptor.createAdaptor(generator);        checkConstant(random);        RandomAdaptor randomAdaptor = new RandomAdaptor(generator);        checkConstant(randomAdaptor);    }    private void checkConstant(Random random) {        byte[] bytes = new byte[] {0};        random.nextBytes(bytes);        assertEquals(0, bytes[0]);        assertEquals(false, random.nextBoolean());        assertEquals(0, random.nextDouble(), 0);        assertEquals(0, random.nextFloat(), 0);        assertEquals(0, random.nextGaussian(), 0);        assertEquals(0, random.nextInt());        assertEquals(0, random.nextInt(1));        assertEquals(0, random.nextLong());        random.setSeed(100);        assertEquals(0, random.nextDouble(), 0);    }    /*     * "Constant" generator to test Adaptor delegation.     * "Powered by Eclipse ;-)"     *     */    private static class ConstantGenerator implements RandomGenerator {        public boolean nextBoolean() {            return false;        }        public void nextBytes(byte[] bytes) {        }        public double nextDouble() {            return 0;        }        public float nextFloat() {            return 0;        }        public double nextGaussian() {            return 0;        }        public int nextInt() {            return 0;        }        public int nextInt(int n) {            return 0;        }        public long nextLong() {            return 0;        }        public void setSeed(int seed) {        }        public void setSeed(int[] seed) {        }        public void setSeed(long seed) {        }    }}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.random;import org.apache.commons.math.DimensionMismatchException;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;import org.apache.commons.math.stat.descriptive.moment.VectorialMean;import junit.framework.*;public class UncorrelatedRandomVectorGeneratorTestextends TestCase {    public UncorrelatedRandomVectorGeneratorTest(String name) {        super(name);        mean = null;        standardDeviation = null;        generator = null;    }    public void testMeanAndCorrelation() throws DimensionMismatchException {        VectorialMean meanStat = new VectorialMean(mean.length);        VectorialCovariance covStat = new VectorialCovariance(mean.length, true);        for (int i = 0; i < 10000; ++i) {            double[] v = generator.nextVector();            meanStat.increment(v);            covStat.increment(v);        }        double[] estimatedMean = meanStat.getResult();        double scale;        RealMatrix estimatedCorrelation = covStat.getResult();        for (int i = 0; i < estimatedMean.length; ++i) {            assertEquals(mean[i], estimatedMean[i], 0.07);            for (int j = 0; j < i; ++j) {                scale = standardDeviation[i] * standardDeviation[j];                assertEquals(0, estimatedCorrelation.getEntry(i, j) / scale, 0.03);            }            scale = standardDeviation[i] * standardDeviation[i];            assertEquals(1, estimatedCorrelation.getEntry(i, i) / scale, 0.025);        }    }    @Override    public void setUp() {        mean              = new double[] {0.0, 1.0, -3.0, 2.3};        standardDeviation = new double[] {1.0, 2.0, 10.0, 0.1};        RandomGenerator rg = new JDKRandomGenerator();        rg.setSeed(17399225432l);        generator =            new UncorrelatedRandomVectorGenerator(mean, standardDeviation,                    new GaussianRandomGenerator(rg));    }    @Override    public void tearDown() {        mean = null;        standardDeviation = null;        generator = null;    }    private double[] mean;    private double[] standardDeviation;    private UncorrelatedRandomVectorGenerator generator;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import org.junit.Assert;import org.junit.Test;public class Well44497aTest {    @Test    public void testReferenceCode() {        int[] base = {              740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,            -1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000,             -595495729,  1047766204,  1875773301, -1637793284,  1379017098,   262792705,   191880010,  -251000180,            -1753047622,  -972355720,    90626881,  1644693418,  1503365577,   439653419,  1806361562,  1268823869         };        int[] init = new int[1391];        for (int i = 0; i < init.length; ++i) {            init[i] = base[i % base.length] + i;        }        Well44497a mt = new Well44497a(init);        int[] refInt = {          -1464956854,  -1524360321,    986845646,   -182050548,   -818943186,  -1744848370,   1392434650,   -182648505,  -2026593838,   1254866610,   -410459761,  -1392048371,   -968730026,   1485793687,   -728749746,   -112685463,            275126404,  -1101838984,   1193096287,    443511615,   -510869213,    549869992,   1974458428,  -1217587840,   -335835016,  -2048974745,   1066947099,   -611611187,   1978925459,    688164478,   -463344808,     56995910,            699288809,    606392470,    117418673,   1948706703,   -485598135,    385841705,   1725261146,   -919553921,     70643668,   2128611684,   1720197347,    738706713,   1162026860,   -611442152,   1469145601,   2051653750,            609067755,  -1971782890,   -971114565,    776260144,   1619791127,  -1547233838,   1502505722,    913168193,   1761269649,     81782996,     62251540,   1519079156,   1239007000,    489633356,   -800433470,  -2107278046,            495320431,    269446836,  -2013306553,   1074614697,   1645125348,    584369930,   -405429577,   1211134012,  -2060113546,     -2047824,   -443978800,    271218497,  -1002185964,   1519315874,   -695096464,    -79101601,          -1521653608,    192426133,   1159511202,  -1354494985,   -477280535,    583522228,   -661741458,  -1251175621,   -369487281,  -2015449518,  -2102058930,   -645264919,   -925270025,  -1674575999,   1363844609,   -831732660,          -1668989157,  -1861246633,     83763283,  -1056074975,   -519054258,  -1546386261,   1691674654,   -885968657,  -1189571815,   2095154843,   1686743191,  -1859471265,   -261593938,   1721982136,   -491120252,   -949699153,            642525852,  -2005306625,  -1004765905,    742736856,   1653443876,    788423835,   1536155740,    879514143,  -1510757104,    115238646,     28600662,   1485490803,   1272460710,    523153480,   -766782926,   1332478031,            528775440,    302965264,  -2046891123,   1108139271,   1611601128,    550846467,   -439082190,   1244786747,    941120547,    -35568474,   1756370964,    304870369,   1902684028,   -408710726,   1673189520,   1180987663,          -1488131864,    158973303,    154514890,  -1387953397,   1453732833,  -1342263302,   -628153633,      4710424,    619931109,    721411332,  -2135645486,   1688696681,   -891749588,  -1641122924,   1397432310,   -865254619,          -1635468227,  -1827787970,  -1311416657,  -1022618057,   1411688086,  -1579840139,   -637954674,   2115653281,  -1155985079,  -1043532593,   -374286955,  -1825883832,   -227940643,   1688394137,   -524577925,   -983222470,          -1955769926,    626525757,  -2009760930,  -1855453635,   -676923169,    754966926,   -291202391,  -2126042921,  -1477304277,  -1409345382,  -1264640578,   -441993991,    -17611930,  -1576809974,   2137694350,   1299022733,           -762509116,  -1087399293,    819303572,    -14571174,   -719035481,  -1644675278,   1492736905,    -15038081,    974773023,   1087127339,   1790024863,  -1493135734,   1936273291,   -442361741,   1639666948,   1147532756,            174955156,  -1537685747,    187972574,    275303083,   1420277149,  -1375787574,   1873043153,     38164241,    653451946,    687758113,    899667071,   1722219976,   2146668333,    587401069,    -26582672,   2034645447,           1401801794,   1043291001,  -1277898614,   2116116828,   1445274301,    150534325,    469242183,   -937704471,    171074779,   -204638071,   1269913689,   -771734064,    -12280461,  -1182158859,   1704390140,   -263303749,           -848503723,  -1822849148,   -634064465,   1130988864,  -1515750310,   -908815400,   1487214333,    994482967,    853103628,   1711185413,   1520342001,   1067859186,   1693632130,   -603831333,    292236742,   -800655385,          -1467184928,    221125007,  -1697377800,   1293953144,   1730537111,   1073329737,    519625212,    689636032,   1127394154,  -1496469136,  -1214585810,    822152197,  -1572579275,   -527866383,   -996792678,  -2058452887,          -1133767559,    576275042,   1579109209,   -295089371,   1502267384,   -724281876,   -911879875,   1131096177,    333026744,   1238706603,   1067340063,   -745697708,   -973992204,   1560446744,   -664017057,   -616056490,           1099714049,    674159948,    383625825,   1411443110,   1862818263,  -1896254899,   1322476914,   -719144734,  -1540101945,    988154902,    781856577,   2013381051,  -2059071359,   -142073207,     60252832,   2052050421,           -666391497,    376633738,   1663011481,  -1706886481,  -1870003191,   1003819645,    898131216,    778824906,   -656875645,  -1730811011,  -1751653787,   2056079904,    231977636,   1831419220,   -465545074,  -1505266471,           1034419975,   -133864043,   1876779821,   1879792902,   -100100435,   -959264741,   -472668436,    203584096,    -46980157,  -1478047098,   -979669209,    809008494,   1279644171,   2055793632,   1385672419,  -1756428826,          -1790481031,  -2089665073,  -1608595011,    457322987,   1267418945,    -19541848,   -796352273,  -1049973752,     30940894,   -539710199,  -1097391703,   -779353550,  -1328320498,   -735447662,   -918513196,   1516945649,           1218919237,   -251287485,   1826366637,    353082340,    889839220,    399638904,  -1462573609,   -618450466,   1429903706,   2095548034,   1486594475,  -1053248922,     74346322,   -357998703,   1790710495,   -146359619,           1581657509,   -797737661,   -920778913,    608399665,    646679359,   1861775150,  -1014371223,    476735306,  -1577737028,    383018939,   1234592859,    344770283,   -472763155,    187217985,   1245828866,   1936329359,             61243025,  -1979390025,    903671173,    302699505,  -1677126111,  -1194113496,    835857595,    706998946,     70931462,   1374113464,  -1464459699,   -231081598,   1366205112,    396990527,  -1615015619,   -968458597,            457632575,     24361353,  -1120685182,   2101590608,   1654666456,  -1208442054,    579414359,   1078056578,    217408674,  -1560683025,    815178420,   1219326466,    450032327,    774403237,     54597342,   -664057229,            447132403,     50603973,    435640301,  -1224073863,  -1339908037,   1775470944,  -1378119263,  -1375189988,  -1287971162,     29816317,  -1313418882,  -1824967031,    443540716,     11064217,  -1463969487,   1967601549,            124474667,   1230898256,  -1741455555,    561643750,    933295231,   -923145874,    245538199,    289478386,    200552280,   -268887021,  -1598221376,   1236123270,    318325803,    773964550,    191670680,    158043961,           -762639146,   -416703928,   -721969492,   1664330785,   -584949010,   1509045840,  -2066001147,   1728613092,  -1103375821,  -1262079070,  -2034789427,   -418216342,   -546365126,   1235751589,   1639799329,   2085089663,           -697590049,  -2007054256,   -147701903,    209371702,  -1868450893,   1241065116,   1537364837,  -1035970557,    318040217,    150492098,   1841159805,   -491979749,  -1275490577,  -1759443566,   -697538216,  -1589624976,           -678703557,   -189067001,   1539472677,  -1396089831,    271512148,    180483983,    483714313,    703861378,   2122114992,   -600097045,    522009268,    160429181,   -744428886,   1541223403,  -1211039718,  -1167643980,           1551471162,   -816207368,  -1429258613,   1350901561,   1934120609,   -961643277,   -214772286,  -2128270227,  -1561239720,   1493926966,   1376671007,     94966082,    221846150,   -164351411,    -51309876,    497148497,           1233668542,    266257753,   -773473851,    953946385,    420815294,  -1390653175,   1834391782,      4704447,   -891751440,   -744104272,  -1082756642,   1431640408,  -1912055536,   -159789461,   -704946016,   1956368139,            642279822,   -374415338,   1562655802,   -272964020,   1071498305,    667364168,  -1546405154,    341389690,   1360662999,    377696332,   -437020076,  -1668574556,   1242655350,   -756555890,    645954261,   1914624235,           2134904445,   -247737098,    143667521,    -17668806,   1804148531,    414247300,   1030053929,  -1595215075,    887532426,    553113691,   1173830167,   -303724353,   -280418143,  -1143962122,  -1898518451,     36464746,           1189572700,  -1549967582,   1093341440,   -452303819,   -731023001,   1111173883,   1678013973,   -836458212,   -842956392,    212774049,   -845621791,    966282353,   -823130040,    700410571,    619075141,   -304785045,          -1816233676,  -1789653997,   -166914694,    690663021,   -669570330,   1098624444,   -987380984,    452844935,  -1089825546,   1221160503,   1217375341,    512281644,  -1106887134,   1665404458,  -1462594714,   -207498587,           -789271490,   -723469709,    512055365,   1445951882,   1692473633,   -996873493,   1445046730,    993087194,  -1666188562,   -897427329,   1008869698,   1236029718,   1499207233,   1704947182,  -1815799281,    686399988,           -475436580,   1588892458,    884859588,   -471913926,   -487416631,   1323960741,  -1257612174,   -468909314,  -1866654496,  -1417895838,   1707647971,    997140465,  -1358794225,   1929422460,   -605622778,  -1587468566,            469149623,   1121515927,    748484204,   1201983830,  -1906623591,     76398473,    261109068,   -796025669,  -1964466661,   1739898262,   -756850622,   1581369453,   1484675811,    484136467,   -705983890,  -1357931714,            548520423,    741992908,   1017931838,  -2078503520,   2097871343,    569233897,    -91903627,   1864053450,   -876129714,    336670307,  -1950420274,   -872316480,   -662220291,    275724295,    703565412,   1334248646,           -217559198,   1044090753,    743502488,  -1518545318,     20614180,   -768582053,    976522354,    -25129962,   -983639284,     71722595,   -119236393,    368844119,   -795808244,    696073964,   1379765302,    235083623,            666280330,  -1313689346,   -643870520,    534522699,   -250414377,  -1239276164,    159264592,  -1119503518,   1168161619,  -1366518946,  -1335653301,    248092140,   1390152547,   2051602724,  -1023547981,  -1479782621,          -1785785862,   1609789158,   -919124123,   1703200068,   -852553456,   1573706142,   -376011685,    305068766,  -1231775451,  -1536883494,   -125122369,   -896696968,    852651567,   -458154391,    747781704,   1173040469,          -1569200836,    312506093,  -1680530410,    117086271,    794587661,  -1231003908,  -1048955503,   2119305423,   1636729108,   -522378372,   1627421730,    545077470,  -1683264872,   1486496559,  -1793064672,   1908368749,          -1226052295,   1399248776,   -588193954,  -1289386125,    534647065,   2126245059,   -238362987,  -1244573058,  -1571832269,  -2052693379,   1494767731,   -528668449,   -980826491,   -151282847,  -1468523556,   1876349941,           -301654558,   1467960576,   -741720848,   -612158589,     92376910,    987915105,   1037689578,    793773489,  -1387669541,    349490139,    564784004,  -1161242130,    619703053,   2063233129,    190888106,     81845991,          -1482466066,    283234313,    114355492,  -1879406787,  -1283370924,  -1378903370,   -730141747,   1570738286,   -281348873,   2131743196,    795654462,   -497365688,    437612465,   1928618254,   1433118279,  -1801292119,          -2059248836,   -221673230,    163637697,   -411319468,    244353317,    786753178,    489172932,    464627154,   1258915212,   -229028334,   -994675463,   1931657329,   1784181437,    -97111947,   1728952452,  -1329133577,          -1606156362,   1341196121,   1679632329,   -796545286,  -1021125869,   1427825468,   -214986389,    250791528,   1029777000,     90661677,    602529506,   2068040879,   1483801763,      2332097,   -457467017,    672399614,           1542769193,   1781253216,  -1967165705,  -2052227925,  -1248173215,  -1676554121,    292413596,    209649573,   1750689340,   1946874730,   -832845570,   1774178655,   -450175610,   -431901779,    613330756,   1969434259,           1251099237,  -1320908513,    -50659188,    273178515,   -296290724,   1195998469,   1329813722,    759419114,   1003396150,   -274557619,   -548886303,  -2055397788,   -766678640,   -464045978,  -1835907569,   -169406709,            820751456,   1778613303,  -1582073956,  -1728391771,  -2075389498,  -1606584632,  -1702107251,    -15724560,     45610235,  -1967510298,   -671487775,  -1841110041,   -913365944,    869680052,   -798103472,  -1564096927,           -918899909,   -810066882,    428829752,  -1413487973,   -844240890,   1343914280,   -689285374,   1827745702,   -799686631,   1696465705,   -726159000,  -1381157526,   1649221296,   1791106481,  -1872852642,   -485685063,           1534949133,  -1611901907,   -581776031,    242740701,   -382394666,    668419384,    388297992,    748818886,    713804061,  -1783774172,  -1823401590,  -1009098384,   2071462929,   1154475522,   1309810666,  -1734475040,           1212095416,    988288210,  -1457428115,   1699730041,  -1804729443,  -1922824494,   1000076038,   -226555981,    131425181,  -1071582828,    357680377,   1574190179,    996651958,    965704429,    -47651768,    243931978,            808955117,   -652323633,    544967309,  -1199510217,    702795379,    997685748,   1593927308,   2119371055,   1451401230,    -41992913,   2033816081,  -1030495962,   1764010175,    457470691,  -2001190141,   -373358035,          -1950331268,  -1291674220,    642934467,  -1825725718,  -1555687487,   1664472129,    -24722338,   1899539596,     78519318,   1662555805,   1744711308,  -2142888582,  -1597853572,    118030659,   1596713428,    404304267,          -1350880388,    648702031,   1185458591,   1798138033,    819516445,  -1466759682,   -751277607,   -879817426,  -1931050435,   1465603177,  -1402344216,    768491239,  -1404853657,  -1915685264,  -1845859847,    313163207,           1239598382,   1988767047,   -555152530,  -1925665864,   -182399255,  -1392390808,     64861291,   -511875035,   1879964459,    918905020,   -840773616,    459610189,  -1522352470,  -1821396360,    977274705,    -60616465,          -1846727880,   1208592937,   -515359427,   1127607806,   -395032287,    491869604,   2053794084,    568321750,   1597027438,   1355613070,  -2069482724,   1899252555,    844726247,   -625112193,   1146099491,  -1037855139,           1203928737,   1875686061,    994108281,   1471873396,   2026801570,      4941446,  -1066074241,   -983738686,   2037429697,   -836521112,   -633388883,   1221918725,   2137035208,   -369891832,    372509548,   -110916409,             80517712,   -658056946,    727893428,  -1353651002,   -475459562,   -291323023,   1059377566,    591801919,   1018232602,   -348255729,   1863827426,    246032476,  -1026132864,  -1356383176,  -1224690998,    262442981,           1257773681,  -1738604660,     77131430,  -1320261233,     -2342727,  -1817187590,  -1883997191,   1367221809,  -1863623746,  -1132606249,    149024763,  -1228275128,   -578030399,    356914163,   2109691820,   -880313621        };        for (int i = 0; i < refInt.length; ++i) {            Assert.assertEquals(refInt[i], mt.nextInt());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import org.junit.Assert;import org.junit.Test;public class Well19937aTest {    @Test    public void testReferenceCode() {        int[] base = {              740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,            -1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000,             -595495729,  1047766204,  1875773301, -1637793284,  1379017098,   262792705,   191880010,  -251000180,            -1753047622,  -972355720,    90626881,  1644693418,  1503365577,   439653419,  1806361562,  1268823869         };        int[] init = new int[624];        for (int i = 0; i < init.length; ++i) {            init[i] = base[i % base.length] + i;        }        Well19937a mt = new Well19937a(init);        int[] refInt = {            -612874471,   -354976292,  -1838197125,  -1781560577,    278390997,   1214938280,  -1752615390,   -760835246,  -1712883765,   -241205782,   -145390202,    495649160,   -514388259,  -1271015916,  -1640000013,    849273623,            -549729394,  -1206917255,   -545909692,    811925434,  -1665729633,  -1525292882,   1416246482,   -153220826,   1148868872,   -326143196,   1724979062,   1790931148,  -1648679618,   -439051683,    112482777,  -1484051520,           -1881272572,  -1270447031,  -1216102401,   1579107248,  -1224395621,   2144411988,   -416216641,  -1529222361,   1628987080,    164445245,   1506928916,    928145916,   1436000427,    862025970,    560077705,  -1887251027,            -514360858,   1735094506,    475624879,   1755802355,    295448361,   -155399225,      3972415,   1368201076,   -465126094,  -1622687259,   -246099304,   1798631152,  -1937269102,  -1700560396,   -293352622,   -896632303,           -2088933220,   -194382452,   -480218162,  -1618517785,  -1925031481,   -150217434,   1678937261,   2130832364,   -485546678,  -1499224981,   1430390884,  -1895417302,    210514746,   1781140999,  -1940853105,  -1238099647,             485922557,   -103223212,    633481679,   -632946979,    695235541,  -1661735272,    277603567,   -958341538,    256982285,   1850270018,   -327388076,   -219053874,   1380560653,  -1221689980,   1335863752,   -545032383,            -575291735,  -1295623907,   -140058298,   1063302709,  -1290702617,   -790401546,   -170630961,  -1203114473,   1458063108,  -1212753301,   1546428514,   2112636413,  -1463028928,  -1812598032,   -883529486,   1131084094,              62042165,   2135819802,  -1192342739,     98361522,  -1341042205,   -475283063,  -1632033747,   1745196892,    168608689,   -914987039,    274428907,   -881357258,    167940012,  -1975737532,   -903960486,  -1370984244,            -589352935,   1783633514,   -570111010,     71495377,    194463285,  -1243905021,  -1398490898,    221691209,    -55728834,   -638916786,   -770622372,  -1911651810,   -295233027,    301467998,   2058638784,    681490183,           -1547865078,  -1668135684,   1299261826,   1649468635,    287995017,  -2076844852,   1193468826,   -853948258,    120082777,   1051829542,  -1288514343,   -159456430,    275748820,   -480127107,   -604943233,  -2138088332,            1202614819,   1427201263,  -1906344469,  -1230779533,   1690367192,    733159097,    794410312,  -1114452505,  -1601554413,    976747949,   1517787154,   2091780205,   1052078906,   1919282771,   -191013374,   1805397142,             736939268,  -1056272823,   -727464316,   -659459005,    797803875,  -1104633884,   1042342081,    -24514837,   1919469940,   1903722546,   -814157872,   1605407665,   -262351256,   -288949635,    729204844,  -1132605534,             745453338,    387915035,   1094173337,   2100279147,    156863702,   -257377544,   -719587984,  -1496015613,   1908993744,   2016957554,    918749666,   -135963651,  -1356808639,  -1711185741,   1472589240,   -398100149,             628791415,  -1381837652,  -1820702771,   -593586943,  -1456631279,  -1837975351,  -1394249972,   -556916726,    833231177,     43449750,   1029237092,  -2086437337,   -459463076,   -533031784,  -1739648287,  -1374722961,            2024908394,   1389678488,      2018558,  -1391707864,   -795935743,    904816957,    836583280,   1766194531,  -1374431014,   -904437876,   2030248636,   -265724199,   2056758426,   -810499837,    887193593,    -77811488,            1496312336,  -1874348275,   -456193866,  -2137130942,    868120387,     29025455,  -1999867716,   2001322335,   -579152815,   -390892056,   1592011837,   -306394879,     93636886,   -190879994,   1923358153,    269052141,            -396050253,   -987531729,    480350991,   1276744541,  -1445571957,   -957571005,  -2046270221,  -1715395752,   1113585628,  -1782113514,   -697560146,    835320000,   1014320959,  -2119834109,    460056841,  -1464772991,           -1282790418,  -2120806165,     86176097,   -731086307,    832497517,  -1876684928,    541008240,    551124479,   -450919132,    647860281,  -2115397586,    979247589,   1095559204,   1927958688,    169497703,   1999579054,            2019745038,   1656022059,  -1109662138,    375237154,   1450814436,    919988416,    849761266,   1457057327,   1771166577,  -1639880487,   -852488298,   1767063646,    657295386,   -585561879,    740792583,   1664558308,            -654749506,   1109275990,    182597559,   1106789745,  -1806628480,     25948116,   1748374299,    196057325,   -164213209,   1687024594,    782029276,   1879737947,  -1528219611,    412585737,   1190325629,   1985821911,           -1272945202,  -1238637137,    465818730,  -1537670961,   1131953615,    905623579,    609183424,   1138422991,   1522974699,    589719061,  -1310894604,    890952933,   -885204790,   -393535694,   1238408670,   1780660354,             677803525,  -1121509064,   1553148616,   1109165936,  -1450120385,   1525252521,  -1354897489,   -595402189,  -1274551767,   -869281409,   1788815975,   2020262116,   1124100185,   -400839020,    310574108,   1354413045,           -1310514485,   1895732085,    626639054,   1667355357,   2065637178,  -1889009143,   -440157749,   1762849463,  -1693853642,    -56602956,   -930874188,   -398470740,    778356402,  -2113156881,     42854964,   1844399604,           -2098310302,  -1812029757,   1441188713,    899579267,   1266994172,   1841370863,   -660740252,    -43254718,   1124500192,   1884907320,    879997211,   1775139845,  -1360112721,   1630490057,    362567879,   1113475029,             290319279,  -1209506867,    398146039,   -957742350,   1185761854,   1519676447,   -912689915,  -1117128973,   -305563462,  -1928033363,  -1766324543,   1702753492,   1696951912,  -1895072395,    932663591,   -566548128,             991675996,     56529814,    980735023,    718166662,   -650028466,   -886842051,   1857048587,   -569023569,  -1820572202,   -851452711,   -958700452,   -621825633,    -65649888,   -510143183,    761267599,  -1692108035,            1729071710,   1623630864,    -53498654,    267235687,    659201413,   1152882627,   -824194574,    356636960,   -502391121,   -538453360,     66115376,  -1633290370,  -1522088932,    268949070,    684499443,   -859474501,            1586764345,  -1515639709,    319695602,   -307025150,     69076508,   1050726785,  -1340930110,    552191600,   -207852941,   -273572993,   -539580440,    710343120,   1957076127,  -1107172811,   -561518280,  -1775022699,            1978792904,   1935531451,  -2084046304,   -419742902,   -737652926,    614022023,   1676952428,    769892939,  -1092786807,  -1117113223,   -266029995,   -350150999,    207738542,   1964896575,     48805284,   1736500159,             551289617,  -1847923501,   1856609505,   2007480480,   -681860219,  -1198106493,   1483591043,   -523895316,  -1814473078,  -1521087404,  -1348859926,   1298056897,   1813789478,    946683654,     79196400,   1766250931,             472737685,   1764634332,  -1844726079,   -130619045,   -508713868,  -1762537125,   1010108863,    170107098,   1705386380,  -1139681802,    183739097,   1662699401,   1842694501,   1714633805,     46208876,    616720693,            -252553427,   1986302230,   -103130254,   1943225981,    110746655,    553260552,   1588938073,  -1934623163,  -2144781332,  -2086217416,   1941265852,   -781953226,   1216234254,    605543697,   -710872598,   2048636577,           -1986927728,  -1007017623,   1243051501,   -614249563,  -2128221291,    581579813,   1173464240,  -1906830937,    261329601,  -1805974103,    769823490,   1858731164,   -561762071,    516417430,  -1221329437,   -825500715,            1091364656,   -993658663,  -1475434188,  -1070804384,  -1876492082,    899494424,    683486936,    878807455,     56642807,  -1268202879,   1379172046,  -1386869373,  -1158233876,   1759190552,   1597629789,   1411151497,           -1254268471,   1075936979,   -918778269,  -2132675184,    953140888,   1906982077,   1154200766,   -365384600,  -1142488826,    708535121,  -2134869964,  -1531201665,  -2100526761,   1268256467,   2071480803,    193135243,            1374158182,    989505347,   -933612202,  -2134839213,  -1302795271,  -2092029041,   1812014826,   2090855917,   2005348528,    606434393,    -60141386,     11156360,    539516285,   -122485034,   -893237911,   -978127424,            1509901816,   -451029719,    428544700,  -1622965963,  -1993611605,  -1989324583,   1104111587,   -795138585,   -899552401,  -2110167769,   -234502445,   1586963605,   -503778455,    529261062,    325327284,   -106186403,              65369563,  -1475700698,   -228624261,    715975009,   1099352363,  -1796883396,   1376542700,   -308942420,   -344940451,   -395389249,  -1562737166,   1869802677,   1273494710,   2075587668,   -789570273,   1563347596,            1142901755,   1676422422,  -1729157809,  -1399423717,  -1814262429,  -1809707284,   1393992342,   -570246212,   1065528749,   -781643849,   1218667301,  -1097949471,   1305629790,    901301039,   -704762030,    360582612,            1411910672,   1848068741,   -614500891,   -146889637,   -913903597,    723527277,   -147033328,   -199273155,    734997691,  -2072735286,   2129258691,  -1385074104,    931616624,   1065477319,  -1543474555,   -531410292,           -2123119121,  -1538464113,  -1153585193,   1559931968,   -654877011,    879865200,   1489681397,   1998864644,  -1964160144,    163671782,   -858364148,   -323324233,    801208648,    705864113,    436184243,    643773864,            2087594507,    134637265,   -749956494,  -1657343972,  -1828172168,    -27357303,  -1145161336,  -1192513644,    216148260,    611393153,    -13752671,   -358631090,  -1211920749,    593572064,    657629904,  -1445961088,            -250704995,   1797542707,  -2122311891,   -316774825,   -296303057,   -868002056,    -86697533,   2020588145,   1203427903,  -1371839056,    669531557,  -2031033836,   1323994690,     13703036,    785437772,  -1465821554,            -694756014,  -2131068154,  -1745448876,  -1095891733,    936594025,  -1119068454,    855423970,   1705079340,   -905640608,    162297141,   1336619311,   -344353769,    -92608588,  -1080573824,   2002293105,  -2088030765,           -1684198727,   -129054718,   -949437132,   -127983221,   -216664110,   1700146143,   -711174649,   1500113839,   1212236226,  -2017364219,  -1263597675,    511929344,   -323998524,  -2021313185,   1803000924,    927670608,             336267187,   1244256964,  -1665390108,    991395134,   -251232188,   1267445783,   1547951569,    740269916,   1776431169,   1687220659,    228229817,    271386089,   -682906779,   -438090344,   1190436796,   -744272540,            1879221151,   1145200306,  -1730983338,  -1119209309,     90826726,   1567861540,   1638852830,  -1645384932,   1566909531,   1088584561,   1030555565,  -1872052014,    720320695,   -885053674,   -321216789,    739907579,             368580703,   -443635520,   1232705619,  -1355949988,  -1047211249,  -1571429448,    599299852,   1036970439,   1513838571,    -51797291,    -26647565,  -1262878942,   -916262582,   1579082269,   -292007383,   1289013866,           -1612184284,   1451738668,    448608569,    476432992,  -1229609565,    786372409,    929928149,   -150100614,    448155944,  -1322320576,   -856549627,   1057443268,  -1536809554,    577508258,    584906122,    275295163,            -604262071,   -236043234,  -1866434954,  -2072447013,    646132876,    847562546,   -310005953,  -1104162658,    393261203,   -730102354,    440824482,   1654535035,  -1296359745,   1487359328,   -977776604,   -775827779,           -1298695106,    519080622,   1697162240,    227873031,   -371123123,   1273702312,  -1710063656,  -2138342344,   1139555478,   1531578907,  -1498880699,   1183507362,   1875307493,  -1649740413,   2135386504,   -962458407,             424161768,    504272962,    202204247,   1783466420,   2015579232,   -676642965,   2067456450,    914480415,   -620398841,   1880405399,   1406637142,   1951104977,    633496157,    224861869,    -58659291,    994942775,            -479000645,   1421449115,    100168104,    249754169,  -1219011494,   1736303638,    364013694,  -1750035055,   -479217141,   1652913106,  -2109452331,   1633842910,  -1547663337,    936627493,  -1152799743,    896955899,           -1407742850,   -523769014,    357161414,    872293304,    744895980,    720829676,   -240843156,   -111779524,   1292836315,  -1792141538,   1946959925,   1181751089,  -1120674052,   1185192575,  -1387002557,   1973209255,            -120887476,   -766577735,   -443913073,    786620227,    428564781,   -101232106,   -425959852,    198082021,   1173272226,  -1744840378,  -1621135606,  -1539498583,  -1101274572,     43399711,  -1256764602,   1201920787,            2049426139,    846545551,  -2121520873,  -1202939675,   -470425740,    321987390,   1862019060,   -951540342,   -894238318,   -430407175,  -1662746491,    656574776,   1580373777,   -431290218,   1645824323,  -1953526979,            -374682356,    474291752,   1071558425,    511038981,   -760598678,   -567797285,  -1176476266,   -268409005,  -2130644484,    -67970563,   1756046948,   1429860462,  -1130984739,   -124916495,  -1544436836,  -1863524031,            1024916487,  -1388636482,  -1573205065,    892628956,   1831270021,   1176430590,   1158914682,  -2006787098,  -1228130033,   1516111488,  -1499151347,    470546266,   1642603981,   1425140838,  -1823071475,  -1775267236,           -1009380612,    164746986,   1129677098,   1842642579,   -482342932,   -507480364,   1656012309,   1981601761,   -881042120,   -511987083,    342447017,    381192578,    983008095,    741012865,  -1877136350,   -199211983,            -452784912,   1929572576,  -1678291139,   -864375281,  -1610561247,  -1936356726,   -749553767,   -865893512,   -567081879,  -1303973729,   -939636958,   -622974563,    428284937,   1049237414,    852280765,     86648946,           -1353851401,  -1045422335,    898035731,  -1636093996,  -1083174191,    245046915,   -359768226,  -1028491655,   1051575118,   1774289451,   1839389415,  -1594053468,    736707953,   1873556950,    401186168,   -583669552,             -88375334,   2002752071,    264506453,  -1304812107,   -759203942,   -114958524,  -1878903503,    841613720,   1910863820,  -1738114003,    701455920,   1791058048,  -1850960547,   1672292671,   1172188809,    604848896,           -1607489375,    305370478,   -948153885,  -1971080100,  -1848966954,   -584538365,     39416319,  -1689119162,    944942598,   1777111075,   1534005553,   2022718432,    -25820385,      3077695,   -315950520,   1859184648,           -1397829266,  -1666371809,    858913807,   -610818620,   1554973298,    580023809,  -1662988256,   -408630026,   1316681876,    738204271,    942829881,   -758486983,    780345857,    667165037,  -2086803585,    789741324        };        for (int i = 0; i < refInt.length; ++i) {            Assert.assertEquals(refInt[i], mt.nextInt());        }    }}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.random;import org.apache.commons.math.stat.StatUtils;import junit.framework.*;public class GaussianRandomGeneratorTestextends TestCase {    public GaussianRandomGeneratorTest(String name) {        super(name);    }    public void testMeanAndStandardDeviation() {        RandomGenerator rg = new JDKRandomGenerator();        rg.setSeed(17399225432l);        GaussianRandomGenerator generator = new GaussianRandomGenerator(rg);        double[] sample = new double[10000];        for (int i = 0; i < sample.length; ++i) {            sample[i] = generator.nextNormalizedDouble();        }        assertEquals(0.0, StatUtils.mean(sample), 0.012);        assertEquals(1.0, StatUtils.variance(sample), 0.01);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import java.text.DecimalFormat;import java.util.ArrayList;import java.util.HashSet;import java.util.List;import junit.framework.AssertionFailedError;import org.apache.commons.math.RetryTestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.distribution.BetaDistributionImpl;import org.apache.commons.math.distribution.BinomialDistributionImpl;import org.apache.commons.math.distribution.BinomialDistributionTest;import org.apache.commons.math.distribution.CauchyDistributionImpl;import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;import org.apache.commons.math.distribution.FDistributionImpl;import org.apache.commons.math.distribution.GammaDistributionImpl;import org.apache.commons.math.distribution.HypergeometricDistributionImpl;import org.apache.commons.math.distribution.HypergeometricDistributionTest;import org.apache.commons.math.distribution.PascalDistributionImpl;import org.apache.commons.math.distribution.PascalDistributionTest;import org.apache.commons.math.distribution.PoissonDistribution;import org.apache.commons.math.distribution.PoissonDistributionImpl;import org.apache.commons.math.distribution.TDistributionImpl;import org.apache.commons.math.distribution.WeibullDistributionImpl;import org.apache.commons.math.distribution.ZipfDistributionImpl;import org.apache.commons.math.distribution.ZipfDistributionTest;import org.apache.commons.math.stat.Frequency;import org.apache.commons.math.stat.descriptive.SummaryStatistics;import org.apache.commons.math.stat.inference.ChiSquareTest;import org.apache.commons.math.stat.inference.ChiSquareTestImpl;import org.apache.commons.math.util.FastMath;/** * Test cases for the RandomData class. * * @version $Revision$ $Date: 2009-04-05 11:55:59 -0500 (Sun, 05 Apr *          2009) $ */public class RandomDataTest extends RetryTestCase {    public RandomDataTest(String name) {        super(name);        randomData = new RandomDataImpl();    }    protected final long smallSampleSize = 1000;    protected final double[] expected = { 250, 250, 250, 250 };    protected final int largeSampleSize = 10000;    private final String[] hex = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",            "a", "b", "c", "d", "e", "f" };    protected RandomDataImpl randomData = null;    protected final ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();    public void testNextIntExtremeValues() {        int x = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);        int y = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);        assertFalse(x == y);    }    public void testNextLongExtremeValues() {        long x = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);        long y = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);        assertFalse(x == y);    }    /** test dispersion and failure modes for nextInt() */    public void testNextInt() {        try {            randomData.nextInt(4, 3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }        Frequency freq = new Frequency();        int value = 0;        for (int i = 0; i < smallSampleSize; i++) {            value = randomData.nextInt(0, 3);            assertTrue("nextInt range", (value >= 0) && (value <= 3));            freq.addValue(value);        }        long[] observed = new long[4];        for (int i = 0; i < 4; i++) {            observed[i] = freq.getCount(i);        }        /*         * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34         * for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 16.27);    }    /** test dispersion and failure modes for nextLong() */    public void testNextLong() {        try {            randomData.nextLong(4, 3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }        Frequency freq = new Frequency();        long value = 0;        for (int i = 0; i < smallSampleSize; i++) {            value = randomData.nextLong(0, 3);            assertTrue("nextInt range", (value >= 0) && (value <= 3));            freq.addValue(value);        }        long[] observed = new long[4];        for (int i = 0; i < 4; i++) {            observed[i] = freq.getCount(i);        }        /*         * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34         * for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 16.27);    }    /** test dispersion and failure modes for nextSecureLong() */    public void testNextSecureLong() {        try {            randomData.nextSecureLong(4, 3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }        Frequency freq = new Frequency();        long value = 0;        for (int i = 0; i < smallSampleSize; i++) {            value = randomData.nextSecureLong(0, 3);            assertTrue("nextInt range", (value >= 0) && (value <= 3));            freq.addValue(value);        }        long[] observed = new long[4];        for (int i = 0; i < 4; i++) {            observed[i] = freq.getCount(i);        }        /*         * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34         * for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 16.27);    }    /** test dispersion and failure modes for nextSecureInt() */    public void testNextSecureInt() {        try {            randomData.nextSecureInt(4, 3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }        Frequency freq = new Frequency();        int value = 0;        for (int i = 0; i < smallSampleSize; i++) {            value = randomData.nextSecureInt(0, 3);            assertTrue("nextInt range", (value >= 0) && (value <= 3));            freq.addValue(value);        }        long[] observed = new long[4];        for (int i = 0; i < 4; i++) {            observed[i] = freq.getCount(i);        }        /*         * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34         * for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 16.27);    }    /**     * Make sure that empirical distribution of random Poisson(4)'s has P(X <=     * 5) close to actual cumulative Poisson probability and that nextPoisson     * fails when mean is non-positive TODO: replace with statistical test,     * adding test stat to TestStatistic     */    public void testNextPoisson() {        try {            randomData.nextPoisson(0);            fail("zero mean -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        Frequency f = new Frequency();        for (int i = 0; i < largeSampleSize; i++) {            try {                f.addValue(randomData.nextPoisson(4.0d));            } catch (Exception ex) {                fail(ex.getMessage());            }        }        long cumFreq = f.getCount(0) + f.getCount(1) + f.getCount(2)                + f.getCount(3) + f.getCount(4) + f.getCount(5);        long sumFreq = f.getSumFreq();        double cumPct = Double.valueOf(cumFreq).doubleValue()                / Double.valueOf(sumFreq).doubleValue();        assertEquals("cum Poisson(4)", cumPct, 0.7851, 0.2);        try {            randomData.nextPoisson(-1);            fail("negative mean supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            randomData.nextPoisson(0);            fail("0 mean supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }    }    public void testNextPoissonConsistency() throws Exception {                // Reseed randomGenerator to get fixed sequence        randomData.reSeed(1000);                  // Small integral means        for (int i = 1; i < 100; i++) {            checkNextPoissonConsistency(i);        }        // non-integer means        for (int i = 1; i < 10; i++) {            checkNextPoissonConsistency(randomData.nextUniform(1, 1000));        }        // large means        // TODO: When MATH-282 is resolved, s/3000/10000 below        for (int i = 1; i < 10; i++) {            checkNextPoissonConsistency(randomData.nextUniform(1000, 3000));        }    }    /**     * Verifies that nextPoisson(mean) generates an empirical distribution of values     * consistent with PoissonDistributionImpl by generating 1000 values, computing a     * grouped frequency distribution of the observed values and comparing this distribution     * to the corresponding expected distribution computed using PoissonDistributionImpl.     * Uses ChiSquare test of goodness of fit to evaluate the null hypothesis that the     * distributions are the same. If the null hypothesis can be rejected with confidence     * 1 - alpha, the check fails.     */    public void checkNextPoissonConsistency(double mean) throws Exception {        // Generate sample values        final int sampleSize = 1000;        // Number of deviates to generate        final int minExpectedCount = 7;     // Minimum size of expected bin count        long maxObservedValue = 0;        final double alpha = 0.001;         // Probability of false failure        Frequency frequency = new Frequency();        for (int i = 0; i < sampleSize; i++) {            long value = randomData.nextPoisson(mean);            if (value > maxObservedValue) {                maxObservedValue = value;            }            frequency.addValue(value);        }        /*         *  Set up bins for chi-square test.         *  Ensure expected counts are all at least minExpectedCount.         *  Start with upper and lower tail bins.         *  Lower bin = [0, lower); Upper bin = [upper, +inf).         */        PoissonDistribution poissonDistribution = new PoissonDistributionImpl(mean);        int lower = 1;        while (poissonDistribution.cumulativeProbability(lower - 1) * sampleSize < minExpectedCount) {            lower++;        }        int upper = (int) (5 * mean);  // Even for mean = 1, not much mass beyond 5        while ((1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize < minExpectedCount) {            upper--;        }        // Set bin width for interior bins.  For poisson, only need to look at end bins.        int binWidth = 1;        boolean widthSufficient = false;        double lowerBinMass = 0;        double upperBinMass = 0;        while (!widthSufficient) {            lowerBinMass = poissonDistribution.cumulativeProbability(lower, lower + binWidth - 1);            upperBinMass = poissonDistribution.cumulativeProbability(upper - binWidth + 1, upper);            widthSufficient = FastMath.min(lowerBinMass, upperBinMass) * sampleSize >= minExpectedCount;            binWidth++;        }        /*         *  Determine interior bin bounds.  Bins are         *  [1, lower = binBounds[0]), [lower, binBounds[1]), [binBounds[1], binBounds[2]), ... ,         *    [binBounds[binCount - 2], upper = binBounds[binCount - 1]), [upper, +inf)         *         */        List<Integer> binBounds = new ArrayList<Integer>();        binBounds.add(lower);        int bound = lower + binWidth;        while (bound < upper - binWidth) {            binBounds.add(bound);            bound += binWidth;        }        binBounds.add(bound);        binBounds.add(upper);        // Compute observed and expected bin counts        final int binCount = binBounds.size() + 1;        long[] observed = new long[binCount];        double[] expected = new double[binCount];        // Bottom bin        observed[0] = 0;        for (int i = 0; i < lower; i++) {            observed[0] += frequency.getCount(i);        }        expected[0] = poissonDistribution.cumulativeProbability(lower - 1) * sampleSize;        // Top bin        observed[binCount - 1] = 0;        for (int i = upper; i <= maxObservedValue; i++) {            observed[binCount - 1] += frequency.getCount(i);        }        expected[binCount - 1] = (1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize;        // Interior bins        for (int i = 1; i < binCount - 1; i++) {            observed[i] = 0;            for (int j = binBounds.get(i - 1); j < binBounds.get(i); j++) {                observed[i] += frequency.getCount(j);            } // Expected count is (mass in [binBounds[i], binBounds[i+1])) * sampleSize            expected[i] = (poissonDistribution.cumulativeProbability(binBounds.get(i) - 1) -                poissonDistribution.cumulativeProbability(binBounds.get(i - 1) -1)) * sampleSize;        }        // Use chisquare test to verify that generated values are poisson(mean)-distributed        ChiSquareTest chiSquareTest = new ChiSquareTestImpl();        try {            // Fail if we can reject null hypothesis that distributions are the same            assertFalse(chiSquareTest.chiSquareTest(expected, observed, alpha));        } catch (AssertionFailedError ex) {            StringBuffer msgBuffer = new StringBuffer();            DecimalFormat df = new DecimalFormat("#.##");            msgBuffer.append("Chisquare test failed for mean = ");            msgBuffer.append(mean);            msgBuffer.append(" p-value = ");            msgBuffer.append(chiSquareTest.chiSquareTest(expected, observed));            msgBuffer.append(" chisquare statistic = ");            msgBuffer.append(chiSquareTest.chiSquare(expected, observed));            msgBuffer.append(". \n");            msgBuffer.append("bin\t\texpected\tobserved\n");            for (int i = 0; i < expected.length; i++) {                msgBuffer.append("[");                msgBuffer.append(i == 0 ? 1: binBounds.get(i - 1));                msgBuffer.append(",");                msgBuffer.append(i == binBounds.size() ? "inf": binBounds.get(i));                msgBuffer.append(")");                msgBuffer.append("\t\t");                msgBuffer.append(df.format(expected[i]));                msgBuffer.append("\t\t");                msgBuffer.append(observed[i]);                msgBuffer.append("\n");            }            msgBuffer.append("This test can fail randomly due to sampling error with probability ");            msgBuffer.append(alpha);            msgBuffer.append(".");            fail(msgBuffer.toString());        }    }    /** test dispersion and failure modes for nextHex() */    public void testNextHex() {        try {            randomData.nextHexString(-1);            fail("negative length supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            randomData.nextHexString(0);            fail("zero length supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }        String hexString = randomData.nextHexString(3);        if (hexString.length() != 3) {            fail("incorrect length for generated string");        }        hexString = randomData.nextHexString(1);        if (hexString.length() != 1) {            fail("incorrect length for generated string");        }        try {            hexString = randomData.nextHexString(0);            fail("zero length requested -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        if (hexString.length() != 1) {            fail("incorrect length for generated string");        }        Frequency f = new Frequency();        for (int i = 0; i < smallSampleSize; i++) {            hexString = randomData.nextHexString(100);            if (hexString.length() != 100) {                fail("incorrect length for generated string");            }            for (int j = 0; j < hexString.length(); j++) {                f.addValue(hexString.substring(j, j + 1));            }        }        double[] expected = new double[16];        long[] observed = new long[16];        for (int i = 0; i < 16; i++) {            expected[i] = (double) smallSampleSize * 100 / 16;            observed[i] = f.getCount(hex[i]);        }        /*         * Use ChiSquare dist with df = 16-1 = 15, alpha = .001 Change to 30.58         * for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 37.70);    }    /** test dispersion and failure modes for nextHex() */    public void testNextSecureHex() {        try {            randomData.nextSecureHexString(-1);            fail("negative length -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            randomData.nextSecureHexString(0);            fail("zero length -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }        String hexString = randomData.nextSecureHexString(3);        if (hexString.length() != 3) {            fail("incorrect length for generated string");        }        hexString = randomData.nextSecureHexString(1);        if (hexString.length() != 1) {            fail("incorrect length for generated string");        }        try {            hexString = randomData.nextSecureHexString(0);            fail("zero length requested -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        if (hexString.length() != 1) {            fail("incorrect length for generated string");        }        Frequency f = new Frequency();        for (int i = 0; i < smallSampleSize; i++) {            hexString = randomData.nextSecureHexString(100);            if (hexString.length() != 100) {                fail("incorrect length for generated string");            }            for (int j = 0; j < hexString.length(); j++) {                f.addValue(hexString.substring(j, j + 1));            }        }        double[] expected = new double[16];        long[] observed = new long[16];        for (int i = 0; i < 16; i++) {            expected[i] = (double) smallSampleSize * 100 / 16;            observed[i] = f.getCount(hex[i]);        }        /*         * Use ChiSquare dist with df = 16-1 = 15, alpha = .001 Change to 30.58         * for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 37.70);    }    /** test failure modes and dispersion of nextUniform() */    public void testNextUniform() {        try {            randomData.nextUniform(4, 3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            randomData.nextUniform(3, 3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }        double[] expected = { 500, 500 };        long[] observed = { 0, 0 };        double lower = -1d;        double upper = 20d;        double midpoint = (lower + upper) / 2d;        double result = 0;        for (int i = 0; i < 1000; i++) {            result = randomData.nextUniform(lower, upper);            if ((result == lower) || (result == upper)) {                fail("generated value equal to an endpoint: " + result);            }            if (result < midpoint) {                observed[0]++;            } else {                observed[1]++;            }        }        /*         * Use ChiSquare dist with df = 2-1 = 1, alpha = .001 Change to 6.64 for         * alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 10.83);    }    /** test exclusive endpoints of nextUniform **/    public void testNextUniformExclusiveEndpoints() {        for (int i = 0; i < 1000; i++) {            double u = randomData.nextUniform(0.99, 1);            assertTrue(u > 0.99 && u < 1);        }    }    /** test failure modes and distribution of nextGaussian() */    public void testNextGaussian() {        try {            randomData.nextGaussian(0, 0);            fail("zero sigma -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }        SummaryStatistics u = new SummaryStatistics();        for (int i = 0; i < largeSampleSize; i++) {            u.addValue(randomData.nextGaussian(0, 1));        }        double xbar = u.getMean();        double s = u.getStandardDeviation();        double n = u.getN();        /*         * t-test at .001-level TODO: replace with externalized t-test, with         * test statistic defined in TestStatistic         */        assertTrue(FastMath.abs(xbar) / (s / FastMath.sqrt(n)) < 3.29);    }    /** test failure modes and distribution of nextExponential() */    public void testNextExponential() {        try {            randomData.nextExponential(-1);            fail("negative mean -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        try {            randomData.nextExponential(0);            fail("zero mean -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        long cumFreq = 0;        double v = 0;        for (int i = 0; i < largeSampleSize; i++) {            v = randomData.nextExponential(1);            assertTrue("exponential deviate postive", v > 0);            if (v < 2)                cumFreq++;        }        /*         * TODO: Replace with a statistical test, with statistic added to         * TestStatistic. Check below compares observed cumulative distribution         * evaluated at 2 with exponential CDF         */        assertEquals("exponential cumulative distribution", (double) cumFreq                / (double) largeSampleSize, 0.8646647167633873, .2);    }    /** test reseeding, algorithm/provider games */    public void testConfig() {        randomData.reSeed(1000);        double v = randomData.nextUniform(0, 1);        randomData.reSeed();        assertTrue("different seeds", Math                .abs(v - randomData.nextUniform(0, 1)) > 10E-12);        randomData.reSeed(1000);        assertEquals("same seeds", v, randomData.nextUniform(0, 1), 10E-12);        randomData.reSeedSecure(1000);        String hex = randomData.nextSecureHexString(40);        randomData.reSeedSecure();        assertTrue("different seeds", !hex.equals(randomData                .nextSecureHexString(40)));        randomData.reSeedSecure(1000);        assertTrue("same seeds", !hex                .equals(randomData.nextSecureHexString(40)));        /*         * remove this test back soon, since it takes about 4 seconds         *         * try { randomData.setSecureAlgorithm("SHA1PRNG","SUN"); } catch         * (NoSuchProviderException ex) { ; } assertTrue("different seeds",         * !hex.equals(randomData.nextSecureHexString(40))); try {         * randomData.setSecureAlgorithm("NOSUCHTHING","SUN");         * fail("expecting NoSuchAlgorithmException"); } catch         * (NoSuchProviderException ex) { ; } catch (NoSuchAlgorithmException         * ex) { ; }         *         * try { randomData.setSecureAlgorithm("SHA1PRNG","NOSUCHPROVIDER");         * fail("expecting NoSuchProviderException"); } catch         * (NoSuchProviderException ex) { ; }         */        // test reseeding without first using the generators        RandomDataImpl rd = new RandomDataImpl();        rd.reSeed(100);        rd.nextLong(1, 2);        RandomDataImpl rd2 = new RandomDataImpl();        rd2.reSeedSecure(2000);        rd2.nextSecureLong(1, 2);        rd = new RandomDataImpl();        rd.reSeed();        rd.nextLong(1, 2);        rd2 = new RandomDataImpl();        rd2.reSeedSecure();        rd2.nextSecureLong(1, 2);    }    /** tests for nextSample() sampling from Collection */    public void testNextSample() {        Object[][] c = { { "0", "1" }, { "0", "2" }, { "0", "3" },                { "0", "4" }, { "1", "2" }, { "1", "3" }, { "1", "4" },                { "2", "3" }, { "2", "4" }, { "3", "4" } };        long[] observed = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };        double[] expected = { 100, 100, 100, 100, 100, 100, 100, 100, 100, 100 };        HashSet<Object> cPop = new HashSet<Object>(); // {0,1,2,3,4}        for (int i = 0; i < 5; i++) {            cPop.add(Integer.toString(i));        }        Object[] sets = new Object[10]; // 2-sets from 5        for (int i = 0; i < 10; i++) {            HashSet<Object> hs = new HashSet<Object>();            hs.add(c[i][0]);            hs.add(c[i][1]);            sets[i] = hs;        }        for (int i = 0; i < 1000; i++) {            Object[] cSamp = randomData.nextSample(cPop, 2);            observed[findSample(sets, cSamp)]++;        }        /*         * Use ChiSquare dist with df = 10-1 = 9, alpha = .001 Change to 21.67         * for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 27.88);        // Make sure sample of size = size of collection returns same collection        HashSet<Object> hs = new HashSet<Object>();        hs.add("one");        Object[] one = randomData.nextSample(hs, 1);        String oneString = (String) one[0];        if ((one.length != 1) || !oneString.equals("one")) {            fail("bad sample for set size = 1, sample size = 1");        }        // Make sure we fail for sample size > collection size        try {            one = randomData.nextSample(hs, 2);            fail("sample size > set size, expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }        // Make sure we fail for empty collection        try {            hs = new HashSet<Object>();            one = randomData.nextSample(hs, 0);            fail("n = k = 0, expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // ignored        }    }    @SuppressWarnings("unchecked")    private int findSample(Object[] u, Object[] samp) {        for (int i = 0; i < u.length; i++) {            HashSet<Object> set = (HashSet<Object>) u[i];            HashSet<Object> sampSet = new HashSet<Object>();            for (int j = 0; j < samp.length; j++) {                sampSet.add(samp[j]);            }            if (set.equals(sampSet)) {                return i;            }        }        fail("sample not found:{" + samp[0] + "," + samp[1] + "}");        return -1;    }    /** tests for nextPermutation */    public void testNextPermutation() {        int[][] p = { { 0, 1, 2 }, { 0, 2, 1 }, { 1, 0, 2 }, { 1, 2, 0 },                { 2, 0, 1 }, { 2, 1, 0 } };        long[] observed = { 0, 0, 0, 0, 0, 0 };        double[] expected = { 100, 100, 100, 100, 100, 100 };        for (int i = 0; i < 600; i++) {            int[] perm = randomData.nextPermutation(3, 3);            observed[findPerm(p, perm)]++;        }        /*         * Use ChiSquare dist with df = 6-1 = 5, alpha = .001 Change to 15.09         * for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected, observed) < 20.52);        // Check size = 1 boundary case        int[] perm = randomData.nextPermutation(1, 1);        if ((perm.length != 1) || (perm[0] != 0)) {            fail("bad permutation for n = 1, sample k = 1");            // Make sure we fail for k size > n            try {                perm = randomData.nextPermutation(2, 3);                fail("permutation k > n, expecting IllegalArgumentException");            } catch (IllegalArgumentException ex) {                // ignored            }            // Make sure we fail for n = 0            try {                perm = randomData.nextPermutation(0, 0);                fail("permutation k = n = 0, expecting IllegalArgumentException");            } catch (IllegalArgumentException ex) {                // ignored            }            // Make sure we fail for k < n < 0            try {                perm = randomData.nextPermutation(-1, -3);                fail("permutation k < n < 0, expecting IllegalArgumentException");            } catch (IllegalArgumentException ex) {                // ignored            }        }    }    // Disable until we have equals    //public void testSerial() {    //    assertEquals(randomData, TestUtils.serializeAndRecover(randomData));    //}    private int findPerm(int[][] p, int[] samp) {        for (int i = 0; i < p.length; i++) {            boolean good = true;            for (int j = 0; j < samp.length; j++) {                if (samp[j] != p[i][j]) {                    good = false;                }            }            if (good) {                return i;            }        }        fail("permutation not found");        return -1;    }        public void testNextInversionDeviate() throws Exception {        // Set the seed for the default random generator        randomData.reSeed(100);        double[] quantiles = new double[10];        for (int i = 0; i < 10; i++) {            quantiles[i] = randomData.nextUniform(0, 1);        }        // Reseed again so the inversion generator gets the same sequence        randomData.reSeed(100);        BetaDistributionImpl betaDistribution = new BetaDistributionImpl(2, 4);        /*         *  Generate a sequence of deviates using inversion - the distribution function         *  evaluated at the random value from the distribution should match the uniform         *  random value used to generate it, which is stored in the quantiles[] array.         */        for (int i = 0; i < 10; i++) {            double value = randomData.nextInversionDeviate(betaDistribution);            assertEquals(betaDistribution.cumulativeProbability(value), quantiles[i], 10E-9);        }     }        public void testNextBeta() throws Exception {        double[] quartiles = TestUtils.getDistributionQuartiles(new BetaDistributionImpl(2,5));        long[] counts = new long[4];        randomData.reSeed(1000);        for (int i = 0; i < 1000; i++) {            double value = randomData.nextBeta(2, 5);            TestUtils.updateCounts(value, counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);    }        public void testNextCauchy() throws Exception {        double[] quartiles = TestUtils.getDistributionQuartiles(new CauchyDistributionImpl(1.2, 2.1));        long[] counts = new long[4];        randomData.reSeed(1000);        for (int i = 0; i < 1000; i++) {            double value = randomData.nextCauchy(1.2, 2.1);            TestUtils.updateCounts(value, counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);    }        public void testNextChiSquare() throws Exception {        double[] quartiles = TestUtils.getDistributionQuartiles(new ChiSquaredDistributionImpl(12));        long[] counts = new long[4];        randomData.reSeed(1000);        for (int i = 0; i < 1000; i++) {            double value = randomData.nextChiSquare(12);            TestUtils.updateCounts(value, counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);    }        public void testNextF() throws Exception {        double[] quartiles = TestUtils.getDistributionQuartiles(new FDistributionImpl(12, 5));        long[] counts = new long[4];        randomData.reSeed(1000);        for (int i = 0; i < 1000; i++) {            double value = randomData.nextF(12, 5);            TestUtils.updateCounts(value, counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);    }        public void testNextGamma() throws Exception {        double[] quartiles = TestUtils.getDistributionQuartiles(new GammaDistributionImpl(4, 2));        long[] counts = new long[4];        randomData.reSeed(1000);        for (int i = 0; i < 1000; i++) {            double value = randomData.nextGamma(4, 2);            TestUtils.updateCounts(value, counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);    }        public void testNextT() throws Exception {        double[] quartiles = TestUtils.getDistributionQuartiles(new TDistributionImpl(10));        long[] counts = new long[4];        randomData.reSeed(1000);        for (int i = 0; i < 1000; i++) {            double value = randomData.nextT(10);            TestUtils.updateCounts(value, counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);    }        public void testNextWeibull() throws Exception {        double[] quartiles = TestUtils.getDistributionQuartiles(new WeibullDistributionImpl(1.2, 2.1));        long[] counts = new long[4];        randomData.reSeed(1000);        for (int i = 0; i < 1000; i++) {            double value = randomData.nextWeibull(1.2, 2.1);            TestUtils.updateCounts(value, counts, quartiles);        }        TestUtils.assertChiSquareAccept(expected, counts, 0.001);    }        public void testNextBinomial() throws Exception {        BinomialDistributionTest testInstance = new BinomialDistributionTest("");        int[] densityPoints = testInstance.makeDensityTestPoints();        double[] densityValues = testInstance.makeDensityTestValues();        int sampleSize = 1000;        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);        BinomialDistributionImpl distribution = (BinomialDistributionImpl) testInstance.makeDistribution();        double[] expectedCounts = new double[length];        long[] observedCounts = new long[length];        for (int i = 0; i < length; i++) {            expectedCounts[i] = sampleSize * densityValues[i];        }        randomData.reSeed(1000);        for (int i = 0; i < sampleSize; i++) {          int value = randomData.nextBinomial(distribution.getNumberOfTrials(),                  distribution.getProbabilityOfSuccess());          for (int j = 0; j < length; j++) {              if (value == densityPoints[j]) {                  observedCounts[j]++;              }          }        }        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);    }        public void testNextHypergeometric() throws Exception {        HypergeometricDistributionTest testInstance = new HypergeometricDistributionTest("");        int[] densityPoints = testInstance.makeDensityTestPoints();        double[] densityValues = testInstance.makeDensityTestValues();        int sampleSize = 1000;        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);        HypergeometricDistributionImpl distribution = (HypergeometricDistributionImpl) testInstance.makeDistribution();        double[] expectedCounts = new double[length];        long[] observedCounts = new long[length];        for (int i = 0; i < length; i++) {            expectedCounts[i] = sampleSize * densityValues[i];        }        randomData.reSeed(1000);        for (int i = 0; i < sampleSize; i++) {          int value = randomData.nextHypergeometric(distribution.getPopulationSize(),                  distribution.getNumberOfSuccesses(), distribution.getSampleSize());          for (int j = 0; j < length; j++) {              if (value == densityPoints[j]) {                  observedCounts[j]++;              }          }        }        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);    }        public void testNextPascal() throws Exception {        PascalDistributionTest testInstance = new PascalDistributionTest("");        int[] densityPoints = testInstance.makeDensityTestPoints();        double[] densityValues = testInstance.makeDensityTestValues();        int sampleSize = 1000;        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);        PascalDistributionImpl distribution = (PascalDistributionImpl) testInstance.makeDistribution();        double[] expectedCounts = new double[length];        long[] observedCounts = new long[length];        for (int i = 0; i < length; i++) {            expectedCounts[i] = sampleSize * densityValues[i];        }        randomData.reSeed(1000);        for (int i = 0; i < sampleSize; i++) {          int value = randomData.nextPascal(distribution.getNumberOfSuccesses(), distribution.getProbabilityOfSuccess());          for (int j = 0; j < length; j++) {              if (value == densityPoints[j]) {                  observedCounts[j]++;              }          }        }        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);    }        public void testNextZipf() throws Exception {        ZipfDistributionTest testInstance = new ZipfDistributionTest("");        int[] densityPoints = testInstance.makeDensityTestPoints();        double[] densityValues = testInstance.makeDensityTestValues();        int sampleSize = 1000;        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);        ZipfDistributionImpl distribution = (ZipfDistributionImpl) testInstance.makeDistribution();        double[] expectedCounts = new double[length];        long[] observedCounts = new long[length];        for (int i = 0; i < length; i++) {            expectedCounts[i] = sampleSize * densityValues[i];        }        randomData.reSeed(1000);        for (int i = 0; i < sampleSize; i++) {          int value = randomData.nextZipf(distribution.getNumberOfElements(), distribution.getExponent());          for (int j = 0; j < length; j++) {              if (value == densityPoints[j]) {                  observedCounts[j]++;              }          }        }        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);    }    }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import java.util.Random;/** * Dummy AbstractRandomGenerator concrete subclass that just wraps a * java.util.Random instance.  Used by AbstractRandomGeneratorTest to test * default implementations in AbstractRandomGenerator. * * @version $Revision$ $Date$ */public class TestRandomGenerator extends AbstractRandomGenerator {    private Random random = new Random();    @Override    public void setSeed(long seed) {       clear();       random.setSeed(seed);    }    @Override    public double nextDouble() {        return random.nextDouble();    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import org.apache.commons.math.stat.Frequency;/** * Test cases for the AbstractRandomGenerator class * * @version $Revision$ $Date$ */public class AbstractRandomGeneratorTest extends RandomDataTest {    protected TestRandomGenerator testGenerator = new TestRandomGenerator();    public AbstractRandomGeneratorTest(String name) {        super(name);        randomData = new RandomDataImpl(testGenerator);    }    @Override    public void testNextInt() {        try {            testGenerator.nextInt(-1);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // ignored        }        Frequency freq = new Frequency();        int value = 0;        for (int i=0; i<smallSampleSize; i++) {            value = testGenerator.nextInt(4);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);        }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected,observed) < 16.27);    }    @Override    public void testNextLong() {        long q1 = Long.MAX_VALUE/4;        long q2 = 2 *  q1;        long q3 = 3 * q1;        Frequency freq = new Frequency();        long val = 0;        int value = 0;        for (int i=0; i<smallSampleSize; i++) {            val = testGenerator.nextLong();            if (val < q1) {                value = 0;            } else if (val < q2) {                value = 1;            } else if (val < q3) {                value = 2;            } else {                value = 3;            }            freq.addValue(value);        }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected,observed) < 16.27);    }    public void testNextBoolean() {        long halfSampleSize = smallSampleSize / 2;        double[] expected = {halfSampleSize, halfSampleSize};        long[] observed = new long[2];        for (int i=0; i<smallSampleSize; i++) {            if (testGenerator.nextBoolean()) {                observed[0]++;            } else {                observed[1]++;            }        }        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001         * Change to 6.635 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected,observed) < 10.828);    }    public void testNextFloat() {        Frequency freq = new Frequency();        float val = 0;        int value = 0;        for (int i=0; i<smallSampleSize; i++) {            val = testGenerator.nextFloat();            if (val < 0.25) {                value = 0;            } else if (val < 0.5) {                value = 1;            } else if (val < 0.75) {                value = 2;            } else {                value = 3;            }            freq.addValue(value);        }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected,observed) < 16.27);    }}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.random;import junit.framework.TestCase;import org.apache.commons.math.DimensionMismatchException;import org.apache.commons.math.linear.MatrixUtils;import org.apache.commons.math.linear.NotPositiveDefiniteMatrixException;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;import org.apache.commons.math.stat.descriptive.moment.VectorialMean;import org.apache.commons.math.util.FastMath;public class CorrelatedRandomVectorGeneratorTestextends TestCase {    public CorrelatedRandomVectorGeneratorTest(String name) {        super(name);        mean       = null;        covariance = null;        generator  = null;    }    public void testRank() {        assertEquals(3, generator.getRank());    }    public void testMath226()        throws DimensionMismatchException, NotPositiveDefiniteMatrixException {        double[] mean = { 1, 1, 10, 1 };        double[][] cov = {                { 1, 3, 2, 6 },                { 3, 13, 16, 2 },                { 2, 16, 38, -1 },                { 6, 2, -1, 197 }        };        RealMatrix covRM = MatrixUtils.createRealMatrix(cov);        JDKRandomGenerator jg = new JDKRandomGenerator();        jg.setSeed(5322145245211l);        NormalizedRandomGenerator rg = new GaussianRandomGenerator(jg);        CorrelatedRandomVectorGenerator sg =            new CorrelatedRandomVectorGenerator(mean, covRM, 0.00001, rg);        for (int i = 0; i < 10; i++) {            double[] generated = sg.nextVector();            assertTrue(FastMath.abs(generated[0] - 1) > 0.1);        }    }    public void testRootMatrix() {        RealMatrix b = generator.getRootMatrix();        RealMatrix bbt = b.multiply(b.transpose());        for (int i = 0; i < covariance.getRowDimension(); ++i) {            for (int j = 0; j < covariance.getColumnDimension(); ++j) {                assertEquals(covariance.getEntry(i, j), bbt.getEntry(i, j), 1.0e-12);            }        }    }    public void testMeanAndCovariance() throws DimensionMismatchException {        VectorialMean meanStat = new VectorialMean(mean.length);        VectorialCovariance covStat = new VectorialCovariance(mean.length, true);        for (int i = 0; i < 5000; ++i) {            double[] v = generator.nextVector();            meanStat.increment(v);            covStat.increment(v);        }        double[] estimatedMean = meanStat.getResult();        RealMatrix estimatedCovariance = covStat.getResult();        for (int i = 0; i < estimatedMean.length; ++i) {            assertEquals(mean[i], estimatedMean[i], 0.07);            for (int j = 0; j <= i; ++j) {                assertEquals(covariance.getEntry(i, j),                        estimatedCovariance.getEntry(i, j),                        0.1 * (1.0 + FastMath.abs(mean[i])) * (1.0 + FastMath.abs(mean[j])));            }        }    }    @Override    public void setUp() {        try {            mean = new double[] { 0.0, 1.0, -3.0, 2.3};            RealMatrix b = MatrixUtils.createRealMatrix(4, 3);            int counter = 0;            for (int i = 0; i < b.getRowDimension(); ++i) {                for (int j = 0; j < b.getColumnDimension(); ++j) {                    b.setEntry(i, j, 1.0 + 0.1 * ++counter);                }            }            RealMatrix bbt = b.multiply(b.transpose());            covariance = MatrixUtils.createRealMatrix(mean.length, mean.length);            for (int i = 0; i < covariance.getRowDimension(); ++i) {                covariance.setEntry(i, i, bbt.getEntry(i, i));                for (int j = 0; j < covariance.getColumnDimension(); ++j) {                    double s = bbt.getEntry(i, j);                    covariance.setEntry(i, j, s);                    covariance.setEntry(j, i, s);                }            }            RandomGenerator rg = new JDKRandomGenerator();            rg.setSeed(17399225432l);            GaussianRandomGenerator rawGenerator = new GaussianRandomGenerator(rg);            generator = new CorrelatedRandomVectorGenerator(mean,                                                            covariance,                                                            1.0e-12 * covariance.getNorm(),                                                            rawGenerator);        } catch (DimensionMismatchException e) {            fail(e.getMessage());        } catch (NotPositiveDefiniteMatrixException e) {            fail("not positive definite matrix");        }    }    @Override    public void tearDown() {        mean       = null;        covariance = null;        generator  = null;    }    private double[] mean;    private RealMatrix covariance;    private CorrelatedRandomVectorGenerator generator;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import java.io.EOFException;import java.net.URL;import org.apache.commons.math.RetryTestCase;import org.apache.commons.math.stat.descriptive.SummaryStatistics;/** * Test cases for the ValueServer class. * * @version $Revision$ $Date$ */public final class ValueServerTest extends RetryTestCase {    private ValueServer vs = new ValueServer();    public ValueServerTest(String name) {        super(name);    }    @Override    public void setUp() {        vs.setMode(ValueServer.DIGEST_MODE);        try {            URL url = getClass().getResource("testData.txt");            vs.setValuesFileURL(url);        } catch (Exception ex) {            fail("malformed test URL");        }    }    /**      * Generate 1000 random values and make sure they look OK.<br>      * Note that there is a non-zero (but very small) probability that      * these tests will fail even if the code is working as designed.      */    public void testNextDigest() throws Exception{        double next = 0.0;        double tolerance = 0.1;        vs.computeDistribution();        assertTrue("empirical distribution property",            vs.getEmpiricalDistribution() != null);        SummaryStatistics stats = new SummaryStatistics();        for (int i = 1; i < 1000; i++) {            next = vs.getNext();            stats.addValue(next);        }        assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);        assertEquals         ("std dev", 1.0173699343977738, stats.getStandardDeviation(),            tolerance);        vs.computeDistribution(500);        stats = new SummaryStatistics();        for (int i = 1; i < 1000; i++) {            next = vs.getNext();            stats.addValue(next);        }        assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);        assertEquals         ("std dev", 1.0173699343977738, stats.getStandardDeviation(),            tolerance);    }    /**      * Make sure exception thrown if digest getNext is attempted      * before loading empiricalDistribution.      */    public void testNextDigestFail() throws Exception {        try {            vs.getNext();            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {}    }    public void testEmptyReplayFile() {        try {            URL url = getClass().getResource("emptyFile.txt");            vs.setMode(ValueServer.REPLAY_MODE);            vs.setValuesFileURL(url);            vs.getNext();            fail("an exception should have been thrown");        } catch (EOFException eof) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testEmptyDigestFile() {        try {            URL url = getClass().getResource("emptyFile.txt");            vs.setMode(ValueServer.DIGEST_MODE);            vs.setValuesFileURL(url);            vs.computeDistribution();            fail("an exception should have been thrown");        } catch (EOFException eof) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    /**     * Test ValueServer REPLAY_MODE using values in testData file.<br>     * Check that the values 1,2,1001,1002 match data file values 1 and 2.     * the sample data file.     */    public void testReplay() throws Exception {        double firstDataValue = 4.038625496201205;        double secondDataValue = 3.6485326248346936;        double tolerance = 10E-15;        double compareValue = 0.0d;        vs.setMode(ValueServer.REPLAY_MODE);        vs.resetReplayFile();        compareValue = vs.getNext();        assertEquals(compareValue,firstDataValue,tolerance);        compareValue = vs.getNext();        assertEquals(compareValue,secondDataValue,tolerance);        for (int i = 3; i < 1001; i++) {           compareValue = vs.getNext();        }        compareValue = vs.getNext();        assertEquals(compareValue,firstDataValue,tolerance);        compareValue = vs.getNext();        assertEquals(compareValue,secondDataValue,tolerance);        vs.closeReplayFile();        // make sure no NPE        vs.closeReplayFile();    }    /**     * Test other ValueServer modes     */    public void testModes() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        vs.setMu(0);        assertEquals("constant mode test",vs.getMu(),vs.getNext(),Double.MIN_VALUE);        vs.setMode(ValueServer.UNIFORM_MODE);        vs.setMu(2);        double val = vs.getNext();        assertTrue(val > 0 && val < 4);        vs.setSigma(1);        vs.setMode(ValueServer.GAUSSIAN_MODE);        val = vs.getNext();        assertTrue("gaussian value close enough to mean",            val < vs.getMu() + 100*vs.getSigma());        vs.setMode(ValueServer.EXPONENTIAL_MODE);        val = vs.getNext();        assertTrue(val > 0);        try {            vs.setMode(1000);            vs.getNext();            fail("bad mode, expecting IllegalStateException");        } catch (IllegalStateException ex) {            // ignored        }    }    /**     * Test fill     */    public void testFill() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        vs.setMu(2);        double[] val = new double[5];        vs.fill(val);        for (int i = 0; i < 5; i++) {            assertEquals("fill test in place",2,val[i],Double.MIN_VALUE);        }        double v2[] = vs.fill(3);        for (int i = 0; i < 3; i++) {            assertEquals("fill test in place",2,v2[i],Double.MIN_VALUE);        }    }    /**     * Test getters to make Clover happy     */    public void testProperties() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        assertEquals("mode test",ValueServer.CONSTANT_MODE,vs.getMode());        vs.setValuesFileURL("http://www.apache.org");        URL url = vs.getValuesFileURL();        assertEquals("valuesFileURL test","http://www.apache.org",url.toString());    }}
//Licensed to the Apache Software Foundation (ASF) under one//or more contributor license agreements.  See the NOTICE file//distributed with this work for additional information//regarding copyright ownership.  The ASF licenses this file//to you under the Apache License, Version 2.0 (the//"License"); you may not use this file except in compliance//with the License.  You may obtain a copy of the License at//http://www.apache.org/licenses/LICENSE-2.0//Unless required by applicable law or agreed to in writing,//software distributed under the License is distributed on an//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY//KIND, either express or implied.  See the License for the//specific language governing permissions and limitations//under the License.package org.apache.commons.math.random;import org.apache.commons.math.stat.StatUtils;import junit.framework.*;public class UniformRandomGeneratorTestextends TestCase {    public UniformRandomGeneratorTest(String name) {        super(name);    }    public void testMeanAndStandardDeviation() {        RandomGenerator rg = new JDKRandomGenerator();        rg.setSeed(17399225432l);        UniformRandomGenerator generator = new UniformRandomGenerator(rg);        double[] sample = new double[10000];        for (int i = 0; i < sample.length; ++i) {            sample[i] = generator.nextNormalizedDouble();        }        assertEquals(0.0, StatUtils.mean(sample), 0.07);        assertEquals(1.0, StatUtils.variance(sample), 0.02);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import java.io.BufferedReader;import java.io.File;import java.io.IOException;import java.io.InputStreamReader;import java.net.URL;import java.util.ArrayList;import org.apache.commons.math.RetryTestCase;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.descriptive.SummaryStatistics;/** * Test cases for the EmpiricalDistribution class * * @version $Revision$ $Date$ */public final class EmpiricalDistributionTest extends RetryTestCase {    protected EmpiricalDistribution empiricalDistribution = null;    protected EmpiricalDistribution empiricalDistribution2 = null;    protected File file = null;    protected URL url = null;    protected double[] dataArray = null;    public EmpiricalDistributionTest(String name) {        super(name);    }    @Override    public void setUp() throws IOException {        empiricalDistribution = new EmpiricalDistributionImpl(100);        url = getClass().getResource("testData.txt");        empiricalDistribution2 = new EmpiricalDistributionImpl(100);        BufferedReader in =                new BufferedReader(new InputStreamReader(                        url.openStream()));        String str = null;        ArrayList<Double> list = new ArrayList<Double>();        while ((str = in.readLine()) != null) {            list.add(Double.valueOf(str));        }        in.close();        in = null;        dataArray = new double[list.size()];        int i = 0;        for (Double data : list) {            dataArray[i] = data.doubleValue();            i++;        }    }    /**     * Test EmpiricalDistrbution.load() using sample data file.<br>     * Check that the sampleCount, mu and sigma match data in     * the sample data file.     */    public void testLoad() throws Exception {        empiricalDistribution.load(url);        // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1        // Make sure that loaded distribution matches this        assertEquals(empiricalDistribution.getSampleStats().getN(),1000,10E-7);        //TODO: replace with statistical tests        assertEquals            (empiricalDistribution.getSampleStats().getMean(),                5.069831575018909,10E-7);        assertEquals          (empiricalDistribution.getSampleStats().getStandardDeviation(),                1.0173699343977738,10E-7);    }    /**     * Test EmpiricalDistrbution.load(double[]) using data taken from     * sample data file.<br>     * Check that the sampleCount, mu and sigma match data in     * the sample data file.     */    public void testDoubleLoad() throws Exception {        empiricalDistribution2.load(dataArray);        // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1        // Make sure that loaded distribution matches this        assertEquals(empiricalDistribution2.getSampleStats().getN(),1000,10E-7);        //TODO: replace with statistical tests        assertEquals            (empiricalDistribution2.getSampleStats().getMean(),                5.069831575018909,10E-7);        assertEquals          (empiricalDistribution2.getSampleStats().getStandardDeviation(),                1.0173699343977738,10E-7);        double[] bounds = ((EmpiricalDistributionImpl) empiricalDistribution2).getGeneratorUpperBounds();        assertEquals(bounds.length, 100);        assertEquals(bounds[99], 1.0, 10e-12);    }    /**      * Generate 1000 random values and make sure they look OK.<br>      * Note that there is a non-zero (but very small) probability that      * these tests will fail even if the code is working as designed.      */    public void testNext() throws Exception {        tstGen(0.1);        tstDoubleGen(0.1);    }    /**      * Make sure exception thrown if digest getNext is attempted      * before loading empiricalDistribution.     */    public void testNexFail() {        try {            empiricalDistribution.getNextValue();            empiricalDistribution2.getNextValue();            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {            // expected        } catch (Exception e) {            fail("wrong exception caught");        }    }    /**     * Make sure we can handle a grid size that is too fine     */    public void testGridTooFine() throws Exception {        empiricalDistribution = new EmpiricalDistributionImpl(1001);        tstGen(0.1);        empiricalDistribution2 = new EmpiricalDistributionImpl(1001);        tstDoubleGen(0.1);    }    /**     * How about too fat?     */    public void testGridTooFat() throws Exception {        empiricalDistribution = new EmpiricalDistributionImpl(1);        tstGen(5); // ridiculous tolerance; but ridiculous grid size                   // really just checking to make sure we do not bomb        empiricalDistribution2 = new EmpiricalDistributionImpl(1);        tstDoubleGen(5);    }    /**     * Test bin index overflow problem (BZ 36450)     */    public void testBinIndexOverflow() throws Exception {        double[] x = new double[] {9474.94326071674, 2080107.8865462579};        new EmpiricalDistributionImpl().load(x);    }    public void testSerialization() {        // Empty        EmpiricalDistribution dist = new EmpiricalDistributionImpl();        EmpiricalDistribution dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(dist);        verifySame(dist, dist2);        // Loaded        empiricalDistribution2.load(dataArray);        dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(empiricalDistribution2);        verifySame(empiricalDistribution2, dist2);    }    public void testLoadNullDoubleArray() {        EmpiricalDistribution dist = new EmpiricalDistributionImpl();        try {            dist.load((double[]) null);            fail("load((double[]) null) expected NullPointerException");        } catch (NullPointerException e) {            // expected        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testLoadNullURL() throws Exception {        EmpiricalDistribution dist = new EmpiricalDistributionImpl();        try {            dist.load((URL) null);            fail("load((URL) null) expected NullPointerException");        } catch (NullPointerException e) {            // expected        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testLoadNullFile() throws Exception {        EmpiricalDistribution dist = new EmpiricalDistributionImpl();        try {            dist.load((File) null);            fail("load((File) null) expected NullPointerException");        } catch (NullPointerException e) {            // expected        } catch (Exception e) {            fail("wrong exception caught");        }    }    /**     * MATH-298     */    public void testGetBinUpperBounds() {        double[] testData = {0, 1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10};        EmpiricalDistributionImpl dist = new EmpiricalDistributionImpl(5);        dist.load(testData);        double[] expectedBinUpperBounds = {2, 4, 6, 8, 10};        double[] expectedGeneratorUpperBounds = {4d/13d, 7d/13d, 9d/13d, 11d/13d, 1};        double tol = 10E-12;        TestUtils.assertEquals(expectedBinUpperBounds, dist.getUpperBounds(), tol);        TestUtils.assertEquals(expectedGeneratorUpperBounds, dist.getGeneratorUpperBounds(), tol);    }    private void verifySame(EmpiricalDistribution d1, EmpiricalDistribution d2) {        assertEquals(d1.isLoaded(), d2.isLoaded());        assertEquals(d1.getBinCount(), d2.getBinCount());        assertEquals(d1.getSampleStats(), d2.getSampleStats());        if (d1.isLoaded()) {            for (int i = 0;  i < d1.getUpperBounds().length; i++) {                assertEquals(d1.getUpperBounds()[i], d2.getUpperBounds()[i], 0);            }            assertEquals(d1.getBinStats(), d2.getBinStats());        }    }    private void tstGen(double tolerance)throws Exception {        empiricalDistribution.load(url);        SummaryStatistics stats = new SummaryStatistics();        for (int i = 1; i < 1000; i++) {            stats.addValue(empiricalDistribution.getNextValue());        }        assertEquals("mean", stats.getMean(),5.069831575018909,tolerance);        assertEquals         ("std dev", stats.getStandardDeviation(),1.0173699343977738,tolerance);    }    private void tstDoubleGen(double tolerance)throws Exception {        empiricalDistribution2.load(dataArray);        SummaryStatistics stats = new SummaryStatistics();        for (int i = 1; i < 1000; i++) {            stats.addValue(empiricalDistribution2.getNextValue());        }        assertEquals("mean", stats.getMean(),5.069831575018909,tolerance);        assertEquals         ("std dev", stats.getStandardDeviation(),1.0173699343977738,tolerance);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import org.junit.Assert;import org.junit.Test;public class Well44497bTest {    @Test    public void testReferenceCode() {        int[] base = {              740849862,  1202665156,  -199039369,  -259008301,  -291878969, -1164428990, -1565918811,   491009864,            -1883086670,  1383450241,  1244617256,   689006653, -1576746370, -1307940314,  1421489086,  1742094000,             -595495729,  1047766204,  1875773301, -1637793284,  1379017098,   262792705,   191880010,  -251000180,            -1753047622,  -972355720,    90626881,  1644693418,  1503365577,   439653419,  1806361562,  1268823869         };        int[] init = new int[1391];        for (int i = 0; i < init.length; ++i) {            init[i] = base[i % base.length] + i;        }        Well44497b mt = new Well44497b(init);        int[] refInt = {           -102003638,  -1254584449,    836441550,   1949705484,    653000494,   1579400718,    699652570,   -140738233,   1164288466,    419933874,    366568847,    780567309,   1867405910,   -350557801,   -964350642,  -1323492759,            191502468,    398676344,   1568976991,   1005053759,    199053603,     31083944,     74697788,  -1343941248,  -1205631880,  -1637961625,    361813531,  -1706096179,   -403340909,   1666226814,  -2034962600,   1237102662,          -1833248535,   1584255126,   1295661745,  -1753848945,   1208145993,    930278953,   -733716134,    192752767,   1692463060,   1727273316,   2122952931,   -809025255,   -992081044,   -895539688,   -419372543,  -1835478922,           2089629419,   1646590742,  -1261083717,  -1005462992,   1619627287,  -1437723182,   1619689210,   1319393089,  -1816963183,   -150214444,   -513482220,   1897815796,  -1861960936,  -1766444468,   2034653890,    585657634,           1867016559,    696942260,  -1536237241,   -527055447,  -1554805020,  -1063992566,   1024799415,   1782080572,  -1884276362,    129028272,   1427925968,  -1154222271,  -1383146732,  -1580532830,  -1907049616,   -104299169,          -1780913000,  -2090815339,  -1789809502,  -1521443849,   1226625769,   1126090676,  -2117094290,   -449575109,   -218982833,   -695554478,     35923022,   1386126825,    -95031305,   -168657023,    436674049,  -1137917876,          -2045134053,  -1025629865,    133144659,     64226081,  -1966942130,    700813483,    344058910,   -910646033,   -212789479,    740360859,  -1269028713,   1517763679,   -664178514,   -683718472,    -71951996,     86583727,          -1235669348,  -1426987265,   -166598353,    214190040,  -1436967644,    233824411,    710927452,  -1939548641,   -433607408,  -1075939594,  -1549702826,  -1310827917,   -640604762,   -696863672,  -1282162126,   -546470833,          -1516734192,   -513809904,   -458526835,    708926727,   -476643096,  -2108375037,     -2870478,  -1460116421,    436587555,   -948939610,   1891375124,   1944216545,    959034236,  -1267038790,  -1695098736,   1853748495,           1594424552,   1270099319,   1139585482,   1837434635,   -709909535,   -457524230,   -887118113,   -241703912,  -1888225819,   -751575804,   1122280146,   1194255209,    949350188,    892826516,   -791212042,   -151203035,           -859297731,  -1979039938,    323603119,  -1022065097,  -1804294506,   -385802891,  -2127523442,   -720380255,  -1315859127,    999649487,    335041941,  -1732821688,  -1833409827,    535715225,  -1285355653,   1206723386,          -1141619270,    759796285,  -1599504546,  -1988521411,   1056668895,   -852564594,   1056509609,  -1831687977,    754168875,  -1301144422,    922880446,  -1502666503,   -949791898,  -1043870198,  -1136941938,  -1649670259,           1342769348,   1692605059,   -132279148,  -1108038310,    -14355545,  -1611387086,   1651826569,    877600127,   1356160799,   -759125205,  -1300490081,   -414938486,   -201479285,   1958709363,   1513313540,  -1396836908,           1352702612,   1142506253,     52969438,   -365142357,  -1619054179,  -1368514102,   1470750417,  -1420830959,   -843909462,  -1679570143,   1447444607,    234551752,  -1507452115,  -1433234579,   -680890000,   -497305145,            860408898,    263376761,   1537070218,   -592353956,   1587852989,   1756653749,  -2081320633,  -1547020311,    723771611,   -883819383,   1899879513,   -268417584,   1058606451,   1665941493,  -1630340612,   -614737477,            891313237,   1368950660,  -1166187089,    296322368,  -1908770726,  -2120378408,   1245479677,   1879710487,  -1705947124,   1018371589,  -1715010575,  -1096078094,  -1749891454,   2130888667,    318647750,    554592231,           -489121568,  -1809605233,  -1697905160,   -953926536,  -2013960553,   -148884919,   1822739964,  -1466301760,    141999978,   1946526064,   1323036718,    864390149,  -2141665227,   1510602225,   1468408474,   1277039721,          -1368096647,    180965986,   2140852057,   -688071899,    819713016,   -154385940,  -1182972611,   1257224305,   1392607672,   1364245931,  -1768434401,    323522132,   -555278604,    474186520,  -1178901665,  -2137343658,           1636421121,   1398987084,   1276656225,   1013316006,   -955917865,  -1537149363,   -179145358,    342862050,   1172728007,    736300054,  -1114656959,  -1831840325,  -1882353535,   -442915191,  -1206488416,  -1818534411,             25312311,   2100297098,  -1562767719,   1762553519,  -1853194231,  -1152612739,  -2020055792,   -809572150,    848584579,   -535789699,   1817604709,   1343773216,   -602234204,   1739930964,   -833790834,    501215449,           -730104057,   1217783189,   -681773267,   -611951354,    978387629,  -1516811237,    974303980,  -1389665696,   2091099075,   -727528826,   2116026151,    271935854,    613242379,  -2100429856,    190004963,  -1629612570,          -1362888327,    175094223,   -917873219,  -2008308245,   -401946815,    504218792,  -1966525201,      4106248,    164895454,    226502921,    655865257,   -610528718,    189428750,   1055978898,     17603028,    591024369,           1127922501,  -1546639293,   1994174637,   -724136988,   -673919372,  -1665002120,   -612145705,   -793102882,  -1904763558,    757565058,  -2091240021,  -2123324826,  -1518702766,   -802889839,   -223045921,  -1509216579,           1195556261,   2079259971,   -903969953,  -1781800655,   1834950463,   -956531922,  -1152550807,  -1116052662,   -348802884,  -1395330117,    -91758501,    -19115285,   1926930669,  -1015793599,    545904386,   1617858191,            716963473,   1917089719,   -980914811,   -212646927,  -1634695647,  -1857924568,  -1462257477,   1273750178,   1060328454,   -361604424,    867932749,    451213698,    405780152,   1165233215,   1877230909,   2103114395,           1644330815,   1252998537,   1961603970,  -1533101488,   1790456024,    -38226118,  -1306744489,    713676418,  -1535871838,   1378109935,   -338185548,   1647669762,   -477465913,    203482277,  -1949756706,   -503326093,           -638704909,    320186309,  -1435581459,    907446649,    -77384645,    537368928,   -335347295,  -1912061924,    547819174,   -225549827,   1089455486,    463516297,   -240127764,    -85895271,   2053179697,   -287394931,            921878827,   -933362608,  -1178670275,  -1200942874,   -672571265,    574422382,   1441734039,  -1814493454,    165751640,   -176907245,  -1170992192,  -2123252090,  -1435971541,   1591853830,   -885477992,   -792847559,           1359875286,   1038392904,  -2027255124,    687291425,   -165513490,   1391146576,  -1387080955,    794663652,   -807189965,    667820962,   -545384499,  -1371368854,   -689031878,   1504805541,   -752825823,  -1920047745,          -1884874017,   -350566320,   -197152911,   -181743050,   -798415949,   -915922276,   1790690149,   -363997181,   1923116185,  -1326427198,  -1621079427,  -1997440997,   1798118127,  -2053110382,   -159879848,  -1286787216,           1046436411,   1832030471,   -389092059,     71686169,    -76025260,   1914270607,   1854169353,    872157826,  -1774323792,   -575165717,  -1919931724,   2051498109,  -1176174934,   -883578901,  -1253047270,  -1310573900,            245466682,  -1784824328,  -1319912821,   1377340217,   1364313761,   -408687373,    142333378,  -1952335763,  -1703126184,    316314678,   2030555423,    488640834,  -1783293306,   2116925005,   -428337460,    -42966447,           -476226114,   -325172903,  -1690748475,    852791569,     26490302,     85251337,  -1374975770,   -376283969,    982639600,    595119792,    376403422,   1574509912,  -1509664496,  -1901241749,    -59019104,    358566667,            341667214,    184541206,   -550950854,  -1897143732,   1595753537,  -1236127928,   2014297822,  -2033179270,   -669806121,  -1927596980,   1010735700,   -581795164,   1922398838,  -1456743538,  -1633813803,    323177707,           2002098813,  -2099067658,    277393729,   -671911622,   -384463053,   2028267908,    367391785,   1270052637,   -172839030,   -650486693,   -831800809,  -1255138113,   -137512799,   1904317942,     -8229811,    707361898,           -276859812,     50417442,   1487081728,   1577776181,   1994451303,   1237303035,   -602016235,  -1905218276,  -1895725672,   1172978849,    801129953,  -1819485071,   -587985848,  -2010386741,  -1645226427,   -850866837,            816998708,    357665811,   1955856762,   1617902189,  -1013761306,    146782652,    904185608,   -500146809,   2085848310,   1917713975,  -1823786899,   1994184748,    789196322,   1766857258,   1770685286,     58213029,          -1699628994,    346827379,  -1274423227,     -5079670,   -193099487,   1020296939,  -1795904054,  -1951053094,    -43782418,   -375403393,   1026761026,   -207269610,   1364563521,   1578793454,    457809423,   -534138380,          -1052938788,  -1897101526,   1449976516,   2052800058,  -1145169719,   1476303269,    370625650,   -325249282,      2165984,   1631432802,   1032336355,  -1292978191,  -1810172401,    725725820,  -1162678778,    702624490,           1387673527,    981825943,   -556408212,  -1108487850,  -1782136935,   1582316425,  -1752682164,    307235003,   1386486299,  -1343636074,   1936875586,  -1265279891,   -345847069,    928241171,    239050350,   1859358526,           -664776217,   -823267892,    346651710,   -867656288,  -1907921425,   1362445801,    541145461,   -192727350,   1649366606,    244694627,   -488180018,    214008256,   2032125437,  -1678591993,   -264593820,   1309017286,           -652451998,   1845366657,   -703990120,   -550186406,   -630285276,   1782372955,   1650564210,  -1127904234,  -1407983860,  -1119422877,  -1565976361,  -1913545385,    549841420,  -1410323732,  -1964467146,    228296551,           -421026422,   1929094398,   -266906424,    264810315,  -2008122665,  -1088278148,    141242192,   1871293282,    234634067,   1724159838,   1638271051,   -837713428,   -657941661,    168093988,    708605363,  -1881612509,          -1810496006,   -193495322,   1889982309,  -2050702012,   -693694192,  -1249780322,    718733403,    -76349730,   -188217051,    920912090,  -1814078273,   2013358456,  -1948845521,   -198407575,  -1248904632,   1182772565,           1236791612,  -1297489171,  -1958468586,   1437011007,    390460941,    113068796,   1247982993,   2102889679,  -1563524844,   -128174212,   -754095070,  -1461699362,    943615640,  -1013270737,    221253920,   1514140013,           1596946745,    674222984,    616356702,   1811224435,  -1764322023,  -1653707581,  -1702404459,    390678142,   -209506765,  -1398278531,   -117061517,   1625861343,    659048069,  -1490678943,    846536668,    210715637,           1855458786,   1727745280,   1086729456,   1109111683,   -985298098,  -1813777567,   -954599702,  -1522494031,   1166103515,   -191868965,  -1048777852,   -661271058,   1161457421,   1509090409,   -919753558,   -155431193,          -1774302994,   -366390263,   2090138916,   -693431491,  -1693888428,   1846774454,    925855693,    474383470,    208889079,    382195164,   -283005634,  -2095134392,    579927985,   1390765326,  -1766119865,    900457129,          -1503703236,    974952690,   -107714111,    381338452,   1187256613,   -860560742,    524103620,   1499506130,    197755276,   -790802926,   -406920967,  -1972219791,   -665721155,   -113336203,   1037154436,  -1185441801,           -745541706,   -546274471,   1988928457,  -1975403782,  -1167172845,    777779004,  -1560935061,   -140258712,  -1243598232,  -1394149587,   -785002782,    311842991,  -1025469277,   -605350463,  -1251538057,    537203966,            597777961,  -1845767072,  -1556349193,  -1491015509,  -1935936671,   2093498487,   1908270236,   -315396187,   1356362300,  -2025658518,    630119678,    276190559,    510123398,  -1266145363,   -170152124,   -151540077,           -477900187,   1895894303,   1870333068,  -1169891437,    353366620,   2111175941,   1691245786,   1318765802,    -90993610,    921309517,    118241505,    367005284,   1624861072,   2010785894,    865255951,   1717799691,            -80757664,   -644944841,    136999836,   -341686875,  -1908076090,  -1968934200,   -346397811,   -184213520,   -511811333,  -2118173466,  -1086490399,   1795322855,   -635494328,    415716276,    851044432,   -904636831,          -1972230341,    -64337858,    571177016,   1248814747,  -1351030778,    457872680,   1843549954,   1718960038,    815088665,   1812961065,    360686952,  -1356586646,   1657802416,   1776192945,   -786723490,   -342254407,           -236653811,    771014701,    906386785,   -308057635,   1907957462,    206000440,    -42143480,    900403654,   -917549795,   -310520796,  -1713627766,   2061136240,   -377977839,    891282946,   -821163030,    328143584,           1503793080,    551621842,  -2086273683,  -2070526343,     91195293,  -1654389038,  -1035734266,   -336619597,  -1220221027,  -1468468844,   2105626873,   -841372573,   -122707018,  -2013073683,    494461000,  -2054807734,            -67946259,   1914163407,   1941835405,  -1027244745,   -768123277,    419129844,   -275750260,   -171533009,     97756174,    -17651409,  -1578102255,    995291430,  -1587462977,    692904675,    951632643,   1882101293,          -1546298756,   2018418068,  -1790777661,   1542305514,  -1437624383,    469587009,  -1647853474,  -1318279028,    497228822,    726733469,   1693133452,  -2091185798,   -209017732,    126386499,   1056958932,  -2105494133,            754067324,     96463951,     83701151,   1101658289,   1485852701,    553783806,   1898769881,  -1072031442,   1438062141,   1992540265,   1152252136,   1019391719,   -175951257,     -6691216,    989789689,    968359367,          -1330392786,   1704963399,   -998432914,   -948060232,  -1921688855,   -975840920,   1360273515,   -872810459,     12676907,  -1908050756,    883609616,     65641549,   -200365398,   1386653304,  -1203665071,   1878689007,            426262328,    315375145,   1900325181,    703658494,   -765404895,   1070155172,   1399748900,   -804264234,  -1619419026,   1347225486,    230635292,   1093717835,     14020583,  -2107039873,   -968325341,  -1679158691,           1959784097,   1065690797,   1090615161,   1311445364,    865835426,    870016646,    574122879,   1842697922,  -1289210431,  -1914001560,   1672467629,   -900366331,  -1524066872,    136503816,  -1910431892,  -1431958329,           -830367152,  -1316233970,   -801974860,   1560669382,    -81784810,    401822577,   -949103202,    943897151,   -722666726,    -96825841,  -1092898846,    230567004,    -70355840,  -1398069192,   -312953142,   1475420133,           -622491023,   1661205388,    -19071322,      6024591,   1473041593,   2053897978,  -1346768903,   1484764721,  -1552461890,   1287146711,   1613069307,    902497864,  -1504480063,    375292915,   -836353108,   2047602411        };        for (int i = 0; i < refInt.length; ++i) {            Assert.assertEquals(refInt[i], mt.nextInt());        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.general;import java.awt.geom.Point2D;import java.io.Serializable;import java.util.ArrayList;import junit.framework.TestCase;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.analysis.MultivariateVectorialFunction;import org.apache.commons.math.analysis.solvers.BrentSolver;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.optimization.OptimizationException;import org.apache.commons.math.optimization.RealPointValuePair;import org.apache.commons.math.optimization.SimpleScalarValueChecker;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */public class NonLinearConjugateGradientOptimizerTestextends TestCase {    public NonLinearConjugateGradientOptimizerTest(String name) {        super(name);    }    public void testTrivial() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0 });        assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);        assertEquals(0.0, optimum.getValue(), 1.0e-10);    }    public void testColumnsPermutation() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },                              new double[] { 4.0, 6.0, 1.0 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0 });        assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);        assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(0.0, optimum.getValue(), 1.0e-10);    }    public void testNoDependency() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 2, 0, 0, 0, 0, 0 },                { 0, 2, 0, 0, 0, 0 },                { 0, 0, 2, 0, 0, 0 },                { 0, 0, 0, 2, 0, 0 },                { 0, 0, 0, 0, 2, 0 },                { 0, 0, 0, 0, 0, 2 }        }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });        for (int i = 0; i < problem.target.length; ++i) {            assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);        }    }    public void testOneSet() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                {  1,  0, 0 },                { -1,  1, 0 },                {  0, -1, 1 }        }, new double[] { 1, 1, 1});        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });        assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);        assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);    }    public void testTwoSets() throws FunctionEvaluationException, OptimizationException {        final double epsilon = 1.0e-7;        LinearProblem problem = new LinearProblem(new double[][] {                {  2,  1,   0,  4,       0, 0 },                { -4, -2,   3, -7,       0, 0 },                {  4,  1,  -2,  8,       0, 0 },                {  0, -3, -12, -1,       0, 0 },                {  0,  0,   0,  0, epsilon, 1 },                {  0,  0,   0,  0,       1, 1 }        }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxEvaluations(100);        optimizer.setPreconditioner(new Preconditioner() {            public double[] precondition(double[] point, double[] r) {                double[] d = r.clone();                d[0] /=  72.0;                d[1] /=  30.0;                d[2] /= 314.0;                d[3] /= 260.0;                d[4] /= 2 * (1 + epsilon * epsilon);                d[5] /= 4.0;                return d;            }        });        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-13, 1.0e-13));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });        assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);        assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);        assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);        assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);        assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);    }    public void testNonInversible() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                {  1, 2, -3 },                {  2, 1,  3 },                { -3, 0, -9 }        }, new double[] { 1, 1, 1 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =                optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });        assertTrue(optimum.getValue() > 0.5);    }    public void testIllConditioned() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem1 = new LinearProblem(new double[][] {                { 10.0, 7.0,  8.0,  7.0 },                {  7.0, 5.0,  6.0,  5.0 },                {  8.0, 6.0, 10.0,  9.0 },                {  7.0, 5.0,  9.0, 10.0 }        }, new double[] { 32, 23, 33, 31 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-13, 1.0e-13));        BrentSolver solver = new BrentSolver();        solver.setAbsoluteAccuracy(1.0e-15);        solver.setRelativeAccuracy(1.0e-15);        optimizer.setLineSearchSolver(solver);        RealPointValuePair optimum1 =            optimizer.optimize(problem1, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });        assertEquals(1.0, optimum1.getPoint()[0], 1.0e-5);        assertEquals(1.0, optimum1.getPoint()[1], 1.0e-5);        assertEquals(1.0, optimum1.getPoint()[2], 1.0e-5);        assertEquals(1.0, optimum1.getPoint()[3], 1.0e-5);        LinearProblem problem2 = new LinearProblem(new double[][] {                { 10.00, 7.00, 8.10, 7.20 },                {  7.08, 5.04, 6.00, 5.00 },                {  8.00, 5.98, 9.89, 9.00 },                {  6.99, 4.99, 9.00, 9.98 }        }, new double[] { 32, 23, 33, 31 });        RealPointValuePair optimum2 =            optimizer.optimize(problem2, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });        assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-1);        assertEquals(137.0, optimum2.getPoint()[1], 1.0e-1);        assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-1);        assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-1);    }    public void testMoreEstimatedParametersSimple()        throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 3.0, 2.0,  0.0, 0.0 },                { 0.0, 1.0, -1.0, 1.0 },                { 2.0, 0.0,  1.0, 0.0 }        }, new double[] { 7.0, 3.0, 5.0 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 7, 6, 5, 4 });        assertEquals(0, optimum.getValue(), 1.0e-10);    }    public void testMoreEstimatedParametersUnsorted()        throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                 { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },                 { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },                 { 0.0, 0.0,  0.0,  0.0, 1.0, -1.0 },                 { 0.0, 0.0, -1.0,  1.0, 0.0,  1.0 },                 { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }        }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 2, 2, 2, 2, 2, 2 });        assertEquals(0, optimum.getValue(), 1.0e-10);    }    public void testRedundantEquations() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 5.0 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 1, 1 });        assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);        assertEquals(1.0, optimum.getPoint()[1], 1.0e-8);    }    public void testInconsistentEquations() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 4.0 });        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));        RealPointValuePair optimum =            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 1, 1 });        assertTrue(optimum.getValue() > 0.1);    }    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {        Circle circle = new Circle();        circle.addPoint( 30.0,  68.0);        circle.addPoint( 50.0,  -6.0);        circle.addPoint(110.0, -20.0);        circle.addPoint( 35.0,  15.0);        circle.addPoint( 45.0,  97.0);        NonLinearConjugateGradientOptimizer optimizer =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-30, 1.0e-30));        BrentSolver solver = new BrentSolver();        solver.setAbsoluteAccuracy(1.0e-13);        solver.setRelativeAccuracy(1.0e-15);        optimizer.setLineSearchSolver(solver);        RealPointValuePair optimum =            optimizer.optimize(circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);        assertEquals(69.960161753, circle.getRadius(center), 1.0e-8);        assertEquals(96.075902096, center.x, 1.0e-8);        assertEquals(48.135167894, center.y, 1.0e-8);    }    private static class LinearProblem implements DifferentiableMultivariateRealFunction, Serializable {        private static final long serialVersionUID = 703247177355019415L;        final RealMatrix factors;        final double[] target;        public LinearProblem(double[][] factors, double[] target) {            this.factors = new BlockRealMatrix(factors);            this.target  = target;        }        private double[] gradient(double[] point) {            double[] r = factors.operate(point);            for (int i = 0; i < r.length; ++i) {                r[i] -= target[i];            }            double[] p = factors.transpose().operate(r);            for (int i = 0; i < p.length; ++i) {                p[i] *= 2;            }            return p;        }        public double value(double[] variables) throws FunctionEvaluationException {            double[] y = factors.operate(variables);            double sum = 0;            for (int i = 0; i < y.length; ++i) {                double ri = y[i] - target[i];                sum += ri * ri;            }            return sum;        }        public MultivariateVectorialFunction gradient() {            return new MultivariateVectorialFunction() {                private static final long serialVersionUID = 2621997811350805819L;                public double[] value(double[] point) {                    return gradient(point);                }            };        }        public MultivariateRealFunction partialDerivative(final int k) {            return new MultivariateRealFunction() {                private static final long serialVersionUID = -6186178619133562011L;                public double value(double[] point) {                    return gradient(point)[k];                }            };        }    }    private static class Circle implements DifferentiableMultivariateRealFunction, Serializable {        private static final long serialVersionUID = -4711170319243817874L;        private ArrayList<Point2D.Double> points;        public Circle() {            points  = new ArrayList<Point2D.Double>();        }        public void addPoint(double px, double py) {            points.add(new Point2D.Double(px, py));        }        public double getRadius(Point2D.Double center) {            double r = 0;            for (Point2D.Double point : points) {                r += point.distance(center);            }            return r / points.size();        }        private double[] gradient(double[] point) {            // optimal radius            Point2D.Double center = new Point2D.Double(point[0], point[1]);            double radius = getRadius(center);            // gradient of the sum of squared residuals            double dJdX = 0;            double dJdY = 0;            for (Point2D.Double pk : points) {                double dk = pk.distance(center);                dJdX += (center.x - pk.x) * (dk - radius) / dk;                dJdY += (center.y - pk.y) * (dk - radius) / dk;            }            dJdX *= 2;            dJdY *= 2;            return new double[] { dJdX, dJdY };        }        public double value(double[] variables)                throws IllegalArgumentException, FunctionEvaluationException {            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);            double radius = getRadius(center);            double sum = 0;            for (Point2D.Double point : points) {                double di = point.distance(center) - radius;                sum += di * di;            }            return sum;        }        public MultivariateVectorialFunction gradient() {            return new MultivariateVectorialFunction() {                private static final long serialVersionUID = 3174909643301201710L;                public double[] value(double[] point) {                    return gradient(point);                }            };        }        public MultivariateRealFunction partialDerivative(final int k) {            return new MultivariateRealFunction() {                private static final long serialVersionUID = 3073956364104833888L;                public double value(double[] point) {                    return gradient(point)[k];                }            };        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.general;import java.awt.geom.Point2D;import java.io.Serializable;import java.util.ArrayList;import java.util.Arrays;import junit.framework.TestCase;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.exception.ConvergenceException;import org.apache.commons.math.exception.TooManyEvaluationsException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;import org.apache.commons.math.analysis.MultivariateMatrixFunction;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.optimization.SimpleVectorialPointChecker;import org.apache.commons.math.optimization.SimpleVectorialValueChecker;import org.apache.commons.math.optimization.VectorialPointValuePair;import org.apache.commons.math.util.FastMath;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */public class GaussNewtonOptimizerTestextends TestCase {    public GaussNewtonOptimizerTest(String name) {        super(name);    }    public void testTrivial() throws FunctionEvaluationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1 }, new double[] { 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);        assertEquals(3.0, optimum.getValue()[0], 1.0e-10);    }    public void testColumnsPermutation() throws FunctionEvaluationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },                              new double[] { 4.0, 6.0, 1.0 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);        assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(4.0, optimum.getValue()[0], 1.0e-10);        assertEquals(6.0, optimum.getValue()[1], 1.0e-10);        assertEquals(1.0, optimum.getValue()[2], 1.0e-10);    }    public void testNoDependency() throws FunctionEvaluationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 2, 0, 0, 0, 0, 0 },                { 0, 2, 0, 0, 0, 0 },                { 0, 0, 2, 0, 0, 0 },                { 0, 0, 0, 2, 0, 0 },                { 0, 0, 0, 0, 2, 0 },                { 0, 0, 0, 0, 0, 2 }        }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },                               new double[] { 0, 0, 0, 0, 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        for (int i = 0; i < problem.target.length; ++i) {            assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);        }    }    public void testOneSet() throws FunctionEvaluationException {        LinearProblem problem = new LinearProblem(new double[][] {                {  1,  0, 0 },                { -1,  1, 0 },                {  0, -1, 1 }        }, new double[] { 1, 1, 1});        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);        assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);    }    public void testTwoSets() throws FunctionEvaluationException {        double epsilon = 1.0e-7;        LinearProblem problem = new LinearProblem(new double[][] {                {  2,  1,   0,  4,       0, 0 },                { -4, -2,   3, -7,       0, 0 },                {  4,  1,  -2,  8,       0, 0 },                {  0, -3, -12, -1,       0, 0 },                {  0,  0,   0,  0, epsilon, 1 },                {  0,  0,   0,  0,       1, 1 }        }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },                               new double[] { 0, 0, 0, 0, 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);        assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);        assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);        assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);        assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);    }    public void testNonInversible() {        LinearProblem problem = new LinearProblem(new double[][] {                {  1, 2, -3 },                {  2, 1,  3 },                { -3, 0, -9 }        }, new double[] { 1, 1, 1 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        try {            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });            fail("an exception should have been caught");        } catch (ConvergenceException ee) {            // expected behavior        } catch (Exception e) {            fail("wrong exception type caught");        }    }    public void testIllConditioned() throws FunctionEvaluationException {        LinearProblem problem1 = new LinearProblem(new double[][] {                { 10.0, 7.0,  8.0,  7.0 },                {  7.0, 5.0,  6.0,  5.0 },                {  8.0, 6.0, 10.0,  9.0 },                {  7.0, 5.0,  9.0, 10.0 }        }, new double[] { 32, 23, 33, 31 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum1 =            optimizer.optimize(problem1, problem1.target, new double[] { 1, 1, 1, 1 },                               new double[] { 0, 1, 2, 3 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);        assertEquals(1.0, optimum1.getPoint()[1], 1.0e-10);        assertEquals(1.0, optimum1.getPoint()[2], 1.0e-10);        assertEquals(1.0, optimum1.getPoint()[3], 1.0e-10);        LinearProblem problem2 = new LinearProblem(new double[][] {                { 10.00, 7.00, 8.10, 7.20 },                {  7.08, 5.04, 6.00, 5.00 },                {  8.00, 5.98, 9.89, 9.00 },                {  6.99, 4.99, 9.00, 9.98 }        }, new double[] { 32, 23, 33, 31 });        VectorialPointValuePair optimum2 =            optimizer.optimize(problem2, problem2.target, new double[] { 1, 1, 1, 1 },                               new double[] { 0, 1, 2, 3 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);        assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8);        assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8);        assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);    }    public void testMoreEstimatedParametersSimple() {        LinearProblem problem = new LinearProblem(new double[][] {                { 3.0, 2.0,  0.0, 0.0 },                { 0.0, 1.0, -1.0, 1.0 },                { 2.0, 0.0,  1.0, 0.0 }        }, new double[] { 7.0, 3.0, 5.0 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        try {            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },                               new double[] { 7, 6, 5, 4 });            fail("an exception should have been caught");        } catch (ConvergenceException ee) {            // expected behavior        } catch (Exception e) {            fail("wrong exception type caught");        }    }    public void testMoreEstimatedParametersUnsorted() {        LinearProblem problem = new LinearProblem(new double[][] {                 { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },                 { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },                 { 0.0, 0.0,  0.0,  0.0, 1.0, -1.0 },                 { 0.0, 0.0, -1.0,  1.0, 0.0,  1.0 },                 { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }        }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        try {            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1 },                               new double[] { 2, 2, 2, 2, 2, 2 });            fail("an exception should have been caught");        } catch (ConvergenceException ee) {            // expected behavior        } catch (Exception e) {            fail("wrong exception type caught");        }    }    public void testRedundantEquations() throws FunctionEvaluationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 5.0 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },                               new double[] { 1, 1 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);        assertEquals(1.0, optimum.getPoint()[1], 1.0e-8);    }    public void testInconsistentEquations() throws FunctionEvaluationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 4.0 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });        assertTrue(optimizer.getRMS() > 0.1);    }    public void testInconsistentSizes() throws FunctionEvaluationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(-1, optimum.getPoint()[0], 1.0e-10);        assertEquals(+1, optimum.getPoint()[1], 1.0e-10);        try {            optimizer.optimize(problem, problem.target,                               new double[] { 1 },                               new double[] { 0, 0 });            fail("an exception should have been thrown");        } catch (DimensionMismatchException oe) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            optimizer.optimize(problem, new double[] { 1 },                               new double[] { 1 },                               new double[] { 0, 0 });            fail("an exception should have been thrown");        } catch (FunctionEvaluationException oe) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testMaxEvaluations() {        Circle circle = new Circle();        circle.addPoint( 30.0,  68.0);        circle.addPoint( 50.0,  -6.0);        circle.addPoint(110.0, -20.0);        circle.addPoint( 35.0,  15.0);        circle.addPoint( 45.0,  97.0);        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleVectorialPointChecker(1.0e-30, 1.0e-30));        try {            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 },                               new double[] { 1, 1, 1, 1, 1 },                               new double[] { 98.680, 47.345 });            fail("an exception should have been caught");        } catch (TooManyEvaluationsException ee) {            // expected behavior        } catch (Exception e) {            fail("wrong exception type caught");        }    }    public void testCircleFitting() throws FunctionEvaluationException {        Circle circle = new Circle();        circle.addPoint( 30.0,  68.0);        circle.addPoint( 50.0,  -6.0);        circle.addPoint(110.0, -20.0);        circle.addPoint( 35.0,  15.0);        circle.addPoint( 45.0,  97.0);        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-13, 1.0e-13));        VectorialPointValuePair optimum =            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 },                               new double[] { 1, 1, 1, 1, 1 },                               new double[] { 98.680, 47.345 });        assertEquals(1.768262623567235,  FastMath.sqrt(circle.getN()) * optimizer.getRMS(),  1.0e-10);        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);        assertEquals(69.96016175359975, circle.getRadius(center), 1.0e-10);        assertEquals(96.07590209601095, center.x, 1.0e-10);        assertEquals(48.135167894714,   center.y, 1.0e-10);    }    public void testCircleFittingBadInit() throws FunctionEvaluationException {        Circle circle = new Circle();        double[][] points = new double[][] {                {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},                {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},                {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},                {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},                { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},                { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},                {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},                {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},                {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},                {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},                {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},                { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},                { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},                {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},                {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},                {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},                {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},                {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},                { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},                { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},                { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},                {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},                {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},                {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},                {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},                {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},                { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},                { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},                {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}        };        double[] target = new double[points.length];        Arrays.fill(target, 0.0);        double[] weights = new double[points.length];        Arrays.fill(weights, 2.0);        for (int i = 0; i < points.length; ++i) {            circle.addPoint(points[i][0], points[i][1]);        }        GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        try {            optimizer.optimize(circle, target, weights, new double[] { -12, -12 });            fail("an exception should have been caught");        } catch (ConvergenceException ee) {            // expected behavior        } catch (Exception e) {            fail("wrong exception type caught");        }        VectorialPointValuePair optimum =            optimizer.optimize(circle, target, weights, new double[] { 0, 0 });        assertEquals(-0.1517383071957963, optimum.getPointRef()[0], 1.0e-6);        assertEquals(0.2074999736353867,  optimum.getPointRef()[1], 1.0e-6);        assertEquals(0.04268731682389561, optimizer.getRMS(),       1.0e-8);    }    private static class LinearProblem implements DifferentiableMultivariateVectorialFunction, Serializable {        private static final long serialVersionUID = -8804268799379350190L;        final RealMatrix factors;        final double[] target;        public LinearProblem(double[][] factors, double[] target) {            this.factors = new BlockRealMatrix(factors);            this.target  = target;        }        public double[] value(double[] variables) {            return factors.operate(variables);        }        public MultivariateMatrixFunction jacobian() {            return new MultivariateMatrixFunction() {                private static final long serialVersionUID = -8387467946663627585L;                public double[][] value(double[] point) {                    return factors.getData();                }            };        }    }    private static class Circle implements DifferentiableMultivariateVectorialFunction, Serializable {        private static final long serialVersionUID = -7165774454925027042L;        private ArrayList<Point2D.Double> points;        public Circle() {            points  = new ArrayList<Point2D.Double>();        }        public void addPoint(double px, double py) {            points.add(new Point2D.Double(px, py));        }        public int getN() {            return points.size();        }        public double getRadius(Point2D.Double center) {            double r = 0;            for (Point2D.Double point : points) {                r += point.distance(center);            }            return r / points.size();        }        private double[][] jacobian(double[] variables) {            int n = points.size();            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);            // gradient of the optimal radius            double dRdX = 0;            double dRdY = 0;            for (Point2D.Double pk : points) {                double dk = pk.distance(center);                dRdX += (center.x - pk.x) / dk;                dRdY += (center.y - pk.y) / dk;            }            dRdX /= n;            dRdY /= n;            // jacobian of the radius residuals            double[][] jacobian = new double[n][2];            for (int i = 0; i < n; ++i) {                Point2D.Double pi = points.get(i);                double di   = pi.distance(center);                jacobian[i][0] = (center.x - pi.x) / di - dRdX;                jacobian[i][1] = (center.y - pi.y) / di - dRdY;           }            return jacobian;        }        public double[] value(double[] variables) {            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);            double radius = getRadius(center);            double[] residuals = new double[points.size()];            for (int i = 0; i < residuals.length; ++i) {                residuals[i] = points.get(i).distance(center) - radius;            }            return residuals;        }        public MultivariateMatrixFunction jacobian() {            return new MultivariateMatrixFunction() {                private static final long serialVersionUID = -4340046230875165095L;                public double[][] value(double[] point) {                    return jacobian(point);                }            };        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.general;import java.awt.geom.Point2D;import java.io.Serializable;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import junit.framework.TestCase;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.exception.ConvergenceException;import org.apache.commons.math.exception.DimensionMismatchException;import org.apache.commons.math.exception.TooManyEvaluationsException;import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;import org.apache.commons.math.analysis.MultivariateMatrixFunction;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.optimization.SimpleVectorialValueChecker;import org.apache.commons.math.optimization.VectorialPointValuePair;import org.apache.commons.math.util.MathUtils;import org.apache.commons.math.util.FastMath;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */public class LevenbergMarquardtOptimizerTest  extends TestCase {    public LevenbergMarquardtOptimizerTest(String name) {        super(name);    }    public void testTrivial() throws FunctionEvaluationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1 }, new double[] { 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        try {            optimizer.guessParametersErrors();            fail("an exception should have been thrown");        } catch (ConvergenceException ee) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);        assertEquals(3.0, optimum.getValue()[0], 1.0e-10);    }    public void testQRColumnsPermutation() throws FunctionEvaluationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },                              new double[] { 4.0, 6.0, 1.0 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);        assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(4.0, optimum.getValue()[0], 1.0e-10);        assertEquals(6.0, optimum.getValue()[1], 1.0e-10);        assertEquals(1.0, optimum.getValue()[2], 1.0e-10);    }    public void testNoDependency() throws FunctionEvaluationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 2, 0, 0, 0, 0, 0 },                { 0, 2, 0, 0, 0, 0 },                { 0, 0, 2, 0, 0, 0 },                { 0, 0, 0, 2, 0, 0 },                { 0, 0, 0, 0, 2, 0 },                { 0, 0, 0, 0, 0, 2 }        }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },                               new double[] { 0, 0, 0, 0, 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        for (int i = 0; i < problem.target.length; ++i) {            assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);        }    }    public void testOneSet() throws FunctionEvaluationException {        LinearProblem problem = new LinearProblem(new double[][] {                {  1,  0, 0 },                { -1,  1, 0 },                {  0, -1, 1 }        }, new double[] { 1, 1, 1});        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);        assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);    }    public void testTwoSets() throws FunctionEvaluationException {        double epsilon = 1.0e-7;        LinearProblem problem = new LinearProblem(new double[][] {                {  2,  1,   0,  4,       0, 0 },                { -4, -2,   3, -7,       0, 0 },                {  4,  1,  -2,  8,       0, 0 },                {  0, -3, -12, -1,       0, 0 },                {  0,  0,   0,  0, epsilon, 1 },                {  0,  0,   0,  0,       1, 1 }        }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },                               new double[] { 0, 0, 0, 0, 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);        assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);        assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);        assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);        assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);        assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);    }    public void testNonInversible() throws FunctionEvaluationException {        LinearProblem problem = new LinearProblem(new double[][] {                {  1, 2, -3 },                {  2, 1,  3 },                { -3, 0, -9 }        }, new double[] { 1, 1, 1 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });        assertTrue(FastMath.sqrt(problem.target.length) * optimizer.getRMS() > 0.6);        try {            optimizer.getCovariances();            fail("an exception should have been thrown");        } catch (ConvergenceException ee) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testIllConditioned() throws FunctionEvaluationException {        LinearProblem problem1 = new LinearProblem(new double[][] {                { 10.0, 7.0,  8.0,  7.0 },                {  7.0, 5.0,  6.0,  5.0 },                {  8.0, 6.0, 10.0,  9.0 },                {  7.0, 5.0,  9.0, 10.0 }        }, new double[] { 32, 23, 33, 31 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum1 =            optimizer.optimize(problem1, problem1.target, new double[] { 1, 1, 1, 1 },                               new double[] { 0, 1, 2, 3 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);        assertEquals(1.0, optimum1.getPoint()[1], 1.0e-10);        assertEquals(1.0, optimum1.getPoint()[2], 1.0e-10);        assertEquals(1.0, optimum1.getPoint()[3], 1.0e-10);        LinearProblem problem2 = new LinearProblem(new double[][] {                { 10.00, 7.00, 8.10, 7.20 },                {  7.08, 5.04, 6.00, 5.00 },                {  8.00, 5.98, 9.89, 9.00 },                {  6.99, 4.99, 9.00, 9.98 }        }, new double[] { 32, 23, 33, 31 });        VectorialPointValuePair optimum2 =            optimizer.optimize(problem2, problem2.target, new double[] { 1, 1, 1, 1 },                               new double[] { 0, 1, 2, 3 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);        assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8);        assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8);        assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);    }    public void testMoreEstimatedParametersSimple() throws FunctionEvaluationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 3.0, 2.0,  0.0, 0.0 },                { 0.0, 1.0, -1.0, 1.0 },                { 2.0, 0.0,  1.0, 0.0 }        }, new double[] { 7.0, 3.0, 5.0 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },                new double[] { 7, 6, 5, 4 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);    }    public void testMoreEstimatedParametersUnsorted() throws FunctionEvaluationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },                { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },                { 0.0, 0.0,  0.0,  0.0, 1.0, -1.0 },                { 0.0, 0.0, -1.0,  1.0, 0.0,  1.0 },                { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }       }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1 },                               new double[] { 2, 2, 2, 2, 2, 2 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(3.0, optimum.getPointRef()[2], 1.0e-10);        assertEquals(4.0, optimum.getPointRef()[3], 1.0e-10);        assertEquals(5.0, optimum.getPointRef()[4], 1.0e-10);        assertEquals(6.0, optimum.getPointRef()[5], 1.0e-10);    }    public void testRedundantEquations() throws FunctionEvaluationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 5.0 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },                               new double[] { 1, 1 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(2.0, optimum.getPointRef()[0], 1.0e-10);        assertEquals(1.0, optimum.getPointRef()[1], 1.0e-10);    }    public void testInconsistentEquations() throws FunctionEvaluationException {        LinearProblem problem = new LinearProblem(new double[][] {                { 1.0,  1.0 },                { 1.0, -1.0 },                { 1.0,  3.0 }        }, new double[] { 3.0, 1.0, 4.0 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });        assertTrue(optimizer.getRMS() > 0.1);    }    public void testInconsistentSizes() throws FunctionEvaluationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });        assertEquals(0, optimizer.getRMS(), 1.0e-10);        assertEquals(-1, optimum.getPoint()[0], 1.0e-10);        assertEquals(+1, optimum.getPoint()[1], 1.0e-10);        try {            optimizer.optimize(problem, problem.target,                               new double[] { 1 },                               new double[] { 0, 0 });            fail("an exception should have been thrown");        } catch (DimensionMismatchException oe) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }        try {            optimizer.optimize(problem, new double[] { 1 },                               new double[] { 1 },                               new double[] { 0, 0 });            fail("an exception should have been thrown");        } catch (FunctionEvaluationException oe) {            // expected behavior        } catch (Exception e) {            fail("wrong exception caught");        }    }    public void testControlParameters() {        Circle circle = new Circle();        circle.addPoint( 30.0,  68.0);        circle.addPoint( 50.0,  -6.0);        circle.addPoint(110.0, -20.0);        circle.addPoint( 35.0,  15.0);        circle.addPoint( 45.0,  97.0);        checkEstimate(circle, 0.1, 10, 1.0e-14, 1.0e-16, 1.0e-10, false);        checkEstimate(circle, 0.1, 10, 1.0e-15, 1.0e-17, 1.0e-10, true);        checkEstimate(circle, 0.1,  5, 1.0e-15, 1.0e-16, 1.0e-10, true);        circle.addPoint(300, -300);        checkEstimate(circle, 0.1, 20, 1.0e-18, 1.0e-16, 1.0e-10, true);    }    private void checkEstimate(DifferentiableMultivariateVectorialFunction problem,                               double initialStepBoundFactor, int maxCostEval,                               double costRelativeTolerance, double parRelativeTolerance,                               double orthoTolerance, boolean shouldFail) {        try {            LevenbergMarquardtOptimizer optimizer                = new LevenbergMarquardtOptimizer(initialStepBoundFactor,                                                  costRelativeTolerance,                                                  parRelativeTolerance,                                                  orthoTolerance,                                                  MathUtils.SAFE_MIN);            optimizer.setMaxEvaluations(maxCostEval);            optimizer.optimize(problem, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },                               new double[] { 98.680, 47.345 });            assertTrue(!shouldFail);        } catch (FunctionEvaluationException ee) {            assertTrue(shouldFail);        } catch (TooManyEvaluationsException ee) {            assertTrue(shouldFail);        } catch (Exception e) {            fail("wrong exception type caught");        }    }    public void testCircleFitting() throws FunctionEvaluationException {        Circle circle = new Circle();        circle.addPoint( 30.0,  68.0);        circle.addPoint( 50.0,  -6.0);        circle.addPoint(110.0, -20.0);        circle.addPoint( 35.0,  15.0);        circle.addPoint( 45.0,  97.0);        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        VectorialPointValuePair optimum =            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },                               new double[] { 98.680, 47.345 });        assertTrue(optimizer.getEvaluations() < 10);        assertTrue(optimizer.getJacobianEvaluations() < 10);        double rms = optimizer.getRMS();        assertEquals(1.768262623567235,  FastMath.sqrt(circle.getN()) * rms,  1.0e-10);        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);        assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);        assertEquals(96.07590211815305, center.x,      1.0e-10);        assertEquals(48.13516790438953, center.y,      1.0e-10);        double[][] cov = optimizer.getCovariances();        assertEquals(1.839, cov[0][0], 0.001);        assertEquals(0.731, cov[0][1], 0.001);        assertEquals(cov[0][1], cov[1][0], 1.0e-14);        assertEquals(0.786, cov[1][1], 0.001);        double[] errors = optimizer.guessParametersErrors();        assertEquals(1.384, errors[0], 0.001);        assertEquals(0.905, errors[1], 0.001);        // add perfect measurements and check errors are reduced        double  r = circle.getRadius(center);        for (double d= 0; d < 2 * FastMath.PI; d += 0.01) {            circle.addPoint(center.x + r * FastMath.cos(d), center.y + r * FastMath.sin(d));        }        double[] target = new double[circle.getN()];        Arrays.fill(target, 0.0);        double[] weights = new double[circle.getN()];        Arrays.fill(weights, 2.0);        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });        cov = optimizer.getCovariances();        assertEquals(0.0016, cov[0][0], 0.001);        assertEquals(3.2e-7, cov[0][1], 1.0e-9);        assertEquals(cov[0][1], cov[1][0], 1.0e-14);        assertEquals(0.0016, cov[1][1], 0.001);        errors = optimizer.guessParametersErrors();        assertEquals(0.004, errors[0], 0.001);        assertEquals(0.004, errors[1], 0.001);    }    public void testCircleFittingBadInit() throws FunctionEvaluationException {        Circle circle = new Circle();        double[][] points = new double[][] {                {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},                {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},                {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},                {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},                { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},                { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},                {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},                {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},                {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},                {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},                {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},                { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},                { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},                {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},                {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},                {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},                {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},                {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},                { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},                { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},                { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},                {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},                {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},                {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},                {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},                {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},                { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},                { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},                {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}        };        double[] target = new double[points.length];        Arrays.fill(target, 0.0);        double[] weights = new double[points.length];        Arrays.fill(weights, 2.0);        for (int i = 0; i < points.length; ++i) {            circle.addPoint(points[i][0], points[i][1]);        }        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-8, 1.0e-8));        VectorialPointValuePair optimum =            optimizer.optimize(circle, target, weights, new double[] { -12, -12 });        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);        assertTrue(optimizer.getEvaluations() < 25);        assertTrue(optimizer.getJacobianEvaluations() < 20);        assertEquals( 0.043, optimizer.getRMS(), 1.0e-3);        assertEquals( 0.292235,  circle.getRadius(center), 1.0e-6);        assertEquals(-0.151738,  center.x,      1.0e-6);        assertEquals( 0.2075001, center.y,      1.0e-6);    }    public void testMath199() throws FunctionEvaluationException {        try {            QuadraticProblem problem = new QuadraticProblem();            problem.addPoint (0, -3.182591015485607);            problem.addPoint (1, -2.5581184967730577);            problem.addPoint (2, -2.1488478161387325);            problem.addPoint (3, -1.9122489313410047);            problem.addPoint (4, 1.7785661310051026);            LevenbergMarquardtOptimizer optimizer                = new LevenbergMarquardtOptimizer(100, 1e-10, 1e-10, 1e-10, 0);            optimizer.optimize(problem,                               new double[] { 0, 0, 0, 0, 0 },                               new double[] { 0.0, 4.4e-323, 1.0, 4.4e-323, 0.0 },                               new double[] { 0, 0, 0 });            fail("an exception should have been thrown");        } catch (ConvergenceException ee) {            // expected behavior        }    }    private static class LinearProblem implements DifferentiableMultivariateVectorialFunction, Serializable {        private static final long serialVersionUID = 703247177355019415L;        final RealMatrix factors;        final double[] target;        public LinearProblem(double[][] factors, double[] target) {            this.factors = new BlockRealMatrix(factors);            this.target  = target;        }        public double[] value(double[] variables) {            return factors.operate(variables);        }        public MultivariateMatrixFunction jacobian() {            return new MultivariateMatrixFunction() {                private static final long serialVersionUID = 556396458721526234L;                public double[][] value(double[] point) {                    return factors.getData();                }            };        }    }    private static class Circle implements DifferentiableMultivariateVectorialFunction, Serializable {        private static final long serialVersionUID = -4711170319243817874L;        private ArrayList<Point2D.Double> points;        public Circle() {            points  = new ArrayList<Point2D.Double>();        }        public void addPoint(double px, double py) {            points.add(new Point2D.Double(px, py));        }        public int getN() {            return points.size();        }        public double getRadius(Point2D.Double center) {            double r = 0;            for (Point2D.Double point : points) {                r += point.distance(center);            }            return r / points.size();        }        private double[][] jacobian(double[] point) {            int n = points.size();            Point2D.Double center = new Point2D.Double(point[0], point[1]);            // gradient of the optimal radius            double dRdX = 0;            double dRdY = 0;            for (Point2D.Double pk : points) {                double dk = pk.distance(center);                dRdX += (center.x - pk.x) / dk;                dRdY += (center.y - pk.y) / dk;            }            dRdX /= n;            dRdY /= n;            // jacobian of the radius residuals            double[][] jacobian = new double[n][2];            for (int i = 0; i < n; ++i) {                Point2D.Double pi = points.get(i);                double di   = pi.distance(center);                jacobian[i][0] = (center.x - pi.x) / di - dRdX;                jacobian[i][1] = (center.y - pi.y) / di - dRdY;            }            return jacobian;        }        public double[] value(double[] variables)        throws FunctionEvaluationException, IllegalArgumentException {            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);            double radius = getRadius(center);            double[] residuals = new double[points.size()];            for (int i = 0; i < residuals.length; ++i) {                residuals[i] = points.get(i).distance(center) - radius;            }            return residuals;        }        public MultivariateMatrixFunction jacobian() {            return new MultivariateMatrixFunction() {                private static final long serialVersionUID = -4340046230875165095L;                public double[][] value(double[] point) {                    return jacobian(point);                }            };        }    }    private static class QuadraticProblem implements DifferentiableMultivariateVectorialFunction, Serializable {        private static final long serialVersionUID = 7072187082052755854L;        private List<Double> x;        private List<Double> y;        public QuadraticProblem() {            x = new ArrayList<Double>();            y = new ArrayList<Double>();        }        public void addPoint(double x, double y) {            this.x.add(x);            this.y.add(y);        }        private double[][] jacobian(double[] variables) {            double[][] jacobian = new double[x.size()][3];            for (int i = 0; i < jacobian.length; ++i) {                jacobian[i][0] = x.get(i) * x.get(i);                jacobian[i][1] = x.get(i);                jacobian[i][2] = 1.0;            }            return jacobian;        }        public double[] value(double[] variables) {            double[] values = new double[x.size()];            for (int i = 0; i < values.length; ++i) {                values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];            }            return values;        }        public MultivariateMatrixFunction jacobian() {            return new MultivariateMatrixFunction() {                private static final long serialVersionUID = -8673650298627399464L;                public double[][] value(double[] point) {                    return jacobian(point);                }            };        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.general;import java.io.Serializable;import java.util.Arrays;import junit.framework.TestCase;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.exception.TooManyEvaluationsException;import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;import org.apache.commons.math.analysis.MultivariateMatrixFunction;import org.apache.commons.math.optimization.VectorialPointValuePair;import org.apache.commons.math.util.FastMath;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */public class MinpackTest extends TestCase {  public MinpackTest(String name) {    super(name);  }  public void testMinpackLinearFullRank() {    minpackTest(new LinearFullRankFunction(10, 5, 1.0,                                           5.0, 2.23606797749979), false);    minpackTest(new LinearFullRankFunction(50, 5, 1.0,                                           8.06225774829855, 6.70820393249937), false);  }  public void testMinpackLinearRank1() {    minpackTest(new LinearRank1Function(10, 5, 1.0,                                        291.521868819476, 1.4638501094228), false);    minpackTest(new LinearRank1Function(50, 5, 1.0,                                        3101.60039334535, 3.48263016573496), false);  }  public void testMinpackLinearRank1ZeroColsAndRows() {    minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false);    minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false);  }  public void testMinpackRosenbrok() {    minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },                                       FastMath.sqrt(24.2)), false);    minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 },                                       FastMath.sqrt(1795769.0)), false);    minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 },                                       11.0 * FastMath.sqrt(169000121.0)), false);  }  public void testMinpackHelicalValley() {    minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 },                                          50.0), false);    minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 },                                          102.95630140987), false);    minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0},                                          991.261822123701), false);  }  public void testMinpackPowellSingular() {    minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },                                           14.6628782986152), false);    minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 },                                           1270.9838708654), false);    minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 },                                           126887.903284750), false);  }  public void testMinpackFreudensteinRoth() {    minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },                                             20.0124960961895, 6.99887517584575,                                             new double[] {                                               11.4124844654993,                                               -0.896827913731509                                             }), false);    minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },                                             12432.833948863, 6.9988751744895,                                             new double[] {                                                11.41300466147456,                                                -0.896796038685959                                             }), false);    minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },                                             11426454.595762, 6.99887517242903,                                             new double[] {                                                 11.412781785788564,                                                 -0.8968051074920405                                             }), false);  }  public void testMinpackBard() {    minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,                                 new double[] {                                   0.0824105765758334,                                   1.1330366534715,                                   2.34369463894115                                 }), false);    minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539,                                 new double[] {                                   0.840666673818329,                                   -158848033.259565,                                   -164378671.653535                                 }), false);    minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969,                                 new double[] {                                   0.840666673867645,                                   -158946167.205518,                                   -164464906.857771                                 }), false);  }  public void testMinpackKowalikOsborne() {    minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },                                           0.0728915102882945,                                           0.017535837721129,                                           new double[] {                                             0.192807810476249,                                             0.191262653354071,                                             0.123052801046931,                                             0.136053221150517                                           }), false);    minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 },                                           2.97937007555202,                                           0.032052192917937,                                           new double[] {                                             728675.473768287,                                             -14.0758803129393,                                             -32977797.7841797,                                             -20571594.1977912                                           }), false);    minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 },                                           29.9590617016037,                                           0.0175364017658228,                                           new double[] {                                             0.192948328597594,                                             0.188053165007911,                                             0.122430604321144,                                             0.134575665392506                                           }), false);  }  public void testMinpackMeyer() {    minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },                                  41153.4665543031, 9.37794514651874,                                  new double[] {                                    0.00560963647102661,                                    6181.34634628659,                                    345.223634624144                                  }), false);    minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 },                                  4168216.89130846, 792.917871779501,                                  new double[] {                                    1.42367074157994e-11,                                    33695.7133432541,                                    901.268527953801                                  }), true);  }  public void testMinpackWatson() {    minpackTest(new WatsonFunction(6, 0.0,                                   5.47722557505166, 0.0478295939097601,                                   new double[] {                                     -0.0157249615083782, 1.01243488232965,                                     -0.232991722387673,  1.26043101102818,                                     -1.51373031394421,   0.99299727291842                                   }), false);    minpackTest(new WatsonFunction(6, 10.0,                                   6433.12578950026, 0.0478295939096951,                                   new double[] {                                     -0.0157251901386677, 1.01243485860105,                                     -0.232991545843829,  1.26042932089163,                                     -1.51372776706575,   0.99299573426328                                   }), false);    minpackTest(new WatsonFunction(6, 100.0,                                   674256.040605213, 0.047829593911544,                                   new double[] {                                    -0.0157247019712586, 1.01243490925658,                                    -0.232991922761641,  1.26043292929555,                                    -1.51373320452707,   0.99299901922322                                   }), false);    minpackTest(new WatsonFunction(9, 0.0,                                   5.47722557505166, 0.00118311459212420,                                   new double[] {                                    -0.153070644166722e-4, 0.999789703934597,                                     0.0147639634910978,   0.146342330145992,                                     1.00082109454817,    -2.61773112070507,                                     4.10440313943354,    -3.14361226236241,                                     1.05262640378759                                   }), false);    minpackTest(new WatsonFunction(9, 10.0,                                   12088.127069307, 0.00118311459212513,                                   new double[] {                                   -0.153071334849279e-4, 0.999789703941234,                                    0.0147639629786217,   0.146342334818836,                                    1.00082107321386,    -2.61773107084722,                                    4.10440307655564,    -3.14361222178686,                                    1.05262639322589                                   }), false);    minpackTest(new WatsonFunction(9, 100.0,                                   1269109.29043834, 0.00118311459212384,                                   new double[] {                                    -0.153069523352176e-4, 0.999789703958371,                                     0.0147639625185392,   0.146342341096326,                                     1.00082104729164,    -2.61773101573645,                                     4.10440301427286,    -3.14361218602503,                                     1.05262638516774                                   }), false);    minpackTest(new WatsonFunction(12, 0.0,                                   5.47722557505166, 0.217310402535861e-4,                                   new double[] {                                    -0.660266001396382e-8, 1.00000164411833,                                    -0.000563932146980154, 0.347820540050756,                                    -0.156731500244233,    1.05281515825593,                                    -3.24727109519451,     7.2884347837505,                                   -10.271848098614,       9.07411353715783,                                    -4.54137541918194,     1.01201187975044                                   }), false);    minpackTest(new WatsonFunction(12, 10.0,                                   19220.7589790951, 0.217310402518509e-4,                                   new double[] {                                    -0.663710223017410e-8, 1.00000164411787,                                    -0.000563932208347327, 0.347820540486998,                                    -0.156731503955652,    1.05281517654573,                                    -3.2472711515214,      7.28843489430665,                                   -10.2718482369638,      9.07411364383733,                                    -4.54137546533666,     1.01201188830857                                   }), false);    minpackTest(new WatsonFunction(12, 100.0,                                   2018918.04462367, 0.217310402539845e-4,                                   new double[] {                                    -0.663806046485249e-8, 1.00000164411786,                                    -0.000563932210324959, 0.347820540503588,                                    -0.156731504091375,    1.05281517718031,                                    -3.24727115337025,     7.28843489775302,                                   -10.2718482410813,      9.07411364688464,                                    -4.54137546660822,     1.0120118885369                                   }), false);  }  public void testMinpackBox3Dimensional() {    minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },                                            32.1115837449572), false);  }  public void testMinpackJennrichSampson() {    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },                                            64.5856498144943, 11.1517793413499,                                            new double[] { //                                            0.2578330049, 0.257829976764542                                               0.2578199266368004, 0.25782997676455244                                            }), false);  }  public void testMinpackBrownDennis() {    minpackTest(new BrownDennisFunction(20,                                        new double[] { 25.0, 5.0, -5.0, -1.0 },                                        2815.43839161816, 292.954288244866,                                        new double[] {                                         -11.59125141003, 13.2024883984741,                                         -0.403574643314272, 0.236736269844604                                        }), false);    minpackTest(new BrownDennisFunction(20,                                        new double[] { 250.0, 50.0, -50.0, -10.0 },                                        555073.354173069, 292.954270581415,                                        new double[] {                                         -11.5959274272203, 13.2041866926242,                                         -0.403417362841545, 0.236771143410386                                       }), false);    minpackTest(new BrownDennisFunction(20,                                        new double[] { 2500.0, 500.0, -500.0, -100.0 },                                        61211252.2338581, 292.954306151134,                                        new double[] {                                         -11.5902596937374, 13.2020628854665,                                         -0.403688070279258, 0.236665033746463                                        }), false);  }  public void testMinpackChebyquad() {    minpackTest(new ChebyquadFunction(1, 8, 1.0,                                      1.88623796907732, 1.88623796907732,                                      new double[] { 0.5 }), false);    minpackTest(new ChebyquadFunction(1, 8, 10.0,                                      5383344372.34005, 1.88424820499951,                                      new double[] { 0.9817314924684 }), false);    minpackTest(new ChebyquadFunction(1, 8, 100.0,                                      0.118088726698392e19, 1.88424820499347,                                      new double[] { 0.9817314852934 }), false);    minpackTest(new ChebyquadFunction(8, 8, 1.0,                                      0.196513862833975, 0.0593032355046727,                                      new double[] {                                        0.0431536648587336, 0.193091637843267,                                        0.266328593812698,  0.499999334628884,                                        0.500000665371116,  0.733671406187302,                                        0.806908362156733,  0.956846335141266                                      }), false);    minpackTest(new ChebyquadFunction(9, 9, 1.0,                                      0.16994993465202, 0.0,                                      new double[] {                                        0.0442053461357828, 0.199490672309881,                                        0.23561910847106,   0.416046907892598,                                        0.5,                0.583953092107402,                                        0.764380891528940,  0.800509327690119,                                        0.955794653864217                                      }), false);    minpackTest(new ChebyquadFunction(10, 10, 1.0,                                      0.183747831178711, 0.0806471004038253,                                      new double[] {                                        0.0596202671753563, 0.166708783805937,                                        0.239171018813509,  0.398885290346268,                                        0.398883667870681,  0.601116332129320,                                        0.60111470965373,   0.760828981186491,                                        0.833291216194063,  0.940379732824644                                      }), false);  }  public void testMinpackBrownAlmostLinear() {    minpackTest(new BrownAlmostLinearFunction(10, 0.5,                                              16.5302162063499, 0.0,                                              new double[] {                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 0.979430303349862,                                                0.979430303349862, 1.20569696650138                                              }), false);    minpackTest(new BrownAlmostLinearFunction(10, 5.0,                                              9765624.00089211, 0.0,                                              new double[] {                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 0.979430303349865,                                               0.979430303349865, 1.20569696650135                                              }), false);    minpackTest(new BrownAlmostLinearFunction(10, 50.0,                                              0.9765625e17, 0.0,                                              new double[] {                                                1.0, 1.0, 1.0, 1.0, 1.0,                                                1.0, 1.0, 1.0, 1.0, 1.0                                              }), false);    minpackTest(new BrownAlmostLinearFunction(30, 0.5,                                              83.476044467848, 0.0,                                              new double[] {                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 0.997754216442807,                                                0.997754216442807, 1.06737350671578                                              }), false);    minpackTest(new BrownAlmostLinearFunction(40, 0.5,                                              128.026364472323, 0.0,                                              new double[] {                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                1.00000000000002, 1.00000000000002,                                                0.999999999999121                                              }), false);    }  public void testMinpackOsborne1() {      minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },                                       0.937564021037838, 0.00739249260904843,                                       new double[] {                                         0.375410049244025, 1.93584654543108,                                        -1.46468676748716, 0.0128675339110439,                                         0.0221227011813076                                       }), false);    }  public void testMinpackOsborne2() {    minpackTest(new Osborne2Function(new double[] {                                       1.3, 0.65, 0.65, 0.7, 0.6,                                       3.0, 5.0, 7.0, 2.0, 4.5, 5.5                                     },                                     1.44686540984712, 0.20034404483314,                                     new double[] {                                       1.30997663810096,  0.43155248076,                                       0.633661261602859, 0.599428560991695,                                       0.754179768272449, 0.904300082378518,                                       1.36579949521007, 4.82373199748107,                                       2.39868475104871, 4.56887554791452,                                       5.67534206273052                                     }), false);  }  private void minpackTest(MinpackFunction function, boolean exceptionExpected) {      LevenbergMarquardtOptimizer optimizer          = new LevenbergMarquardtOptimizer(FastMath.sqrt(2.22044604926e-16),                                            FastMath.sqrt(2.22044604926e-16),                                            2.22044604926e-16);      optimizer.setMaxEvaluations(400 * (function.getN() + 1));//      assertTrue(function.checkTheoreticalStartCost(optimizer.getRMS()));      try {          VectorialPointValuePair optimum =              optimizer.optimize(function,                                 function.getTarget(), function.getWeight(),                                 function.getStartPoint());          assertFalse(exceptionExpected);          function.checkTheoreticalMinCost(optimizer.getRMS());          function.checkTheoreticalMinParams(optimum);      } catch (TooManyEvaluationsException e) {          assertTrue(exceptionExpected);      } catch (FunctionEvaluationException fe) {          assertTrue(exceptionExpected);      }  }  private static abstract class MinpackFunction      implements DifferentiableMultivariateVectorialFunction, Serializable {      private static final long serialVersionUID = -6209760235478794233L;      protected int      n;      protected int      m;      protected double[] startParams;      protected double   theoreticalMinCost;      protected double[] theoreticalMinParams;      protected double   costAccuracy;      protected double   paramsAccuracy;      protected MinpackFunction(int m, double[] startParams,                                double theoreticalMinCost, double[] theoreticalMinParams) {          this.m = m;          this.n = startParams.length;          this.startParams          = startParams.clone();          this.theoreticalMinCost   = theoreticalMinCost;          this.theoreticalMinParams = theoreticalMinParams;          this.costAccuracy         = 1.0e-8;          this.paramsAccuracy       = 1.0e-5;      }      protected static double[] buildArray(int n, double x) {          double[] array = new double[n];          Arrays.fill(array, x);          return array;      }      public double[] getTarget() {          return buildArray(m, 0.0);      }      public double[] getWeight() {          return buildArray(m, 1.0);      }      public double[] getStartPoint() {          return startParams.clone();      }      protected void setCostAccuracy(double costAccuracy) {          this.costAccuracy = costAccuracy;      }      protected void setParamsAccuracy(double paramsAccuracy) {          this.paramsAccuracy = paramsAccuracy;      }      public int getN() {          return startParams.length;      }      public void checkTheoreticalMinCost(double rms) {          double threshold = costAccuracy * (1.0 + theoreticalMinCost);          assertEquals(theoreticalMinCost, FastMath.sqrt(m) * rms, threshold);      }      public void checkTheoreticalMinParams(VectorialPointValuePair optimum) {          double[] params = optimum.getPointRef();          if (theoreticalMinParams != null) {              for (int i = 0; i < theoreticalMinParams.length; ++i) {                  double mi = theoreticalMinParams[i];                  double vi = params[i];                  assertEquals(mi, vi, paramsAccuracy * (1.0 + FastMath.abs(mi)));              }          }      }      public MultivariateMatrixFunction jacobian() {          return new MultivariateMatrixFunction() {            private static final long serialVersionUID = -2435076097232923678L;            public double[][] value(double[] point) {                  return jacobian(point);              }          };      }      public abstract double[][] jacobian(double[] variables);      public abstract double[] value(double[] variables);  }  private static class LinearFullRankFunction extends MinpackFunction {    private static final long serialVersionUID = -9030323226268039536L;    public LinearFullRankFunction(int m, int n, double x0,                                  double theoreticalStartCost,                                  double theoreticalMinCost) {      super(m, buildArray(n, x0), theoreticalMinCost,            buildArray(n, -1.0));    }    @Override    public double[][] jacobian(double[] variables) {      double t = 2.0 / m;      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = (i == j) ? (1 - t) : -t;        }      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double sum = 0;      for (int i = 0; i < n; ++i) {        sum += variables[i];      }      double t  = 1 + 2 * sum / m;      double[] f = new double[m];      for (int i = 0; i < n; ++i) {        f[i] = variables[i] - t;      }      Arrays.fill(f, n, m, -t);      return f;    }  }  private static class LinearRank1Function extends MinpackFunction {    private static final long serialVersionUID = 8494863245104608300L;    public LinearRank1Function(int m, int n, double x0,                                  double theoreticalStartCost,                                  double theoreticalMinCost) {      super(m, buildArray(n, x0), theoreticalMinCost, null);    }    @Override    public double[][] jacobian(double[] variables) {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = (i + 1) * (j + 1);        }      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double[] f = new double[m];      double sum = 0;      for (int i = 0; i < n; ++i) {        sum += (i + 1) * variables[i];      }      for (int i = 0; i < m; ++i) {        f[i] = (i + 1) * sum - 1;      }      return f;    }  }  private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction {    private static final long serialVersionUID = -3316653043091995018L;    public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {      super(m, buildArray(n, x0),            FastMath.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),            null);    }    @Override    public double[][] jacobian(double[] variables) {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];        jacobian[i][0] = 0;        for (int j = 1; j < (n - 1); ++j) {          if (i == 0) {            jacobian[i][j] = 0;          } else if (i != (m - 1)) {            jacobian[i][j] = i * (j + 1);          } else {            jacobian[i][j] = 0;          }        }        jacobian[i][n - 1] = 0;      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double[] f = new double[m];      double sum = 0;      for (int i = 1; i < (n - 1); ++i) {        sum += (i + 1) * variables[i];      }      for (int i = 0; i < (m - 1); ++i) {        f[i] = i * sum - 1;      }      f[m - 1] = -1;      return f;    }  }  private static class RosenbrockFunction extends MinpackFunction {    private static final long serialVersionUID = 2893438180956569134L;    public RosenbrockFunction(double[] startParams, double theoreticalStartCost) {      super(2, startParams, 0.0, buildArray(2, 1.0));    }    @Override    public double[][] jacobian(double[] variables) {      double x1 = variables[0];      return new double[][] { { -20 * x1, 10 }, { -1, 0 } };    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      return new double[] { 10 * (x2 - x1 * x1), 1 - x1 };    }  }  private static class HelicalValleyFunction extends MinpackFunction {    private static final long serialVersionUID = 220613787843200102L;    public HelicalValleyFunction(double[] startParams,                                 double theoreticalStartCost) {      super(3, startParams, 0.0, new double[] { 1.0, 0.0, 0.0 });    }    @Override    public double[][] jacobian(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double tmpSquare = x1 * x1 + x2 * x2;      double tmp1 = twoPi * tmpSquare;      double tmp2 = FastMath.sqrt(tmpSquare);      return new double[][] {        {  100 * x2 / tmp1, -100 * x1 / tmp1, 10 },        { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 },        { 0, 0, 1 }      };    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double tmp1;      if (x1 == 0) {        tmp1 = (x2 >= 0) ? 0.25 : -0.25;      } else {        tmp1 = FastMath.atan(x2 / x1) / twoPi;        if (x1 < 0) {          tmp1 += 0.5;        }      }      double tmp2 = FastMath.sqrt(x1 * x1 + x2 * x2);      return new double[] {        10.0 * (x3 - 10 * tmp1),        10.0 * (tmp2 - 1),        x3      };    }    private static final double twoPi = 2.0 * FastMath.PI;  }  private static class PowellSingularFunction extends MinpackFunction {    private static final long serialVersionUID = 7298364171208142405L;    public PowellSingularFunction(double[] startParams,                                  double theoreticalStartCost) {      super(4, startParams, 0.0, buildArray(4, 0.0));    }    @Override    public double[][] jacobian(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double x4 = variables[3];      return new double[][] {        { 1, 10, 0, 0 },        { 0, 0, sqrt5, -sqrt5 },        { 0, 2 * (x2 - 2 * x3), -4 * (x2 - 2 * x3), 0 },        { 2 * sqrt10 * (x1 - x4), 0, 0, -2 * sqrt10 * (x1 - x4) }      };    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double x4 = variables[3];      return new double[] {        x1 + 10 * x2,        sqrt5 * (x3 - x4),        (x2 - 2 * x3) * (x2 - 2 * x3),        sqrt10 * (x1 - x4) * (x1 - x4)      };    }    private static final double sqrt5  = FastMath.sqrt( 5.0);    private static final double sqrt10 = FastMath.sqrt(10.0);  }  private static class FreudensteinRothFunction extends MinpackFunction {    private static final long serialVersionUID = 2892404999344244214L;    public FreudensteinRothFunction(double[] startParams,                                    double theoreticalStartCost,                                    double theoreticalMinCost,                                    double[] theoreticalMinParams) {      super(2, startParams, theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double x2 = variables[1];      return new double[][] {        { 1, x2 * (10 - 3 * x2) -  2 },        { 1, x2 * ( 2 + 3 * x2) - 14, }      };    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      return new double[] {       -13.0 + x1 + ((5.0 - x2) * x2 -  2.0) * x2,       -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2      };    }  }  private static class BardFunction extends MinpackFunction {    private static final long serialVersionUID = 5990442612572087668L;    public BardFunction(double x0,                        double theoreticalStartCost,                        double theoreticalMinCost,                        double[] theoreticalMinParams) {      super(15, buildArray(3, x0), theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double   x2 = variables[1];      double   x3 = variables[2];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp1 = i  + 1;        double tmp2 = 15 - i;        double tmp3 = (i <= 7) ? tmp1 : tmp2;        double tmp4 = x2 * tmp2 + x3 * tmp3;        tmp4 *= tmp4;        jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double   x3 = variables[2];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double tmp1 = i + 1;        double tmp2 = 15 - i;        double tmp3 = (i <= 7) ? tmp1 : tmp2;        f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3));      }      return f;    }    private static final double[] y = {      0.14, 0.18, 0.22, 0.25, 0.29,      0.32, 0.35, 0.39, 0.37, 0.58,      0.73, 0.96, 1.34, 2.10, 4.39    };  }  private static class KowalikOsborneFunction extends MinpackFunction {    private static final long serialVersionUID = -4867445739880495801L;    public KowalikOsborneFunction(double[] startParams,                                  double theoreticalStartCost,                                  double theoreticalMinCost,                                  double[] theoreticalMinParams) {      super(11, startParams, theoreticalMinCost,            theoreticalMinParams);      if (theoreticalStartCost > 20.0) {        setCostAccuracy(2.0e-4);        setParamsAccuracy(5.0e-3);      }    }    @Override    public double[][] jacobian(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double   x3 = variables[2];      double   x4 = variables[3];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp = v[i] * (v[i] + x3) + x4;        double j1  = -v[i] * (v[i] + x2) / tmp;        double j2  = -v[i] * x1 / tmp;        double j3  = j1 * j2;        double j4  = j3 / v[i];        jacobian[i] = new double[] { j1, j2, j3, j4 };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double x4 = variables[3];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4);      }      return f;    }    private static final double[] v = {      4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625    };    private static final double[] y = {      0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627,      0.0456, 0.0342, 0.0323, 0.0235, 0.0246    };  }  private static class MeyerFunction extends MinpackFunction {    private static final long serialVersionUID = -838060619150131027L;    public MeyerFunction(double[] startParams,                         double theoreticalStartCost,                         double theoreticalMinCost,                         double[] theoreticalMinParams) {      super(16, startParams, theoreticalMinCost,            theoreticalMinParams);      if (theoreticalStartCost > 1.0e6) {        setCostAccuracy(7.0e-3);        setParamsAccuracy(2.0e-2);      }    }    @Override    public double[][] jacobian(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double   x3 = variables[2];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = 5.0 * (i + 1) + 45.0 + x3;        double tmp1 = x2 / temp;        double tmp2 = FastMath.exp(tmp1);        double tmp3 = x1 * tmp2 / temp;        jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        f[i] = x1 * FastMath.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];      }     return f;    }    private static final double[] y = {      34780.0, 28610.0, 23650.0, 19630.0,      16370.0, 13720.0, 11540.0,  9744.0,       8261.0,  7030.0,  6005.0,  5147.0,       4427.0,  3820.0,  3307.0,  2872.0    };  }  private static class WatsonFunction extends MinpackFunction {    private static final long serialVersionUID = -9034759294980218927L;    public WatsonFunction(int n, double x0,                          double theoreticalStartCost,                          double theoreticalMinCost,                          double[] theoreticalMinParams) {      super(31, buildArray(n, x0), theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double[][] jacobian = new double[m][];      for (int i = 0; i < (m - 2); ++i) {        double div = (i + 1) / 29.0;        double s2  = 0.0;        double dx  = 1.0;        for (int j = 0; j < n; ++j) {          s2 += dx * variables[j];          dx *= div;        }        double temp= 2 * div * s2;        dx = 1.0 / div;        jacobian[i] = new double[n];        for (int j = 0; j < n; ++j) {          jacobian[i][j] = dx * (j - temp);          dx *= div;        }      }      jacobian[m - 2]    = new double[n];      jacobian[m - 2][0] = 1;      jacobian[m - 1]   = new double[n];      jacobian[m - 1][0]= -2 * variables[0];      jacobian[m - 1][1]= 1;      return jacobian;    }    @Override    public double[] value(double[] variables) {     double[] f = new double[m];     for (int i = 0; i < (m - 2); ++i) {       double div = (i + 1) / 29.0;       double s1 = 0;       double dx = 1;       for (int j = 1; j < n; ++j) {         s1 += j * dx * variables[j];         dx *= div;       }       double s2 =0;       dx =1;       for (int j = 0; j < n; ++j) {         s2 += dx * variables[j];         dx *= div;       }       f[i] = s1 - s2 * s2 - 1;     }     double x1 = variables[0];     double x2 = variables[1];     f[m - 2] = x1;     f[m - 1] = x2 - x1 * x1 - 1;     return f;    }  }  private static class Box3DimensionalFunction extends MinpackFunction {    private static final long serialVersionUID = 5511403858142574493L;    public Box3DimensionalFunction(int m, double[] startParams,                                   double theoreticalStartCost) {      super(m, startParams, 0.0,            new double[] { 1.0, 10.0, 1.0 });   }    @Override    public double[][] jacobian(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double tmp = (i + 1) / 10.0;        jacobian[i] = new double[] {          -tmp * FastMath.exp(-tmp * x1),           tmp * FastMath.exp(-tmp * x2),          FastMath.exp(-i - 1) - FastMath.exp(-tmp)        };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double tmp = (i + 1) / 10.0;        f[i] = FastMath.exp(-tmp * x1) - FastMath.exp(-tmp * x2)             + (FastMath.exp(-i - 1) - FastMath.exp(-tmp)) * x3;      }      return f;    }  }  private static class JennrichSampsonFunction extends MinpackFunction {    private static final long serialVersionUID = -2489165190443352947L;    public JennrichSampsonFunction(int m, double[] startParams,                                   double theoreticalStartCost,                                   double theoreticalMinCost,                                   double[] theoreticalMinParams) {      super(m, startParams, theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double t = i + 1;        jacobian[i] = new double[] { -t * FastMath.exp(t * x1), -t * FastMath.exp(t * x2) };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = i + 1;        f[i] = 2 + 2 * temp - FastMath.exp(temp * x1) - FastMath.exp(temp * x2);      }      return f;    }  }  private static class BrownDennisFunction extends MinpackFunction {    private static final long serialVersionUID = 8340018645694243910L;    public BrownDennisFunction(int m, double[] startParams,                               double theoreticalStartCost,                               double theoreticalMinCost,                               double[] theoreticalMinParams) {      super(m, startParams, theoreticalMinCost,            theoreticalMinParams);      setCostAccuracy(2.5e-8);    }    @Override    public double[][] jacobian(double[] variables) {      double   x1 = variables[0];      double   x2 = variables[1];      double   x3 = variables[2];      double   x4 = variables[3];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = (i + 1) / 5.0;        double ti   = FastMath.sin(temp);        double tmp1 = x1 + temp * x2 - FastMath.exp(temp);        double tmp2 = x3 + ti   * x4 - FastMath.cos(temp);        jacobian[i] = new double[] {          2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2        };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double x4 = variables[3];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = (i + 1) / 5.0;        double tmp1 = x1 + temp * x2 - FastMath.exp(temp);        double tmp2 = x3 + FastMath.sin(temp) * x4 - FastMath.cos(temp);        f[i] = tmp1 * tmp1 + tmp2 * tmp2;      }      return f;    }  }  private static class ChebyquadFunction extends MinpackFunction {    private static final long serialVersionUID = -2394877275028008594L;    private static double[] buildChebyquadArray(int n, double factor) {      double[] array = new double[n];      double inv = factor / (n + 1);      for (int i = 0; i < n; ++i) {        array[i] = (i + 1) * inv;      }      return array;    }    public ChebyquadFunction(int n, int m, double factor,                             double theoreticalStartCost,                             double theoreticalMinCost,                             double[] theoreticalMinParams) {      super(m, buildChebyquadArray(n, factor), theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];      }      double dx = 1.0 / n;      for (int j = 0; j < n; ++j) {        double tmp1 = 1;        double tmp2 = 2 * variables[j] - 1;        double temp = 2 * tmp2;        double tmp3 = 0;        double tmp4 = 2;        for (int i = 0; i < m; ++i) {          jacobian[i][j] = dx * tmp4;          double ti = 4 * tmp2 + temp * tmp4 - tmp3;          tmp3 = tmp4;          tmp4 = ti;          ti   = temp * tmp2 - tmp1;          tmp1 = tmp2;          tmp2 = ti;        }      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double[] f = new double[m];      for (int j = 0; j < n; ++j) {        double tmp1 = 1;        double tmp2 = 2 * variables[j] - 1;        double temp = 2 * tmp2;        for (int i = 0; i < m; ++i) {          f[i] += tmp2;          double ti = temp * tmp2 - tmp1;          tmp1 = tmp2;          tmp2 = ti;        }      }      double dx = 1.0 / n;      boolean iev = false;      for (int i = 0; i < m; ++i) {        f[i] *= dx;        if (iev) {          f[i] += 1.0 / (i * (i + 2));        }        iev = ! iev;      }      return f;    }  }  private static class BrownAlmostLinearFunction extends MinpackFunction {    private static final long serialVersionUID = 8239594490466964725L;    public BrownAlmostLinearFunction(int m, double factor,                                     double theoreticalStartCost,                                     double theoreticalMinCost,                                     double[] theoreticalMinParams) {      super(m, buildArray(m, factor), theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        jacobian[i] = new double[n];      }      double prod = 1;      for (int j = 0; j < n; ++j) {        prod *= variables[j];        for (int i = 0; i < n; ++i) {          jacobian[i][j] = 1;        }        jacobian[j][j] = 2;      }      for (int j = 0; j < n; ++j) {        double temp = variables[j];        if (temp == 0) {          temp = 1;          prod = 1;          for (int k = 0; k < n; ++k) {            if (k != j) {              prod *= variables[k];            }          }        }        jacobian[n - 1][j] = prod / temp;      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double[] f = new double[m];      double sum  = -(n + 1);      double prod = 1;      for (int j = 0; j < n; ++j) {        sum  += variables[j];        prod *= variables[j];      }      for (int i = 0; i < n; ++i) {        f[i] = variables[i] + sum;      }      f[n - 1] = prod - 1;      return f;    }  }  private static class Osborne1Function extends MinpackFunction {    private static final long serialVersionUID = 4006743521149849494L;    public Osborne1Function(double[] startParams,                            double theoreticalStartCost,                            double theoreticalMinCost,                            double[] theoreticalMinParams) {      super(33, startParams, theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double   x2 = variables[1];      double   x3 = variables[2];      double   x4 = variables[3];      double   x5 = variables[4];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = 10.0 * i;        double tmp1 = FastMath.exp(-temp * x4);        double tmp2 = FastMath.exp(-temp * x5);        jacobian[i] = new double[] {          -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2        };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x1 = variables[0];      double x2 = variables[1];      double x3 = variables[2];      double x4 = variables[3];      double x5 = variables[4];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = 10.0 * i;        double tmp1 = FastMath.exp(-temp * x4);        double tmp2 = FastMath.exp(-temp * x5);        f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2);      }      return f;    }    private static final double[] y = {      0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751,      0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490,      0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406    };  }  private static class Osborne2Function extends MinpackFunction {    private static final long serialVersionUID = -8418268780389858746L;    public Osborne2Function(double[] startParams,                            double theoreticalStartCost,                            double theoreticalMinCost,                            double[] theoreticalMinParams) {      super(65, startParams, theoreticalMinCost,            theoreticalMinParams);    }    @Override    public double[][] jacobian(double[] variables) {      double   x01 = variables[0];      double   x02 = variables[1];      double   x03 = variables[2];      double   x04 = variables[3];      double   x05 = variables[4];      double   x06 = variables[5];      double   x07 = variables[6];      double   x08 = variables[7];      double   x09 = variables[8];      double   x10 = variables[9];      double   x11 = variables[10];      double[][] jacobian = new double[m][];      for (int i = 0; i < m; ++i) {        double temp = i / 10.0;        double tmp1 = FastMath.exp(-x05 * temp);        double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09));        double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10));        double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11));        jacobian[i] = new double[] {          -tmp1,          -tmp2,          -tmp3,          -tmp4,          temp * x01 * tmp1,          x02 * (temp - x09) * (temp - x09) * tmp2,          x03 * (temp - x10) * (temp - x10) * tmp3,          x04 * (temp - x11) * (temp - x11) * tmp4,          -2 * x02 * x06 * (temp - x09) * tmp2,          -2 * x03 * x07 * (temp - x10) * tmp3,          -2 * x04 * x08 * (temp - x11) * tmp4        };      }      return jacobian;    }    @Override    public double[] value(double[] variables) {      double x01 = variables[0];      double x02 = variables[1];      double x03 = variables[2];      double x04 = variables[3];      double x05 = variables[4];      double x06 = variables[5];      double x07 = variables[6];      double x08 = variables[7];      double x09 = variables[8];      double x10 = variables[9];      double x11 = variables[10];      double[] f = new double[m];      for (int i = 0; i < m; ++i) {        double temp = i / 10.0;        double tmp1 = FastMath.exp(-x05 * temp);        double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09));        double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10));        double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11));        f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4);      }      return f;    }    private static final double[] y = {      1.366, 1.191, 1.112, 1.013, 0.991,      0.885, 0.831, 0.847, 0.786, 0.725,      0.746, 0.679, 0.608, 0.655, 0.616,      0.606, 0.602, 0.626, 0.651, 0.724,      0.649, 0.649, 0.694, 0.644, 0.624,      0.661, 0.612, 0.558, 0.533, 0.495,      0.500, 0.423, 0.395, 0.375, 0.372,      0.391, 0.396, 0.405, 0.428, 0.429,      0.523, 0.562, 0.607, 0.653, 0.672,      0.708, 0.633, 0.668, 0.645, 0.632,      0.591, 0.559, 0.597, 0.625, 0.739,      0.710, 0.729, 0.720, 0.636, 0.581,      0.428, 0.292, 0.162, 0.098, 0.054    };  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.univariate;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.optimization.univariate.BrentOptimizer;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.random.JDKRandomGenerator;import org.apache.commons.math.util.FastMath;import org.junit.Test;public class MultiStartUnivariateRealOptimizerTest {    @Test    public void testSinMin() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealOptimizer underlying = new BrentOptimizer(1e-10, 1e-14);        underlying.setMaxEvaluations(300);        JDKRandomGenerator g = new JDKRandomGenerator();        g.setSeed(44428400075l);        MultiStartUnivariateRealOptimizer optimizer =            new MultiStartUnivariateRealOptimizer(underlying, 10, g);        optimizer.optimize(f, GoalType.MINIMIZE, -100.0, 100.0);        UnivariateRealPointValuePair[] optima = optimizer.getOptima();        for (int i = 1; i < optima.length; ++i) {            double d = (optima[i].getPoint() - optima[i-1].getPoint()) / (2 * FastMath.PI);            assertTrue (FastMath.abs(d - FastMath.rint(d)) < 1.0e-8);            assertEquals(-1.0, f.value(optima[i].getPoint()), 1.0e-10);            assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1.0e-10);        }        assertTrue(optimizer.getEvaluations() > 200);        assertTrue(optimizer.getEvaluations() < 300);    }    @Test    public void testQuinticMin() throws MathException {        // The quintic function has zeros at 0, +-0.5 and +-1.        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14);        underlying.setMaxEvaluations(300);        JDKRandomGenerator g = new JDKRandomGenerator();        g.setSeed(4312000053L);        MultiStartUnivariateRealOptimizer optimizer =            new MultiStartUnivariateRealOptimizer(underlying, 5, g);        UnivariateRealPointValuePair optimum            = optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2);        assertEquals(-0.2719561293, optimum.getPoint(), 1e-9);        assertEquals(-0.0443342695, optimum.getValue(), 1e-9);        UnivariateRealPointValuePair[] optima = optimizer.getOptima();        for (int i = 0; i < optima.length; ++i) {            assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1e-9);        }        assertTrue(optimizer.getEvaluations() >= 50);        assertTrue(optimizer.getEvaluations() <= 100);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.univariate;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import org.apache.commons.math.MathException;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.exception.TooManyEvaluationsException;import org.apache.commons.math.analysis.QuinticFunction;import org.apache.commons.math.analysis.SinFunction;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;import org.junit.Test;/** * @version $Revision: 811685 $ $Date: 2009-09-05 19:36:48 +0200 (Sat, 05 Sep 2009) $ */public final class BrentOptimizerTest {    @Test    public void testSinMin() throws MathException {        UnivariateRealFunction f = new SinFunction();        UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);        optimizer.setMaxEvaluations(200);        assertEquals(200, optimizer.getMaxEvaluations());        assertEquals(3 * Math.PI / 2, optimizer.optimize(f, GoalType.MINIMIZE, 4, 5).getPoint(),1e-8);        assertTrue(optimizer.getEvaluations() <= 50);        assertEquals(3 * Math.PI / 2, optimizer.optimize(f, GoalType.MINIMIZE, 1, 5).getPoint(), 1e-8);        assertTrue(optimizer.getEvaluations() <= 100);        assertTrue(optimizer.getEvaluations() >= 15);        optimizer.setMaxEvaluations(10);        try {            optimizer.optimize(f, GoalType.MINIMIZE, 4, 5);            fail("an exception should have been thrown");        } catch (TooManyEvaluationsException fee) {            // expected        } catch (Exception e) {            fail("wrong exception caught");        }    }    @Test    public void testQuinticMin() throws MathException {        // The function has local minima at -0.27195613 and 0.82221643.        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);        optimizer.setMaxEvaluations(200);        assertEquals(-0.27195613, optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2).getPoint(), 1.0e-8);        assertEquals( 0.82221643, optimizer.optimize(f, GoalType.MINIMIZE,  0.3,  0.9).getPoint(), 1.0e-8);        assertTrue(optimizer.getEvaluations() <= 50);        // search in a large interval        assertEquals(-0.27195613, optimizer.optimize(f, GoalType.MINIMIZE, -1.0, 0.2).getPoint(), 1.0e-8);        assertTrue(optimizer.getEvaluations() <= 50);    }    @Test    public void testQuinticMinStatistics() throws MathException {        // The function has local minima at -0.27195613 and 0.82221643.        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-11, 1e-14);        optimizer.setMaxEvaluations(40);        final DescriptiveStatistics[] stat = new DescriptiveStatistics[2];        for (int i = 0; i < stat.length; i++) {            stat[i] = new DescriptiveStatistics();        }        final double min = -0.75;        final double max = 0.25;        final int nSamples = 200;        final double delta = (max - min) / nSamples;        for (int i = 0; i < nSamples; i++) {            final double start = min + i * delta;            stat[0].addValue(optimizer.optimize(f, GoalType.MINIMIZE, min, max, start).getPoint());            stat[1].addValue(optimizer.getEvaluations());        }        final double meanOptValue = stat[0].getMean();        final double medianEval = stat[1].getPercentile(50);        assertTrue(meanOptValue > -0.2719561281);        assertTrue(meanOptValue < -0.2719561280);        assertEquals(23, (int) medianEval);    }    @Test(expected = TooManyEvaluationsException.class)    public void testQuinticMax() throws MathException {        // The quintic function has zeros at 0, +-0.5 and +-1.        // The function has a local maximum at 0.27195613.        UnivariateRealFunction f = new QuinticFunction();        UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-12, 1e-14);        assertEquals(0.27195613, optimizer.optimize(f, GoalType.MAXIMIZE, 0.2, 0.3).getPoint(), 1e-8);        optimizer.setMaxEvaluations(5);        try {            optimizer.optimize(f, GoalType.MAXIMIZE, 0.2, 0.3);            fail("an exception should have been thrown");        } catch (TooManyEvaluationsException miee) {            // expected        } catch (Exception e) {            fail("wrong exception caught");        }    }    @Test    public void testMinEndpoints() throws Exception {        UnivariateRealFunction f = new SinFunction();        UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-8, 1e-14);        optimizer.setMaxEvaluations(50);        // endpoint is minimum        double result = optimizer.optimize(f, GoalType.MINIMIZE, 3 * Math.PI / 2, 5).getPoint();        assertEquals(3 * Math.PI / 2, result, 1e-6);        result = optimizer.optimize(f, GoalType.MINIMIZE, 4, 3 * Math.PI / 2).getPoint();        assertEquals(3 * Math.PI / 2, result, 1e-6);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.univariate;import org.apache.commons.math.MathException;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.optimization.GoalType;import org.junit.Assert;import org.junit.Test;/** * Test for {@link BracketFinder}. */public class BracketFinderTest {    @Test    public void testCubicMin() throws MathException {        final BracketFinder bFind = new BracketFinder();        final UnivariateRealFunction func = new UnivariateRealFunction() {                public double value(double x)                    throws FunctionEvaluationException {                    if (x < -2) {                        return value(-2);                    }                    else  {                        return (x - 1) * (x + 2) * (x + 3);                    }                }            };        bFind.search(func, GoalType.MINIMIZE, -2 , -1);        final double tol = 1e-15;        // Comparing with results computed in Python.        Assert.assertEquals(-2, bFind.getLo(), tol);        Assert.assertEquals(-1, bFind.getMid(), tol);        Assert.assertEquals(0.61803399999999997, bFind.getHi(), tol);    }    @Test    public void testCubicMax() throws MathException {        final BracketFinder bFind = new BracketFinder();        final UnivariateRealFunction func = new UnivariateRealFunction() {                public double value(double x)                    throws FunctionEvaluationException {                    if (x < -2) {                        return value(-2);                    }                    else  {                        return -(x - 1) * (x + 2) * (x + 3);                    }                }            };        bFind.search(func, GoalType.MAXIMIZE, -2 , -1);        final double tol = 1e-15;        Assert.assertEquals(-2, bFind.getLo(), tol);        Assert.assertEquals(-1, bFind.getMid(), tol);        Assert.assertEquals(0.61803399999999997, bFind.getHi(), tol);    }    @Test    public void testMinimumIsOnIntervalBoundary() throws MathException {        final UnivariateRealFunction func = new UnivariateRealFunction() {                public double value(double x)                    throws FunctionEvaluationException {                    return x * x;                }            };        final BracketFinder bFind = new BracketFinder();        bFind.search(func, GoalType.MINIMIZE, 0, 1);        Assert.assertTrue(bFind.getLo() <= 0);        Assert.assertTrue(0 <= bFind.getHi());        bFind.search(func, GoalType.MINIMIZE, -1, 0);        Assert.assertTrue(bFind.getLo() <= 0);        Assert.assertTrue(0 <= bFind.getHi());    }    @Test    public void testIntervalBoundsOrdering() throws MathException {        final UnivariateRealFunction func = new UnivariateRealFunction() {                public double value(double x)                    throws FunctionEvaluationException {                    return x * x;                }            };        final BracketFinder bFind = new BracketFinder();        bFind.search(func, GoalType.MINIMIZE, -1, 1);        Assert.assertTrue(bFind.getLo() <= 0);        Assert.assertTrue(0 <= bFind.getHi());        bFind.search(func, GoalType.MINIMIZE, 1, -1);        Assert.assertTrue(bFind.getLo() <= 0);        Assert.assertTrue(0 <= bFind.getHi());        bFind.search(func, GoalType.MINIMIZE, 1, 2);        Assert.assertTrue(bFind.getLo() <= 0);        Assert.assertTrue(0 <= bFind.getHi());        bFind.search(func, GoalType.MINIMIZE, 2, 1);        Assert.assertTrue(bFind.getLo() <= 0);        Assert.assertTrue(0 <= bFind.getHi());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.direct;import org.apache.commons.math.ConvergenceException;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.optimization.OptimizationException;import org.apache.commons.math.optimization.RealPointValuePair;import org.apache.commons.math.optimization.SimpleScalarValueChecker;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class MultiDirectionalTest {  @Test  public void testFunctionEvaluationExceptions() {      MultivariateRealFunction wrong =          new MultivariateRealFunction() {            private static final long serialVersionUID = 4751314470965489371L;            public double value(double[] x) throws FunctionEvaluationException {                if (x[0] < 0) {                    throw new FunctionEvaluationException(x, "{0}", "oops");                } else if (x[0] > 1) {                    throw new FunctionEvaluationException(new RuntimeException("oops"), x);                } else {                    return x[0] * (1 - x[0]);                }            }      };      try {          MultiDirectional optimizer = new MultiDirectional(0.9, 1.9);          optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { -1.0 });          Assert.fail("an exception should have been thrown");      } catch (FunctionEvaluationException ce) {          // expected behavior          Assert.assertNull(ce.getCause());      } catch (Exception e) {          Assert.fail("wrong exception caught: " + e.getMessage());      }      try {          MultiDirectional optimizer = new MultiDirectional(0.9, 1.9);          optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { +2.0 });          Assert.fail("an exception should have been thrown");      } catch (FunctionEvaluationException ce) {          // expected behavior          Assert.assertNotNull(ce.getCause());      } catch (Exception e) {          Assert.fail("wrong exception caught: " + e.getMessage());      }  }  @Test  public void testMinimizeMaximize()      throws FunctionEvaluationException, ConvergenceException {      // the following function has 4 local extrema:      final double xM        = -3.841947088256863675365;      final double yM        = -1.391745200270734924416;      final double xP        =  0.2286682237349059125691;      final double yP        = -yM;      final double valueXmYm =  0.2373295333134216789769; // local  maximum      final double valueXmYp = -valueXmYm;                // local  minimum      final double valueXpYm = -0.7290400707055187115322; // global minimum      final double valueXpYp = -valueXpYm;                // global maximum      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {          private static final long serialVersionUID = -7039124064449091152L;          public double value(double[] variables) throws FunctionEvaluationException {              final double x = variables[0];              final double y = variables[1];              return ((x == 0) || (y == 0)) ? 0 : (FastMath.atan(x) * FastMath.atan(x + 2) * FastMath.atan(y) * FastMath.atan(y) / (x * y));          }      };      MultiDirectional optimizer = new MultiDirectional();      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));      optimizer.setMaxEvaluations(200);      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });      RealPointValuePair optimum;      // minimization      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });      Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);      Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);      Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);      Assert.assertTrue(optimizer.getEvaluations() > 120);      Assert.assertTrue(optimizer.getEvaluations() < 150);      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });      Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);      Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);      Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);      Assert.assertTrue(optimizer.getEvaluations() > 120);      Assert.assertTrue(optimizer.getEvaluations() < 150);      // maximization      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });      Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);      Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);      Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);      Assert.assertTrue(optimizer.getEvaluations() > 120);      Assert.assertTrue(optimizer.getEvaluations() < 150);      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });      Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);      Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);      Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);      Assert.assertTrue(optimizer.getEvaluations() > 180);      Assert.assertTrue(optimizer.getEvaluations() < 220);  }  @Test  public void testRosenbrock()    throws FunctionEvaluationException, ConvergenceException {    MultivariateRealFunction rosenbrock =      new MultivariateRealFunction() {        private static final long serialVersionUID = -9044950469615237490L;        public double value(double[] x) throws FunctionEvaluationException {          ++count;          double a = x[1] - x[0] * x[0];          double b = 1.0 - x[0];          return 100 * a * a + b * b;        }      };    count = 0;    MultiDirectional optimizer = new MultiDirectional();    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));    optimizer.setMaxEvaluations(100);    optimizer.setStartConfiguration(new double[][] {            { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }    });    RealPointValuePair optimum =        optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });    Assert.assertEquals(count, optimizer.getEvaluations());    Assert.assertTrue(optimizer.getEvaluations() > 50);    Assert.assertTrue(optimizer.getEvaluations() < 100);    Assert.assertTrue(optimum.getValue() > 1.0e-2);  }  @Test  public void testPowell()    throws FunctionEvaluationException, ConvergenceException {    MultivariateRealFunction powell =      new MultivariateRealFunction() {        private static final long serialVersionUID = -832162886102041840L;        public double value(double[] x) throws FunctionEvaluationException {          ++count;          double a = x[0] + 10 * x[1];          double b = x[2] - x[3];          double c = x[1] - 2 * x[2];          double d = x[0] - x[3];          return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;        }      };    count = 0;    MultiDirectional optimizer = new MultiDirectional();    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));    optimizer.setMaxEvaluations(1000);    RealPointValuePair optimum =      optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });    Assert.assertEquals(count, optimizer.getEvaluations());    Assert.assertTrue(optimizer.getEvaluations() > 800);    Assert.assertTrue(optimizer.getEvaluations() < 900);    Assert.assertTrue(optimum.getValue() > 1.0e-2);  }  @Test  public void testMath283()      throws FunctionEvaluationException, OptimizationException {      // fails because MultiDirectional.iterateSimplex is looping forever      // the while(true) should be replaced with a convergence check      MultiDirectional multiDirectional = new MultiDirectional();      multiDirectional.setMaxEvaluations(1000);      final Gaussian2D function = new Gaussian2D(0.0, 0.0, 1.0);      RealPointValuePair estimate = multiDirectional.optimize(function,                                    GoalType.MAXIMIZE, function.getMaximumPosition());      final double EPSILON = 1e-5;      final double expectedMaximum = function.getMaximum();      final double actualMaximum = estimate.getValue();      Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);      final double[] expectedPosition = function.getMaximumPosition();      final double[] actualPosition = estimate.getPoint();      Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );      Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );  }  private static class Gaussian2D implements MultivariateRealFunction {      private final double[] maximumPosition;      private final double std;      public Gaussian2D(double xOpt, double yOpt, double std) {          maximumPosition = new double[] { xOpt, yOpt };          this.std = std;      }      public double getMaximum() {          return value(maximumPosition);      }      public double[] getMaximumPosition() {          return maximumPosition.clone();      }      public double value(double[] point) {          final double x = point[0], y = point[1];          final double twoS2 = 2.0 * std * std;          return 1.0 / (twoS2 * FastMath.PI) * FastMath.exp(-(x * x + y * y) / twoS2);      }  }  private int count;}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.direct;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.MathException;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.analysis.SumSincFunction;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.optimization.MultivariateRealOptimizer;import org.apache.commons.math.optimization.RealPointValuePair;import org.apache.commons.math.optimization.SimpleScalarValueChecker;import org.junit.Assert;import org.junit.Test;/** * Test for {@link PowellOptimizer}. */public class PowellOptimizerTest {    @Test    public void testSumSinc() throws MathException {        final MultivariateRealFunction func = new SumSincFunction(-1);        int dim = 2;        final double[] minPoint = new double[dim];        for (int i = 0; i < dim; i++) {            minPoint[i] = 0;        }        double[] init = new double[dim];        // Initial is minimum.        for (int i = 0; i < dim; i++) {            init[i] = minPoint[i];        }        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-9, 1e-7);        // Initial is far from minimum.        for (int i = 0; i < dim; i++) {            init[i] = minPoint[i] + 3;        }        doTest(func, minPoint, init,  GoalType.MINIMIZE, 1e-9, 1e-7);    }    @Test    public void testQuadratic() throws MathException {        final MultivariateRealFunction func = new MultivariateRealFunction() {                public double value(double[] x)                    throws FunctionEvaluationException {                    final double a = x[0] - 1;                    final double b = x[1] - 1;                    return a * a + b * b + 1;                }            };        int dim = 2;        final double[] minPoint = new double[dim];        for (int i = 0; i < dim; i++) {            minPoint[i] = 1;        }        double[] init = new double[dim];        // Initial is minimum.        for (int i = 0; i < dim; i++) {            init[i] = minPoint[i];        }        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-8);        // Initial is far from minimum.        for (int i = 0; i < dim; i++) {            init[i] = minPoint[i] - 20;        }        doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-8);    }    @Test    public void testMaximizeQuadratic() throws MathException {        final MultivariateRealFunction func = new MultivariateRealFunction() {                public double value(double[] x)                    throws FunctionEvaluationException {                    final double a = x[0] - 1;                    final double b = x[1] - 1;                    return -a * a - b * b + 1;                }            };        int dim = 2;        final double[] maxPoint = new double[dim];        for (int i = 0; i < dim; i++) {            maxPoint[i] = 1;        }        double[] init = new double[dim];        // Initial is minimum.        for (int i = 0; i < dim; i++) {            init[i] = maxPoint[i];        }        doTest(func, maxPoint, init,  GoalType.MAXIMIZE, 1e-9, 1e-8);        // Initial is far from minimum.        for (int i = 0; i < dim; i++) {            init[i] = maxPoint[i] - 20;        }        doTest(func, maxPoint, init, GoalType.MAXIMIZE, 1e-9, 1e-8);    }    /**     * @param func Function to optimize.     * @param optimum Expected optimum.     * @param init Starting point.     * @param goal Minimization or maximization.     * @param fTol Tolerance (relative error on the objective function) for     * "Powell" algorithm.     * @param pointTol Tolerance for checking that the optimum is correct.     */    private void doTest(MultivariateRealFunction func,                        double[] optimum,                        double[] init,                        GoalType goal,                        double fTol,                        double pointTol)        throws MathException {        final MultivariateRealOptimizer optim = new PowellOptimizer(fTol, Math.ulp(1d));        optim.setMaxEvaluations(1000);        final RealPointValuePair result = optim.optimize(func, goal, init);        final double[] found = result.getPoint();        for (int i = 0, dim = optimum.length; i < dim; i++) {            Assert.assertEquals(optimum[i], found[i], pointTol);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.direct;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.exception.TooManyEvaluationsException;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.analysis.MultivariateVectorialFunction;import org.apache.commons.math.linear.Array2DRowRealMatrix;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.optimization.LeastSquaresConverter;import org.apache.commons.math.optimization.RealPointValuePair;import org.apache.commons.math.optimization.SimpleRealPointChecker;import org.apache.commons.math.optimization.SimpleScalarValueChecker;import org.junit.Test;public class NelderMeadTest {    @Test    public void testFunctionEvaluationExceptions() {        MultivariateRealFunction wrong =            new MultivariateRealFunction() {                private static final long serialVersionUID = 4751314470965489371L;                public double value(double[] x) throws FunctionEvaluationException {                    if (x[0] < 0) {                        throw new FunctionEvaluationException(x, "{0}", "oops");                    } else if (x[0] > 1) {                        throw new FunctionEvaluationException(new RuntimeException("oops"), x);                    } else {                        return x[0] * (1 - x[0]);                    }                }            };        try {            NelderMead optimizer = new NelderMead(0.9, 1.9, 0.4, 0.6);            optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { -1.0 });            fail("an exception should have been thrown");        } catch (FunctionEvaluationException ce) {            // expected behavior            assertNull(ce.getCause());        } catch (Exception e) {            fail("wrong exception caught: " + e.getMessage());        }        try {            NelderMead optimizer = new NelderMead(0.9, 1.9, 0.4, 0.6);            optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { +2.0 });            fail("an exception should have been thrown");        } catch (FunctionEvaluationException ce) {            // expected behavior            assertNotNull(ce.getCause());        } catch (Exception e) {            fail("wrong exception caught: " + e.getMessage());        }    }    @Test    public void testMinimizeMaximize()        throws FunctionEvaluationException {        // the following function has 4 local extrema:        final double xM        = -3.841947088256863675365;        final double yM        = -1.391745200270734924416;        final double xP        =  0.2286682237349059125691;        final double yP        = -yM;        final double valueXmYm =  0.2373295333134216789769; // local  maximum        final double valueXmYp = -valueXmYm;                // local  minimum        final double valueXpYm = -0.7290400707055187115322; // global minimum        final double valueXpYp = -valueXpYm;                // global maximum        MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {                private static final long serialVersionUID = -7039124064449091152L;                public double value(double[] variables) throws FunctionEvaluationException {                    final double x = variables[0];                    final double y = variables[1];                    return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));                }            };        NelderMead optimizer = new NelderMead();        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-30));        optimizer.setMaxEvaluations(100);        optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });        RealPointValuePair optimum;        // minimization        optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });        assertEquals(xM,        optimum.getPoint()[0], 2.0e-7);        assertEquals(yP,        optimum.getPoint()[1], 2.0e-5);        assertEquals(valueXmYp, optimum.getValue(),    6.0e-12);        assertTrue(optimizer.getEvaluations() > 60);        assertTrue(optimizer.getEvaluations() < 90);        optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });        assertEquals(xP,        optimum.getPoint()[0], 5.0e-6);        assertEquals(yM,        optimum.getPoint()[1], 6.0e-6);        assertEquals(valueXpYm, optimum.getValue(),    1.0e-11);        assertTrue(optimizer.getEvaluations() > 60);        assertTrue(optimizer.getEvaluations() < 90);        // maximization        optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });        assertEquals(xM,        optimum.getPoint()[0], 1.0e-5);        assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);        assertEquals(valueXmYm, optimum.getValue(),    3.0e-12);        assertTrue(optimizer.getEvaluations() > 60);        assertTrue(optimizer.getEvaluations() < 90);        optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });        assertEquals(xP,        optimum.getPoint()[0], 4.0e-6);        assertEquals(yP,        optimum.getPoint()[1], 5.0e-6);        assertEquals(valueXpYp, optimum.getValue(),    7.0e-12);        assertTrue(optimizer.getEvaluations() > 60);        assertTrue(optimizer.getEvaluations() < 90);    }    @Test    public void testRosenbrock()        throws FunctionEvaluationException {        Rosenbrock rosenbrock = new Rosenbrock();        NelderMead optimizer = new NelderMead();        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));        optimizer.setMaxEvaluations(100);        optimizer.setStartConfiguration(new double[][] {                { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }            });        RealPointValuePair optimum =            optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });        assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());        assertTrue(optimizer.getEvaluations() > 40);        assertTrue(optimizer.getEvaluations() < 50);        assertTrue(optimum.getValue() < 8.0e-4);    }    @Test    public void testPowell()        throws FunctionEvaluationException {        Powell powell = new Powell();        NelderMead optimizer = new NelderMead();        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));        optimizer.setMaxEvaluations(200);        RealPointValuePair optimum =            optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });        assertEquals(powell.getCount(), optimizer.getEvaluations());        assertTrue(optimizer.getEvaluations() > 110);        assertTrue(optimizer.getEvaluations() < 130);        assertTrue(optimum.getValue() < 2.0e-3);    }    @Test    public void testLeastSquares1()        throws FunctionEvaluationException {        final RealMatrix factors =            new Array2DRowRealMatrix(new double[][] {                    { 1.0, 0.0 },                    { 0.0, 1.0 }                }, false);        LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {                public double[] value(double[] variables) {                    return factors.operate(variables);                }            }, new double[] { 2.0, -3.0 });        NelderMead optimizer = new NelderMead();        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-6));        optimizer.setMaxEvaluations(200);        RealPointValuePair optimum =            optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10.0, 10.0 });        assertEquals( 2.0, optimum.getPointRef()[0], 3.0e-5);        assertEquals(-3.0, optimum.getPointRef()[1], 4.0e-4);        assertTrue(optimizer.getEvaluations() > 60);        assertTrue(optimizer.getEvaluations() < 80);        assertTrue(optimum.getValue() < 1.0e-6);    }    @Test    public void testLeastSquares2()        throws FunctionEvaluationException {        final RealMatrix factors =            new Array2DRowRealMatrix(new double[][] {                    { 1.0, 0.0 },                    { 0.0, 1.0 }                }, false);        LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {                public double[] value(double[] variables) {                    return factors.operate(variables);                }            }, new double[] { 2.0, -3.0 }, new double[] { 10.0, 0.1 });        NelderMead optimizer = new NelderMead();        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-6));        optimizer.setMaxEvaluations(200);        RealPointValuePair optimum =            optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10.0, 10.0 });        assertEquals( 2.0, optimum.getPointRef()[0], 5.0e-5);        assertEquals(-3.0, optimum.getPointRef()[1], 8.0e-4);        assertTrue(optimizer.getEvaluations() > 60);        assertTrue(optimizer.getEvaluations() < 80);        assertTrue(optimum.getValue() < 1.0e-6);    }    @Test    public void testLeastSquares3()        throws FunctionEvaluationException {        final RealMatrix factors =            new Array2DRowRealMatrix(new double[][] {                    { 1.0, 0.0 },                    { 0.0, 1.0 }                }, false);        LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorialFunction() {                public double[] value(double[] variables) {                    return factors.operate(variables);                }            }, new double[] { 2.0, -3.0 }, new Array2DRowRealMatrix(new double [][] {                    { 1.0, 1.2 }, { 1.2, 2.0 }                }));        NelderMead optimizer = new NelderMead();        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-6));        optimizer.setMaxEvaluations(200);        RealPointValuePair optimum =            optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10.0, 10.0 });        assertEquals( 2.0, optimum.getPointRef()[0], 2.0e-3);        assertEquals(-3.0, optimum.getPointRef()[1], 8.0e-4);        assertTrue(optimizer.getEvaluations() > 60);        assertTrue(optimizer.getEvaluations() < 80);        assertTrue(optimum.getValue() < 1.0e-6);    }    @Test(expected = TooManyEvaluationsException.class)    public void testMaxIterations() throws FunctionEvaluationException {        Powell powell = new Powell();        NelderMead optimizer = new NelderMead();        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));        optimizer.setMaxEvaluations(20);        optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });    }    private static class Rosenbrock implements MultivariateRealFunction {        private int count;        public Rosenbrock() {            count = 0;        }        public double value(double[] x) throws FunctionEvaluationException {            ++count;            double a = x[1] - x[0] * x[0];            double b = 1.0 - x[0];            return 100 * a * a + b * b;        }        public int getCount() {            return count;        }    }    private static class Powell implements MultivariateRealFunction {        private int count;        public Powell() {            count = 0;        }        public double value(double[] x) throws FunctionEvaluationException {            ++count;            double a = x[0] + 10 * x[1];            double b = x[2] - x[3];            double c = x[1] - 2 * x[2];            double d = x[0] - x[3];            return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d;        }        public int getCount() {            return count;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.linear;import java.util.ArrayList;import java.util.Collection;import org.apache.commons.math.TestUtils;import org.apache.commons.math.optimization.GoalType;import org.junit.Assert;import org.junit.Test;public class SimplexTableauTest {    @Test    public void testInitialization() {        LinearObjectiveFunction f = createFunction();        Collection<LinearConstraint> constraints = createConstraints();        SimplexTableau tableau =            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);        double[][] expectedInitialTableau = {                                             {-1, 0,  -1,  -1,  2, 0, 0, 0, -4},                                             { 0, 1, -15, -10, 25, 0, 0, 0,  0},                                             { 0, 0,   1,   0, -1, 1, 0, 0,  2},                                             { 0, 0,   0,   1, -1, 0, 1, 0,  3},                                             { 0, 0,   1,   1, -2, 0, 0, 1,  4}        };        assertMatrixEquals(expectedInitialTableau, tableau.getData());    }    @Test    public void testDropPhase1Objective() {        LinearObjectiveFunction f = createFunction();        Collection<LinearConstraint> constraints = createConstraints();        SimplexTableau tableau =            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);        double[][] expectedTableau = {                                      { 1, -15, -10, 0, 0, 0, 0},                                      { 0,   1,   0, 1, 0, 0, 2},                                      { 0,   0,   1, 0, 1, 0, 3},                                      { 0,   1,   1, 0, 0, 1, 4}        };        tableau.dropPhase1Objective();        assertMatrixEquals(expectedTableau, tableau.getData());    }    @Test    public void testTableauWithNoArtificialVars() {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {15, 10}, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.LEQ, 2));        constraints.add(new LinearConstraint(new double[] {0, 1}, Relationship.LEQ, 3));        constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.LEQ, 4));        SimplexTableau tableau =            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);        double[][] initialTableau = {                                     {1, -15, -10, 25, 0, 0, 0, 0},                                     {0,   1,   0, -1, 1, 0, 0, 2},                                     {0,   0,   1, -1, 0, 1, 0, 3},                                     {0,   1,   1, -2, 0, 0, 1, 4}        };        assertMatrixEquals(initialTableau, tableau.getData());    }    @Test    public void testSerial() {        LinearObjectiveFunction f = createFunction();        Collection<LinearConstraint> constraints = createConstraints();        SimplexTableau tableau =            new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);        Assert.assertEquals(tableau, TestUtils.serializeAndRecover(tableau));    }    private LinearObjectiveFunction createFunction() {        return new LinearObjectiveFunction(new double[] {15, 10}, 0);    }    private Collection<LinearConstraint> createConstraints() {        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.LEQ, 2));        constraints.add(new LinearConstraint(new double[] {0, 1}, Relationship.LEQ, 3));        constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.EQ, 4));        return constraints;    }    private void assertMatrixEquals(double[][] expected, double[][] result) {        Assert.assertEquals("Wrong number of rows.", expected.length, result.length);        for (int i = 0; i < expected.length; i++) {            Assert.assertEquals("Wrong number of columns.", expected[i].length, result[i].length);            for (int j = 0; j < expected[i].length; j++) {                Assert.assertEquals("Wrong value at position [" + i + "," + j + "]", expected[i][j], result[i][j], 1.0e-15);            }        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.linear;import org.junit.Assert;import java.util.ArrayList;import java.util.Collection;import org.apache.commons.math.optimization.GoalType;import org.apache.commons.math.optimization.OptimizationException;import org.apache.commons.math.optimization.RealPointValuePair;import org.junit.Test;public class SimplexSolverTest {    @Test    public void testMath272() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 1, 0 }, Relationship.GEQ,  1));        constraints.add(new LinearConstraint(new double[] { 1, 0, 1 }, Relationship.GEQ,  1));        constraints.add(new LinearConstraint(new double[] { 0, 1, 0 }, Relationship.GEQ,  1));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);        Assert.assertEquals(0.0, solution.getPoint()[0], .0000001);        Assert.assertEquals(1.0, solution.getPoint()[1], .0000001);        Assert.assertEquals(1.0, solution.getPoint()[2], .0000001);        Assert.assertEquals(3.0, solution.getValue(), .0000001);    }    @Test    public void testMath286() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.6, 0.4 }, 0 );        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 23.0));        constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 23.0));        constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0, 0, 0 }, Relationship.GEQ, 10.0));        constraints.add(new LinearConstraint(new double[] { 0, 0, 1, 0, 0, 0 }, Relationship.GEQ, 8.0));        constraints.add(new LinearConstraint(new double[] { 0, 0, 0, 0, 1, 0 }, Relationship.GEQ, 5.0));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);        Assert.assertEquals(25.8, solution.getValue(), .0000001);        Assert.assertEquals(23.0, solution.getPoint()[0] + solution.getPoint()[2] + solution.getPoint()[4], 0.0000001);        Assert.assertEquals(23.0, solution.getPoint()[1] + solution.getPoint()[3] + solution.getPoint()[5], 0.0000001);        Assert.assertTrue(solution.getPoint()[0] >= 10.0 - 0.0000001);        Assert.assertTrue(solution.getPoint()[2] >= 8.0 - 0.0000001);        Assert.assertTrue(solution.getPoint()[4] >= 5.0 - 0.0000001);    }    @Test    public void testDegeneracy() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.7 }, 0 );        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.LEQ, 18.0));        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.GEQ, 10.0));        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.GEQ, 8.0));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);        Assert.assertEquals(13.6, solution.getValue(), .0000001);    }    @Test    public void testMath288() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 7, 3, 0, 0 }, 0 );        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 3, 0, -5, 0 }, Relationship.LEQ, 0.0));        constraints.add(new LinearConstraint(new double[] { 2, 0, 0, -5 }, Relationship.LEQ, 0.0));        constraints.add(new LinearConstraint(new double[] { 0, 3, 0, -5 }, Relationship.LEQ, 0.0));        constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0 }, Relationship.LEQ, 1.0));        constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 0 }, Relationship.LEQ, 1.0));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);        Assert.assertEquals(10.0, solution.getValue(), .0000001);    }    @Test    public void testMath290GEQ() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 5 }, 0 );        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 2, 0 }, Relationship.GEQ, -1.0));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);        Assert.assertEquals(0, solution.getValue(), .0000001);        Assert.assertEquals(0, solution.getPoint()[0], .0000001);        Assert.assertEquals(0, solution.getPoint()[1], .0000001);    }    @Test(expected=NoFeasibleSolutionException.class)    public void testMath290LEQ() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 5 }, 0 );        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 2, 0 }, Relationship.LEQ, -1.0));        SimplexSolver solver = new SimplexSolver();        solver.optimize(f, constraints, GoalType.MINIMIZE, true);    }    @Test    public void testMath293() throws OptimizationException {      LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.4, 0.6}, 0 );      Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();      constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 30.0));      constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 30.0));      constraints.add(new LinearConstraint(new double[] { 0.8, 0.2, 0.0, 0.0, 0.0, 0.0 }, Relationship.GEQ, 10.0));      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.7, 0.3, 0.0, 0.0 }, Relationship.GEQ, 10.0));      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, 10.0));      SimplexSolver solver = new SimplexSolver();      RealPointValuePair solution1 = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);      Assert.assertEquals(15.7143, solution1.getPoint()[0], .0001);      Assert.assertEquals(0.0, solution1.getPoint()[1], .0001);      Assert.assertEquals(14.2857, solution1.getPoint()[2], .0001);      Assert.assertEquals(0.0, solution1.getPoint()[3], .0001);      Assert.assertEquals(0.0, solution1.getPoint()[4], .0001);      Assert.assertEquals(30.0, solution1.getPoint()[5], .0001);      Assert.assertEquals(40.57143, solution1.getValue(), .0001);      double valA = 0.8 * solution1.getPoint()[0] + 0.2 * solution1.getPoint()[1];      double valB = 0.7 * solution1.getPoint()[2] + 0.3 * solution1.getPoint()[3];      double valC = 0.4 * solution1.getPoint()[4] + 0.6 * solution1.getPoint()[5];      f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.4, 0.6}, 0 );      constraints = new ArrayList<LinearConstraint>();      constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 30.0));      constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 30.0));      constraints.add(new LinearConstraint(new double[] { 0.8, 0.2, 0.0, 0.0, 0.0, 0.0 }, Relationship.GEQ, valA));      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.7, 0.3, 0.0, 0.0 }, Relationship.GEQ, valB));      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, valC));      RealPointValuePair solution2 = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);      Assert.assertEquals(40.57143, solution2.getValue(), .0001);    }    @Test    public void testSimplexSolver() throws OptimizationException {        LinearObjectiveFunction f =            new LinearObjectiveFunction(new double[] { 15, 10 }, 7);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2));        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.LEQ, 3));        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 4));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);        Assert.assertEquals(2.0, solution.getPoint()[0], 0.0);        Assert.assertEquals(2.0, solution.getPoint()[1], 0.0);        Assert.assertEquals(57.0, solution.getValue(), 0.0);    }    @Test    public void testSingleVariableAndConstraint() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 3 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 10));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);        Assert.assertEquals(10.0, solution.getPoint()[0], 0.0);        Assert.assertEquals(30.0, solution.getValue(), 0.0);    }    /**     * With no artificial variables needed (no equals and no greater than     * constraints) we can go straight to Phase 2.     */    @Test    public void testModelWithNoArtificialVars() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2));        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.LEQ, 3));        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.LEQ, 4));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);        Assert.assertEquals(2.0, solution.getPoint()[0], 0.0);        Assert.assertEquals(2.0, solution.getPoint()[1], 0.0);        Assert.assertEquals(50.0, solution.getValue(), 0.0);    }    @Test    public void testMinimization() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, -5);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 6));        constraints.add(new LinearConstraint(new double[] { 3, 2 }, Relationship.LEQ, 12));        constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.GEQ, 0));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);        Assert.assertEquals(4.0, solution.getPoint()[0], 0.0);        Assert.assertEquals(0.0, solution.getPoint()[1], 0.0);        Assert.assertEquals(-13.0, solution.getValue(), 0.0);    }    @Test    public void testSolutionWithNegativeDecisionVariable() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.GEQ, 6));        constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 14));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);        Assert.assertEquals(-2.0, solution.getPoint()[0], 0.0);        Assert.assertEquals(8.0, solution.getPoint()[1], 0.0);        Assert.assertEquals(12.0, solution.getValue(), 0.0);    }    @Test(expected = NoFeasibleSolutionException.class)    public void testInfeasibleSolution() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 1));        constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.GEQ, 3));        SimplexSolver solver = new SimplexSolver();        solver.optimize(f, constraints, GoalType.MAXIMIZE, false);    }    @Test(expected = UnboundedSolutionException.class)    public void testUnboundedSolution() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.EQ, 2));        SimplexSolver solver = new SimplexSolver();        solver.optimize(f, constraints, GoalType.MAXIMIZE, false);    }    @Test    public void testRestrictVariablesToNonNegative() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 409, 523, 70, 204, 339 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] {    43,   56, 345,  56,    5 }, Relationship.LEQ,  4567456));        constraints.add(new LinearConstraint(new double[] {    12,   45,   7,  56,   23 }, Relationship.LEQ,    56454));        constraints.add(new LinearConstraint(new double[] {     8,  768,   0,  34, 7456 }, Relationship.LEQ,  1923421));        constraints.add(new LinearConstraint(new double[] { 12342, 2342,  34, 678, 2342 }, Relationship.GEQ,     4356));        constraints.add(new LinearConstraint(new double[] {    45,  678,  76,  52,   23 }, Relationship.EQ,    456356));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);        Assert.assertEquals(2902.92783505155, solution.getPoint()[0], .0000001);        Assert.assertEquals(480.419243986254, solution.getPoint()[1], .0000001);        Assert.assertEquals(0.0, solution.getPoint()[2], .0000001);        Assert.assertEquals(0.0, solution.getPoint()[3], .0000001);        Assert.assertEquals(0.0, solution.getPoint()[4], .0000001);        Assert.assertEquals(1438556.7491409, solution.getValue(), .0000001);    }    @Test    public void testEpsilon() throws OptimizationException {      LinearObjectiveFunction f =          new LinearObjectiveFunction(new double[] { 10, 5, 1 }, 0);      Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();      constraints.add(new LinearConstraint(new double[] {  9, 8, 0 }, Relationship.EQ,  17));      constraints.add(new LinearConstraint(new double[] {  0, 7, 8 }, Relationship.LEQ,  7));      constraints.add(new LinearConstraint(new double[] { 10, 0, 2 }, Relationship.LEQ, 10));      SimplexSolver solver = new SimplexSolver();      RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);      Assert.assertEquals(1.0, solution.getPoint()[0], 0.0);      Assert.assertEquals(1.0, solution.getPoint()[1], 0.0);      Assert.assertEquals(0.0, solution.getPoint()[2], 0.0);      Assert.assertEquals(15.0, solution.getValue(), 0.0);  }    @Test    public void testTrivialModel() throws OptimizationException {        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 1 }, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ,  0));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);        Assert.assertEquals(0, solution.getValue(), .0000001);    }    @Test    public void testLargeModel() throws OptimizationException {        double[] objective = new double[] {                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 12, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           12, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 12, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 12, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 12, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 12, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                                           1, 1, 1, 1, 1, 1};        LinearObjectiveFunction f = new LinearObjectiveFunction(objective, 0);        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();        constraints.add(equationFromString(objective.length, "x0 + x1 + x2 + x3 - x12 = 0"));        constraints.add(equationFromString(objective.length, "x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 - x13 = 0"));        constraints.add(equationFromString(objective.length, "x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 >= 49"));        constraints.add(equationFromString(objective.length, "x0 + x1 + x2 + x3 >= 42"));        constraints.add(equationFromString(objective.length, "x14 + x15 + x16 + x17 - x26 = 0"));        constraints.add(equationFromString(objective.length, "x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x27 = 0"));        constraints.add(equationFromString(objective.length, "x14 + x15 + x16 + x17 - x12 = 0"));        constraints.add(equationFromString(objective.length, "x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x13 = 0"));        constraints.add(equationFromString(objective.length, "x28 + x29 + x30 + x31 - x40 = 0"));        constraints.add(equationFromString(objective.length, "x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 - x41 = 0"));        constraints.add(equationFromString(objective.length, "x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 >= 49"));        constraints.add(equationFromString(objective.length, "x28 + x29 + x30 + x31 >= 42"));        constraints.add(equationFromString(objective.length, "x42 + x43 + x44 + x45 - x54 = 0"));        constraints.add(equationFromString(objective.length, "x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x55 = 0"));        constraints.add(equationFromString(objective.length, "x42 + x43 + x44 + x45 - x40 = 0"));        constraints.add(equationFromString(objective.length, "x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x41 = 0"));        constraints.add(equationFromString(objective.length, "x56 + x57 + x58 + x59 - x68 = 0"));        constraints.add(equationFromString(objective.length, "x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 - x69 = 0"));        constraints.add(equationFromString(objective.length, "x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 >= 51"));        constraints.add(equationFromString(objective.length, "x56 + x57 + x58 + x59 >= 44"));        constraints.add(equationFromString(objective.length, "x70 + x71 + x72 + x73 - x82 = 0"));        constraints.add(equationFromString(objective.length, "x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x83 = 0"));        constraints.add(equationFromString(objective.length, "x70 + x71 + x72 + x73 - x68 = 0"));        constraints.add(equationFromString(objective.length, "x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x69 = 0"));        constraints.add(equationFromString(objective.length, "x84 + x85 + x86 + x87 - x96 = 0"));        constraints.add(equationFromString(objective.length, "x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 - x97 = 0"));        constraints.add(equationFromString(objective.length, "x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 >= 51"));        constraints.add(equationFromString(objective.length, "x84 + x85 + x86 + x87 >= 44"));        constraints.add(equationFromString(objective.length, "x98 + x99 + x100 + x101 - x110 = 0"));        constraints.add(equationFromString(objective.length, "x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x111 = 0"));        constraints.add(equationFromString(objective.length, "x98 + x99 + x100 + x101 - x96 = 0"));        constraints.add(equationFromString(objective.length, "x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x97 = 0"));        constraints.add(equationFromString(objective.length, "x112 + x113 + x114 + x115 - x124 = 0"));        constraints.add(equationFromString(objective.length, "x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 - x125 = 0"));        constraints.add(equationFromString(objective.length, "x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 >= 49"));        constraints.add(equationFromString(objective.length, "x112 + x113 + x114 + x115 >= 42"));        constraints.add(equationFromString(objective.length, "x126 + x127 + x128 + x129 - x138 = 0"));        constraints.add(equationFromString(objective.length, "x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x139 = 0"));        constraints.add(equationFromString(objective.length, "x126 + x127 + x128 + x129 - x124 = 0"));        constraints.add(equationFromString(objective.length, "x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x125 = 0"));        constraints.add(equationFromString(objective.length, "x140 + x141 + x142 + x143 - x152 = 0"));        constraints.add(equationFromString(objective.length, "x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 - x153 = 0"));        constraints.add(equationFromString(objective.length, "x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 >= 59"));        constraints.add(equationFromString(objective.length, "x140 + x141 + x142 + x143 >= 42"));        constraints.add(equationFromString(objective.length, "x154 + x155 + x156 + x157 - x166 = 0"));        constraints.add(equationFromString(objective.length, "x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x167 = 0"));        constraints.add(equationFromString(objective.length, "x154 + x155 + x156 + x157 - x152 = 0"));        constraints.add(equationFromString(objective.length, "x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x153 = 0"));        constraints.add(equationFromString(objective.length, "x83 + x82 - x168 = 0"));        constraints.add(equationFromString(objective.length, "x111 + x110 - x169 = 0"));        constraints.add(equationFromString(objective.length, "x170 - x182 = 0"));        constraints.add(equationFromString(objective.length, "x171 - x183 = 0"));        constraints.add(equationFromString(objective.length, "x172 - x184 = 0"));        constraints.add(equationFromString(objective.length, "x173 - x185 = 0"));        constraints.add(equationFromString(objective.length, "x174 - x186 = 0"));        constraints.add(equationFromString(objective.length, "x175 + x176 - x187 = 0"));        constraints.add(equationFromString(objective.length, "x177 - x188 = 0"));        constraints.add(equationFromString(objective.length, "x178 - x189 = 0"));        constraints.add(equationFromString(objective.length, "x179 - x190 = 0"));        constraints.add(equationFromString(objective.length, "x180 - x191 = 0"));        constraints.add(equationFromString(objective.length, "x181 - x192 = 0"));        constraints.add(equationFromString(objective.length, "x170 - x26 = 0"));        constraints.add(equationFromString(objective.length, "x171 - x27 = 0"));        constraints.add(equationFromString(objective.length, "x172 - x54 = 0"));        constraints.add(equationFromString(objective.length, "x173 - x55 = 0"));        constraints.add(equationFromString(objective.length, "x174 - x168 = 0"));        constraints.add(equationFromString(objective.length, "x177 - x169 = 0"));        constraints.add(equationFromString(objective.length, "x178 - x138 = 0"));        constraints.add(equationFromString(objective.length, "x179 - x139 = 0"));        constraints.add(equationFromString(objective.length, "x180 - x166 = 0"));        constraints.add(equationFromString(objective.length, "x181 - x167 = 0"));        constraints.add(equationFromString(objective.length, "x193 - x205 = 0"));        constraints.add(equationFromString(objective.length, "x194 - x206 = 0"));        constraints.add(equationFromString(objective.length, "x195 - x207 = 0"));        constraints.add(equationFromString(objective.length, "x196 - x208 = 0"));        constraints.add(equationFromString(objective.length, "x197 - x209 = 0"));        constraints.add(equationFromString(objective.length, "x198 + x199 - x210 = 0"));        constraints.add(equationFromString(objective.length, "x200 - x211 = 0"));        constraints.add(equationFromString(objective.length, "x201 - x212 = 0"));        constraints.add(equationFromString(objective.length, "x202 - x213 = 0"));        constraints.add(equationFromString(objective.length, "x203 - x214 = 0"));        constraints.add(equationFromString(objective.length, "x204 - x215 = 0"));        constraints.add(equationFromString(objective.length, "x193 - x182 = 0"));        constraints.add(equationFromString(objective.length, "x194 - x183 = 0"));        constraints.add(equationFromString(objective.length, "x195 - x184 = 0"));        constraints.add(equationFromString(objective.length, "x196 - x185 = 0"));        constraints.add(equationFromString(objective.length, "x197 - x186 = 0"));        constraints.add(equationFromString(objective.length, "x198 + x199 - x187 = 0"));        constraints.add(equationFromString(objective.length, "x200 - x188 = 0"));        constraints.add(equationFromString(objective.length, "x201 - x189 = 0"));        constraints.add(equationFromString(objective.length, "x202 - x190 = 0"));        constraints.add(equationFromString(objective.length, "x203 - x191 = 0"));        constraints.add(equationFromString(objective.length, "x204 - x192 = 0"));        SimplexSolver solver = new SimplexSolver();        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);        Assert.assertEquals(7518.0, solution.getValue(), .0000001);    }    /**     * Converts a test string to a {@link LinearConstraint}.     * Ex: x0 + x1 + x2 + x3 - x12 = 0     */    private LinearConstraint equationFromString(int numCoefficients, String s) {        Relationship relationship;        if (s.contains(">=")) {            relationship = Relationship.GEQ;        } else if (s.contains("<=")) {            relationship = Relationship.LEQ;        } else if (s.contains("=")) {            relationship = Relationship.EQ;        } else {            throw new IllegalArgumentException();        }        String[] equationParts = s.split("[>|<]?=");        double rhs = Double.parseDouble(equationParts[1].trim());        double[] lhs = new double[numCoefficients];        String left = equationParts[0].replaceAll(" ?x", "");        String[] coefficients = left.split(" ");        for (String coefficient : coefficients) {            double value = coefficient.charAt(0) == '-' ? -1 : 1;            int index = Integer.parseInt(coefficient.replaceFirst("[+|-]", "").trim());            lhs[index] = value;        }        return new LinearConstraint(lhs, relationship, rhs);    }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at////   http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.apache.commons.math.optimization.fitting;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.Random;import org.apache.commons.math.analysis.polynomials.PolynomialFunction;import org.apache.commons.math.exception.ConvergenceException;import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;import org.apache.commons.math.util.FastMath;import org.junit.Test;public class PolynomialFitterTest {    @Test    public void testNoError() {        Random randomizer = new Random(64925784252l);        for (int degree = 1; degree < 10; ++degree) {            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);            PolynomialFitter fitter =                new PolynomialFitter(degree, new LevenbergMarquardtOptimizer());            for (int i = 0; i <= degree; ++i) {                fitter.addObservedPoint(1.0, i, p.value(i));            }            PolynomialFunction fitted = fitter.fit();            for (double x = -1.0; x < 1.0; x += 0.01) {                double error = FastMath.abs(p.value(x) - fitted.value(x)) /                               (1.0 + FastMath.abs(p.value(x)));                assertEquals(0.0, error, 1.0e-6);            }        }    }    @Test    public void testSmallError() {        Random randomizer = new Random(53882150042l);        double maxError = 0;        for (int degree = 0; degree < 10; ++degree) {            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);            PolynomialFitter fitter =                new PolynomialFitter(degree, new LevenbergMarquardtOptimizer());            for (double x = -1.0; x < 1.0; x += 0.01) {                fitter.addObservedPoint(1.0, x,                                        p.value(x) + 0.1 * randomizer.nextGaussian());            }            PolynomialFunction fitted = fitter.fit();            for (double x = -1.0; x < 1.0; x += 0.01) {                double error = FastMath.abs(p.value(x) - fitted.value(x)) /                              (1.0 + FastMath.abs(p.value(x)));                maxError = FastMath.max(maxError, error);                assertTrue(FastMath.abs(error) < 0.1);            }        }        assertTrue(maxError > 0.01);    }    @Test    public void testRedundantSolvable() {        // Levenberg-Marquardt should handle redundant information gracefully        checkUnsolvableProblem(new LevenbergMarquardtOptimizer(), true);    }    @Test    public void testRedundantUnsolvable() {        // Gauss-Newton should not be able to solve redundant information        DifferentiableMultivariateVectorialOptimizer optimizer =            new GaussNewtonOptimizer(true);        checkUnsolvableProblem(optimizer, false);    }    private void checkUnsolvableProblem(DifferentiableMultivariateVectorialOptimizer optimizer,                                        boolean solvable) {        Random randomizer = new Random(1248788532l);        for (int degree = 0; degree < 10; ++degree) {            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);            PolynomialFitter fitter = new PolynomialFitter(degree, optimizer);            // reusing the same point over and over again does not bring            // information, the problem cannot be solved in this case for            // degrees greater than 1 (but one point is sufficient for            // degree 0)            for (double x = -1.0; x < 1.0; x += 0.01) {                fitter.addObservedPoint(1.0, 0.0, p.value(0.0));            }            try {                fitter.fit();                assertTrue(solvable || (degree == 0));            } catch(ConvergenceException e) {                assertTrue((! solvable) && (degree > 0));            }        }    }    private PolynomialFunction buildRandomPolynomial(int degree, Random randomizer) {        final double[] coefficients = new double[degree + 1];        for (int i = 0; i <= degree; ++i) {            coefficients[i] = randomizer.nextGaussian();        }        return new PolynomialFunction(coefficients);    }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at////   http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.apache.commons.math.optimization.fitting;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.optimization.OptimizationException;import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;import org.apache.commons.math.util.FastMath;import org.junit.Assert;import org.junit.Test;public class CurveFitterTest {    @Test    public void testMath303()        throws OptimizationException, FunctionEvaluationException {        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        CurveFitter fitter = new CurveFitter(optimizer);        fitter.addObservedPoint(2.805d, 0.6934785852953367d);        fitter.addObservedPoint(2.74333333333333d, 0.6306772025518496d);        fitter.addObservedPoint(1.655d, 0.9474675497289684);        fitter.addObservedPoint(1.725d, 0.9013594835804194d);        ParametricRealFunction sif = new SimpleInverseFunction();        double[] initialguess1 = new double[1];        initialguess1[0] = 1.0d;        Assert.assertEquals(1, fitter.fit(sif, initialguess1).length);        double[] initialguess2 = new double[2];        initialguess2[0] = 1.0d;        initialguess2[1] = .5d;        Assert.assertEquals(2, fitter.fit(sif, initialguess2).length);    }    @Test    public void testMath304()        throws OptimizationException, FunctionEvaluationException {        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        CurveFitter fitter = new CurveFitter(optimizer);        fitter.addObservedPoint(2.805d, 0.6934785852953367d);        fitter.addObservedPoint(2.74333333333333d, 0.6306772025518496d);        fitter.addObservedPoint(1.655d, 0.9474675497289684);        fitter.addObservedPoint(1.725d, 0.9013594835804194d);        ParametricRealFunction sif = new SimpleInverseFunction();        double[] initialguess1 = new double[1];        initialguess1[0] = 1.0d;        Assert.assertEquals(1.6357215104109237, fitter.fit(sif, initialguess1)[0], 1.0e-14);        double[] initialguess2 = new double[1];        initialguess2[0] = 10.0d;        Assert.assertEquals(1.6357215104109237, fitter.fit(sif, initialguess1)[0], 1.0e-14);    }    @Test    public void testMath372()    throws OptimizationException, FunctionEvaluationException {        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();        CurveFitter curveFitter = new CurveFitter(optimizer);        curveFitter.addObservedPoint( 15,  4443);        curveFitter.addObservedPoint( 31,  8493);        curveFitter.addObservedPoint( 62, 17586);        curveFitter.addObservedPoint(125, 30582);        curveFitter.addObservedPoint(250, 45087);        curveFitter.addObservedPoint(500, 50683);        ParametricRealFunction f = new ParametricRealFunction() {            public double value(double x, double[] parameters) {                double a = parameters[0];                double b = parameters[1];                double c = parameters[2];                double d = parameters[3];                return d + ((a - d) / (1 + FastMath.pow(x / c, b)));            }            public double[] gradient(double x, double[] parameters) {                double a = parameters[0];                double b = parameters[1];                double c = parameters[2];                double d = parameters[3];                double[] gradients = new double[4];                double den = 1 + FastMath.pow(x / c, b);                // derivative with respect to a                gradients[0] = 1 / den;                // derivative with respect to b                // in the reported (invalid) issue, there was a sign error here                gradients[1] = -((a - d) * FastMath.pow(x / c, b) * FastMath.log(x / c)) / (den * den);                // derivative with respect to c                gradients[2] = (b * FastMath.pow(x / c, b - 1) * (x / (c * c)) * (a - d)) / (den * den);                // derivative with respect to d                gradients[3] = 1 - (1 / den);                return gradients;            }        };        double[] initialGuess = new double[] { 1500, 0.95, 65, 35000 };        double[] estimatedParameters = curveFitter.fit(f, initialGuess);        Assert.assertEquals( 2411.00, estimatedParameters[0], 500.00);        Assert.assertEquals(    1.62, estimatedParameters[1],   0.04);        Assert.assertEquals(  111.22, estimatedParameters[2],   0.30);        Assert.assertEquals(55347.47, estimatedParameters[3], 300.00);        Assert.assertTrue(optimizer.getRMS() < 600.0);    }    private static class SimpleInverseFunction implements ParametricRealFunction {        public double value(double x, double[] parameters) {            return parameters[0] / x + (parameters.length < 2 ? 0 : parameters[1]);        }        public double[] gradient(double x, double[] doubles) {            double[] gradientVector = new double[doubles.length];            gradientVector[0] = 1 / x;            if (doubles.length >= 2) {                gradientVector[1] = 1;            }            return gradientVector;        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.fitting;import static org.junit.Assert.assertEquals;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.optimization.OptimizationException;import org.apache.commons.math.optimization.general.       LevenbergMarquardtOptimizer;import org.junit.Test;/** * Tests {@link GaussianFitter}. * * @since 2.2 * @version $Revision$ $Date$ */public class GaussianFitterTest {    /** Good data. */    protected static final double[][] DATASET1 = new double[][] {        {4.0254623,  531026.0},        {4.02804905, 664002.0},        {4.02934242, 787079.0},        {4.03128248, 984167.0},        {4.03386923, 1294546.0},        {4.03580929, 1560230.0},        {4.03839603, 1887233.0},        {4.0396894,  2113240.0},        {4.04162946, 2375211.0},        {4.04421621, 2687152.0},        {4.04550958, 2862644.0},        {4.04744964, 3078898.0},        {4.05003639, 3327238.0},        {4.05132976, 3461228.0},        {4.05326982, 3580526.0},        {4.05585657, 3576946.0},        {4.05779662, 3439750.0},        {4.06038337, 3220296.0},        {4.06167674, 3070073.0},        {4.0636168,  2877648.0},        {4.06620355, 2595848.0},        {4.06749692, 2390157.0},        {4.06943698, 2175960.0},        {4.07202373, 1895104.0},        {4.0733171,  1687576.0},        {4.07525716, 1447024.0},        {4.0778439,  1130879.0},        {4.07978396, 904900.0},        {4.08237071, 717104.0},        {4.08366408, 620014.0}    };    /** Poor data: right of peak not symmetric with left of peak. */    protected static final double[][] DATASET2 = new double[][] {        {-20.15,   1523.0},        {-19.65,   1566.0},        {-19.15,   1592.0},        {-18.65,   1927.0},        {-18.15,   3089.0},        {-17.65,   6068.0},        {-17.15,  14239.0},        {-16.65,  34124.0},        {-16.15,  64097.0},        {-15.65, 110352.0},        {-15.15, 164742.0},        {-14.65, 209499.0},        {-14.15, 267274.0},        {-13.65, 283290.0},        {-13.15, 275363.0},        {-12.65, 258014.0},        {-12.15, 225000.0},        {-11.65, 200000.0},        {-11.15, 190000.0},        {-10.65, 185000.0},        {-10.15, 180000.0},        { -9.65, 179000.0},        { -9.15, 178000.0},        { -8.65, 177000.0},        { -8.15, 176000.0},        { -7.65, 175000.0},        { -7.15, 174000.0},        { -6.65, 173000.0},        { -6.15, 172000.0},        { -5.65, 171000.0},        { -5.15, 170000.0}    };    /** Poor data: long tails. */    protected static final double[][] DATASET3 = new double[][] {        {-90.15,   1513.0},        {-80.15,   1514.0},        {-70.15,   1513.0},        {-60.15,   1514.0},        {-50.15,   1513.0},        {-40.15,   1514.0},        {-30.15,   1513.0},        {-20.15,   1523.0},        {-19.65,   1566.0},        {-19.15,   1592.0},        {-18.65,   1927.0},        {-18.15,   3089.0},        {-17.65,   6068.0},        {-17.15,  14239.0},        {-16.65,  34124.0},        {-16.15,  64097.0},        {-15.65, 110352.0},        {-15.15, 164742.0},        {-14.65, 209499.0},        {-14.15, 267274.0},        {-13.65, 283290.0},        {-13.15, 275363.0},        {-12.65, 258014.0},        {-12.15, 214073.0},        {-11.65, 182244.0},        {-11.15, 136419.0},        {-10.65,  97823.0},        {-10.15,  58930.0},        { -9.65,  35404.0},        { -9.15,  16120.0},        { -8.65,   9823.0},        { -8.15,   5064.0},        { -7.65,   2575.0},        { -7.15,   1642.0},        { -6.65,   1101.0},        { -6.15,    812.0},        { -5.65,    690.0},        { -5.15,    565.0},        {  5.15,    564.0},        { 15.15,    565.0},        { 25.15,    564.0},        { 35.15,    565.0},        { 45.15,    564.0},        { 55.15,    565.0},        { 65.15,    564.0},        { 75.15,    565.0}    };    /** Poor data: right of peak is missing. */    protected static final double[][] DATASET4 = new double[][] {        {-20.15,   1523.0},        {-19.65,   1566.0},        {-19.15,   1592.0},        {-18.65,   1927.0},        {-18.15,   3089.0},        {-17.65,   6068.0},        {-17.15,  14239.0},        {-16.65,  34124.0},        {-16.15,  64097.0},        {-15.65, 110352.0},        {-15.15, 164742.0},        {-14.65, 209499.0},        {-14.15, 267274.0},        {-13.65, 283290.0}    };    /** Good data, but few points. */    protected static final double[][] DATASET5 = new double[][] {        {4.0254623,  531026.0},        {4.03128248, 984167.0},        {4.03839603, 1887233.0},        {4.04421621, 2687152.0},        {4.05132976, 3461228.0},        {4.05326982, 3580526.0},        {4.05779662, 3439750.0},        {4.0636168,  2877648.0},        {4.06943698, 2175960.0},        {4.07525716, 1447024.0},        {4.08237071, 717104.0},        {4.08366408, 620014.0}    };    /**     * Basic.     *     * @throws OptimizationException in the event of a test case error     * @throws FunctionEvaluationException in the event of a test case error     */    @Test    public void testFit01()    throws OptimizationException, FunctionEvaluationException {        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());        addDatasetToGaussianFitter(DATASET1, fitter);        GaussianFunction fitFunction = fitter.fit();        assertEquals(99200.86969833552, fitFunction.getA(), 1e-4);        assertEquals(3410515.285208688, fitFunction.getB(), 1e-4);        assertEquals(4.054928275302832, fitFunction.getC(), 1e-4);        assertEquals(0.014609868872574, fitFunction.getD(), 1e-4);    }    /**     * Zero points is not enough observed points.     *     * @throws OptimizationException in the event of a test case error     * @throws FunctionEvaluationException in the event of a test case error     */    @Test(expected=IllegalArgumentException.class)    public void testFit02()    throws OptimizationException, FunctionEvaluationException {        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());        fitter.fit();    }    /**     * Two points is not enough observed points.     *     * @throws OptimizationException in the event of a test case error     * @throws FunctionEvaluationException in the event of a test case error     */    @Test(expected=IllegalArgumentException.class)    public void testFit03()    throws OptimizationException, FunctionEvaluationException {        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());        addDatasetToGaussianFitter(new double[][] {            {4.0254623,  531026.0},            {4.02804905, 664002.0}},            fitter);        fitter.fit();    }    /**     * Poor data: right of peak not symmetric with left of peak.     *     * @throws OptimizationException in the event of a test case error     * @throws FunctionEvaluationException in the event of a test case error     */    @Test    public void testFit04()    throws OptimizationException, FunctionEvaluationException {        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());        addDatasetToGaussianFitter(DATASET2, fitter);        GaussianFunction fitFunction = fitter.fit();        assertEquals(-256534.689445631, fitFunction.getA(), 1e-4);        assertEquals(481328.2181530679, fitFunction.getB(), 1e-4);        assertEquals(-10.5217226891099, fitFunction.getC(), 1e-4);        assertEquals(-7.64248239366800, fitFunction.getD(), 1e-4);    }    /**     * Poor data: long tails.     *     * @throws OptimizationException in the event of a test case error     * @throws FunctionEvaluationException in the event of a test case error     */    @Test    public void testFit05()    throws OptimizationException, FunctionEvaluationException {        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());        addDatasetToGaussianFitter(DATASET3, fitter);        GaussianFunction fitFunction = fitter.fit();        assertEquals(491.6310079258938, fitFunction.getA(), 1e-4);        assertEquals(283508.6800413632, fitFunction.getB(), 1e-4);        assertEquals(-13.2966857238057, fitFunction.getC(), 1e-4);        assertEquals(1.725590356962981, fitFunction.getD(), 1e-4);    }    /**     * Poor data: right of peak is missing.     *     * @throws OptimizationException in the event of a test case error     * @throws FunctionEvaluationException in the event of a test case error     */    @Test    public void testFit06()    throws OptimizationException, FunctionEvaluationException {        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());        addDatasetToGaussianFitter(DATASET4, fitter);        GaussianFunction fitFunction = fitter.fit();        assertEquals(530.3649792355617, fitFunction.getA(), 1e-4);        assertEquals(284517.0835567514, fitFunction.getB(), 1e-4);        assertEquals(-13.5355534565105, fitFunction.getC(), 1e-4);        assertEquals(1.512353018625465, fitFunction.getD(), 1e-4);    }    /**     * Basic with smaller dataset.     *     * @throws OptimizationException in the event of a test case error     * @throws FunctionEvaluationException in the event of a test case error     */    @Test    public void testFit07()    throws OptimizationException, FunctionEvaluationException {        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());        addDatasetToGaussianFitter(DATASET5, fitter);        GaussianFunction fitFunction = fitter.fit();        assertEquals(176748.1400947575, fitFunction.getA(), 1e-4);        assertEquals(3361537.018813906, fitFunction.getB(), 1e-4);        assertEquals(4.054949992747176, fitFunction.getC(), 1e-4);        assertEquals(0.014192380137002, fitFunction.getD(), 1e-4);    }    /**     * Adds the specified points to specified <code>GaussianFitter</code>     * instance.     *     * @param points data points where first dimension is a point index and     *        second dimension is an array of length two representing the point     *        with the first value corresponding to X and the second value     *        corresponding to Y     * @param fitter fitter to which the points in <code>points</code> should be     *        added as observed points     */    protected static void addDatasetToGaussianFitter(double[][] points,                                                     GaussianFitter fitter) {        for (int i = 0; i < points.length; i++) {            fitter.addObservedPoint(points[i][0], points[i][1]);        }    }}
// Licensed to the Apache Software Foundation (ASF) under one// or more contributor license agreements.  See the NOTICE file// distributed with this work for additional information// regarding copyright ownership.  The ASF licenses this file// to you under the Apache License, Version 2.0 (the// "License"); you may not use this file except in compliance// with the License.  You may obtain a copy of the License at////   http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing,// software distributed under the License is distributed on an// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY// KIND, either express or implied.  See the License for the// specific language governing permissions and limitations// under the License.package org.apache.commons.math.optimization.fitting;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.Random;import org.apache.commons.math.optimization.OptimizationException;import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;import org.apache.commons.math.util.FastMath;import org.apache.commons.math.util.MathUtils;import org.junit.Test;public class HarmonicFitterTest {    @Test    public void testNoError() throws OptimizationException {        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);        HarmonicFitter fitter =            new HarmonicFitter(new LevenbergMarquardtOptimizer());        for (double x = 0.0; x < 1.3; x += 0.01) {            fitter.addObservedPoint(1.0, x, f.value(x));        }        HarmonicFunction fitted = fitter.fit();        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 1.0e-13);        assertEquals(f.getPulsation(), fitted.getPulsation(), 1.0e-13);        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.0e-13);        for (double x = -1.0; x < 1.0; x += 0.01) {            assertTrue(FastMath.abs(f.value(x) - fitted.value(x)) < 1.0e-13);        }    }    @Test    public void test1PercentError() throws OptimizationException {        Random randomizer = new Random(64925784252l);        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);        HarmonicFitter fitter =            new HarmonicFitter(new LevenbergMarquardtOptimizer());        for (double x = 0.0; x < 10.0; x += 0.1) {            fitter.addObservedPoint(1.0, x,                                   f.value(x) + 0.01 * randomizer.nextGaussian());        }        HarmonicFunction fitted = fitter.fit();        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 7.6e-4);        assertEquals(f.getPulsation(), fitted.getPulsation(), 2.7e-3);        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.3e-2);    }    @Test    public void testInitialGuess() throws OptimizationException {        Random randomizer = new Random(45314242l);        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);        HarmonicFitter fitter =            new HarmonicFitter(new LevenbergMarquardtOptimizer(), new double[] { 0.15, 3.6, 4.5 });        for (double x = 0.0; x < 10.0; x += 0.1) {            fitter.addObservedPoint(1.0, x,                                   f.value(x) + 0.01 * randomizer.nextGaussian());        }        HarmonicFunction fitted = fitter.fit();        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 1.2e-3);        assertEquals(f.getPulsation(), fitted.getPulsation(), 3.3e-3);        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.7e-2);    }    @Test    public void testUnsorted() throws OptimizationException {        Random randomizer = new Random(64925784252l);        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);        HarmonicFitter fitter =            new HarmonicFitter(new LevenbergMarquardtOptimizer());        // build a regularly spaced array of measurements        int size = 100;        double[] xTab = new double[size];        double[] yTab = new double[size];        for (int i = 0; i < size; ++i) {            xTab[i] = 0.1 * i;            yTab[i] = f.value(xTab[i]) + 0.01 * randomizer.nextGaussian();        }        // shake it        for (int i = 0; i < size; ++i) {            int i1 = randomizer.nextInt(size);            int i2 = randomizer.nextInt(size);            double xTmp = xTab[i1];            double yTmp = yTab[i1];            xTab[i1] = xTab[i2];            yTab[i1] = yTab[i2];            xTab[i2] = xTmp;            yTab[i2] = yTmp;        }        // pass it to the fitter        for (int i = 0; i < size; ++i) {            fitter.addObservedPoint(1.0, xTab[i], yTab[i]);        }        HarmonicFunction fitted = fitter.fit();        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 7.6e-4);        assertEquals(f.getPulsation(), fitted.getPulsation(), 3.5e-3);        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.5e-2);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization.fitting;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.exception.ZeroException;import org.apache.commons.math.optimization.OptimizationException;import org.apache.commons.math.optimization.fitting.CurveFitter;import org.apache.commons.math.optimization.general.       LevenbergMarquardtOptimizer;import org.junit.Test;import static org.junit.Assert.assertEquals;/** * Tests {@link ParametricGaussianFunction}. * * @since 2.2 * @version $Revision$ $Date$ */public class ParametricGaussianFunctionTest {    /** Dataset 1 used by some test cases. */    protected static final double[][] DATASET1 = new double[][] {        {4.0254623,  531026.0},        {4.02804905, 664002.0},        {4.02934242, 787079.0},        {4.03128248, 984167.0},        {4.03386923, 1294546.0},        {4.03580929, 1560230.0},        {4.03839603, 1887233.0},        {4.0396894,  2113240.0},        {4.04162946, 2375211.0},        {4.04421621, 2687152.0},        {4.04550958, 2862644.0},        {4.04744964, 3078898.0},        {4.05003639, 3327238.0},        {4.05132976, 3461228.0},        {4.05326982, 3580526.0},        {4.05585657, 3576946.0},        {4.05779662, 3439750.0},        {4.06038337, 3220296.0},        {4.06167674, 3070073.0},        {4.0636168,  2877648.0},        {4.06620355, 2595848.0},        {4.06749692, 2390157.0},        {4.06943698, 2175960.0},        {4.07202373, 1895104.0},        {4.0733171,  1687576.0},        {4.07525716, 1447024.0},        {4.0778439,  1130879.0},        {4.07978396, 904900.0},        {4.08237071, 717104.0},        {4.08366408, 620014.0}    };    /**     * Using not-so-good initial parameters.     *     * @throws OptimizationException in the event of a test case error     * @throws FunctionEvaluationException in the event of a test case error     */    @Test    public void testFit01()    throws OptimizationException, FunctionEvaluationException {        CurveFitter fitter = new CurveFitter(new LevenbergMarquardtOptimizer());        addDatasetToCurveFitter(DATASET1, fitter);        double[] parameters = fitter.fit(new ParametricGaussianFunction(),                                         new double[] {8.64753e3, 3.483323e6, 4.06322, 1.946857e-2});        assertEquals(99200.94715858076, parameters[0], 1e-4);        assertEquals(3410515.221897707, parameters[1], 1e-4);        assertEquals(4.054928275257894, parameters[2], 1e-4);        assertEquals(0.014609868499860, parameters[3], 1e-4);    }    /**     * Using eye-balled guesses for initial parameters.     *     * @throws OptimizationException in the event of a test case error     * @throws FunctionEvaluationException in the event of a test case error     */    @Test    public void testFit02()    throws OptimizationException, FunctionEvaluationException {        CurveFitter fitter = new CurveFitter(new LevenbergMarquardtOptimizer());        addDatasetToCurveFitter(DATASET1, fitter);        double[] parameters = fitter.fit(new ParametricGaussianFunction(),                                         new double[] {500000.0, 3500000.0, 4.055, 0.025479654});        assertEquals(99200.81836264656, parameters[0], 1e-4);        assertEquals(3410515.327151986, parameters[1], 1e-4);        assertEquals(4.054928275377392, parameters[2], 1e-4);        assertEquals(0.014609869119806, parameters[3], 1e-4);    }    /**     * The parameters array is null.     *     * @throws FunctionEvaluationException in the event of a test case error     */    @Test(expected=IllegalArgumentException.class)    public void testValue01() throws FunctionEvaluationException {        ParametricGaussianFunction f = new ParametricGaussianFunction();        f.value(0.0, null);    }    /**     * The parameters array length is not 4.     *     * @throws FunctionEvaluationException in the event of a test case error     */    @Test(expected=IllegalArgumentException.class)    public void testValue02() throws FunctionEvaluationException {        ParametricGaussianFunction f = new ParametricGaussianFunction();        f.value(0.0, new double[] {0.0, 1.0});    }    /**     * The parameters d is 0.     *     * @throws FunctionEvaluationException in the event of a test case error     */    @Test(expected=ZeroException.class)    public void testValue03() throws FunctionEvaluationException {        ParametricGaussianFunction f = new ParametricGaussianFunction();        f.value(0.0, new double[] {0.0, 1.0, 1.0, 0.0});    }    /**     * Adds the specified points to specified <code>CurveFitter</code> instance.     *     * @param points data points where first dimension is a point index and     *        second dimension is an array of length two representing the point     *        with the first value corresponding to X and the second value     *        corresponding to Y     * @param fitter fitter to which the points in <code>points</code> should be     *        added as observed points     */    protected static void addDatasetToCurveFitter(double[][] points,                                                  CurveFitter fitter) {        for (int i = 0; i < points.length; i++) {            fitter.addObservedPoint(points[i][0], points[i][1]);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.Serializable;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.exception.ConvergenceException;import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;import org.apache.commons.math.analysis.MultivariateMatrixFunction;import org.apache.commons.math.linear.BlockRealMatrix;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;import org.apache.commons.math.random.GaussianRandomGenerator;import org.apache.commons.math.random.JDKRandomGenerator;import org.apache.commons.math.random.RandomVectorGenerator;import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;import org.junit.Test;/** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> *    Minpack Copyright Notice (1999) University of Chicago. *    All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> *  <li>Redistributions of source code must retain the above copyright *      notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above *     copyright notice, this list of conditions and the following *     disclaimer in the documentation and/or other materials provided *     with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment: *     <code>This product includes software developed by the University of *           Chicago, as Operator of Argonne National Laboratory.</code> *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL *     BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */public class MultiStartDifferentiableMultivariateVectorialOptimizerTest {    @Test    public void testTrivial() throws FunctionEvaluationException, OptimizationException {        LinearProblem problem =            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });        DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =            new GaussNewtonOptimizer(true);        JDKRandomGenerator g = new JDKRandomGenerator();        g.setSeed(16069223052l);        RandomVectorGenerator generator =            new UncorrelatedRandomVectorGenerator(1, new GaussianRandomGenerator(g));        MultiStartDifferentiableMultivariateVectorialOptimizer optimizer =            new MultiStartDifferentiableMultivariateVectorialOptimizer(underlyingOptimizer,                                                                       10, generator);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        // no optima before first optimization attempt        try {            optimizer.getOptima();            fail("an exception should have been thrown");        } catch (IllegalStateException ise) {            // expected        }        VectorialPointValuePair optimum =            optimizer.optimize(problem, problem.target, new double[] { 1 }, new double[] { 0 });        assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);        assertEquals(3.0, optimum.getValue()[0], 1.0e-10);        VectorialPointValuePair[] optima = optimizer.getOptima();        assertEquals(10, optima.length);        for (int i = 0; i < optima.length; ++i) {            assertEquals(1.5, optima[i].getPoint()[0], 1.0e-10);            assertEquals(3.0, optima[i].getValue()[0], 1.0e-10);        }        assertTrue(optimizer.getEvaluations() > 20);        assertTrue(optimizer.getEvaluations() < 50);        assertEquals(100, optimizer.getMaxEvaluations());    }    @Test(expected = ConvergenceException.class)    public void testNoOptimum() throws FunctionEvaluationException, OptimizationException {        DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =            new GaussNewtonOptimizer(true);        JDKRandomGenerator g = new JDKRandomGenerator();        g.setSeed(12373523445l);        RandomVectorGenerator generator =            new UncorrelatedRandomVectorGenerator(1, new GaussianRandomGenerator(g));        MultiStartDifferentiableMultivariateVectorialOptimizer optimizer =            new MultiStartDifferentiableMultivariateVectorialOptimizer(underlyingOptimizer,                                                                       10, generator);        optimizer.setMaxEvaluations(100);        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));        optimizer.optimize(new DifferentiableMultivariateVectorialFunction() {                public MultivariateMatrixFunction jacobian() {                    return null;                }                public double[] value(double[] point) throws FunctionEvaluationException {                    throw new FunctionEvaluationException(point[0]);                }            }, new double[] { 2 }, new double[] { 1 }, new double[] { 0 });    }    private static class LinearProblem implements DifferentiableMultivariateVectorialFunction, Serializable {        private static final long serialVersionUID = -8804268799379350190L;        final RealMatrix factors;        final double[] target;        public LinearProblem(double[][] factors, double[] target) {            this.factors = new BlockRealMatrix(factors);            this.target  = target;        }        public double[] value(double[] variables) {            return factors.operate(variables);        }        public MultivariateMatrixFunction jacobian() {            return new MultivariateMatrixFunction() {                private static final long serialVersionUID = -8387467946663627585L;                public double[][] value(double[] point) {                    return factors.getData();                }            };        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import org.apache.commons.math.ConvergenceException;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.optimization.direct.NelderMead;import org.apache.commons.math.random.GaussianRandomGenerator;import org.apache.commons.math.random.JDKRandomGenerator;import org.apache.commons.math.random.RandomVectorGenerator;import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;import org.junit.Test;public class MultiStartMultivariateRealOptimizerTest {  @Test  public void testRosenbrock()    throws FunctionEvaluationException, ConvergenceException {    Rosenbrock rosenbrock = new Rosenbrock();    NelderMead underlying = new NelderMead();    underlying.setStartConfiguration(new double[][] {                                         { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }                                     });    JDKRandomGenerator g = new JDKRandomGenerator();    g.setSeed(16069223052l);    RandomVectorGenerator generator =        new UncorrelatedRandomVectorGenerator(2, new GaussianRandomGenerator(g));    MultiStartMultivariateRealOptimizer optimizer =        new MultiStartMultivariateRealOptimizer(underlying, 10, generator);    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));    optimizer.setMaxEvaluations(1100);    RealPointValuePair optimum =        optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });    assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());    assertTrue(optimizer.getEvaluations() > 900);    assertTrue(optimizer.getEvaluations() < 1200);    assertTrue(optimum.getValue() < 8.0e-4);  }  private static class Rosenbrock implements MultivariateRealFunction {      private int count;      public Rosenbrock() {          count = 0;      }      public double value(double[] x) throws FunctionEvaluationException {          ++count;          double a = x[1] - x[0] * x[0];          double b = 1.0 - x[0];          return 100 * a * a + b * b;      }      public int getCount() {          return count;      }  }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.optimization;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.awt.geom.Point2D;import java.util.ArrayList;import org.apache.commons.math.FunctionEvaluationException;import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;import org.apache.commons.math.analysis.MultivariateRealFunction;import org.apache.commons.math.analysis.MultivariateVectorialFunction;import org.apache.commons.math.analysis.solvers.BrentSolver;import org.apache.commons.math.optimization.general.ConjugateGradientFormula;import org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer;import org.apache.commons.math.random.GaussianRandomGenerator;import org.apache.commons.math.random.JDKRandomGenerator;import org.apache.commons.math.random.RandomVectorGenerator;import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;import org.junit.Test;public class MultiStartDifferentiableMultivariateRealOptimizerTest {    @Test    public void testCircleFitting() throws FunctionEvaluationException {        Circle circle = new Circle();        circle.addPoint( 30.0,  68.0);        circle.addPoint( 50.0,  -6.0);        circle.addPoint(110.0, -20.0);        circle.addPoint( 35.0,  15.0);        circle.addPoint( 45.0,  97.0);        NonLinearConjugateGradientOptimizer underlying =            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);        JDKRandomGenerator g = new JDKRandomGenerator();        g.setSeed(753289573253l);        RandomVectorGenerator generator =            new UncorrelatedRandomVectorGenerator(new double[] { 50.0, 50.0 }, new double[] { 10.0, 10.0 },                                                  new GaussianRandomGenerator(g));        MultiStartDifferentiableMultivariateRealOptimizer optimizer =            new MultiStartDifferentiableMultivariateRealOptimizer(underlying, 10, generator);        optimizer.setMaxEvaluations(100);        assertEquals(100, optimizer.getMaxEvaluations());        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-10));        BrentSolver solver = new BrentSolver();        RealPointValuePair optimum =            optimizer.optimize(circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });        RealPointValuePair[] optima = optimizer.getOptima();        for (RealPointValuePair o : optima) {            Point2D.Double center = new Point2D.Double(o.getPointRef()[0], o.getPointRef()[1]);            assertEquals(69.960161753, circle.getRadius(center), 1.0e-8);            assertEquals(96.075902096, center.x, 1.0e-8);            assertEquals(48.135167894, center.y, 1.0e-8);        }        assertTrue(optimizer.getEvaluations() > 70);        assertTrue(optimizer.getEvaluations() < 90);        assertEquals(3.1267527, optimum.getValue(), 1.0e-8);    }    private static class Circle implements DifferentiableMultivariateRealFunction {        private ArrayList<Point2D.Double> points;        public Circle() {            points  = new ArrayList<Point2D.Double>();        }        public void addPoint(double px, double py) {            points.add(new Point2D.Double(px, py));        }        public double getRadius(Point2D.Double center) {            double r = 0;            for (Point2D.Double point : points) {                r += point.distance(center);            }            return r / points.size();        }        private double[] gradient(double[] point) {            // optimal radius            Point2D.Double center = new Point2D.Double(point[0], point[1]);            double radius = getRadius(center);            // gradient of the sum of squared residuals            double dJdX = 0;            double dJdY = 0;            for (Point2D.Double pk : points) {                double dk = pk.distance(center);                dJdX += (center.x - pk.x) * (dk - radius) / dk;                dJdY += (center.y - pk.y) * (dk - radius) / dk;            }            dJdX *= 2;            dJdY *= 2;            return new double[] { dJdX, dJdY };        }        public double value(double[] variables)        throws IllegalArgumentException, FunctionEvaluationException {            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);            double radius = getRadius(center);            double sum = 0;            for (Point2D.Double point : points) {                double di = point.distance(center) - radius;                sum += di * di;            }            return sum;        }        public MultivariateVectorialFunction gradient() {            return new MultivariateVectorialFunction() {                public double[] value(double[] point) {                    return gradient(point);                }            };        }        public MultivariateRealFunction partialDerivative(final int k) {            return new MultivariateRealFunction() {                public double value(double[] point) {                    return gradient(point)[k];                }            };        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import org.apache.commons.math.TestUtils;import org.junit.Test;public class ComplexFieldTest {    @Test    public void testZero() {        assertEquals(Complex.ZERO, ComplexField.getInstance().getZero());    }    @Test    public void testOne() {        assertEquals(Complex.ONE, ComplexField.getInstance().getOne());    }    @Test    public void testSerial() {        // deserializing the singleton should give the singleton itself back        ComplexField field = ComplexField.getInstance();        assertTrue(field == TestUtils.serializeAndRecover(field));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import java.util.List;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class ComplexTest extends TestCase {    private double inf = Double.POSITIVE_INFINITY;    private double neginf = Double.NEGATIVE_INFINITY;    private double nan = Double.NaN;    private double pi = FastMath.PI;    private Complex oneInf = new Complex(1, inf);    private Complex oneNegInf = new Complex(1, neginf);    private Complex infOne = new Complex(inf, 1);    private Complex infZero = new Complex(inf, 0);    private Complex infNaN = new Complex(inf, nan);    private Complex infNegInf = new Complex(inf, neginf);    private Complex infInf = new Complex(inf, inf);    private Complex negInfInf = new Complex(neginf, inf);    private Complex negInfZero = new Complex(neginf, 0);    private Complex negInfOne = new Complex(neginf, 1);    private Complex negInfNaN = new Complex(neginf, nan);    private Complex negInfNegInf = new Complex(neginf, neginf);    private Complex oneNaN = new Complex(1, nan);    private Complex zeroInf = new Complex(0, inf);    private Complex zeroNaN = new Complex(0, nan);    private Complex nanInf = new Complex(nan, inf);    private Complex nanNegInf = new Complex(nan, neginf);    private Complex nanZero = new Complex(nan, 0);    public void testConstructor() {        Complex z = new Complex(3.0, 4.0);        assertEquals(3.0, z.getReal(), 1.0e-5);        assertEquals(4.0, z.getImaginary(), 1.0e-5);    }    public void testConstructorNaN() {        Complex z = new Complex(3.0, Double.NaN);        assertTrue(z.isNaN());        z = new Complex(nan, 4.0);        assertTrue(z.isNaN());        z = new Complex(3.0, 4.0);        assertFalse(z.isNaN());    }    public void testAbs() {        Complex z = new Complex(3.0, 4.0);        assertEquals(5.0, z.abs(), 1.0e-5);    }    public void testAbsNaN() {        assertTrue(Double.isNaN(Complex.NaN.abs()));        Complex z = new Complex(inf, nan);        assertTrue(Double.isNaN(z.abs()));    }    public void testAbsInfinite() {        Complex z = new Complex(inf, 0);        assertEquals(inf, z.abs(), 0);        z = new Complex(0, neginf);        assertEquals(inf, z.abs(), 0);        z = new Complex(inf, neginf);        assertEquals(inf, z.abs(), 0);    }    public void testAdd() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.add(y);        assertEquals(8.0, z.getReal(), 1.0e-5);        assertEquals(10.0, z.getImaginary(), 1.0e-5);    }    public void testAddNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.add(Complex.NaN);        assertTrue(z.isNaN());        z = new Complex(1, nan);        Complex w = x.add(z);        assertEquals(w.getReal(), 4.0, 0);        assertTrue(Double.isNaN(w.getImaginary()));    }    public void testAddInfinite() {        Complex x = new Complex(1, 1);        Complex z = new Complex(inf, 0);        Complex w = x.add(z);        assertEquals(w.getImaginary(), 1, 0);        assertEquals(inf, w.getReal(), 0);        x = new Complex(neginf, 0);        assertTrue(Double.isNaN(x.add(z).getReal()));    }    public void testConjugate() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.conjugate();        assertEquals(3.0, z.getReal(), 1.0e-5);        assertEquals(-4.0, z.getImaginary(), 1.0e-5);    }    public void testConjugateNaN() {        Complex z = Complex.NaN.conjugate();        assertTrue(z.isNaN());    }    public void testConjugateInfiinite() {        Complex z = new Complex(0, inf);        assertEquals(neginf, z.conjugate().getImaginary(), 0);        z = new Complex(0, neginf);        assertEquals(inf, z.conjugate().getImaginary(), 0);    }    public void testDivide() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.divide(y);        assertEquals(39.0 / 61.0, z.getReal(), 1.0e-5);        assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5);    }    public void testDivideReal() {        Complex x = new Complex(2d, 3d);        Complex y = new Complex(2d, 0d);        assertEquals(new Complex(1d, 1.5), x.divide(y));    }    public void testDivideImaginary() {        Complex x = new Complex(2d, 3d);        Complex y = new Complex(0d, 2d);        assertEquals(new Complex(1.5d, -1d), x.divide(y));    }    public void testDivideInfinite() {        Complex x = new Complex(3, 4);        Complex w = new Complex(neginf, inf);        assertTrue(x.divide(w).equals(Complex.ZERO));        Complex z = w.divide(x);        assertTrue(Double.isNaN(z.getReal()));        assertEquals(inf, z.getImaginary(), 0);        w = new Complex(inf, inf);        z = w.divide(x);        assertTrue(Double.isNaN(z.getImaginary()));        assertEquals(inf, z.getReal(), 0);        w = new Complex(1, inf);        z = w.divide(w);        assertTrue(Double.isNaN(z.getReal()));        assertTrue(Double.isNaN(z.getImaginary()));    }    public void testDivideZero() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.divide(Complex.ZERO);        assertEquals(z, Complex.NaN);    }    public void testDivideNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.divide(Complex.NaN);        assertTrue(z.isNaN());    }    public void testDivideNaNInf() {       Complex z = oneInf.divide(Complex.ONE);       assertTrue(Double.isNaN(z.getReal()));       assertEquals(inf, z.getImaginary(), 0);       z = negInfNegInf.divide(oneNaN);       assertTrue(Double.isNaN(z.getReal()));       assertTrue(Double.isNaN(z.getImaginary()));       z = negInfInf.divide(Complex.ONE);       assertTrue(Double.isNaN(z.getReal()));       assertTrue(Double.isNaN(z.getImaginary()));    }    public void testMultiply() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.multiply(y);        assertEquals(-9.0, z.getReal(), 1.0e-5);        assertEquals(38.0, z.getImaginary(), 1.0e-5);    }    public void testMultiplyNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.multiply(Complex.NaN);        assertTrue(z.isNaN());    }    public void testMultiplyNaNInf() {        Complex z = new Complex(1,1);        Complex w = z.multiply(infOne);        assertEquals(w.getReal(), inf, 0);        assertEquals(w.getImaginary(), inf, 0);        // [MATH-164]        assertTrue(new Complex( 1,0).multiply(infInf).equals(Complex.INF));        assertTrue(new Complex(-1,0).multiply(infInf).equals(Complex.INF));        assertTrue(new Complex( 1,0).multiply(negInfZero).equals(Complex.INF));        w = oneInf.multiply(oneNegInf);        assertEquals(w.getReal(), inf, 0);        assertEquals(w.getImaginary(), inf, 0);        w = negInfNegInf.multiply(oneNaN);        assertTrue(Double.isNaN(w.getReal()));        assertTrue(Double.isNaN(w.getImaginary()));    }    public void testScalarMultiply() {        Complex x = new Complex(3.0, 4.0);        double y = 2.0;        Complex z = x.multiply(y);        assertEquals(6.0, z.getReal(), 1.0e-5);        assertEquals(8.0, z.getImaginary(), 1.0e-5);    }    public void testScalarMultiplyNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.multiply(Double.NaN);        assertTrue(z.isNaN());    }    public void testScalarMultiplyInf() {        Complex z = new Complex(1,1);        Complex w = z.multiply(Double.POSITIVE_INFINITY);        assertEquals(w.getReal(), inf, 0);        assertEquals(w.getImaginary(), inf, 0);        w = z.multiply(Double.NEGATIVE_INFINITY);        assertEquals(w.getReal(), inf, 0);        assertEquals(w.getImaginary(), inf, 0);    }    public void testNegate() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.negate();        assertEquals(-3.0, z.getReal(), 1.0e-5);        assertEquals(-4.0, z.getImaginary(), 1.0e-5);    }    public void testNegateNaN() {        Complex z = Complex.NaN.negate();        assertTrue(z.isNaN());    }    public void testSubtract() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.subtract(y);        assertEquals(-2.0, z.getReal(), 1.0e-5);        assertEquals(-2.0, z.getImaginary(), 1.0e-5);    }    public void testSubtractNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.subtract(Complex.NaN);        assertTrue(z.isNaN());    }    public void testEqualsNull() {        Complex x = new Complex(3.0, 4.0);        assertFalse(x.equals(null));    }    public void testEqualsClass() {        Complex x = new Complex(3.0, 4.0);        assertFalse(x.equals(this));    }    public void testEqualsSame() {        Complex x = new Complex(3.0, 4.0);        assertTrue(x.equals(x));    }    public void testEqualsTrue() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(3.0, 4.0);        assertTrue(x.equals(y));    }    public void testEqualsRealDifference() {        Complex x = new Complex(0.0, 0.0);        Complex y = new Complex(0.0 + Double.MIN_VALUE, 0.0);        assertFalse(x.equals(y));    }    public void testEqualsImaginaryDifference() {        Complex x = new Complex(0.0, 0.0);        Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);        assertFalse(x.equals(y));    }    public void testEqualsNaN() {        Complex realNaN = new Complex(Double.NaN, 0.0);        Complex imaginaryNaN = new Complex(0.0, Double.NaN);        Complex complexNaN = Complex.NaN;        assertTrue(realNaN.equals(imaginaryNaN));        assertTrue(imaginaryNaN.equals(complexNaN));        assertTrue(realNaN.equals(complexNaN));    }    public void testHashCode() {        Complex x = new Complex(0.0, 0.0);        Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);        assertFalse(x.hashCode()==y.hashCode());        y = new Complex(0.0 + Double.MIN_VALUE, 0.0);        assertFalse(x.hashCode()==y.hashCode());        Complex realNaN = new Complex(Double.NaN, 0.0);        Complex imaginaryNaN = new Complex(0.0, Double.NaN);        assertEquals(realNaN.hashCode(), imaginaryNaN.hashCode());        assertEquals(imaginaryNaN.hashCode(), Complex.NaN.hashCode());    }    public void testAcos() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(0.936812, -2.30551);        TestUtils.assertEquals(expected, z.acos(), 1.0e-5);        TestUtils.assertEquals(new Complex(FastMath.acos(0), 0),                Complex.ZERO.acos(), 1.0e-12);    }    public void testAcosInf() {        TestUtils.assertSame(Complex.NaN, oneInf.acos());        TestUtils.assertSame(Complex.NaN, oneNegInf.acos());        TestUtils.assertSame(Complex.NaN, infOne.acos());        TestUtils.assertSame(Complex.NaN, negInfOne.acos());        TestUtils.assertSame(Complex.NaN, infInf.acos());        TestUtils.assertSame(Complex.NaN, infNegInf.acos());        TestUtils.assertSame(Complex.NaN, negInfInf.acos());        TestUtils.assertSame(Complex.NaN, negInfNegInf.acos());    }    public void testAcosNaN() {        assertTrue(Complex.NaN.acos().isNaN());    }    public void testAsin() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(0.633984, 2.30551);        TestUtils.assertEquals(expected, z.asin(), 1.0e-5);    }    public void testAsinNaN() {        assertTrue(Complex.NaN.asin().isNaN());    }    public void testAsinInf() {        TestUtils.assertSame(Complex.NaN, oneInf.asin());        TestUtils.assertSame(Complex.NaN, oneNegInf.asin());        TestUtils.assertSame(Complex.NaN, infOne.asin());        TestUtils.assertSame(Complex.NaN, negInfOne.asin());        TestUtils.assertSame(Complex.NaN, infInf.asin());        TestUtils.assertSame(Complex.NaN, infNegInf.asin());        TestUtils.assertSame(Complex.NaN, negInfInf.asin());        TestUtils.assertSame(Complex.NaN, negInfNegInf.asin());    }    public void testAtan() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(1.44831, 0.158997);        TestUtils.assertEquals(expected, z.atan(), 1.0e-5);    }    public void testAtanInf() {        TestUtils.assertSame(Complex.NaN, oneInf.atan());        TestUtils.assertSame(Complex.NaN, oneNegInf.atan());        TestUtils.assertSame(Complex.NaN, infOne.atan());        TestUtils.assertSame(Complex.NaN, negInfOne.atan());        TestUtils.assertSame(Complex.NaN, infInf.atan());        TestUtils.assertSame(Complex.NaN, infNegInf.atan());        TestUtils.assertSame(Complex.NaN, negInfInf.atan());        TestUtils.assertSame(Complex.NaN, negInfNegInf.atan());    }    public void testAtanNaN() {        assertTrue(Complex.NaN.atan().isNaN());        assertTrue(Complex.I.atan().isNaN());    }    public void testCos() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-27.03495, -3.851153);        TestUtils.assertEquals(expected, z.cos(), 1.0e-5);    }    public void testCosNaN() {        assertTrue(Complex.NaN.cos().isNaN());    }    public void testCosInf() {        TestUtils.assertSame(infNegInf, oneInf.cos());        TestUtils.assertSame(infInf, oneNegInf.cos());        TestUtils.assertSame(Complex.NaN, infOne.cos());        TestUtils.assertSame(Complex.NaN, negInfOne.cos());        TestUtils.assertSame(Complex.NaN, infInf.cos());        TestUtils.assertSame(Complex.NaN, infNegInf.cos());        TestUtils.assertSame(Complex.NaN, negInfInf.cos());        TestUtils.assertSame(Complex.NaN, negInfNegInf.cos());    }    public void testCosh() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-6.58066, -7.58155);        TestUtils.assertEquals(expected, z.cosh(), 1.0e-5);    }    public void testCoshNaN() {        assertTrue(Complex.NaN.cosh().isNaN());    }    public void testCoshInf() {        TestUtils.assertSame(Complex.NaN, oneInf.cosh());        TestUtils.assertSame(Complex.NaN, oneNegInf.cosh());        TestUtils.assertSame(infInf, infOne.cosh());        TestUtils.assertSame(infNegInf, negInfOne.cosh());        TestUtils.assertSame(Complex.NaN, infInf.cosh());        TestUtils.assertSame(Complex.NaN, infNegInf.cosh());        TestUtils.assertSame(Complex.NaN, negInfInf.cosh());        TestUtils.assertSame(Complex.NaN, negInfNegInf.cosh());    }    public void testExp() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-13.12878, -15.20078);        TestUtils.assertEquals(expected, z.exp(), 1.0e-5);        TestUtils.assertEquals(Complex.ONE,                Complex.ZERO.exp(), 10e-12);        Complex iPi = Complex.I.multiply(new Complex(pi,0));        TestUtils.assertEquals(Complex.ONE.negate(),                iPi.exp(), 10e-12);    }    public void testExpNaN() {        assertTrue(Complex.NaN.exp().isNaN());    }    public void testExpInf() {        TestUtils.assertSame(Complex.NaN, oneInf.exp());        TestUtils.assertSame(Complex.NaN, oneNegInf.exp());        TestUtils.assertSame(infInf, infOne.exp());        TestUtils.assertSame(Complex.ZERO, negInfOne.exp());        TestUtils.assertSame(Complex.NaN, infInf.exp());        TestUtils.assertSame(Complex.NaN, infNegInf.exp());        TestUtils.assertSame(Complex.NaN, negInfInf.exp());        TestUtils.assertSame(Complex.NaN, negInfNegInf.exp());    }    public void testLog() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(1.60944, 0.927295);        TestUtils.assertEquals(expected, z.log(), 1.0e-5);    }    public void testLogNaN() {        assertTrue(Complex.NaN.log().isNaN());    }    public void testLogInf() {        TestUtils.assertEquals(new Complex(inf, pi / 2),                oneInf.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, -pi / 2),                oneNegInf.log(), 10e-12);        TestUtils.assertEquals(infZero, infOne.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, pi),                negInfOne.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, pi / 4),                infInf.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, -pi / 4),                infNegInf.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, 3d * pi / 4),                negInfInf.log(), 10e-12);        TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),                negInfNegInf.log(), 10e-12);    }    public void testLogZero() {        TestUtils.assertSame(negInfZero, Complex.ZERO.log());    }    public void testPow() {        Complex x = new Complex(3, 4);        Complex y = new Complex(5, 6);        Complex expected = new Complex(-1.860893, 11.83677);        TestUtils.assertEquals(expected, x.pow(y), 1.0e-5);    }    public void testPowNaNBase() {        Complex x = new Complex(3, 4);        assertTrue(Complex.NaN.pow(x).isNaN());    }    public void testPowNaNExponent() {        Complex x = new Complex(3, 4);        assertTrue(x.pow(Complex.NaN).isNaN());    }   public void testPowInf() {       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneInf));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneNegInf));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infOne));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infInf));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infNegInf));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfInf));       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfNegInf));       TestUtils.assertSame(Complex.NaN,infOne.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,negInfOne.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,infInf.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,infNegInf.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,negInfInf.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infNegInf));       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(negInfNegInf));       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infInf));       TestUtils.assertSame(Complex.NaN,infInf.pow(infNegInf));       TestUtils.assertSame(Complex.NaN,infInf.pow(negInfNegInf));       TestUtils.assertSame(Complex.NaN,infInf.pow(infInf));       TestUtils.assertSame(Complex.NaN,infNegInf.pow(infNegInf));       TestUtils.assertSame(Complex.NaN,infNegInf.pow(negInfNegInf));       TestUtils.assertSame(Complex.NaN,infNegInf.pow(infInf));   }   public void testPowZero() {       TestUtils.assertSame(Complex.NaN,               Complex.ZERO.pow(Complex.ONE));       TestUtils.assertSame(Complex.NaN,               Complex.ZERO.pow(Complex.ZERO));       TestUtils.assertSame(Complex.NaN,               Complex.ZERO.pow(Complex.I));       TestUtils.assertEquals(Complex.ONE,               Complex.ONE.pow(Complex.ZERO), 10e-12);       TestUtils.assertEquals(Complex.ONE,               Complex.I.pow(Complex.ZERO), 10e-12);       TestUtils.assertEquals(Complex.ONE,               new Complex(-1, 3).pow(Complex.ZERO), 10e-12);   }    public void testpowNull() {        try {            Complex.ONE.pow(null);            fail("Expecting NullPointerException");        } catch (NullPointerException ex) {            // expected        }    }    public void testSin() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(3.853738, -27.01681);        TestUtils.assertEquals(expected, z.sin(), 1.0e-5);    }    public void testSinInf() {        TestUtils.assertSame(infInf, oneInf.sin());        TestUtils.assertSame(infNegInf, oneNegInf.sin());        TestUtils.assertSame(Complex.NaN, infOne.sin());        TestUtils.assertSame(Complex.NaN, negInfOne.sin());        TestUtils.assertSame(Complex.NaN, infInf.sin());        TestUtils.assertSame(Complex.NaN, infNegInf.sin());        TestUtils.assertSame(Complex.NaN, negInfInf.sin());        TestUtils.assertSame(Complex.NaN, negInfNegInf.sin());    }    public void testSinNaN() {        assertTrue(Complex.NaN.sin().isNaN());    }    public void testSinh() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-6.54812, -7.61923);        TestUtils.assertEquals(expected, z.sinh(), 1.0e-5);    }    public void testSinhNaN() {        assertTrue(Complex.NaN.sinh().isNaN());    }    public void testSinhInf() {        TestUtils.assertSame(Complex.NaN, oneInf.sinh());        TestUtils.assertSame(Complex.NaN, oneNegInf.sinh());        TestUtils.assertSame(infInf, infOne.sinh());        TestUtils.assertSame(negInfInf, negInfOne.sinh());        TestUtils.assertSame(Complex.NaN, infInf.sinh());        TestUtils.assertSame(Complex.NaN, infNegInf.sinh());        TestUtils.assertSame(Complex.NaN, negInfInf.sinh());        TestUtils.assertSame(Complex.NaN, negInfNegInf.sinh());    }    public void testSqrtRealPositive() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(2, 1);        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);    }    public void testSqrtRealZero() {        Complex z = new Complex(0.0, 4);        Complex expected = new Complex(1.41421, 1.41421);        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);    }    public void testSqrtRealNegative() {        Complex z = new Complex(-3.0, 4);        Complex expected = new Complex(1, 2);        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);    }    public void testSqrtImaginaryZero() {        Complex z = new Complex(-3.0, 0.0);        Complex expected = new Complex(0.0, 1.73205);        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);    }    public void testSqrtImaginaryNegative() {        Complex z = new Complex(-3.0, -4.0);        Complex expected = new Complex(1.0, -2.0);        TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);    }    public void testSqrtPolar() {        double r = 1;        for (int i = 0; i < 5; i++) {            r += i;            double theta = 0;            for (int j =0; j < 11; j++) {                theta += pi /12;                Complex z = ComplexUtils.polar2Complex(r, theta);                Complex sqrtz = ComplexUtils.polar2Complex(FastMath.sqrt(r), theta / 2);                TestUtils.assertEquals(sqrtz, z.sqrt(), 10e-12);            }        }    }    public void testSqrtNaN() {        assertTrue(Complex.NaN.sqrt().isNaN());    }    public void testSqrtInf() {        TestUtils.assertSame(infNaN, oneInf.sqrt());        TestUtils.assertSame(infNaN, oneNegInf.sqrt());        TestUtils.assertSame(infZero, infOne.sqrt());        TestUtils.assertSame(zeroInf, negInfOne.sqrt());        TestUtils.assertSame(infNaN, infInf.sqrt());        TestUtils.assertSame(infNaN, infNegInf.sqrt());        TestUtils.assertSame(nanInf, negInfInf.sqrt());        TestUtils.assertSame(nanNegInf, negInfNegInf.sqrt());    }    public void testSqrt1z() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(4.08033, -2.94094);        TestUtils.assertEquals(expected, z.sqrt1z(), 1.0e-5);    }    public void testSqrt1zNaN() {        assertTrue(Complex.NaN.sqrt1z().isNaN());    }    public void testTan() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-0.000187346, 0.999356);        TestUtils.assertEquals(expected, z.tan(), 1.0e-5);    }    public void testTanNaN() {        assertTrue(Complex.NaN.tan().isNaN());    }    public void testTanInf() {        TestUtils.assertSame(zeroNaN, oneInf.tan());        TestUtils.assertSame(zeroNaN, oneNegInf.tan());        TestUtils.assertSame(Complex.NaN, infOne.tan());        TestUtils.assertSame(Complex.NaN, negInfOne.tan());        TestUtils.assertSame(Complex.NaN, infInf.tan());        TestUtils.assertSame(Complex.NaN, infNegInf.tan());        TestUtils.assertSame(Complex.NaN, negInfInf.tan());        TestUtils.assertSame(Complex.NaN, negInfNegInf.tan());    }   public void testTanCritical() {        TestUtils.assertSame(infNaN, new Complex(pi/2, 0).tan());        TestUtils.assertSame(negInfNaN, new Complex(-pi/2, 0).tan());    }    public void testTanh() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(1.00071, 0.00490826);        TestUtils.assertEquals(expected, z.tanh(), 1.0e-5);    }    public void testTanhNaN() {        assertTrue(Complex.NaN.tanh().isNaN());    }    public void testTanhInf() {        TestUtils.assertSame(Complex.NaN, oneInf.tanh());        TestUtils.assertSame(Complex.NaN, oneNegInf.tanh());        TestUtils.assertSame(nanZero, infOne.tanh());        TestUtils.assertSame(nanZero, negInfOne.tanh());        TestUtils.assertSame(Complex.NaN, infInf.tanh());        TestUtils.assertSame(Complex.NaN, infNegInf.tanh());        TestUtils.assertSame(Complex.NaN, negInfInf.tanh());        TestUtils.assertSame(Complex.NaN, negInfNegInf.tanh());    }    public void testTanhCritical() {        TestUtils.assertSame(nanInf, new Complex(0, pi/2).tanh());    }    /** test issue MATH-221 */    public void testMath221() {        assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0)));    }    /**     * Test: computing <b>third roots</b> of z.     * <pre>     * <code>     * <b>z = -2 + 2 * i</b>     *   => z_0 =  1      +          i     *   => z_1 = -1.3660 + 0.3660 * i     *   => z_2 =  0.3660 - 1.3660 * i     * </code>     * </pre>     */    public void testNthRoot_normal_thirdRoot() {        // The complex number we want to compute all third-roots for.        Complex z = new Complex(-2,2);        // The List holding all third roots        Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);        // Returned Collection must not be empty!        assertEquals(3, thirdRootsOfZ.length);        // test z_0        assertEquals(1.0,                  thirdRootsOfZ[0].getReal(),      1.0e-5);        assertEquals(1.0,                  thirdRootsOfZ[0].getImaginary(), 1.0e-5);        // test z_1        assertEquals(-1.3660254037844386,  thirdRootsOfZ[1].getReal(),      1.0e-5);        assertEquals(0.36602540378443843,  thirdRootsOfZ[1].getImaginary(), 1.0e-5);        // test z_2        assertEquals(0.366025403784439,    thirdRootsOfZ[2].getReal(),      1.0e-5);        assertEquals(-1.3660254037844384,  thirdRootsOfZ[2].getImaginary(), 1.0e-5);    }    /**     * Test: computing <b>fourth roots</b> of z.     * <pre>     * <code>     * <b>z = 5 - 2 * i</b>     *   => z_0 =  1.5164 - 0.1446 * i     *   => z_1 =  0.1446 + 1.5164 * i     *   => z_2 = -1.5164 + 0.1446 * i     *   => z_3 = -1.5164 - 0.1446 * i     * </code>     * </pre>     */    public void testNthRoot_normal_fourthRoot() {        // The complex number we want to compute all third-roots for.        Complex z = new Complex(5,-2);        // The List holding all fourth roots        Complex[] fourthRootsOfZ = z.nthRoot(4).toArray(new Complex[0]);        // Returned Collection must not be empty!        assertEquals(4, fourthRootsOfZ.length);        // test z_0        assertEquals(1.5164629308487783,     fourthRootsOfZ[0].getReal(),      1.0e-5);        assertEquals(-0.14469266210702247,   fourthRootsOfZ[0].getImaginary(), 1.0e-5);        // test z_1        assertEquals(0.14469266210702256,    fourthRootsOfZ[1].getReal(),      1.0e-5);        assertEquals(1.5164629308487783,     fourthRootsOfZ[1].getImaginary(), 1.0e-5);        // test z_2        assertEquals(-1.5164629308487783,    fourthRootsOfZ[2].getReal(),      1.0e-5);        assertEquals(0.14469266210702267,    fourthRootsOfZ[2].getImaginary(), 1.0e-5);        // test z_3        assertEquals(-0.14469266210702275,   fourthRootsOfZ[3].getReal(),      1.0e-5);        assertEquals(-1.5164629308487783,    fourthRootsOfZ[3].getImaginary(), 1.0e-5);    }    /**     * Test: computing <b>third roots</b> of z.     * <pre>     * <code>     * <b>z = 8</b>     *   => z_0 =  2     *   => z_1 = -1 + 1.73205 * i     *   => z_2 = -1 - 1.73205 * i     * </code>     * </pre>     */    public void testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty() {        // The number 8 has three third roots. One we all already know is the number 2.        // But there are two more complex roots.        Complex z = new Complex(8,0);        // The List holding all third roots        Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);        // Returned Collection must not be empty!        assertEquals(3, thirdRootsOfZ.length);        // test z_0        assertEquals(2.0,                thirdRootsOfZ[0].getReal(),      1.0e-5);        assertEquals(0.0,                thirdRootsOfZ[0].getImaginary(), 1.0e-5);        // test z_1        assertEquals(-1.0,               thirdRootsOfZ[1].getReal(),      1.0e-5);        assertEquals(1.7320508075688774, thirdRootsOfZ[1].getImaginary(), 1.0e-5);        // test z_2        assertEquals(-1.0,               thirdRootsOfZ[2].getReal(),      1.0e-5);        assertEquals(-1.732050807568877, thirdRootsOfZ[2].getImaginary(), 1.0e-5);    }    /**     * Test: computing <b>third roots</b> of z with real part 0.     * <pre>     * <code>     * <b>z = 2 * i</b>     *   => z_0 =  1.0911 + 0.6299 * i     *   => z_1 = -1.0911 + 0.6299 * i     *   => z_2 = -2.3144 - 1.2599 * i     * </code>     * </pre>     */    public void testNthRoot_cornercase_thirdRoot_realPartZero() {        // complex number with only imaginary part        Complex z = new Complex(0,2);        // The List holding all third roots        Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]);        // Returned Collection must not be empty!        assertEquals(3, thirdRootsOfZ.length);        // test z_0        assertEquals(1.0911236359717216,      thirdRootsOfZ[0].getReal(),      1.0e-5);        assertEquals(0.6299605249474365,      thirdRootsOfZ[0].getImaginary(), 1.0e-5);        // test z_1        assertEquals(-1.0911236359717216,     thirdRootsOfZ[1].getReal(),      1.0e-5);        assertEquals(0.6299605249474365,      thirdRootsOfZ[1].getImaginary(), 1.0e-5);        // test z_2        assertEquals(-2.3144374213981936E-16, thirdRootsOfZ[2].getReal(),      1.0e-5);        assertEquals(-1.2599210498948732,     thirdRootsOfZ[2].getImaginary(), 1.0e-5);    }    /**     * Test cornercases with NaN and Infinity.     */    public void testNthRoot_cornercase_NAN_Inf() {        // NaN + finite -> NaN        List<Complex> roots = oneNaN.nthRoot(3);        assertEquals(1,roots.size());        assertEquals(Complex.NaN, roots.get(0));        roots = nanZero.nthRoot(3);        assertEquals(1,roots.size());        assertEquals(Complex.NaN, roots.get(0));        // NaN + infinite -> NaN        roots = nanInf.nthRoot(3);        assertEquals(1,roots.size());        assertEquals(Complex.NaN, roots.get(0));        // finite + infinite -> Inf        roots = oneInf.nthRoot(3);        assertEquals(1,roots.size());        assertEquals(Complex.INF, roots.get(0));        // infinite + infinite -> Inf        roots = negInfInf.nthRoot(3);        assertEquals(1,roots.size());        assertEquals(Complex.INF, roots.get(0));    }    /**     * Test standard values     */    public void testGetArgument() {        Complex z = new Complex(1, 0);        assertEquals(0.0, z.getArgument(), 1.0e-12);        z = new Complex(1, 1);        assertEquals(FastMath.PI/4, z.getArgument(), 1.0e-12);        z = new Complex(0, 1);        assertEquals(FastMath.PI/2, z.getArgument(), 1.0e-12);        z = new Complex(-1, 1);        assertEquals(3 * FastMath.PI/4, z.getArgument(), 1.0e-12);        z = new Complex(-1, 0);        assertEquals(FastMath.PI, z.getArgument(), 1.0e-12);        z = new Complex(-1, -1);        assertEquals(-3 * FastMath.PI/4, z.getArgument(), 1.0e-12);        z = new Complex(0, -1);        assertEquals(-FastMath.PI/2, z.getArgument(), 1.0e-12);        z = new Complex(1, -1);        assertEquals(-FastMath.PI/4, z.getArgument(), 1.0e-12);    }    /**     * Verify atan2-style handling of infinite parts     */    public void testGetArgumentInf() {        assertEquals(FastMath.PI/4, infInf.getArgument(), 1.0e-12);        assertEquals(FastMath.PI/2, oneInf.getArgument(), 1.0e-12);        assertEquals(0.0, infOne.getArgument(), 1.0e-12);        assertEquals(FastMath.PI/2, zeroInf.getArgument(), 1.0e-12);        assertEquals(0.0, infZero.getArgument(), 1.0e-12);        assertEquals(FastMath.PI, negInfOne.getArgument(), 1.0e-12);        assertEquals(-3.0*FastMath.PI/4, negInfNegInf.getArgument(), 1.0e-12);        assertEquals(-FastMath.PI/2, oneNegInf.getArgument(), 1.0e-12);    }    /**     * Verify that either part NaN results in NaN     */    public void testGetArgumentNaN() {        assertEquals(nan, nanZero.getArgument());        assertEquals(nan, zeroNaN.getArgument());        assertEquals(nan, Complex.NaN.getArgument());    }    public void testSerial() {        Complex z = new Complex(3.0, 4.0);        assertEquals(z, TestUtils.serializeAndRecover(z));        Complex ncmplx = (Complex)TestUtils.serializeAndRecover(oneNaN);        assertEquals(nanZero, ncmplx);        assertTrue(ncmplx.isNaN());        Complex infcmplx = (Complex)TestUtils.serializeAndRecover(infInf);        assertEquals(infInf, infcmplx);        assertTrue(infcmplx.isInfinite());        TestComplex tz = new TestComplex(3.0, 4.0);        assertEquals(tz, TestUtils.serializeAndRecover(tz));        TestComplex ntcmplx = (TestComplex)TestUtils.serializeAndRecover(new TestComplex(oneNaN));        assertEquals(nanZero, ntcmplx);        assertTrue(ntcmplx.isNaN());        TestComplex inftcmplx = (TestComplex)TestUtils.serializeAndRecover(new TestComplex(infInf));        assertEquals(infInf, inftcmplx);        assertTrue(inftcmplx.isInfinite());    }    /**     * Class to test extending Complex     */    public static class TestComplex extends Complex {        /**         * Serialization identifier.         */        private static final long serialVersionUID = 3268726724160389237L;        public TestComplex(double real, double imaginary) {            super(real, imaginary);        }        public TestComplex(Complex other){            this(other.getReal(), other.getImaginary());        }        @Override        protected TestComplex createComplex(double real, double imaginary){            return new TestComplex(real, imaginary);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import java.util.Locale;public class FrenchComplexFormatTest extends ComplexFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return ',';    }    @Override    protected Locale getLocale() {        return Locale.FRENCH;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import java.text.NumberFormat;import java.text.ParseException;import java.text.ParsePosition;import java.util.Locale;import org.apache.commons.math.util.CompositeFormat;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;public abstract class ComplexFormatAbstractTest extends TestCase {    CompositeFormat complexFormat = null;    ComplexFormat complexFormatJ = null;    protected abstract Locale getLocale();    protected abstract char getDecimalCharacter();    @Override    protected void setUp() throws Exception {        complexFormat = ComplexFormat.getInstance(getLocale());        complexFormatJ = ComplexFormat.getInstance(getLocale());        complexFormatJ.setImaginaryCharacter("j");    }    public void testSimpleNoDecimals() {        Complex c = new Complex(1, 1);        String expected = "1 + 1i";        String actual = complexFormat.format(c);        assertEquals(expected, actual);    }    public void testSimpleWithDecimals() {        Complex c = new Complex(1.23, 1.43);        String expected = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);        assertEquals(expected, actual);    }    public void testSimpleWithDecimalsTrunc() {        Complex c = new Complex(1.2323, 1.4343);        String expected = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);        assertEquals(expected, actual);    }    public void testNegativeReal() {        Complex c = new Complex(-1.2323, 1.4343);        String expected = "-1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);        assertEquals(expected, actual);    }    public void testNegativeImaginary() {        Complex c = new Complex(1.2323, -1.4343);        String expected = "1" + getDecimalCharacter() + "23 - 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);        assertEquals(expected, actual);    }    public void testNegativeBoth() {        Complex c = new Complex(-1.2323, -1.4343);        String expected = "-1" + getDecimalCharacter() + "23 - 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);        assertEquals(expected, actual);    }    public void testZeroReal() {        Complex c = new Complex(0.0, -1.4343);        String expected = "0 - 1" + getDecimalCharacter() + "43i";        String actual = complexFormat.format(c);        assertEquals(expected, actual);    }    public void testZeroImaginary() {        Complex c = new Complex(30.233, 0);        String expected = "30" + getDecimalCharacter() + "23";        String actual = complexFormat.format(c);        assertEquals(expected, actual);    }    public void testDifferentImaginaryChar() {        Complex c = new Complex(1, 1);        String expected = "1 + 1j";        String actual = complexFormatJ.format(c);        assertEquals(expected, actual);    }    public void testStaticFormatComplex() {        Locale defaultLocal = Locale.getDefault();        Locale.setDefault(getLocale());        Complex c = new Complex(232.222, -342.33);        String expected = "232" + getDecimalCharacter() + "22 - 342" + getDecimalCharacter() + "33i";        String actual = ComplexFormat.formatComplex(c);        assertEquals(expected, actual);        Locale.setDefault(defaultLocal);    }    public void testNan() {        Complex c = new Complex(Double.NaN, Double.NaN);        String expected = "(NaN) + (NaN)i";        String actual = complexFormat.format(c);        assertEquals(expected, actual);    }    public void testPositiveInfinity() {        Complex c = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);        String expected = "(Infinity) + (Infinity)i";        String actual = complexFormat.format(c);        assertEquals(expected, actual);    }    public void testNegativeInfinity() {        Complex c = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);        String expected = "(-Infinity) - (Infinity)i";        String actual = complexFormat.format(c);        assertEquals(expected, actual);    }    public void testParseSimpleNoDecimals() {        String source = "1 + 1i";        Complex expected = new Complex(1, 1);        try {            Complex actual = (Complex)complexFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseSimpleWithDecimals() {        String source = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i";        Complex expected = new Complex(1.23, 1.43);        try {            Complex actual = (Complex)complexFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseSimpleWithDecimalsTrunc() {        String source = "1" + getDecimalCharacter() + "2323 + 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(1.2323, 1.4343);        try {            Complex actual = (Complex)complexFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeReal() {        String source = "-1" + getDecimalCharacter() + "2323 + 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(-1.2323, 1.4343);        try {            Complex actual = (Complex)complexFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeImaginary() {        String source = "1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(1.2323, -1.4343);        try {            Complex actual = (Complex)complexFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNegativeBoth() {        String source = "-1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(-1.2323, -1.4343);        try {            Complex actual = (Complex)complexFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseZeroReal() {        String source = "0" + getDecimalCharacter() + "0 - 1" + getDecimalCharacter() + "4343i";        Complex expected = new Complex(0.0, -1.4343);        try {            Complex actual = (Complex)complexFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseZeroImaginary() {        String source = "-1" + getDecimalCharacter() + "2323";        Complex expected = new Complex(-1.2323, 0);        try {            Complex actual = (Complex)complexFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseDifferentImaginaryChar() {        String source = "-1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343j";        Complex expected = new Complex(-1.2323, -1.4343);        try {            Complex actual = (Complex)complexFormatJ.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParseNan() {        String source = "(NaN) + (NaN)i";        Complex expected = new Complex(Double.NaN, Double.NaN);        try {            Complex actual = (Complex)complexFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testParsePositiveInfinity() {        String source = "(Infinity) + (Infinity)i";        Complex expected = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);        try {            Complex actual = (Complex)complexFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testPaseNegativeInfinity() {        String source = "(-Infinity) - (Infinity)i";        Complex expected = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);        try {            Complex actual = (Complex)complexFormat.parseObject(source);            assertEquals(expected, actual);        } catch (ParseException ex) {            fail(ex.getMessage());        }    }    public void testConstructorSingleFormat() {        NumberFormat nf = NumberFormat.getInstance();        ComplexFormat cf = new ComplexFormat(nf);        assertNotNull(cf);        assertEquals(nf, cf.getRealFormat());    }    public void testGetImaginaryFormat() {        NumberFormat nf = NumberFormat.getInstance();        ComplexFormat cf = new ComplexFormat();        assertNotSame(nf, cf.getImaginaryFormat());        cf.setImaginaryFormat(nf);        assertSame(nf, cf.getImaginaryFormat());    }    public void testSetImaginaryFormatNull() {        try {            ComplexFormat cf = new ComplexFormat();            cf.setImaginaryFormat(null);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }    public void testSetRealFormatNull() {        try {            ComplexFormat cf = new ComplexFormat();            cf.setRealFormat(null);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }    public void testGetRealFormat() {        NumberFormat nf = NumberFormat.getInstance();        ComplexFormat cf = new ComplexFormat();        assertNotSame(nf, cf.getRealFormat());        cf.setRealFormat(nf);        assertSame(nf, cf.getRealFormat());    }    public void testSetImaginaryCharacterNull() {        try {            ComplexFormat cf = new ComplexFormat();            cf.setImaginaryCharacter(null);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }    public void testSetImaginaryCharacterEmpty() {        try {            ComplexFormat cf = new ComplexFormat();            cf.setImaginaryCharacter("");            fail();        } catch (IllegalArgumentException ex) {            // success        }    }    public void testFormatNumber() {        CompositeFormat cf = ComplexFormat.getInstance(getLocale());        Double pi = Double.valueOf(FastMath.PI);        String text = cf.format(pi);        assertEquals("3" + getDecimalCharacter() + "14", text);    }    public void testFormatObject() {        try {            CompositeFormat cf = new ComplexFormat();            Object object = new Object();            cf.format(object);            fail();        } catch (IllegalArgumentException ex) {            // success        }    }    public void testForgottenImaginaryCharacter() {        ParsePosition pos = new ParsePosition(0);        assertNull(new ComplexFormat().parse("1 + 1", pos));        assertEquals(5, pos.getErrorIndex());    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import org.apache.commons.math.TestUtils;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class ComplexUtilsTest extends TestCase {    private double inf = Double.POSITIVE_INFINITY;    private double negInf = Double.NEGATIVE_INFINITY;    private double nan = Double.NaN;    private double pi = FastMath.PI;    private Complex negInfInf = new Complex(negInf, inf);    private Complex infNegInf = new Complex(inf, negInf);    private Complex infInf = new Complex(inf, inf);    private Complex negInfNegInf = new Complex(negInf, negInf);    private Complex infNaN = new Complex(inf, nan);    public void testPolar2Complex() {        TestUtils.assertEquals(Complex.ONE,                ComplexUtils.polar2Complex(1, 0), 10e-12);        TestUtils.assertEquals(Complex.ZERO,                ComplexUtils.polar2Complex(0, 1), 10e-12);        TestUtils.assertEquals(Complex.ZERO,                ComplexUtils.polar2Complex(0, -1), 10e-12);        TestUtils.assertEquals(Complex.I,                ComplexUtils.polar2Complex(1, pi/2), 10e-12);        TestUtils.assertEquals(Complex.I.negate(),                ComplexUtils.polar2Complex(1, -pi/2), 10e-12);        double r = 0;        for (int i = 0; i < 5; i++) {          r += i;          double theta = 0;          for (int j =0; j < 20; j++) {              theta += pi / 6;              TestUtils.assertEquals(altPolar(r, theta),                      ComplexUtils.polar2Complex(r, theta), 10e-12);          }          theta = -2 * pi;          for (int j =0; j < 20; j++) {              theta -= pi / 6;              TestUtils.assertEquals(altPolar(r, theta),                      ComplexUtils.polar2Complex(r, theta), 10e-12);          }        }    }    protected Complex altPolar(double r, double theta) {        return Complex.I.multiply(new Complex(theta, 0)).exp().multiply(new Complex(r, 0));    }    public void testPolar2ComplexIllegalModulus() {        try {            ComplexUtils.polar2Complex(-1, 0);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }    }    public void testPolar2ComplexNaN() {        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(nan, 1));        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, nan));        TestUtils.assertSame(Complex.NaN,                ComplexUtils.polar2Complex(nan, nan));    }    public void testPolar2ComplexInf() {        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, inf));        TestUtils.assertSame(Complex.NaN,                ComplexUtils.polar2Complex(1, negInf));        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(inf, inf));        TestUtils.assertSame(Complex.NaN,                ComplexUtils.polar2Complex(inf, negInf));        TestUtils.assertSame(infInf, ComplexUtils.polar2Complex(inf, pi/4));        TestUtils.assertSame(infNaN, ComplexUtils.polar2Complex(inf, 0));        TestUtils.assertSame(infNegInf, ComplexUtils.polar2Complex(inf, -pi/4));        TestUtils.assertSame(negInfInf, ComplexUtils.polar2Complex(inf, 3*pi/4));        TestUtils.assertSame(negInfNegInf, ComplexUtils.polar2Complex(inf, 5*pi/4));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import java.util.Locale;public class ComplexFormatTest extends ComplexFormatAbstractTest {    @Override    protected char getDecimalCharacter() {        return '.';    }    @Override    protected Locale getLocale() {        return Locale.US;    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.util.Locale;import org.apache.commons.math.util.FastMath;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class ArgumentOutsideDomainExceptionTest extends TestCase {    public void testConstructor(){        ArgumentOutsideDomainException ex = new ArgumentOutsideDomainException(FastMath.PI, 10.0, 20.0);        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertTrue(ex.getMessage().indexOf("3.14") > 0);        assertEquals(FastMath.PI, ex.getArgument()[0], 0);        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import junit.framework.TestCase;import java.io.ByteArrayOutputStream;import java.io.PrintStream;import java.io.PrintWriter;import java.util.Locale;import org.apache.commons.math.exception.util.DummyLocalizable;import org.apache.commons.math.exception.util.Localizable;import org.apache.commons.math.exception.util.LocalizedFormats;/** * @version $Revision$ $Date$ */public class MathExceptionTest extends TestCase {    public void testConstructor(){        MathException ex = new MathException();        assertNull(ex.getCause());        assertEquals("", ex.getMessage());        assertEquals("", ex.getMessage(Locale.FRENCH));    }    public void testConstructorPatternArguments(){        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };        MathException ex = new MathException(pattern, arguments);        assertNull(ex.getCause());        assertEquals(pattern, ex.getLocalizablePattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    public void testConstructorCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathException ex = new MathException(cause);        assertEquals(cause, ex.getCause());    }    public void testConstructorPatternArgumentsCause(){        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathException ex = new MathException(cause, pattern, arguments);        assertEquals(cause, ex.getCause());        assertEquals(pattern, ex.getLocalizablePattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    /**     * Tests the printStackTrace() operation.     */    public void testPrintStackTrace() {        Localizable outMsg = new DummyLocalizable("outer message");        Localizable inMsg = new DummyLocalizable("inner message");        MathException cause = new MathConfigurationException(inMsg);        MathException ex = new MathException(cause, outMsg);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        PrintStream ps = new PrintStream(baos);        ex.printStackTrace(ps);        String stack = baos.toString();        String outerMsg = "org.apache.commons.math.MathException: outer message";        String innerMsg = "Caused by: " +        "org.apache.commons.math.MathConfigurationException: inner message";        assertTrue(stack.startsWith(outerMsg));        assertTrue(stack.indexOf(innerMsg) > 0);        PrintWriter pw = new PrintWriter(ps, true);        ex.printStackTrace(pw);        stack = baos.toString();        assertTrue(stack.startsWith(outerMsg));        assertTrue(stack.indexOf(innerMsg) > 0);    }    /**     * Test serialization     */    public void testSerialization() {        Localizable outMsg = new DummyLocalizable("outer message");        Localizable inMsg = new DummyLocalizable("inner message");        MathException cause = new MathConfigurationException(inMsg);        MathException ex = new MathException(cause, outMsg);        MathException image = (MathException) TestUtils.serializeAndRecover(ex);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        PrintStream ps = new PrintStream(baos);        ex.printStackTrace(ps);        String stack = baos.toString();        ByteArrayOutputStream baos2 = new ByteArrayOutputStream();        PrintStream ps2 = new PrintStream(baos2);        image.printStackTrace(ps2);        String stack2 = baos2.toString();        // See if JDK supports nested exceptions.  If not, stack trace of        // inner exception will not be serialized        boolean jdkSupportsNesting = false;        try {            Throwable.class.getDeclaredMethod("getCause", new Class[0]);            jdkSupportsNesting = true;        } catch (NoSuchMethodException e) {            jdkSupportsNesting = false;        }        if (jdkSupportsNesting) {            assertEquals(stack, stack2);        } else {            assertTrue(stack2.indexOf(inMsg.getSourceString()) != -1);            assertTrue(stack2.indexOf("MathConfigurationException") != -1);        }    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.util.Locale;import org.apache.commons.math.exception.util.LocalizedFormats;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class MaxIterationsExceededExceptionTest extends TestCase {    public void testSimpleConstructor(){        MaxIterationsExceededException ex = new MaxIterationsExceededException(1000000);        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertTrue(ex.getMessage().indexOf("1,000,000") > 0);        assertEquals(1000000, ex.getMaxIterations());        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    public void testComplexConstructor(){        MaxIterationsExceededException ex =            new MaxIterationsExceededException(1000000,                LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,                1234567);        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertTrue(ex.getMessage().indexOf("1,000,000") < 0);        assertTrue(ex.getMessage().indexOf("1,234,567") > 0);        assertEquals(1000000, ex.getMaxIterations());        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.util.Locale;import org.apache.commons.math.exception.util.LocalizedFormats;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class FunctionEvaluationExceptionTest extends TestCase {    public void testConstructor(){        FunctionEvaluationException ex = new FunctionEvaluationException(0.0);        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertTrue(ex.getMessage().indexOf("0") > 0);        assertEquals(0.0, ex.getArgument()[0], 0);    }    public void testConstructorArray(){        FunctionEvaluationException ex =            new FunctionEvaluationException(new double[] { 0, 1, 2 });        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertTrue(ex.getMessage().indexOf("0") > 0);        assertEquals(0.0, ex.getArgument()[0], 0);        assertEquals(1.0, ex.getArgument()[1], 0);        assertEquals(2.0, ex.getArgument()[2], 0);    }    public void testConstructorPatternArguments(){        LocalizedFormats pattern = LocalizedFormats.EVALUATION_FAILED;        Object[] arguments = { Double.valueOf(0.0) };        FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments);        assertNull(ex.getCause());        assertEquals(pattern, ex.getLocalizablePattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    public void testConstructorArrayPatternArguments(){        LocalizedFormats pattern = LocalizedFormats.EVALUATION_FAILED;        Object[] arguments = { Double.valueOf(0.0) };        FunctionEvaluationException ex =            new FunctionEvaluationException(new double[] { 0, 1, 2 }, pattern, arguments);        assertNull(ex.getCause());        assertEquals(pattern, ex.getLocalizablePattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));        assertEquals(0.0, ex.getArgument()[0], 0);        assertEquals(1.0, ex.getArgument()[1], 0);        assertEquals(2.0, ex.getArgument()[2], 0);    }    public void testConstructorPatternArgumentsCause(){        LocalizedFormats pattern = LocalizedFormats.EVALUATION_FAILED;        Object[] arguments = { Double.valueOf(0.0) };        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        FunctionEvaluationException ex = new FunctionEvaluationException(cause, 0.0, pattern, arguments);        assertEquals(cause, ex.getCause());        assertEquals(pattern, ex.getLocalizablePattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    public void testConstructorArrayPatternArgumentsCause(){        LocalizedFormats pattern = LocalizedFormats.EVALUATION_FAILED;        Object[] arguments = { Double.valueOf(0.0) };        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        FunctionEvaluationException ex =            new FunctionEvaluationException(cause, new double[] { 0, 1, 2 }, pattern, arguments);        assertEquals(cause, ex.getCause());        assertEquals(pattern, ex.getLocalizablePattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));        assertEquals(0.0, ex.getArgument()[0], 0);        assertEquals(1.0, ex.getArgument()[1], 0);        assertEquals(2.0, ex.getArgument()[2], 0);    }    public void testConstructorArgumentCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        FunctionEvaluationException ex = new FunctionEvaluationException(cause, 0.0);        assertEquals(cause, ex.getCause());        assertTrue(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    public void testConstructorArrayArgumentCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        FunctionEvaluationException ex =            new FunctionEvaluationException(cause, new double[] { 0, 1, 2 });        assertEquals(cause, ex.getCause());        assertTrue(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));        assertEquals(0.0, ex.getArgument()[0], 0);        assertEquals(1.0, ex.getArgument()[1], 0);        assertEquals(2.0, ex.getArgument()[2], 0);    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import junit.framework.TestCase;import java.util.Locale;import org.apache.commons.math.exception.util.LocalizedFormats;/** * @version $Revision$ $Date$ */public class MathConfigurationExceptionTest extends TestCase {    public void testConstructor(){        MathConfigurationException ex = new MathConfigurationException();        assertNull(ex.getCause());        assertEquals("", ex.getMessage());        assertEquals("", ex.getMessage(Locale.FRENCH));    }    public void testConstructorPatternArguments(){        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };        MathConfigurationException ex = new MathConfigurationException(pattern, arguments);        assertNull(ex.getCause());        assertEquals(pattern, ex.getLocalizablePattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    public void testConstructorCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathConfigurationException ex = new MathConfigurationException(cause);        assertEquals(cause, ex.getCause());    }    public void testConstructorPatternArgumentsCause(){        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathConfigurationException ex = new MathConfigurationException(cause, pattern, arguments);        assertEquals(cause, ex.getCause());        assertEquals(pattern, ex.getLocalizablePattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.text.DecimalFormat;import junit.framework.Assert;import junit.framework.AssertionFailedError;import org.apache.commons.math.complex.Complex;import org.apache.commons.math.complex.ComplexFormat;import org.apache.commons.math.distribution.ContinuousDistribution;import org.apache.commons.math.linear.FieldMatrix;import org.apache.commons.math.linear.RealMatrix;import org.apache.commons.math.stat.inference.ChiSquareTest;import org.apache.commons.math.stat.inference.ChiSquareTestImpl;import org.apache.commons.math.util.FastMath;/** * @version $Revision$ $Date$ */public class TestUtils {    /**     * Collection of static methods used in math unit tests.     */    private TestUtils() {        super();    }    /**     * Verifies that expected and actual are within delta, or are both NaN or     * infinities of the same sign.     */    public static void assertEquals(double expected, double actual, double delta) {        assertEquals(null, expected, actual, delta);    }    /**     * Verifies that expected and actual are within delta, or are both NaN or     * infinities of the same sign.     */    public static void assertEquals(String msg, double expected, double actual, double delta) {        // check for NaN        if(Double.isNaN(expected)){            Assert.assertTrue("" + actual + " is not NaN.",                Double.isNaN(actual));        } else {            Assert.assertEquals(msg, expected, actual, delta);        }    }    /**     * Verifies that the two arguments are exactly the same, either     * both NaN or infinities of same sign, or identical floating point values.     */    public static void assertSame(double expected, double actual) {     assertEquals(expected, actual, 0);    }    /**     * Verifies that real and imaginary parts of the two complex arguments     * are exactly the same.  Also ensures that NaN / infinite components match.     */    public static void assertSame(Complex expected, Complex actual) {        assertSame(expected.getReal(), actual.getReal());        assertSame(expected.getImaginary(), actual.getImaginary());    }    /**     * Verifies that real and imaginary parts of the two complex arguments     * differ by at most delta.  Also ensures that NaN / infinite components match.     */    public static void assertEquals(Complex expected, Complex actual, double delta) {        assertEquals(expected.getReal(), actual.getReal(), delta);        assertEquals(expected.getImaginary(), actual.getImaginary(), delta);    }    /**     * Verifies that two double arrays have equal entries, up to tolerance     */    public static void assertEquals(double expected[], double observed[], double tolerance) {        assertEquals("Array comparison failure", expected, observed, tolerance);    }    /**     * Serializes an object to a bytes array and then recovers the object from the bytes array.     * Returns the deserialized object.     *     * @param o  object to serialize and recover     * @return  the recovered, deserialized object     */    public static Object serializeAndRecover(Object o) {        try {            // serialize the Object            ByteArrayOutputStream bos = new ByteArrayOutputStream();            ObjectOutputStream so = new ObjectOutputStream(bos);            so.writeObject(o);            // deserialize the Object            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());            ObjectInputStream si = new ObjectInputStream(bis);            return si.readObject();        } catch (IOException ioe) {            return null;        } catch (ClassNotFoundException cnfe) {            return null;        }    }    /**     * Verifies that serialization preserves equals and hashCode.     * Serializes the object, then recovers it and checks equals and hash code.     *     * @param object  the object to serialize and recover     */    public static void checkSerializedEquality(Object object) {        Object object2 = serializeAndRecover(object);        Assert.assertEquals("Equals check", object, object2);        Assert.assertEquals("HashCode check", object.hashCode(), object2.hashCode());    }    /**     * Verifies that the relative error in actual vs. expected is less than or     * equal to relativeError.  If expected is infinite or NaN, actual must be     * the same (NaN or infinity of the same sign).     *     * @param expected expected value     * @param actual  observed value     * @param relativeError  maximum allowable relative error     */    public static void assertRelativelyEquals(double expected, double actual,            double relativeError) {        assertRelativelyEquals(null, expected, actual, relativeError);    }    /**     * Verifies that the relative error in actual vs. expected is less than or     * equal to relativeError.  If expected is infinite or NaN, actual must be     * the same (NaN or infinity of the same sign).     *     * @param msg  message to return with failure     * @param expected expected value     * @param actual  observed value     * @param relativeError  maximum allowable relative error     */    public static void assertRelativelyEquals(String msg, double expected,            double actual, double relativeError) {        if (Double.isNaN(expected)) {            Assert.assertTrue(msg, Double.isNaN(actual));        } else if (Double.isNaN(actual)) {            Assert.assertTrue(msg, Double.isNaN(expected));        } else if (Double.isInfinite(actual) || Double.isInfinite(expected)) {            Assert.assertEquals(expected, actual, relativeError);        } else if (expected == 0.0) {            Assert.assertEquals(msg, actual, expected, relativeError);        } else {            double absError = FastMath.abs(expected) * relativeError;            Assert.assertEquals(msg, expected, actual, absError);        }    }    /**     * Fails iff values does not contain a number within epsilon of z.     *     * @param msg  message to return with failure     * @param values complex array to search     * @param z  value sought     * @param epsilon  tolerance     */    public static void assertContains(String msg, Complex[] values,            Complex z, double epsilon) {        int i = 0;        boolean found = false;        while (!found && i < values.length) {            try {                assertEquals(values[i], z, epsilon);                found = true;            } catch (AssertionFailedError er) {                // no match            }            i++;        }        if (!found) {            Assert.fail(msg +                " Unable to find " + ComplexFormat.formatComplex(z));        }    }    /**     * Fails iff values does not contain a number within epsilon of z.     *     * @param values complex array to search     * @param z  value sought     * @param epsilon  tolerance     */    public static void assertContains(Complex[] values,            Complex z, double epsilon) {        assertContains(null, values, z, epsilon);    }    /**     * Fails iff values does not contain a number within epsilon of x.     *     * @param msg  message to return with failure     * @param values double array to search     * @param x value sought     * @param epsilon  tolerance     */    public static void assertContains(String msg, double[] values,            double x, double epsilon) {        int i = 0;        boolean found = false;        while (!found && i < values.length) {            try {                assertEquals(values[i], x, epsilon);                found = true;            } catch (AssertionFailedError er) {                // no match            }            i++;        }        if (!found) {            Assert.fail(msg + " Unable to find" + x);        }    }    /**     * Fails iff values does not contain a number within epsilon of x.     *     * @param values double array to search     * @param x value sought     * @param epsilon  tolerance     */    public static void assertContains(double[] values, double x,            double epsilon) {       assertContains(null, values, x, epsilon);    }    /** verifies that two matrices are close (1-norm) */    public static void assertEquals(String msg, RealMatrix expected, RealMatrix observed,        double tolerance) {        Assert.assertNotNull(msg + "\nObserved should not be null",observed);        if (expected.getColumnDimension() != observed.getColumnDimension() ||                expected.getRowDimension() != observed.getRowDimension()) {            StringBuffer messageBuffer = new StringBuffer(msg);            messageBuffer.append("\nObserved has incorrect dimensions.");            messageBuffer.append("\nobserved is " + observed.getRowDimension() +                    " x " + observed.getColumnDimension());            messageBuffer.append("\nexpected " + expected.getRowDimension() +                    " x " + expected.getColumnDimension());            Assert.fail(messageBuffer.toString());        }        RealMatrix delta = expected.subtract(observed);        if (delta.getNorm() >= tolerance) {            StringBuffer messageBuffer = new StringBuffer(msg);            messageBuffer.append("\nExpected: " + expected);            messageBuffer.append("\nObserved: " + observed);            messageBuffer.append("\nexpected - observed: " + delta);            Assert.fail(messageBuffer.toString());        }    }    /** verifies that two matrices are equal */    public static void assertEquals(FieldMatrix<? extends FieldElement<?>> expected,                                    FieldMatrix<? extends FieldElement<?>> observed) {        Assert.assertNotNull("Observed should not be null",observed);        if (expected.getColumnDimension() != observed.getColumnDimension() ||                expected.getRowDimension() != observed.getRowDimension()) {            StringBuffer messageBuffer = new StringBuffer();            messageBuffer.append("Observed has incorrect dimensions.");            messageBuffer.append("\nobserved is " + observed.getRowDimension() +                    " x " + observed.getColumnDimension());            messageBuffer.append("\nexpected " + expected.getRowDimension() +                    " x " + expected.getColumnDimension());            Assert.fail(messageBuffer.toString());        }        for (int i = 0; i < expected.getRowDimension(); ++i) {            for (int j = 0; j < expected.getColumnDimension(); ++j) {                FieldElement<?> eij = expected.getEntry(i, j);                FieldElement<?> oij = observed.getEntry(i, j);                Assert.assertEquals(eij, oij);            }        }    }    /** verifies that two arrays are close (sup norm) */    public static void assertEquals(String msg, double[] expected, double[] observed,        double tolerance) {        StringBuffer out = new StringBuffer(msg);        if (expected.length != observed.length) {            out.append("\n Arrays not same length. \n");            out.append("expected has length ");            out.append(expected.length);            out.append(" observed length = ");            out.append(observed.length);            Assert.fail(out.toString());        }        boolean failure = false;        for (int i=0; i < expected.length; i++) {            try {                assertEquals(expected[i], observed[i], tolerance);            } catch (AssertionFailedError ex) {                failure = true;                out.append("\n Elements at index ");                out.append(i);                out.append(" differ. ");                out.append(" expected = ");                out.append(expected[i]);                out.append(" observed = ");                out.append(observed[i]);            }        }        if (failure) {            Assert.fail(out.toString());        }    }    /** verifies that two arrays are equal */    public static <T extends FieldElement<T>> void assertEquals(T[] m, T[] n) {        if (m.length != n.length) {            Assert.fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            Assert.assertEquals(m[i],n[i]);        }    }    /**     * Computes the sum of squared deviations of <values> from <target>     * @param values array of deviates     * @param target value to compute deviations from     *     * @return sum of squared deviations     */    public static double sumSquareDev(double[] values, double target) {        double sumsq = 0d;        for (int i = 0; i < values.length; i++) {            final double dev = values[i] - target;            sumsq += (dev * dev);        }        return sumsq;    }        /**     * Asserts the null hypothesis for a ChiSquare test.  Fails and dumps arguments and test     * statistics if the null hypothesis can be rejected with confidence 100 * (1 - alpha)%     *      * @param valueLabels     * @param expected expected counts     * @param observed observed counts     * @param alpha significance level of the test     */    public static void assertChiSquareAccept(String[] valueLabels, double[] expected, long[] observed, double alpha) throws Exception {        ChiSquareTest chiSquareTest = new ChiSquareTestImpl();        try {            // Fail if we can reject null hypothesis that distributions are the same            Assert.assertFalse(chiSquareTest.chiSquareTest(expected, observed, alpha));        } catch (AssertionFailedError ex) {            StringBuffer msgBuffer = new StringBuffer();            DecimalFormat df = new DecimalFormat("#.##");            msgBuffer.append("Chisquare test failed");            msgBuffer.append(" p-value = ");            msgBuffer.append(chiSquareTest.chiSquareTest(expected, observed));            msgBuffer.append(" chisquare statistic = ");            msgBuffer.append(chiSquareTest.chiSquare(expected, observed));            msgBuffer.append(". \n");            msgBuffer.append("value\texpected\tobserved\n");            for (int i = 0; i < expected.length; i++) {                msgBuffer.append(valueLabels[i]);                msgBuffer.append("\t");                msgBuffer.append(df.format(expected[i]));                msgBuffer.append("\t\t");                msgBuffer.append(observed[i]);                msgBuffer.append("\n");            }            msgBuffer.append("This test can fail randomly due to sampling error with probability ");            msgBuffer.append(alpha);            msgBuffer.append(".");            Assert.fail(msgBuffer.toString());        }       }        /**     * Asserts the null hypothesis for a ChiSquare test.  Fails and dumps arguments and test     * statistics if the null hypothesis can be rejected with confidence 100 * (1 - alpha)%     *      * @param values     * @param expected expected counts     * @param observed observed counts     * @param alpha significance level of the test     */    public static void assertChiSquareAccept(int[] values, double[] expected, long[] observed, double alpha) throws Exception {        String[] labels = new String[values.length];        for (int i = 0; i < values.length; i++) {            labels[i] = Integer.toString(values[i]);        }        assertChiSquareAccept(labels, expected, observed, alpha);    }        /**     * Asserts the null hypothesis for a ChiSquare test.  Fails and dumps arguments and test     * statistics if the null hypothesis can be rejected with confidence 100 * (1 - alpha)%     *      * @param values     * @param expected expected counts     * @param observed observed counts     * @param alpha significance level of the test     */    public static void assertChiSquareAccept(double[] values, double[] expected, long[] observed, double alpha) throws Exception {        String[] labels = new String[values.length];        for (int i = 0; i < values.length; i++) {            labels[i] = Double.toString(values[i]);        }        assertChiSquareAccept(labels, expected, observed, alpha);    }        /**     * Asserts the null hypothesis for a ChiSquare test.  Fails and dumps arguments and test     * statistics if the null hypothesis can be rejected with confidence 100 * (1 - alpha)%     *      * @param expected expected counts     * @param observed observed counts     * @param alpha significance level of the test     */    public static void assertChiSquareAccept(double[] expected, long[] observed, double alpha) throws Exception {        String[] labels = new String[expected.length];        for (int i = 0; i < labels.length; i++) {            labels[i] = Integer.toString(i + 1);        }        assertChiSquareAccept(labels, expected, observed, alpha);    }        /**     * Computes the 25th, 50th and 75th percentiles of the given distribution and returns     * these values in an array.     */    public static double[] getDistributionQuartiles(ContinuousDistribution distribution) throws Exception {        double[] quantiles = new double[3];        quantiles[0] = distribution.inverseCumulativeProbability(0.25d);        quantiles[1] = distribution.inverseCumulativeProbability(0.5d);        quantiles[2] = distribution.inverseCumulativeProbability(0.75d);        return quantiles;    }        /**     * Updates observed counts of values in quartiles.     * counts[0] <-> 1st quartile ... counts[3] <-> top quartile     */    public static void updateCounts(double value, long[] counts, double[] quartiles) {        if (value < quartiles[0]) {            counts[0]++;        } else if (value > quartiles[2]) {            counts[3]++;        } else if (value > quartiles[1]) {            counts[2]++;        } else {            counts[1]++;        }      }        /**     * Eliminates points with zero mass from densityPoints and densityValues parallel     * arrays.  Returns the number of positive mass points and collapses the arrays so     * that the first <returned value> elements of the input arrays represent the positive     * mass points.     */    public static int eliminateZeroMassPoints(int[] densityPoints, double[] densityValues) {        int positiveMassCount = 0;        for (int i = 0; i < densityValues.length; i++) {            if (densityValues[i] > 0) {                positiveMassCount++;            }        }        if (positiveMassCount < densityValues.length) {            int[] newPoints = new int[positiveMassCount];            double[] newValues = new double[positiveMassCount];            int j = 0;            for (int i = 0; i < densityValues.length; i++) {                if (densityValues[i] > 0) {                    newPoints[j] = densityPoints[i];                    newValues[j] = densityValues[i];                    j++;                }            }            System.arraycopy(newPoints,0,densityPoints,0,positiveMassCount);            System.arraycopy(newValues,0,densityValues,0,positiveMassCount);        }        return positiveMassCount;    } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import junit.framework.TestCase;import java.util.Locale;import org.apache.commons.math.exception.util.LocalizedFormats;/** * @version $Revision$ $Date$ */public class ConvergenceExceptionTest extends TestCase {    public void testConstructor(){        ConvergenceException ex = new ConvergenceException();        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertNotNull(ex.getMessage(Locale.FRENCH));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    public void testConstructorPatternArguments(){        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };        ConvergenceException ex = new ConvergenceException(pattern, arguments);        assertNull(ex.getCause());        assertEquals(pattern, ex.getLocalizablePattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }    public void testConstructorCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        ConvergenceException ex = new ConvergenceException(cause);        assertEquals(cause, ex.getCause());    }    public void testConstructorPatternArgumentsCause(){        LocalizedFormats pattern = LocalizedFormats.ROTATION_MATRIX_DIMENSIONS;        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        ConvergenceException ex = new ConvergenceException(cause, pattern, arguments);        assertEquals(cause, ex.getCause());        assertEquals(pattern, ex.getLocalizablePattern());        assertEquals(arguments.length, ex.getArguments().length);        for (int i = 0; i < arguments.length; ++i) {            assertEquals(arguments[i], ex.getArguments()[i]);        }        assertFalse(pattern.equals(ex.getMessage()));        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.util.Locale;import junit.framework.TestCase;/** * @version $Revision$ $Date$ */public class DuplicateSampleAbscissaExceptionTest extends TestCase {    public void testConstructor(){        DuplicateSampleAbscissaException ex = new DuplicateSampleAbscissaException(1.2, 10, 11);        assertNull(ex.getCause());        assertNotNull(ex.getMessage());        assertTrue(ex.getMessage().indexOf("1.2") > 0);        assertEquals(1.2, ex.getDuplicateAbscissa(), 0);        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));    }}