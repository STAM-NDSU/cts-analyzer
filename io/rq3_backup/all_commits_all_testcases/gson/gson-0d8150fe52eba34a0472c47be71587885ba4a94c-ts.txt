/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.common.MoreAsserts;import com.google.gson.common.TestTypes.CrazyLongTypeAdapter;import com.google.gson.common.TestTypes.MyEnum;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.ArrayList;import java.util.Collection;/** * Functional tests for Json serialization and deserialization of arrays. * * @author Inderjeet Singh * @author Joel Leitch */public class ArrayTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testTopLevelArrayOfIntsSerialization() {    int[] target = {1, 2, 3, 4, 5, 6, 7, 8, 9};    assertEquals("[1,2,3,4,5,6,7,8,9]", gson.toJson(target));  }  public void testTopLevelArrayOfIntsDeserialization() {    int[] expected = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };    int[] actual = gson.fromJson("[1,2,3,4,5,6,7,8,9]", int[].class);    MoreAsserts.assertEquals(expected, actual);  }  public void testEmptyArraySerialization() {    int[] target = {};    assertEquals("[]", gson.toJson(target));  }  public void testEmptyArrayDeserialization() {    int[] actualObject = gson.fromJson("[]", int[].class);    assertTrue(actualObject.length == 0);    Integer[] actualObject2 = gson.fromJson("[]", Integer[].class);    assertTrue(actualObject2.length == 0);  }  public void testNullsInArraySerialization() {    String[] array = {"foo", null, "bar"};    String expected = "[\"foo\",null,\"bar\"]";    String json = gson.toJson(array);    assertEquals(expected, json);  }  public void testNullsInArrayDeserialization() {    String json = "[\"foo\",null,\"bar\"]";    String[] expected = {"foo", null, "bar"};    String[] target = gson.fromJson(json, expected.getClass());    for (int i = 0; i < expected.length; ++i) {      assertEquals(expected[i], target[i]);    }  }  public void testArrayOfStringsSerialization() {    String[] target = {"Hello", "World"};    assertEquals("[\"Hello\",\"World\"]", gson.toJson(target));  }  public void testArrayOfStringsDeserialization() {    String json = "[\"Hello\",\"World\"]";    String[] target = gson.fromJson(json, String[].class);    assertEquals("Hello", target[0]);    assertEquals("World", target[1]);  }  public void testTopLevelEnumInASingleElementArrayDeserialization() {    String json = "[" + MyEnum.VALUE1.getExpectedJson() + "]";    MyEnum target = gson.fromJson(json, MyEnum.class);    assertEquals(json, "[" + target.getExpectedJson() + "]");  }  @SuppressWarnings("unchecked")  public void testArrayOfCollectionSerialization() throws Exception {    StringBuilder sb = new StringBuilder("[");    int arraySize = 3;    Type typeToSerialize = new TypeToken<Collection<Integer>[]>() {}.getType();    Collection<Integer>[] arrayOfCollection = new ArrayList[arraySize];    for (int i = 0; i < arraySize; ++i) {      int startValue = (3 * i) + 1;      sb.append('[').append(startValue).append(',').append(startValue + 1).append(']');      ArrayList<Integer> tmpList = new ArrayList<Integer>();      tmpList.add(startValue);      tmpList.add(startValue + 1);      arrayOfCollection[i] = tmpList;      if (i < arraySize - 1) {        sb.append(',');      }    }    sb.append(']');    String json = gson.toJson(arrayOfCollection, typeToSerialize);    assertEquals(sb.toString(), json);  }  public void testArrayOfCollectionDeserialization() throws Exception {    String json = "[[1,2],[3,4]]";    Type type = new TypeToken<Collection<Integer>[]>() {}.getType();    Collection<Integer>[] target = gson.fromJson(json, type);    assertEquals(2, target.length);    MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0]));    MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0]));  }    public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception {    CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter();    gson = new GsonBuilder()        .registerTypeAdapter(long.class, typeAdapter)        .registerTypeAdapter(Long.class, typeAdapter)        .create();    long[] value = { 1L };    String serializedValue = gson.toJson(value);    String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]";    assertEquals(expected, serializedValue);        long[] deserializedValue = gson.fromJson(serializedValue, long[].class);    assertEquals(1, deserializedValue.length);    assertEquals(value[0], deserializedValue[0]);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.JsonElement;import com.google.gson.JsonNull;import com.google.gson.JsonObject;import com.google.gson.JsonSerializationContext;import com.google.gson.JsonSerializer;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.common.TestTypes.ClassWithObjects;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.Collection;/** * Functional tests for the different cases for serializing (or ignoring) null fields and object. * * @author Inderjeet Singh * @author Joel Leitch */public class NullObjectAndFieldTest extends TestCase {  private GsonBuilder gsonBuilder;  @Override  protected void setUp() throws Exception {    super.setUp();    gsonBuilder = new GsonBuilder().serializeNulls();  }  public void testTopLevelNullObjectSerialization() {    Gson gson = gsonBuilder.create();    String actual = gson.toJson(null);    assertEquals("null", actual);    actual = gson.toJson(null, String.class);    assertEquals("null", actual);  }  public void testTopLevelNullObjectDeserialization() throws Exception {    Gson gson = gsonBuilder.create();    String actual = gson.fromJson("null", String.class);    assertNull(actual);  }  public void testExplicitSerializationOfNulls() {    Gson gson = gsonBuilder.create();    ClassWithObjects target = new ClassWithObjects(null);    String actual = gson.toJson(target);    String expected = "{\"bag\":null}";    assertEquals(expected, actual);  }  public void testExplicitDeserializationOfNulls() throws Exception {    Gson gson = gsonBuilder.create();    ClassWithObjects target = gson.fromJson("{\"bag\":null}", ClassWithObjects.class);    assertNull(target.bag);  }    public void testExplicitSerializationOfNullArrayMembers() {    Gson gson = gsonBuilder.create();    ClassWithMembers target = new ClassWithMembers();    String json = gson.toJson(target);    assertTrue(json.contains("\"array\":null"));  }    /**    * Added to verify http://code.google.com/p/google-gson/issues/detail?id=68   */  public void testNullWrappedPrimitiveMemberSerialization() {    Gson gson = gsonBuilder.serializeNulls().create();    ClassWithNullWrappedPrimitive target = new ClassWithNullWrappedPrimitive();    String json = gson.toJson(target);    assertTrue(json.contains("\"value\":null"));  }    /**    * Added to verify http://code.google.com/p/google-gson/issues/detail?id=68   */  public void testNullWrappedPrimitiveMemberDeserialization() {    Gson gson = gsonBuilder.create();    String json = "{'value':null}";    ClassWithNullWrappedPrimitive target = gson.fromJson(json, ClassWithNullWrappedPrimitive.class);    assertNull(target.value);  }    private static class ClassWithNullWrappedPrimitive {    private Long value;  }    public void testExplicitSerializationOfNullCollectionMembers() {    Gson gson = gsonBuilder.create();    ClassWithMembers target = new ClassWithMembers();    String json = gson.toJson(target);    assertTrue(json.contains("\"col\":null"));  }    public void testExplicitSerializationOfNullStringMembers() {    Gson gson = gsonBuilder.create();    ClassWithMembers target = new ClassWithMembers();    String json = gson.toJson(target);    assertTrue(json.contains("\"str\":null"));  }    static class ClassWithMembers {    String str;    int[] array;    Collection<String> col;  }  public void testCustomSerializationOfNulls() {    gsonBuilder.registerTypeAdapter(ClassWithObjects.class, new ClassWithObjectsSerializer());    Gson gson = gsonBuilder.create();    ClassWithObjects target = new ClassWithObjects(new BagOfPrimitives());    String actual = gson.toJson(target);    String expected = "{\"bag\":null}";    assertEquals(expected, actual);  }  private static class ClassWithObjectsSerializer implements JsonSerializer<ClassWithObjects> {    public JsonElement serialize(ClassWithObjects src, Type typeOfSrc,        JsonSerializationContext context) {      JsonObject obj = new JsonObject();      obj.add("bag", new JsonNull());      return obj;    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import java.math.BigDecimal;import java.math.BigInteger;import java.net.URI;import java.net.URL;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashSet;import java.util.Locale;import java.util.Set;import junit.framework.TestCase;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.JsonParseException;/** * Functional test for Json serialization and deserialization for common classes for which default * support is provided in Gson. The tests for Map types are available in {@link MapTest}. * * @author Inderjeet Singh * @author Joel Leitch */public class DefaultTypeAdaptersTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testUrlSerialization() throws Exception {    String urlValue = "http://google.com/";    URL url = new URL(urlValue);    assertEquals('"' + urlValue + '"', gson.toJson(url));  }  public void testUrlDeserialization() {    String urlValue = "http://google.com/";    String json = '"' + urlValue + '"';    URL target = gson.fromJson(json, URL.class);    assertEquals(urlValue, target.toExternalForm());  }  public void testUrlNullSerialization() throws Exception {    ClassWithUrlField target = new ClassWithUrlField();    assertEquals("{}", gson.toJson(target));  }  public void testUrlNullDeserialization() {    String json = "{}";    ClassWithUrlField target = gson.fromJson(json, ClassWithUrlField.class);    assertNull(target.url);  }    private static class ClassWithUrlField {    URL url;  }  public void testUriSerialization() throws Exception {    String uriValue = "http://google.com/";    URI uri = new URI(uriValue);    assertEquals('"' + uriValue + '"', gson.toJson(uri));  }  public void testUriDeserialization() {    String uriValue = "http://google.com/";    String json = '"' + uriValue + '"';    URI target = gson.fromJson(json, URI.class);    assertEquals(uriValue, target.toASCIIString());  }  public void testLocaleSerializationWithLanguage() {    Locale target = new Locale("en");    assertEquals("\"en\"", gson.toJson(target));  }  public void testLocaleDeserializationWithLanguage() {    String json = "\"en\"";    Locale locale = gson.fromJson(json, Locale.class);    assertEquals("en", locale.getLanguage());  }  public void testLocaleSerializationWithLanguageCountry() {    Locale target = Locale.CANADA_FRENCH;    assertEquals("\"fr_CA\"", gson.toJson(target));  }  public void testLocaleDeserializationWithLanguageCountry() {    String json = "\"fr_CA\"";    Locale locale = gson.fromJson(json, Locale.class);    assertEquals(Locale.CANADA_FRENCH, locale);  }  public void testLocaleSerializationWithLanguageCountryVariant() {    Locale target = new Locale("de", "DE", "EURO");    String json = gson.toJson(target);    assertEquals("\"de_DE_EURO\"", json);  }  public void testLocaleDeserializationWithLanguageCountryVariant() {    String json = "\"de_DE_EURO\"";    Locale locale = gson.fromJson(json, Locale.class);    assertEquals("de", locale.getLanguage());    assertEquals("DE", locale.getCountry());    assertEquals("EURO", locale.getVariant());  }  public void testBigDecimalFieldSerialization() {    ClassWithBigDecimal target = new ClassWithBigDecimal("-122.01e-21");    String json = gson.toJson(target);    String actual = json.substring(json.indexOf(':') + 1, json.indexOf('}'));    assertEquals(target.value, new BigDecimal(actual));  }  public void testBigDecimalFieldDeserialization() {    ClassWithBigDecimal expected = new ClassWithBigDecimal("-122.01e-21");    String json = expected.getExpectedJson();    ClassWithBigDecimal actual = gson.fromJson(json, ClassWithBigDecimal.class);    assertEquals(expected.value, actual.value);  }  public void testBadValueForBigDecimalDeserialization() {    try {      gson.fromJson("{\"value\"=1.5e-1.0031}", ClassWithBigDecimal.class);      fail("Exponent of a BigDecimal must be an integer value.");    } catch (JsonParseException expected) { }  }  public void testBigIntegerFieldSerialization() {    ClassWithBigInteger target = new ClassWithBigInteger("23232323215323234234324324324324324324");    String json = gson.toJson(target);    assertEquals(target.getExpectedJson(), json);  }  public void testBigIntegerFieldDeserialization() {    ClassWithBigInteger expected = new ClassWithBigInteger("879697697697697697697697697697697697");    String json = expected.getExpectedJson();    ClassWithBigInteger actual = gson.fromJson(json, ClassWithBigInteger.class);    assertEquals(expected.value, actual.value);  }  public void testSetSerialization() throws Exception {    Gson gson = new Gson();    HashSet<String> s = new HashSet<String>();    s.add("blah");    String json = gson.toJson(s);    assertEquals("[\"blah\"]", json);    json = gson.toJson(s, Set.class);    assertEquals("[\"blah\"]", json);  }  public void testDefaultDateSerialization() {    Date now = new Date();    String json = gson.toJson(now);    assertEquals("\"" + DateFormat.getDateTimeInstance().format(now) + "\"", json);  }  public void testDefaultDateDeserialization() {    Date date = new Date();    String json = gson.toJson(date);    Date extracted = gson.fromJson(json, Date.class);    // Using comparison of string forms since the extracted date has lost the millisecond portion.    assertEquals(date.toString(), extracted.toString());      }    public void testDefaultDateSerializationUsingBuilder() throws Exception {    Gson gson = new GsonBuilder().create();    Date now = new Date();    String json = gson.toJson(now);    assertEquals("\"" + DateFormat.getDateTimeInstance().format(now) + "\"", json);  }  public void testDefaultDateDeserializationUsingBuilder() throws Exception {    Gson gson = new GsonBuilder().create();    Date now = new Date();    String json = gson.toJson(now);    Date extracted = gson.fromJson(json, Date.class);    assertEquals(now.toString(), extracted.toString());      }  public void testDateSerializationWithPattern() throws Exception {    String pattern = "yyyy-MM-dd";    DateFormat formatter = new SimpleDateFormat(pattern);    Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create();    Date now = new Date();    String json = gson.toJson(now);    assertEquals("\"" + formatter.format(now) + "\"", json);  }    @SuppressWarnings("deprecation")  public void testDateDeserializationWithPattern() throws Exception {    String pattern = "yyyy-MM-dd";    Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create();    Date now = new Date();    String json = gson.toJson(now);    Date extracted = gson.fromJson(json, Date.class);    assertEquals(now.getYear(), extracted.getYear());        assertEquals(now.getMonth(), extracted.getMonth());        assertEquals(now.getDay(), extracted.getDay());      }    private static class ClassWithBigDecimal {    BigDecimal value;    ClassWithBigDecimal() { }    ClassWithBigDecimal(String value) {      this.value = new BigDecimal(value);    }    String getExpectedJson() {      return "{\"value\":" + value.toEngineeringString() + "}";    }  }  private static class ClassWithBigInteger {    BigInteger value;    ClassWithBigInteger() { }    ClassWithBigInteger(String value) {      this.value = new BigInteger(value);    }    String getExpectedJson() {      return "{\"value\":" + value + "}";    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.JsonParseException;import com.google.gson.common.MoreAsserts;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.common.TestTypes.MyEnum;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.Iterator;import java.util.LinkedList;import java.util.List;import java.util.Queue;/** * Functional tests for Json serialization and deserialization of collections. * * @author Inderjeet Singh * @author Joel Leitch */public class CollectionTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testTopLevelCollectionOfIntegersSerialization() {    Collection<Integer> target = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);    Type targetType = new TypeToken<Collection<Integer>>() {}.getType();    String json = gson.toJson(target, targetType);    assertEquals("[1,2,3,4,5,6,7,8,9]", json);  }  public void testTopLevelCollectionOfIntegersDeserialization() {    String json = "[0,1,2,3,4,5,6,7,8,9]";    Type collectionType = new TypeToken<Collection<Integer>>() { }.getType();    Collection<Integer> target = gson.fromJson(json, collectionType);    int[] expected = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};    MoreAsserts.assertEquals(expected, toIntArray(target));  }  public void testTopLevelListOfIntegerCollectionsDeserialization() throws Exception {    String json = "[[1,2,3],[4,5,6],[7,8,9]]";    Type collectionType = new TypeToken<Collection<Collection<Integer>>>() {}.getType();    List<Collection<Integer>> target = gson.fromJson(json, collectionType);    int[][] expected = new int[3][3];    for (int i = 0; i < 3; ++i) {      int start = (3 * i) + 1;      for (int j = 0; j < 3; ++j) {        expected[i][j] = start + j;      }    }    for (int i = 0; i < 3; i++) {      MoreAsserts.assertEquals(expected[i], toIntArray(target.get(i)));    }  }    public void testLinkedListSerialization() {    List<String> list = new LinkedList<String>();    list.add("a1");    list.add("a2");    Type linkedListType = new TypeToken<LinkedList<String>>() {}.getType();    String json = gson.toJson(list, linkedListType);    assertTrue(json.contains("a1"));    assertTrue(json.contains("a2"));  }  public void testLinkedListDeserialization() {    String json = "['a1','a2']";    Type linkedListType = new TypeToken<LinkedList<String>>() {}.getType();    List<String> list = gson.fromJson(json, linkedListType);    assertEquals("a1", list.get(0));    assertEquals("a2", list.get(1));  }  public void testQueueSerialization() {    Queue<String> queue = new LinkedList<String>();    queue.add("a1");    queue.add("a2");    Type queueType = new TypeToken<Queue<String>>() {}.getType();    String json = gson.toJson(queue, queueType);    assertTrue(json.contains("a1"));    assertTrue(json.contains("a2"));  }  public void testQueueDeserialization() {    String json = "['a1','a2']";    Type queueType = new TypeToken<Queue<String>>() {}.getType();    Queue<String> queue = gson.fromJson(json, queueType);    assertEquals("a1", queue.element());     queue.remove();    assertEquals("a2", queue.element());  }  public void testNullsInListSerialization() {    List<String> list = new ArrayList<String>();    list.add("foo");    list.add(null);    list.add("bar");    String expected = "[\"foo\",null,\"bar\"]";    Type typeOfList = new TypeToken<List<String>>() {}.getType();    String json = gson.toJson(list, typeOfList);    assertEquals(expected, json);  }  public void testNullsInListDeserialization() {    List<String> expected = new ArrayList<String>();    expected.add("foo");    expected.add(null);    expected.add("bar");    String json = "[\"foo\",null,\"bar\"]";    Type expectedType = new TypeToken<List<String>>() {}.getType();    List<String> target = gson.fromJson(json, expectedType);    for (int i = 0; i < expected.size(); ++i) {      assertEquals(expected.get(i), target.get(i));    }  }  public void testCollectionOfStringsSerialization() {    List<String> target = new ArrayList<String>();    target.add("Hello");    target.add("World");    assertEquals("[\"Hello\",\"World\"]", gson.toJson(target));  }  public void testCollectionOfBagOfPrimitivesSerialization() {    List<BagOfPrimitives> target = new ArrayList<BagOfPrimitives>();    BagOfPrimitives objA = new BagOfPrimitives(3L, 1, true, "blah");    BagOfPrimitives objB = new BagOfPrimitives(2L, 6, false, "blahB");    target.add(objA);    target.add(objB);    String result = gson.toJson(target);    assertTrue(result.startsWith("["));    assertTrue(result.endsWith("]"));    for (BagOfPrimitives obj : target) {      assertTrue(result.contains(obj.getExpectedJson()));    }  }  public void testCollectionOfEnumsSerialization() {    Type type = new TypeToken<Collection<MyEnum>>() {}.getType();    Collection<MyEnum> target = new ArrayList<MyEnum>();    target.add(MyEnum.VALUE1);    target.add(MyEnum.VALUE2);    String expectedJson = "[\"VALUE1\",\"VALUE2\"]";    String actualJson = gson.toJson(target);    assertEquals(expectedJson, actualJson);    actualJson = gson.toJson(target, type);    assertEquals(expectedJson, actualJson);  }  public void testCollectionOfEnumsDeserialization() {    Type type = new TypeToken<Collection<MyEnum>>() {}.getType();    String json = "[\"VALUE1\",\"VALUE2\"]";    Collection<MyEnum> target = gson.fromJson(json, type);    MoreAsserts.assertContains(target, MyEnum.VALUE1);    MoreAsserts.assertContains(target, MyEnum.VALUE2);  }  public void testCollectionOfStringsDeserialization() {    String json = "[\"Hello\",\"World\"]";    Type collectionType = new TypeToken<Collection<String>>() { }.getType();    Collection<String> target = gson.fromJson(json, collectionType);    assertTrue(target.contains("Hello"));    assertTrue(target.contains("World"));  }  public void testRawCollectionOfIntegersSerialization() {    Collection<Integer> target = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);    assertEquals("[1,2,3,4,5,6,7,8,9]", gson.toJson(target));  }  @SuppressWarnings("unchecked")  public void testRawCollectionSerialization() {    BagOfPrimitives bag1 = new BagOfPrimitives();    Collection target = Arrays.asList(bag1, bag1);    String json = gson.toJson(target);    assertTrue(json.contains(bag1.getExpectedJson()));  }  public void testRawCollectionDeserializationNotAlllowed() {    String json = "[0,1,2,3,4,5,6,7,8,9]";    try {        gson.fromJson(json, Collection.class);        fail("Can not deserialize a non-genericized collection.");    } catch (JsonParseException expected) { }    json = "[\"Hello\", \"World\"]";    try {      gson.fromJson(json, Collection.class);      fail("Can not deserialize a non-genericized collection.");    } catch (JsonParseException expected) { }  }  @SuppressWarnings("unchecked")  public void testRawCollectionOfBagOfPrimitivesNotAllowed() {    try {      BagOfPrimitives bag = new BagOfPrimitives(10, 20, false, "stringValue");      String json = '[' + bag.getExpectedJson() + ',' + bag.getExpectedJson() + ']';      Collection target = gson.fromJson(json, Collection.class);      assertEquals(2, target.size());      for (BagOfPrimitives bag1 : (Collection<BagOfPrimitives>) target) {        assertEquals(bag.getExpectedJson(), bag1.getExpectedJson());      }      fail("Raw collection of objects should not work");    } catch (JsonParseException expected) {    }  }  @SuppressWarnings("unchecked")  private static int[] toIntArray(Collection collection) {    int[] ints = new int[collection.size()];    int i = 0;    for (Iterator iterator = collection.iterator(); iterator.hasNext(); ++i) {      Object obj = iterator.next();      if (obj instanceof Integer) {        ints[i] = ((Integer)obj).intValue();      } else if (obj instanceof Long) {        ints[i] = ((Long)obj).intValue();      }    }    return ints;  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.InstanceCreator;import com.google.gson.JsonParseException;import com.google.gson.common.TestTypes.ArrayOfObjects;import com.google.gson.common.TestTypes.BagOfPrimitiveWrappers;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.common.TestTypes.ClassOverridingEquals;import com.google.gson.common.TestTypes.ClassWithArray;import com.google.gson.common.TestTypes.ClassWithNoFields;import com.google.gson.common.TestTypes.ClassWithObjects;import com.google.gson.common.TestTypes.ClassWithTransientFields;import com.google.gson.common.TestTypes.MyEnum;import com.google.gson.common.TestTypes.Nested;import com.google.gson.common.TestTypes.PrimitiveArray;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.ArrayList;import java.util.Collection;import java.util.LinkedList;import java.util.List;import java.util.Queue;import java.util.Set;import java.util.SortedSet;import java.util.TreeSet;/** * Functional tests for Json serialization and deserialization of regular classes. * * @author Inderjeet Singh * @author Joel Leitch */public class ObjectTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testJsonInSingleQuotesDeserialization() {    String json = "{'stringValue':'no message','intValue':10,'longValue':20}";    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);    assertEquals("no message", target.stringValue);    assertEquals(10, target.intValue);    assertEquals(20, target.longValue);  }    public void testJsonInMixedQuotesDeserialization() {    String json = "{\"stringValue\":'no message','intValue':10,'longValue':20}";    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);    assertEquals("no message", target.stringValue);    assertEquals(10, target.intValue);    assertEquals(20, target.longValue);  }    public void testBagOfPrimitivesSerialization() throws Exception {    BagOfPrimitives target = new BagOfPrimitives(10, 20, false, "stringValue");    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testBagOfPrimitivesDeserialization() throws Exception {    BagOfPrimitives src = new BagOfPrimitives(10, 20, false, "stringValue");    String json = src.getExpectedJson();    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);    assertEquals(json, target.getExpectedJson());  }  public void testBagOfPrimitiveWrappersSerialization() throws Exception {    BagOfPrimitiveWrappers target = new BagOfPrimitiveWrappers(10L, 20, false);    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testBagOfPrimitiveWrappersDeserialization() throws Exception {    BagOfPrimitiveWrappers target = new BagOfPrimitiveWrappers(10L, 20, false);    String jsonString = target.getExpectedJson();    target = gson.fromJson(jsonString, BagOfPrimitiveWrappers.class);    assertEquals(jsonString, target.getExpectedJson());  }  public void testDirectedAcyclicGraphSerialization() throws Exception {    ContainsReferenceToSelfType a = new ContainsReferenceToSelfType();    ContainsReferenceToSelfType b = new ContainsReferenceToSelfType();    ContainsReferenceToSelfType c = new ContainsReferenceToSelfType();    a.children.add(b);    a.children.add(c);    b.children.add(c);    assertNotNull(gson.toJson(a));  }  public void testDirectedAcyclicGraphDeserialization() throws Exception {    String json = "{\"children\":[{\"children\":[{\"children\":[]}]},{\"children\":[]}]}";    ContainsReferenceToSelfType target = gson.fromJson(json, ContainsReferenceToSelfType.class);    assertNotNull(target);    assertEquals(2, target.children.size());  }  public void testClassWithTransientFieldsSerialization() throws Exception {    ClassWithTransientFields target = new ClassWithTransientFields(1L);    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testClassWithTransientFieldsDeserialization() throws Exception {    String json = "{\"longValue\":[1]}";    ClassWithTransientFields target = gson.fromJson(json, ClassWithTransientFields.class);    assertEquals(json, target.getExpectedJson());  }  public void testClassWithTransientFieldsDeserializationTransientFieldsPassedInJsonAreIgnored()      throws Exception {    String json = "{\"transientLongValue\":1,\"longValue\":[1]}";    ClassWithTransientFields target = gson.fromJson(json, ClassWithTransientFields.class);    assertFalse(target.transientLongValue != 1);  }  public void testClassWithNoFieldsSerialization() throws Exception {    assertEquals("{}", gson.toJson(new ClassWithNoFields()));  }  public void testClassWithNoFieldsDeserialization() throws Exception {    String json = "{}";    ClassWithNoFields target = gson.fromJson(json, ClassWithNoFields.class);    ClassWithNoFields expected = new ClassWithNoFields();    assertEquals(expected, target);  }  public void testNestedSerialization() throws Exception {    Nested target = new Nested(new BagOfPrimitives(10, 20, false, "stringValue"),       new BagOfPrimitives(30, 40, true, "stringValue"));    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testNestedDeserialization() throws Exception {    String json = "{\"primitive1\":{\"longValue\":10,\"intValue\":20,\"booleanValue\":false,"        + "\"stringValue\":\"stringValue\"},\"primitive2\":{\"longValue\":30,\"intValue\":40,"        + "\"booleanValue\":true,\"stringValue\":\"stringValue\"}}";    Nested target = gson.fromJson(json, Nested.class);    assertEquals(json, target.getExpectedJson());  }  public void testInheritenceSerialization() throws Exception {    SubTypeOfNested target = new SubTypeOfNested(new BagOfPrimitives(10, 20, false, "stringValue"),        new BagOfPrimitives(30, 40, true, "stringValue"));    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testInheritenceDeserialization() throws Exception {    String json = "{\"value\":5,\"primitive1\":{\"longValue\":10,\"intValue\":20,"        + "\"booleanValue\":false,\"stringValue\":\"stringValue\"},\"primitive2\":"        + "{\"longValue\":30,\"intValue\":40,\"booleanValue\":true,"        + "\"stringValue\":\"stringValue\"}}";    SubTypeOfNested target = gson.fromJson(json, SubTypeOfNested.class);    assertEquals(json, target.getExpectedJson());  }  public void testNullSerialization() throws Exception {    assertEquals("", gson.toJson(null));  }  public void testNullDeserialization() throws Exception {    try {      gson.fromJson("", Object.class);      fail("Null strings should not be allowed");    } catch (JsonParseException expected) {    }  }  public void testNullFieldsSerialization() throws Exception {    Nested target = new Nested(new BagOfPrimitives(10, 20, false, "stringValue"), null);    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testNullFieldsDeserialization() throws Exception {    String json = "{\"primitive1\":{\"longValue\":10,\"intValue\":20,\"booleanValue\":false"        + ",\"stringValue\":\"stringValue\"}}";    Nested target = gson.fromJson(json, Nested.class);    assertEquals(json, target.getExpectedJson());  }  public void testArrayOfObjectsSerialization() throws Exception {    ArrayOfObjects target = new ArrayOfObjects();    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testArrayOfObjectsDeserialization() throws Exception {    String json = new ArrayOfObjects().getExpectedJson();    ArrayOfObjects target = gson.fromJson(json, ArrayOfObjects.class);    assertEquals(json, target.getExpectedJson());  }  public void testArrayOfArraysSerialization() throws Exception {    ArrayOfArrays target = new ArrayOfArrays();    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testArrayOfArraysDeserialization() throws Exception {    String json = new ArrayOfArrays().getExpectedJson();    ArrayOfArrays target = gson.fromJson(json, ArrayOfArrays.class);    assertEquals(json, target.getExpectedJson());  }  public void testClassWithEnumFieldSerialization() throws Exception {    ClassWithEnumFields target = new ClassWithEnumFields();    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testClassWithEnumFieldDeserialization() throws Exception {    String json = new ClassWithEnumFields().getExpectedJson();    ClassWithEnumFields target = gson.fromJson(json, ClassWithEnumFields.class);    assertEquals(json, target.getExpectedJson());  }  public void testTopLevelEnumSerialization() throws Exception {    MyEnum target = MyEnum.VALUE1;    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testTopLevelEnumDeserialization() throws Exception {    String json = MyEnum.VALUE1.getExpectedJson();    MyEnum target = gson.fromJson(json, MyEnum.class);    assertEquals(json, target.getExpectedJson());  }  public void testSubInterfacesOfCollectionSerialization() throws Exception {    List<Integer> list = new LinkedList<Integer>();    list.add(0);    list.add(1);    list.add(2);    list.add(3);    Queue<Long> queue = new LinkedList<Long>();    queue.add(0L);    queue.add(1L);    queue.add(2L);    queue.add(3L);    Set<Float> set = new TreeSet<Float>();    set.add(0.1F);    set.add(0.2F);    set.add(0.3F);    set.add(0.4F);    SortedSet<Character> sortedSet = new TreeSet<Character>();    sortedSet.add('a');    sortedSet.add('b');    sortedSet.add('c');    sortedSet.add('d');    ClassWithSubInterfacesOfCollection target =        new ClassWithSubInterfacesOfCollection(list, queue, set, sortedSet);    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testSubInterfacesOfCollectionDeserialization() throws Exception {    String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4],"        + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]"        + "}";    ClassWithSubInterfacesOfCollection target = gson.fromJson(        json, ClassWithSubInterfacesOfCollection.class);    assertEquals(json, target.getExpectedJson());  }  /**   * Created in response to Issue 14: http://code.google.com/p/google-gson/issues/detail?id=14   */  public void testNullArraysDeserialization() throws Exception {    String json = "{\"array\": null}";    ClassWithArray target = gson.fromJson(json, ClassWithArray.class);    assertNull(target.array);  }  /**   * Created in response to Issue 14: http://code.google.com/p/google-gson/issues/detail?id=14   */  public void testNullObjectFieldsDeserialization() throws Exception {    String json = "{\"bag\": null}";    ClassWithObjects target = gson.fromJson(json, ClassWithObjects.class);    assertNull(target.bag);  }  public void testEmptyCollectionInAnObjectDeserialization() throws Exception {    String json = "{\"children\":[]}";    ContainsReferenceToSelfType target = gson.fromJson(json, ContainsReferenceToSelfType.class);    assertNotNull(target);    assertTrue(target.children.isEmpty());  }  public void testPrimitiveArrayInAnObjectDeserialization() throws Exception {    String json = "{\"longArray\":[0,1,2,3,4,5,6,7,8,9]}";    PrimitiveArray target = gson.fromJson(json, PrimitiveArray.class);    assertEquals(json, target.getExpectedJson());  }  /**   * Created in response to Issue 14: http://code.google.com/p/google-gson/issues/detail?id=14   */  public void testNullPrimitiveFieldsDeserialization() throws Exception {    String json = "{\"longValue\":null}";    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);    assertEquals(BagOfPrimitives.DEFAULT_VALUE, target.longValue);  }  public void testEmptyCollectionInAnObjectSerialization() throws Exception {    ContainsReferenceToSelfType target = new ContainsReferenceToSelfType();    assertEquals("{\"children\":[]}", gson.toJson(target));  }  public void testCircularSerialization() throws Exception {    ContainsReferenceToSelfType a = new ContainsReferenceToSelfType();    ContainsReferenceToSelfType b = new ContainsReferenceToSelfType();    a.children.add(b);    b.children.add(a);    try {      gson.toJson(a);      fail("Circular types should not get printed!");    } catch (IllegalStateException expected) { }  }  public void testSelfReferenceSerialization() throws Exception {    ClassOverridingEquals objA = new ClassOverridingEquals();    objA.ref = objA;    try {      gson.toJson(objA);      fail("Circular reference to self can not be serialized!");    } catch (IllegalStateException expected) { }  }  public void testPrivateNoArgConstructorDeserialization() throws Exception {    ClassWithPrivateNoArgsConstructor target =      gson.fromJson("{\"a\":20}", ClassWithPrivateNoArgsConstructor.class);    assertEquals(20, target.a);  }  public void testAnonymousLocalClassesSerialization() throws Exception {    assertEquals("", gson.toJson(new ClassWithNoFields() {      // empty anonymous class    }));  }  public void testPrimitiveArrayFieldSerialization() {    PrimitiveArray target = new PrimitiveArray(new long[] { 1L, 2L, 3L });    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  /**   * Tests that a class field with type Object can be serialized properly.    * See issue 54   */  public void testClassWithObjectFieldSerialization() {    ClassWithObjectField obj = new ClassWithObjectField();    obj.member = "abc";    String json = gson.toJson(obj);    assertTrue(json.contains("abc"));  }    private static class ClassWithObjectField {    Object member;  }    public void testInnerClassSerialization() {        Parent p = new Parent();    Parent.Child c = p.new Child();    String json = gson.toJson(c);    assertTrue(json.contains("value2"));    assertFalse(json.contains("value1"));  }     public void testInnerClassDeserialization() {    final Parent p = new Parent();    Gson gson = new GsonBuilder().registerTypeAdapter(        Parent.Child.class, new InstanceCreator<Parent.Child>() {      public Parent.Child createInstance(Type type) {        return p.new Child();      }          }).create();    String json = "{'value2':3}";    Parent.Child c = gson.fromJson(json, Parent.Child.class);    assertEquals(3, c.value2);  }     private static class Parent {    int value1 = 1;    private class Child {      int value2 = 2;    }  }    public static class ClassWithSubInterfacesOfCollection {    private List<Integer> list;    private Queue<Long> queue;    private Set<Float> set;    private SortedSet<Character> sortedSet;    ClassWithSubInterfacesOfCollection() {    }    public ClassWithSubInterfacesOfCollection(List<Integer> list, Queue<Long> queue, Set<Float> set,        SortedSet<Character> sortedSet) {      this.list = list;      this.queue = queue;      this.set = set;      this.sortedSet = sortedSet;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{");      sb.append("\"list\":");      append(sb, list).append(",");      sb.append("\"queue\":");      append(sb, queue).append(",");      sb.append("\"set\":");      append(sb, set).append(",");      sb.append("\"sortedSet\":");      append(sb, sortedSet);      sb.append("}");      return sb.toString();    }    private StringBuilder append(StringBuilder sb, Collection<?> c) {      sb.append("[");      boolean first = true;      for (Object o : c) {        if (!first) {          sb.append(",");        } else {          first = false;        }        if (o instanceof String || o instanceof Character) {          sb.append('\"');        }        sb.append(o.toString());        if (o instanceof String || o instanceof Character) {          sb.append('\"');        }      }      sb.append("]");      return sb;    }  }  private static class ContainsReferenceToSelfType {    public Collection<ContainsReferenceToSelfType> children =        new ArrayList<ContainsReferenceToSelfType>();  }  private static class SubTypeOfNested extends Nested {    private final long value = 5;    public SubTypeOfNested() {      this(null, null);    }    public SubTypeOfNested(BagOfPrimitives primitive1, BagOfPrimitives primitive2) {      super(primitive1, primitive2);    }    @Override    public void appendFields(StringBuilder sb) {      sb.append("\"value\":").append(value).append(",");      super.appendFields(sb);    }  }  private static class ArrayOfArrays {    private final BagOfPrimitives[][] elements;    public ArrayOfArrays() {      elements = new BagOfPrimitives[3][2];      for (int i = 0; i < elements.length; ++i) {        BagOfPrimitives[] row = elements[i];        for (int j = 0; j < row.length; ++j) {          row[j] = new BagOfPrimitives(i+j, i*j, false, i+"_"+j);        }      }    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder("{\"elements\":[");      boolean first = true;      for (BagOfPrimitives[] row : elements) {        if (first) {          first = false;        } else {          sb.append(",");        }        boolean firstOfRow = true;        sb.append("[");        for (BagOfPrimitives element : row) {          if (firstOfRow) {            firstOfRow = false;          } else {            sb.append(",");          }          sb.append(element.getExpectedJson());        }        sb.append("]");      }      sb.append("]}");      return sb.toString();    }  }  private static class ClassWithEnumFields {    private final MyEnum value1 = MyEnum.VALUE1;    private final MyEnum value2 = MyEnum.VALUE2;    public String getExpectedJson() {      return "{\"value1\":\"" + value1 + "\",\"value2\":\"" + value2 + "\"}";    }  }  private static class ClassWithPrivateNoArgsConstructor {    public int a;    private ClassWithPrivateNoArgsConstructor() {      a = 10;    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import java.lang.reflect.Type;import java.util.LinkedHashMap;import java.util.Map;import junit.framework.TestCase;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.InstanceCreator;import com.google.gson.reflect.TypeToken;/** * Functional test for Json serialization and deserialization for Maps * * @author Inderjeet Singh * @author Joel Leitch */public class MapTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testMapSerialization() {    Map<String, Integer> map = new LinkedHashMap<String, Integer>();    map.put("a", 1);    map.put("b", 2);    Type typeOfMap = new TypeToken<Map<String, Integer>>() {}.getType();    String json = gson.toJson(map, typeOfMap);    assertTrue(json.contains("\"a\":1"));    assertTrue(json.contains("\"b\":2"));  }  public void testMapDeserialization() {    String json = "{\"a\":1,\"b\":2}";    Type typeOfMap = new TypeToken<Map<String,Integer>>(){}.getType();    Map<String, Integer> target = gson.fromJson(json, typeOfMap);    assertEquals(1, target.get("a").intValue());    assertEquals(2, target.get("b").intValue());  }  @SuppressWarnings("unchecked")  public void testRawMapSerialization() {    Map map = new LinkedHashMap();    map.put("a", 1);    map.put("b", "string");    String json = gson.toJson(map);    assertTrue(json.contains("\"a\":1"));    assertTrue(json.contains("\"b\":\"string\""));      }    public void testMapSerializationEmpty() {    Map<String, Integer> map = new LinkedHashMap<String, Integer>();    Type typeOfMap = new TypeToken<Map<String, Integer>>() {}.getType();    String json = gson.toJson(map, typeOfMap);    assertEquals("{}", json);  }  public void testParameterizedMapSubclassSerialization() {    MyParameterizedMap<String, String> map = new MyParameterizedMap<String, String>();    map.put("a", "b");    Type type = new TypeToken<MyParameterizedMap<String, String>>() {}.getType();    String json = gson.toJson(map, type);    assertTrue(json.contains("\"a\":\"b\""));  }  @SuppressWarnings("unchecked")  public void testParameterizedMapSubclassDeserialization() {    Type type = new TypeToken<MyParameterizedMap<String, Integer>>() {}.getType();    Gson gson = new GsonBuilder().registerTypeAdapter(type,         new InstanceCreator<MyParameterizedMap>() {      public MyParameterizedMap createInstance(Type type) {        return new MyParameterizedMap();      }          }).create();    String json = "{\"a\":1,\"b\":2}";    MyParameterizedMap<String, Integer> map = gson.fromJson(json, type);    assertEquals(1, map.get("a").intValue());     assertEquals(2, map.get("b").intValue());   }  private static class MyParameterizedMap<K, V> extends LinkedHashMap<K, V> {    int foo = 10;  }    public void testMapSubclassSerialization() {    MyMap map = new MyMap();    map.put("a", "b");    String json = gson.toJson(map, MyMap.class);    assertTrue(json.contains("\"a\":\"b\""));  }    public void disable_testMapSubclassDeserialization() {    Gson gson = new GsonBuilder().registerTypeAdapter(MyMap.class, new InstanceCreator<MyMap>(){      public MyMap createInstance(Type type) {        return new MyMap();      }          }).create();    String json = "{\"a\":1,\"b\":2}";    MyMap map = gson.fromJson(json, MyMap.class);    assertEquals("1", map.get("a"));     assertEquals("2", map.get("b"));   }    private static class MyMap extends LinkedHashMap<String, String> {    int foo = 10;  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.InstanceCreator;import com.google.gson.JsonDeserializationContext;import com.google.gson.JsonDeserializer;import com.google.gson.JsonElement;import com.google.gson.JsonObject;import com.google.gson.JsonParseException;import com.google.gson.JsonPrimitive;import com.google.gson.JsonSerializationContext;import com.google.gson.JsonSerializer;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.common.TestTypes.ClassWithCustomTypeConverter;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;/** * Functional tests for the support of custom serializer and deserializers. * * @author Inderjeet Singh * @author Joel Leitch */public class CustomTypeAdaptersTest extends TestCase {  private GsonBuilder builder;  @Override  protected void setUp() throws Exception {    super.setUp();    builder = new GsonBuilder();  }  public void testCustomSerializers() {    Gson gson = builder.registerTypeAdapter(        ClassWithCustomTypeConverter.class, new JsonSerializer<ClassWithCustomTypeConverter>() {      public JsonElement serialize(ClassWithCustomTypeConverter src, Type typeOfSrc,          JsonSerializationContext context) {        JsonObject json = new JsonObject();        json.addProperty("bag", 5);        json.addProperty("value", 25);        return json;      }    }).create();    ClassWithCustomTypeConverter target = new ClassWithCustomTypeConverter();    assertEquals("{\"bag\":5,\"value\":25}", gson.toJson(target));  }  public void testCustomDeserializers() {    Gson gson = new GsonBuilder().registerTypeAdapter(        ClassWithCustomTypeConverter.class, new JsonDeserializer<ClassWithCustomTypeConverter>() {      public ClassWithCustomTypeConverter deserialize(JsonElement json, Type typeOfT,          JsonDeserializationContext context) {        JsonObject jsonObject = json.getAsJsonObject();        int value = jsonObject.get("bag").getAsInt();        return new ClassWithCustomTypeConverter(new BagOfPrimitives(value,            value, false, ""), value);      }    }).create();    String json = "{\"bag\":5,\"value\":25}";    ClassWithCustomTypeConverter target = gson.fromJson(json, ClassWithCustomTypeConverter.class);    assertEquals(5, target.getBag().getIntValue());  }    public void disable_testCustomSerializersOfSelf() {    Gson gson = createGsonObjectWithFooTypeAdapter();    Gson basicGson = new Gson();    Foo newFooObject = new Foo(1, 2L);    String jsonFromCustomSerializer = gson.toJson(newFooObject);    String jsonFromGson = basicGson.toJson(newFooObject);        assertEquals(jsonFromGson, jsonFromCustomSerializer);  }  public void disable_testCustomDeserializersOfSelf() {    Gson gson = createGsonObjectWithFooTypeAdapter();    Gson basicGson = new Gson();    Foo expectedFoo = new Foo(1, 2L);    String json = basicGson.toJson(expectedFoo);    Foo newFooObject = gson.fromJson(json, Foo.class);        assertEquals(expectedFoo.key, newFooObject.key);    assertEquals(expectedFoo.value, newFooObject.value);  }  public void testCustomNestedSerializers() {    Gson gson = new GsonBuilder().registerTypeAdapter(        BagOfPrimitives.class, new JsonSerializer<BagOfPrimitives>() {      public JsonElement serialize(BagOfPrimitives src, Type typeOfSrc,          JsonSerializationContext context) {        return new JsonPrimitive(6);      }    }).create();    ClassWithCustomTypeConverter target = new ClassWithCustomTypeConverter();    assertEquals("{\"bag\":6,\"value\":10}", gson.toJson(target));  }  public void testCustomNestedDeserializers() {    Gson gson = new GsonBuilder().registerTypeAdapter(        BagOfPrimitives.class, new JsonDeserializer<BagOfPrimitives>() {      public BagOfPrimitives deserialize(JsonElement json, Type typeOfT,          JsonDeserializationContext context) throws JsonParseException {        int value = json.getAsInt();        return new BagOfPrimitives(value, value, false, "");      }    }).create();    String json = "{\"bag\":7,\"value\":25}";    ClassWithCustomTypeConverter target = gson.fromJson(json, ClassWithCustomTypeConverter.class);    assertEquals(7, target.getBag().getIntValue());  }    public void testCustomTypeAdapterDoesNotAppliesToSubClasses() {    Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer<Base> () {      public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {        JsonObject json = new JsonObject();        json.addProperty("value", src.baseValue);        return json;      }              }).create();    Base b = new Base();    String json = gson.toJson(b);    assertTrue(json.contains("value"));        b = new Derived();    json = gson.toJson(b);    assertTrue(json.contains("derivedValue"));      }    public void testCustomTypeAdapterAppliesToSubClassesSerializedAsBaseClass() {    Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer<Base> () {      public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {        JsonObject json = new JsonObject();        json.addProperty("value", src.baseValue);        return json;      }              }).create();    Base b = new Base();    String json = gson.toJson(b);    assertTrue(json.contains("value"));        b = new Derived();    json = gson.toJson(b, Base.class);    assertTrue(json.contains("value"));        assertFalse(json.contains("derivedValue"));  }    private static class Base {    int baseValue = 2;  }    private static class Derived extends Base {    int derivedValue = 3;  }      private Gson createGsonObjectWithFooTypeAdapter() {    return new GsonBuilder().registerTypeAdapter(Foo.class, new FooTypeAdapter()).create();  }    public static class Foo {    private final int key;    private final long value;        public Foo() {      this(0, 0L);    }    public Foo(int key, long value) {      this.key = key;      this.value = value;    }  }    public static class FooTypeAdapter implements JsonSerializer<Foo>, JsonDeserializer<Foo> {    public Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)        throws JsonParseException {      return context.deserialize(json, typeOfT);    }    public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext context) {      return context.serialize(src, typeOfSrc);    }  }    public void testCustomSerializerForLong() {    final ClassWithBooleanField customSerializerInvoked = new ClassWithBooleanField();    customSerializerInvoked.value = false;    Gson gson = new GsonBuilder().registerTypeAdapter(Long.class, new JsonSerializer<Long>() {      public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context) {        customSerializerInvoked.value = true;        return new JsonPrimitive(src);      }          }).serializeNulls().create();    ClassWithWrapperLongField src = new ClassWithWrapperLongField();    String json = gson.toJson(src);    assertTrue(json.contains("\"value\":null"));    assertFalse(customSerializerInvoked.value);        customSerializerInvoked.value = false;    src.value = 10L;    json = gson.toJson(src);    assertTrue(json.contains("\"value\":10"));    assertTrue(customSerializerInvoked.value);  }    public void testCustomDeserializerForLong() {    final ClassWithBooleanField customDeserializerInvoked = new ClassWithBooleanField();    customDeserializerInvoked.value = false;    Gson gson = new GsonBuilder().registerTypeAdapter(Long.class, new JsonDeserializer<Long>() {      public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)          throws JsonParseException {        customDeserializerInvoked.value = true;        if (json == null || json.isJsonNull()) {          return null;        } else {          Number number = json.getAsJsonPrimitive().getAsNumber();          return number == null ? null : number.longValue();        }      }          }).create();    String json = "{'value':null}";    ClassWithWrapperLongField target = gson.fromJson(json, ClassWithWrapperLongField.class);    assertNull(target.value);    assertFalse(customDeserializerInvoked.value);        customDeserializerInvoked.value = false;    json = "{'value':10}";    target = gson.fromJson(json, ClassWithWrapperLongField.class);    assertEquals(10L, target.value.longValue());    assertTrue(customDeserializerInvoked.value);  }    private static class ClassWithWrapperLongField {    Long value;  }    private static class ClassWithBooleanField {    Boolean value;  }    public void testCustomByteArraySerializer() {    Gson gson = new GsonBuilder().registerTypeAdapter(byte[].class, new JsonSerializer<byte[]>() {      public JsonElement serialize(byte[] src, Type typeOfSrc, JsonSerializationContext context) {        StringBuilder sb = new StringBuilder(src.length);        for (byte b : src) {          sb.append(b);        }        return new JsonPrimitive(sb.toString());      }          }).create();    byte[] data = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};    String json = gson.toJson(data);    assertEquals("\"0123456789\"", json);  }    public void testCustomByteArrayDeserializerAndInstanceCreator() {    GsonBuilder gsonBuilder = new GsonBuilder().registerTypeAdapter(byte[].class,         new JsonDeserializer<byte[]>() {      public byte[] deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)          throws JsonParseException {        String str = json.getAsString();        byte[] data = new byte[str.length()];        for (int i = 0; i < data.length; ++i) {          data[i] = Byte.parseByte(""+str.charAt(i));        }        return data;      }          });    gsonBuilder.registerTypeAdapter(byte[].class, new InstanceCreator<byte[]>() {      public byte[] createInstance(Type type) {        return new byte[0];      }          });    Gson gson = gsonBuilder.create();    String json = "'0123456789'";    byte[] actual = gson.fromJson(json, byte[].class);    byte[] expected = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};    for (int i = 0; i < actual.length; ++i) {      assertEquals(expected[i], actual[i]);    }  }    private static class StringHolder {    String part1;    String part2;    public StringHolder(String string) {      String[] parts = string.split(":");      part1 = parts[0];      part2 = parts[1];    }    public StringHolder(String part1, String part2) {      this.part1 = part1;      this.part2 = part2;    }  }    private static class StringHolderTypeAdapter implements JsonSerializer<StringHolder>,       JsonDeserializer<StringHolder>, InstanceCreator<StringHolder> {    public StringHolder createInstance(Type type) {      //Fill up with objects that will be thrown away      return new StringHolder("unknown:thing");    }    public StringHolder deserialize(JsonElement src, Type type,         JsonDeserializationContext context) {      return new StringHolder(src.getAsString());    }    public JsonElement serialize(StringHolder src, Type typeOfSrc,         JsonSerializationContext context) {      String contents = src.part1 + ':' + src.part2;      return new JsonPrimitive(contents);    }  }    // Test created from Issue 70  public void testCustomAdapterInvokedForCollectionElementSerializationWithType() {    Gson gson = new GsonBuilder()      .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())      .create();    Type setType = new TypeToken<Set<StringHolder>>() {}.getType();    StringHolder holder = new StringHolder("Jacob", "Tomaw");    Set<StringHolder> setOfHolders = new HashSet<StringHolder>();    setOfHolders.add(holder);    String json = gson.toJson(setOfHolders, setType);    assertTrue(json.contains("Jacob:Tomaw"));  }  // Test created from Issue 70  public void testCustomAdapterInvokedForCollectionElementSerialization() {    Gson gson = new GsonBuilder()      .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())      .create();    StringHolder holder = new StringHolder("Jacob", "Tomaw");    Set<StringHolder> setOfHolders = new HashSet<StringHolder>();    setOfHolders.add(holder);    String json = gson.toJson(setOfHolders);    assertTrue(json.contains("Jacob:Tomaw"));  }  // Test created from Issue 70  public void testCustomAdapterInvokedForCollectionElementDeserialization() {    Gson gson = new GsonBuilder()      .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())      .create();    Type setType = new TypeToken<Set<StringHolder>>() {}.getType();    Set<StringHolder> setOfHolders = gson.fromJson("['Jacob:Tomaw']", setType);    assertEquals(1, setOfHolders.size());    StringHolder foo = setOfHolders.iterator().next();    assertEquals("Jacob", foo.part1);    assertEquals("Tomaw", foo.part2);  }    // Test created from Issue 70  public void testCustomAdapterInvokedForMapElementSerializationWithType() {    Gson gson = new GsonBuilder()      .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())      .create();    Type mapType = new TypeToken<Map<String,StringHolder>>() {}.getType();    StringHolder holder = new StringHolder("Jacob", "Tomaw");    Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>();    mapOfHolders.put("foo", holder);    String json = gson.toJson(mapOfHolders, mapType);    assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\""));  }    // Test created from Issue 70  public void testCustomAdapterInvokedForMapElementSerialization() {    Gson gson = new GsonBuilder()      .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())      .create();    StringHolder holder = new StringHolder("Jacob", "Tomaw");    Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>();    mapOfHolders.put("foo", holder);    String json = gson.toJson(mapOfHolders);    assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\""));  }  // Test created from Issue 70  public void testCustomAdapterInvokedForMapElementDeserialization() {    Gson gson = new GsonBuilder()      .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())      .create();    Type mapType = new TypeToken<Map<String, StringHolder>>() {}.getType();    Map<String, StringHolder> mapOfFoo = gson.fromJson("{'foo':'Jacob:Tomaw'}", mapType);    assertEquals(1, mapOfFoo.size());    StringHolder foo = mapOfFoo.get("foo");    assertEquals("Jacob", foo.part1);    assertEquals("Tomaw", foo.part2);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import java.math.BigDecimal;import java.math.BigInteger;import junit.framework.TestCase;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.JsonParseException;import com.google.gson.common.TestTypes.CrazyLongTypeAdapter;/** * Functional tests for Json primitive values: integers, and floating point numbers. * * @author Inderjeet Singh * @author Joel Leitch */public class PrimitiveTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testPrimitiveIntegerAutoboxedSerialization() {    assertEquals("1", gson.toJson(1));  }  public void testPrimitiveIntegerAutoboxedDeserialization() {    int expected = 1;    int actual = gson.fromJson("1", int.class);    assertEquals(expected, actual);    actual = gson.fromJson("1", Integer.class);    assertEquals(expected, actual);  }  public void testPrimitiveIntegerAutoboxedInASingleElementArraySerialization() {    int target[] = {-9332};    assertEquals("[-9332]", gson.toJson(target));    assertEquals("[-9332]", gson.toJson(target, int[].class));    assertEquals("[-9332]", gson.toJson(target, Integer[].class));  }  public void testPrimitiveIntegerAutoboxedInASingleElementArrayDeserialization() {    int expected = 1;    int actual = gson.fromJson("[1]", int.class);    assertEquals(expected, actual);    actual = gson.fromJson("[1]", Integer.class);    assertEquals(expected, actual);  }  public void testReallyLongValuesSerialization() {    long value = 333961828784581L;    assertEquals("333961828784581", gson.toJson(value));  }  public void testReallyLongValuesDeserialization() {    String json = "333961828784581";    long value = gson.fromJson(json, Long.class);    assertEquals(333961828784581L, value);  }  public void testPrimitiveLongAutoboxedSerialization() {    assertEquals("1", gson.toJson(1L, long.class));    assertEquals("1", gson.toJson(1L, Long.class));  }  public void testPrimitiveLongAutoboxedDeserialization() {    long expected = 1L;    long actual = gson.fromJson("1", long.class);    assertEquals(expected, actual);    actual = gson.fromJson("1", Long.class);    assertEquals(expected, actual);  }  public void testPrimitiveLongAutoboxedInASingleElementArraySerialization() {    long[] target = {-23L};    assertEquals("[-23]", gson.toJson(target));    assertEquals("[-23]", gson.toJson(target, long[].class));    assertEquals("[-23]", gson.toJson(target, Long[].class));  }  public void testPrimitiveLongAutoboxedInASingleElementArrayDeserialization() {    long expected = 1L;    long actual = gson.fromJson("[1]", long.class);    assertEquals(expected, actual);    actual = gson.fromJson("[1]", Long.class);    assertEquals(expected, actual);  }  public void testPrimitiveBooleanAutoboxedSerialization() {    assertEquals("true", gson.toJson(true));    assertEquals("false", gson.toJson(false));  }  public void testPrimitiveBooleanAutoboxedDeserialization() {    assertEquals(Boolean.FALSE, gson.fromJson("[false]", Boolean.class));    assertEquals(Boolean.TRUE, gson.fromJson("[true]", Boolean.class));    boolean value = gson.fromJson("false", boolean.class);    assertEquals(false, value);    value = gson.fromJson("true", boolean.class);    assertEquals(true, value);  }  public void testPrimitiveBooleanAutoboxedInASingleElementArraySerialization() {    boolean target[] = {false};    assertEquals("[false]", gson.toJson(target));    assertEquals("[false]", gson.toJson(target, boolean[].class));    assertEquals("[false]", gson.toJson(target, Boolean[].class));  }  public void testPrimitiveBooleanAutoboxedInASingleElementArrayDeserialization() {    assertEquals(Boolean.FALSE, gson.fromJson("[false]", Boolean.class));    assertEquals(Boolean.TRUE, gson.fromJson("[true]", Boolean.class));    boolean value = gson.fromJson("[false]", boolean.class);    assertEquals(false, value);    value = gson.fromJson("[true]", boolean.class);    assertEquals(true, value);  }  public void testPrimitiveDoubleAutoboxedSerialization() {    assertEquals("-122.08234335", gson.toJson(-122.08234335));    assertEquals("122.08112002", gson.toJson(new Double(122.08112002)));  }  public void testPrimitiveDoubleAutoboxedDeserialization() {    double actual = gson.fromJson("-122.08858585", double.class);    assertEquals(-122.08858585, actual);    actual = gson.fromJson("122.023900008000", Double.class);    assertEquals(122.023900008, actual);  }  public void testPrimitiveDoubleAutoboxedInASingleElementArraySerialization() {    double[] target = {-122.08D};    assertEquals("[-122.08]", gson.toJson(target));    assertEquals("[-122.08]", gson.toJson(target, double[].class));    assertEquals("[-122.08]", gson.toJson(target, Double[].class));  }  public void testPrimitiveDoubleAutoboxedInASingleElementArrayDeserialization() {    double expected = -122.08;    double actual = gson.fromJson("[-122.08]", double.class);    assertEquals(expected, actual);    actual = gson.fromJson("[-122.08]", Double.class);    assertEquals(expected, actual);  }  public void testBigDecimalSerialization() {    BigDecimal target = new BigDecimal("-122.0e-21");    String json = gson.toJson(target);    assertEquals(target, new BigDecimal(json));  }  public void testBigDecimalDeserialization() {    BigDecimal target = new BigDecimal("-122.0e-21");    String json = "-122.0e-21";    assertEquals(target, gson.fromJson(json, BigDecimal.class));  }  public void testBigDecimalInASingleElementArraySerialization() {    BigDecimal[] target = {new BigDecimal("-122.08e-21")};    String json = gson.toJson(target);    String actual = extractElementFromArray(json);    assertEquals(target[0], new BigDecimal(actual));    json = gson.toJson(target, BigDecimal[].class);    actual = extractElementFromArray(json);    assertEquals(target[0], new BigDecimal(actual));  }  public void testBigDecimalInASingleElementArrayDeserialization() {    BigDecimal expected = new BigDecimal("-122.08e-21");    BigDecimal actual = gson.fromJson("[-122.08e-21]", BigDecimal.class);    assertEquals(expected, actual);  }  public void testSmallValueForBigDecimalSerialization() {    BigDecimal target = new BigDecimal("1.55");    String actual = gson.toJson(target);    assertEquals(target.toString(), actual);  }  public void testSmallValueForBigDecimalDeserialization() {    BigDecimal expected = new BigDecimal("1.55");    BigDecimal actual = gson.fromJson("1.55", BigDecimal.class);    assertEquals(expected, actual);  }  public void testBigIntegerSerialization() {    BigInteger target = new BigInteger("12121211243123245845384534687435634558945453489543985435");    assertEquals(target.toString(), gson.toJson(target));  }  public void testBigIntegerDeserialization() {    String json = "12121211243123245845384534687435634558945453489543985435";    BigInteger target = new BigInteger(json);    assertEquals(target, gson.fromJson(json, BigInteger.class));  }  public void testBigIntegerInASingleElementArraySerialization() {    BigInteger[] target = {new BigInteger("1212121243434324323254365345367456456456465464564564")};    String json = gson.toJson(target);    String actual = extractElementFromArray(json);    assertEquals(target[0], new BigInteger(actual));    json = gson.toJson(target, BigInteger[].class);    actual = extractElementFromArray(json);    assertEquals(target[0], new BigInteger(actual));  }  public void testBigIntegerInASingleElementArrayDeserialization() {    BigInteger expected = new BigInteger("34343434343424242423432323243243242");    BigInteger actual = gson.fromJson("[34343434343424242423432323243243242]", BigInteger.class);    assertEquals(expected, actual);  }  public void testSmallValueForBigIntegerSerialization() {    BigInteger target = new BigInteger("15");    String actual = gson.toJson(target);    assertEquals(target.toString(), actual);  }  public void testSmallValueForBigIntegerDeserialization() {    BigInteger expected = new BigInteger("15");    BigInteger actual = gson.fromJson("15", BigInteger.class);    assertEquals(expected, actual);  }  public void testBadValueForBigIntegerDeserialization() {    try {      gson.fromJson("15.099", BigInteger.class);      fail("BigInteger can not be decimal values.");    } catch (JsonParseException expected) { }  }    public void testOverridingDefaultPrimitiveSerialization() {    CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter();    gson = new GsonBuilder()        .registerTypeAdapter(long.class, typeAdapter)        .registerTypeAdapter(Long.class, typeAdapter)        .create();    long value = 1L;    String serializedValue = gson.toJson(value);    assertEquals(String.valueOf(value + CrazyLongTypeAdapter.DIFFERENCE), serializedValue);        long deserializedValue = gson.fromJson(serializedValue, long.class);    assertEquals(value, deserializedValue);  }  private String extractElementFromArray(String json) {    return json.substring(json.indexOf('[') + 1, json.indexOf(']'));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.JsonDeserializationContext;import com.google.gson.JsonDeserializer;import com.google.gson.JsonElement;import com.google.gson.JsonParseException;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.common.TestTypes.ClassOverridingEquals;import junit.framework.TestCase;import java.lang.reflect.Type;/** * Functional tests that do not fall neatly into any of the existing classification. * * @author Inderjeet Singh * @author Joel Leitch */public class UncategorizedTest extends TestCase {  private Gson gson = null;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testInvalidJsonDeserializationFails() throws Exception {    try {      gson.fromJson("adfasdf1112,,,\":", BagOfPrimitives.class);      fail("Bad JSON should throw a ParseException");    } catch (JsonParseException expected) { }    try {      gson.fromJson("{adfasdf1112,,,\":}", BagOfPrimitives.class);      fail("Bad JSON should throw a ParseException");    } catch (JsonParseException expected) { }  }  public void testObjectEqualButNotSameSerialization() throws Exception {    ClassOverridingEquals objA = new ClassOverridingEquals();    ClassOverridingEquals objB = new ClassOverridingEquals();    objB.ref = objA;    String json = gson.toJson(objB);    assertEquals(objB.getExpectedJson(), json);  }  public void testStaticFieldsAreNotSerialized() {    BagOfPrimitives target = new BagOfPrimitives();    assertFalse(gson.toJson(target).contains("DEFAULT_VALUE"));  }  /**   * This test ensures that a custom deserializer is able to return a derived class instance for a   * base class object. For a motivation for this test, see Issue 37 and   * http://groups.google.com/group/google-gson/browse_thread/thread/677d56e9976d7761   */  public void testReturningDerivedClassesDuringDeserialization() {    Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new BaseTypeAdapter()).create();    String json = "{\"opType\":\"OP1\"}";    Base base = gson.fromJson(json, Base.class);    assertTrue(base instanceof Derived1);    assertEquals(OperationType.OP1, base.opType);    json = "{\"opType\":\"OP2\"}";    base = gson.fromJson(json, Base.class);    assertTrue(base instanceof Derived2);    assertEquals(OperationType.OP2, base.opType);  }  private enum OperationType { OP1, OP2 }  private static class Base {    OperationType opType;  }  private static class Derived1 extends Base {    Derived1() { opType = OperationType.OP1; }  }  private static class Derived2 extends Base {    Derived2() { opType = OperationType.OP2; }  }  private static class BaseTypeAdapter implements JsonDeserializer<Base> {    public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)        throws JsonParseException {      String opTypeStr = json.getAsJsonObject().get("opType").getAsString();      OperationType opType = OperationType.valueOf(opTypeStr);      switch (opType) {      case OP1:        return new Derived1();      case OP2:        return new Derived2();      }      throw new JsonParseException("unknown type: " + json);    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.ParamterizedTypeFixtures.MyParameterizedType;import com.google.gson.ParamterizedTypeFixtures.MyParameterizedTypeAdapter;import com.google.gson.ParamterizedTypeFixtures.MyParameterizedTypeInstanceCreator;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.io.Reader;import java.io.StringReader;import java.io.StringWriter;import java.io.Writer;import java.lang.reflect.Type;import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * Functional tests for the serialization and deserialization of parameterized types in Gson. * * @author Inderjeet Singh * @author Joel Leitch */public class ParameterizedTypesTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testParameterizedTypesSerialization() throws Exception {    MyParameterizedType<Integer> src = new MyParameterizedType<Integer>(10);    Type typeOfSrc = new TypeToken<MyParameterizedType<Integer>>() {}.getType();    String json = gson.toJson(src, typeOfSrc);    assertEquals(src.getExpectedJson(), json);  }  public void testParameterizedTypeDeserialization() throws Exception {    BagOfPrimitives bag = new BagOfPrimitives();    MyParameterizedType<BagOfPrimitives> expected = new MyParameterizedType<BagOfPrimitives>(bag);    Type expectedType = new TypeToken<MyParameterizedType<BagOfPrimitives>>() {}.getType();    BagOfPrimitives bagDefaultInstance = new BagOfPrimitives();    Gson gson = new GsonBuilder().registerTypeAdapter(        expectedType, new MyParameterizedTypeInstanceCreator<BagOfPrimitives>(bagDefaultInstance))        .create();    String json = expected.getExpectedJson();    MyParameterizedType<BagOfPrimitives> actual = gson.fromJson(json, expectedType);    assertEquals(expected, actual);  }  public void testTypesWithMultipleParametersSerialization() throws Exception {    MultiParameters<Integer, Float, Double, String, BagOfPrimitives> src =      new MultiParameters<Integer, Float, Double, String, BagOfPrimitives>(10, 1.0F, 2.1D,          "abc", new BagOfPrimitives());    Type typeOfSrc = new TypeToken<MultiParameters<Integer, Float, Double, String,        BagOfPrimitives>>() {}.getType();    String json = gson.toJson(src, typeOfSrc);    String expected = "{\"a\":10,\"b\":1.0,\"c\":2.1,\"d\":\"abc\","      + "\"e\":{\"longValue\":0,\"intValue\":0,\"booleanValue\":false,\"stringValue\":\"\"}}";    assertEquals(expected, json);  }  public void testTypesWithMultipleParametersDeserialization() throws Exception {    Type typeOfTarget = new TypeToken<MultiParameters<Integer, Float, Double, String,        BagOfPrimitives>>() {}.getType();    String json = "{\"a\":10,\"b\":1.0,\"c\":2.1,\"d\":\"abc\","      + "\"e\":{\"longValue\":0,\"intValue\":0,\"booleanValue\":false,\"stringValue\":\"\"}}";    MultiParameters<Integer, Float, Double, String, BagOfPrimitives> target =      gson.fromJson(json, typeOfTarget);    MultiParameters<Integer, Float, Double, String, BagOfPrimitives> expected =      new MultiParameters<Integer, Float, Double, String, BagOfPrimitives>(10, 1.0F, 2.1D,          "abc", new BagOfPrimitives());    assertEquals(expected, target);  }  public void testParameterizedTypeWithCustomSerializer() {    Type ptIntegerType = new TypeToken<MyParameterizedType<Integer>>() {}.getType();    Type ptStringType = new TypeToken<MyParameterizedType<String>>() {}.getType();    Gson gson = new GsonBuilder()        .registerTypeAdapter(ptIntegerType, new MyParameterizedTypeAdapter<Integer>())        .registerTypeAdapter(ptStringType, new MyParameterizedTypeAdapter<String>())        .create();    MyParameterizedType<Integer> intTarget = new MyParameterizedType<Integer>(10);    String json = gson.toJson(intTarget, ptIntegerType);    assertEquals(MyParameterizedTypeAdapter.<Integer>getExpectedJson(intTarget), json);    MyParameterizedType<String> stringTarget = new MyParameterizedType<String>("abc");    json = gson.toJson(stringTarget, ptStringType);    assertEquals(MyParameterizedTypeAdapter.<String>getExpectedJson(stringTarget), json);  }  public void testParameterizedTypesWithCustomDeserializer() {    Type ptIntegerType = new TypeToken<MyParameterizedType<Integer>>() {}.getType();    Type ptStringType = new TypeToken<MyParameterizedType<String>>() {}.getType();    Gson gson = new GsonBuilder().registerTypeAdapter(        ptIntegerType, new MyParameterizedTypeAdapter<Integer>())        .registerTypeAdapter(ptStringType, new MyParameterizedTypeAdapter<String>())        .registerTypeAdapter(ptStringType, new MyParameterizedTypeInstanceCreator<String>(""))        .registerTypeAdapter(ptIntegerType,            new MyParameterizedTypeInstanceCreator<Integer>(new Integer(0)))        .create();    MyParameterizedType<Integer> src = new MyParameterizedType<Integer>(10);    String json = MyParameterizedTypeAdapter.<Integer>getExpectedJson(src);    MyParameterizedType<Integer> intTarget = gson.fromJson(json, ptIntegerType);    assertEquals(10, (int) intTarget.value);    MyParameterizedType<String> srcStr = new MyParameterizedType<String>("abc");    json = MyParameterizedTypeAdapter.<String>getExpectedJson(srcStr);    MyParameterizedType<String> stringTarget = gson.fromJson(json, ptStringType);    assertEquals("abc", stringTarget.value);  }  public void testParameterizedTypesWithWriterSerialization() throws Exception {    Writer writer = new StringWriter();    MyParameterizedType<Integer> src = new MyParameterizedType<Integer>(10);    Type typeOfSrc = new TypeToken<MyParameterizedType<Integer>>() {}.getType();    gson.toJson(src, typeOfSrc, writer);    assertEquals(src.getExpectedJson(), writer.toString());  }  public void testParameterizedTypeWithReaderDeserialization() throws Exception {    BagOfPrimitives bag = new BagOfPrimitives();    MyParameterizedType<BagOfPrimitives> expected = new MyParameterizedType<BagOfPrimitives>(bag);    Type expectedType = new TypeToken<MyParameterizedType<BagOfPrimitives>>() {}.getType();    BagOfPrimitives bagDefaultInstance = new BagOfPrimitives();    Gson gson = new GsonBuilder().registerTypeAdapter(        expectedType, new MyParameterizedTypeInstanceCreator<BagOfPrimitives>(bagDefaultInstance))        .create();    Reader json = new StringReader(expected.getExpectedJson());    MyParameterizedType<Integer> actual = gson.fromJson(json, expectedType);    assertEquals(expected, actual);  }  @SuppressWarnings("unchecked")  public void testVariableTypeFieldsAndGenericArraysSerialization() throws Exception {    Integer obj = 0;    Integer[] array = { 1, 2, 3 };    List<Integer> list = new ArrayList<Integer>();    list.add(4);    list.add(5);    List<Integer>[] arrayOfLists = new List[] { list, list };    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();    ObjectWithTypeVariables<Integer> objToSerialize =        new ObjectWithTypeVariables<Integer>(obj, array, list, arrayOfLists, list, arrayOfLists);    String json = gson.toJson(objToSerialize, typeOfSrc);    assertEquals(objToSerialize.getExpectedJson(), json);  }  @SuppressWarnings("unchecked")  public void testVariableTypeFieldsAndGenericArraysDeserialization() throws Exception {    Integer obj = 0;    Integer[] array = { 1, 2, 3 };    List<Integer> list = new ArrayList<Integer>();    list.add(4);    list.add(5);    List<Integer>[] arrayOfLists = new List[] { list, list };    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();    ObjectWithTypeVariables<Integer> objToSerialize =        new ObjectWithTypeVariables<Integer>(obj, array, list, arrayOfLists, list, arrayOfLists);    String json = gson.toJson(objToSerialize, typeOfSrc);    ObjectWithTypeVariables<Integer> objAfterDeserialization = gson.fromJson(json, typeOfSrc);    assertEquals(objAfterDeserialization.getExpectedJson(), json);  }  public void testVariableTypeDeserialization() throws Exception {    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();    ObjectWithTypeVariables<Integer> objToSerialize =        new ObjectWithTypeVariables<Integer>(0, null, null, null, null, null);    String json = gson.toJson(objToSerialize, typeOfSrc);    ObjectWithTypeVariables<Integer> objAfterDeserialization = gson.fromJson(json, typeOfSrc);    assertEquals(objAfterDeserialization.getExpectedJson(), json);  }  public void testVariableTypeArrayDeserialization() throws Exception {    Integer[] array = { 1, 2, 3 };    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();    ObjectWithTypeVariables<Integer> objToSerialize =        new ObjectWithTypeVariables<Integer>(null, array, null, null, null, null);    String json = gson.toJson(objToSerialize, typeOfSrc);    ObjectWithTypeVariables<Integer> objAfterDeserialization = gson.fromJson(json, typeOfSrc);    assertEquals(objAfterDeserialization.getExpectedJson(), json);  }  public void testParameterizedTypeWithVariableTypeDeserialization() throws Exception {    List<Integer> list = new ArrayList<Integer>();    list.add(4);    list.add(5);    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();    ObjectWithTypeVariables<Integer> objToSerialize =        new ObjectWithTypeVariables<Integer>(null, null, list, null, null, null);    String json = gson.toJson(objToSerialize, typeOfSrc);    ObjectWithTypeVariables<Integer> objAfterDeserialization = gson.fromJson(json, typeOfSrc);    assertEquals(objAfterDeserialization.getExpectedJson(), json);  }  @SuppressWarnings("unchecked")  public void testParameterizedTypeGenericArraysSerialization() throws Exception {    List<Integer> list = new ArrayList<Integer>();    list.add(1);    list.add(2);    List<Integer>[] arrayOfLists = new List[] { list, list };    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();    ObjectWithTypeVariables<Integer> objToSerialize =        new ObjectWithTypeVariables<Integer>(null, null, null, arrayOfLists, null, null);    String json = gson.toJson(objToSerialize, typeOfSrc);    assertEquals("{\"arrayOfListOfTypeParameters\":[[1,2],[1,2]]}", json);  }  @SuppressWarnings("unchecked")  public void testParameterizedTypeGenericArraysDeserialization() throws Exception {    List<Integer> list = new ArrayList<Integer>();    list.add(1);    list.add(2);    List<Integer>[] arrayOfLists = new List[] { list, list };    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();    ObjectWithTypeVariables<Integer> objToSerialize =        new ObjectWithTypeVariables<Integer>(null, null, null, arrayOfLists, null, null);    String json = gson.toJson(objToSerialize, typeOfSrc);    ObjectWithTypeVariables<Integer> objAfterDeserialization = gson.fromJson(json, typeOfSrc);    assertEquals(objAfterDeserialization.getExpectedJson(), json);  }  /**   * An test object that has fields that are type variables.   *   * @param <T> Enforce T to be a string to make writing the "toExpectedJson" method easier.   */  private static class ObjectWithTypeVariables<T extends Number> {    private final T typeParameterObj;    private final T[] typeParameterArray;    private final List<T> listOfTypeParameters;    private final List<T>[] arrayOfListOfTypeParameters;    private final List<? extends T> listOfWildcardTypeParameters;    private final List<? extends T>[] arrayOfListOfWildcardTypeParameters;    public ObjectWithTypeVariables() {      this(null, null, null, null, null, null);    }    public ObjectWithTypeVariables(T obj, T[] array, List<T> list, List<T>[] arrayOfList,        List<? extends T> wildcardList, List<? extends T>[] arrayOfWildcardList) {      this.typeParameterObj = obj;      this.typeParameterArray = array;      this.listOfTypeParameters = list;      this.arrayOfListOfTypeParameters = arrayOfList;      this.listOfWildcardTypeParameters = wildcardList;      this.arrayOfListOfWildcardTypeParameters = arrayOfWildcardList;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder().append("{");      boolean needsComma = false;      if (typeParameterObj != null) {        sb.append("\"typeParameterObj\":").append(toString(typeParameterObj));        needsComma = true;      }      if (typeParameterArray != null) {        if (needsComma) {          sb.append(',');        }        sb.append("\"typeParameterArray\":[");        appendObjectsToBuilder(sb, Arrays.asList(typeParameterArray));        sb.append(']');        needsComma = true;      }      if (listOfTypeParameters != null) {        if (needsComma) {          sb.append(',');        }        sb.append("\"listOfTypeParameters\":[");        appendObjectsToBuilder(sb, listOfTypeParameters);        sb.append(']');        needsComma = true;      }      if (arrayOfListOfTypeParameters != null) {        if (needsComma) {          sb.append(',');        }        sb.append("\"arrayOfListOfTypeParameters\":[");        appendObjectsToBuilder(sb, arrayOfListOfTypeParameters);        sb.append(']');        needsComma = true;      }      if (listOfWildcardTypeParameters != null) {        if (needsComma) {          sb.append(',');        }        sb.append("\"listOfWildcardTypeParameters\":[");        appendObjectsToBuilder(sb, listOfWildcardTypeParameters);        sb.append(']');        needsComma = true;      }      if (arrayOfListOfWildcardTypeParameters != null) {        if (needsComma) {          sb.append(',');        }        sb.append("\"arrayOfListOfWildcardTypeParameters\":[");        appendObjectsToBuilder(sb, arrayOfListOfWildcardTypeParameters);        sb.append(']');        needsComma = true;      }      sb.append('}');      return sb.toString();    }    private void appendObjectsToBuilder(StringBuilder sb, Iterable<? extends T> iterable) {      boolean isFirst = true;      for (T obj : iterable) {        if (!isFirst) {          sb.append(',');        }        isFirst = false;        sb.append(toString(obj));      }    }    private void appendObjectsToBuilder(StringBuilder sb, List<? extends T>[] arrayOfList) {      boolean isFirst = true;      for (List<? extends T> list : arrayOfList) {        if (!isFirst) {          sb.append(',');        }        isFirst = false;        if (list != null) {          sb.append('[');          appendObjectsToBuilder(sb, list);          sb.append(']');        } else {          sb.append("null");        }      }    }    public String toString(T obj) {      return obj.toString();    }  }  private static class MultiParameters<A, B, C, D, E> {    A a;    B b;    C c;    D d;    E e;    MultiParameters() {    }    MultiParameters(A a, B b, C c, D d, E e) {      super();      this.a = a;      this.b = b;      this.c = c;      this.d = d;      this.e = e;    }    @Override    public int hashCode() {      final int prime = 31;      int result = 1;      result = prime * result + ((a == null) ? 0 : a.hashCode());      result = prime * result + ((b == null) ? 0 : b.hashCode());      result = prime * result + ((c == null) ? 0 : c.hashCode());      result = prime * result + ((d == null) ? 0 : d.hashCode());      result = prime * result + ((e == null) ? 0 : e.hashCode());      return result;    }    @Override    @SuppressWarnings("unchecked")    public boolean equals(Object obj) {      if (this == obj) {        return true;      }      if (obj == null) {        return false;      }      if (getClass() != obj.getClass()) {        return false;      }      MultiParameters<A, B, C, D, E> other = (MultiParameters<A, B, C, D, E>) obj;      if (a == null) {        if (other.a != null) {          return false;        }      } else if (!a.equals(other.a)) {        return false;      }      if (b == null) {        if (other.b != null) {          return false;        }      } else if (!b.equals(other.b)) {        return false;      }      if (c == null) {        if (other.c != null) {          return false;        }      } else if (!c.equals(other.c)) {        return false;      }      if (d == null) {        if (other.d != null) {          return false;        }      } else if (!d.equals(other.d)) {        return false;      }      if (e == null) {        if (other.e != null) {          return false;        }      } else if (!e.equals(other.e)) {        return false;      }      return true;    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.common.TestTypes.BagOfPrimitives;import junit.framework.TestCase;import java.io.Reader;import java.io.StringReader;import java.io.StringWriter;import java.io.Writer;/** * Functional tests for the support of {@link Reader}s and {@link Writer}s. * * @author Inderjeet Singh * @author Joel Leitch */public class ReadersWritersTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testWriterForSerialization() throws Exception {    Writer writer = new StringWriter();    BagOfPrimitives src = new BagOfPrimitives();    gson.toJson(src, writer);    assertEquals(src.getExpectedJson(), writer.toString());  }  public void testReaderForDeserialization() throws Exception {    BagOfPrimitives expected = new BagOfPrimitives();    Reader json = new StringReader(expected.getExpectedJson());    BagOfPrimitives actual = gson.fromJson(json, BagOfPrimitives.class);    assertEquals(expected, actual);  }  public void testTopLevelNullObjectSerializationWithWriter() {    StringWriter writer = new StringWriter();    gson.toJson(null, writer);    assertEquals("", writer.toString());  }  public void testTopLevelNullObjectDeserializationWithReader() {    StringReader reader = new StringReader("null");    Integer nullIntObject = gson.fromJson(reader, Integer.class);    assertNull(nullIntObject);  }  public void testTopLevelNullObjectSerializationWithWriterAndSerializeNulls() {    Gson gson = new GsonBuilder().serializeNulls().create();    StringWriter writer = new StringWriter();    gson.toJson(null, writer);    assertEquals("null", writer.toString());  }  public void testTopLevelNullObjectDeserializationWithReaderAndSerializeNulls() {    Gson gson = new GsonBuilder().serializeNulls().create();    StringReader reader = new StringReader("null");    Integer nullIntObject = gson.fromJson(reader, Integer.class);    assertNull(nullIntObject);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.atomic.AtomicBoolean;import junit.framework.TestCase;import com.google.gson.Gson;/** * Tests for ensuring Gson thread-safety. *  * @author Inderjeet Singh * @author Joel Leitch */public class ConcurrencyTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  /**   * Source-code based on   * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081   */  public void testSingleThreadSerialization() {     MyObject myObj = new MyObject();     for (int i = 0; i < 10; i++) {       gson.toJson(myObj);     }   }   /**   * Source-code based on   * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081   */  public void testSingleThreadDeserialization() {     for (int i = 0; i < 10; i++) {       gson.fromJson("{'a':'hello','b':'world','i':1}", MyObject.class);     }   }   /**   * Source-code based on   * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081   */  public void testMultiThreadSerialization() throws InterruptedException {    final CountDownLatch startLatch = new CountDownLatch(1);    final CountDownLatch finishedLatch = new CountDownLatch(10);    final AtomicBoolean failed = new AtomicBoolean(false);    ExecutorService executor = Executors.newFixedThreadPool(10);    for (int taskCount = 0; taskCount < 10; taskCount++) {      executor.execute(new Runnable() {        public void run() {          MyObject myObj = new MyObject();          try {            startLatch.await();            for (int i = 0; i < 10; i++) {              gson.toJson(myObj);            }          } catch (Throwable t) {            failed.set(true);          } finally {            finishedLatch.countDown();          }        }      });    }    startLatch.countDown();    finishedLatch.await();    assertFalse(failed.get());  }  /**   * Source-code based on   * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081   */  public void testMultiThreadDeserialization() throws InterruptedException {    final CountDownLatch startLatch = new CountDownLatch(1);    final CountDownLatch finishedLatch = new CountDownLatch(10);    final AtomicBoolean failed = new AtomicBoolean(false);    ExecutorService executor = Executors.newFixedThreadPool(10);    for (int taskCount = 0; taskCount < 10; taskCount++) {      executor.execute(new Runnable() {        public void run() {          try {            startLatch.await();            for (int i = 0; i < 10; i++) {              gson.fromJson("{'a':'hello','b':'world','i':1}", MyObject.class);             }          } catch (Throwable t) {            failed.set(true);          } finally {            finishedLatch.countDown();          }        }      });    }    startLatch.countDown();    finishedLatch.await();    assertFalse(failed.get());  }    private static class MyObject {    String a;    String b;    int i;    MyObject() {      this("hello", "world", 42);    }    public MyObject(String a, String b, int i) {      this.a = a;      this.b = b;      this.i = i;    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.annotations.Since;import com.google.gson.common.TestTypes.BagOfPrimitives;import junit.framework.TestCase;/** * Functional tests for versioning support in Gson. * * @author Inderjeet Singh * @author Joel Leitch */public class VersioningTest extends TestCase {  private static final int A = 0;  private static final int B = 1;  private static final int C = 2;  private static final int D = 3;  private GsonBuilder builder;  @Override  protected void setUp() throws Exception {    super.setUp();    builder = new GsonBuilder();  }  public void testVersionedClassesSerialization() {    Gson gson = builder.setVersion(1.0).create();    String json1 = gson.toJson(new Version1());    String json2 = gson.toJson(new Version1_1());    assertEquals(json1, json2);  }  public void testVersionedClassesDeserialization() {    Gson gson = builder.setVersion(1.0).create();    String json = "{\"a\":3,\"b\":4,\"c\":5}";    Version1 version1 = gson.fromJson(json, Version1.class);    assertEquals(3, version1.a);    assertEquals(4, version1.b);    Version1_1 version1_1 = gson.fromJson(json, Version1_1.class);    assertEquals(3, version1_1.a);    assertEquals(4, version1_1.b);    assertEquals(C, version1_1.c);  }  public void testIgnoreLaterVersionClassSerialization() {    Gson gson = builder.setVersion(1.0).create();    assertEquals("", gson.toJson(new Version1_2()));  }  public void testIgnoreLaterVersionClassDeserialization() {    Gson gson = builder.setVersion(1.0).create();    String json = "{\"a\":3,\"b\":4,\"c\":5,\"d\":6}";    Version1_2 version1_2 = gson.fromJson(json, Version1_2.class);    // Since the class is versioned to be after 1.0, all fields should get set to    // their default values.    assertEquals(A, version1_2.a);    assertEquals(B, version1_2.b);    assertEquals(C, version1_2.c);    assertEquals(D, version1_2.d);  }  public void testVersionedGsonWithUnversionedClassesSerialization() {    Gson gson = builder.setVersion(1.0).create();    BagOfPrimitives target = new BagOfPrimitives(10, 20, false, "stringValue");    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testVersionedGsonWithUnversionedClassesDeserialization() {    Gson gson = builder.setVersion(1.0).create();    String json = "{\"longValue\":10,\"intValue\":20,\"booleanValue\":false}";    BagOfPrimitives expected = new BagOfPrimitives();    expected.longValue = 10;    expected.intValue = 20;    expected.booleanValue = false;    BagOfPrimitives actual = gson.fromJson(json, BagOfPrimitives.class);    assertEquals(expected, actual);  }  private static class Version1 {    int a = A;    @Since(1.0) int b = B;  }  private static class Version1_1 extends Version1 {    @Since(1.1) int c = C;  }  @Since(1.2)  private static class Version1_2 extends Version1_1 {    int d = D;  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.FieldNamingPolicy;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.common.TestTypes.ClassWithSerializedNameFields;import com.google.gson.common.TestTypes.StringWrapper;import junit.framework.TestCase;/** * Functional tests for naming policies. * * @author Inderjeet Singh * @author Joel Leitch */public class NamingPolicyTest extends TestCase {  private GsonBuilder builder;  @Override  protected void setUp() throws Exception {    super.setUp();    builder = new GsonBuilder();  }  public void testGsonWithNonDefaultFieldNamingPolicySerialization() {    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();    StringWrapper target = new StringWrapper("blah");    assertEquals("{\"SomeConstantStringInstanceField\":\""        + target.someConstantStringInstanceField + "\"}", gson.toJson(target));  }  public void testGsonWithNonDefaultFieldNamingPolicyDeserialiation() {    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();    StringWrapper target = new StringWrapper("SomeValue");    String jsonRepresentation = gson.toJson(target);    StringWrapper deserializedObject = gson.fromJson(jsonRepresentation, StringWrapper.class);    assertEquals(target.someConstantStringInstanceField,        deserializedObject.someConstantStringInstanceField);  }  public void testGsonWithSerializedNameFieldNamingPolicySerialization() {    Gson gson = builder.create();    ClassWithSerializedNameFields expected = new ClassWithSerializedNameFields(5);    String actual = gson.toJson(expected);    assertEquals(expected.getExpectedJson(), actual);  }  public void testGsonWithSerializedNameFieldNamingPolicyDeserialization() {    Gson gson = builder.create();    ClassWithSerializedNameFields expected = new ClassWithSerializedNameFields(5);    ClassWithSerializedNameFields actual =        gson.fromJson(expected.getExpectedJson(), ClassWithSerializedNameFields.class);    assertEquals(expected.f, actual.f);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.common.TestTypes.ClassWithTransientFields;import com.google.gson.common.TestTypes.Nested;import com.google.gson.common.TestTypes.PrimitiveArray;import junit.framework.TestCase;import java.util.ArrayList;import java.util.List;/** * Functional tests for print formatting. * * @author Inderjeet Singh * @author Joel Leitch */public class PrintFormattingTest extends TestCase {  @SuppressWarnings("unchecked")  public void testCompactFormattingLeavesNoWhiteSpace() {    Gson gson = new Gson();    List list = new ArrayList();    list.add(new BagOfPrimitives());    list.add(new Nested());    list.add(new PrimitiveArray());    list.add(new ClassWithTransientFields());    String json = gson.toJson(list);    assertContainsNoWhiteSpace(json);  }  private static void assertContainsNoWhiteSpace(String str) {    for (char c : str.toCharArray()) {      assertFalse(Character.isWhitespace(c));    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import junit.framework.TestCase;/** * Functional tests for internationalized strings. * * @author Inderjeet Singh */public class InternationalizationTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  /*  public void testStringsWithRawChineseCharactersSerialization() throws Exception {    String target = "好好好";    String json = gson.toJson(target);    String expected = "\"\\u597d\\u597d\\u597d\"";    assertEquals(expected, json);  }  */  public void testStringsWithRawChineseCharactersDeserialization() throws Exception {    String expected = "好好好";    String json = "\"" + expected + "\"";    String actual = gson.fromJson(json, String.class);    assertEquals(expected, actual);  }  public void testStringsWithUnicodeChineseCharactersSerialization() throws Exception {    String target = "\u597d\u597d\u597d";    String json = gson.toJson(target);    String expected = "\"\\u597d\\u597d\\u597d\"";    assertEquals(expected, json);  }  public void testStringsWithUnicodeChineseCharactersDeserialization() throws Exception {    String expected = "\u597d\u597d\u597d";    String json = "\"" + expected + "\"";    String actual = gson.fromJson(json, String.class);    assertEquals(expected, actual);  }  public void testStringsWithUnicodeChineseCharactersEscapedDeserialization() throws Exception {    String actual = gson.fromJson("'\\u597d\\u597d\\u597d'", String.class);    assertEquals("\u597d\u597d\u597d", actual);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.common.TestTypes.BagOfPrimitives;import junit.framework.TestCase;public class EscapingTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testEscapingQuotesInStringArray() throws Exception {    String[] valueWithQuotes = { "beforeQuote\"afterQuote" };    String jsonRepresentation = gson.toJson(valueWithQuotes);    String[] target = gson.fromJson(jsonRepresentation, String[].class);    assertEquals(1, target.length);    assertEquals(valueWithQuotes[0], target[0]);  }  public void testEscapingObjectFields() throws Exception {    BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>");    String jsonRepresentation = gson.toJson(objWithPrimitives);    assertFalse(jsonRepresentation.contains("<"));    assertFalse(jsonRepresentation.contains(">"));    assertTrue(jsonRepresentation.contains("\\\""));    BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class);    assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson());  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.annotations.Expose;import junit.framework.TestCase;/** * Unit tests for the regarding functional "@Expose" type tests. * * @author Joel Leitch */public class ExposeFieldsTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();  }  public void testNullExposeFieldSerialization() throws Exception {    ClassWithExposedFields object = new ClassWithExposedFields(null, 1);    String json = gson.toJson(object);    assertEquals(object.getExpectedJson(), json);  }  public void testArrayWithOneNullExposeFieldObjectSerialization() throws Exception {    ClassWithExposedFields object1 = new ClassWithExposedFields(1, 1);    ClassWithExposedFields object2 = new ClassWithExposedFields(null, 1);    ClassWithExposedFields object3 = new ClassWithExposedFields(2, 2);    ClassWithExposedFields[] objects = { object1, object2, object3 };    String json = gson.toJson(objects);    String expected = new StringBuilder()        .append('[').append(object1.getExpectedJson()).append(',')        .append(object2.getExpectedJson()).append(',')        .append(object3.getExpectedJson()).append(']')        .toString();    assertEquals(expected, json);  }  public void testExposeAnnotationSerialization() throws Exception {    ClassWithExposedFields target = new ClassWithExposedFields(1, 2);    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testExposeAnnotationDeserialization() throws Exception {    String json = '{' + "\"a\":" + 3 + ",\"b\":" + 4 + '}';    ClassWithExposedFields target = gson.fromJson(json, ClassWithExposedFields.class);    assertEquals(3, (int) target.a);    assertNull(target.b);  }  public void testNoExposedFieldSerialization() throws Exception {    ClassWithNoExposedFields obj = new ClassWithNoExposedFields();    String json = gson.toJson(obj);    assertEquals("{}", json);  }  public void testNoExposedFieldDeserialization() throws Exception {    String json = '{' + "\"a\":" + 4 + ",\"b\":" + 5 + '}';    ClassWithNoExposedFields obj = gson.fromJson(json, ClassWithNoExposedFields.class);    assertEquals(0, obj.a);    assertEquals(1, obj.b);  }  private static class ClassWithExposedFields {    @Expose private final Integer a;    private final Integer b;    ClassWithExposedFields() {      this(null, null);    }    public ClassWithExposedFields(Integer a, Integer b) {      this.a = a;      this.b = b;    }    public String getExpectedJson() {      if (a == null) {        return "{}";      }      return '{' + "\"a\":" + a + '}';    }    public String getExpectedJsonWithoutAnnotations() {      StringBuilder stringBuilder = new StringBuilder();      boolean requiresComma = false;      stringBuilder.append('{');      if (a != null) {        stringBuilder.append("\"a\":").append(a);        requiresComma = true;      }      if (b != null) {        if (requiresComma) {          stringBuilder.append(',');        }        stringBuilder.append("\"b\":").append(b);      }      stringBuilder.append('}');      return stringBuilder.toString();    }  }  private static class  ClassWithNoExposedFields {    private final int a = 0;    private final int b = 1;  }}
package com.google.gson.functional;import com.google.gson.Gson;import junit.framework.TestCase;/** * Functional tests for Json serialization and deserialization of strings. * * @author Inderjeet Singh * @author Joel Leitch */public class StringTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }    public void testStringValueSerialization() throws Exception {    String value = "someRandomStringValue";    assertEquals('"' + value + '"', gson.toJson(value));  }  public void testStringValueDeserialization() throws Exception {    String value = "someRandomStringValue";    String actual = gson.fromJson("\"" + value + "\"", String.class);    assertEquals(value, actual);  }  public void testSingleQuoteInStringSerialization() throws Exception {    String valueWithQuotes = "beforeQuote'afterQuote";    String jsonRepresentation = gson.toJson(valueWithQuotes);    assertEquals(valueWithQuotes, gson.fromJson(jsonRepresentation, String.class));  }  public void testEscapedCtrlNInStringSerialization() throws Exception {    String value = "a\nb";    String json = gson.toJson(value);    assertEquals("\"a\\nb\"", json);  }  public void testEscapedCtrlNInStringDeserialization() throws Exception {    String json = "'a\\nb'";    String actual = gson.fromJson(json, String.class);    assertEquals("a\nb", actual);  }  public void testEscapedCtrlRInStringSerialization() throws Exception {    String value = "a\rb";    String json = gson.toJson(value);    assertEquals("\"a\\rb\"", json);  }  public void testEscapedCtrlRInStringDeserialization() throws Exception {    String json = "'a\\rb'";    String actual = gson.fromJson(json, String.class);    assertEquals("a\rb", actual);  }  public void testEscapedBackslashInStringSerialization() throws Exception {    String value = "a\\b";    String json = gson.toJson(value);    assertEquals("\"a\\\\b\"", json);  }  public void testEscapedBackslashInStringDeserialization() throws Exception {    String actual = gson.fromJson("'a\\\\b'", String.class);    assertEquals("a\\b", actual);  }  public void testSingleQuoteInStringDeserialization() throws Exception {    String value = "beforeQuote'afterQuote";    String actual = gson.fromJson("\"" + value + "\"", String.class);    assertEquals(value, actual);  }  public void testEscapingQuotesInStringSerialization() throws Exception {    String valueWithQuotes = "beforeQuote\"afterQuote";    String jsonRepresentation = gson.toJson(valueWithQuotes);    String target = gson.fromJson(jsonRepresentation, String.class);    assertEquals(valueWithQuotes, target);  }  public void testEscapingQuotesInStringDeserialization() throws Exception {    String value = "beforeQuote\\\"afterQuote";    String actual = gson.fromJson("\"" + value + "\"", String.class);    String expected = "beforeQuote\"afterQuote";    assertEquals(expected, actual);  }  public void testStringValueAsSingleElementArraySerialization() throws Exception {    String[] target = {"abc"};    assertEquals("[\"abc\"]", gson.toJson(target));    assertEquals("[\"abc\"]", gson.toJson(target, String[].class));  }  public void testStringValueAsSingleElementArrayDeserialization() throws Exception {    String value = "someRandomStringValue";    String actual = gson.fromJson("[\"" + value + "\"]", String.class);    assertEquals(value, actual);  }    public void testStringWithEscapedSlashDeserialization() {    String value = "/";    String json = "'\\/'";    String actual = gson.fromJson(json, String.class);    assertEquals(value, actual);  }}
package com.google.gson.metrics;import com.google.gson.Gson;import com.google.gson.JsonParseException;import junit.framework.TestCase;/** * Tests to measure performance for Gson. All tests in this file will be disabled in code. To run * them remove disabled_ prefix from the tests and run them. *  * @author Inderjeet Singh * @author Joel Leitch */public class PerformanceTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }    public void testDummy() {        // This is here to prevent Junit for complaining when we disable all tests.  }  public void disabled_testStringDeserializationPerformance() {        StringBuilder sb = new StringBuilder(8096);    sb.append("Error Yippie");    while (true) {      try {        String stackTrace = sb.toString();        sb.append(stackTrace);        String json = "{\"message\":\"Error message.\"," + "\"stackTrace\":\"" + stackTrace + "\"}";        parseLongJson(json);        System.out.println("Gson could handle a string of size: " + stackTrace.length());      } catch (JsonParseException expected) {        break;      }    }  }    private void parseLongJson(String json) throws JsonParseException {    ExceptionHolder target = gson.fromJson(json, ExceptionHolder.class);    assertTrue(target.message.contains("Error"));    assertTrue(target.stackTrace.contains("Yippie"));  }  private static class ExceptionHolder {    public final String message;    public final String stackTrace;    public ExceptionHolder() {      this("", "");    }    public ExceptionHolder(String message, String stackTrace) {      this.message = message;      this.stackTrace = stackTrace;    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.common;import java.lang.reflect.Type;import com.google.gson.JsonDeserializationContext;import com.google.gson.JsonDeserializer;import com.google.gson.JsonElement;import com.google.gson.JsonParseException;import com.google.gson.JsonPrimitive;import com.google.gson.JsonSerializationContext;import com.google.gson.JsonSerializer;import com.google.gson.annotations.SerializedName;/** * Types used for testing JSON serialization and deserialization * * @author Inderjeet Singh * @author Joel Leitch */public class TestTypes {  public static class StringWrapper {    public final String someConstantStringInstanceField;    StringWrapper() {      this("Blah");    }    public StringWrapper(String value) {      someConstantStringInstanceField = value;    }  }  public static class BagOfPrimitives {    public static final long DEFAULT_VALUE = 0;    public long longValue;    public int intValue;    public boolean booleanValue;    public String stringValue;    public BagOfPrimitives() {      this(DEFAULT_VALUE, 0, false, "");    }    public BagOfPrimitives(long longValue, int intValue, boolean booleanValue, String stringValue) {      this.longValue = longValue;      this.intValue = intValue;      this.booleanValue = booleanValue;      this.stringValue = stringValue;    }    public int getIntValue() {      return intValue;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{");      sb.append("\"longValue\":").append(longValue).append(",");      sb.append("\"intValue\":").append(intValue).append(",");      sb.append("\"booleanValue\":").append(booleanValue).append(",");      sb.append("\"stringValue\":\"").append(stringValue).append("\"");      sb.append("}");      return sb.toString();    }    @Override    public int hashCode() {      final int prime = 31;      int result = 1;      result = prime * result + (booleanValue ? 1231 : 1237);      result = prime * result + intValue;      result = prime * result + (int) (longValue ^ (longValue >>> 32));      result = prime * result + ((stringValue == null) ? 0 : stringValue.hashCode());      return result;    }    @Override    public boolean equals(Object obj) {      if (this == obj)        return true;      if (obj == null)        return false;      if (getClass() != obj.getClass())        return false;      BagOfPrimitives other = (BagOfPrimitives) obj;      if (booleanValue != other.booleanValue)        return false;      if (intValue != other.intValue)        return false;      if (longValue != other.longValue)        return false;      if (stringValue == null) {        if (other.stringValue != null)          return false;      } else if (!stringValue.equals(other.stringValue))        return false;      return true;    }    @Override    public String toString() {      return String.format("(longValue=%d,intValue=%d,booleanValue=%b,stringValue=%s)",          longValue, intValue, booleanValue, stringValue);    }  }  public static class BagOfPrimitiveWrappers {    private final Long longValue;    private final Integer intValue;    private final Boolean booleanValue;    public BagOfPrimitiveWrappers() {      this(0L, 0, false);    }    public BagOfPrimitiveWrappers(Long longValue, Integer intValue, Boolean booleanValue) {      this.longValue = longValue;      this.intValue = intValue;      this.booleanValue = booleanValue;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{");      sb.append("\"longValue\":").append(longValue).append(",");      sb.append("\"intValue\":").append(intValue).append(",");      sb.append("\"booleanValue\":").append(booleanValue);      sb.append("}");      return sb.toString();    }  }  public static class PrimitiveArray {    private final long[] longArray;    public PrimitiveArray() {      this(new long[0]);    }    public PrimitiveArray(long[] longArray) {      this.longArray = longArray;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{\"longArray\":[");      boolean first = true;      for (long l : longArray) {        if (!first) {          sb.append(",");        } else {          first = false;        }        sb.append(l);      }      sb.append("]}");      return sb.toString();    }  }  public static class ClassWithNoFields {    // Nothing here.. .    @Override    public boolean equals(Object other) {      return other.getClass() == ClassWithNoFields.class;    }  }  public static class Nested {    private final BagOfPrimitives primitive1;    private final BagOfPrimitives primitive2;    public Nested() {      this(null, null);    }    public Nested(BagOfPrimitives primitive1, BagOfPrimitives primitive2) {      this.primitive1 = primitive1;      this.primitive2 = primitive2;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{");      appendFields(sb);      sb.append("}");      return sb.toString();    }    public void appendFields(StringBuilder sb) {      if (primitive1 != null) {        sb.append("\"primitive1\":").append(primitive1.getExpectedJson());      }      if (primitive1 != null && primitive2 != null) {        sb.append(",");      }      if (primitive2 != null) {        sb.append("\"primitive2\":").append(primitive2.getExpectedJson());      }    }  }  public static class ClassWithTransientFields {    public final transient long transientLongValue;    private final long[] longValue;    public ClassWithTransientFields() {      this(0L);    }    public ClassWithTransientFields(long value) {      longValue = new long[] { value };      transientLongValue = value + 1;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{");      sb.append("\"longValue\":[").append(longValue[0]).append("]");      sb.append("}");      return sb.toString();    }  }  public static class ClassWithCustomTypeConverter {    private final BagOfPrimitives bag;    private final int value;    public ClassWithCustomTypeConverter() {      this(new BagOfPrimitives(), 10);    }    public ClassWithCustomTypeConverter(int value) {      this(new BagOfPrimitives(value, value, false, ""), value);    }    public ClassWithCustomTypeConverter(BagOfPrimitives bag, int value) {      this.bag = bag;      this.value = value;    }    public BagOfPrimitives getBag() {      return bag;    }    public String getExpectedJson() {      return "{\"url\":\"" + bag.getExpectedJson() + "\",\"value\":" + value + "}";    }    public int getValue() {      return value;    }  }  public static class ArrayOfObjects {    private final BagOfPrimitives[] elements;    public ArrayOfObjects() {      elements = new BagOfPrimitives[3];      for (int i = 0; i < elements.length; ++i) {        elements[i] = new BagOfPrimitives(i, i+2, false, "i"+i);      }    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder("{\"elements\":[");      boolean first = true;      for (BagOfPrimitives element : elements) {        if (first) {          first = false;        } else {          sb.append(",");        }        sb.append(element.getExpectedJson());      }      sb.append("]}");      return sb.toString();    }  }  public static enum MyEnum {    VALUE1, VALUE2;    public String getExpectedJson() {      return "\"" + toString() + "\"";    }  }  public static class ClassOverridingEquals {    public ClassOverridingEquals ref;    public String getExpectedJson() {      if (ref == null) {        return "{}";      }      return "{\"ref\":" + ref.getExpectedJson() + "}";    }    @Override    public boolean equals(Object obj) {      return true;    }    @Override    public int hashCode() {      return 1;    }  }  public static class ClassWithArray {    public final Object[] array;    public ClassWithArray() {      array = null;    }    public ClassWithArray(Object[] array) {      this.array = array;    }  }  public static class ClassWithObjects {    public final BagOfPrimitives bag;    public ClassWithObjects() {      this(new BagOfPrimitives());    }    public ClassWithObjects(BagOfPrimitives bag) {      this.bag = bag;    }  }  public static class ClassWithSerializedNameFields {    @SerializedName("fooBar") public final int f;    public ClassWithSerializedNameFields() {      this(1);    }    public ClassWithSerializedNameFields(int f) {      this.f = f;    }    public String getExpectedJson() {      return '{' + "\"fooBar\":" + f + '}';    }  }    public static class CrazyLongTypeAdapter      implements JsonSerializer<Long>, JsonDeserializer<Long> {    public static final long DIFFERENCE = 5L;    public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context) {      return new JsonPrimitive(src + DIFFERENCE);    }        public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)        throws JsonParseException {      return json.getAsLong() - DIFFERENCE;    }}}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;/** * Performs some unit testing for the {@link JsonEscapingVisitor} class. * * @author Joel Leitch */public class JsonEscapingVisitorTest extends TestCase {  private StubbedJsonElementVisitor stubVisitor;  private JsonEscapingVisitor escapingVisitor;  @Override  protected void setUp() throws Exception {    super.setUp();    stubVisitor = new StubbedJsonElementVisitor();    escapingVisitor = new JsonEscapingVisitor(stubVisitor);  }  public void testNonStringPrimitiveVisitation() throws Exception {    boolean value = true;    JsonPrimitive primitive = new JsonPrimitive(value);    escapingVisitor.visitPrimitive(primitive);    assertEquals(value, stubVisitor.primitiveReceived.getAsBoolean());  }  public void testStringPrimitiveVisitationNoEscapingRequired() throws Exception {    String value = "Testing123";    JsonPrimitive primitive = new JsonPrimitive(value);    escapingVisitor.visitPrimitive(primitive);    assertEquals(value, stubVisitor.primitiveReceived.getAsObject());  }  public void testStringPrimitiveVisitationEscapingRequired() throws Exception {    String value = "Testing\"123";    JsonPrimitive primitive = new JsonPrimitive(value);    escapingVisitor.visitPrimitive(primitive);    assertEquals(Escaper.escapeJsonString(value), stubVisitor.primitiveReceived.getAsString());  }  public void testNonStringArrayVisitation() throws Exception {    int value = 123;    JsonPrimitive primitive = new JsonPrimitive(value);    JsonArray array = new JsonArray();    array.add(primitive);    escapingVisitor.visitArrayMember(array, primitive, true);    assertEquals(value, stubVisitor.primitiveReceived.getAsInt());  }  public void testStringArrayVisitationNoEscaping() throws Exception {    String value = "Testing123";    JsonPrimitive primitive = new JsonPrimitive(value);    JsonArray array = new JsonArray();    array.add(primitive);    escapingVisitor.visitArrayMember(array, primitive, true);    assertEquals(value, stubVisitor.primitiveReceived.getAsString());  }  public void testStringArrayVisitationEscapingRequired() throws Exception {    String value = "Testing\"123";    JsonPrimitive primitive = new JsonPrimitive(value);    JsonArray array = new JsonArray();    array.add(primitive);    escapingVisitor.visitArrayMember(array, primitive, true);    assertEquals(Escaper.escapeJsonString(value), stubVisitor.primitiveReceived.getAsString());  }  public void testNonStringFieldVisitation() throws Exception {    String fieldName = "fieldName";    int value = 123;    JsonPrimitive primitive = new JsonPrimitive(value);    JsonObject object = new JsonObject();    object.addProperty(fieldName, value);    escapingVisitor.visitObjectMember(object, fieldName, primitive, true);    assertEquals(value, stubVisitor.primitiveReceived.getAsInt());  }  public void testStringFieldVisitationNoEscaping() throws Exception {    String fieldName = "fieldName";    String value = "Testing123";    JsonPrimitive primitive = new JsonPrimitive(value);    JsonObject object = new JsonObject();    object.addProperty(fieldName, value);    escapingVisitor.visitObjectMember(object, fieldName, primitive, true);    assertEquals(value, stubVisitor.primitiveReceived.getAsString());  }  public void testStringFieldVisitationEscapingRequired() throws Exception {    String fieldName = "fieldName";    String value = "Testing\"123";    JsonPrimitive primitive = new JsonPrimitive(value);    JsonObject object = new JsonObject();    object.addProperty(fieldName, value);    escapingVisitor.visitObjectMember(object, fieldName, primitive, true);    assertEquals(Escaper.escapeJsonString(value), stubVisitor.primitiveReceived.getAsString());  }  private static class StubbedJsonElementVisitor implements JsonElementVisitor {    public JsonPrimitive primitiveReceived;    public void endArray(JsonArray array) {      // Do nothing    }    public void endObject(JsonObject object) {      // Do nothing    }    public void startArray(JsonArray array) {      // Do nothing    }    public void startObject(JsonObject object) {      // Do nothing    }    public void visitArrayMember(JsonArray parent, JsonPrimitive member, boolean isFirst) {      primitiveReceived = member;    }    public void visitArrayMember(JsonArray parent, JsonArray member, boolean isFirst) {      // Do nothing    }    public void visitArrayMember(JsonArray parent, JsonObject member, boolean isFirst) {      // Do nothing    }    public void visitObjectMember(        JsonObject parent, String memberName, JsonPrimitive member, boolean isFirst) {      primitiveReceived = member;    }    public void visitObjectMember(        JsonObject parent, String memberName, JsonArray member, boolean isFirst) {      // Do nothing    }    public void visitObjectMember(        JsonObject parent, String memberName, JsonObject member, boolean isFirst) {      // Do nothing    }    public void visitPrimitive(JsonPrimitive primitive) {      primitiveReceived = primitive;    }    public void visitNullArrayMember(JsonArray parent, boolean isFirst) {      // Do nothing    }    public void visitNull() {      // Do nothing          }    public void visitNullObjectMember(JsonObject parent, String memberName, boolean isFirst) {      // Do nothing          }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.List;/** * Unit tests for the {@link ParameterizedTypeHandlerMap} class. * * @author Joel Leitch */public class ParameterizedTypeHandlerMapTest extends TestCase {  private ParameterizedTypeHandlerMap<String> paramMap;  @Override  protected void setUp() throws Exception {    super.setUp();    paramMap = new ParameterizedTypeHandlerMap<String>();  }  public void testNullMap() throws Exception {    assertFalse(paramMap.hasSpecificHandlerFor(String.class));    assertFalse(paramMap.hasAnyHandlerFor(String.class));    assertNull(paramMap.getHandlerFor(String.class));  }  public void testHasGenericButNotSpecific() throws Exception {    Type specificType = new TypeToken<List<String>>() {}.getType();    String handler = "blah";    paramMap.register(List.class, handler);    assertFalse(paramMap.hasSpecificHandlerFor(specificType));    assertTrue(paramMap.hasSpecificHandlerFor(List.class));    assertTrue(paramMap.hasAnyHandlerFor(specificType));    assertTrue(paramMap.hasAnyHandlerFor(List.class));    assertEquals(handler, paramMap.getHandlerFor(specificType));  }  public void testHasSpecificType() throws Exception {    Type specificType = new TypeToken<List<String>>() {}.getType();    String handler = "blah";    paramMap.register(specificType, handler);    assertTrue(paramMap.hasSpecificHandlerFor(specificType));    assertFalse(paramMap.hasSpecificHandlerFor(List.class));    assertTrue(paramMap.hasAnyHandlerFor(specificType));    assertFalse(paramMap.hasAnyHandlerFor(List.class));    assertEquals(handler, paramMap.getHandlerFor(specificType));  }  public void testTypeOverridding() throws Exception {    String handler1 = "blah1";    String handler2 = "blah2";    paramMap.register(String.class, handler1);    paramMap.register(String.class, handler2);    assertTrue(paramMap.hasSpecificHandlerFor(String.class));    assertEquals(handler2, paramMap.getHandlerFor(String.class));  }  public void testMakeUnmodifiable() throws Exception {    paramMap.makeUnmodifiable();    try {     paramMap.register(String.class, "blah");     fail("Can not register handlers when map is unmodifiable");    } catch (IllegalStateException expected) { }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;import junit.framework.TestCase;import java.lang.reflect.Type;import java.text.DateFormat;import java.util.Date;/** * Simple unit tests for the {@link JsonDeserializerExceptionWrapper} class. * * @author Inderjeet Singh * @author Joel Leitch */public class JsonDeserializerExceptionWrapperTest extends TestCase {  private static final String DATE_STRING =      DateFormat.getDateInstance(DateFormat.LONG).format(new Date());  private static final JsonPrimitive PRIMITIVE_ELEMENT = new JsonPrimitive(DATE_STRING);  public void testRethrowJsonParseException() throws Exception {    String errorMsg = "please rethrow me";    JsonDeserializerExceptionWrapper<String> wrappedJsonSerializer =        new JsonDeserializerExceptionWrapper<String>(            new ExceptionJsonDeserializer(new JsonParseException(errorMsg)));    try {      wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, String.class, null);      fail("JsonParseException should have been thrown");    } catch (JsonParseException expected) {      assertNull(expected.getCause());      assertEquals(errorMsg, expected.getMessage());    }  }  public void testWrappedExceptionPropagation() throws Exception {    IllegalArgumentException exceptionToThrow = new IllegalArgumentException();    JsonDeserializerExceptionWrapper<String> wrappedJsonSerializer =        new JsonDeserializerExceptionWrapper<String>(            new ExceptionJsonDeserializer(exceptionToThrow));    try {      wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, String.class, null);      fail("JsonParseException should have been thrown");    } catch (JsonParseException expected) {      assertEquals(exceptionToThrow, expected.getCause());    }  }  public void testProperSerialization() throws Exception {    DefaultDateTypeAdapter dateSerializer = new DefaultDateTypeAdapter(DateFormat.LONG);    JsonDeserializerExceptionWrapper<Date> wrappedJsonSerializer =        new JsonDeserializerExceptionWrapper<Date>(dateSerializer);    Date expected = dateSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null);    Date actual = wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null);    assertEquals(expected, actual);  }  private static class ExceptionJsonDeserializer implements JsonDeserializer<String> {    private final RuntimeException exceptionToThrow;    public ExceptionJsonDeserializer(RuntimeException exceptionToThrow) {      this.exceptionToThrow = exceptionToThrow;    }    public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)        throws JsonParseException {      throw exceptionToThrow;    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;/** * Performs some unit testing for the {@link Escaper} class. * * @author Joel Leitch */public class EscaperTest extends TestCase {  public void testNoSpecialCharacters() {    String value = "Testing123";    String escapedString = Escaper.escapeJsonString(value);    assertEquals(value, escapedString);  }  public void testNewlineEscaping() throws Exception {    String containsNewline = "123\n456";    String escapedString = Escaper.escapeJsonString(containsNewline);    assertEquals("123\\n456", escapedString);  }  public void testCarrageReturnEscaping() throws Exception {    String containsCarrageReturn = "123\r456";    String escapedString = Escaper.escapeJsonString(containsCarrageReturn);    assertEquals("123\\r456", escapedString);  }  public void testTabEscaping() throws Exception {    String containsTab = "123\t456";    String escapedString = Escaper.escapeJsonString(containsTab);    assertEquals("123\\t456", escapedString);  }  public void testQuoteEscaping() throws Exception {    String containsQuote = "123\"456";    String escapedString = Escaper.escapeJsonString(containsQuote);    assertEquals("123\\\"456", escapedString);  }  public void testEqualsEscaping() throws Exception {    String containsEquals = "123=456";    int index = containsEquals.indexOf('=');    String unicodeValue = convertToUnicodeString(Character.codePointAt(containsEquals, index));    String escapedString = Escaper.escapeJsonString(containsEquals);    assertEquals("123" + unicodeValue + "456", escapedString);  }  public void testGreaterThanAndLessThanEscaping() throws Exception {    String containsLtGt = "123>456<";    int gtIndex = containsLtGt.indexOf('>');    int ltIndex = containsLtGt.indexOf('<');    String gtAsUnicode = convertToUnicodeString(Character.codePointAt(containsLtGt, gtIndex));    String ltAsUnicode = convertToUnicodeString(Character.codePointAt(containsLtGt, ltIndex));    String escapedString = Escaper.escapeJsonString(containsLtGt);    assertEquals("123" + gtAsUnicode + "456" + ltAsUnicode, escapedString);  }  public void testAmpersandEscaping() throws Exception {    String containsAmp = "123&456";    int ampIndex = containsAmp.indexOf('&');    String ampAsUnicode = convertToUnicodeString(Character.codePointAt(containsAmp, ampIndex));    String escapedString = Escaper.escapeJsonString(containsAmp);    assertEquals("123" + ampAsUnicode + "456", escapedString);    char ampCharAsUnicode = '\u0026';    String containsAmpUnicode = "123" + ampCharAsUnicode + "456";    escapedString = Escaper.escapeJsonString(containsAmpUnicode);    assertEquals("123" + ampAsUnicode + "456", escapedString);  }  public void testSlashEscaping() throws Exception {    String containsSlash = "123\\456";    String escapedString = Escaper.escapeJsonString(containsSlash);    assertEquals("123\\\\456", escapedString);  }  public void testSingleQuoteNotEscaped() throws Exception {    String containsSingleQuote = "123'456";    String escapedString = Escaper.escapeJsonString(containsSingleQuote);    assertEquals(containsSingleQuote, escapedString);  }  public void testRequiredEscapingUnicodeCharacter() throws Exception {    char unicodeChar = '\u2028';    String unicodeString = "Testing" + unicodeChar;    String escapedString = Escaper.escapeJsonString(unicodeString);    assertFalse(unicodeString.equals(escapedString));    assertEquals("Testing\\u2028", escapedString);  }  public void testUnicodeCharacterStringNoEscaping() throws Exception {    String unicodeString = "\u0065\u0066";    String escapedString = Escaper.escapeJsonString(unicodeString);    assertEquals(unicodeString, escapedString);  }  /*  public void testChineseCharacterEscaping() throws Exception {    String unicodeString = "\u597d\u597d\u597d";    String chineseString = "好好好";    assertEquals(unicodeString, chineseString);    String expectedEscapedString = "\\u597d\\u597d\\u597d";    String escapedString = Escaper.escapeJsonString(chineseString);    assertEquals(expectedEscapedString, escapedString);  }   */  private String convertToUnicodeString(int codepoint) {    String hexValue = Integer.toHexString(codepoint);    StringBuilder sb = new StringBuilder("\\u");    for (int i = 0; i < 4 - hexValue.length(); i++) {      sb.append(0);    }    sb.append(hexValue);    return sb.toString().toLowerCase();  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.List;/** * Unit tests for the {@link ParameterizedTypeImpl} class. * * @author Inderjeet Singh * @author Joel Leitch */public class ParameterizedTypeImplTest extends TestCase {  private Type parameterizedType;  private ParameterizedTypeImpl ourType;  @Override  protected void setUp() throws Exception {    super.setUp();    parameterizedType = new TypeToken<List<String>>() {}.getType();    ourType = new ParameterizedTypeImpl(List.class, new Type[] { String.class }, null);  }  public void testOurTypeFunctionality() throws Exception {    assertNull(ourType.getOwnerType());    assertEquals(String.class, ourType.getActualTypeArguments()[0]);    assertEquals(List.class, ourType.getRawType());    assertEquals(parameterizedType, ourType);    assertEquals(parameterizedType.hashCode(), ourType.hashCode());  }  public void testNotEquals() throws Exception {    Type differentParameterizedType = new TypeToken<List<Integer>>() {}.getType();    assertFalse(differentParameterizedType.equals(ourType));    assertFalse(ourType.equals(differentParameterizedType));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.HashMap;import java.util.Map;/** * Unit test for the default JSON map serialization object located in the * {@link DefaultTypeAdapters} class. * * @author Joel Leitch */public class DefaultMapJsonSerializerTest extends TestCase {  @SuppressWarnings("unchecked")  private JsonSerializer<Map> mapSerializer;  @Override  protected void setUp() throws Exception {    super.setUp();    mapSerializer = new DefaultTypeAdapters.MapTypeAdapter();  }  public void testEmptyMapNoTypeSerialization() {    Map<String, String> emptyMap = new HashMap<String, String>();    JsonElement element = mapSerializer.serialize(emptyMap, emptyMap.getClass(), null);    assertTrue(element instanceof JsonObject);    JsonObject emptyMapJsonObject = (JsonObject) element;    assertTrue(emptyMapJsonObject.entrySet().isEmpty());  }  public void testEmptyMapSerialization() {    Type mapType = new TypeToken<Map<String, String>>() { }.getType();    Map<String, String> emptyMap = new HashMap<String, String>();    JsonElement element = mapSerializer.serialize(emptyMap, mapType, null);    assertTrue(element instanceof JsonObject);    JsonObject emptyMapJsonObject = (JsonObject) element;    assertTrue(emptyMapJsonObject.entrySet().isEmpty());  }}
package com.google.gson;import junit.framework.TestCase;/** * Unit tests for {@link StringUnmarshaller}.  *  * @author Inderjeet Singh */public class StringUnmarshallerTest extends TestCase {  public void testCtrlN() {    assertEquals("a\nb", StringUnmarshaller.unmarshall("'a\\nb'"));  }  public void testCtrlR() {    assertEquals("a\rb", StringUnmarshaller.unmarshall("'a\\rb'"));  }    public void testCtrlT() {    assertEquals("\tb", StringUnmarshaller.unmarshall("'\\tb'"));  }    public void testBackSpace() {    assertEquals("\b foo", StringUnmarshaller.unmarshall("'\\b foo'"));  }    public void testFormFeed() {    assertEquals("\f bar", StringUnmarshaller.unmarshall("'\\f bar'"));  }    public void testSingleQuote() {    assertEquals("a'b", StringUnmarshaller.unmarshall("'a'b'"));  }    public void testSingleQuoteEscaped() {    assertEquals("a'b", StringUnmarshaller.unmarshall("'a\\'b'"));  }    public void testDoubleQuote() {    assertEquals("a\"b", StringUnmarshaller.unmarshall("'a\"b'"));  }    public void testDoubleQuoteEscaped() {    assertEquals("a\"b", StringUnmarshaller.unmarshall("'a\\\"b'"));  }    public void testBackslash() {    assertEquals("a\\b", StringUnmarshaller.unmarshall("'a\\\\b'"));  }      public void testUnicodeString() {    assertEquals("\u03a9b", StringUnmarshaller.unmarshall("'\\u03a9b'"));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;/** * Tests for the {@link LowerCamelCaseSeparatorNamingPolicy} class. * * @author Joel Leitch */public class LowerCamelCaseSeparatorNamingPolicyTest extends TestCase {  private static final Class<String> CLASS = String.class;  private static final String UNDERSCORE = "_";  private LowerCamelCaseSeparatorNamingPolicy namingPolicy;  @Override  protected void setUp() throws Exception {    super.setUp();    namingPolicy = new LowerCamelCaseSeparatorNamingPolicy(UNDERSCORE);  }  public void testNameBeginsWithLowerCase() throws Exception {    String translatedName = namingPolicy.translateName("testNameBeginsWithLower", CLASS, null);    assertEquals("test_name_begins_with_lower", translatedName);  }  public void testNameBeginsWithUpperCase() throws Exception {    String translatedName = namingPolicy.translateName("TestNameBeginsWithUpper", CLASS, null);    assertEquals("test_name_begins_with_upper", translatedName);  }  public void testExceptionPossiblyIncorrectSeparation() throws Exception {    String translatedName = namingPolicy.translateName("aURL", CLASS, null);    assertEquals("a_u_r_l", translatedName);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;/** * Tests for the {@link CamelCaseSeparatorNamingPolicy} class. * * @author Joel Leitch */public class CamelCaseSeparatorNamingPolicyTest extends TestCase {  private static final Class<String> CLASS = String.class;  private static final String UNDERSCORE = "_";  private static final String MULTI_CHAR_SEPARATOR = "_$_";  public void testInvalidInstantiation() throws Exception {    try {      new CamelCaseSeparatorNamingPolicy(null);      fail("Null separator string is not supported");    } catch (IllegalArgumentException expected) { }    try {      new CamelCaseSeparatorNamingPolicy("");      fail("Empty separator string is not supported");    } catch (IllegalArgumentException expected) { }    try {      new CamelCaseSeparatorNamingPolicy(" ");      fail("space separator string is not supported");    } catch (IllegalArgumentException expected) { }    try {      new CamelCaseSeparatorNamingPolicy("\n");      fail("new-line separator string is not supported");    } catch (IllegalArgumentException expected) { }  }  public void testUnderscoreSeparator() throws Exception {    CamelCaseSeparatorNamingPolicy namingPolicy =        new CamelCaseSeparatorNamingPolicy(UNDERSCORE);    String translatedName = namingPolicy.translateName("testUnderscoreBetweenWords", CLASS, null);    assertEquals("test_Underscore_Between_Words", translatedName);  }  public void testMultiCharSeparator() throws Exception {    CamelCaseSeparatorNamingPolicy namingPolicy =        new CamelCaseSeparatorNamingPolicy(MULTI_CHAR_SEPARATOR);    String translatedName = namingPolicy.translateName("testMultCharBetweenWords", CLASS, null);    assertEquals("test_$_Mult_$_Char_$_Between_$_Words", translatedName);  }  public void testNameBeginsWithCapital() throws Exception {    CamelCaseSeparatorNamingPolicy namingPolicy = new CamelCaseSeparatorNamingPolicy(UNDERSCORE);    String translatedName = namingPolicy.translateName("TestNameBeginsWithCapital", CLASS, null);    assertEquals("Test_Name_Begins_With_Capital", translatedName);  }  public void testExceptionPossiblyIncorrectSeparation() throws Exception {    CamelCaseSeparatorNamingPolicy namingPolicy = new CamelCaseSeparatorNamingPolicy(UNDERSCORE);    String translatedName = namingPolicy.translateName("aURL", CLASS, null);    assertEquals("a_U_R_L", translatedName);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.annotations.Expose;import junit.framework.TestCase;import java.lang.reflect.Field;/** * Unit tests for the {@link ExposeAnnotationBasedExclusionStrategy} class. * * @author Joel Leitch */public class ExposeAnnotationBasedExclusionStrategyTest extends TestCase {  private ExposeAnnotationBasedExclusionStrategy strategy;  @Override  protected void setUp() throws Exception {    super.setUp();    strategy = new ExposeAnnotationBasedExclusionStrategy();  }  public void testNeverSkipClasses() throws Exception {    assertFalse(strategy.shouldSkipClass(MockObject.class));  }    public void testSkipNonAnnotatedFields() throws Exception {    Field f = MockObject.class.getField("hiddenField");    assertTrue(strategy.shouldSkipField(f));  }    public void testNeverSkipExposedAnnotatedFields() throws Exception {    Field f = MockObject.class.getField("exposedField");    assertFalse(strategy.shouldSkipField(f));  }  private static class MockObject {    @Expose    public final int exposedField = 0;    public final int hiddenField = 0;  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.List;/** * Small test for the {@link TypeInfoArray}. * * @author Inderjeet Singh * @author Joel Leitch */public class TypeInfoArrayTest extends TestCase {  public void testArray() {    String[] a = {"a", "b", "c"};    TypeInfoArray typeInfo = new TypeInfoArray(a.getClass());    assertEquals(a.getClass(), typeInfo.getRawClass());    assertEquals(String.class, typeInfo.getComponentRawType());  }  public void testArrayOfArrays() {    String[][] a = {        new String[]{"a1", "a2", "a3"},        new String[]{"b1", "b2", "b3"},        new String[]{"c1", "c2", "c3"}};    TypeInfoArray typeInfo = new TypeInfoArray(a.getClass());    assertEquals(a.getClass(), typeInfo.getRawClass());    assertEquals(String.class, typeInfo.getComponentRawType());    assertEquals(String[].class, typeInfo.getSecondLevelType());  }  public void testParameterizedArray() {    Type type = new TypeToken<List<String>[]>() {}.getType();    TypeInfoArray typeInfo = new TypeInfoArray(type);    assertEquals(List[].class, typeInfo.getRawClass());    assertEquals(List.class, typeInfo.getComponentRawType());  }  public void testParameterizedArrayOfArrays() {    Type type = new TypeToken<List<String>[][]>() {}.getType();    Type secondLevelType = new TypeToken<List<String>[]>() {}.getType();    TypeInfoArray typeInfo = new TypeInfoArray(type);    assertEquals(List[][].class, typeInfo.getRawClass());    assertEquals(secondLevelType, typeInfo.getSecondLevelType());    assertEquals(List.class, typeInfo.getComponentRawType());  }  public void testNestedParameterizedArray() {    Type type = new TypeToken<List<List<String>>[]>() {}.getType();    Type secondLevelType = new TypeToken<List<List<String>>>() {}.getType();    TypeInfoArray typeInfo = new TypeInfoArray(type);    assertEquals(List[].class, typeInfo.getRawClass());    assertEquals(secondLevelType, typeInfo.getSecondLevelType());    assertEquals(List.class, typeInfo.getComponentRawType());  }  public void testPrimitiveArray() throws Exception {    TypeInfoArray arrayTypeInfo = new TypeInfoArray(int[].class);    assertTrue(arrayTypeInfo.isArray());    assertFalse(arrayTypeInfo.isPrimitive());    assertEquals(int.class, arrayTypeInfo.getSecondLevelType());  }  public void testStringArray() throws Exception {    TypeInfoArray arrayTypeInfo = new TypeInfoArray(String[].class);    assertTrue(arrayTypeInfo.isArray());    assertEquals(String.class, arrayTypeInfo.getSecondLevelType());    assertEquals(String[].class, arrayTypeInfo.getRawClass());  }  public void testPrimitiveArrayType() throws Exception {    TypeInfoArray typeInfo = new TypeInfoArray(long[].class);    assertTrue(typeInfo.isArray());    assertEquals(long.class, typeInfo.getSecondLevelType());    assertEquals(long[].class, typeInfo.getRawClass());  }  public void testStringArrayType() throws Exception {    TypeInfoArray typeInfo = new TypeInfoArray(String[].class);    assertTrue(typeInfo.isArray());    assertEquals(String[].class, typeInfo.getRawClass());    assertEquals(String.class, typeInfo.getSecondLevelType());  }  public void testArrayAsParameterizedTypes() throws Exception {    Type type = new TypeToken<List<String>[]>() {}.getType();    Type secondLevelType = new TypeToken<List<String>>() {}.getType();    TypeInfoArray typeInfo = new TypeInfoArray(type);    assertTrue(typeInfo.isArray());    assertEquals(List[].class, typeInfo.getRawClass());    assertEquals(secondLevelType, typeInfo.getSecondLevelType());    Type actualType = typeInfo.getActualType();    assertEquals(type, actualType);    Type actualTypeForFirstTypeVariable = TypeUtils.getActualTypeForFirstTypeVariable(actualType);    assertEquals(String.class, actualTypeForFirstTypeVariable);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.annotations.SerializedName;import junit.framework.TestCase;import java.lang.reflect.Field;/** * Unit tests for the {@link SerializedNameAnnotationInterceptingNamingPolicy} class. * * @author Joel Leitch */public class SerializedNameAnnotationInterceptingNamingPolicyTest extends TestCase {  private static final String ANNOTATED_FIELD_NAME = "annotatedFieldName";  private SerializedNameAnnotationInterceptingNamingPolicy policy;  @Override  protected void setUp() throws Exception {    super.setUp();    policy = new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy());  }  public void testFieldWithAnnotation() throws Exception {    String fieldName = "fieldWithAnnotation";    Field f = SomeObject.class.getField(fieldName);    assertFalse(ANNOTATED_FIELD_NAME.equals(fieldName));    assertEquals(ANNOTATED_FIELD_NAME, policy.translateName(f));  }  public void testFieldWithoutAnnotation() throws Exception {    String fieldName = "fieldWithoutAnnotation";    Field f = SomeObject.class.getField(fieldName);    assertEquals(fieldName, policy.translateName(f));  }  private static class SomeObject {    @SerializedName(ANNOTATED_FIELD_NAME) public final int fieldWithAnnotation = 1;    public final int fieldWithoutAnnotation = 1;  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.List;/** * Exercising the construction of the Parameter object and ensure the * proper types are returned. * * @author Joel Leitch */public class TypeInfoTest extends TestCase {  public void testPrimitive() throws Exception {    TypeInfo typeInfo = new TypeInfo(boolean.class);    assertFalse(typeInfo.isArray());    assertTrue(typeInfo.isPrimitive());    assertEquals(boolean.class, typeInfo.getRawClass());    assertEquals(Boolean.class, typeInfo.getWrappedClass());  }  public void testPrimitiveWrapper() throws Exception {    TypeInfo typeInfo = new TypeInfo(Integer.class);    assertEquals(Integer.class, typeInfo.getRawClass());    assertTrue(typeInfo.isPrimitive());    assertFalse(typeInfo.isArray());  }  public void testString() throws Exception {    TypeInfo typeInfo = new TypeInfo(String.class);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isPrimitive());    assertEquals(String.class, typeInfo.getRawClass());  }  public void testObject() throws Exception {    TypeInfo typeInfo = new TypeInfo(Object.class);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isPrimitive());    assertEquals(Object.class, typeInfo.getRawClass());  }  public void testPrimitiveType() throws Exception {    TypeInfo typeInfo = new TypeInfo(long.class);    assertFalse(typeInfo.isArray());    assertEquals(long.class, typeInfo.getRawClass());  }  public void testObjectType() throws Exception {    TypeInfo typeInfo = new TypeInfo(String.class);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isPrimitive());    assertEquals(String.class, typeInfo.getRawClass());  }  public void testParameterizedTypes() throws Exception {    Type type = new TypeToken<List<String>>() {}.getType();    TypeInfo typeInfo = new TypeInfo(type);    assertFalse(typeInfo.isArray());    assertEquals(List.class, typeInfo.getRawClass());    assertEquals(type, typeInfo.getActualType());  }  public void testGenericizedGenericType() throws Exception {    Type type = new TypeToken<List<List<String>>>() {}.getType();    Type genericType = new TypeToken<List<String>>() {}.getType();    TypeInfo typeInfo = new TypeInfo(type);    assertFalse(typeInfo.isArray());    assertEquals(List.class, typeInfo.getRawClass());    Type actualTypeForFirstTypeVariable = TypeUtils.getActualTypeForFirstTypeVariable(type);    assertEquals(genericType, actualTypeForFirstTypeVariable);    typeInfo = new TypeInfo(genericType);    actualTypeForFirstTypeVariable = TypeUtils.getActualTypeForFirstTypeVariable(genericType);    assertEquals(String.class, actualTypeForFirstTypeVariable);  }  public void testStrangeTypeParameters() throws Exception {    try {      new TypeInfo(new Type() {});      fail("Should not be able to determine this unknown type");    } catch (IllegalArgumentException expected) {    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.MemoryRefStack;import junit.framework.TestCase;import java.util.EmptyStackException;/** * Unit tests for the {@link MemoryRefStack} class. * * @author Joel Leitch */public class MemoryRefStackTest extends TestCase {  private MemoryRefStack<MockObject> stack;  @Override  protected void setUp() throws Exception {    super.setUp();    stack = new MemoryRefStack<MockObject>();  }  public void testPeekEmptyStack() throws Exception {    try {      stack.peek();    } catch (EmptyStackException expected) { }  }  public void testPushPeekAndPop() throws Exception {    MockObject obj = new MockObject();    assertEquals(obj, stack.push(obj));    assertEquals(obj, stack.peek());    assertEquals(obj, stack.pop());  }  public void testPopTooMany() throws Exception {    MockObject obj = new MockObject();    stack.push(obj);    assertEquals(obj, stack.pop());    try {      stack.pop();    } catch (EmptyStackException expected) { }  }  public void testContains() throws Exception {    MockObject objA = new MockObject();    MockObject objB = new MockObject();    assertEquals(objA, objB);    stack.push(objA);    assertFalse(stack.contains(objB));    assertTrue(stack.contains(objA));  }  private static class MockObject {    private final int value = 1;    @Override    public boolean equals(Object obj) {      return obj instanceof MockObject && value == ((MockObject) obj).value;    }    @Override    public int hashCode() {      return value;    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;import java.lang.reflect.Type;import java.math.BigInteger;import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.atomic.AtomicLong;/** * Contains numerous tests involving registered type converters with a Gson instance. * * @author Inderjeet Singh * @author Joel Leitch */public class GsonTypeAdapterTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new GsonBuilder()        .registerTypeAdapter(AtomicLong.class, new ExceptionTypeAdapter())        .registerTypeAdapter(AtomicInteger.class, new AtomicIntegerTypeAdapter())        .create();  }  public void testDefaultTypeAdapterThrowsParseException() throws Exception {    try {      gson.fromJson("{\"abc\":123}", BigInteger.class);      fail("Should have thrown a JsonParseException");    } catch (JsonParseException expected) { }  }  public void testTypeAdapterThrowsException() throws Exception {    try {      gson.toJson(new AtomicLong(0));      fail("Type Adapter should have thrown an exception");    } catch (IllegalStateException expected) { }    try {      gson.fromJson("123", AtomicLong.class);      fail("Type Adapter should have thrown an exception");    } catch (JsonParseException expected) { }  }  public void testTypeAdapterProperlyConvertsTypes() throws Exception {    int intialValue = 1;    AtomicInteger atomicInt = new AtomicInteger(intialValue);    String json = gson.toJson(atomicInt);    assertEquals(intialValue + 1, Integer.parseInt(json));    atomicInt = gson.fromJson(json, AtomicInteger.class);    assertEquals(intialValue, atomicInt.get());  }  public void testTypeAdapterDoesNotAffectNonAdaptedTypes() throws Exception {    String expected = "blah";    String actual = gson.toJson(expected);    assertEquals("\"" + expected + "\"", actual);    actual = gson.fromJson(actual, String.class);    assertEquals(expected, actual);  }  private static class ExceptionTypeAdapter      implements JsonSerializer<AtomicLong>, JsonDeserializer<AtomicLong> {    public JsonElement serialize(        AtomicLong src, Type typeOfSrc, JsonSerializationContext context) {      throw new IllegalStateException();    }    public AtomicLong deserialize(        JsonElement json, Type typeOfT, JsonDeserializationContext context)        throws JsonParseException {      throw new IllegalStateException();    }  }  private static class AtomicIntegerTypeAdapter      implements JsonSerializer<AtomicInteger>, JsonDeserializer<AtomicInteger> {    public JsonElement serialize(AtomicInteger src, Type typeOfSrc, JsonSerializationContext context) {      return new JsonPrimitive(src.incrementAndGet());    }    public AtomicInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)        throws JsonParseException {      int intValue = json.getAsInt();      return new AtomicInteger(--intValue);    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.Collection;import java.util.Map;/** * Unit tests for {@link TypeUtils}. * * @author Inderjeet Singh */public class TypeUtilsTest extends TestCase {  private static final Type MAP_TYPE = new TypeToken<Map<String, Integer>>() {}.getType();  public void testGetActualTypeForFirstTypeVariable() {    assertEquals(String.class, TypeUtils.getActualTypeForFirstTypeVariable(MAP_TYPE));  }  public void testIsArrayForNonArrayClasses() {    assertFalse(TypeUtils.isArray(Boolean.class));    assertFalse(TypeUtils.isArray(MAP_TYPE));  }  public void testIsArrayForArrayClasses() {    assertTrue(TypeUtils.isArray(String[].class));    assertTrue(TypeUtils.isArray(Integer[][].class));    assertTrue(TypeUtils.isArray(Collection[].class));  }  public void testToRawClassForNonGenericClasses() {    assertEquals(String.class, TypeUtils.toRawClass(String.class));  }  public void testToRawClassForGenericClasses() {    assertEquals(Map.class, TypeUtils.toRawClass(MAP_TYPE));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.annotations.Since;import junit.framework.TestCase;import java.lang.reflect.Field;/** * Unit tests for the {@link VersionExclusionStrategy} class. * * @author Joel Leitch */public class VersionExclusionStrategyTest extends TestCase {  private static final double VERSION = 5.0D;  public void testDisallowNegativeValuesAndFailFast() throws Exception {    try {      new VersionExclusionStrategy(-1.0D);      fail("should have thrown an exception.");    } catch (IllegalArgumentException expected) { }  }  public void testClassAndFieldAreAtSameVersion() throws Exception {    Class<MockObject> clazz = MockObject.class;    Field f = clazz.getField("someField");    VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION);        assertFalse(strategy.shouldSkipClass(clazz));    assertFalse(strategy.shouldSkipField(f));  }  public void testClassAndFieldAreBehindInVersion() throws Exception {    Class<MockObject> clazz = MockObject.class;    Field f = clazz.getField("someField");    VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION + 1);        assertFalse(strategy.shouldSkipClass(clazz));    assertFalse(strategy.shouldSkipField(f));  }  public void testClassAndFieldAreAheadInVersion() throws Exception {    Class<MockObject> clazz = MockObject.class;    Field f = clazz.getField("someField");    VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION - 1);        assertTrue(strategy.shouldSkipClass(clazz));    assertTrue(strategy.shouldSkipField(f));  }  @Since(VERSION)  private static class MockObject {    @Since(VERSION)    public final int someField = 0;  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.List;/** * Unit tests for the {@link GenericArrayTypeImpl} class. * * @author Inderjeet Singh * @author Joel Leitch */public class GenericArrayTypeImplTest extends TestCase {  private Type parameterizedType;  private Type genericArrayType;  private GenericArrayTypeImpl ourType;  @Override  protected void setUp() throws Exception {    super.setUp();    parameterizedType = new TypeToken<List<String>>() {}.getType();    genericArrayType = new TypeToken<List<String>[]>() {}.getType();    ourType = new GenericArrayTypeImpl(parameterizedType);  }  public void testOurTypeFunctionality() throws Exception {    assertEquals(parameterizedType, ourType.getGenericComponentType());    assertEquals(genericArrayType, ourType);    assertEquals(genericArrayType.hashCode(), ourType.hashCode());  }  public void testNotEquals() throws Exception {    Type differentGenericArrayType = new TypeToken<List<String>[][]>() {}.getType();    assertFalse(differentGenericArrayType.equals(ourType));    assertFalse(ourType.equals(differentGenericArrayType));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;/** * Unit tests for the {@link JsonFieldNameValidator} class. * * @author Joel Leitch */public class JsonFieldNameValidatorTest extends TestCase {  private JsonFieldNameValidator validator;  @Override  protected void setUp() throws Exception {    super.setUp();    validator = new JsonFieldNameValidator();  }  public void testValidFieldBeginsWithDollarSign() throws Exception {    String fieldName = "$abc";    assertEquals(fieldName, validator.validate(fieldName));  }  public void testValidFieldBeginsWithUnderscore() throws Exception {    String fieldName = "_abc";    assertEquals(fieldName, validator.validate(fieldName));  }  public void testValidFieldBeginsWithLetter() throws Exception {    String fieldName = "abc";    assertEquals(fieldName, validator.validate(fieldName));  }  public void testValidFieldMixingLetter() throws Exception {    String fieldName = "$abc_12v$34";    assertEquals(fieldName, validator.validate(fieldName));  }  public void testInvalidFieldStartingWithNumbers() throws Exception {    try {      validator.validate("1abc");      fail("Json field name can not start with a number");    } catch (IllegalArgumentException expected) { }  }  public void testInvalidFieldStartingTwoDollarSigns() throws Exception {    try {      validator.validate("$$abc");      fail("Json field name can not start with a double dollar sign");    } catch (IllegalArgumentException expected) { }  }  public void testInvalidFieldStartingTwoUnderscores() throws Exception {    try {      validator.validate("__abc");      fail("Json field name can not start with a double underscore");    } catch (IllegalArgumentException expected) { }  }  public void testInvalidFieldStartingDollarUnderscore() throws Exception {    try {      validator.validate("$_abc");      fail("Json field name can not start with two non-alphabet characters");    } catch (IllegalArgumentException expected) { }  }  public void testKeywordAsFieldName() throws Exception {    try {      validator.validate("break");      fail("Json field name can not be a reserved word");    } catch (IllegalArgumentException expected) { }  }  public void testInvalidCharacters() throws Exception {    try {      validator.validate("abc.123");      fail("Json field name can not contain a period character");    } catch (IllegalArgumentException expected) { }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;/** * Unit test for the {@link com.google.gson.ModifyFirstLetterNamingPolicy} class. * * @author Joel Leitch */public class ModifyFirstLetterNamingPolicyTest extends TestCase {  public void testInvalidConstruction() throws Exception {    try {      new ModifyFirstLetterNamingPolicy(null);      fail("Null values are not allowed as a constructor parameters");    } catch (IllegalArgumentException expected) { }  }  public void testLowerCaseFirstLetter() throws Exception {    ModifyFirstLetterNamingPolicy policy =        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.LOWER);    assertEquals("blah", policy.translateName("Blah", String.class, null));    assertEquals("blah", policy.translateName("blah", String.class, null));  }  public void testUpperCaseFirstLetter() throws Exception {    ModifyFirstLetterNamingPolicy policy =        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);    assertEquals("Blah", policy.translateName("blah", String.class, null));    assertEquals("Blah", policy.translateName("Blah", String.class, null));  }  public void testSingleCharacterField() throws Exception {    ModifyFirstLetterNamingPolicy policy =        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);    assertEquals("B", policy.translateName("b", String.class, null));    assertEquals("B", policy.translateName("B", String.class, null));  }  public void testFieldStartsWithUnderscore() throws Exception {    ModifyFirstLetterNamingPolicy policy =        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);    assertEquals("_Blah", policy.translateName("_blah", String.class, null));    assertEquals("_Blah", policy.translateName("_Blah", String.class, null));  }  public void testFieldStartsWithUnderscoreFollowedBySingleLetter() throws Exception {    ModifyFirstLetterNamingPolicy policy =        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);    assertEquals("_B", policy.translateName("_b", String.class, null));    assertEquals("_B", policy.translateName("_B", String.class, null));  }  public void testFieldHasSingleNonLetter() throws Exception {    ModifyFirstLetterNamingPolicy policy =        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.LOWER);    assertEquals("_", policy.translateName("_", String.class, null));    policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);    assertEquals("_", policy.translateName("_", String.class, null));  }  public void testFieldHasNoLetters() throws Exception {    ModifyFirstLetterNamingPolicy policy =        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.LOWER);    assertEquals("$_$", policy.translateName("$_$", String.class, null));    policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);    assertEquals("$_$", policy.translateName("$_$", String.class, null));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.LowerCaseNamingPolicy;import junit.framework.TestCase;/** * Tests for the {@link LowerCaseNamingPolicy} class. * * @author Joel Leitch */public class LowerCaseNamingPolicyTest extends TestCase {  private static final String ALL_LOWER = "abcdefg";  private static final String ALL_UPPER = "ABCDEFG";  private static final String MIXED = "aBcdeFg";  private LowerCaseNamingPolicy namingPolicy;  @Override  protected void setUp() throws Exception {    super.setUp();    namingPolicy = new LowerCaseNamingPolicy();  }  public void testAllLowerCase() throws Exception {    assertEquals(ALL_LOWER, namingPolicy.translateName(ALL_LOWER, String.class, null));  }  public void testAllUpperCase() throws Exception {    assertEquals(ALL_LOWER, namingPolicy.translateName(ALL_UPPER, String.class, null));  }  public void testMixedCase() throws Exception {    assertEquals(ALL_LOWER, namingPolicy.translateName(MIXED, String.class, null));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;/** * Unit tests for {@link GsonBuilder}. * * @author Inderjeet Singh */public class GsonBuilderTest extends TestCase {  public void testCreatingMoreThanOnce() {    GsonBuilder builder = new GsonBuilder();    builder.create();    builder.create();  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.LowerCaseNamingPolicy;import com.google.gson.UpperCaseNamingPolicy;import junit.framework.TestCase;/** * Tests for the {@link LowerCaseNamingPolicy} class. * * @author Joel Leitch */public class UpperCaseNamingPolicyTest extends TestCase {  private static final String ALL_LOWER = "abcdefg";  private static final String ALL_UPPER = "ABCDEFG";  private static final String MIXED = "aBcdeFg";  private UpperCaseNamingPolicy namingPolicy;  @Override  protected void setUp() throws Exception {    super.setUp();    namingPolicy = new UpperCaseNamingPolicy();  }  public void testAllLowerCase() throws Exception {    assertEquals(ALL_UPPER, namingPolicy.translateName(ALL_LOWER, String.class, null));  }  public void testAllUpperCase() throws Exception {    assertEquals(ALL_UPPER, namingPolicy.translateName(ALL_UPPER, String.class, null));  }  public void testMixedCase() throws Exception {    assertEquals(ALL_UPPER, namingPolicy.translateName(MIXED, String.class, null));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Unit test for the default JSON map serialization object located in the * {@link DefaultTypeAdapters} class. * * @author Joel Leitch */public class TypeInfoMapTest extends TestCase {  public void testInvalidConstruction() throws Exception {    try {      new TypeInfoMap(String.class);      fail("Must be a ParameterizedType");    } catch (IllegalArgumentException expected) { }  }  public void testNonMapConstruction() throws Exception {    try {      Type parameterizedMapType = new TypeToken<List<String>>() {}.getType();      new TypeInfoMap(parameterizedMapType);      fail("The raw type must be a Map");    } catch (IllegalArgumentException expected) { }  }  public void testBasicGetters() throws Exception {    Type parameterizedMapType = new TypeToken<Map<String, Integer>>() {}.getType();    TypeInfoMap mapTypeInfo = new TypeInfoMap(parameterizedMapType);    assertEquals(String.class, mapTypeInfo.getKeyType());    assertEquals(Integer.class, mapTypeInfo.getValueType());  }  public void testMapImplementations() throws Exception {    Type parameterizedMapType = new TypeToken<HashMap<String, Integer>>() {}.getType();    TypeInfoMap mapTypeInfo = new TypeInfoMap(parameterizedMapType);    assertEquals(String.class, mapTypeInfo.getKeyType());    assertEquals(Integer.class, mapTypeInfo.getValueType());  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Field;import java.lang.reflect.Type;import java.util.List;/** * Small test to ensure that the TypeInfoFactory is return the object that we expect. * * @author Inderjeet Singh * @author Joel Leitch */public class TypeInfoFactoryTest extends TestCase {  private static Type OBJ_TYPE = new TypeToken<ObjectWithDifferentFields<Integer>>() {}.getType();  private ObjectWithDifferentFields<Integer> obj;  @Override  protected void setUp() throws Exception {    super.setUp();    obj = new ObjectWithDifferentFields<Integer>();  }  public void testSimpleField() throws Exception {    Field f = obj.getClass().getField("simpleField");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(String.class, typeInfo.getActualType());    assertEquals(String.class, typeInfo.getRawClass());  }  public void testEnumField() throws Exception {    Field f = obj.getClass().getField("enumField");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertTrue(typeInfo.isEnum());    assertEquals(ObjectWithDifferentFields.TestEnum.class, typeInfo.getActualType());    assertEquals(ObjectWithDifferentFields.TestEnum.class, typeInfo.getRawClass());  }  public void testParameterizedTypeField() throws Exception {    Type listType = new TypeToken<List<String>>() {}.getType();    Field f = obj.getClass().getField("simpleParameterizedType");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List.class, typeInfo.getRawClass());  }  public void testNestedParameterizedTypeField() throws Exception {    Type listType = new TypeToken<List<List<String>>>() {}.getType();    Field f = obj.getClass().getField("simpleNestedParameterizedType");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List.class, typeInfo.getRawClass());  }  public void testGenericArrayTypeField() throws Exception {    Type listType = new TypeToken<List<String>[]>() {}.getType();    Field f = obj.getClass().getField("simpleGenericArray");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertTrue(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List[].class, typeInfo.getRawClass());  }  public void testTypeVariableField() throws Exception {    Field f = obj.getClass().getField("typeVariableObj");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(Integer.class, typeInfo.getActualType());    assertEquals(Integer.class, typeInfo.getRawClass());  }  public void testTypeVariableArrayField() throws Exception {    Field f = obj.getClass().getField("typeVariableArray");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertTrue(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(Integer[].class, typeInfo.getActualType());    assertEquals(Integer[].class, typeInfo.getRawClass());  }  public void testMutliDimensionalTypeVariableArrayField() throws Exception {    Field f = obj.getClass().getField("mutliDimensionalTypeVariableArray");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertTrue(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(Integer[][][].class, typeInfo.getActualType());    assertEquals(Integer[][][].class, typeInfo.getRawClass());  }  public void testParameterizedTypeVariableField() throws Exception {    Type listType = new TypeToken<List<Integer>>() {}.getType();    Field f = obj.getClass().getField("listOfTypeVariables");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List.class, typeInfo.getRawClass());  }  public void testNestedParameterizedTypeVariableField() throws Exception {    Type listType = new TypeToken<List<List<Integer>>>() {}.getType();    Field f = obj.getClass().getField("listOfListsOfTypeVariables");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List.class, typeInfo.getRawClass());  }  public void testParameterizedTypeVariableArrayField() throws Exception {    Type listType = new TypeToken<List<Integer>[]>() {}.getType();    Field f = obj.getClass().getField("listOfTypeVariablesArray");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertTrue(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List[].class, typeInfo.getRawClass());  }  public void testWildcardField() throws Exception {    Type listType = new TypeToken<List<Object>>() {}.getType();    Field f = obj.getClass().getField("listWithWildcard");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List.class, typeInfo.getRawClass());  }  public void testArrayOfWildcardField() throws Exception {    Type listType = new TypeToken<List<Object>[]>() {}.getType();    Field f = obj.getClass().getField("arrayOfListWithWildcard");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertTrue(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List[].class, typeInfo.getRawClass());  }  public void testListStringWildcardField() throws Exception {    Type listType = new TypeToken<List<String>>() {}.getType();    Field f = obj.getClass().getField("listWithStringWildcard");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List.class, typeInfo.getRawClass());  }  public void testArrayOfListStringWildcardField() throws Exception {    Type listType = new TypeToken<List<String>[]>() {}.getType();    Field f = obj.getClass().getField("arrayOfListWithStringWildcard");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertTrue(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List[].class, typeInfo.getRawClass());  }  public void testListTypeVariableWildcardField() throws Exception {    Type listType = new TypeToken<List<Integer>>() {}.getType();    Field f = obj.getClass().getField("listWithTypeVariableWildcard");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List.class, typeInfo.getRawClass());  }  public void testArrayOfListTypeVariableWildcardField() throws Exception {    Type listType = new TypeToken<List<Integer>[]>() {}.getType();    Field f = obj.getClass().getField("arrayOfListWithTypeVariableWildcard");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertTrue(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List[].class, typeInfo.getRawClass());  }  private static class ObjectWithDifferentFields<T> {    public static enum TestEnum {      TEST_1, TEST_2;    }    public String simpleField;    public TestEnum enumField;    public List<String> simpleParameterizedType;    public List<List<String>> simpleNestedParameterizedType;    public List<String>[] simpleGenericArray;    public T typeVariableObj;    public T[] typeVariableArray;    public T[][][] mutliDimensionalTypeVariableArray;    public List<T> listOfTypeVariables;    public List<List<T>> listOfListsOfTypeVariables;    public List<T>[] listOfTypeVariablesArray;    public List<?> listWithWildcard;    public List<?>[] arrayOfListWithWildcard;    public List<? extends String> listWithStringWildcard;    public List<? extends String>[] arrayOfListWithStringWildcard;    public List<? extends T> listWithTypeVariableWildcard;    public List<? extends T>[] arrayOfListWithTypeVariableWildcard;  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.common.TestTypes.ArrayOfObjects;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.common.TestTypes.ClassWithNoFields;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Modifier;import java.lang.reflect.Type;import java.util.Arrays;import java.util.LinkedList;import java.util.List;/** * Functional tests for Gson that depend on some internal package-protected elements of * com.google.gson package and hence must be placed in the same package. We should make every * attempt to migrate tests out of this class. * * @author Inderjeet Singh * @author Joel Leitch */public class FunctionalWithInternalDependenciesTest extends TestCase {  private static int INDENTATION_SIZE = 2;  private static int PRINT_MARGIN = 100;  private static int RIGHT_MARGIN = 8;  private static boolean DEBUG = false;  private GsonBuilder builder;  @Override  protected void setUp() throws Exception {    super.setUp();    builder = new GsonBuilder();  }  public void testAnonymousLocalClassesSerialization() {    Gson gson = new Gson(new ModifierBasedExclusionStrategy(        true, Modifier.TRANSIENT, Modifier.STATIC), Gson.DEFAULT_NAMING_POLICY);    assertEquals("{}", gson.toJson(new ClassWithNoFields() {      // empty anonymous class    }));  }  public void testPrettyPrintList() {    JsonFormatter formatter = new JsonPrintFormatter(PRINT_MARGIN, INDENTATION_SIZE, RIGHT_MARGIN);    Gson gson = builder.setFormatter(formatter).create();    BagOfPrimitives b = new BagOfPrimitives();    List<BagOfPrimitives> listOfB = new LinkedList<BagOfPrimitives>();    for (int i = 0; i < 15; ++i) {      listOfB.add(b);    }    Type typeOfSrc = new TypeToken<List<BagOfPrimitives>>() {}.getType();    String json = gson.toJson(listOfB, typeOfSrc);    print(json);    assertPrintMargin(json);  }  public void testPrettyPrintArrayOfObjects() {    JsonFormatter formatter = new JsonPrintFormatter(PRINT_MARGIN, INDENTATION_SIZE, RIGHT_MARGIN);    Gson gson = builder.setFormatter(formatter).create();    ArrayOfObjects target = new ArrayOfObjects();    String json = gson.toJson(target);    print(json);    assertPrintMargin(json);  }  public void testPrettyPrintArrayOfPrimitives() {    JsonFormatter formatter = new JsonPrintFormatter(PRINT_MARGIN, INDENTATION_SIZE, RIGHT_MARGIN);    Gson gson = builder.setFormatter(formatter).create();    int[] ints = new int[] { 1, 2, 3, 4, 5 };    String json = gson.toJson(ints);    assertEquals("[1,2,3,4,5]\n", json);  }  public void testPrettyPrintArrayOfPrimitiveArrays() {    JsonFormatter formatter = new JsonPrintFormatter(PRINT_MARGIN, INDENTATION_SIZE, RIGHT_MARGIN);    Gson gson = builder.setFormatter(formatter).create();    int[][] ints = new int[][] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 }, { 9, 0 }, { 10 } };    String json = gson.toJson(ints);    assertEquals("[[1,2],[3,4],[5,6],[7,8],[9,0],[10]]\n", json);  }  public void testPrettyPrintListOfPrimitiveArrays() {    JsonFormatter formatter = new JsonPrintFormatter(PRINT_MARGIN, INDENTATION_SIZE, RIGHT_MARGIN);    Gson gson = builder.setFormatter(formatter).create();    List<Integer[]> list = Arrays.asList(new Integer[][] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 },        { 9, 0 }, { 10 } });    String json = gson.toJson(list);    assertEquals("[[1,2],[3,4],[5,6],[7,8],[9,0],[10]]\n", json);  }  public void testMultipleArrays() {    JsonFormatter formatter = new JsonPrintFormatter(PRINT_MARGIN, INDENTATION_SIZE, RIGHT_MARGIN);    Gson gson = builder.setFormatter(formatter).create();    int[][][] ints = new int[][][] { {  { 1 }, { 2 } } };    String json = gson.toJson(ints);    assertEquals("[[[1],[2]]]\n", json);  }  private void print(String msg) {    if (DEBUG) {      System.out.println(msg);    }  }  private void assertPrintMargin(String str) {    int position = 0;    char[] chars = str.toCharArray();    for (int i = 0; i < chars.length; ++i, ++position) {      char c = chars[i];      if (c == '\n') {        position = 0;      }      assertTrue(position < PRINT_MARGIN + RIGHT_MARGIN);    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;import java.lang.reflect.Field;/** * Tests for the {@link JavaFieldNamingPolicy} class. * * @author Joel Leitch */public class JavaFieldNamingPolicyTest extends TestCase {  private JavaFieldNamingPolicy namingPolicy;  @Override  protected void setUp() throws Exception {    super.setUp();    namingPolicy = new JavaFieldNamingPolicy();  }  public void testFieldNamingPolicy() throws Exception {    Field f = String.class.getFields()[0];    assertEquals(f.getName(), namingPolicy.translateName(f));  }  public void testNullField() throws Exception {    try {      namingPolicy.translateName((Field) null);      fail("Should have thrown an exception");    } catch (IllegalArgumentException expected) { }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.DisjunctionExclusionStrategy;import com.google.gson.ExclusionStrategy;import junit.framework.TestCase;import java.lang.reflect.Field;import java.util.LinkedList;import java.util.List;/** * Unit tests for the {@link DisjunctionExclusionStrategy} class. * * @author Joel Leitch */public class DisjunctionExclusionStrategyTest extends TestCase {  private static final ExclusionStrategy FALSE_STRATEGY = new MockExclusionStrategy(false, false);  private static final ExclusionStrategy TRUE_STRATEGY = new MockExclusionStrategy(true, true);  private static final Class<?> CLAZZ = String.class;  private static final Field FIELD = CLAZZ.getFields()[0];  public void testBadInstantiation() throws Exception {    try {      new DisjunctionExclusionStrategy();    } catch (IllegalArgumentException expected) { }    try {      ExclusionStrategy[] constructorParam = null;      new DisjunctionExclusionStrategy(constructorParam);    } catch (IllegalArgumentException expected) { }    try {      ExclusionStrategy[] constructorParam = new ExclusionStrategy[0];      new DisjunctionExclusionStrategy(constructorParam);    } catch (IllegalArgumentException expected) { }    try {      List<ExclusionStrategy> constructorParam = null;      new DisjunctionExclusionStrategy(constructorParam);    } catch (IllegalArgumentException expected) { }    try {      List<ExclusionStrategy> constructorParam = new LinkedList<ExclusionStrategy>();      new DisjunctionExclusionStrategy(constructorParam);    } catch (IllegalArgumentException expected) { }  }  public void testSkipFieldsWithMixedTrueAndFalse() throws Exception {    DisjunctionExclusionStrategy strategy =        new DisjunctionExclusionStrategy(FALSE_STRATEGY, TRUE_STRATEGY);    assertTrue(strategy.shouldSkipClass(CLAZZ));    assertTrue(strategy.shouldSkipField(FIELD));  }  public void testSkipFieldsWithFalseOnly() throws Exception {    DisjunctionExclusionStrategy strategy =  new DisjunctionExclusionStrategy(FALSE_STRATEGY);    assertFalse(strategy.shouldSkipClass(CLAZZ));    assertFalse(strategy.shouldSkipField(FIELD));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.NullExclusionStrategy;import junit.framework.TestCase;/** * Unit test for the {@link NullExclusionStrategy} class. * * @author Joel Leitch */public class NullExclusionStrategyTest extends TestCase {  private NullExclusionStrategy strategy;  @Override  protected void setUp() throws Exception {    super.setUp();    strategy = new NullExclusionStrategy();  }  public void testNeverSkipsClass() throws Exception {    assertFalse(strategy.shouldSkipClass(String.class));  }  public void testNeverSkipsField() throws Exception {    assertFalse(strategy.shouldSkipField("".getClass().getFields()[0]));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;import junit.framework.TestCase;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/** * A simple unit test for the {@link DefaultDateTypeAdapter} class. * * @author Joel Leitch */public class DefaultDateTypeAdapterTest extends TestCase {  public void testDateSerialization() throws Exception {    int dateStyle = DateFormat.LONG;    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle);    DateFormat formatter = DateFormat.getDateInstance(dateStyle);    Date currentDate = new Date();    String dateString = dateTypeAdapter.serialize(currentDate, Date.class, null).getAsString();    assertEquals(formatter.format(currentDate), dateString);  }  public void testDatePattern() throws Exception {    String pattern = "yyyy-MM-dd";    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(pattern);    DateFormat formatter = new SimpleDateFormat(pattern);    Date currentDate = new Date();    String dateString = dateTypeAdapter.serialize(currentDate, Date.class, null).getAsString();    assertEquals(formatter.format(currentDate), dateString);  }  public void testInvalidDatePattern() throws Exception {    try {      new DefaultDateTypeAdapter("I am a bad Date pattern....");      fail("Invalid date pattern should fail.");    } catch (IllegalArgumentException expected) { }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;/** * Performs some unit testing for the {@link PrimitiveTypeAdapter} class. * * @author Joel Leitch */public class PrimitiveTypeAdapterTest extends TestCase {  private PrimitiveTypeAdapter typeAdapter;  @Override  protected void setUp() throws Exception {    super.setUp();    typeAdapter = new PrimitiveTypeAdapter();  }  public void testImproperConversion() throws Exception {    double someValue = 1.0;    try {      typeAdapter.adaptType(someValue, String.class);      fail("Should not be able to convert incompatible types.");    } catch (JsonParseException expected) { }  }  public void testImproperCharacterConversion() throws Exception {    String someValue = "test123";    try {      typeAdapter.adaptType(someValue, Character.class);      fail("Should not be able to convert incompatible types.");    } catch (JsonParseException expected) { }  }  public void testProperPrimitiveConversions() throws Exception {    String stringValue = "1.0";    Double actualValue = typeAdapter.adaptType(stringValue, Double.class);    assertEquals(1.0, actualValue.doubleValue(), 0.0001);    Double doubleValue = 1.0;    actualValue = typeAdapter.adaptType(doubleValue, Double.class);    assertEquals(1.0, actualValue.doubleValue(), 0.0001);    stringValue = "A";    Character actualCharacter = typeAdapter.adaptType(stringValue, Character.class);    assertEquals('A', actualCharacter.charValue());  }  public void testProperEnumConversions() throws Exception {    TestEnum expected = TestEnum.TEST1;    TestEnum actual = typeAdapter.adaptType(expected, TestEnum.class);    assertEquals(expected, actual);  }  private static enum TestEnum {    TEST1, TEST2, TEST3  }}