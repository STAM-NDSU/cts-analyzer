/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.JsonParseException;import com.google.gson.common.MoreAsserts;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.common.TestTypes.ClassWithObjects;import com.google.gson.common.TestTypes.CrazyLongTypeAdapter;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.math.BigDecimal;import java.util.ArrayList;import java.util.Collection;/** * Functional tests for Json serialization and deserialization of arrays. * * @author Inderjeet Singh * @author Joel Leitch */public class ArrayTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testTopLevelArrayOfIntsSerialization() {    int[] target = {1, 2, 3, 4, 5, 6, 7, 8, 9};    assertEquals("[1,2,3,4,5,6,7,8,9]", gson.toJson(target));  }  public void testTopLevelArrayOfIntsDeserialization() {    int[] expected = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };    int[] actual = gson.fromJson("[1,2,3,4,5,6,7,8,9]", int[].class);    MoreAsserts.assertEquals(expected, actual);  }  public void testInvalidArrayDeserialization() {    String json = "[1, 2 3, 4, 5]";    try {      gson.fromJson(json, int[].class);      fail("Gson should not deserialize array elements with missing ,");    } catch (JsonParseException expected) {          }  }  public void testEmptyArraySerialization() {    int[] target = {};    assertEquals("[]", gson.toJson(target));  }  public void testEmptyArrayDeserialization() {    int[] actualObject = gson.fromJson("[]", int[].class);    assertTrue(actualObject.length == 0);    Integer[] actualObject2 = gson.fromJson("[]", Integer[].class);    assertTrue(actualObject2.length == 0);    actualObject = gson.fromJson("[ ]", int[].class);    assertTrue(actualObject.length == 0);}  public void testNullsInArraySerialization() {    String[] array = {"foo", null, "bar"};    String expected = "[\"foo\",null,\"bar\"]";    String json = gson.toJson(array);    assertEquals(expected, json);  }  public void testNullsInArrayDeserialization() {    String json = "[\"foo\",null,\"bar\"]";    String[] expected = {"foo", null, "bar"};    String[] target = gson.fromJson(json, expected.getClass());    for (int i = 0; i < expected.length; ++i) {      assertEquals(expected[i], target[i]);    }  }    public void testSingleNullInArraySerialization() {        BagOfPrimitives[] array = new BagOfPrimitives[1];    array[0] = null;    String json = gson.toJson(array);    assertEquals("[null]", json);  }    public void testSingleNullInArrayDeserialization() {    BagOfPrimitives[] array = gson.fromJson("[null]", BagOfPrimitives[].class);    assertNull(array[0]);  }    public void testNullsInArrayWithSerializeNullPropertySetSerialization() {    gson = new GsonBuilder().serializeNulls().create();    String[] array = {"foo", null, "bar"};    String expected = "[\"foo\",null,\"bar\"]";    String json = gson.toJson(array);    assertEquals(expected, json);  }  public void testArrayOfStringsSerialization() {    String[] target = {"Hello", "World"};    assertEquals("[\"Hello\",\"World\"]", gson.toJson(target));  }  public void testArrayOfStringsDeserialization() {    String json = "[\"Hello\",\"World\"]";    String[] target = gson.fromJson(json, String[].class);    assertEquals("Hello", target[0]);    assertEquals("World", target[1]);  }  @SuppressWarnings("unchecked")  public void testArrayOfCollectionSerialization() throws Exception {    StringBuilder sb = new StringBuilder("[");    int arraySize = 3;    Type typeToSerialize = new TypeToken<Collection<Integer>[]>() {}.getType();    Collection<Integer>[] arrayOfCollection = new ArrayList[arraySize];    for (int i = 0; i < arraySize; ++i) {      int startValue = (3 * i) + 1;      sb.append('[').append(startValue).append(',').append(startValue + 1).append(']');      ArrayList<Integer> tmpList = new ArrayList<Integer>();      tmpList.add(startValue);      tmpList.add(startValue + 1);      arrayOfCollection[i] = tmpList;      if (i < arraySize - 1) {        sb.append(',');      }    }    sb.append(']');    String json = gson.toJson(arrayOfCollection, typeToSerialize);    assertEquals(sb.toString(), json);  }  public void testArrayOfCollectionDeserialization() throws Exception {    String json = "[[1,2],[3,4]]";    Type type = new TypeToken<Collection<Integer>[]>() {}.getType();    Collection<Integer>[] target = gson.fromJson(json, type);    assertEquals(2, target.length);    MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0]));    MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0]));  }    public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception {    CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter();    gson = new GsonBuilder()        .registerTypeAdapter(long.class, typeAdapter)        .registerTypeAdapter(Long.class, typeAdapter)        .create();    long[] value = { 1L };    String serializedValue = gson.toJson(value);    String expected = "[" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + "]";    assertEquals(expected, serializedValue);        long[] deserializedValue = gson.fromJson(serializedValue, long[].class);    assertEquals(1, deserializedValue.length);    assertEquals(value[0], deserializedValue[0]);  }    public void testArrayOfPrimitivesAsObjectsSerialization() throws Exception {    Object[] objs = new Object[]{1, "abc", 0.3f, 5L};    String json = gson.toJson(objs);    assertTrue(json.contains("abc"));    assertTrue(json.contains("0.3"));    assertTrue(json.contains("5"));  }  public void testArrayOfPrimitivesAsObjectsDeserialization() throws Exception {    String json = "[1,'abc',0.3,5]";    Object[] objs = gson.fromJson(json, Object[].class);    assertEquals(1, objs[0]);    assertEquals("abc", objs[1]);    assertEquals(new BigDecimal("0.3"), objs[2]);    assertEquals(5, objs[3]);  }  public void testArrayOfObjectsWithoutTypeInfoDeserialization() throws Exception {    String json = "[1,'abc',{a:1},5]";    try {      gson.fromJson(json, Object[].class);    } catch (JsonParseException expected) {    }  }    public void testArrayWithoutTypeInfoDeserialization() throws Exception {    String json = "[1,'abc',[1,2],5]";    try {      gson.fromJson(json, Object[].class);    } catch (JsonParseException expected) {    }  }    public void testObjectArrayWithNonPrimitivesSerializaiton() throws Exception {    ClassWithObjects classWithObjects = new ClassWithObjects();    BagOfPrimitives bagOfPrimitives = new BagOfPrimitives();    String classWithObjectsJson = gson.toJson(classWithObjects);    String bagOfPrimitivesJson = gson.toJson(bagOfPrimitives);    Object[] objects = new Object[] { classWithObjects, bagOfPrimitives };    String json = gson.toJson(objects);        assertTrue(json.contains(classWithObjectsJson));    assertTrue(json.contains(bagOfPrimitivesJson));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.JsonElement;import com.google.gson.JsonNull;import com.google.gson.JsonObject;import com.google.gson.JsonSerializationContext;import com.google.gson.JsonSerializer;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.common.TestTypes.ClassWithObjects;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.Collection;/** * Functional tests for the different cases for serializing (or ignoring) null fields and object. * * @author Inderjeet Singh * @author Joel Leitch */public class NullObjectAndFieldTest extends TestCase {  private GsonBuilder gsonBuilder;  @Override  protected void setUp() throws Exception {    super.setUp();    gsonBuilder = new GsonBuilder().serializeNulls();  }  public void testTopLevelNullObjectSerialization() {    Gson gson = gsonBuilder.create();    String actual = gson.toJson(null);    assertEquals("null", actual);    actual = gson.toJson(null, String.class);    assertEquals("null", actual);  }  public void testTopLevelNullObjectDeserialization() throws Exception {    Gson gson = gsonBuilder.create();    String actual = gson.fromJson("null", String.class);    assertNull(actual);  }  public void testExplicitSerializationOfNulls() {    Gson gson = gsonBuilder.create();    ClassWithObjects target = new ClassWithObjects(null);    String actual = gson.toJson(target);    String expected = "{\"bag\":null}";    assertEquals(expected, actual);  }  public void testExplicitDeserializationOfNulls() throws Exception {    Gson gson = gsonBuilder.create();    ClassWithObjects target = gson.fromJson("{\"bag\":null}", ClassWithObjects.class);    assertNull(target.bag);  }    public void testExplicitSerializationOfNullArrayMembers() {    Gson gson = gsonBuilder.create();    ClassWithMembers target = new ClassWithMembers();    String json = gson.toJson(target);    assertTrue(json.contains("\"array\":null"));  }    /**    * Added to verify http://code.google.com/p/google-gson/issues/detail?id=68   */  public void testNullWrappedPrimitiveMemberSerialization() {    Gson gson = gsonBuilder.serializeNulls().create();    ClassWithNullWrappedPrimitive target = new ClassWithNullWrappedPrimitive();    String json = gson.toJson(target);    assertTrue(json.contains("\"value\":null"));  }    /**    * Added to verify http://code.google.com/p/google-gson/issues/detail?id=68   */  public void testNullWrappedPrimitiveMemberDeserialization() {    Gson gson = gsonBuilder.create();    String json = "{'value':null}";    ClassWithNullWrappedPrimitive target = gson.fromJson(json, ClassWithNullWrappedPrimitive.class);    assertNull(target.value);  }    public void testExplicitSerializationOfNullCollectionMembers() {    Gson gson = gsonBuilder.create();    ClassWithMembers target = new ClassWithMembers();    String json = gson.toJson(target);    assertTrue(json.contains("\"col\":null"));  }    public void testExplicitSerializationOfNullStringMembers() {    Gson gson = gsonBuilder.create();    ClassWithMembers target = new ClassWithMembers();    String json = gson.toJson(target);    assertTrue(json.contains("\"str\":null"));  }  public void testCustomSerializationOfNulls() {    gsonBuilder.registerTypeAdapter(ClassWithObjects.class, new ClassWithObjectsSerializer());    Gson gson = gsonBuilder.create();    ClassWithObjects target = new ClassWithObjects(new BagOfPrimitives());    String actual = gson.toJson(target);    String expected = "{\"bag\":null}";    assertEquals(expected, actual);  }    public void testPrintPrintingObjectWithNulls() throws Exception {    gsonBuilder = new GsonBuilder();    Gson gson = gsonBuilder.setPrettyPrinting().create();    String result = gson.toJson(new ClassWithMembers());    assertEquals("{}\n", result);    gson = gsonBuilder.serializeNulls().create();    result = gson.toJson(new ClassWithMembers());    assertTrue(result.contains("\"str\":null"));  }    public void testPrintPrintingArraysWithNulls() throws Exception {    gsonBuilder = new GsonBuilder();    Gson gson = gsonBuilder.setPrettyPrinting().create();    String result = gson.toJson(new String[] { "1", null, "3" });    assertEquals("[\"1\",null,\"3\"]\n", result);    gson = gsonBuilder.serializeNulls().create();    result = gson.toJson(new String[] { "1", null, "3" });    assertEquals("[\"1\",null,\"3\"]\n", result);  }  private static class ClassWithNullWrappedPrimitive {    private Long value;  }  @SuppressWarnings("unused")  private static class ClassWithMembers {    String str;    int[] array;    Collection<String> col;  }    private static class ClassWithObjectsSerializer implements JsonSerializer<ClassWithObjects> {    public JsonElement serialize(ClassWithObjects src, Type typeOfSrc,        JsonSerializationContext context) {      JsonObject obj = new JsonObject();      obj.add("bag", new JsonNull());      return obj;    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import java.math.BigDecimal;import java.math.BigInteger;import java.net.URI;import java.net.URL;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.HashSet;import java.util.Locale;import java.util.Properties;import java.util.Set;import java.util.UUID;import junit.framework.TestCase;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.JsonParseException;/** * Functional test for Json serialization and deserialization for common classes for which default * support is provided in Gson. The tests for Map types are available in {@link MapTest}. * * @author Inderjeet Singh * @author Joel Leitch */public class DefaultTypeAdaptersTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testUrlSerialization() throws Exception {    String urlValue = "http://google.com/";    URL url = new URL(urlValue);    assertEquals("\"http://google.com/\"", gson.toJson(url));  }  public void testUrlDeserialization() {    String urlValue = "http://google.com/";    String json = "'http:\\/\\/google.com\\/'";    URL target = gson.fromJson(json, URL.class);    assertEquals(urlValue, target.toExternalForm());        gson.fromJson('"' + urlValue + '"', URL.class);    assertEquals(urlValue, target.toExternalForm());  }  public void testUrlNullSerialization() throws Exception {    ClassWithUrlField target = new ClassWithUrlField();    assertEquals("{}", gson.toJson(target));  }  public void testUrlNullDeserialization() {    String json = "{}";    ClassWithUrlField target = gson.fromJson(json, ClassWithUrlField.class);    assertNull(target.url);  }    private static class ClassWithUrlField {    URL url;  }  public void testUriSerialization() throws Exception {    String uriValue = "http://google.com/";    URI uri = new URI(uriValue);    assertEquals("\"http://google.com/\"", gson.toJson(uri));  }  public void testUriDeserialization() {    String uriValue = "http://google.com/";    String json = '"' + uriValue + '"';    URI target = gson.fromJson(json, URI.class);    assertEquals(uriValue, target.toASCIIString());  }    public void testUuidSerialization() throws Exception {    String uuidValue = "c237bec1-19ef-4858-a98e-521cf0aad4c0";    UUID uuid = UUID.fromString(uuidValue);    assertEquals('"' + uuidValue + '"', gson.toJson(uuid));  }  public void testUuidDeserialization() {    String uuidValue = "c237bec1-19ef-4858-a98e-521cf0aad4c0";    String json = '"' + uuidValue + '"';    UUID target = gson.fromJson(json, UUID.class);    assertEquals(uuidValue, target.toString());  }  public void testLocaleSerializationWithLanguage() {    Locale target = new Locale("en");    assertEquals("\"en\"", gson.toJson(target));  }  public void testLocaleDeserializationWithLanguage() {    String json = "\"en\"";    Locale locale = gson.fromJson(json, Locale.class);    assertEquals("en", locale.getLanguage());  }  public void testLocaleSerializationWithLanguageCountry() {    Locale target = Locale.CANADA_FRENCH;    assertEquals("\"fr_CA\"", gson.toJson(target));  }  public void testLocaleDeserializationWithLanguageCountry() {    String json = "\"fr_CA\"";    Locale locale = gson.fromJson(json, Locale.class);    assertEquals(Locale.CANADA_FRENCH, locale);  }  public void testLocaleSerializationWithLanguageCountryVariant() {    Locale target = new Locale("de", "DE", "EURO");    String json = gson.toJson(target);    assertEquals("\"de_DE_EURO\"", json);  }  public void testLocaleDeserializationWithLanguageCountryVariant() {    String json = "\"de_DE_EURO\"";    Locale locale = gson.fromJson(json, Locale.class);    assertEquals("de", locale.getLanguage());    assertEquals("DE", locale.getCountry());    assertEquals("EURO", locale.getVariant());  }  public void testBigDecimalFieldSerialization() {    ClassWithBigDecimal target = new ClassWithBigDecimal("-122.01e-21");    String json = gson.toJson(target);    String actual = json.substring(json.indexOf(':') + 1, json.indexOf('}'));    assertEquals(target.value, new BigDecimal(actual));  }  public void testBigDecimalFieldDeserialization() {    ClassWithBigDecimal expected = new ClassWithBigDecimal("-122.01e-21");    String json = expected.getExpectedJson();    ClassWithBigDecimal actual = gson.fromJson(json, ClassWithBigDecimal.class);    assertEquals(expected.value, actual.value);  }  public void testBadValueForBigDecimalDeserialization() {    try {      gson.fromJson("{\"value\"=1.5e-1.0031}", ClassWithBigDecimal.class);      fail("Exponent of a BigDecimal must be an integer value.");    } catch (JsonParseException expected) { }  }  public void testBigIntegerFieldSerialization() {    ClassWithBigInteger target = new ClassWithBigInteger("23232323215323234234324324324324324324");    String json = gson.toJson(target);    assertEquals(target.getExpectedJson(), json);  }  public void testBigIntegerFieldDeserialization() {    ClassWithBigInteger expected = new ClassWithBigInteger("879697697697697697697697697697697697");    String json = expected.getExpectedJson();    ClassWithBigInteger actual = gson.fromJson(json, ClassWithBigInteger.class);    assertEquals(expected.value, actual.value);  }  public void testSetSerialization() throws Exception {    Gson gson = new Gson();    HashSet<String> s = new HashSet<String>();    s.add("blah");    String json = gson.toJson(s);    assertEquals("[\"blah\"]", json);    json = gson.toJson(s, Set.class);    assertEquals("[\"blah\"]", json);  }  public void testDefaultDateSerialization() {    Date now = new Date();    String json = gson.toJson(now);    assertEquals("\"" + DateFormat.getDateTimeInstance().format(now) + "\"", json);  }  public void testDefaultDateDeserialization() {    Date date = new Date();    String json = gson.toJson(date);    Date extracted = gson.fromJson(json, Date.class);    // Using comparison of string forms since the extracted date has lost the millisecond portion.    assertEquals(date.toString(), extracted.toString());      }    public void testDefaultDateSerializationUsingBuilder() throws Exception {    Gson gson = new GsonBuilder().create();    Date now = new Date();    String json = gson.toJson(now);    assertEquals("\"" + DateFormat.getDateTimeInstance().format(now) + "\"", json);  }  public void testDefaultDateDeserializationUsingBuilder() throws Exception {    Gson gson = new GsonBuilder().create();    Date now = new Date();    String json = gson.toJson(now);    Date extracted = gson.fromJson(json, Date.class);    assertEquals(now.toString(), extracted.toString());      }  public void testDefaultCalendarSerialization() throws Exception {    Gson gson = new GsonBuilder().create();    String json = gson.toJson(Calendar.getInstance());    assertTrue(json.contains("year"));    assertTrue(json.contains("month"));    assertTrue(json.contains("dayOfMonth"));    assertTrue(json.contains("hourOfDay"));    assertTrue(json.contains("minute"));    assertTrue(json.contains("second"));  }    public void testDefaultCalendarDeserialization() throws Exception {    Gson gson = new GsonBuilder().create();    String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}";    Calendar cal = gson.fromJson(json, Calendar.class);    assertEquals(2009, cal.get(Calendar.YEAR));    assertEquals(2, cal.get(Calendar.MONTH));    assertEquals(11, cal.get(Calendar.DAY_OF_MONTH));    assertEquals(14, cal.get(Calendar.HOUR_OF_DAY));    assertEquals(29, cal.get(Calendar.MINUTE));    assertEquals(23, cal.get(Calendar.SECOND));  }  public void testDefaultGregorianCalendarSerialization() throws Exception {    Gson gson = new GsonBuilder().create();    GregorianCalendar cal = new GregorianCalendar();    String json = gson.toJson(cal);    assertTrue(json.contains("year"));    assertTrue(json.contains("month"));    assertTrue(json.contains("dayOfMonth"));    assertTrue(json.contains("hourOfDay"));    assertTrue(json.contains("minute"));    assertTrue(json.contains("second"));  }    public void testDefaultGregorianCalendarDeserialization() throws Exception {    Gson gson = new GsonBuilder().create();    String json = "{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}";    GregorianCalendar cal = gson.fromJson(json, GregorianCalendar.class);    assertEquals(2009, cal.get(Calendar.YEAR));    assertEquals(2, cal.get(Calendar.MONTH));    assertEquals(11, cal.get(Calendar.DAY_OF_MONTH));    assertEquals(14, cal.get(Calendar.HOUR_OF_DAY));    assertEquals(29, cal.get(Calendar.MINUTE));    assertEquals(23, cal.get(Calendar.SECOND));  }    public void testDateSerializationWithPattern() throws Exception {    String pattern = "yyyy-MM-dd";    DateFormat formatter = new SimpleDateFormat(pattern);    Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create();    Date now = new Date();    String json = gson.toJson(now);    assertEquals("\"" + formatter.format(now) + "\"", json);  }    @SuppressWarnings("deprecation")  public void testDateDeserializationWithPattern() throws Exception {    String pattern = "yyyy-MM-dd";    Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL).setDateFormat(pattern).create();    Date now = new Date();    String json = gson.toJson(now);    Date extracted = gson.fromJson(json, Date.class);    assertEquals(now.getYear(), extracted.getYear());        assertEquals(now.getMonth(), extracted.getMonth());        assertEquals(now.getDay(), extracted.getDay());      }    private static class ClassWithBigDecimal {    BigDecimal value;    // For use by Gson    @SuppressWarnings("unused")    private ClassWithBigDecimal() { }    ClassWithBigDecimal(String value) {      this.value = new BigDecimal(value);    }    String getExpectedJson() {      return "{\"value\":" + value.toEngineeringString() + "}";    }  }  private static class ClassWithBigInteger {    BigInteger value;    // For use by Gson    @SuppressWarnings("unused")    private ClassWithBigInteger() { }    ClassWithBigInteger(String value) {      this.value = new BigInteger(value);    }    String getExpectedJson() {      return "{\"value\":" + value + "}";    }  }    public void testPropertiesSerialization() {    Properties props = new Properties();    props.setProperty("foo", "bar");    String json = gson.toJson(props);    String expected = "{\"foo\":\"bar\"}";    assertEquals(expected, json);  }    public void testPropertiesDeserialization() {    String json = "{foo:'bar'}";    Properties props = gson.fromJson(json, Properties.class);    assertEquals("bar", props.getProperty("foo"));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import junit.framework.TestCase;/** * Performs some functional testing to ensure GSON infrastructure properly serializes/deserializes * fields that either should or should not be included in the output based on the GSON * configuration. * * @author Joel Leitch */public class FieldExclusionTest extends TestCase {  private static final String VALUE = "blah_1234";  private Outer outer;    @Override  protected void setUp() throws Exception {    super.setUp();    outer = new Outer();  }    public void testDefaultInnerClassExclusion() throws Exception {    Gson gson = new Gson();    Outer.Inner target = outer.new Inner(VALUE);    String result = gson.toJson(target);    assertEquals(target.toJson(), result);        gson = new GsonBuilder().create();    target = outer.new Inner(VALUE);    result = gson.toJson(target);    assertEquals(target.toJson(), result);  }    public void testInnerClassExclusion() throws Exception {    Gson gson = new GsonBuilder().disableInnerClassSerialization().create();    Outer.Inner target = outer.new Inner(VALUE);    String result = gson.toJson(target);    assertEquals("", result);  }    public void testDefaultNestedStaticClassIncluded() throws Exception {    Gson gson = new Gson();    Outer.Inner target = outer.new Inner(VALUE);    String result = gson.toJson(target);    assertEquals(target.toJson(), result);        gson = new GsonBuilder().create();    target = outer.new Inner(VALUE);    result = gson.toJson(target);    assertEquals(target.toJson(), result);  }    private static class Outer {    private class Inner extends NestedClass {      public Inner(String value) {        super(value);      }    }          }    private static class NestedClass {    private final String value;    public NestedClass(String value) {      this.value = value;    }        public String toJson() {      return "{\"value\":\"" + value + "\"}";    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.JsonParseException;import com.google.gson.common.MoreAsserts;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.Collections;import java.util.HashSet;import java.util.Iterator;import java.util.LinkedList;import java.util.List;import java.util.Queue;import java.util.Set;/** * Functional tests for Json serialization and deserialization of collections. * * @author Inderjeet Singh * @author Joel Leitch */public class CollectionTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testTopLevelCollectionOfIntegersSerialization() {    Collection<Integer> target = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);    Type targetType = new TypeToken<Collection<Integer>>() {}.getType();    String json = gson.toJson(target, targetType);    assertEquals("[1,2,3,4,5,6,7,8,9]", json);  }  public void testTopLevelCollectionOfIntegersDeserialization() {    String json = "[0,1,2,3,4,5,6,7,8,9]";    Type collectionType = new TypeToken<Collection<Integer>>() { }.getType();    Collection<Integer> target = gson.fromJson(json, collectionType);    int[] expected = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};    MoreAsserts.assertEquals(expected, toIntArray(target));  }  public void testTopLevelListOfIntegerCollectionsDeserialization() throws Exception {    String json = "[[1,2,3],[4,5,6],[7,8,9]]";    Type collectionType = new TypeToken<Collection<Collection<Integer>>>() {}.getType();    List<Collection<Integer>> target = gson.fromJson(json, collectionType);    int[][] expected = new int[3][3];    for (int i = 0; i < 3; ++i) {      int start = (3 * i) + 1;      for (int j = 0; j < 3; ++j) {        expected[i][j] = start + j;      }    }    for (int i = 0; i < 3; i++) {      MoreAsserts.assertEquals(expected[i], toIntArray(target.get(i)));    }  }    public void testLinkedListSerialization() {    List<String> list = new LinkedList<String>();    list.add("a1");    list.add("a2");    Type linkedListType = new TypeToken<LinkedList<String>>() {}.getType();    String json = gson.toJson(list, linkedListType);    assertTrue(json.contains("a1"));    assertTrue(json.contains("a2"));  }  public void testLinkedListDeserialization() {    String json = "['a1','a2']";    Type linkedListType = new TypeToken<LinkedList<String>>() {}.getType();    List<String> list = gson.fromJson(json, linkedListType);    assertEquals("a1", list.get(0));    assertEquals("a2", list.get(1));  }  public void testQueueSerialization() {    Queue<String> queue = new LinkedList<String>();    queue.add("a1");    queue.add("a2");    Type queueType = new TypeToken<Queue<String>>() {}.getType();    String json = gson.toJson(queue, queueType);    assertTrue(json.contains("a1"));    assertTrue(json.contains("a2"));  }  public void testQueueDeserialization() {    String json = "['a1','a2']";    Type queueType = new TypeToken<Queue<String>>() {}.getType();    Queue<String> queue = gson.fromJson(json, queueType);    assertEquals("a1", queue.element());     queue.remove();    assertEquals("a2", queue.element());  }  public void testNullsInListSerialization() {    List<String> list = new ArrayList<String>();    list.add("foo");    list.add(null);    list.add("bar");    String expected = "[\"foo\",null,\"bar\"]";    Type typeOfList = new TypeToken<List<String>>() {}.getType();    String json = gson.toJson(list, typeOfList);    assertEquals(expected, json);  }  public void testNullsInListDeserialization() {    List<String> expected = new ArrayList<String>();    expected.add("foo");    expected.add(null);    expected.add("bar");    String json = "[\"foo\",null,\"bar\"]";    Type expectedType = new TypeToken<List<String>>() {}.getType();    List<String> target = gson.fromJson(json, expectedType);    for (int i = 0; i < expected.size(); ++i) {      assertEquals(expected.get(i), target.get(i));    }  }  public void testCollectionOfObjectSerialization() {    List<Object> target = new ArrayList<Object>();    target.add("Hello");    target.add("World");    assertEquals("[\"Hello\",\"World\"]", gson.toJson(target));        Type type = new TypeToken<List<Object>>() {}.getType();    assertEquals("[\"Hello\",\"World\"]", gson.toJson(target, type));  }  public void testCollectionOfStringsSerialization() {    List<String> target = new ArrayList<String>();    target.add("Hello");    target.add("World");    assertEquals("[\"Hello\",\"World\"]", gson.toJson(target));  }  public void testCollectionOfBagOfPrimitivesSerialization() {    List<BagOfPrimitives> target = new ArrayList<BagOfPrimitives>();    BagOfPrimitives objA = new BagOfPrimitives(3L, 1, true, "blah");    BagOfPrimitives objB = new BagOfPrimitives(2L, 6, false, "blahB");    target.add(objA);    target.add(objB);    String result = gson.toJson(target);    assertTrue(result.startsWith("["));    assertTrue(result.endsWith("]"));    for (BagOfPrimitives obj : target) {      assertTrue(result.contains(obj.getExpectedJson()));    }  }  public void testCollectionOfStringsDeserialization() {    String json = "[\"Hello\",\"World\"]";    Type collectionType = new TypeToken<Collection<String>>() { }.getType();    Collection<String> target = gson.fromJson(json, collectionType);    assertTrue(target.contains("Hello"));    assertTrue(target.contains("World"));  }  public void testRawCollectionOfIntegersSerialization() {    Collection<Integer> target = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);    assertEquals("[1,2,3,4,5,6,7,8,9]", gson.toJson(target));  }  @SuppressWarnings("unchecked")  public void testRawCollectionSerialization() {    BagOfPrimitives bag1 = new BagOfPrimitives();    Collection target = Arrays.asList(bag1, bag1);    String json = gson.toJson(target);    assertTrue(json.contains(bag1.getExpectedJson()));  }  public void testRawCollectionDeserializationNotAlllowed() {    String json = "[0,1,2,3,4,5,6,7,8,9]";    try {        gson.fromJson(json, Collection.class);        fail("Can not deserialize a non-genericized collection.");    } catch (JsonParseException expected) { }    json = "[\"Hello\", \"World\"]";    try {      gson.fromJson(json, Collection.class);      fail("Can not deserialize a non-genericized collection.");    } catch (JsonParseException expected) { }  }  @SuppressWarnings("unchecked")  public void testRawCollectionOfBagOfPrimitivesNotAllowed() {    try {      BagOfPrimitives bag = new BagOfPrimitives(10, 20, false, "stringValue");      String json = '[' + bag.getExpectedJson() + ',' + bag.getExpectedJson() + ']';      Collection target = gson.fromJson(json, Collection.class);      assertEquals(2, target.size());      for (BagOfPrimitives bag1 : (Collection<BagOfPrimitives>) target) {        assertEquals(bag.getExpectedJson(), bag1.getExpectedJson());      }      fail("Raw collection of objects should not work");    } catch (JsonParseException expected) {    }  }    public void testWildcardPrimitiveCollectionSerilaization() throws Exception {    Collection<? extends Integer> target = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);    Type collectionType = new TypeToken<Collection<? extends Integer>>() { }.getType();    String json = gson.toJson(target, collectionType);    assertEquals("[1,2,3,4,5,6,7,8,9]", json);        json = gson.toJson(target);    assertEquals("[1,2,3,4,5,6,7,8,9]", json);  }    public void testWildcardPrimitiveCollectionDeserilaization() throws Exception {    String json = "[1,2,3,4,5,6,7,8,9]";    Type collectionType = new TypeToken<Collection<? extends Integer>>() { }.getType();    Collection<? extends Integer> target = gson.fromJson(json, collectionType);    assertEquals(9, target.size());    assertTrue(target.contains(1));    assertTrue(target.contains(9));  }    public void testWildcardCollectionField() throws Exception {    Collection<BagOfPrimitives> collection = new ArrayList<BagOfPrimitives>();    BagOfPrimitives objA = new BagOfPrimitives(3L, 1, true, "blah");    BagOfPrimitives objB = new BagOfPrimitives(2L, 6, false, "blahB");    collection.add(objA);    collection.add(objB);        ObjectWithWildcardCollection target = new ObjectWithWildcardCollection(collection);    String json = gson.toJson(target);    assertTrue(json.contains(objA.getExpectedJson()));    assertTrue(json.contains(objB.getExpectedJson()));        target = gson.fromJson(json, ObjectWithWildcardCollection.class);    Collection<? extends BagOfPrimitives> deserializedCollection = target.getCollection();    assertEquals(2, deserializedCollection.size());    assertTrue(deserializedCollection.contains(objA));    assertTrue(deserializedCollection.contains(objB));  }  @SuppressWarnings("unchecked")  private static int[] toIntArray(Collection collection) {    int[] ints = new int[collection.size()];    int i = 0;    for (Iterator iterator = collection.iterator(); iterator.hasNext(); ++i) {      Object obj = iterator.next();      if (obj instanceof Integer) {        ints[i] = ((Integer)obj).intValue();      } else if (obj instanceof Long) {        ints[i] = ((Long)obj).intValue();      }    }    return ints;  }  private static class ObjectWithWildcardCollection {    private final Collection<? extends BagOfPrimitives> collection;    // For use by Gson    @SuppressWarnings({ "unchecked", "unused" })    public ObjectWithWildcardCollection() {      this(Collections.EMPTY_LIST);    }        public ObjectWithWildcardCollection(Collection<? extends BagOfPrimitives> collection) {      this.collection = collection;    }        public Collection<? extends BagOfPrimitives> getCollection() {      return collection;    }  }    private static class Entry {    int value;    // For use by Gson    @SuppressWarnings("unused")    private Entry() {      this(10);    }    Entry(int value) {      this.value = value;    }  }  public void testSetSerialization() {    Set<Entry> set = new HashSet<Entry>();     set.add(new Entry(1));    set.add(new Entry(2));        String json = gson.toJson(set);    assertTrue(json.contains("1"));    assertTrue(json.contains("2"));  }  public void testSetDeserialization() {    String json = "[{value:1},{value:2}]";    Type type = new TypeToken<Set<Entry>>() {}.getType();            Set<Entry> set = gson.fromJson(json, type);    assertEquals(2, set.size());    for (Entry entry : set) {      assertTrue(entry.value == 1 || entry.value == 2);    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import java.lang.reflect.Type;import java.util.Arrays;import java.util.LinkedHashMap;import java.util.LinkedList;import java.util.List;import java.util.Map;import junit.framework.TestCase;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.common.TestTypes.ArrayOfObjects;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.reflect.TypeToken;/** * Functional tests for pretty printing option. * * @author Inderjeet Singh * @author Joel Leitch */public class PrettyPrintingTest extends TestCase {  private static int PRINT_MARGIN = 80;  private static int RIGHT_MARGIN = 4;  private static final boolean DEBUG = false;  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new GsonBuilder().setPrettyPrinting().create();  }  public void testPrettyPrintList() {    BagOfPrimitives b = new BagOfPrimitives();    List<BagOfPrimitives> listOfB = new LinkedList<BagOfPrimitives>();    for (int i = 0; i < 15; ++i) {      listOfB.add(b);    }    Type typeOfSrc = new TypeToken<List<BagOfPrimitives>>() {}.getType();    String json = gson.toJson(listOfB, typeOfSrc);    print(json);    assertPrintMargin(json);  }  public void testPrettyPrintArrayOfObjects() {    ArrayOfObjects target = new ArrayOfObjects();    String json = gson.toJson(target);    print(json);    assertPrintMargin(json);  }  public void testPrettyPrintArrayOfPrimitives() {    int[] ints = new int[] { 1, 2, 3, 4, 5 };    String json = gson.toJson(ints);    assertEquals("[1,2,3,4,5]\n", json);  }  public void testPrettyPrintArrayOfPrimitiveArrays() {    int[][] ints = new int[][] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 },        { 9, 0 }, { 10 } };    String json = gson.toJson(ints);    assertEquals("[[1,2],[3,4],[5,6],[7,8],[9,0],[10]]\n", json);  }  public void testPrettyPrintListOfPrimitiveArrays() {    List<Integer[]> list = Arrays.asList(new Integer[][] { { 1, 2 }, { 3, 4 },        { 5, 6 }, { 7, 8 }, { 9, 0 }, { 10 } });    String json = gson.toJson(list);    assertEquals("[[1,2],[3,4],[5,6],[7,8],[9,0],[10]]\n", json);  }    public void testMap() {    Map<String, Integer> map = new LinkedHashMap<String, Integer>();    map.put("abc", 1);    map.put("def", 5);    String json = gson.toJson(map);    assertEquals("{\"abc\":1,\"def\":5}\n", json);  }  public void testMultipleArrays() {    int[][][] ints = new int[][][] { { { 1 }, { 2 } } };    String json = gson.toJson(ints);    assertEquals("[[[1],[2]]]\n", json);  }  private void print(String msg) {    if (DEBUG) {      System.out.println(msg);    }  }  private void assertPrintMargin(String str) {    int position = 0;    char[] chars = str.toCharArray();    for (int i = 0; i < chars.length; ++i, ++position) {      char c = chars[i];      if (c == '\n') {        position = 0;      }      assertTrue(position <= PRINT_MARGIN - RIGHT_MARGIN + 1);    }  }}
package com.google.gson.functional;import java.util.Map;import java.util.Set;import java.util.Map.Entry;import junit.framework.TestCase;import com.google.gson.Gson;import com.google.gson.JsonElement;import com.google.gson.JsonObject;import com.google.gson.JsonPrimitive;import com.google.gson.common.TestTypes.BagOfPrimitives;/** * Functional tests for {@link Gson#toJsonTree(Object)} and  * {@link Gson#toJsonTree(Object, java.lang.reflect.Type)} *  * @author Inderjeet Singh * @author Joel Leitch */public class JsonTreeTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testToJsonTree() {    BagOfPrimitives bag = new BagOfPrimitives(10L, 5, false, "foo");    JsonElement json = gson.toJsonTree(bag);    assertTrue(json.isJsonObject());    JsonObject obj = json.getAsJsonObject();    Set<Entry<String, JsonElement>> children = obj.entrySet();    assertEquals(4, children.size());    assertContains(obj, new JsonPrimitive(10L));    assertContains(obj, new JsonPrimitive(5));    assertContains(obj, new JsonPrimitive(false));    assertContains(obj, new JsonPrimitive("foo"));  }  public void testToJsonTreeObjectType() {    SubTypeOfBagOfPrimitives bag = new SubTypeOfBagOfPrimitives(10L, 5, false, "foo", 1.4F);    JsonElement json = gson.toJsonTree(bag, BagOfPrimitives.class);    assertTrue(json.isJsonObject());    JsonObject obj = json.getAsJsonObject();    Set<Entry<String, JsonElement>> children = obj.entrySet();    assertEquals(4, children.size());    assertContains(obj, new JsonPrimitive(10L));    assertContains(obj, new JsonPrimitive(5));    assertContains(obj, new JsonPrimitive(false));    assertContains(obj, new JsonPrimitive("foo"));  }  public void testJsonTreeToString() {    SubTypeOfBagOfPrimitives bag = new SubTypeOfBagOfPrimitives(10L, 5, false, "foo", 1.4F);    String json1 = gson.toJson(bag);    JsonElement jsonElement = gson.toJsonTree(bag, SubTypeOfBagOfPrimitives.class);    String json2 = gson.toJson(jsonElement);    assertEquals(json1, json2);  }  private void assertContains(JsonObject json, JsonPrimitive child) {    for (Map.Entry<String, JsonElement> entry : json.entrySet()) {      JsonElement node = entry.getValue();      if (node.isJsonPrimitive()) {        if (node.getAsJsonPrimitive().equals(child)) {          return;        }      }    }    fail();  }    private static class SubTypeOfBagOfPrimitives extends BagOfPrimitives {    @SuppressWarnings("unused")    float f = 1.2F;    public SubTypeOfBagOfPrimitives(long l, int i, boolean b, String string, float f) {      super(l, i, b, string);      this.f = f;    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import java.lang.reflect.Type;import java.util.ArrayList;import java.util.Collection;import java.util.LinkedList;import java.util.List;import java.util.Queue;import java.util.Set;import java.util.SortedSet;import java.util.TreeSet;import junit.framework.TestCase;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.InstanceCreator;import com.google.gson.common.TestTypes.ArrayOfObjects;import com.google.gson.common.TestTypes.BagOfPrimitiveWrappers;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.common.TestTypes.ClassOverridingEquals;import com.google.gson.common.TestTypes.ClassWithArray;import com.google.gson.common.TestTypes.ClassWithNoFields;import com.google.gson.common.TestTypes.ClassWithObjects;import com.google.gson.common.TestTypes.ClassWithTransientFields;import com.google.gson.common.TestTypes.Nested;import com.google.gson.common.TestTypes.PrimitiveArray;/** * Functional tests for Json serialization and deserialization of regular classes. * * @author Inderjeet Singh * @author Joel Leitch */public class ObjectTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testJsonInSingleQuotesDeserialization() {    String json = "{'stringValue':'no message','intValue':10,'longValue':20}";    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);    assertEquals("no message", target.stringValue);    assertEquals(10, target.intValue);    assertEquals(20, target.longValue);  }    public void testJsonInMixedQuotesDeserialization() {    String json = "{\"stringValue\":'no message','intValue':10,'longValue':20}";    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);    assertEquals("no message", target.stringValue);    assertEquals(10, target.intValue);    assertEquals(20, target.longValue);  }    public void testBagOfPrimitivesSerialization() throws Exception {    BagOfPrimitives target = new BagOfPrimitives(10, 20, false, "stringValue");    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testBagOfPrimitivesDeserialization() throws Exception {    BagOfPrimitives src = new BagOfPrimitives(10, 20, false, "stringValue");    String json = src.getExpectedJson();    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);    assertEquals(json, target.getExpectedJson());  }  public void testBagOfPrimitiveWrappersSerialization() throws Exception {    BagOfPrimitiveWrappers target = new BagOfPrimitiveWrappers(10L, 20, false);    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testBagOfPrimitiveWrappersDeserialization() throws Exception {    BagOfPrimitiveWrappers target = new BagOfPrimitiveWrappers(10L, 20, false);    String jsonString = target.getExpectedJson();    target = gson.fromJson(jsonString, BagOfPrimitiveWrappers.class);    assertEquals(jsonString, target.getExpectedJson());  }  public void testDirectedAcyclicGraphSerialization() throws Exception {    ContainsReferenceToSelfType a = new ContainsReferenceToSelfType();    ContainsReferenceToSelfType b = new ContainsReferenceToSelfType();    ContainsReferenceToSelfType c = new ContainsReferenceToSelfType();    a.children.add(b);    a.children.add(c);    b.children.add(c);    assertNotNull(gson.toJson(a));  }  public void testDirectedAcyclicGraphDeserialization() throws Exception {    String json = "{\"children\":[{\"children\":[{\"children\":[]}]},{\"children\":[]}]}";    ContainsReferenceToSelfType target = gson.fromJson(json, ContainsReferenceToSelfType.class);    assertNotNull(target);    assertEquals(2, target.children.size());  }  public void testClassWithTransientFieldsSerialization() throws Exception {    ClassWithTransientFields<Long> target = new ClassWithTransientFields<Long>(1L);    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  @SuppressWarnings("unchecked")  public void testClassWithTransientFieldsDeserialization() throws Exception {    String json = "{\"longValue\":[1]}";    ClassWithTransientFields target = gson.fromJson(json, ClassWithTransientFields.class);    assertEquals(json, target.getExpectedJson());  }  @SuppressWarnings("unchecked")  public void testClassWithTransientFieldsDeserializationTransientFieldsPassedInJsonAreIgnored()      throws Exception {    String json = "{\"transientLongValue\":1,\"longValue\":[1]}";    ClassWithTransientFields target = gson.fromJson(json, ClassWithTransientFields.class);    assertFalse(target.transientLongValue != 1);  }  public void testClassWithNoFieldsSerialization() throws Exception {    assertEquals("{}", gson.toJson(new ClassWithNoFields()));  }  public void testClassWithNoFieldsDeserialization() throws Exception {    String json = "{}";    ClassWithNoFields target = gson.fromJson(json, ClassWithNoFields.class);    ClassWithNoFields expected = new ClassWithNoFields();    assertEquals(expected, target);  }  public void testNestedSerialization() throws Exception {    Nested target = new Nested(new BagOfPrimitives(10, 20, false, "stringValue"),       new BagOfPrimitives(30, 40, true, "stringValue"));    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testNestedDeserialization() throws Exception {    String json = "{\"primitive1\":{\"longValue\":10,\"intValue\":20,\"booleanValue\":false,"        + "\"stringValue\":\"stringValue\"},\"primitive2\":{\"longValue\":30,\"intValue\":40,"        + "\"booleanValue\":true,\"stringValue\":\"stringValue\"}}";    Nested target = gson.fromJson(json, Nested.class);    assertEquals(json, target.getExpectedJson());  }  public void testInheritenceSerialization() throws Exception {    SubTypeOfNested target = new SubTypeOfNested(new BagOfPrimitives(10, 20, false, "stringValue"),        new BagOfPrimitives(30, 40, true, "stringValue"));    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testInheritenceDeserialization() throws Exception {    String json = "{\"value\":5,\"primitive1\":{\"longValue\":10,\"intValue\":20,"        + "\"booleanValue\":false,\"stringValue\":\"stringValue\"},\"primitive2\":"        + "{\"longValue\":30,\"intValue\":40,\"booleanValue\":true,"        + "\"stringValue\":\"stringValue\"}}";    SubTypeOfNested target = gson.fromJson(json, SubTypeOfNested.class);    assertEquals(json, target.getExpectedJson());  }  public void testNullSerialization() throws Exception {    assertEquals("", gson.toJson(null));  }  public void testNullDeserialization() throws Exception {    Object object = gson.fromJson("", Object.class);    assertNull(object);  }  public void testNullFieldsSerialization() throws Exception {    Nested target = new Nested(new BagOfPrimitives(10, 20, false, "stringValue"), null);    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testNullFieldsDeserialization() throws Exception {    String json = "{\"primitive1\":{\"longValue\":10,\"intValue\":20,\"booleanValue\":false"        + ",\"stringValue\":\"stringValue\"}}";    Nested target = gson.fromJson(json, Nested.class);    assertEquals(json, target.getExpectedJson());  }  public void testArrayOfObjectsSerialization() throws Exception {    ArrayOfObjects target = new ArrayOfObjects();    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testArrayOfObjectsDeserialization() throws Exception {    String json = new ArrayOfObjects().getExpectedJson();    ArrayOfObjects target = gson.fromJson(json, ArrayOfObjects.class);    assertEquals(json, target.getExpectedJson());  }  public void testArrayOfArraysSerialization() throws Exception {    ArrayOfArrays target = new ArrayOfArrays();    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testArrayOfArraysDeserialization() throws Exception {    String json = new ArrayOfArrays().getExpectedJson();    ArrayOfArrays target = gson.fromJson(json, ArrayOfArrays.class);    assertEquals(json, target.getExpectedJson());  }  public void testSubInterfacesOfCollectionSerialization() throws Exception {    List<Integer> list = new LinkedList<Integer>();    list.add(0);    list.add(1);    list.add(2);    list.add(3);    Queue<Long> queue = new LinkedList<Long>();    queue.add(0L);    queue.add(1L);    queue.add(2L);    queue.add(3L);    Set<Float> set = new TreeSet<Float>();    set.add(0.1F);    set.add(0.2F);    set.add(0.3F);    set.add(0.4F);    SortedSet<Character> sortedSet = new TreeSet<Character>();    sortedSet.add('a');    sortedSet.add('b');    sortedSet.add('c');    sortedSet.add('d');    ClassWithSubInterfacesOfCollection target =        new ClassWithSubInterfacesOfCollection(list, queue, set, sortedSet);    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testSubInterfacesOfCollectionDeserialization() throws Exception {    String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4],"        + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]"        + "}";    ClassWithSubInterfacesOfCollection target =       gson.fromJson(json, ClassWithSubInterfacesOfCollection.class);    assertTrue(target.listContains(0, 1, 2, 3));    assertTrue(target.queueContains(0, 1, 2, 3));    assertTrue(target.setContains(0.1F, 0.2F, 0.3F, 0.4F));    assertTrue(target.sortedSetContains('a', 'b', 'c', 'd'));  }  public void testArrayOfObjectsAsFields() throws Exception {    ClassWithObjects classWithObjects = new ClassWithObjects();    BagOfPrimitives bagOfPrimitives = new BagOfPrimitives();    String stringValue = "someStringValueInArray";    String classWithObjectsJson = gson.toJson(classWithObjects);    String bagOfPrimitivesJson = gson.toJson(bagOfPrimitives);        ClassWithArray classWithArray = new ClassWithArray(        new Object[] { stringValue, classWithObjects, bagOfPrimitives });    String json = gson.toJson(classWithArray);    assertTrue(json.contains(classWithObjectsJson));    assertTrue(json.contains(bagOfPrimitivesJson));    assertTrue(json.contains("\"" + stringValue + "\""));  }  /**   * Created in response to Issue 14: http://code.google.com/p/google-gson/issues/detail?id=14   */  public void testNullArraysDeserialization() throws Exception {    String json = "{\"array\": null}";    ClassWithArray target = gson.fromJson(json, ClassWithArray.class);    assertNull(target.array);  }  /**   * Created in response to Issue 14: http://code.google.com/p/google-gson/issues/detail?id=14   */  public void testNullObjectFieldsDeserialization() throws Exception {    String json = "{\"bag\": null}";    ClassWithObjects target = gson.fromJson(json, ClassWithObjects.class);    assertNull(target.bag);  }  public void testEmptyCollectionInAnObjectDeserialization() throws Exception {    String json = "{\"children\":[]}";    ContainsReferenceToSelfType target = gson.fromJson(json, ContainsReferenceToSelfType.class);    assertNotNull(target);    assertTrue(target.children.isEmpty());  }  public void testPrimitiveArrayInAnObjectDeserialization() throws Exception {    String json = "{\"longArray\":[0,1,2,3,4,5,6,7,8,9]}";    PrimitiveArray target = gson.fromJson(json, PrimitiveArray.class);    assertEquals(json, target.getExpectedJson());  }  /**   * Created in response to Issue 14: http://code.google.com/p/google-gson/issues/detail?id=14   */  public void testNullPrimitiveFieldsDeserialization() throws Exception {    String json = "{\"longValue\":null}";    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);    assertEquals(BagOfPrimitives.DEFAULT_VALUE, target.longValue);  }  public void testEmptyCollectionInAnObjectSerialization() throws Exception {    ContainsReferenceToSelfType target = new ContainsReferenceToSelfType();    assertEquals("{\"children\":[]}", gson.toJson(target));  }  public void testCircularSerialization() throws Exception {    ContainsReferenceToSelfType a = new ContainsReferenceToSelfType();    ContainsReferenceToSelfType b = new ContainsReferenceToSelfType();    a.children.add(b);    b.children.add(a);    try {      gson.toJson(a);      fail("Circular types should not get printed!");    } catch (IllegalStateException expected) { }  }  public void testSelfReferenceSerialization() throws Exception {    ClassOverridingEquals objA = new ClassOverridingEquals();    objA.ref = objA;    try {      gson.toJson(objA);      fail("Circular reference to self can not be serialized!");    } catch (IllegalStateException expected) { }  }  public void testPrivateNoArgConstructorDeserialization() throws Exception {    ClassWithPrivateNoArgsConstructor target =      gson.fromJson("{\"a\":20}", ClassWithPrivateNoArgsConstructor.class);    assertEquals(20, target.a);  }  public void testAnonymousLocalClassesSerialization() throws Exception {    assertEquals("", gson.toJson(new ClassWithNoFields() {      // empty anonymous class    }));  }  public void testPrimitiveArrayFieldSerialization() {    PrimitiveArray target = new PrimitiveArray(new long[] { 1L, 2L, 3L });    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  /**   * Tests that a class field with type Object can be serialized properly.    * See issue 54   */  public void testClassWithObjectFieldSerialization() {    ClassWithObjectField obj = new ClassWithObjectField();    obj.member = "abc";    String json = gson.toJson(obj);    assertTrue(json.contains("abc"));  }  private static class ClassWithObjectField {    @SuppressWarnings("unused")    Object member;  }    public void testInnerClassSerialization() {        Parent p = new Parent();    Parent.Child c = p.new Child();    String json = gson.toJson(c);    assertTrue(json.contains("value2"));    assertFalse(json.contains("value1"));  }     public void testInnerClassDeserialization() {    final Parent p = new Parent();    Gson gson = new GsonBuilder().registerTypeAdapter(        Parent.Child.class, new InstanceCreator<Parent.Child>() {      public Parent.Child createInstance(Type type) {        return p.new Child();      }          }).create();    String json = "{'value2':3}";    Parent.Child c = gson.fromJson(json, Parent.Child.class);    assertEquals(3, c.value2);  }     private static class Parent {    @SuppressWarnings("unused")    int value1 = 1;    private class Child {      int value2 = 2;    }  }    private static class ClassWithSubInterfacesOfCollection {    private List<Integer> list;    private Queue<Long> queue;    private Set<Float> set;    private SortedSet<Character> sortedSet;    // For use by Gson    @SuppressWarnings("unused")    private ClassWithSubInterfacesOfCollection() {    }    public ClassWithSubInterfacesOfCollection(List<Integer> list, Queue<Long> queue, Set<Float> set,        SortedSet<Character> sortedSet) {      this.list = list;      this.queue = queue;      this.set = set;      this.sortedSet = sortedSet;    }    boolean listContains(int... values) {      for (int value : values) {        if (!list.contains(value)) {          return false;        }      }      return true;    }        boolean queueContains(long... values) {      for (long value : values) {        if (!queue.contains(value)) {          return false;        }      }      return true;          }        boolean setContains(float... values) {      for (float value : values) {        if (!set.contains(value)) {          return false;        }      }      return true;    }    boolean sortedSetContains(char... values) {      for (char value : values) {        if (!sortedSet.contains(value)) {          return false;        }      }      return true;          }        public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{");      sb.append("\"list\":");      append(sb, list).append(",");      sb.append("\"queue\":");      append(sb, queue).append(",");      sb.append("\"set\":");      append(sb, set).append(",");      sb.append("\"sortedSet\":");      append(sb, sortedSet);      sb.append("}");      return sb.toString();    }    private StringBuilder append(StringBuilder sb, Collection<?> c) {      sb.append("[");      boolean first = true;      for (Object o : c) {        if (!first) {          sb.append(",");        } else {          first = false;        }        if (o instanceof String || o instanceof Character) {          sb.append('\"');        }        sb.append(o.toString());        if (o instanceof String || o instanceof Character) {          sb.append('\"');        }      }      sb.append("]");      return sb;    }  }  private static class ContainsReferenceToSelfType {    public Collection<ContainsReferenceToSelfType> children =        new ArrayList<ContainsReferenceToSelfType>();  }  private static class SubTypeOfNested extends Nested {    private final long value = 5;    // Used by Gson    @SuppressWarnings("unused")    private SubTypeOfNested() {      this(null, null);    }    public SubTypeOfNested(BagOfPrimitives primitive1, BagOfPrimitives primitive2) {      super(primitive1, primitive2);    }    @Override    public void appendFields(StringBuilder sb) {      sb.append("\"value\":").append(value).append(",");      super.appendFields(sb);    }  }  private static class ArrayOfArrays {    private final BagOfPrimitives[][] elements;    public ArrayOfArrays() {      elements = new BagOfPrimitives[3][2];      for (int i = 0; i < elements.length; ++i) {        BagOfPrimitives[] row = elements[i];        for (int j = 0; j < row.length; ++j) {          row[j] = new BagOfPrimitives(i+j, i*j, false, i+"_"+j);        }      }    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder("{\"elements\":[");      boolean first = true;      for (BagOfPrimitives[] row : elements) {        if (first) {          first = false;        } else {          sb.append(",");        }        boolean firstOfRow = true;        sb.append("[");        for (BagOfPrimitives element : row) {          if (firstOfRow) {            firstOfRow = false;          } else {            sb.append(",");          }          sb.append(element.getExpectedJson());        }        sb.append("]");      }      sb.append("]}");      return sb.toString();    }  }  private static class ClassWithPrivateNoArgsConstructor {    public int a;    private ClassWithPrivateNoArgsConstructor() {      a = 10;    }  }    /**   * In response to Issue 41 http://code.google.com/p/google-gson/issues/detail?id=41   */  public void testObjectFieldNamesWithoutQuotesDeserialization() {    String json = "{longValue:1,'booleanValue':true,\"stringValue\":'bar'}";    BagOfPrimitives bag = gson.fromJson(json, BagOfPrimitives.class);    assertEquals(1, bag.longValue);    assertTrue(bag.booleanValue);    assertEquals("bar", bag.stringValue);  }    public void testStringFieldWithNumberValueDeserialization() {    String json = "{\"stringValue\":1}";    BagOfPrimitives bag = gson.fromJson(json, BagOfPrimitives.class);    assertEquals("1", bag.stringValue);        json = "{\"stringValue\":1.5E+6}";    bag = gson.fromJson(json, BagOfPrimitives.class);    assertEquals("1.5E+6", bag.stringValue);        json = "{\"stringValue\":true}";    bag = gson.fromJson(json, BagOfPrimitives.class);    assertEquals("true", bag.stringValue);  }  /**   * Created to reproduce issue 140   */  public void testStringFieldWithEmptyValueSerialization() {    ClassWithEmptyStringFields target = new ClassWithEmptyStringFields();    target.a = "5794749";    String json = gson.toJson(target);    assertTrue(json.contains("\"a\":\"5794749\""));    assertTrue(json.contains("\"b\":\"\""));    assertTrue(json.contains("\"c\":\"\""));  }  /**   * Created to reproduce issue 140   */  public void testStringFieldWithEmptyValueDeserialization() {    String json = "{a:\"5794749\",b:\"\",c:\"\"}";    ClassWithEmptyStringFields target = gson.fromJson(json, ClassWithEmptyStringFields.class);    assertEquals("5794749", target.a);    assertEquals("", target.b);    assertEquals("", target.c);  }  private static class ClassWithEmptyStringFields {    String a = "";    String b = "";    String c = "";  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.InstanceCreator;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.Collection;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;import java.util.TreeMap;/** * Functional test for Json serialization and deserialization for Maps * * @author Inderjeet Singh * @author Joel Leitch */public class MapTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testMapSerialization() {    Map<String, Integer> map = new LinkedHashMap<String, Integer>();    map.put("a", 1);    map.put("b", 2);    Type typeOfMap = new TypeToken<Map<String, Integer>>() {}.getType();    String json = gson.toJson(map, typeOfMap);    assertTrue(json.contains("\"a\":1"));    assertTrue(json.contains("\"b\":2"));  }  public void testMapDeserialization() {    String json = "{\"a\":1,\"b\":2}";    Type typeOfMap = new TypeToken<Map<String,Integer>>(){}.getType();    Map<String, Integer> target = gson.fromJson(json, typeOfMap);    assertEquals(1, target.get("a").intValue());    assertEquals(2, target.get("b").intValue());  }  @SuppressWarnings("unchecked")  public void testRawMapSerialization() {    Map map = new LinkedHashMap();    map.put("a", 1);    map.put("b", "string");    String json = gson.toJson(map);    assertTrue(json.contains("\"a\":1"));    assertTrue(json.contains("\"b\":\"string\""));      }    public void testMapSerializationEmpty() {    Map<String, Integer> map = new LinkedHashMap<String, Integer>();    Type typeOfMap = new TypeToken<Map<String, Integer>>() {}.getType();    String json = gson.toJson(map, typeOfMap);    assertEquals("{}", json);  }    public void testMapDeserializationEmpty() {    Type typeOfMap = new TypeToken<Map<String, Integer>>() {}.getType();    Map<String, Integer> map = gson.fromJson("{}", typeOfMap);    assertTrue(map.isEmpty());  }    public void testMapSerializationWithNullValue() {    Map<String, Integer> map = new LinkedHashMap<String, Integer>();    map.put("abc", null);    Type typeOfMap = new TypeToken<Map<String, Integer>>() {}.getType();    String json = gson.toJson(map, typeOfMap);        // Maps are represented as JSON objects, so ignoring null field    assertEquals("{}", json);  }    public void testMapDeserializationWithNullValue() {    Type typeOfMap = new TypeToken<Map<String, Integer>>() {}.getType();    Map<String, Integer> map = gson.fromJson("{\"abc\":null}", typeOfMap);    assertEquals(1, map.size());    assertNull(map.get("abc"));  }    public void testMapSerializationWithNullValueButSerializeNulls() {    gson = new GsonBuilder().serializeNulls().create();    Map<String, Integer> map = new LinkedHashMap<String, Integer>();    map.put("abc", null);    Type typeOfMap = new TypeToken<Map<String, Integer>>() {}.getType();    String json = gson.toJson(map, typeOfMap);    assertEquals("{\"abc\":null}", json);  }    public void testMapSerializationWithNullKey() {    Map<String, Integer> map = new LinkedHashMap<String, Integer>();    map.put(null, 123);    Type typeOfMap = new TypeToken<Map<String, Integer>>() {}.getType();    String json = gson.toJson(map, typeOfMap);    assertEquals("{\"null\":123}", json);  }    public void testMapDeserializationWithNullKey() {    Type typeOfMap = new TypeToken<Map<String, Integer>>() {}.getType();    Map<String, Integer> map = gson.fromJson("{\"null\":123}", typeOfMap);    assertEquals(1, map.size());    assertNull(map.get(null));  }    public void testMapSerializationWithIntegerKeys() {    Map<Integer, String> map = new LinkedHashMap<Integer, String>();    map.put(123, "456");    Type typeOfMap = new TypeToken<Map<Integer, String>>() {}.getType();    String json = gson.toJson(map, typeOfMap);    assertEquals("{\"123\":\"456\"}", json);  }    public void testMapDeserializationWithIntegerKeys() {    Type typeOfMap = new TypeToken<Map<Integer, String>>() {}.getType();    Map<Integer, String> map = gson.fromJson("{\"123\":\"456\"}", typeOfMap);    assertEquals(1, map.size());    assertTrue(map.containsKey(123));    assertEquals("456", map.get(123));  }  public void testParameterizedMapSubclassSerialization() {    MyParameterizedMap<String, String> map = new MyParameterizedMap<String, String>();    map.put("a", "b");    Type type = new TypeToken<MyParameterizedMap<String, String>>() {}.getType();    String json = gson.toJson(map, type);    assertTrue(json.contains("\"a\":\"b\""));  }  @SuppressWarnings("unchecked")  public void testParameterizedMapSubclassDeserialization() {    Type type = new TypeToken<MyParameterizedMap<String, Integer>>() {}.getType();    Gson gson = new GsonBuilder().registerTypeAdapter(type,         new InstanceCreator<MyParameterizedMap>() {      public MyParameterizedMap createInstance(Type type) {        return new MyParameterizedMap();      }          }).create();    String json = "{\"a\":1,\"b\":2}";    MyParameterizedMap<String, Integer> map = gson.fromJson(json, type);    assertEquals(1, map.get("a").intValue());     assertEquals(2, map.get("b").intValue());   }  private static class MyParameterizedMap<K, V> extends LinkedHashMap<K, V> {    private static final long serialVersionUID = 1L;    @SuppressWarnings("unused")    int foo = 10;  }    public void testMapSubclassSerialization() {    MyMap map = new MyMap();    map.put("a", "b");    String json = gson.toJson(map, MyMap.class);    assertTrue(json.contains("\"a\":\"b\""));  }    public void disable_testMapSubclassDeserialization() {    Gson gson = new GsonBuilder().registerTypeAdapter(MyMap.class, new InstanceCreator<MyMap>() {      public MyMap createInstance(Type type) {        return new MyMap();      }          }).create();    String json = "{\"a\":1,\"b\":2}";    MyMap map = gson.fromJson(json, MyMap.class);    assertEquals("1", map.get("a"));     assertEquals("2", map.get("b"));   }    /**   * Created in response to http://code.google.com/p/google-gson/issues/detail?id=99   */  private static class ClassWithAMap {    Map<String, String> map = new TreeMap<String, String>();  }    /**   * Created in response to http://code.google.com/p/google-gson/issues/detail?id=99   */  public void testMapSerializationWithNullValues() {    ClassWithAMap target = new ClassWithAMap();    target.map.put("name1", null);    target.map.put("name2", "value2");    String json = gson.toJson(target);    assertFalse(json.contains("name1"));    assertTrue(json.contains("name2"));  }    /**   * Created in response to http://code.google.com/p/google-gson/issues/detail?id=99   */  public void testMapSerializationWithNullValuesSerialized() {    Gson gson = new GsonBuilder().serializeNulls().create();    ClassWithAMap target = new ClassWithAMap();    target.map.put("name1", null);    target.map.put("name2", "value2");    String json = gson.toJson(target);    assertTrue(json.contains("name1"));    assertTrue(json.contains("name2"));  }    public void testMapSerializationWithWildcardValues() {    Map<String, ? extends Collection<? extends Integer>> map =        new LinkedHashMap<String, Collection<Integer>>();    map.put("test", null);    Type typeOfMap =         new TypeToken<Map<String, ? extends Collection<? extends Integer>>>() {}.getType();    String json = gson.toJson(map, typeOfMap);    assertEquals("{}", json);  }    public void testMapDeserializationWithWildcardValues() {    Type typeOfMap = new TypeToken<Map<String, ? extends Long>>() {}.getType();    Map<String, ? extends Long> map = gson.fromJson("{\"test\":123}", typeOfMap);    assertEquals(1, map.size());    assertEquals(new Long(123L), map.get("test"));  }    private static class MyMap extends LinkedHashMap<String, String> {    private static final long serialVersionUID = 1L;    @SuppressWarnings("unused")    int foo = 10;  }    /**   * From bug report http://code.google.com/p/google-gson/issues/detail?id=95   */  public void testMapOfMapSerialization() {    Map<String, Map<String, String>> map = new HashMap<String, Map<String, String>>();    Map<String, String> nestedMap = new HashMap<String, String>();    nestedMap.put("1", "1");    nestedMap.put("2", "2");    map.put("nestedMap", nestedMap);    String json = gson.toJson(map);    assertTrue(json.contains("nestedMap"));    assertTrue(json.contains("\"1\":\"1\""));    assertTrue(json.contains("\"2\":\"2\""));  }    /**   * From bug report http://code.google.com/p/google-gson/issues/detail?id=95   */  public void testMapOfMapDeserialization() {    String json = "{nestedMap:{'2':'2','1':'1'}}";    Type type = new TypeToken<Map<String, Map<String, String>>>(){}.getType();    Map<String, Map<String, String>> map = gson.fromJson(json, type);    Map<String, String> nested = map.get("nestedMap");    assertEquals("1", nested.get("1"));    assertEquals("2", nested.get("2"));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.InstanceCreator;import com.google.gson.JsonDeserializationContext;import com.google.gson.JsonDeserializer;import com.google.gson.JsonElement;import com.google.gson.JsonObject;import com.google.gson.JsonParseException;import com.google.gson.JsonPrimitive;import com.google.gson.JsonSerializationContext;import com.google.gson.JsonSerializer;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.common.TestTypes.ClassWithCustomTypeConverter;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;/** * Functional tests for the support of custom serializer and deserializers. * * @author Inderjeet Singh * @author Joel Leitch */public class CustomTypeAdaptersTest extends TestCase {  private GsonBuilder builder;  @Override  protected void setUp() throws Exception {    super.setUp();    builder = new GsonBuilder();  }  public void testCustomSerializers() {    Gson gson = builder.registerTypeAdapter(        ClassWithCustomTypeConverter.class, new JsonSerializer<ClassWithCustomTypeConverter>() {      public JsonElement serialize(ClassWithCustomTypeConverter src, Type typeOfSrc,          JsonSerializationContext context) {        JsonObject json = new JsonObject();        json.addProperty("bag", 5);        json.addProperty("value", 25);        return json;      }    }).create();    ClassWithCustomTypeConverter target = new ClassWithCustomTypeConverter();    assertEquals("{\"bag\":5,\"value\":25}", gson.toJson(target));  }  public void testCustomDeserializers() {    Gson gson = new GsonBuilder().registerTypeAdapter(        ClassWithCustomTypeConverter.class, new JsonDeserializer<ClassWithCustomTypeConverter>() {      public ClassWithCustomTypeConverter deserialize(JsonElement json, Type typeOfT,          JsonDeserializationContext context) {        JsonObject jsonObject = json.getAsJsonObject();        int value = jsonObject.get("bag").getAsInt();        return new ClassWithCustomTypeConverter(new BagOfPrimitives(value,            value, false, ""), value);      }    }).create();    String json = "{\"bag\":5,\"value\":25}";    ClassWithCustomTypeConverter target = gson.fromJson(json, ClassWithCustomTypeConverter.class);    assertEquals(5, target.getBag().getIntValue());  }    public void disable_testCustomSerializersOfSelf() {    Gson gson = createGsonObjectWithFooTypeAdapter();    Gson basicGson = new Gson();    Foo newFooObject = new Foo(1, 2L);    String jsonFromCustomSerializer = gson.toJson(newFooObject);    String jsonFromGson = basicGson.toJson(newFooObject);        assertEquals(jsonFromGson, jsonFromCustomSerializer);  }  public void disable_testCustomDeserializersOfSelf() {    Gson gson = createGsonObjectWithFooTypeAdapter();    Gson basicGson = new Gson();    Foo expectedFoo = new Foo(1, 2L);    String json = basicGson.toJson(expectedFoo);    Foo newFooObject = gson.fromJson(json, Foo.class);        assertEquals(expectedFoo.key, newFooObject.key);    assertEquals(expectedFoo.value, newFooObject.value);  }  public void testCustomNestedSerializers() {    Gson gson = new GsonBuilder().registerTypeAdapter(        BagOfPrimitives.class, new JsonSerializer<BagOfPrimitives>() {      public JsonElement serialize(BagOfPrimitives src, Type typeOfSrc,          JsonSerializationContext context) {        return new JsonPrimitive(6);      }    }).create();    ClassWithCustomTypeConverter target = new ClassWithCustomTypeConverter();    assertEquals("{\"bag\":6,\"value\":10}", gson.toJson(target));  }  public void testCustomNestedDeserializers() {    Gson gson = new GsonBuilder().registerTypeAdapter(        BagOfPrimitives.class, new JsonDeserializer<BagOfPrimitives>() {      public BagOfPrimitives deserialize(JsonElement json, Type typeOfT,          JsonDeserializationContext context) throws JsonParseException {        int value = json.getAsInt();        return new BagOfPrimitives(value, value, false, "");      }    }).create();    String json = "{\"bag\":7,\"value\":25}";    ClassWithCustomTypeConverter target = gson.fromJson(json, ClassWithCustomTypeConverter.class);    assertEquals(7, target.getBag().getIntValue());  }    public void testCustomTypeAdapterDoesNotAppliesToSubClasses() {    Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer<Base> () {      public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {        JsonObject json = new JsonObject();        json.addProperty("value", src.baseValue);        return json;      }              }).create();    Base b = new Base();    String json = gson.toJson(b);    assertTrue(json.contains("value"));        b = new Derived();    json = gson.toJson(b);    assertTrue(json.contains("derivedValue"));      }    public void testCustomTypeAdapterAppliesToSubClassesSerializedAsBaseClass() {    Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new JsonSerializer<Base> () {      public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {        JsonObject json = new JsonObject();        json.addProperty("value", src.baseValue);        return json;      }              }).create();    Base b = new Base();    String json = gson.toJson(b);    assertTrue(json.contains("value"));        b = new Derived();    json = gson.toJson(b, Base.class);    assertTrue(json.contains("value"));        assertFalse(json.contains("derivedValue"));  }    private static class Base {    int baseValue = 2;  }    private static class Derived extends Base {    @SuppressWarnings("unused")    int derivedValue = 3;  }      private Gson createGsonObjectWithFooTypeAdapter() {    return new GsonBuilder().registerTypeAdapter(Foo.class, new FooTypeAdapter()).create();  }    public static class Foo {    private final int key;    private final long value;        public Foo() {      this(0, 0L);    }    public Foo(int key, long value) {      this.key = key;      this.value = value;    }  }    public static class FooTypeAdapter implements JsonSerializer<Foo>, JsonDeserializer<Foo> {    public Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)        throws JsonParseException {      return context.deserialize(json, typeOfT);    }    public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext context) {      return context.serialize(src, typeOfSrc);    }  }    public void testCustomSerializerForLong() {    final ClassWithBooleanField customSerializerInvoked = new ClassWithBooleanField();    customSerializerInvoked.value = false;    Gson gson = new GsonBuilder().registerTypeAdapter(Long.class, new JsonSerializer<Long>() {      public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context) {        customSerializerInvoked.value = true;        return new JsonPrimitive(src);      }          }).serializeNulls().create();    ClassWithWrapperLongField src = new ClassWithWrapperLongField();    String json = gson.toJson(src);    assertTrue(json.contains("\"value\":null"));    assertFalse(customSerializerInvoked.value);        customSerializerInvoked.value = false;    src.value = 10L;    json = gson.toJson(src);    assertTrue(json.contains("\"value\":10"));    assertTrue(customSerializerInvoked.value);  }    public void testCustomDeserializerForLong() {    final ClassWithBooleanField customDeserializerInvoked = new ClassWithBooleanField();    customDeserializerInvoked.value = false;    Gson gson = new GsonBuilder().registerTypeAdapter(Long.class, new JsonDeserializer<Long>() {      public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)          throws JsonParseException {        customDeserializerInvoked.value = true;        if (json == null || json.isJsonNull()) {          return null;        } else {          Number number = json.getAsJsonPrimitive().getAsNumber();          return number == null ? null : number.longValue();        }      }          }).create();    String json = "{'value':null}";    ClassWithWrapperLongField target = gson.fromJson(json, ClassWithWrapperLongField.class);    assertNull(target.value);    assertFalse(customDeserializerInvoked.value);        customDeserializerInvoked.value = false;    json = "{'value':10}";    target = gson.fromJson(json, ClassWithWrapperLongField.class);    assertEquals(10L, target.value.longValue());    assertTrue(customDeserializerInvoked.value);  }    private static class ClassWithWrapperLongField {    Long value;  }    private static class ClassWithBooleanField {    Boolean value;  }    public void testCustomByteArraySerializer() {    Gson gson = new GsonBuilder().registerTypeAdapter(byte[].class, new JsonSerializer<byte[]>() {      public JsonElement serialize(byte[] src, Type typeOfSrc, JsonSerializationContext context) {        StringBuilder sb = new StringBuilder(src.length);        for (byte b : src) {          sb.append(b);        }        return new JsonPrimitive(sb.toString());      }          }).create();    byte[] data = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};    String json = gson.toJson(data);    assertEquals("\"0123456789\"", json);  }    public void testCustomByteArrayDeserializerAndInstanceCreator() {    GsonBuilder gsonBuilder = new GsonBuilder().registerTypeAdapter(byte[].class,         new JsonDeserializer<byte[]>() {      public byte[] deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)          throws JsonParseException {        String str = json.getAsString();        byte[] data = new byte[str.length()];        for (int i = 0; i < data.length; ++i) {          data[i] = Byte.parseByte(""+str.charAt(i));        }        return data;      }          });    Gson gson = gsonBuilder.create();    String json = "'0123456789'";    byte[] actual = gson.fromJson(json, byte[].class);    byte[] expected = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};    for (int i = 0; i < actual.length; ++i) {      assertEquals(expected[i], actual[i]);    }  }    private static class StringHolder {    String part1;    String part2;    public StringHolder(String string) {      String[] parts = string.split(":");      part1 = parts[0];      part2 = parts[1];    }    public StringHolder(String part1, String part2) {      this.part1 = part1;      this.part2 = part2;    }  }    private static class StringHolderTypeAdapter implements JsonSerializer<StringHolder>,       JsonDeserializer<StringHolder>, InstanceCreator<StringHolder> {    public StringHolder createInstance(Type type) {      //Fill up with objects that will be thrown away      return new StringHolder("unknown:thing");    }    public StringHolder deserialize(JsonElement src, Type type,         JsonDeserializationContext context) {      return new StringHolder(src.getAsString());    }    public JsonElement serialize(StringHolder src, Type typeOfSrc,         JsonSerializationContext context) {      String contents = src.part1 + ':' + src.part2;      return new JsonPrimitive(contents);    }  }    // Test created from Issue 70  public void testCustomAdapterInvokedForCollectionElementSerializationWithType() {    Gson gson = new GsonBuilder()      .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())      .create();    Type setType = new TypeToken<Set<StringHolder>>() {}.getType();    StringHolder holder = new StringHolder("Jacob", "Tomaw");    Set<StringHolder> setOfHolders = new HashSet<StringHolder>();    setOfHolders.add(holder);    String json = gson.toJson(setOfHolders, setType);    assertTrue(json.contains("Jacob:Tomaw"));  }  // Test created from Issue 70  public void testCustomAdapterInvokedForCollectionElementSerialization() {    Gson gson = new GsonBuilder()      .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())      .create();    StringHolder holder = new StringHolder("Jacob", "Tomaw");    Set<StringHolder> setOfHolders = new HashSet<StringHolder>();    setOfHolders.add(holder);    String json = gson.toJson(setOfHolders);    assertTrue(json.contains("Jacob:Tomaw"));  }  // Test created from Issue 70  public void testCustomAdapterInvokedForCollectionElementDeserialization() {    Gson gson = new GsonBuilder()      .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())      .create();    Type setType = new TypeToken<Set<StringHolder>>() {}.getType();    Set<StringHolder> setOfHolders = gson.fromJson("['Jacob:Tomaw']", setType);    assertEquals(1, setOfHolders.size());    StringHolder foo = setOfHolders.iterator().next();    assertEquals("Jacob", foo.part1);    assertEquals("Tomaw", foo.part2);  }    // Test created from Issue 70  public void testCustomAdapterInvokedForMapElementSerializationWithType() {    Gson gson = new GsonBuilder()      .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())      .create();    Type mapType = new TypeToken<Map<String,StringHolder>>() {}.getType();    StringHolder holder = new StringHolder("Jacob", "Tomaw");    Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>();    mapOfHolders.put("foo", holder);    String json = gson.toJson(mapOfHolders, mapType);    assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\""));  }    // Test created from Issue 70  public void testCustomAdapterInvokedForMapElementSerialization() {    Gson gson = new GsonBuilder()      .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())      .create();    StringHolder holder = new StringHolder("Jacob", "Tomaw");    Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>();    mapOfHolders.put("foo", holder);    String json = gson.toJson(mapOfHolders);    assertTrue(json.contains("\"foo\":\"Jacob:Tomaw\""));  }  // Test created from Issue 70  public void testCustomAdapterInvokedForMapElementDeserialization() {    Gson gson = new GsonBuilder()      .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())      .create();    Type mapType = new TypeToken<Map<String, StringHolder>>() {}.getType();    Map<String, StringHolder> mapOfFoo = gson.fromJson("{'foo':'Jacob:Tomaw'}", mapType);    assertEquals(1, mapOfFoo.size());    StringHolder foo = mapOfFoo.get("foo");    assertEquals("Jacob", foo.part1);    assertEquals("Tomaw", foo.part2);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import java.math.BigDecimal;import java.math.BigInteger;import junit.framework.TestCase;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.JsonParseException;import com.google.gson.LongSerializationPolicy;import com.google.gson.common.TestTypes.CrazyLongTypeAdapter;/** * Functional tests for Json primitive values: integers, and floating point numbers. * * @author Inderjeet Singh * @author Joel Leitch */public class PrimitiveTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testPrimitiveIntegerAutoboxedSerialization() {    assertEquals("1", gson.toJson(1));  }  public void testPrimitiveIntegerAutoboxedDeserialization() {    int expected = 1;    int actual = gson.fromJson("1", int.class);    assertEquals(expected, actual);    actual = gson.fromJson("1", Integer.class);    assertEquals(expected, actual);  }  public void testPrimitiveIntegerAutoboxedInASingleElementArraySerialization() {    int target[] = {-9332};    assertEquals("[-9332]", gson.toJson(target));    assertEquals("[-9332]", gson.toJson(target, int[].class));    assertEquals("[-9332]", gson.toJson(target, Integer[].class));  }  public void testPrimitiveIntegerAutoboxedInASingleElementArrayDeserialization() {    int expected = 1;    int actual = gson.fromJson("[1]", int.class);    assertEquals(expected, actual);    actual = gson.fromJson("[1]", Integer.class);    assertEquals(expected, actual);  }  public void testReallyLongValuesSerialization() {    long value = 333961828784581L;    assertEquals("333961828784581", gson.toJson(value));  }  public void testReallyLongValuesDeserialization() {    String json = "333961828784581";    long value = gson.fromJson(json, Long.class);    assertEquals(333961828784581L, value);  }  public void testPrimitiveLongAutoboxedSerialization() {    assertEquals("1", gson.toJson(1L, long.class));    assertEquals("1", gson.toJson(1L, Long.class));  }  public void testPrimitiveLongAutoboxedDeserialization() {    long expected = 1L;    long actual = gson.fromJson("1", long.class);    assertEquals(expected, actual);    actual = gson.fromJson("1", Long.class);    assertEquals(expected, actual);  }  public void testPrimitiveLongAutoboxedInASingleElementArraySerialization() {    long[] target = {-23L};    assertEquals("[-23]", gson.toJson(target));    assertEquals("[-23]", gson.toJson(target, long[].class));    assertEquals("[-23]", gson.toJson(target, Long[].class));  }  public void testPrimitiveLongAutoboxedInASingleElementArrayDeserialization() {    long expected = 1L;    long actual = gson.fromJson("[1]", long.class);    assertEquals(expected, actual);    actual = gson.fromJson("[1]", Long.class);    assertEquals(expected, actual);  }  public void testPrimitiveBooleanAutoboxedSerialization() {    assertEquals("true", gson.toJson(true));    assertEquals("false", gson.toJson(false));  }  public void testPrimitiveBooleanAutoboxedDeserialization() {    assertEquals(Boolean.FALSE, gson.fromJson("[false]", Boolean.class));    assertEquals(Boolean.TRUE, gson.fromJson("[true]", Boolean.class));    boolean value = gson.fromJson("false", boolean.class);    assertEquals(false, value);    value = gson.fromJson("true", boolean.class);    assertEquals(true, value);  }  public void testPrimitiveBooleanAutoboxedInASingleElementArraySerialization() {    boolean target[] = {false};    assertEquals("[false]", gson.toJson(target));    assertEquals("[false]", gson.toJson(target, boolean[].class));    assertEquals("[false]", gson.toJson(target, Boolean[].class));  }  public void testPrimitiveBooleanAutoboxedInASingleElementArrayDeserialization() {    assertEquals(Boolean.FALSE, gson.fromJson("[false]", Boolean.class));    assertEquals(Boolean.TRUE, gson.fromJson("[true]", Boolean.class));    boolean value = gson.fromJson("[false]", boolean.class);    assertEquals(false, value);    value = gson.fromJson("[true]", boolean.class);    assertEquals(true, value);  }    public void testNumberSerialization() {    Number expected = 1L;    String json = gson.toJson(expected);    assertEquals(expected.toString(), json);        json = gson.toJson(expected, Number.class);    assertEquals(expected.toString(), json);  }    public void testNumberDeserialization() {    String json = "1";    Number expected = new Integer(json);    Number actual = gson.fromJson(json, Number.class);    assertEquals(expected.intValue(), actual.intValue());        json = String.valueOf(Long.MAX_VALUE);    expected = new Long(json);    actual = gson.fromJson(json, Number.class);    assertEquals(expected.longValue(), actual.longValue());  }  public void testPrimitiveDoubleAutoboxedSerialization() {    assertEquals("-122.08234335", gson.toJson(-122.08234335));    assertEquals("122.08112002", gson.toJson(new Double(122.08112002)));  }  public void testPrimitiveDoubleAutoboxedDeserialization() {    double actual = gson.fromJson("-122.08858585", double.class);    assertEquals(-122.08858585, actual);    actual = gson.fromJson("122.023900008000", Double.class);    assertEquals(122.023900008, actual);  }  public void testPrimitiveDoubleAutoboxedInASingleElementArraySerialization() {    double[] target = {-122.08D};    assertEquals("[-122.08]", gson.toJson(target));    assertEquals("[-122.08]", gson.toJson(target, double[].class));    assertEquals("[-122.08]", gson.toJson(target, Double[].class));  }    public void testDoubleAsStringRepresentationDeserialization() {    String doubleValue = "1.0043E+5";    Double expected = Double.valueOf(doubleValue);    Double actual = gson.fromJson(doubleValue, Double.class);    assertEquals(expected, actual);    double actual1 = gson.fromJson(doubleValue, double.class);    assertEquals(expected.doubleValue(), actual1);  }    public void testDoubleNoFractAsStringRepresentationDeserialization() {    String doubleValue = "1E+5";    Double expected = Double.valueOf(doubleValue);    Double actual = gson.fromJson(doubleValue, Double.class);    assertEquals(expected, actual);    double actual1 = gson.fromJson(doubleValue, double.class);    assertEquals(expected.doubleValue(), actual1);  }  public void testLargeDoubleDeserialization() {    String doubleValue = "1.234567899E8";    Double expected = Double.valueOf(doubleValue);    Double actual = gson.fromJson(doubleValue, Double.class);    assertEquals(expected, actual);    double actual1 = gson.fromJson(doubleValue, double.class);    assertEquals(expected.doubleValue(), actual1);  }  public void testPrimitiveDoubleAutoboxedInASingleElementArrayDeserialization() {    double expected = -122.08;    double actual = gson.fromJson("[-122.08]", double.class);    assertEquals(expected, actual);    actual = gson.fromJson("[-122.08]", Double.class);    assertEquals(expected, actual);  }  public void testBigDecimalSerialization() {    BigDecimal target = new BigDecimal("-122.0e-21");    String json = gson.toJson(target);    assertEquals(target, new BigDecimal(json));  }  public void testBigDecimalDeserialization() {    BigDecimal target = new BigDecimal("-122.0e-21");    String json = "-122.0e-21";    assertEquals(target, gson.fromJson(json, BigDecimal.class));  }  public void testBigDecimalInASingleElementArraySerialization() {    BigDecimal[] target = {new BigDecimal("-122.08e-21")};    String json = gson.toJson(target);    String actual = extractElementFromArray(json);    assertEquals(target[0], new BigDecimal(actual));    json = gson.toJson(target, BigDecimal[].class);    actual = extractElementFromArray(json);    assertEquals(target[0], new BigDecimal(actual));  }  public void testBigDecimalInASingleElementArrayDeserialization() {    BigDecimal expected = new BigDecimal("-122.08e-21");    BigDecimal actual = gson.fromJson("[-122.08e-21]", BigDecimal.class);    assertEquals(expected, actual);  }  public void testSmallValueForBigDecimalSerialization() {    BigDecimal target = new BigDecimal("1.55");    String actual = gson.toJson(target);    assertEquals(target.toString(), actual);  }  public void testSmallValueForBigDecimalDeserialization() {    BigDecimal expected = new BigDecimal("1.55");    BigDecimal actual = gson.fromJson("1.55", BigDecimal.class);    assertEquals(expected, actual);  }    public void testBigDecimalPreservePrecisionSerialization() {    String expectedValue = "1.000";    BigDecimal obj = new BigDecimal(expectedValue);    String actualValue = gson.toJson(obj);        assertEquals(expectedValue, actualValue);  }    public void testBigDecimalPreservePrecisionDeserialization() {    String json = "1.000";    BigDecimal expected = new BigDecimal(json);    BigDecimal actual = gson.fromJson(json, BigDecimal.class);        assertEquals(expected, actual);  }  public void testBigDecimalAsStringRepresentationDeserialization() {    String doubleValue = "0.05E+5";    BigDecimal expected = new BigDecimal(doubleValue);    BigDecimal actual = gson.fromJson(doubleValue, BigDecimal.class);    assertEquals(expected, actual);  }    public void testBigDecimalNoFractAsStringRepresentationDeserialization() {    String doubleValue = "5E+5";    BigDecimal expected = new BigDecimal(doubleValue);    BigDecimal actual = gson.fromJson(doubleValue, BigDecimal.class);    assertEquals(expected, actual);  }  public void testBigIntegerSerialization() {    BigInteger target = new BigInteger("12121211243123245845384534687435634558945453489543985435");    assertEquals(target.toString(), gson.toJson(target));  }  public void testBigIntegerDeserialization() {    String json = "12121211243123245845384534687435634558945453489543985435";    BigInteger target = new BigInteger(json);    assertEquals(target, gson.fromJson(json, BigInteger.class));  }  public void testBigIntegerInASingleElementArraySerialization() {    BigInteger[] target = {new BigInteger("1212121243434324323254365345367456456456465464564564")};    String json = gson.toJson(target);    String actual = extractElementFromArray(json);    assertEquals(target[0], new BigInteger(actual));    json = gson.toJson(target, BigInteger[].class);    actual = extractElementFromArray(json);    assertEquals(target[0], new BigInteger(actual));  }  public void testBigIntegerInASingleElementArrayDeserialization() {    BigInteger expected = new BigInteger("34343434343424242423432323243243242");    BigInteger actual = gson.fromJson("[34343434343424242423432323243243242]", BigInteger.class);    assertEquals(expected, actual);  }  public void testSmallValueForBigIntegerSerialization() {    BigInteger target = new BigInteger("15");    String actual = gson.toJson(target);    assertEquals(target.toString(), actual);  }  public void testSmallValueForBigIntegerDeserialization() {    BigInteger expected = new BigInteger("15");    BigInteger actual = gson.fromJson("15", BigInteger.class);    assertEquals(expected, actual);  }  public void testBadValueForBigIntegerDeserialization() {    try {      gson.fromJson("15.099", BigInteger.class);      fail("BigInteger can not be decimal values.");    } catch (JsonParseException expected) { }  }    public void testOverridingDefaultPrimitiveSerialization() {    CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter();    gson = new GsonBuilder()        .registerTypeAdapter(long.class, typeAdapter)        .registerTypeAdapter(Long.class, typeAdapter)        .create();    long value = 1L;    String serializedValue = gson.toJson(value);    assertEquals(String.valueOf(value + CrazyLongTypeAdapter.DIFFERENCE), serializedValue);        long deserializedValue = gson.fromJson(serializedValue, long.class);    assertEquals(value, deserializedValue);  }  private String extractElementFromArray(String json) {    return json.substring(json.indexOf('[') + 1, json.indexOf(']'));  }    public void testDoubleNaNSerializationNotSupportedByDefault() {    try {      double nan = Double.NaN;      gson.toJson(nan);      fail("Gson should not accept NaN for serialization");    } catch (IllegalArgumentException expected) {          }    try {      gson.toJson(Double.NaN);      fail("Gson should not accept NaN for serialization");    } catch (IllegalArgumentException expected) {          }  }      public void testDoubleNaNSerialization() {    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();    double nan = Double.NaN;    assertEquals("NaN", gson.toJson(nan));    assertEquals("NaN", gson.toJson(Double.NaN));  }    public void testDoubleNaNDeserialization() {    assertTrue(Double.isNaN(gson.fromJson("NaN", Double.class)));    assertTrue(Double.isNaN(gson.fromJson("NaN", double.class)));  }    public void testFloatNaNSerializationNotSupportedByDefault() {    try {      float nan = Float.NaN;      gson.toJson(nan);      fail("Gson should not accept NaN for serialization");    } catch (IllegalArgumentException expected) {          }    try {      gson.toJson(Float.NaN);      fail("Gson should not accept NaN for serialization");    } catch (IllegalArgumentException expected) {          }  }    public void testFloatNaNSerialization() {    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();    float nan = Float.NaN;    assertEquals("NaN", gson.toJson(nan));    assertEquals("NaN", gson.toJson(Float.NaN));  }    public void testFloatNaNDeserialization() {    assertTrue(Float.isNaN(gson.fromJson("NaN", Float.class)));    assertTrue(Float.isNaN(gson.fromJson("NaN", float.class)));  }  public void testBigDecimalNaNDeserializationNotSupported() {    try {      gson.fromJson("NaN", BigDecimal.class);      fail("Gson should not accept NaN for deserialization by default.");    } catch (JsonParseException expected) {          }  }  public void testDoubleInfinitySerializationNotSupportedByDefault() {    try {      double infinity = Double.POSITIVE_INFINITY;      gson.toJson(infinity);      fail("Gson should not accept positive infinity for serialization by default.");    } catch (IllegalArgumentException expected) {          }    try {      gson.toJson(Double.POSITIVE_INFINITY);      fail("Gson should not accept positive infinity for serialization by default.");    } catch (IllegalArgumentException expected) {          }  }    public void testDoubleInfinitySerialization() {    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();    double infinity = Double.POSITIVE_INFINITY;    assertEquals("Infinity", gson.toJson(infinity));    assertEquals("Infinity", gson.toJson(Double.POSITIVE_INFINITY));  }    public void testDoubleInfinityDeserialization() {    assertTrue(Double.isInfinite(gson.fromJson("Infinity", Double.class)));    assertTrue(Double.isInfinite(gson.fromJson("Infinity", double.class)));  }    public void testFloatInfinitySerializationNotSupportedByDefault() {    try {      float infinity = Float.POSITIVE_INFINITY;      gson.toJson(infinity);      fail("Gson should not accept positive infinity for serialization by default");    } catch (IllegalArgumentException expected) {          }    try {      gson.toJson(Float.POSITIVE_INFINITY);      fail("Gson should not accept positive infinity for serialization by default");    } catch (IllegalArgumentException expected) {          }  }    public void testFloatInfinitySerialization() {    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();    float infinity = Float.POSITIVE_INFINITY;    assertEquals("Infinity", gson.toJson(infinity));    assertEquals("Infinity", gson.toJson(Float.POSITIVE_INFINITY));  }    public void testFloatInfinityDeserialization() {    assertTrue(Float.isInfinite(gson.fromJson("Infinity", Float.class)));    assertTrue(Float.isInfinite(gson.fromJson("Infinity", float.class)));  }    public void testBigDecimalInfinityDeserializationNotSupported() {    try {      gson.fromJson("Infinity", BigDecimal.class);      fail("Gson should not accept positive infinity for deserialization with BigDecimal");    } catch (JsonParseException expected) {          }  }    public void testNegativeInfinitySerializationNotSupportedByDefault() {    try {      double negativeInfinity = Double.NEGATIVE_INFINITY;      gson.toJson(negativeInfinity);      fail("Gson should not accept negative infinity for serialization by default");    } catch (IllegalArgumentException expected) {          }    try {      gson.toJson(Double.NEGATIVE_INFINITY);      fail("Gson should not accept negative infinity for serialization by default");    } catch (IllegalArgumentException expected) {          }  }    public void testNegativeInfinitySerialization() {    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();    double negativeInfinity = Double.NEGATIVE_INFINITY;    assertEquals("-Infinity", gson.toJson(negativeInfinity));    assertEquals("-Infinity", gson.toJson(Double.NEGATIVE_INFINITY));  }    public void testNegativeInfinityDeserialization() {    assertTrue(Double.isInfinite(gson.fromJson("-Infinity", double.class)));    assertTrue(Double.isInfinite(gson.fromJson("-Infinity", Double.class)));  }    public void testNegativeInfinityFloatSerializationNotSupportedByDefault() {    try {      float negativeInfinity = Float.NEGATIVE_INFINITY;      gson.toJson(negativeInfinity);      fail("Gson should not accept negative infinity for serialization by default");    } catch (IllegalArgumentException expected) {          }    try {      gson.toJson(Float.NEGATIVE_INFINITY);      fail("Gson should not accept negative infinity for serialization by default");    } catch (IllegalArgumentException expected) {          }  }    public void testNegativeInfinityFloatSerialization() {    Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();    float negativeInfinity = Float.NEGATIVE_INFINITY;    assertEquals("-Infinity", gson.toJson(negativeInfinity));    assertEquals("-Infinity", gson.toJson(Float.NEGATIVE_INFINITY));  }    public void testNegativeInfinityFloatDeserialization() {    assertTrue(Float.isInfinite(gson.fromJson("-Infinity", float.class)));    assertTrue(Float.isInfinite(gson.fromJson("-Infinity", Float.class)));  }    public void testBigDecimalNegativeInfinityDeserializationNotSupported() {    try {      gson.fromJson("-Infinity", BigDecimal.class);      fail("Gson should not accept positive infinity for deserialization");    } catch (JsonParseException expected) {          }  }      public void testLongAsStringSerialization() throws Exception {    gson = new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();    String result = gson.toJson(15L);    assertEquals("\"15\"", result);        // Test with an integer and ensure its still a number    result = gson.toJson(2);    assertEquals("2", result);  }    public void testLongAsStringDeserialization() throws Exception {    long value = gson.fromJson("\"15\"", long.class);    assertEquals(15, value);    gson = new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();    value = gson.fromJson("\"25\"", long.class);    assertEquals(25, value);  }    public void testHtmlCharacterSerialization() throws Exception {    String target = "<script>var a = 12;</script>";    String result = gson.toJson(target);    assertFalse(result.equals('"' + target + '"'));        gson = new GsonBuilder().disableHtmlEscaping().create();    result = gson.toJson(target);    assertTrue(result.equals('"' + target + '"'));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.JsonDeserializationContext;import com.google.gson.JsonDeserializer;import com.google.gson.JsonElement;import com.google.gson.JsonParseException;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.common.TestTypes.ClassOverridingEquals;import junit.framework.TestCase;import java.lang.reflect.Type;/** * Functional tests that do not fall neatly into any of the existing classification. * * @author Inderjeet Singh * @author Joel Leitch */public class UncategorizedTest extends TestCase {  private Gson gson = null;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testInvalidJsonDeserializationFails() throws Exception {    try {      gson.fromJson("adfasdf1112,,,\":", BagOfPrimitives.class);      fail("Bad JSON should throw a ParseException");    } catch (JsonParseException expected) { }    try {      gson.fromJson("{adfasdf1112,,,\":}", BagOfPrimitives.class);      fail("Bad JSON should throw a ParseException");    } catch (JsonParseException expected) { }  }  public void testObjectEqualButNotSameSerialization() throws Exception {    ClassOverridingEquals objA = new ClassOverridingEquals();    ClassOverridingEquals objB = new ClassOverridingEquals();    objB.ref = objA;    String json = gson.toJson(objB);    assertEquals(objB.getExpectedJson(), json);  }  public void testStaticFieldsAreNotSerialized() {    BagOfPrimitives target = new BagOfPrimitives();    assertFalse(gson.toJson(target).contains("DEFAULT_VALUE"));  }  /**   * This test ensures that a custom deserializer is able to return a derived class instance for a   * base class object. For a motivation for this test, see Issue 37 and   * http://groups.google.com/group/google-gson/browse_thread/thread/677d56e9976d7761   */  public void testReturningDerivedClassesDuringDeserialization() {    Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new BaseTypeAdapter()).create();    String json = "{\"opType\":\"OP1\"}";    Base base = gson.fromJson(json, Base.class);    assertTrue(base instanceof Derived1);    assertEquals(OperationType.OP1, base.opType);    json = "{\"opType\":\"OP2\"}";    base = gson.fromJson(json, Base.class);    assertTrue(base instanceof Derived2);    assertEquals(OperationType.OP2, base.opType);  }  private enum OperationType { OP1, OP2 }  private static class Base {    OperationType opType;  }  private static class Derived1 extends Base {    Derived1() { opType = OperationType.OP1; }  }  private static class Derived2 extends Base {    Derived2() { opType = OperationType.OP2; }  }  private static class BaseTypeAdapter implements JsonDeserializer<Base> {    public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)        throws JsonParseException {      String opTypeStr = json.getAsJsonObject().get("opType").getAsString();      OperationType opType = OperationType.valueOf(opTypeStr);      switch (opType) {      case OP1:        return new Derived1();      case OP2:        return new Derived2();      }      throw new JsonParseException("unknown type: " + json);    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.ParamterizedTypeFixtures.MyParameterizedType;import com.google.gson.ParamterizedTypeFixtures.MyParameterizedTypeAdapter;import com.google.gson.ParamterizedTypeFixtures.MyParameterizedTypeInstanceCreator;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.io.Reader;import java.io.Serializable;import java.io.StringReader;import java.io.StringWriter;import java.io.Writer;import java.lang.reflect.Type;import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * Functional tests for the serialization and deserialization of parameterized types in Gson. * * @author Inderjeet Singh * @author Joel Leitch */public class ParameterizedTypesTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testParameterizedTypesSerialization() throws Exception {    MyParameterizedType<Integer> src = new MyParameterizedType<Integer>(10);    Type typeOfSrc = new TypeToken<MyParameterizedType<Integer>>() {}.getType();    String json = gson.toJson(src, typeOfSrc);    assertEquals(src.getExpectedJson(), json);  }  public void testParameterizedTypeDeserialization() throws Exception {    BagOfPrimitives bag = new BagOfPrimitives();    MyParameterizedType<BagOfPrimitives> expected = new MyParameterizedType<BagOfPrimitives>(bag);    Type expectedType = new TypeToken<MyParameterizedType<BagOfPrimitives>>() {}.getType();    BagOfPrimitives bagDefaultInstance = new BagOfPrimitives();    Gson gson = new GsonBuilder().registerTypeAdapter(        expectedType, new MyParameterizedTypeInstanceCreator<BagOfPrimitives>(bagDefaultInstance))        .create();    String json = expected.getExpectedJson();    MyParameterizedType<BagOfPrimitives> actual = gson.fromJson(json, expectedType);    assertEquals(expected, actual);  }  public void testTypesWithMultipleParametersSerialization() throws Exception {    MultiParameters<Integer, Float, Double, String, BagOfPrimitives> src =        new MultiParameters<Integer, Float, Double, String, BagOfPrimitives>(10, 1.0F, 2.1D,            "abc", new BagOfPrimitives());    Type typeOfSrc = new TypeToken<MultiParameters<Integer, Float, Double, String,        BagOfPrimitives>>() {}.getType();    String json = gson.toJson(src, typeOfSrc);    String expected = "{\"a\":10,\"b\":1.0,\"c\":2.1,\"d\":\"abc\","        + "\"e\":{\"longValue\":0,\"intValue\":0,\"booleanValue\":false,\"stringValue\":\"\"}}";    assertEquals(expected, json);  }  public void testTypesWithMultipleParametersDeserialization() throws Exception {    Type typeOfTarget = new TypeToken<MultiParameters<Integer, Float, Double, String,        BagOfPrimitives>>() {}.getType();    String json = "{\"a\":10,\"b\":1.0,\"c\":2.1,\"d\":\"abc\","        + "\"e\":{\"longValue\":0,\"intValue\":0,\"booleanValue\":false,\"stringValue\":\"\"}}";    MultiParameters<Integer, Float, Double, String, BagOfPrimitives> target =        gson.fromJson(json, typeOfTarget);    MultiParameters<Integer, Float, Double, String, BagOfPrimitives> expected =        new MultiParameters<Integer, Float, Double, String, BagOfPrimitives>(10, 1.0F, 2.1D,            "abc", new BagOfPrimitives());    assertEquals(expected, target);  }  public void testParameterizedTypeWithCustomSerializer() {    Type ptIntegerType = new TypeToken<MyParameterizedType<Integer>>() {}.getType();    Type ptStringType = new TypeToken<MyParameterizedType<String>>() {}.getType();    Gson gson = new GsonBuilder()        .registerTypeAdapter(ptIntegerType, new MyParameterizedTypeAdapter<Integer>())        .registerTypeAdapter(ptStringType, new MyParameterizedTypeAdapter<String>())        .create();    MyParameterizedType<Integer> intTarget = new MyParameterizedType<Integer>(10);    String json = gson.toJson(intTarget, ptIntegerType);    assertEquals(MyParameterizedTypeAdapter.<Integer>getExpectedJson(intTarget), json);    MyParameterizedType<String> stringTarget = new MyParameterizedType<String>("abc");    json = gson.toJson(stringTarget, ptStringType);    assertEquals(MyParameterizedTypeAdapter.<String>getExpectedJson(stringTarget), json);  }  public void testParameterizedTypesWithCustomDeserializer() {    Type ptIntegerType = new TypeToken<MyParameterizedType<Integer>>() {}.getType();    Type ptStringType = new TypeToken<MyParameterizedType<String>>() {}.getType();    Gson gson = new GsonBuilder().registerTypeAdapter(        ptIntegerType, new MyParameterizedTypeAdapter<Integer>())        .registerTypeAdapter(ptStringType, new MyParameterizedTypeAdapter<String>())        .registerTypeAdapter(ptStringType, new MyParameterizedTypeInstanceCreator<String>(""))        .registerTypeAdapter(ptIntegerType,            new MyParameterizedTypeInstanceCreator<Integer>(new Integer(0)))        .create();    MyParameterizedType<Integer> src = new MyParameterizedType<Integer>(10);    String json = MyParameterizedTypeAdapter.<Integer>getExpectedJson(src);    MyParameterizedType<Integer> intTarget = gson.fromJson(json, ptIntegerType);    assertEquals(10, (int) intTarget.value);    MyParameterizedType<String> srcStr = new MyParameterizedType<String>("abc");    json = MyParameterizedTypeAdapter.<String>getExpectedJson(srcStr);    MyParameterizedType<String> stringTarget = gson.fromJson(json, ptStringType);    assertEquals("abc", stringTarget.value);  }  public void testParameterizedTypesWithWriterSerialization() throws Exception {    Writer writer = new StringWriter();    MyParameterizedType<Integer> src = new MyParameterizedType<Integer>(10);    Type typeOfSrc = new TypeToken<MyParameterizedType<Integer>>() {}.getType();    gson.toJson(src, typeOfSrc, writer);    assertEquals(src.getExpectedJson(), writer.toString());  }  public void testParameterizedTypeWithReaderDeserialization() throws Exception {    BagOfPrimitives bag = new BagOfPrimitives();    MyParameterizedType<BagOfPrimitives> expected = new MyParameterizedType<BagOfPrimitives>(bag);    Type expectedType = new TypeToken<MyParameterizedType<BagOfPrimitives>>() {}.getType();    BagOfPrimitives bagDefaultInstance = new BagOfPrimitives();    Gson gson = new GsonBuilder().registerTypeAdapter(        expectedType, new MyParameterizedTypeInstanceCreator<BagOfPrimitives>(bagDefaultInstance))        .create();    Reader json = new StringReader(expected.getExpectedJson());    MyParameterizedType<Integer> actual = gson.fromJson(json, expectedType);    assertEquals(expected, actual);  }  @SuppressWarnings("unchecked")  public void testVariableTypeFieldsAndGenericArraysSerialization() throws Exception {    Integer obj = 0;    Integer[] array = { 1, 2, 3 };    List<Integer> list = new ArrayList<Integer>();    list.add(4);    list.add(5);    List<Integer>[] arrayOfLists = new List[] { list, list };    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();    ObjectWithTypeVariables<Integer> objToSerialize =        new ObjectWithTypeVariables<Integer>(obj, array, list, arrayOfLists, list, arrayOfLists);    String json = gson.toJson(objToSerialize, typeOfSrc);    assertEquals(objToSerialize.getExpectedJson(), json);  }  @SuppressWarnings("unchecked")  public void testVariableTypeFieldsAndGenericArraysDeserialization() throws Exception {    Integer obj = 0;    Integer[] array = { 1, 2, 3 };    List<Integer> list = new ArrayList<Integer>();    list.add(4);    list.add(5);    List<Integer>[] arrayOfLists = new List[] { list, list };    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();    ObjectWithTypeVariables<Integer> objToSerialize =        new ObjectWithTypeVariables<Integer>(obj, array, list, arrayOfLists, list, arrayOfLists);    String json = gson.toJson(objToSerialize, typeOfSrc);    ObjectWithTypeVariables<Integer> objAfterDeserialization = gson.fromJson(json, typeOfSrc);    assertEquals(objAfterDeserialization.getExpectedJson(), json);  }  public void testVariableTypeDeserialization() throws Exception {    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();    ObjectWithTypeVariables<Integer> objToSerialize =        new ObjectWithTypeVariables<Integer>(0, null, null, null, null, null);    String json = gson.toJson(objToSerialize, typeOfSrc);    ObjectWithTypeVariables<Integer> objAfterDeserialization = gson.fromJson(json, typeOfSrc);    assertEquals(objAfterDeserialization.getExpectedJson(), json);  }  public void testVariableTypeArrayDeserialization() throws Exception {    Integer[] array = { 1, 2, 3 };    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();    ObjectWithTypeVariables<Integer> objToSerialize =        new ObjectWithTypeVariables<Integer>(null, array, null, null, null, null);    String json = gson.toJson(objToSerialize, typeOfSrc);    ObjectWithTypeVariables<Integer> objAfterDeserialization = gson.fromJson(json, typeOfSrc);    assertEquals(objAfterDeserialization.getExpectedJson(), json);  }  public void testParameterizedTypeWithVariableTypeDeserialization() throws Exception {    List<Integer> list = new ArrayList<Integer>();    list.add(4);    list.add(5);    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();    ObjectWithTypeVariables<Integer> objToSerialize =        new ObjectWithTypeVariables<Integer>(null, null, list, null, null, null);    String json = gson.toJson(objToSerialize, typeOfSrc);    ObjectWithTypeVariables<Integer> objAfterDeserialization = gson.fromJson(json, typeOfSrc);    assertEquals(objAfterDeserialization.getExpectedJson(), json);  }  @SuppressWarnings("unchecked")  public void testParameterizedTypeGenericArraysSerialization() throws Exception {    List<Integer> list = new ArrayList<Integer>();    list.add(1);    list.add(2);    List<Integer>[] arrayOfLists = new List[] { list, list };    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();    ObjectWithTypeVariables<Integer> objToSerialize =        new ObjectWithTypeVariables<Integer>(null, null, null, arrayOfLists, null, null);    String json = gson.toJson(objToSerialize, typeOfSrc);    assertEquals("{\"arrayOfListOfTypeParameters\":[[1,2],[1,2]]}", json);  }  @SuppressWarnings("unchecked")  public void testParameterizedTypeGenericArraysDeserialization() throws Exception {    List<Integer> list = new ArrayList<Integer>();    list.add(1);    list.add(2);    List<Integer>[] arrayOfLists = new List[] { list, list };    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();    ObjectWithTypeVariables<Integer> objToSerialize =        new ObjectWithTypeVariables<Integer>(null, null, null, arrayOfLists, null, null);    String json = gson.toJson(objToSerialize, typeOfSrc);    ObjectWithTypeVariables<Integer> objAfterDeserialization = gson.fromJson(json, typeOfSrc);    assertEquals(objAfterDeserialization.getExpectedJson(), json);  }  /**   * An test object that has fields that are type variables.   *   * @param <T> Enforce T to be a string to make writing the "toExpectedJson" method easier.   */  private static class ObjectWithTypeVariables<T extends Number> {    private final T typeParameterObj;    private final T[] typeParameterArray;    private final List<T> listOfTypeParameters;    private final List<T>[] arrayOfListOfTypeParameters;    private final List<? extends T> listOfWildcardTypeParameters;    private final List<? extends T>[] arrayOfListOfWildcardTypeParameters;    // For use by Gson    @SuppressWarnings("unused")    private ObjectWithTypeVariables() {      this(null, null, null, null, null, null);    }    public ObjectWithTypeVariables(T obj, T[] array, List<T> list, List<T>[] arrayOfList,        List<? extends T> wildcardList, List<? extends T>[] arrayOfWildcardList) {      this.typeParameterObj = obj;      this.typeParameterArray = array;      this.listOfTypeParameters = list;      this.arrayOfListOfTypeParameters = arrayOfList;      this.listOfWildcardTypeParameters = wildcardList;      this.arrayOfListOfWildcardTypeParameters = arrayOfWildcardList;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder().append("{");      boolean needsComma = false;      if (typeParameterObj != null) {        sb.append("\"typeParameterObj\":").append(toString(typeParameterObj));        needsComma = true;      }      if (typeParameterArray != null) {        if (needsComma) {          sb.append(',');        }        sb.append("\"typeParameterArray\":[");        appendObjectsToBuilder(sb, Arrays.asList(typeParameterArray));        sb.append(']');        needsComma = true;      }      if (listOfTypeParameters != null) {        if (needsComma) {          sb.append(',');        }        sb.append("\"listOfTypeParameters\":[");        appendObjectsToBuilder(sb, listOfTypeParameters);        sb.append(']');        needsComma = true;      }      if (arrayOfListOfTypeParameters != null) {        if (needsComma) {          sb.append(',');        }        sb.append("\"arrayOfListOfTypeParameters\":[");        appendObjectsToBuilder(sb, arrayOfListOfTypeParameters);        sb.append(']');        needsComma = true;      }      if (listOfWildcardTypeParameters != null) {        if (needsComma) {          sb.append(',');        }        sb.append("\"listOfWildcardTypeParameters\":[");        appendObjectsToBuilder(sb, listOfWildcardTypeParameters);        sb.append(']');        needsComma = true;      }      if (arrayOfListOfWildcardTypeParameters != null) {        if (needsComma) {          sb.append(',');        }        sb.append("\"arrayOfListOfWildcardTypeParameters\":[");        appendObjectsToBuilder(sb, arrayOfListOfWildcardTypeParameters);        sb.append(']');        needsComma = true;      }      sb.append('}');      return sb.toString();    }    private void appendObjectsToBuilder(StringBuilder sb, Iterable<? extends T> iterable) {      boolean isFirst = true;      for (T obj : iterable) {        if (!isFirst) {          sb.append(',');        }        isFirst = false;        sb.append(toString(obj));      }    }    private void appendObjectsToBuilder(StringBuilder sb, List<? extends T>[] arrayOfList) {      boolean isFirst = true;      for (List<? extends T> list : arrayOfList) {        if (!isFirst) {          sb.append(',');        }        isFirst = false;        if (list != null) {          sb.append('[');          appendObjectsToBuilder(sb, list);          sb.append(']');        } else {          sb.append("null");        }      }    }    public String toString(T obj) {      return obj.toString();    }  }  private static class MultiParameters<A, B, C, D, E> {    A a;    B b;    C c;    D d;    E e;    // For use by Gson    @SuppressWarnings("unused")    private MultiParameters() {    }    MultiParameters(A a, B b, C c, D d, E e) {      super();      this.a = a;      this.b = b;      this.c = c;      this.d = d;      this.e = e;    }    @Override    public int hashCode() {      final int prime = 31;      int result = 1;      result = prime * result + ((a == null) ? 0 : a.hashCode());      result = prime * result + ((b == null) ? 0 : b.hashCode());      result = prime * result + ((c == null) ? 0 : c.hashCode());      result = prime * result + ((d == null) ? 0 : d.hashCode());      result = prime * result + ((e == null) ? 0 : e.hashCode());      return result;    }    @Override    @SuppressWarnings("unchecked")    public boolean equals(Object obj) {      if (this == obj) {        return true;      }      if (obj == null) {        return false;      }      if (getClass() != obj.getClass()) {        return false;      }      MultiParameters<A, B, C, D, E> other = (MultiParameters<A, B, C, D, E>) obj;      if (a == null) {        if (other.a != null) {          return false;        }      } else if (!a.equals(other.a)) {        return false;      }      if (b == null) {        if (other.b != null) {          return false;        }      } else if (!b.equals(other.b)) {        return false;      }      if (c == null) {        if (other.c != null) {          return false;        }      } else if (!c.equals(other.c)) {        return false;      }      if (d == null) {        if (other.d != null) {          return false;        }      } else if (!d.equals(other.d)) {        return false;      }      if (e == null) {        if (other.e != null) {          return false;        }      } else if (!e.equals(other.e)) {        return false;      }      return true;    }  }    // Begin: tests to reproduce issue 103  private static class Quantity {    @SuppressWarnings("unused")    int q = 10;  }  private static class MyQuantity extends Quantity {    @SuppressWarnings("unused")    int q2 = 20;  }  private interface Measurable<T> {      }  private interface Field<T> {      }  private interface Immutable {      }    public static final class Amount<Q extends Quantity>       implements Measurable<Q>, Field<Amount<?>>, Serializable, Immutable {    private static final long serialVersionUID = -7560491093120970437L;    int value = 30;  }    public void testDeepParameterizedTypeSerialization() {    Amount<MyQuantity> amount = new Amount<MyQuantity>();    String json = gson.toJson(amount);    assertTrue(json.contains("value"));    assertTrue(json.contains("30"));      }    public void testDeepParameterizedTypeDeserialization() {    String json = "{value:30}";    Type type = new TypeToken<Amount<MyQuantity>>() {}.getType();        Amount<MyQuantity> amount = gson.fromJson(json, type);    assertEquals(30, amount.value);  }  // End: tests to reproduce issue 103}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import java.io.StringReader;import junit.framework.TestCase;import com.google.gson.Gson;import com.google.gson.JsonArray;import com.google.gson.JsonObject;import com.google.gson.JsonParseException;import com.google.gson.JsonParser;import com.google.gson.JsonPrimitive;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.common.TestTypes.Nested;/** * Functional tests for that use JsonParser and related Gson methods * * @author Inderjeet Singh * @author Joel Leitch */public class JsonParserTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }    public void testDeserializingCustomTree() {    JsonObject obj = new JsonObject();    obj.addProperty("stringValue", "foo");    obj.addProperty("intValue", 11);    BagOfPrimitives target = gson.fromJson(obj, BagOfPrimitives.class);    assertEquals(11, target.intValue);    assertEquals("foo", target.stringValue);  }    public void testBadTypeForDeserializingCustomTree() {    JsonObject obj = new JsonObject();    obj.addProperty("stringValue", "foo");    obj.addProperty("intValue", 11);    JsonArray array = new JsonArray();    array.add(obj);    try {      gson.fromJson(array, BagOfPrimitives.class);      fail("BagOfPrimitives is not an array");    } catch (JsonParseException expected) { }  }    public void testBadFieldTypeForCustomDeserializerCustomTree() {    JsonArray array = new JsonArray();    array.add(new JsonPrimitive("blah"));    JsonObject obj = new JsonObject();    obj.addProperty("stringValue", "foo");    obj.addProperty("intValue", 11);    obj.add("longValue", array);    try {      gson.fromJson(obj, BagOfPrimitives.class);      fail("BagOfPrimitives is not an array");    } catch (JsonParseException expected) { }  }  public void testBadFieldTypeForDeserializingCustomTree() {    JsonArray array = new JsonArray();    array.add(new JsonPrimitive("blah"));    JsonObject primitive1 = new JsonObject();    primitive1.addProperty("string", "foo");    primitive1.addProperty("intValue", 11);    JsonObject obj = new JsonObject();    obj.add("primitive1", primitive1);    obj.add("primitive2", array);        try {      gson.fromJson(obj, Nested.class);      fail("Nested has field BagOfPrimitives which is not an array");    } catch (JsonParseException expected) { }  }  public void testChangingCustomTreeAndDeserializing() {    StringReader json =       new StringReader("{'stringValue':'no message','intValue':10,'longValue':20}");    JsonObject obj = (JsonObject) new JsonParser().parse(json);    obj.remove("stringValue");    obj.addProperty("stringValue", "fooBar");    BagOfPrimitives target = gson.fromJson(obj, BagOfPrimitives.class);    assertEquals(10, target.intValue);    assertEquals(20, target.longValue);    assertEquals("fooBar", target.stringValue);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.JsonElement;import com.google.gson.JsonParserAsync;import com.google.gson.common.TestTypes.BagOfPrimitives;import junit.framework.TestCase;import java.io.CharArrayReader;import java.io.CharArrayWriter;import java.io.IOException;import java.io.Reader;import java.io.StringReader;import java.io.StringWriter;import java.io.Writer;/** * Functional tests for the support of {@link Reader}s and {@link Writer}s. * * @author Inderjeet Singh * @author Joel Leitch */public class ReadersWritersTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testWriterForSerialization() throws Exception {    Writer writer = new StringWriter();    BagOfPrimitives src = new BagOfPrimitives();    gson.toJson(src, writer);    assertEquals(src.getExpectedJson(), writer.toString());  }  public void testReaderForDeserialization() throws Exception {    BagOfPrimitives expected = new BagOfPrimitives();    Reader json = new StringReader(expected.getExpectedJson());    BagOfPrimitives actual = gson.fromJson(json, BagOfPrimitives.class);    assertEquals(expected, actual);  }  public void testTopLevelNullObjectSerializationWithWriter() {    StringWriter writer = new StringWriter();    gson.toJson(null, writer);    assertEquals("", writer.toString());  }  public void testTopLevelNullObjectDeserializationWithReader() {    StringReader reader = new StringReader("null");    Integer nullIntObject = gson.fromJson(reader, Integer.class);    assertNull(nullIntObject);  }  public void testTopLevelNullObjectSerializationWithWriterAndSerializeNulls() {    Gson gson = new GsonBuilder().serializeNulls().create();    StringWriter writer = new StringWriter();    gson.toJson(null, writer);    assertEquals("null", writer.toString());  }  public void testTopLevelNullObjectDeserializationWithReaderAndSerializeNulls() {    Gson gson = new GsonBuilder().serializeNulls().create();    StringReader reader = new StringReader("null");    Integer nullIntObject = gson.fromJson(reader, Integer.class);    assertNull(nullIntObject);  }    public void testReadWriteTwoStrings() throws IOException {    Gson gson= new Gson();    CharArrayWriter writer= new CharArrayWriter();    writer.write(gson.toJson("one").toCharArray());    writer.write(gson.toJson("two").toCharArray());    CharArrayReader reader = new CharArrayReader(writer.toCharArray());    JsonParserAsync parser = new JsonParserAsync(reader);    String actualOne = gson.fromJson(parser.next(), String.class);    assertEquals("one", actualOne);    String actualTwo = gson.fromJson(parser.next(), String.class);    assertEquals("two", actualTwo);  }    public void testReadWriteTwoObjects() throws IOException {    Gson gson= new Gson();    CharArrayWriter writer= new CharArrayWriter();    BagOfPrimitives expectedOne = new BagOfPrimitives(1, 1, true, "one");    writer.write(gson.toJson(expectedOne).toCharArray());    BagOfPrimitives expectedTwo = new BagOfPrimitives(2, 2, false, "two");    writer.write(gson.toJson(expectedTwo).toCharArray());    CharArrayReader reader = new CharArrayReader(writer.toCharArray());    JsonParserAsync parser = new JsonParserAsync(reader);    BagOfPrimitives actualOne = gson.fromJson(parser.next(), BagOfPrimitives.class);    assertEquals("one", actualOne.stringValue);    BagOfPrimitives actualTwo = gson.fromJson(parser.next(), BagOfPrimitives.class);    assertEquals("two", actualTwo.stringValue);    JsonElement jsonElement = parser.next();    assertNull(jsonElement);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.atomic.AtomicBoolean;import junit.framework.TestCase;import com.google.gson.Gson;/** * Tests for ensuring Gson thread-safety. *  * @author Inderjeet Singh * @author Joel Leitch */public class ConcurrencyTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  /**   * Source-code based on   * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081   */  public void testSingleThreadSerialization() {     MyObject myObj = new MyObject();     for (int i = 0; i < 10; i++) {       gson.toJson(myObj);     }   }   /**   * Source-code based on   * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081   */  public void testSingleThreadDeserialization() {     for (int i = 0; i < 10; i++) {       gson.fromJson("{'a':'hello','b':'world','i':1}", MyObject.class);     }   }   /**   * Source-code based on   * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081   */  public void testMultiThreadSerialization() throws InterruptedException {    final CountDownLatch startLatch = new CountDownLatch(1);    final CountDownLatch finishedLatch = new CountDownLatch(10);    final AtomicBoolean failed = new AtomicBoolean(false);    ExecutorService executor = Executors.newFixedThreadPool(10);    for (int taskCount = 0; taskCount < 10; taskCount++) {      executor.execute(new Runnable() {        public void run() {          MyObject myObj = new MyObject();          try {            startLatch.await();            for (int i = 0; i < 10; i++) {              gson.toJson(myObj);            }          } catch (Throwable t) {            failed.set(true);          } finally {            finishedLatch.countDown();          }        }      });    }    startLatch.countDown();    finishedLatch.await();    assertFalse(failed.get());  }  /**   * Source-code based on   * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081   */  public void testMultiThreadDeserialization() throws InterruptedException {    final CountDownLatch startLatch = new CountDownLatch(1);    final CountDownLatch finishedLatch = new CountDownLatch(10);    final AtomicBoolean failed = new AtomicBoolean(false);    ExecutorService executor = Executors.newFixedThreadPool(10);    for (int taskCount = 0; taskCount < 10; taskCount++) {      executor.execute(new Runnable() {        public void run() {          try {            startLatch.await();            for (int i = 0; i < 10; i++) {              gson.fromJson("{'a':'hello','b':'world','i':1}", MyObject.class);             }          } catch (Throwable t) {            failed.set(true);          } finally {            finishedLatch.countDown();          }        }      });    }    startLatch.countDown();    finishedLatch.await();    assertFalse(failed.get());  }    @SuppressWarnings("unused")  private static class MyObject {    String a;    String b;    int i;    MyObject() {      this("hello", "world", 42);    }    public MyObject(String a, String b, int i) {      this.a = a;      this.b = b;      this.i = i;    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.annotations.Since;import com.google.gson.annotations.Until;import com.google.gson.common.TestTypes.BagOfPrimitives;import junit.framework.TestCase;/** * Functional tests for versioning support in Gson. * * @author Inderjeet Singh * @author Joel Leitch */public class VersioningTest extends TestCase {  private static final int A = 0;  private static final int B = 1;  private static final int C = 2;  private static final int D = 3;  private GsonBuilder builder;  @Override  protected void setUp() throws Exception {    super.setUp();    builder = new GsonBuilder();  }  public void testVersionedUntilSerialization() {    Version1 target = new Version1();    Gson gson = builder.setVersion(1.29).create();    String json = gson.toJson(target);    assertTrue(json.contains("\"a\":" + A));        gson = builder.setVersion(1.3).create();    json = gson.toJson(target);    assertFalse(json.contains("\"a\":" + A));  }    public void testVersionedUntilDeserialization() {    Gson gson = builder.setVersion(1.3).create();    String json = "{\"a\":3,\"b\":4,\"c\":5}";    Version1 version1 = gson.fromJson(json, Version1.class);    assertEquals(A, version1.a);  }  public void testVersionedClassesSerialization() {    Gson gson = builder.setVersion(1.0).create();    String json1 = gson.toJson(new Version1());    String json2 = gson.toJson(new Version1_1());    assertEquals(json1, json2);  }  public void testVersionedClassesDeserialization() {    Gson gson = builder.setVersion(1.0).create();    String json = "{\"a\":3,\"b\":4,\"c\":5}";    Version1 version1 = gson.fromJson(json, Version1.class);    assertEquals(3, version1.a);    assertEquals(4, version1.b);    Version1_1 version1_1 = gson.fromJson(json, Version1_1.class);    assertEquals(3, version1_1.a);    assertEquals(4, version1_1.b);    assertEquals(C, version1_1.c);  }  public void testIgnoreLaterVersionClassSerialization() {    Gson gson = builder.setVersion(1.0).create();    assertEquals("", gson.toJson(new Version1_2()));  }  public void testIgnoreLaterVersionClassDeserialization() {    Gson gson = builder.setVersion(1.0).create();    String json = "{\"a\":3,\"b\":4,\"c\":5,\"d\":6}";    Version1_2 version1_2 = gson.fromJson(json, Version1_2.class);    // Since the class is versioned to be after 1.0, all fields should get set to    // their default values.    assertEquals(A, version1_2.a);    assertEquals(B, version1_2.b);    assertEquals(C, version1_2.c);    assertEquals(D, version1_2.d);  }  public void testVersionedGsonWithUnversionedClassesSerialization() {    Gson gson = builder.setVersion(1.0).create();    BagOfPrimitives target = new BagOfPrimitives(10, 20, false, "stringValue");    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testVersionedGsonWithUnversionedClassesDeserialization() {    Gson gson = builder.setVersion(1.0).create();    String json = "{\"longValue\":10,\"intValue\":20,\"booleanValue\":false}";    BagOfPrimitives expected = new BagOfPrimitives();    expected.longValue = 10;    expected.intValue = 20;    expected.booleanValue = false;    BagOfPrimitives actual = gson.fromJson(json, BagOfPrimitives.class);    assertEquals(expected, actual);  }  public void testVersionedGsonMixingSinceAndUntilSerialization() {    Gson gson = builder.setVersion(1.0).create();    SinceUntilMixing target = new SinceUntilMixing();    String json = gson.toJson(target);    assertFalse(json.contains("\"b\":" + B));        gson = builder.setVersion(1.2).create();    json = gson.toJson(target);    assertTrue(json.contains("\"b\":" + B));        gson = builder.setVersion(1.3).create();    json = gson.toJson(target);    assertFalse(json.contains("\"b\":" + B));  }  public void testVersionedGsonMixingSinceAndUntilDeserialization() {    String json = "{\"a\":5,\"b\":6}";    Gson gson = builder.setVersion(1.0).create();    SinceUntilMixing result = gson.fromJson(json, SinceUntilMixing.class);    assertEquals(5, result.a);    assertEquals(B, result.b);        gson = builder.setVersion(1.2).create();    result = gson.fromJson(json, SinceUntilMixing.class);    assertEquals(5, result.a);    assertEquals(6, result.b);        gson = builder.setVersion(1.3).create();    result = gson.fromJson(json, SinceUntilMixing.class);    assertEquals(5, result.a);    assertEquals(B, result.b);  }  private static class Version1 {    @Until(1.3) int a = A;    @Since(1.0) int b = B;  }  private static class Version1_1 extends Version1 {    @Since(1.1) int c = C;  }  @Since(1.2)  private static class Version1_2 extends Version1_1 {    int d = D;  }    private static class SinceUntilMixing {    int a = A;        @Since(1.1)    @Until(1.3)    int b = B;  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.FieldNamingPolicy;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.annotations.SerializedName;import com.google.gson.common.TestTypes.ClassWithSerializedNameFields;import com.google.gson.common.TestTypes.StringWrapper;import junit.framework.TestCase;/** * Functional tests for naming policies. * * @author Inderjeet Singh * @author Joel Leitch */public class NamingPolicyTest extends TestCase {  private GsonBuilder builder;  @Override  protected void setUp() throws Exception {    super.setUp();    builder = new GsonBuilder();  }  public void testGsonWithNonDefaultFieldNamingPolicySerialization() {    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();    StringWrapper target = new StringWrapper("blah");    assertEquals("{\"SomeConstantStringInstanceField\":\""        + target.someConstantStringInstanceField + "\"}", gson.toJson(target));  }  public void testGsonWithNonDefaultFieldNamingPolicyDeserialiation() {    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();    StringWrapper target = new StringWrapper("SomeValue");    String jsonRepresentation = gson.toJson(target);    StringWrapper deserializedObject = gson.fromJson(jsonRepresentation, StringWrapper.class);    assertEquals(target.someConstantStringInstanceField,        deserializedObject.someConstantStringInstanceField);  }  public void testGsonWithSerializedNameFieldNamingPolicySerialization() {    Gson gson = builder.create();    ClassWithSerializedNameFields expected = new ClassWithSerializedNameFields(5);    String actual = gson.toJson(expected);    assertEquals(expected.getExpectedJson(), actual);  }  public void testGsonWithSerializedNameFieldNamingPolicyDeserialization() {    Gson gson = builder.create();    ClassWithSerializedNameFields expected = new ClassWithSerializedNameFields(5);    ClassWithSerializedNameFields actual =        gson.fromJson(expected.getExpectedJson(), ClassWithSerializedNameFields.class);    assertEquals(expected.f, actual.f);  }    public void testGsonDuplicateNameUsingSerializedNameFieldNamingPolicySerialization() {    Gson gson = builder.create();    ClassWithDuplicateFields target = new ClassWithDuplicateFields(10);    String actual = gson.toJson(target);    assertEquals("{\"a\":10}", actual);        target = new ClassWithDuplicateFields(3.0D);    actual = gson.toJson(target);    assertEquals("{\"a\":3.0}", actual);  }  @SuppressWarnings("unused")  private static class ClassWithDuplicateFields {    public Integer a;    @SerializedName("a") public Double b;        public ClassWithDuplicateFields(Integer a) {      this(a, null);    }        public ClassWithDuplicateFields(Double b) {      this(null, b);    }        public ClassWithDuplicateFields(Integer a, Double b) {      this.a = a;      this.b = b;    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.common.TestTypes.BagOfPrimitives;import com.google.gson.common.TestTypes.ClassWithTransientFields;import com.google.gson.common.TestTypes.Nested;import com.google.gson.common.TestTypes.PrimitiveArray;import junit.framework.TestCase;import java.util.ArrayList;import java.util.List;/** * Functional tests for print formatting. * * @author Inderjeet Singh * @author Joel Leitch */public class PrintFormattingTest extends TestCase {  @SuppressWarnings("unchecked")  public void testCompactFormattingLeavesNoWhiteSpace() {    Gson gson = new Gson();    List list = new ArrayList();    list.add(new BagOfPrimitives());    list.add(new Nested());    list.add(new PrimitiveArray());    list.add(new ClassWithTransientFields());    String json = gson.toJson(list);    assertContainsNoWhiteSpace(json);  }  private static void assertContainsNoWhiteSpace(String str) {    for (char c : str.toCharArray()) {      assertFalse(Character.isWhitespace(c));    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import junit.framework.TestCase;/** * Functional tests for internationalized strings. * * @author Inderjeet Singh */public class InternationalizationTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  /*  public void testStringsWithRawChineseCharactersSerialization() throws Exception {    String target = "好好好";    String json = gson.toJson(target);    String expected = "\"\\u597d\\u597d\\u597d\"";    assertEquals(expected, json);  }  */  public void testStringsWithRawChineseCharactersDeserialization() throws Exception {    String expected = "好好好";    String json = "\"" + expected + "\"";    String actual = gson.fromJson(json, String.class);    assertEquals(expected, actual);  }  public void testStringsWithUnicodeChineseCharactersSerialization() throws Exception {    String target = "\u597d\u597d\u597d";    String json = gson.toJson(target);    String expected = "\"\u597d\u597d\u597d\"";    assertEquals(expected, json);  }  public void testStringsWithUnicodeChineseCharactersDeserialization() throws Exception {    String expected = "\u597d\u597d\u597d";    String json = "\"" + expected + "\"";    String actual = gson.fromJson(json, String.class);    assertEquals(expected, actual);  }  public void testStringsWithUnicodeChineseCharactersEscapedDeserialization() throws Exception {    String actual = gson.fromJson("'\\u597d\\u597d\\u597d'", String.class);    assertEquals("\u597d\u597d\u597d", actual);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.common.TestTypes.BagOfPrimitives;import junit.framework.TestCase;/** * Performs some functional test involving JSON output escaping. * * @author Inderjeet Singh * @author Joel Leitch */public class EscapingTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testEscapingQuotesInStringArray() throws Exception {    String[] valueWithQuotes = { "beforeQuote\"afterQuote" };    String jsonRepresentation = gson.toJson(valueWithQuotes);    String[] target = gson.fromJson(jsonRepresentation, String[].class);    assertEquals(1, target.length);    assertEquals(valueWithQuotes[0], target[0]);  }  public void testEscapingObjectFields() throws Exception {    BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, "test with\" <script>");    String jsonRepresentation = gson.toJson(objWithPrimitives);    assertFalse(jsonRepresentation.contains("<"));    assertFalse(jsonRepresentation.contains(">"));    assertTrue(jsonRepresentation.contains("\\\""));    BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class);    assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson());  }    public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() throws Exception {    Gson escapeHtmlGson = new GsonBuilder().create();    Gson noEscapeHtmlGson = new GsonBuilder().disableHtmlEscaping().create();        BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>");    String escapedJsonForm = escapeHtmlGson.toJson(target);    String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target);    assertFalse(escapedJsonForm.equals(nonEscapedJsonForm));        assertEquals(target, noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class));    assertEquals(target, escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.common.MoreAsserts;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.ArrayList;import java.util.Collection;/** * Functional tests for Java 5.0 enums. * * @author Inderjeet Singh * @author Joel Leitch */public class EnumTest extends TestCase {    private Gson gson;    @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }    public void testTopLevelEnumSerialization() throws Exception {    String result = gson.toJson(MyEnum.VALUE1);    assertEquals('"' + MyEnum.VALUE1.toString() + '"', result);  }    public void testTopLevelEnumDeserialization() throws Exception {    MyEnum result = gson.fromJson('"' + MyEnum.VALUE1.toString() + '"', MyEnum.class);    assertEquals(MyEnum.VALUE1, result);  }    public void testTopLevelEnumInASingleElementArrayDeserialization() {    String json = "[" + MyEnum.VALUE1.getExpectedJson() + "]";    MyEnum target = gson.fromJson(json, MyEnum.class);    assertEquals(json, "[" + target.getExpectedJson() + "]");  }  public void testCollectionOfEnumsSerialization() {    Type type = new TypeToken<Collection<MyEnum>>() {}.getType();    Collection<MyEnum> target = new ArrayList<MyEnum>();    target.add(MyEnum.VALUE1);    target.add(MyEnum.VALUE2);    String expectedJson = "[\"VALUE1\",\"VALUE2\"]";    String actualJson = gson.toJson(target);    assertEquals(expectedJson, actualJson);    actualJson = gson.toJson(target, type);    assertEquals(expectedJson, actualJson);  }  public void testCollectionOfEnumsDeserialization() {    Type type = new TypeToken<Collection<MyEnum>>() {}.getType();    String json = "[\"VALUE1\",\"VALUE2\"]";    Collection<MyEnum> target = gson.fromJson(json, type);    MoreAsserts.assertContains(target, MyEnum.VALUE1);    MoreAsserts.assertContains(target, MyEnum.VALUE2);  }  public void testClassWithEnumFieldSerialization() throws Exception {    ClassWithEnumFields target = new ClassWithEnumFields();    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testClassWithEnumFieldDeserialization() throws Exception {    String json = "{value1:'VALUE1',value2:'VALUE2'}";    ClassWithEnumFields target = gson.fromJson(json, ClassWithEnumFields.class);    assertEquals(MyEnum.VALUE1,target.value1);    assertEquals(MyEnum.VALUE2,target.value2);  }    private static enum MyEnum {    VALUE1, VALUE2;    public String getExpectedJson() {      return "\"" + toString() + "\"";    }  }  private static class ClassWithEnumFields {    private final MyEnum value1 = MyEnum.VALUE1;    private final MyEnum value2 = MyEnum.VALUE2;    public String getExpectedJson() {      return "{\"value1\":\"" + value1 + "\",\"value2\":\"" + value2 + "\"}";    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import java.lang.reflect.Type;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.InstanceCreator;import com.google.gson.annotations.Expose;import junit.framework.TestCase;/** * Unit tests for the regarding functional "@Expose" type tests. * * @author Joel Leitch */public class ExposeFieldsTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new GsonBuilder()        .excludeFieldsWithoutExposeAnnotation()        .registerTypeAdapter(SomeInterface.class, new SomeInterfaceInstanceCreator())        .create();  }  public void testNullExposeFieldSerialization() throws Exception {    ClassWithExposedFields object = new ClassWithExposedFields(null, 1);    String json = gson.toJson(object);    assertEquals(object.getExpectedJson(), json);  }  public void testArrayWithOneNullExposeFieldObjectSerialization() throws Exception {    ClassWithExposedFields object1 = new ClassWithExposedFields(1, 1);    ClassWithExposedFields object2 = new ClassWithExposedFields(null, 1);    ClassWithExposedFields object3 = new ClassWithExposedFields(2, 2);    ClassWithExposedFields[] objects = { object1, object2, object3 };    String json = gson.toJson(objects);    String expected = new StringBuilder()        .append('[').append(object1.getExpectedJson()).append(',')        .append(object2.getExpectedJson()).append(',')        .append(object3.getExpectedJson()).append(']')        .toString();    assertEquals(expected, json);  }  public void testExposeAnnotationSerialization() throws Exception {    ClassWithExposedFields target = new ClassWithExposedFields(1, 2);    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testExposeAnnotationDeserialization() throws Exception {    String json = "{a:3,b:4,d:20.0}";    ClassWithExposedFields target = gson.fromJson(json, ClassWithExposedFields.class);    assertEquals(3, (int) target.a);    assertNull(target.b);    assertFalse(target.d == 20);  }  public void testNoExposedFieldSerialization() throws Exception {    ClassWithNoExposedFields obj = new ClassWithNoExposedFields();    String json = gson.toJson(obj);    assertEquals("{}", json);  }  public void testNoExposedFieldDeserialization() throws Exception {    String json = "{a:4,b:5}";    ClassWithNoExposedFields obj = gson.fromJson(json, ClassWithNoExposedFields.class);    assertEquals(0, obj.a);    assertEquals(1, obj.b);  }    public void testExposedInterfaceFieldSerialization() throws Exception {    String expected = "{\"interfaceField\":{}}";    ClassWithInterfaceField target = new ClassWithInterfaceField(new SomeObject());    String actual = gson.toJson(target);        assertEquals(expected, actual);  }    public void testExposedInterfaceFieldDeserialization() throws Exception {    String json = "{\"interfaceField\":{}}";    ClassWithInterfaceField obj = gson.fromJson(json, ClassWithInterfaceField.class);    assertNotNull(obj.interfaceField);  }  @SuppressWarnings("unused")  private static class ClassWithExposedFields {    @Expose private final Integer a;    private final Integer b;    @Expose(serialize = false) final long c;    @Expose(deserialize = false) final double d;    @Expose(serialize = false, deserialize = false) final char e;    // For use by Gson    private ClassWithExposedFields() {      this(null, null);    }    public ClassWithExposedFields(Integer a, Integer b) {      this(a, b, 1L, 2.0, 'a');    }    public ClassWithExposedFields(Integer a, Integer b, long c, double d, char e) {      this.a = a;      this.b = b;      this.c = c;      this.d = d;      this.e = e;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder("{");      if (a != null) {        sb.append("\"a\":").append(a).append(",");      }      sb.append("\"d\":").append(d);      sb.append("}");      return sb.toString();    }  }  private static class ClassWithNoExposedFields {    private final int a = 0;    private final int b = 1;  }    private static interface SomeInterface {    // Empty interface  }    private static class SomeObject implements SomeInterface {    // Do nothing  }    private static class SomeInterfaceInstanceCreator implements InstanceCreator<SomeInterface> {    public SomeInterface createInstance(Type type) {      return new SomeObject();    }  }    private static class ClassWithInterfaceField {    @Expose    private final SomeInterface interfaceField;    // For use by Gson    @SuppressWarnings("unused")    private ClassWithInterfaceField() {      this(null);    }    public ClassWithInterfaceField(SomeInterface interfaceField) {      this.interfaceField = interfaceField;    }  }  }
package com.google.gson.functional;import com.google.gson.Gson;import junit.framework.TestCase;/** * Functional tests for Json serialization and deserialization of strings. * * @author Inderjeet Singh * @author Joel Leitch */public class StringTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }    public void testStringValueSerialization() throws Exception {    String value = "someRandomStringValue";    assertEquals('"' + value + '"', gson.toJson(value));  }  public void testStringValueDeserialization() throws Exception {    String value = "someRandomStringValue";    String actual = gson.fromJson("\"" + value + "\"", String.class);    assertEquals(value, actual);  }  public void testSingleQuoteInStringSerialization() throws Exception {    String valueWithQuotes = "beforeQuote'afterQuote";    String jsonRepresentation = gson.toJson(valueWithQuotes);    assertEquals(valueWithQuotes, gson.fromJson(jsonRepresentation, String.class));  }  public void testEscapedCtrlNInStringSerialization() throws Exception {    String value = "a\nb";    String json = gson.toJson(value);    assertEquals("\"a\\nb\"", json);  }  public void testEscapedCtrlNInStringDeserialization() throws Exception {    String json = "'a\\nb'";    String actual = gson.fromJson(json, String.class);    assertEquals("a\nb", actual);  }  public void testEscapedCtrlRInStringSerialization() throws Exception {    String value = "a\rb";    String json = gson.toJson(value);    assertEquals("\"a\\rb\"", json);  }  public void testEscapedCtrlRInStringDeserialization() throws Exception {    String json = "'a\\rb'";    String actual = gson.fromJson(json, String.class);    assertEquals("a\rb", actual);  }  public void testEscapedBackslashInStringSerialization() throws Exception {    String value = "a\\b";    String json = gson.toJson(value);    assertEquals("\"a\\\\b\"", json);  }  public void testEscapedBackslashInStringDeserialization() throws Exception {    String actual = gson.fromJson("'a\\\\b'", String.class);    assertEquals("a\\b", actual);  }  public void testSingleQuoteInStringDeserialization() throws Exception {    String value = "beforeQuote'afterQuote";    String actual = gson.fromJson("\"" + value + "\"", String.class);    assertEquals(value, actual);  }  public void testEscapingQuotesInStringSerialization() throws Exception {    String valueWithQuotes = "beforeQuote\"afterQuote";    String jsonRepresentation = gson.toJson(valueWithQuotes);    String target = gson.fromJson(jsonRepresentation, String.class);    assertEquals(valueWithQuotes, target);  }  public void testEscapingQuotesInStringDeserialization() throws Exception {    String value = "beforeQuote\\\"afterQuote";    String actual = gson.fromJson("\"" + value + "\"", String.class);    String expected = "beforeQuote\"afterQuote";    assertEquals(expected, actual);  }  public void testStringValueAsSingleElementArraySerialization() throws Exception {    String[] target = {"abc"};    assertEquals("[\"abc\"]", gson.toJson(target));    assertEquals("[\"abc\"]", gson.toJson(target, String[].class));  }  public void testStringValueAsSingleElementArrayDeserialization() throws Exception {    String value = "someRandomStringValue";    String actual = gson.fromJson("[\"" + value + "\"]", String.class);    assertEquals(value, actual);  }    public void testStringWithEscapedSlashDeserialization() {    String value = "/";    String json = "'\\/'";    String actual = gson.fromJson(json, String.class);    assertEquals(value, actual);  }    /**   * Created in response to http://groups.google.com/group/google-gson/browse_thread/thread/2431d4a3d0d6cb23   */  public void testAssignmentCharSerialization() {    String value = "abc=";    String json = gson.toJson(value);    assertEquals("\"abc\\u003d\"", json);  }    /**   * Created in response to http://groups.google.com/group/google-gson/browse_thread/thread/2431d4a3d0d6cb23   */  public void testAssignmentCharDeserialization() {    String json = "\"abc=\"";    String value = gson.fromJson(json, String.class);    assertEquals("abc=", value);    json = "'abc\u003d'";    value = gson.fromJson(json, String.class);    assertEquals("abc=", value);  }    public void testJavascriptKeywordsInStringSerialization() {    String value = "null true false function";    String json = gson.toJson(value);    assertEquals("\"" + value + "\"", json);  }    public void testJavascriptKeywordsInStringDeserialization() {    String json = "'null true false function'";    String value = gson.fromJson(json, String.class);    assertEquals(json.substring(1, json.length() - 1), value);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.common.TestTypes.BagOfPrimitives;import junit.framework.TestCase;/** * Tests for security-related aspects of Gson *  * @author Inderjeet Singh */public class SecurityTest extends TestCase {  /**   * Keep this in sync with Gson.JSON_NON_EXECUTABLE_PREFIX   */  private static final String JSON_NON_EXECUTABLE_PREFIX = ")]}'\n";  private GsonBuilder gsonBuilder;  @Override  protected void setUp() throws Exception {    super.setUp();    gsonBuilder = new GsonBuilder();  }  public void testNonExecutableJsonSerialization() {    Gson gson = gsonBuilder.generateNonExecutableJson().create();    String json = gson.toJson(new BagOfPrimitives());    assertTrue(json.startsWith(JSON_NON_EXECUTABLE_PREFIX));  }    public void testNonExecutableJsonDeserialization() {    String json = JSON_NON_EXECUTABLE_PREFIX + "{longValue:1}";    Gson gson = gsonBuilder.create();    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);    assertEquals(1, target.longValue);  }    public void testJsonWithNonExectuableTokenSerialization() {    Gson gson = gsonBuilder.generateNonExecutableJson().create();    String json = gson.toJson(JSON_NON_EXECUTABLE_PREFIX);    assertTrue(json.contains(")]}'\n"));  }    /**   *  Gson should be able to deserialize a stream with non-exectuable token even if it is created   *  without {@link GsonBuilder#generateNonExecutableJson()}.   */  public void testJsonWithNonExectuableTokenWithRegularGsonDeserialization() {    Gson gson = gsonBuilder.create();    String json = JSON_NON_EXECUTABLE_PREFIX + "{stringValue:')]}\\u0027\\n'}";    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);    assertEquals(")]}'\n", target.stringValue);  }      /**   *  Gson should be able to deserialize a stream with non-exectuable token if it is created   *  with {@link GsonBuilder#generateNonExecutableJson()}.   */  public void testJsonWithNonExectuableTokenWithConfiguredGsonDeserialization() {    // Gson should be able to deserialize a stream with non-exectuable token even if it is created     Gson gson = gsonBuilder.generateNonExecutableJson().create();    String json = JSON_NON_EXECUTABLE_PREFIX + "{intValue:2,stringValue:')]}\\u0027\\n'}";    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);    assertEquals(")]}'\n", target.stringValue);    assertEquals(2, target.intValue);  }  }
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.functional;import java.lang.reflect.Type;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.JsonDeserializationContext;import com.google.gson.JsonDeserializer;import com.google.gson.JsonElement;import com.google.gson.JsonObject;import com.google.gson.JsonParseException;import junit.framework.TestCase;/** * Functional Test exercising custom deserialization only.  When test applies to both  * serialization and deserialization then add it to CustomTypeAdapterTest. * * @author Joel Leitch */public class CustomDeserializerTest extends TestCase {  private static final String DEFAULT_VALUE = "test123";  private static final String SUFFIX = "blah";    private Gson gson;    @Override  protected void setUp() throws Exception {    super.setUp();    gson = new GsonBuilder().registerTypeAdapter(DataHolder.class, new DataHolderDeserializer()).create();  }    public void testDefaultConstructorNotCalledOnObject() throws Exception {    DataHolder data = new DataHolder(DEFAULT_VALUE);    String json = gson.toJson(data);        DataHolder actual = gson.fromJson(json, DataHolder.class);    assertEquals(DEFAULT_VALUE + SUFFIX, actual.getData());  }    public void testDefaultConstructorNotCalledOnField() throws Exception {    DataHolderWrapper dataWrapper = new DataHolderWrapper(new DataHolder(DEFAULT_VALUE));    String json = gson.toJson(dataWrapper);        DataHolderWrapper actual = gson.fromJson(json, DataHolderWrapper.class);    assertEquals(DEFAULT_VALUE + SUFFIX, actual.getWrappedData().getData());  }  private static class DataHolder {    private final String data;    // For use by Gson    @SuppressWarnings("unused")    private DataHolder() {      throw new IllegalStateException();    }        public DataHolder(String data) {      this.data = data;    }        public String getData() {      return data;    }  }    private static class DataHolderWrapper {    private final DataHolder wrappedData;        // For use by Gson    @SuppressWarnings("unused")    private DataHolderWrapper() {      this(new DataHolder(DEFAULT_VALUE));    }        public DataHolderWrapper(DataHolder data) {      this.wrappedData = data;    }    public DataHolder getWrappedData() {      return wrappedData;    }  }    private static class DataHolderDeserializer implements JsonDeserializer<DataHolder> {    public DataHolder deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)        throws JsonParseException {      JsonObject jsonObj = json.getAsJsonObject();      String dataString = jsonObj.get("data").getAsString();      return new DataHolder(dataString + SUFFIX);    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.metrics;import com.google.gson.Gson;import com.google.gson.JsonParseException;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.ArrayList;import java.util.List;/** * Tests to measure performance for Gson. All tests in this file will be disabled in code. To run * them remove disabled_ prefix from the tests and run them. *  * @author Inderjeet Singh * @author Joel Leitch */public class PerformanceTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }    public void testDummy() {        // This is here to prevent Junit for complaining when we disable all tests.  }    public void disabled_testStringDeserialization() {        StringBuilder sb = new StringBuilder(8096);    sb.append("Error Yippie");    while (true) {      try {        String stackTrace = sb.toString();        sb.append(stackTrace);        String json = "{\"message\":\"Error message.\"," + "\"stackTrace\":\"" + stackTrace + "\"}";        parseLongJson(json);        System.out.println("Gson could handle a string of size: " + stackTrace.length());      } catch (JsonParseException expected) {        break;      }    }  }    private void parseLongJson(String json) throws JsonParseException {    ExceptionHolder target = gson.fromJson(json, ExceptionHolder.class);    assertTrue(target.message.contains("Error"));    assertTrue(target.stackTrace.contains("Yippie"));  }  private static class ExceptionHolder {    public final String message;    public final String stackTrace;        // For use by Gson    @SuppressWarnings("unused")    private ExceptionHolder() {      this("", "");    }    public ExceptionHolder(String message, String stackTrace) {      this.message = message;      this.stackTrace = stackTrace;    }  }  @SuppressWarnings("unused")  private static class CollectionEntry {    final String name;    final String value;    // For use by Gson    private CollectionEntry() {      this(null, null);    }    CollectionEntry(String name, String value) {      this.name = name;      this.value = value;    }  }    /**   * Created in response to http://code.google.com/p/google-gson/issues/detail?id=96   */  public void disabled_testLargeCollectionSerialization() {    int count = 1400000;    List<CollectionEntry> list = new ArrayList<CollectionEntry>(count);    for (int i = 0; i < count; ++i) {      list.add(new CollectionEntry("name"+i,"value"+i));    }        gson.toJson(list);  }    /**   * Created in response to http://code.google.com/p/google-gson/issues/detail?id=96   */  public void disabled_testLargeCollectionDeserialization() {    StringBuilder sb = new StringBuilder();    int count = 87000;    boolean first = true;    sb.append('[');    for (int i = 0; i < count; ++i) {      if (first) {        first = false;      } else {        sb.append(',');      }      sb.append("{name:'name").append(i).append("',value:'value").append(i).append("'}");    }        sb.append(']');    String json = sb.toString();    Type collectionType = new TypeToken<ArrayList<CollectionEntry>>(){}.getType();        List<CollectionEntry> list = gson.fromJson(json, collectionType);           assertEquals(count, list.size());  }  /**   * Created in response to http://code.google.com/p/google-gson/issues/detail?id=96   */  // Last I tested, Gson was able to serialize upto 14MB byte array  public void disable_testByteArraySerialization() {    for (int size = 4145152; true; size += 1036288) {      byte[] ba = new byte[size];      for (int i = 0; i < size; ++i) {        ba[i] = 0x05;      }      gson.toJson(ba);      System.out.printf("Gson could serialize a byte array of size: %d\n", size);    }  }    /**   * Created in response to http://code.google.com/p/google-gson/issues/detail?id=96   */  // Last I tested, Gson was able to deserialize a byte array of 11MB  public void disable_testByteArrayDeserialization() {    for (int numElements = 10639296; true; numElements += 16384) {      StringBuilder sb = new StringBuilder(numElements*2);      sb.append("[");      boolean first = true;      for (int i = 0; i < numElements; ++i) {        if (first) {          first = false;        } else {          sb.append(",");        }        sb.append("5");      }      sb.append("]");      String json = sb.toString();      byte[] ba = gson.fromJson(json, byte[].class);      System.out.printf("Gson could deserialize a byte array of size: %d\n", ba.length);    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.common;import java.lang.reflect.Type;import com.google.gson.JsonDeserializationContext;import com.google.gson.JsonDeserializer;import com.google.gson.JsonElement;import com.google.gson.JsonParseException;import com.google.gson.JsonPrimitive;import com.google.gson.JsonSerializationContext;import com.google.gson.JsonSerializer;import com.google.gson.annotations.SerializedName;/** * Types used for testing JSON serialization and deserialization * * @author Inderjeet Singh * @author Joel Leitch */public class TestTypes {  public static class StringWrapper {    public final String someConstantStringInstanceField;    StringWrapper() {      this("Blah");    }    public StringWrapper(String value) {      someConstantStringInstanceField = value;    }  }  public static class BagOfPrimitives {    public static final long DEFAULT_VALUE = 0;    public long longValue;    public int intValue;    public boolean booleanValue;    public String stringValue;    public BagOfPrimitives() {      this(DEFAULT_VALUE, 0, false, "");    }    public BagOfPrimitives(long longValue, int intValue, boolean booleanValue, String stringValue) {      this.longValue = longValue;      this.intValue = intValue;      this.booleanValue = booleanValue;      this.stringValue = stringValue;    }    public int getIntValue() {      return intValue;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{");      sb.append("\"longValue\":").append(longValue).append(",");      sb.append("\"intValue\":").append(intValue).append(",");      sb.append("\"booleanValue\":").append(booleanValue).append(",");      sb.append("\"stringValue\":\"").append(stringValue).append("\"");      sb.append("}");      return sb.toString();    }    @Override    public int hashCode() {      final int prime = 31;      int result = 1;      result = prime * result + (booleanValue ? 1231 : 1237);      result = prime * result + intValue;      result = prime * result + (int) (longValue ^ (longValue >>> 32));      result = prime * result + ((stringValue == null) ? 0 : stringValue.hashCode());      return result;    }    @Override    public boolean equals(Object obj) {      if (this == obj)        return true;      if (obj == null)        return false;      if (getClass() != obj.getClass())        return false;      BagOfPrimitives other = (BagOfPrimitives) obj;      if (booleanValue != other.booleanValue)        return false;      if (intValue != other.intValue)        return false;      if (longValue != other.longValue)        return false;      if (stringValue == null) {        if (other.stringValue != null)          return false;      } else if (!stringValue.equals(other.stringValue))        return false;      return true;    }    @Override    public String toString() {      return String.format("(longValue=%d,intValue=%d,booleanValue=%b,stringValue=%s)",          longValue, intValue, booleanValue, stringValue);    }  }  public static class BagOfPrimitiveWrappers {    private final Long longValue;    private final Integer intValue;    private final Boolean booleanValue;    public BagOfPrimitiveWrappers() {      this(0L, 0, false);    }    public BagOfPrimitiveWrappers(Long longValue, Integer intValue, Boolean booleanValue) {      this.longValue = longValue;      this.intValue = intValue;      this.booleanValue = booleanValue;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{");      sb.append("\"longValue\":").append(longValue).append(",");      sb.append("\"intValue\":").append(intValue).append(",");      sb.append("\"booleanValue\":").append(booleanValue);      sb.append("}");      return sb.toString();    }  }  public static class PrimitiveArray {    private final long[] longArray;    public PrimitiveArray() {      this(new long[0]);    }    public PrimitiveArray(long[] longArray) {      this.longArray = longArray;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{\"longArray\":[");      boolean first = true;      for (long l : longArray) {        if (!first) {          sb.append(",");        } else {          first = false;        }        sb.append(l);      }      sb.append("]}");      return sb.toString();    }  }  public static class ClassWithNoFields {    // Nothing here.. .    @Override    public boolean equals(Object other) {      return other.getClass() == ClassWithNoFields.class;    }  }  public static class Nested {    private final BagOfPrimitives primitive1;    private final BagOfPrimitives primitive2;    public Nested() {      this(null, null);    }    public Nested(BagOfPrimitives primitive1, BagOfPrimitives primitive2) {      this.primitive1 = primitive1;      this.primitive2 = primitive2;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{");      appendFields(sb);      sb.append("}");      return sb.toString();    }    public void appendFields(StringBuilder sb) {      if (primitive1 != null) {        sb.append("\"primitive1\":").append(primitive1.getExpectedJson());      }      if (primitive1 != null && primitive2 != null) {        sb.append(",");      }      if (primitive2 != null) {        sb.append("\"primitive2\":").append(primitive2.getExpectedJson());      }    }  }  public static class ClassWithTransientFields<T> {    public transient T transientT;     public final transient long transientLongValue;    private final long[] longValue;    public ClassWithTransientFields() {      this(0L);    }    public ClassWithTransientFields(long value) {      longValue = new long[] { value };      transientLongValue = value + 1;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{");      sb.append("\"longValue\":[").append(longValue[0]).append("]");      sb.append("}");      return sb.toString();    }  }  public static class ClassWithCustomTypeConverter {    private final BagOfPrimitives bag;    private final int value;    public ClassWithCustomTypeConverter() {      this(new BagOfPrimitives(), 10);    }    public ClassWithCustomTypeConverter(int value) {      this(new BagOfPrimitives(value, value, false, ""), value);    }    public ClassWithCustomTypeConverter(BagOfPrimitives bag, int value) {      this.bag = bag;      this.value = value;    }    public BagOfPrimitives getBag() {      return bag;    }    public String getExpectedJson() {      return "{\"url\":\"" + bag.getExpectedJson() + "\",\"value\":" + value + "}";    }    public int getValue() {      return value;    }  }  public static class ArrayOfObjects {    private final BagOfPrimitives[] elements;    public ArrayOfObjects() {      elements = new BagOfPrimitives[3];      for (int i = 0; i < elements.length; ++i) {        elements[i] = new BagOfPrimitives(i, i+2, false, "i"+i);      }    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder("{\"elements\":[");      boolean first = true;      for (BagOfPrimitives element : elements) {        if (first) {          first = false;        } else {          sb.append(",");        }        sb.append(element.getExpectedJson());      }      sb.append("]}");      return sb.toString();    }  }  public static class ClassOverridingEquals {    public ClassOverridingEquals ref;    public String getExpectedJson() {      if (ref == null) {        return "{}";      }      return "{\"ref\":" + ref.getExpectedJson() + "}";    }    @Override    public boolean equals(Object obj) {      return true;    }    @Override    public int hashCode() {      return 1;    }  }  public static class ClassWithArray {    public final Object[] array;    public ClassWithArray() {      array = null;    }    public ClassWithArray(Object[] array) {      this.array = array;    }  }  public static class ClassWithObjects {    public final BagOfPrimitives bag;    public ClassWithObjects() {      this(new BagOfPrimitives());    }    public ClassWithObjects(BagOfPrimitives bag) {      this.bag = bag;    }  }  public static class ClassWithSerializedNameFields {    @SerializedName("fooBar") public final int f;    public ClassWithSerializedNameFields() {      this(1);    }    public ClassWithSerializedNameFields(int f) {      this.f = f;    }    public String getExpectedJson() {      return '{' + "\"fooBar\":" + f + '}';    }  }    public static class CrazyLongTypeAdapter      implements JsonSerializer<Long>, JsonDeserializer<Long> {    public static final long DIFFERENCE = 5L;    public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context) {      return new JsonPrimitive(src + DIFFERENCE);    }        public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)        throws JsonParseException {      return json.getAsLong() - DIFFERENCE;    }}}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;/** * Performs some unit testing for the {@link JsonEscapingVisitor} class. * * @author Joel Leitch */public class JsonEscapingVisitorTest extends TestCase {  private StubbedJsonElementVisitor stubVisitor;  private JsonEscapingVisitor escapingVisitor;  private Escaper escaper;  @Override  protected void setUp() throws Exception {    super.setUp();    stubVisitor = new StubbedJsonElementVisitor();    escaper = new Escaper(true);    escapingVisitor = new JsonEscapingVisitor(stubVisitor, escaper);  }  public void testNonStringPrimitiveVisitation() throws Exception {    boolean value = true;    JsonPrimitive primitive = new JsonPrimitive(value);    escapingVisitor.visitPrimitive(primitive);    assertEquals(value, stubVisitor.primitiveReceived.getAsBoolean());  }  public void testStringPrimitiveVisitationNoEscapingRequired() throws Exception {    String value = "Testing123";    JsonPrimitive primitive = new JsonPrimitive(value);    escapingVisitor.visitPrimitive(primitive);    assertEquals(value, stubVisitor.primitiveReceived.getAsObject());  }  public void testStringPrimitiveVisitationEscapingRequired() throws Exception {    String value = "Testing\"123";    JsonPrimitive primitive = new JsonPrimitive(value);    escapingVisitor.visitPrimitive(primitive);    assertEquals(escaper.escapeJsonString(value), stubVisitor.primitiveReceived.getAsString());  }  public void testNonStringArrayVisitation() throws Exception {    int value = 123;    JsonPrimitive primitive = new JsonPrimitive(value);    JsonArray array = new JsonArray();    array.add(primitive);    escapingVisitor.visitArrayMember(array, primitive, true);    assertEquals(value, stubVisitor.primitiveReceived.getAsInt());  }  public void testStringArrayVisitationNoEscaping() throws Exception {    String value = "Testing123";    JsonPrimitive primitive = new JsonPrimitive(value);    JsonArray array = new JsonArray();    array.add(primitive);    escapingVisitor.visitArrayMember(array, primitive, true);    assertEquals(value, stubVisitor.primitiveReceived.getAsString());  }  public void testStringArrayVisitationEscapingRequired() throws Exception {    String value = "Testing\"123";    JsonPrimitive primitive = new JsonPrimitive(value);    JsonArray array = new JsonArray();    array.add(primitive);    escapingVisitor.visitArrayMember(array, primitive, true);    assertEquals(escaper.escapeJsonString(value), stubVisitor.primitiveReceived.getAsString());  }  public void testNonStringFieldVisitation() throws Exception {    String fieldName = "fieldName";    int value = 123;    JsonPrimitive primitive = new JsonPrimitive(value);    JsonObject object = new JsonObject();    object.addProperty(fieldName, value);    escapingVisitor.visitObjectMember(object, fieldName, primitive, true);    assertEquals(value, stubVisitor.primitiveReceived.getAsInt());  }  public void testStringFieldVisitationNoEscaping() throws Exception {    String fieldName = "fieldName";    String value = "Testing123";    JsonPrimitive primitive = new JsonPrimitive(value);    JsonObject object = new JsonObject();    object.addProperty(fieldName, value);    escapingVisitor.visitObjectMember(object, fieldName, primitive, true);    assertEquals(value, stubVisitor.primitiveReceived.getAsString());  }  public void testStringFieldVisitationEscapingRequired() throws Exception {    String fieldName = "fieldName";    String value = "Testing\"123";    JsonPrimitive primitive = new JsonPrimitive(value);    JsonObject object = new JsonObject();    object.addProperty(fieldName, value);    escapingVisitor.visitObjectMember(object, fieldName, primitive, true);    assertEquals(escaper.escapeJsonString(value), stubVisitor.primitiveReceived.getAsString());  }  private static class StubbedJsonElementVisitor implements JsonElementVisitor {    public JsonPrimitive primitiveReceived;    public void endArray(JsonArray array) {      // Do nothing    }    public void endObject(JsonObject object) {      // Do nothing    }    public void startArray(JsonArray array) {      // Do nothing    }    public void startObject(JsonObject object) {      // Do nothing    }    public void visitArrayMember(JsonArray parent, JsonPrimitive member, boolean isFirst) {      primitiveReceived = member;    }    public void visitArrayMember(JsonArray parent, JsonArray member, boolean isFirst) {      // Do nothing    }    public void visitArrayMember(JsonArray parent, JsonObject member, boolean isFirst) {      // Do nothing    }    public void visitObjectMember(        JsonObject parent, String memberName, JsonPrimitive member, boolean isFirst) {      primitiveReceived = member;    }    public void visitObjectMember(        JsonObject parent, String memberName, JsonArray member, boolean isFirst) {      // Do nothing    }    public void visitObjectMember(        JsonObject parent, String memberName, JsonObject member, boolean isFirst) {      // Do nothing    }    public void visitPrimitive(JsonPrimitive primitive) {      primitiveReceived = primitive;    }    public void visitNullArrayMember(JsonArray parent, boolean isFirst) {      // Do nothing    }    public void visitNull() {      // Do nothing          }    public void visitNullObjectMember(JsonObject parent, String memberName, boolean isFirst) {      // Do nothing          }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.List;/** * Unit tests for the {@link ParameterizedTypeHandlerMap} class. * * @author Joel Leitch */public class ParameterizedTypeHandlerMapTest extends TestCase {  private ParameterizedTypeHandlerMap<String> paramMap;  @Override  protected void setUp() throws Exception {    super.setUp();    paramMap = new ParameterizedTypeHandlerMap<String>();  }  public void testNullMap() throws Exception {    assertFalse(paramMap.hasSpecificHandlerFor(String.class));    assertNull(paramMap.getHandlerFor(String.class));    assertNull(paramMap.getHandlerFor(String.class));  }  public void testHasGenericButNotSpecific() throws Exception {    Type specificType = new TypeToken<List<String>>() {}.getType();    String handler = "blah";    paramMap.register(List.class, handler);    assertFalse(paramMap.hasSpecificHandlerFor(specificType));    assertTrue(paramMap.hasSpecificHandlerFor(List.class));    assertNotNull(paramMap.getHandlerFor(specificType));    assertNotNull(paramMap.getHandlerFor(List.class));    assertEquals(handler, paramMap.getHandlerFor(specificType));  }  public void testHasSpecificType() throws Exception {    Type specificType = new TypeToken<List<String>>() {}.getType();    String handler = "blah";    paramMap.register(specificType, handler);    assertTrue(paramMap.hasSpecificHandlerFor(specificType));    assertFalse(paramMap.hasSpecificHandlerFor(List.class));    assertNotNull(paramMap.getHandlerFor(specificType));    assertNull(paramMap.getHandlerFor(List.class));    assertEquals(handler, paramMap.getHandlerFor(specificType));  }  public void testTypeOverridding() throws Exception {    String handler1 = "blah1";    String handler2 = "blah2";    paramMap.register(String.class, handler1);    paramMap.register(String.class, handler2);    assertTrue(paramMap.hasSpecificHandlerFor(String.class));    assertEquals(handler2, paramMap.getHandlerFor(String.class));  }  public void testMakeUnmodifiable() throws Exception {    paramMap.makeUnmodifiable();    try {     paramMap.register(String.class, "blah");     fail("Can not register handlers when map is unmodifiable");    } catch (IllegalStateException expected) { }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;import junit.framework.TestCase;import java.lang.reflect.Type;import java.text.DateFormat;import java.util.Date;/** * Simple unit tests for the {@link JsonDeserializerExceptionWrapper} class. * * @author Inderjeet Singh * @author Joel Leitch */public class JsonDeserializerExceptionWrapperTest extends TestCase {  private static final String DATE_STRING =      DateFormat.getDateInstance(DateFormat.LONG).format(new Date());  private static final JsonPrimitive PRIMITIVE_ELEMENT = new JsonPrimitive(DATE_STRING);  public void testRethrowJsonParseException() throws Exception {    String errorMsg = "please rethrow me";    JsonDeserializerExceptionWrapper<String> wrappedJsonSerializer =        new JsonDeserializerExceptionWrapper<String>(            new ExceptionJsonDeserializer(new JsonParseException(errorMsg)));    try {      wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, String.class, null);      fail("JsonParseException should have been thrown");    } catch (JsonParseException expected) {      assertNull(expected.getCause());      assertEquals(errorMsg, expected.getMessage());    }  }  public void testWrappedExceptionPropagation() throws Exception {    IllegalArgumentException exceptionToThrow = new IllegalArgumentException();    JsonDeserializerExceptionWrapper<String> wrappedJsonSerializer =        new JsonDeserializerExceptionWrapper<String>(            new ExceptionJsonDeserializer(exceptionToThrow));    try {      wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, String.class, null);      fail("JsonParseException should have been thrown");    } catch (JsonParseException expected) {      assertEquals(exceptionToThrow, expected.getCause());    }  }  public void testProperSerialization() throws Exception {    DefaultDateTypeAdapter dateSerializer = new DefaultDateTypeAdapter(DateFormat.LONG);    JsonDeserializerExceptionWrapper<Date> wrappedJsonSerializer =        new JsonDeserializerExceptionWrapper<Date>(dateSerializer);    Date expected = dateSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null);    Date actual = wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null);    assertEquals(expected, actual);  }  private static class ExceptionJsonDeserializer implements JsonDeserializer<String> {    private final RuntimeException exceptionToThrow;    public ExceptionJsonDeserializer(RuntimeException exceptionToThrow) {      this.exceptionToThrow = exceptionToThrow;    }    public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)        throws JsonParseException {      throw exceptionToThrow;    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;/** * Performs some unit testing for the {@link Escaper} class. * * @author Joel Leitch */public class EscaperTest extends TestCase {  private Escaper escapeHtmlChar;  private Escaper noEscapeHtmlChar;    @Override  protected void setUp() throws Exception {    super.setUp();    escapeHtmlChar = new Escaper(true);    noEscapeHtmlChar = new Escaper(false);  }  public void testNoSpecialCharacters() {    String value = "Testing123";    String escapedString = escapeHtmlChar.escapeJsonString(value);    assertEquals(value, escapedString);  }  public void testNewlineEscaping() throws Exception {    String containsNewline = "123\n456";    String escapedString = escapeHtmlChar.escapeJsonString(containsNewline);    assertEquals("123\\n456", escapedString);  }  public void testCarrageReturnEscaping() throws Exception {    String containsCarrageReturn = "123\r456";    String escapedString = escapeHtmlChar.escapeJsonString(containsCarrageReturn);    assertEquals("123\\r456", escapedString);  }  public void testTabEscaping() throws Exception {    String containsTab = "123\t456";    String escapedString = escapeHtmlChar.escapeJsonString(containsTab);    assertEquals("123\\t456", escapedString);  }  public void testDoubleQuoteEscaping() throws Exception {    String containsQuote = "123\"456";    String escapedString = escapeHtmlChar.escapeJsonString(containsQuote);    assertEquals("123\\\"456", escapedString);  }    public void testSingleQuoteEscaping() throws Exception {    String containsQuote = "123'456";    String escapedString = escapeHtmlChar.escapeJsonString(containsQuote);    assertEquals("123\\'456", escapedString);  }  public void testLineSeparatorEscaping() throws Exception {    String src = "123\u2028 456";    String escapedString = escapeHtmlChar.escapeJsonString(src);    assertEquals("123\\u2028 456", escapedString);  }  public void testParagraphSeparatorEscaping() throws Exception {    String src = "123\u2029 456";    String escapedString = escapeHtmlChar.escapeJsonString(src);    assertEquals("123\\u2029 456", escapedString);  }  public void testControlCharBlockEscaping() throws Exception {    for (char c = '\u007f'; c <= '\u009f'; ++c) {      String src = "123 " + c + " 456";      String escapedString = escapeHtmlChar.escapeJsonString(src);      assertFalse(src.equals(escapedString));    }  }  public void testEqualsEscaping() throws Exception {    String containsEquals = "123=456";    int index = containsEquals.indexOf('=');    String unicodeValue = convertToUnicodeString(Character.codePointAt(containsEquals, index));    String escapedString = escapeHtmlChar.escapeJsonString(containsEquals);    assertEquals("123" + unicodeValue + "456", escapedString);        escapedString = noEscapeHtmlChar.escapeJsonString(containsEquals);    assertEquals(containsEquals, escapedString);  }  public void testGreaterThanAndLessThanEscaping() throws Exception {    String containsLtGt = "123>456<";    int gtIndex = containsLtGt.indexOf('>');    int ltIndex = containsLtGt.indexOf('<');    String gtAsUnicode = convertToUnicodeString(Character.codePointAt(containsLtGt, gtIndex));    String ltAsUnicode = convertToUnicodeString(Character.codePointAt(containsLtGt, ltIndex));    String escapedString = escapeHtmlChar.escapeJsonString(containsLtGt);    assertEquals("123" + gtAsUnicode + "456" + ltAsUnicode, escapedString);        escapedString = noEscapeHtmlChar.escapeJsonString(containsLtGt);    assertEquals(containsLtGt, escapedString);  }  public void testAmpersandEscaping() throws Exception {    String containsAmp = "123&456";    int ampIndex = containsAmp.indexOf('&');    String ampAsUnicode = convertToUnicodeString(Character.codePointAt(containsAmp, ampIndex));    String escapedString = escapeHtmlChar.escapeJsonString(containsAmp);    assertEquals("123" + ampAsUnicode + "456", escapedString);        escapedString = noEscapeHtmlChar.escapeJsonString(containsAmp);    assertEquals(containsAmp, escapedString);    char ampCharAsUnicode = '\u0026';    String containsAmpUnicode = "123" + ampCharAsUnicode + "456";    escapedString = escapeHtmlChar.escapeJsonString(containsAmpUnicode);    assertEquals("123" + ampAsUnicode + "456", escapedString);    escapedString = noEscapeHtmlChar.escapeJsonString(containsAmpUnicode);    assertEquals(containsAmp, escapedString);  }  public void testSlashEscaping() throws Exception {    String containsSlash = "123\\456";    String escapedString = escapeHtmlChar.escapeJsonString(containsSlash);    assertEquals("123\\\\456", escapedString);  }  public void testSingleQuoteNotEscaped() throws Exception {    String containsSingleQuote = "123'456";    String escapedString = noEscapeHtmlChar.escapeJsonString(containsSingleQuote);    assertEquals(containsSingleQuote, escapedString);  }  public void testRequiredEscapingUnicodeCharacter() throws Exception {    char unicodeChar = '\u2028';    String unicodeString = "Testing" + unicodeChar;    String escapedString = escapeHtmlChar.escapeJsonString(unicodeString);    assertFalse(unicodeString.equals(escapedString));    assertEquals("Testing\\u2028", escapedString);  }  public void testUnicodeCharacterStringNoEscaping() throws Exception {    String unicodeString = "\u0065\u0066";    String escapedString = escapeHtmlChar.escapeJsonString(unicodeString);    assertEquals(unicodeString, escapedString);  }  /*  public void testChineseCharacterEscaping() throws Exception {    String unicodeString = "\u597d\u597d\u597d";    String chineseString = "好好好";    assertEquals(unicodeString, chineseString);    String expectedEscapedString = "\\u597d\\u597d\\u597d";    String escapedString = Escaper.escapeJsonString(chineseString);    assertEquals(expectedEscapedString, escapedString);  }   */  private String convertToUnicodeString(int codepoint) {    String hexValue = Integer.toHexString(codepoint);    StringBuilder sb = new StringBuilder("\\u");    for (int i = 0; i < 4 - hexValue.length(); i++) {      sb.append(0);    }    sb.append(hexValue);    return sb.toString().toLowerCase();  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.List;/** * Unit tests for the {@link ParameterizedTypeImpl} class. * * @author Inderjeet Singh * @author Joel Leitch */public class ParameterizedTypeImplTest extends TestCase {  private Type parameterizedType;  private ParameterizedTypeImpl ourType;  @Override  protected void setUp() throws Exception {    super.setUp();    parameterizedType = new TypeToken<List<String>>() {}.getType();    ourType = new ParameterizedTypeImpl(List.class, new Type[] { String.class }, null);  }  public void testOurTypeFunctionality() throws Exception {    assertNull(ourType.getOwnerType());    assertEquals(String.class, ourType.getActualTypeArguments()[0]);    assertEquals(List.class, ourType.getRawType());    assertEquals(parameterizedType, ourType);    assertEquals(parameterizedType.hashCode(), ourType.hashCode());  }  public void testNotEquals() throws Exception {    Type differentParameterizedType = new TypeToken<List<Integer>>() {}.getType();    assertFalse(differentParameterizedType.equals(ourType));    assertFalse(ourType.equals(differentParameterizedType));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.HashMap;import java.util.Map;/** * Unit test for the default JSON map serialization object located in the * {@link DefaultTypeAdapters} class. * * @author Joel Leitch */public class DefaultMapJsonSerializerTest extends TestCase {  @SuppressWarnings("unchecked")  private JsonSerializer<Map> mapSerializer;  @Override  protected void setUp() throws Exception {    super.setUp();    mapSerializer = new DefaultTypeAdapters.MapTypeAdapter();  }  public void testEmptyMapNoTypeSerialization() {    Map<String, String> emptyMap = new HashMap<String, String>();    JsonElement element = mapSerializer.serialize(emptyMap, emptyMap.getClass(), null);    assertTrue(element instanceof JsonObject);    JsonObject emptyMapJsonObject = (JsonObject) element;    assertTrue(emptyMapJsonObject.entrySet().isEmpty());  }  public void testEmptyMapSerialization() {    Type mapType = new TypeToken<Map<String, String>>() { }.getType();    Map<String, String> emptyMap = new HashMap<String, String>();    JsonElement element = mapSerializer.serialize(emptyMap, mapType, null);    assertTrue(element instanceof JsonObject);    JsonObject emptyMapJsonObject = (JsonObject) element;    assertTrue(emptyMapJsonObject.entrySet().isEmpty());  }}
package com.google.gson;import junit.framework.TestCase;/** * Unit tests for {@link StringUnmarshaller}.  *  * @author Inderjeet Singh */public class StringUnmarshallerTest extends TestCase {  public void testCtrlN() {    assertEquals("a\nb", StringUnmarshaller.unmarshall("'a\\nb'"));  }  public void testCtrlR() {    assertEquals("a\rb", StringUnmarshaller.unmarshall("'a\\rb'"));  }    public void testCtrlT() {    assertEquals("\tb", StringUnmarshaller.unmarshall("'\\tb'"));  }    public void testBackSpace() {    assertEquals("\b foo", StringUnmarshaller.unmarshall("'\\b foo'"));  }    public void testFormFeed() {    assertEquals("\f bar", StringUnmarshaller.unmarshall("'\\f bar'"));  }    public void testSingleQuote() {    assertEquals("a'b", StringUnmarshaller.unmarshall("'a'b'"));  }    public void testSingleQuoteEscaped() {    assertEquals("a'b", StringUnmarshaller.unmarshall("'a\\'b'"));  }    public void testDoubleQuote() {    assertEquals("a\"b", StringUnmarshaller.unmarshall("'a\"b'"));  }    public void testDoubleQuoteEscaped() {    assertEquals("a\"b", StringUnmarshaller.unmarshall("'a\\\"b'"));  }    public void testBackslash() {    assertEquals("a\\b", StringUnmarshaller.unmarshall("'a\\\\b'"));  }      public void testUnicodeString() {    assertEquals("\u03a9b", StringUnmarshaller.unmarshall("'\\u03a9b'"));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;/** * Tests for the {@link LowerCamelCaseSeparatorNamingPolicy} class. * * @author Joel Leitch */public class LowerCamelCaseSeparatorNamingPolicyTest extends TestCase {  private static final Class<String> CLASS = String.class;  private static final String UNDERSCORE = "_";  private LowerCamelCaseSeparatorNamingPolicy namingPolicy;  @Override  protected void setUp() throws Exception {    super.setUp();    namingPolicy = new LowerCamelCaseSeparatorNamingPolicy(UNDERSCORE);  }  public void testNameBeginsWithLowerCase() throws Exception {    String translatedName = namingPolicy.translateName("testNameBeginsWithLower", CLASS, null);    assertEquals("test_name_begins_with_lower", translatedName);  }  public void testNameBeginsWithUpperCase() throws Exception {    String translatedName = namingPolicy.translateName("TestNameBeginsWithUpper", CLASS, null);    assertEquals("test_name_begins_with_upper", translatedName);  }  public void testExceptionPossiblyIncorrectSeparation() throws Exception {    String translatedName = namingPolicy.translateName("aURL", CLASS, null);    assertEquals("a_u_r_l", translatedName);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;/** * Tests for the {@link CamelCaseSeparatorNamingPolicy} class. * * @author Joel Leitch */public class CamelCaseSeparatorNamingPolicyTest extends TestCase {  private static final Class<String> CLASS = String.class;  private static final String UNDERSCORE = "_";  private static final String MULTI_CHAR_SEPARATOR = "_$_";  public void testInvalidInstantiation() throws Exception {    try {      new CamelCaseSeparatorNamingPolicy(null);      fail("Null separator string is not supported");    } catch (IllegalArgumentException expected) { }    try {      new CamelCaseSeparatorNamingPolicy("");      fail("Empty separator string is not supported");    } catch (IllegalArgumentException expected) { }    try {      new CamelCaseSeparatorNamingPolicy(" ");      fail("space separator string is not supported");    } catch (IllegalArgumentException expected) { }    try {      new CamelCaseSeparatorNamingPolicy("\n");      fail("new-line separator string is not supported");    } catch (IllegalArgumentException expected) { }  }  public void testUnderscoreSeparator() throws Exception {    CamelCaseSeparatorNamingPolicy namingPolicy =        new CamelCaseSeparatorNamingPolicy(UNDERSCORE);    String translatedName = namingPolicy.translateName("testUnderscoreBetweenWords", CLASS, null);    assertEquals("test_Underscore_Between_Words", translatedName);  }  public void testMultiCharSeparator() throws Exception {    CamelCaseSeparatorNamingPolicy namingPolicy =        new CamelCaseSeparatorNamingPolicy(MULTI_CHAR_SEPARATOR);    String translatedName = namingPolicy.translateName("testMultCharBetweenWords", CLASS, null);    assertEquals("test_$_Mult_$_Char_$_Between_$_Words", translatedName);  }  public void testNameBeginsWithCapital() throws Exception {    CamelCaseSeparatorNamingPolicy namingPolicy = new CamelCaseSeparatorNamingPolicy(UNDERSCORE);    String translatedName = namingPolicy.translateName("TestNameBeginsWithCapital", CLASS, null);    assertEquals("Test_Name_Begins_With_Capital", translatedName);  }  public void testExceptionPossiblyIncorrectSeparation() throws Exception {    CamelCaseSeparatorNamingPolicy namingPolicy = new CamelCaseSeparatorNamingPolicy(UNDERSCORE);    String translatedName = namingPolicy.translateName("aURL", CLASS, null);    assertEquals("a_U_R_L", translatedName);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.ExposeAnnotationBasedExclusionStrategy.Phase;import com.google.gson.annotations.Expose;import junit.framework.TestCase;import java.lang.reflect.Field;/** * Unit tests for the {@link ExposeAnnotationBasedExclusionStrategy} class. * * @author Joel Leitch */public class ExposeAnnotationBasedExclusionStrategyTest extends TestCase {  private ExposeAnnotationBasedExclusionStrategy strategy;  @Override  protected void setUp() throws Exception {    super.setUp();    strategy = new ExposeAnnotationBasedExclusionStrategy(Phase.SERIALIZATION);  }  public void testNeverSkipClasses() throws Exception {    assertFalse(strategy.shouldSkipClass(MockObject.class));  }    public void testSkipNonAnnotatedFields() throws Exception {    Field f = MockObject.class.getField("hiddenField");    assertTrue(strategy.shouldSkipField(f));  }    public void testNeverSkipExposedAnnotatedFields() throws Exception {    Field f = MockObject.class.getField("exposedField");    assertFalse(strategy.shouldSkipField(f));  }  @SuppressWarnings("unused")  private static class MockObject {    @Expose    public final int exposedField = 0;    public final int hiddenField = 0;  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.List;/** * Small test for the {@link TypeInfoArray}. * * @author Inderjeet Singh * @author Joel Leitch */public class TypeInfoArrayTest extends TestCase {  public void testArray() {    String[] a = {"a", "b", "c"};    TypeInfoArray typeInfo = new TypeInfoArray(a.getClass());    assertEquals(a.getClass(), typeInfo.getRawClass());    assertEquals(String.class, typeInfo.getComponentRawType());  }  public void testArrayOfArrays() {    String[][] a = {        new String[]{"a1", "a2", "a3"},        new String[]{"b1", "b2", "b3"},        new String[]{"c1", "c2", "c3"}};    TypeInfoArray typeInfo = new TypeInfoArray(a.getClass());    assertEquals(a.getClass(), typeInfo.getRawClass());    assertEquals(String.class, typeInfo.getComponentRawType());    assertEquals(String[].class, typeInfo.getSecondLevelType());  }  public void testParameterizedArray() {    Type type = new TypeToken<List<String>[]>() {}.getType();    TypeInfoArray typeInfo = new TypeInfoArray(type);    assertEquals(List[].class, typeInfo.getRawClass());    assertEquals(List.class, typeInfo.getComponentRawType());  }  public void testParameterizedArrayOfArrays() {    Type type = new TypeToken<List<String>[][]>() {}.getType();    Type secondLevelType = new TypeToken<List<String>[]>() {}.getType();    TypeInfoArray typeInfo = new TypeInfoArray(type);    assertEquals(List[][].class, typeInfo.getRawClass());    assertEquals(secondLevelType, typeInfo.getSecondLevelType());    assertEquals(List.class, typeInfo.getComponentRawType());  }  public void testNestedParameterizedArray() {    Type type = new TypeToken<List<List<String>>[]>() {}.getType();    Type secondLevelType = new TypeToken<List<List<String>>>() {}.getType();    TypeInfoArray typeInfo = new TypeInfoArray(type);    assertEquals(List[].class, typeInfo.getRawClass());    assertEquals(secondLevelType, typeInfo.getSecondLevelType());    assertEquals(List.class, typeInfo.getComponentRawType());  }  public void testPrimitiveArray() throws Exception {    TypeInfoArray arrayTypeInfo = new TypeInfoArray(int[].class);    assertTrue(arrayTypeInfo.isArray());    assertFalse(arrayTypeInfo.isPrimitive());    assertEquals(int.class, arrayTypeInfo.getSecondLevelType());  }  public void testStringArray() throws Exception {    TypeInfoArray arrayTypeInfo = new TypeInfoArray(String[].class);    assertTrue(arrayTypeInfo.isArray());    assertEquals(String.class, arrayTypeInfo.getSecondLevelType());    assertEquals(String[].class, arrayTypeInfo.getRawClass());  }  public void testPrimitiveArrayType() throws Exception {    TypeInfoArray typeInfo = new TypeInfoArray(long[].class);    assertTrue(typeInfo.isArray());    assertEquals(long.class, typeInfo.getSecondLevelType());    assertEquals(long[].class, typeInfo.getRawClass());  }  public void testStringArrayType() throws Exception {    TypeInfoArray typeInfo = new TypeInfoArray(String[].class);    assertTrue(typeInfo.isArray());    assertEquals(String[].class, typeInfo.getRawClass());    assertEquals(String.class, typeInfo.getSecondLevelType());  }  public void testArrayAsParameterizedTypes() throws Exception {    Type type = new TypeToken<List<String>[]>() {}.getType();    Type secondLevelType = new TypeToken<List<String>>() {}.getType();    TypeInfoArray typeInfo = new TypeInfoArray(type);    assertTrue(typeInfo.isArray());    assertEquals(List[].class, typeInfo.getRawClass());    assertEquals(secondLevelType, typeInfo.getSecondLevelType());    Type actualType = typeInfo.getActualType();    assertEquals(type, actualType);    Type actualTypeForFirstTypeVariable = TypeUtils.getActualTypeForFirstTypeVariable(actualType);    assertEquals(String.class, actualTypeForFirstTypeVariable);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import java.lang.reflect.Field;import junit.framework.TestCase;/** * Unit test for the {@link InnerClassExclusionStrategy} class. * * @author Joel Leitch */public class InnerClassExclusionStrategyTest extends TestCase {  public InnerClass innerClass;  public StaticNestedClass staticNestedClass;  private InnerClassExclusionStrategy strategy;    @Override  protected void setUp() throws Exception {    super.setUp();    innerClass = new InnerClass();    staticNestedClass = new StaticNestedClass();    strategy = new InnerClassExclusionStrategy();  }  public void testExcludeInnerClassObject() throws Exception {    Class<?> clazz = innerClass.getClass();    assertTrue(strategy.shouldSkipClass(clazz));  }    public void testExcludeInnerClassField() throws Exception {    Field f = getClass().getField("innerClass");    assertTrue(strategy.shouldSkipField(f));  }    public void testIncludeStaticNestedClassObject() throws Exception {    Class<?> clazz = staticNestedClass.getClass();    assertFalse(strategy.shouldSkipClass(clazz));  }    public void testIncludeStaticNestedClassField() throws Exception {    Field f = getClass().getField("staticNestedClass");    assertFalse(strategy.shouldSkipField(f));  }    class InnerClass {  }    static class StaticNestedClass {  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.annotations.SerializedName;import junit.framework.TestCase;import java.lang.reflect.Field;/** * Unit tests for the {@link SerializedNameAnnotationInterceptingNamingPolicy} class. * * @author Joel Leitch */public class SerializedNameAnnotationInterceptingNamingPolicyTest extends TestCase {  private static final String ANNOTATED_FIELD_NAME = "annotatedFieldName";  private SerializedNameAnnotationInterceptingNamingPolicy policy;  @Override  protected void setUp() throws Exception {    super.setUp();    policy = new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy());  }  public void testFieldWithAnnotation() throws Exception {    String fieldName = "fieldWithAnnotation";    Field f = SomeObject.class.getField(fieldName);    assertFalse(ANNOTATED_FIELD_NAME.equals(fieldName));    assertEquals(ANNOTATED_FIELD_NAME, policy.translateName(f));  }  public void testFieldWithoutAnnotation() throws Exception {    String fieldName = "fieldWithoutAnnotation";    Field f = SomeObject.class.getField(fieldName);    assertEquals(fieldName, policy.translateName(f));  }  @SuppressWarnings("unused")  private static class SomeObject {    @SerializedName(ANNOTATED_FIELD_NAME) public final int fieldWithAnnotation = 1;    public final int fieldWithoutAnnotation = 1;  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.List;/** * Exercising the construction of the Parameter object and ensure the * proper types are returned. * * @author Joel Leitch */public class TypeInfoTest extends TestCase {  public void testPrimitive() throws Exception {    TypeInfo typeInfo = new TypeInfo(boolean.class);    assertFalse(typeInfo.isArray());    assertTrue(typeInfo.isPrimitive());    assertEquals(boolean.class, typeInfo.getRawClass());    assertEquals(Boolean.class, typeInfo.getWrappedClass());  }  public void testPrimitiveWrapper() throws Exception {    TypeInfo typeInfo = new TypeInfo(Integer.class);    assertEquals(Integer.class, typeInfo.getRawClass());    assertTrue(typeInfo.isPrimitive());    assertFalse(typeInfo.isArray());  }  public void testString() throws Exception {    TypeInfo typeInfo = new TypeInfo(String.class);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isPrimitive());    assertEquals(String.class, typeInfo.getRawClass());  }  public void testObject() throws Exception {    TypeInfo typeInfo = new TypeInfo(Object.class);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isPrimitive());    assertEquals(Object.class, typeInfo.getRawClass());  }  public void testPrimitiveType() throws Exception {    TypeInfo typeInfo = new TypeInfo(long.class);    assertFalse(typeInfo.isArray());    assertEquals(long.class, typeInfo.getRawClass());  }  public void testObjectType() throws Exception {    TypeInfo typeInfo = new TypeInfo(String.class);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isPrimitive());    assertEquals(String.class, typeInfo.getRawClass());  }  public void testParameterizedTypes() throws Exception {    Type type = new TypeToken<List<String>>() {}.getType();    TypeInfo typeInfo = new TypeInfo(type);    assertFalse(typeInfo.isArray());    assertEquals(List.class, typeInfo.getRawClass());    assertEquals(type, typeInfo.getActualType());  }  public void testGenericizedGenericType() throws Exception {    Type type = new TypeToken<List<List<String>>>() {}.getType();    Type genericType = new TypeToken<List<String>>() {}.getType();    TypeInfo typeInfo = new TypeInfo(type);    assertFalse(typeInfo.isArray());    assertEquals(List.class, typeInfo.getRawClass());    Type actualTypeForFirstTypeVariable = TypeUtils.getActualTypeForFirstTypeVariable(type);    assertEquals(genericType, actualTypeForFirstTypeVariable);    typeInfo = new TypeInfo(genericType);    actualTypeForFirstTypeVariable = TypeUtils.getActualTypeForFirstTypeVariable(genericType);    assertEquals(String.class, actualTypeForFirstTypeVariable);  }  public void testStrangeTypeParameters() throws Exception {    try {      new TypeInfo(new Type() {});      fail("Should not be able to determine this unknown type");    } catch (IllegalArgumentException expected) {    }  }}
/* * Copyright (C) 2009 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;/** * Unit test for the {@link LongSerializationPolicy} class. * * @author Inderjeet Singh * @author Joel Leitch */public class LongSerializationPolicyTest extends TestCase {  public void testDefaultLongSerialization() throws Exception {    JsonElement element = LongSerializationPolicy.DEFAULT.serialize(1556L);    assertTrue(element.isJsonPrimitive());        JsonPrimitive jsonPrimitive = element.getAsJsonPrimitive();    assertFalse(jsonPrimitive.isString());    assertTrue(jsonPrimitive.isNumber());    assertEquals(1556L, element.getAsLong());  }    public void testStringLongSerialization() throws Exception {    JsonElement element = LongSerializationPolicy.STRING.serialize(1556L);    assertTrue(element.isJsonPrimitive());        JsonPrimitive jsonPrimitive = element.getAsJsonPrimitive();    assertFalse(jsonPrimitive.isNumber());    assertTrue(jsonPrimitive.isString());    assertEquals("1556", element.getAsString());  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.MemoryRefStack;import junit.framework.TestCase;import java.util.EmptyStackException;/** * Unit tests for the {@link MemoryRefStack} class. * * @author Joel Leitch */public class MemoryRefStackTest extends TestCase {  private MemoryRefStack<MockObject> stack;  @Override  protected void setUp() throws Exception {    super.setUp();    stack = new MemoryRefStack<MockObject>();  }  public void testPeekEmptyStack() throws Exception {    try {      stack.peek();    } catch (EmptyStackException expected) { }  }  public void testPushPeekAndPop() throws Exception {    MockObject obj = new MockObject();    assertEquals(obj, stack.push(obj));    assertEquals(obj, stack.peek());    assertEquals(obj, stack.pop());  }  public void testPopTooMany() throws Exception {    MockObject obj = new MockObject();    stack.push(obj);    assertEquals(obj, stack.pop());    try {      stack.pop();    } catch (EmptyStackException expected) { }  }  public void testContains() throws Exception {    MockObject objA = new MockObject();    MockObject objB = new MockObject();    assertEquals(objA, objB);    stack.push(objA);    assertFalse(stack.contains(objB));    assertTrue(stack.contains(objA));  }  private static class MockObject {    private final int value = 1;    @Override    public boolean equals(Object obj) {      return obj instanceof MockObject && value == ((MockObject) obj).value;    }    @Override    public int hashCode() {      return value;    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;import java.lang.reflect.Type;import java.math.BigInteger;import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.atomic.AtomicLong;/** * Contains numerous tests involving registered type converters with a Gson instance. * * @author Inderjeet Singh * @author Joel Leitch */public class GsonTypeAdapterTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new GsonBuilder()        .registerTypeAdapter(AtomicLong.class, new ExceptionTypeAdapter())        .registerTypeAdapter(AtomicInteger.class, new AtomicIntegerTypeAdapter())        .create();  }  public void testDefaultTypeAdapterThrowsParseException() throws Exception {    try {      gson.fromJson("{\"abc\":123}", BigInteger.class);      fail("Should have thrown a JsonParseException");    } catch (JsonParseException expected) { }  }  public void testTypeAdapterThrowsException() throws Exception {    try {      gson.toJson(new AtomicLong(0));      fail("Type Adapter should have thrown an exception");    } catch (IllegalStateException expected) { }    try {      gson.fromJson("123", AtomicLong.class);      fail("Type Adapter should have thrown an exception");    } catch (JsonParseException expected) { }  }  public void testTypeAdapterProperlyConvertsTypes() throws Exception {    int intialValue = 1;    AtomicInteger atomicInt = new AtomicInteger(intialValue);    String json = gson.toJson(atomicInt);    assertEquals(intialValue + 1, Integer.parseInt(json));    atomicInt = gson.fromJson(json, AtomicInteger.class);    assertEquals(intialValue, atomicInt.get());  }  public void testTypeAdapterDoesNotAffectNonAdaptedTypes() throws Exception {    String expected = "blah";    String actual = gson.toJson(expected);    assertEquals("\"" + expected + "\"", actual);    actual = gson.fromJson(actual, String.class);    assertEquals(expected, actual);  }  private static class ExceptionTypeAdapter      implements JsonSerializer<AtomicLong>, JsonDeserializer<AtomicLong> {    public JsonElement serialize(        AtomicLong src, Type typeOfSrc, JsonSerializationContext context) {      throw new IllegalStateException();    }    public AtomicLong deserialize(        JsonElement json, Type typeOfT, JsonDeserializationContext context)        throws JsonParseException {      throw new IllegalStateException();    }  }  private static class AtomicIntegerTypeAdapter      implements JsonSerializer<AtomicInteger>, JsonDeserializer<AtomicInteger> {    public JsonElement serialize(AtomicInteger src, Type typeOfSrc, JsonSerializationContext context) {      return new JsonPrimitive(src.incrementAndGet());    }    public AtomicInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)        throws JsonParseException {      int intValue = json.getAsInt();      return new AtomicInteger(--intValue);    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.Collection;import java.util.Map;/** * Unit tests for {@link TypeUtils}. * * @author Inderjeet Singh */public class TypeUtilsTest extends TestCase {  private static final Type MAP_TYPE = new TypeToken<Map<String, Integer>>() {}.getType();  public void testGetActualTypeForFirstTypeVariable() {    assertEquals(String.class, TypeUtils.getActualTypeForFirstTypeVariable(MAP_TYPE));  }  public void testIsArrayForNonArrayClasses() {    assertFalse(TypeUtils.isArray(Boolean.class));    assertFalse(TypeUtils.isArray(MAP_TYPE));  }  public void testIsArrayForArrayClasses() {    assertTrue(TypeUtils.isArray(String[].class));    assertTrue(TypeUtils.isArray(Integer[][].class));    assertTrue(TypeUtils.isArray(Collection[].class));  }  public void testToRawClassForNonGenericClasses() {    assertEquals(String.class, TypeUtils.toRawClass(String.class));  }  public void testToRawClassForGenericClasses() {    assertEquals(Map.class, TypeUtils.toRawClass(MAP_TYPE));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.annotations.Since;import junit.framework.TestCase;import java.lang.reflect.Field;/** * Unit tests for the {@link VersionExclusionStrategy} class. * * @author Joel Leitch */public class VersionExclusionStrategyTest extends TestCase {  private static final double VERSION = 5.0D;  public void testDisallowNegativeValuesAndFailFast() throws Exception {    try {      new VersionExclusionStrategy(-1.0D);      fail("should have thrown an exception.");    } catch (IllegalArgumentException expected) { }  }  public void testClassAndFieldAreAtSameVersion() throws Exception {    Class<MockObject> clazz = MockObject.class;    Field f = clazz.getField("someField");    VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION);        assertFalse(strategy.shouldSkipClass(clazz));    assertFalse(strategy.shouldSkipField(f));  }  public void testClassAndFieldAreBehindInVersion() throws Exception {    Class<MockObject> clazz = MockObject.class;    Field f = clazz.getField("someField");    VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION + 1);        assertFalse(strategy.shouldSkipClass(clazz));    assertFalse(strategy.shouldSkipField(f));  }  public void testClassAndFieldAreAheadInVersion() throws Exception {    Class<MockObject> clazz = MockObject.class;    Field f = clazz.getField("someField");    VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION - 1);        assertTrue(strategy.shouldSkipClass(clazz));    assertTrue(strategy.shouldSkipField(f));  }  @Since(VERSION)  private static class MockObject {    @SuppressWarnings("unused")    @Since(VERSION)    public final int someField = 0;  }}
/* * Copyright (C) 2009 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.common.TestTypes.BagOfPrimitives;import junit.framework.TestCase;import java.io.CharArrayReader;import java.io.CharArrayWriter;import java.io.StringReader;/** * Unit test for {@link JsonParser} *  * @author Inderjeet Singh */public class JsonParserTest extends TestCase {    private JsonParser parser;    @Override  protected void setUp() throws Exception {    super.setUp();    parser = new JsonParser();  }    public void testParseString() {    String json = "{a:10,b:'c'}";    JsonElement e = parser.parse(json);    assertTrue(e.isJsonObject());    assertEquals(10, e.getAsJsonObject().get("a").getAsInt());    assertEquals("c", e.getAsJsonObject().get("b").getAsString());  }  public void testParseReader() {    StringReader reader = new StringReader("{a:10,b:'c'}");    JsonElement e = parser.parse(reader);    assertTrue(e.isJsonObject());    assertEquals(10, e.getAsJsonObject().get("a").getAsInt());    assertEquals("c", e.getAsJsonObject().get("b").getAsString());  }    public void testReadWriteTwoObjects() throws Exception {    Gson gson= new Gson();    CharArrayWriter writer= new CharArrayWriter();    BagOfPrimitives expectedOne = new BagOfPrimitives(1, 1, true, "one");    writer.write(gson.toJson(expectedOne).toCharArray());    BagOfPrimitives expectedTwo = new BagOfPrimitives(2, 2, false, "two");    writer.write(gson.toJson(expectedTwo).toCharArray());    CharArrayReader reader = new CharArrayReader(writer.toCharArray());      JsonParserJavacc parser = new JsonParserJavacc(reader);        JsonElement element1 = parser.parse();    JsonElement element2 = parser.parse();    BagOfPrimitives actualOne = gson.fromJson(element1, BagOfPrimitives.class);    assertEquals("one", actualOne.stringValue);    BagOfPrimitives actualTwo = gson.fromJson(element2, BagOfPrimitives.class);    assertEquals("two", actualTwo.stringValue);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;/** * Unit test for the {@link JsonObject} class. * * @author Joel Leitch */public class JsonObjectTest extends TestCase {  public void testAddingAndRemovingObjectProperties() throws Exception {    JsonObject jsonObj = new JsonObject();    String propertyName = "property";    assertFalse(jsonObj.has(propertyName));    assertNull(jsonObj.get(propertyName));        JsonPrimitive value = new JsonPrimitive("blah");    jsonObj.add(propertyName, value);    assertEquals(value, jsonObj.get(propertyName));        JsonElement removedElement = jsonObj.remove(propertyName);    assertEquals(value, removedElement);    assertFalse(jsonObj.has(propertyName));  }    public void testAddingNullProperties() throws Exception {    String propertyName = "property";    JsonObject jsonObj = new JsonObject();    jsonObj.add(propertyName, null);        assertTrue(jsonObj.has(propertyName));        JsonElement jsonElement = jsonObj.get(propertyName);    assertNotNull(jsonElement);    assertTrue(jsonElement.isJsonNull());  }    public void testAddingBooleanProperties() throws Exception {    String propertyName = "property";    JsonObject jsonObj = new JsonObject();    jsonObj.addProperty(propertyName, true);        assertTrue(jsonObj.has(propertyName));        JsonElement jsonElement = jsonObj.get(propertyName);    assertNotNull(jsonElement);    assertTrue(jsonElement.getAsBoolean());  }    public void testAddingStringProperties() throws Exception {    String propertyName = "property";    String value = "blah";    JsonObject jsonObj = new JsonObject();    jsonObj.addProperty(propertyName, value);        assertTrue(jsonObj.has(propertyName));        JsonElement jsonElement = jsonObj.get(propertyName);    assertNotNull(jsonElement);    assertEquals(value, jsonElement.getAsString());  }    public void testAddingCharacterProperties() throws Exception {    String propertyName = "property";    char value = 'a';    JsonObject jsonObj = new JsonObject();    jsonObj.addProperty(propertyName, value);        assertTrue(jsonObj.has(propertyName));        JsonElement jsonElement = jsonObj.get(propertyName);    assertNotNull(jsonElement);    assertEquals(String.valueOf(value), jsonElement.getAsString());    assertEquals(value, jsonElement.getAsCharacter());  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.List;/** * Unit tests for the {@link GenericArrayTypeImpl} class. * * @author Inderjeet Singh * @author Joel Leitch */public class GenericArrayTypeImplTest extends TestCase {  private Type parameterizedType;  private Type genericArrayType;  private GenericArrayTypeImpl ourType;  @Override  protected void setUp() throws Exception {    super.setUp();    parameterizedType = new TypeToken<List<String>>() {}.getType();    genericArrayType = new TypeToken<List<String>[]>() {}.getType();    ourType = new GenericArrayTypeImpl(parameterizedType);  }  public void testOurTypeFunctionality() throws Exception {    assertEquals(parameterizedType, ourType.getGenericComponentType());    assertEquals(genericArrayType, ourType);    assertEquals(genericArrayType.hashCode(), ourType.hashCode());  }  public void testNotEquals() throws Exception {    Type differentGenericArrayType = new TypeToken<List<String>[][]>() {}.getType();    assertFalse(differentGenericArrayType.equals(ourType));    assertFalse(ourType.equals(differentGenericArrayType));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;/** * Unit tests for the {@link JsonFieldNameValidator} class. * * @author Joel Leitch */public class JsonFieldNameValidatorTest extends TestCase {  private JsonFieldNameValidator validator;  @Override  protected void setUp() throws Exception {    super.setUp();    validator = new JsonFieldNameValidator();  }  public void testValidFieldBeginsWithDollarSign() throws Exception {    String fieldName = "$abc";    assertEquals(fieldName, validator.validate(fieldName));  }  public void testValidFieldBeginsWithUnderscore() throws Exception {    String fieldName = "_abc";    assertEquals(fieldName, validator.validate(fieldName));  }  public void testValidFieldBeginsWithLetter() throws Exception {    String fieldName = "abc";    assertEquals(fieldName, validator.validate(fieldName));  }  public void testValidFieldMixingLetter() throws Exception {    String fieldName = "$abc_12v$34";    assertEquals(fieldName, validator.validate(fieldName));  }  public void testInvalidFieldStartingWithNumbers() throws Exception {    try {      validator.validate("1abc");      fail("Json field name can not start with a number");    } catch (IllegalArgumentException expected) { }  }  public void testInvalidFieldStartingTwoDollarSigns() throws Exception {    try {      validator.validate("$$abc");      fail("Json field name can not start with a double dollar sign");    } catch (IllegalArgumentException expected) { }  }  public void testInvalidFieldStartingTwoUnderscores() throws Exception {    try {      validator.validate("__abc");      fail("Json field name can not start with a double underscore");    } catch (IllegalArgumentException expected) { }  }  public void testInvalidFieldStartingDollarUnderscore() throws Exception {    try {      validator.validate("$_abc");      fail("Json field name can not start with two non-alphabet characters");    } catch (IllegalArgumentException expected) { }  }  public void testJavaAndJsKeywordAsFieldName() throws Exception {    String fieldName = "break";    assertEquals(fieldName, validator.validate(fieldName));  }  public void testInvalidCharacters() throws Exception {    try {      validator.validate("abc.123");      fail("Json field name can not contain a period character");    } catch (IllegalArgumentException expected) { }  }}
package com.google.gson;import java.util.Iterator;import junit.framework.TestCase;/** * Unit tests for {@link JsonParserAsync} * * @author Inderjeet Singh */public class JsonParserAsyncTest extends TestCase {    public void testParseTwoStrings() {    JsonParserAsync parser = new JsonParserAsync("'one' 'two'");    String actualOne = parser.next().getAsString();    assertEquals("one", actualOne);    String actualTwo = parser.next().getAsString();    assertEquals("two", actualTwo);  }    public void testIterator() {    Iterator<JsonElement> parser = new JsonParserAsync("'one' 'two'");    assertTrue(parser.hasNext());    assertEquals("one", parser.next().getAsString());    assertTrue(parser.hasNext());    assertEquals("two", parser.next().getAsString());    assertFalse(parser.hasNext());  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.common.TestTypes.ClassWithNoFields;import junit.framework.TestCase;import java.lang.reflect.Modifier;/** * Functional tests for Gson that depend on some internal package-protected elements of * com.google.gson package and hence must be placed in the same package. We should make every * attempt to migrate tests out of this class. * * @author Inderjeet Singh * @author Joel Leitch */public class FunctionWithInternalDependenciesTest extends TestCase {  public void testAnonymousLocalClassesSerialization() {    Gson gson = new Gson(new ModifierBasedExclusionStrategy(        true, Modifier.TRANSIENT, Modifier.STATIC), Gson.DEFAULT_NAMING_POLICY);    assertEquals("{}", gson.toJson(new ClassWithNoFields() {      // empty anonymous class    }));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;/** * Unit test for the {@link com.google.gson.ModifyFirstLetterNamingPolicy} class. * * @author Joel Leitch */public class ModifyFirstLetterNamingPolicyTest extends TestCase {  public void testInvalidConstruction() throws Exception {    try {      new ModifyFirstLetterNamingPolicy(null);      fail("Null values are not allowed as a constructor parameters");    } catch (IllegalArgumentException expected) { }  }  public void testLowerCaseFirstLetter() throws Exception {    ModifyFirstLetterNamingPolicy policy =        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.LOWER);    assertEquals("blah", policy.translateName("Blah", String.class, null));    assertEquals("blah", policy.translateName("blah", String.class, null));  }  public void testUpperCaseFirstLetter() throws Exception {    ModifyFirstLetterNamingPolicy policy =        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);    assertEquals("Blah", policy.translateName("blah", String.class, null));    assertEquals("Blah", policy.translateName("Blah", String.class, null));  }  public void testSingleCharacterField() throws Exception {    ModifyFirstLetterNamingPolicy policy =        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);    assertEquals("B", policy.translateName("b", String.class, null));    assertEquals("B", policy.translateName("B", String.class, null));  }  public void testFieldStartsWithUnderscore() throws Exception {    ModifyFirstLetterNamingPolicy policy =        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);    assertEquals("_Blah", policy.translateName("_blah", String.class, null));    assertEquals("_Blah", policy.translateName("_Blah", String.class, null));  }  public void testFieldStartsWithUnderscoreFollowedBySingleLetter() throws Exception {    ModifyFirstLetterNamingPolicy policy =        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);    assertEquals("_B", policy.translateName("_b", String.class, null));    assertEquals("_B", policy.translateName("_B", String.class, null));  }  public void testFieldHasSingleNonLetter() throws Exception {    ModifyFirstLetterNamingPolicy policy =        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.LOWER);    assertEquals("_", policy.translateName("_", String.class, null));    policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);    assertEquals("_", policy.translateName("_", String.class, null));  }  public void testFieldHasNoLetters() throws Exception {    ModifyFirstLetterNamingPolicy policy =        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.LOWER);    assertEquals("$_$", policy.translateName("$_$", String.class, null));    policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);    assertEquals("$_$", policy.translateName("$_$", String.class, null));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.LowerCaseNamingPolicy;import junit.framework.TestCase;/** * Tests for the {@link LowerCaseNamingPolicy} class. * * @author Joel Leitch */public class LowerCaseNamingPolicyTest extends TestCase {  private static final String ALL_LOWER = "abcdefg";  private static final String ALL_UPPER = "ABCDEFG";  private static final String MIXED = "aBcdeFg";  private LowerCaseNamingPolicy namingPolicy;  @Override  protected void setUp() throws Exception {    super.setUp();    namingPolicy = new LowerCaseNamingPolicy();  }  public void testAllLowerCase() throws Exception {    assertEquals(ALL_LOWER, namingPolicy.translateName(ALL_LOWER, String.class, null));  }  public void testAllUpperCase() throws Exception {    assertEquals(ALL_LOWER, namingPolicy.translateName(ALL_UPPER, String.class, null));  }  public void testMixedCase() throws Exception {    assertEquals(ALL_LOWER, namingPolicy.translateName(MIXED, String.class, null));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;/** * Unit tests for {@link GsonBuilder}. * * @author Inderjeet Singh */public class GsonBuilderTest extends TestCase {  public void testCreatingMoreThanOnce() {    GsonBuilder builder = new GsonBuilder();    builder.create();    builder.create();  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.LowerCaseNamingPolicy;import com.google.gson.UpperCaseNamingPolicy;import junit.framework.TestCase;/** * Tests for the {@link LowerCaseNamingPolicy} class. * * @author Joel Leitch */public class UpperCaseNamingPolicyTest extends TestCase {  private static final String ALL_LOWER = "abcdefg";  private static final String ALL_UPPER = "ABCDEFG";  private static final String MIXED = "aBcdeFg";  private UpperCaseNamingPolicy namingPolicy;  @Override  protected void setUp() throws Exception {    super.setUp();    namingPolicy = new UpperCaseNamingPolicy();  }  public void testAllLowerCase() throws Exception {    assertEquals(ALL_UPPER, namingPolicy.translateName(ALL_LOWER, String.class, null));  }  public void testAllUpperCase() throws Exception {    assertEquals(ALL_UPPER, namingPolicy.translateName(ALL_UPPER, String.class, null));  }  public void testMixedCase() throws Exception {    assertEquals(ALL_UPPER, namingPolicy.translateName(MIXED, String.class, null));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Unit test for the default JSON map serialization object located in the * {@link DefaultTypeAdapters} class. * * @author Joel Leitch */public class TypeInfoMapTest extends TestCase {  public void testInvalidConstruction() throws Exception {    try {      new TypeInfoMap(String.class);      fail("Must be a ParameterizedType");    } catch (IllegalArgumentException expected) { }  }  public void testNonMapConstruction() throws Exception {    try {      Type parameterizedMapType = new TypeToken<List<String>>() {}.getType();      new TypeInfoMap(parameterizedMapType);      fail("The raw type must be a Map");    } catch (IllegalArgumentException expected) { }  }  public void testBasicGetters() throws Exception {    Type parameterizedMapType = new TypeToken<Map<String, Integer>>() {}.getType();    TypeInfoMap mapTypeInfo = new TypeInfoMap(parameterizedMapType);    assertEquals(String.class, mapTypeInfo.getKeyType());    assertEquals(Integer.class, mapTypeInfo.getValueType());  }  public void testMapImplementations() throws Exception {    Type parameterizedMapType = new TypeToken<HashMap<String, Integer>>() {}.getType();    TypeInfoMap mapTypeInfo = new TypeInfoMap(parameterizedMapType);    assertEquals(String.class, mapTypeInfo.getKeyType());    assertEquals(Integer.class, mapTypeInfo.getValueType());  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Field;import java.lang.reflect.Type;import java.util.List;/** * Small test to ensure that the TypeInfoFactory is return the object that we expect. * * @author Inderjeet Singh * @author Joel Leitch */public class TypeInfoFactoryTest extends TestCase {  private static Type OBJ_TYPE = new TypeToken<ObjectWithDifferentFields<Integer>>() {}.getType();  private ObjectWithDifferentFields<Integer> obj;  @Override  protected void setUp() throws Exception {    super.setUp();    obj = new ObjectWithDifferentFields<Integer>();  }  public void testSimpleField() throws Exception {    Field f = obj.getClass().getField("simpleField");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(String.class, typeInfo.getActualType());    assertEquals(String.class, typeInfo.getRawClass());  }  public void testEnumField() throws Exception {    Field f = obj.getClass().getField("enumField");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertTrue(typeInfo.isEnum());    assertEquals(ObjectWithDifferentFields.TestEnum.class, typeInfo.getActualType());    assertEquals(ObjectWithDifferentFields.TestEnum.class, typeInfo.getRawClass());  }  public void testParameterizedTypeField() throws Exception {    Type listType = new TypeToken<List<String>>() {}.getType();    Field f = obj.getClass().getField("simpleParameterizedType");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List.class, typeInfo.getRawClass());  }  public void testNestedParameterizedTypeField() throws Exception {    Type listType = new TypeToken<List<List<String>>>() {}.getType();    Field f = obj.getClass().getField("simpleNestedParameterizedType");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List.class, typeInfo.getRawClass());  }  public void testGenericArrayTypeField() throws Exception {    Type listType = new TypeToken<List<String>[]>() {}.getType();    Field f = obj.getClass().getField("simpleGenericArray");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertTrue(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List[].class, typeInfo.getRawClass());  }  public void testTypeVariableField() throws Exception {    Field f = obj.getClass().getField("typeVariableObj");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(Integer.class, typeInfo.getActualType());    assertEquals(Integer.class, typeInfo.getRawClass());  }  public void testTypeVariableArrayField() throws Exception {    Field f = obj.getClass().getField("typeVariableArray");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertTrue(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(Integer[].class, typeInfo.getActualType());    assertEquals(Integer[].class, typeInfo.getRawClass());  }  public void testMutliDimensionalTypeVariableArrayField() throws Exception {    Field f = obj.getClass().getField("mutliDimensionalTypeVariableArray");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertTrue(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(Integer[][][].class, typeInfo.getActualType());    assertEquals(Integer[][][].class, typeInfo.getRawClass());  }  public void testParameterizedTypeVariableField() throws Exception {    Type listType = new TypeToken<List<Integer>>() {}.getType();    Field f = obj.getClass().getField("listOfTypeVariables");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List.class, typeInfo.getRawClass());  }  public void testNestedParameterizedTypeVariableField() throws Exception {    Type listType = new TypeToken<List<List<Integer>>>() {}.getType();    Field f = obj.getClass().getField("listOfListsOfTypeVariables");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List.class, typeInfo.getRawClass());  }  public void testParameterizedTypeVariableArrayField() throws Exception {    Type listType = new TypeToken<List<Integer>[]>() {}.getType();    Field f = obj.getClass().getField("listOfTypeVariablesArray");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertTrue(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List[].class, typeInfo.getRawClass());  }  public void testWildcardField() throws Exception {    Type listType = new TypeToken<List<Object>>() {}.getType();    Field f = obj.getClass().getField("listWithWildcard");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List.class, typeInfo.getRawClass());  }  public void testArrayOfWildcardField() throws Exception {    Type listType = new TypeToken<List<Object>[]>() {}.getType();    Field f = obj.getClass().getField("arrayOfListWithWildcard");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertTrue(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List[].class, typeInfo.getRawClass());  }  public void testListStringWildcardField() throws Exception {    Type listType = new TypeToken<List<String>>() {}.getType();    Field f = obj.getClass().getField("listWithStringWildcard");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List.class, typeInfo.getRawClass());  }  public void testArrayOfListStringWildcardField() throws Exception {    Type listType = new TypeToken<List<String>[]>() {}.getType();    Field f = obj.getClass().getField("arrayOfListWithStringWildcard");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertTrue(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List[].class, typeInfo.getRawClass());  }  public void testListTypeVariableWildcardField() throws Exception {    Type listType = new TypeToken<List<Integer>>() {}.getType();    Field f = obj.getClass().getField("listWithTypeVariableWildcard");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List.class, typeInfo.getRawClass());  }  public void testArrayOfListTypeVariableWildcardField() throws Exception {    Type listType = new TypeToken<List<Integer>[]>() {}.getType();    Field f = obj.getClass().getField("arrayOfListWithTypeVariableWildcard");    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);    assertTrue(typeInfo.isArray());    assertFalse(typeInfo.isEnum());    assertEquals(listType, typeInfo.getActualType());    assertEquals(List[].class, typeInfo.getRawClass());  }  @SuppressWarnings("unused")  private static class ObjectWithDifferentFields<T> {    public static enum TestEnum {      TEST_1, TEST_2;    }    public String simpleField;    public TestEnum enumField;    public List<String> simpleParameterizedType;    public List<List<String>> simpleNestedParameterizedType;    public List<String>[] simpleGenericArray;    public T typeVariableObj;    public T[] typeVariableArray;    public T[][][] mutliDimensionalTypeVariableArray;    public List<T> listOfTypeVariables;    public List<List<T>> listOfListsOfTypeVariables;    public List<T>[] listOfTypeVariablesArray;    public List<?> listWithWildcard;    public List<?>[] arrayOfListWithWildcard;    public List<? extends String> listWithStringWildcard;    public List<? extends String>[] arrayOfListWithStringWildcard;    public List<? extends T> listWithTypeVariableWildcard;    public List<? extends T>[] arrayOfListWithTypeVariableWildcard;  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import java.math.BigDecimal;import java.math.BigInteger;import junit.framework.TestCase;/** * Unit test for the {@link JsonPrimitive} class. *  * @author Joel Leitch */public class JsonPrimitiveTest extends TestCase {  public void testBoolean() throws Exception {    JsonPrimitive json = new JsonPrimitive(Boolean.TRUE);        assertTrue(json.isBoolean());    assertTrue(json.getAsBoolean());  }    public void testParsingStringAsBoolean() throws Exception {    JsonPrimitive json = new JsonPrimitive("true");        assertFalse(json.isBoolean());    assertTrue(json.getAsBoolean());  }    public void testParsingStringAsNumber() throws Exception {    JsonPrimitive json = new JsonPrimitive("1");    assertFalse(json.isNumber());    assertEquals(1D, json.getAsDouble(), 0.00001);    assertEquals(1F, json.getAsFloat(), 0.00001);    assertEquals(1, json.getAsInt());    assertEquals(1L, json.getAsLong());    assertEquals((short) 1, json.getAsShort());    assertEquals((byte) 1, json.getAsByte());    assertEquals(new BigInteger("1"), json.getAsBigInteger());    assertEquals(new BigDecimal("1"), json.getAsBigDecimal());  }    public void testStringsAndChar() throws Exception {    JsonPrimitive json = new JsonPrimitive("abc");    assertTrue(json.isString());    assertEquals('a', json.getAsCharacter());    assertEquals("abc", json.getAsString());        json = new JsonPrimitive('z');    assertTrue(json.isString());    assertEquals('z', json.getAsCharacter());    assertEquals("z", json.getAsString());  }    public void testExponential() throws Exception {    JsonPrimitive json = new JsonPrimitive("1E+7");    assertEquals(new BigDecimal("1E+7"), json.getAsBigDecimal());    assertEquals(new Double("1E+7"), json.getAsDouble(), 0.00001);    assertEquals(new Float("1E+7"), json.getAsDouble(), 0.00001);        try {      json.getAsInt();      fail("Integers can not handle exponents like this.");    } catch (NumberFormatException expected) { }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import junit.framework.TestCase;import java.lang.reflect.Field;/** * Tests for the {@link JavaFieldNamingPolicy} class. * * @author Joel Leitch */public class JavaFieldNamingPolicyTest extends TestCase {  private JavaFieldNamingPolicy namingPolicy;  @Override  protected void setUp() throws Exception {    super.setUp();    namingPolicy = new JavaFieldNamingPolicy();  }  public void testFieldNamingPolicy() throws Exception {    Field f = String.class.getFields()[0];    assertEquals(f.getName(), namingPolicy.translateName(f));  }  public void testNullField() throws Exception {    try {      namingPolicy.translateName((Field) null);      fail("Should have thrown an exception");    } catch (IllegalArgumentException expected) { }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.DisjunctionExclusionStrategy;import com.google.gson.ExclusionStrategy;import junit.framework.TestCase;import java.lang.reflect.Field;import java.util.LinkedList;import java.util.List;/** * Unit tests for the {@link DisjunctionExclusionStrategy} class. * * @author Joel Leitch */public class DisjunctionExclusionStrategyTest extends TestCase {  private static final ExclusionStrategy FALSE_STRATEGY = new MockExclusionStrategy(false, false);  private static final ExclusionStrategy TRUE_STRATEGY = new MockExclusionStrategy(true, true);  private static final Class<?> CLAZZ = String.class;  private static final Field FIELD = CLAZZ.getFields()[0];  public void testBadInstantiation() throws Exception {    try {      List<ExclusionStrategy> constructorParam = null;      new DisjunctionExclusionStrategy(constructorParam);    } catch (IllegalArgumentException expected) { }  }  public void testSkipFieldsWithMixedTrueAndFalse() throws Exception {    List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();    strategies.add(FALSE_STRATEGY);    strategies.add(TRUE_STRATEGY);    DisjunctionExclusionStrategy strategy = new DisjunctionExclusionStrategy(strategies);    assertTrue(strategy.shouldSkipClass(CLAZZ));    assertTrue(strategy.shouldSkipField(FIELD));  }  public void testSkipFieldsWithFalseOnly() throws Exception {    List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();    strategies.add(FALSE_STRATEGY);    DisjunctionExclusionStrategy strategy =  new DisjunctionExclusionStrategy(strategies);    assertFalse(strategy.shouldSkipClass(CLAZZ));    assertFalse(strategy.shouldSkipField(FIELD));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.NullExclusionStrategy;import junit.framework.TestCase;/** * Unit test for the {@link NullExclusionStrategy} class. * * @author Joel Leitch */public class NullExclusionStrategyTest extends TestCase {  private NullExclusionStrategy strategy;  @Override  protected void setUp() throws Exception {    super.setUp();    strategy = new NullExclusionStrategy();  }  public void testNeverSkipsClass() throws Exception {    assertFalse(strategy.shouldSkipClass(String.class));  }  public void testNeverSkipsField() throws Exception {    assertFalse(strategy.shouldSkipField("".getClass().getFields()[0]));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;import junit.framework.TestCase;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/** * A simple unit test for the {@link DefaultDateTypeAdapter} class. * * @author Joel Leitch */public class DefaultDateTypeAdapterTest extends TestCase {  public void testDateSerialization() throws Exception {    int dateStyle = DateFormat.LONG;    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle);    DateFormat formatter = DateFormat.getDateInstance(dateStyle);    Date currentDate = new Date();    String dateString = dateTypeAdapter.serialize(currentDate, Date.class, null).getAsString();    assertEquals(formatter.format(currentDate), dateString);  }  public void testDatePattern() throws Exception {    String pattern = "yyyy-MM-dd";    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(pattern);    DateFormat formatter = new SimpleDateFormat(pattern);    Date currentDate = new Date();    String dateString = dateTypeAdapter.serialize(currentDate, Date.class, null).getAsString();    assertEquals(formatter.format(currentDate), dateString);  }  public void testInvalidDatePattern() throws Exception {    try {      new DefaultDateTypeAdapter("I am a bad Date pattern....");      fail("Invalid date pattern should fail.");    } catch (IllegalArgumentException expected) { }  }}